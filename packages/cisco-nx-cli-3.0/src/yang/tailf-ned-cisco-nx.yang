module tailf-ned-cisco-nx {
  namespace 'http://tail-f.com/ned/cisco-nx';
  prefix nx;

  import tailf-common {
    prefix tailf;
  }

  import ietf-inet-types {
    prefix inet;
  }

  include tailf-ned-cisco-nx-router;
  include tailf-ned-cisco-nx-router-ospf;


  revision 2013-09-24 {
    description
    "Added loopback interface definition";
  }
  revision 2013-09-10 {
    description
    "Added basic OSPF routing and interface HSRP";
  }

  revision 2013-07-29 {
    description
    "Extended YANG module to support Nexus 1k.";
  }
  revision 2013-06-27 {
    description
    "Renamed YANG module, submodule and namespace.";
  }


  typedef ipv4-prefix {
    type string {
      pattern
      '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}'
      +  '([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'
      + '/(([0-9])|([1-2][0-9])|(3[0-2]))';
    }
    description
    "The ipv4-prefix type represents an IPv4 address prefix.
    The prefix length is given by the number following the
    slash character and must be less than or equal to 32.

    A prefix length value of n corresponds to an IP address
    mask that has n contiguous 1-bits from the most
    significant bit (MSB) and all other bits set to 0.

    The canonical format of an IPv4 prefix has all bits of
    the IPv4 address set to zero that are not part of the
    IPv4 prefix.";
  }

  typedef ipv6-prefix {
    type string {
      pattern '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}'
      + '((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|'
      + '(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\.){3}'
      + '(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))'
      + '(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))';
      pattern '(([^:]+:){6}(([^:]+:[^:]+)|(.*\..*)))|'
      + '((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?)'
      + '(/.+)';
    }
    description
    "The ipv6-prefix type represents an IPv6 address prefix.
    The prefix length is given by the number following the
    slash character and must be less than or equal 128.

    A prefix length value of n corresponds to an IP address
    mask that has n contiguous 1-bits from the most
    significant bit (MSB) and all other bits set to 0.

    The IPv6 address should have all bits that do not belong
    to the prefix set to zero.

    The canonical format of an IPv6 prefix has all bits of
    the IPv6 address set to zero that are not part of the
    IPv6 prefix.  Furthermore, IPv6 address is represented
    in the compressed format described in RFC 4291, Section
    2.2, item 2 with the following additional rules: the ::
    substitution must be applied to the longest sequence of
    all-zero 16-bit chunks in an IPv6 address.  If there is
    a tie, the first sequence of all-zero 16-bit chunks is
    replaced by ::.  Single all-zero 16-bit chunks are not
    compressed.  The canonical format uses lowercase
    characters and leading zeros are not allowed.";
    reference
    "RFC 4291: IP Version 6 Addressing Architecture";
  }

  typedef spanning-tree-cost-type {
    type union {
      type uint32 {
        range "1..200000000";
        tailf:info "<1-200000000>;;Port path cost";
      }
      type enumeration {
        enum auto {
          tailf:code-name spanning-tree-cost-type-auto;
          tailf:info "Determine cost based on media speed of this "
          +"interface";
        }
      }
    }
  }

  typedef ip-mask {
    type string {
      pattern
      '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}'
      + '([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'
      + '/(([0-9])|([1-2][0-9])|(3[0-2]))';
    }
  }

  typedef mac-address-type {
    type union {
      type string {
        tailf:info "E.E.E;;Static Router MAC address (Option 1)";
        pattern "[0-9a-fA-F](\.[0-9a-fA-F]){2}";
      }
      type string {
        tailf:info "EE-EE-EE-EE-EE-EE;;Static Router MAC address "
        +"(Option 2)";
        pattern "[0-9a-fA-F]{2}(\-[0-9a-fA-F]{2}){5}";
      }
      type string {
        tailf:info "EE.EE.EE.EE.EE.EE;;Static Router MAC address "
        +"(Option 3)";
        pattern "[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}";
      }
      type string {
        tailf:info "EEEE.EEEE.EEEE;;Static Router MAC address "
        +"(Option 4)";
        pattern "[0-9a-fA-F]{4}(\.[0-9a-fA-F]{4}){2}";
      }
    }
  }

  typedef mac-address-type2 {
    type union {
      type string {
        tailf:info "E.E.E;;MAC address (Option 1)";
        pattern "[0-9a-fA-F](\.[0-9a-fA-F]){2}";
      }
      type string {
        tailf:info "EE-EE-EE-EE-EE-EE;;MAC address "
        +"(Option 2)";
        pattern "[0-9a-fA-F]{2}(\-[0-9a-fA-F]{2}){5}";
      }
      type string {
        tailf:info "EE.EE.EE.EE.EE.EE;;MAC address "
        +"(Option 3)";
        pattern "[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}";
      }
      type string {
        tailf:info "EEEE.EEEE.EEEE;;MAC address "
        +"(Option 4)";
        pattern "[0-9a-fA-F]{4}(\.[0-9a-fA-F]{4}){2}";
      }
    }
  }

  typedef mst-cost-type {
    type union {
      type uint32 {
        range "1..200000000";
        tailf:info "<1-200000000>;;Port path cost";
      }
      type enumeration {
        enum auto {
          tailf:code-name mst_cost_type_auto;
          tailf:info "Determine cost based on media speed of this "
          +"interface";
        }
      }
    }
  }

  typedef vlan-list-type {
    type uint16 {
      range "1..3967|4048..4093";
      tailf:info "<1-3967,4048-4093>  VLAN IDs of the allowed VLANs "
      +"when this port in trunking mode";
    }
  }

  typedef vrf-member-type {
    type union {
      type string {
        length "1..32";
        tailf:info "WORD;;VRF name (Max Size 32)";
      }
      type enumeration {
        enum management {
          tailf:info "(no abbrev) Configurable VRF name";
        }
      }
    }
  }

  grouping ethernet-settings-grouping {
    container bandwidth {
      tailf:info "Set bandwidth information parameter";
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-compact-syntax;
      leaf inherit {
        tailf:cli-optional-in-sequence;
        tailf:info "Specify that bandwith is inherited";
        type empty;
      }
      leaf bandwidth {
        tailf:cli-drop-node-name;
        type uint32 {
          range "1..10000000";
          tailf:info "<1-10000000>;;Bandwidth in kilobits";
        }
      }
    }

    leaf beacon {
      tailf:info "Disable/enable the beacon for an interface";
      tailf:cli-full-command;
      type empty;
    }

    leaf "description" {
      tailf:info "Enter description of maximum 80 characters";
      tailf:cli-full-command;
      tailf:cli-multi-value;
      type string {
        length "1..80";
      }
    }

    leaf cdp {
      tailf:info "Configure CDP interface parameters";
      tailf:cli-full-command;
      type enumeration {
        enum enable {
          tailf:code-name ethernet-settings-grouping_cdp_enable;
          tailf:info "Enable/disable CDP on the interface";
        }
      }
    }


    container channel-group {
      tailf:info "Configure port channel parameters";
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-compact-syntax;
      leaf id {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<1-4096>;;Spedify a port-channel number";
        }
      }
      leaf mode {
        tailf:info "Specify channeling mode";
        type enumeration {
          enum active {
            tailf:info "Set channeling mode to ACTIVE";
          }
          enum on {
            tailf:info "Set channeling mode to ON";
          }
          enum passive {
            tailf:code-name mode_passive;
            tailf:info "Set channeling mode to PASSIVE";
          }
        }
      }
    }

    leaf delay {
      tailf:info "Specify interface throughput delay";
      tailf:cli-full-command;
      type uint32 {
        range "1..16777215";
        tailf:info "<1-16777215>;;Throughput delay (tens of "
        +"microseconds)";
      }
    }

    leaf duplex {
      tailf:info "Enter the port duplex mode";
      tailf:cli-full-command;
      type enumeration {
        enum auto {
          tailf:code-name duplex_auto;
          tailf:info "Auto";
        }
        enum full {
          tailf:info "Full";
        }
        enum half {
          tailf:info "Half";
        }
      }
    }

    container fex {
      tailf:info "Configure FEX fabric";
      leaf associate {
        tailf:info "Associate the port to a FEX";
        type uint8 {
          tailf:info "<100-199>;;FEX number";
          range "100..199";
        }
      }
    }

    container flowcontrol {
      tailf:info "Configure interface flowcontrol";
      leaf receive {
        tailf:info "Receive pause frames";
        tailf:cli-full-command;
        type enumeration {
          enum off {
            tailf:code-name flowcontrol_off;
            tailf:info "Receive OFF";
          }
          enum on {
            tailf:code-name flowcontrol_on;
            tailf:info "Receive ON";
          }
        }
      }
      leaf send {
        tailf:info "Send pause frames";
        tailf:cli-full-command;
        type enumeration {
          enum off {
            tailf:code-name send_off;
            tailf:info "Send OFF";
          }
          enum on {
            tailf:code-name send_on;
            tailf:info "Send ON";
          }
        }
      }
    }

    container inherit {
      tailf:info "Inherit a port-profile";
      leaf port-profile {
        tailf:info "Inherit a port-profile";

        type string {
          tailf:info "WORD;;Enter the name of the profile";
        }
      }
    }

    container ip {
      tailf:info "Configure IP features";
      container port {
        tailf:info "Port policy";
        container access-group {
          tailf:info "Specify access control for packets";
          tailf:cli-sequence-commands;
          tailf:cli-compact-syntax;
          leaf name {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type string {
              length "1..64";
              tailf:info "WORD;;List name (Max Size 64)";
            }
          }
          leaf inout {
            tailf:cli-drop-node-name;
            type enumeration {
              enum in {
                tailf:info "Inbound packets";
              }
              enum out {
                tailf:info "Outbound packets";
              }
            }
          }
        }
      }
    }

    container ipv6 {
      tailf:info "Configure IPv6 features";
      container port {
        tailf:info "Port policy";
        container traffic-filter {
          tailf:info "Specify access control for packets";
          tailf:cli-sequence-commands;
          tailf:cli-compact-syntax;
          leaf name {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type string {
              length "1..64";
              tailf:info "WORD;;List name (Max Size 64)";
            }
          }
          leaf inout {
            tailf:cli-drop-node-name;
            type enumeration {
              enum in {
                tailf:info "Inbound packets";
              }
            }
          }
        }
      }
    }

    container link {
      tailf:info "Configure link";
      container debounce {
        tailf:info "Configure link debounce timer";
        presence "Configure link debounce timer";
        leaf time {
          tailf:info "Link debounce time";
          type uint16 {
            range "0..5000";
            tailf:info "<0-5000>;;Timer value (in "
            +"milliseconds)";
          }
        }
      }
    }

    leaf lldp {
      tailf:info "Configure Interface LLDP parameters";
      tailf:cli-full-command;
      type enumeration {
        enum receive {
          tailf:code-name lldp_receive;
          tailf:info "Enable LLDP reception on interface";
        }
        enum transmit {
          tailf:info "Enable LLDP transmission on interface";
        }
      }
    }

    container load-interval {
      tailf:info "Specify interval for load calculation for an "
      +"interface";
      leaf interval {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        type uint16 {
          range "30..300";
          tailf:info "<30-300>;;Load interval delay in seconds";
        }
      }
      list counter {
        tailf:info "Specify counter for this load interval";
        tailf:cli-incomplete-command;
        tailf:cli-suppress-mode;
        key "id";
        leaf id {
          type uint8 {
            range "1..3";
            tailf:info "<1-3>;;Specify counter for this load "
            +"interval";
          }
        }
        leaf interval {
          tailf:cli-drop-node-name;
          type uint16 {
            range "30..300";
            tailf:info "<30-300>;;Load interval delay in "
            +"seconds";
          }
        }
      }
    }

    container logging {
      tailf:info "Configure logging for interface";
      container event {
        tailf:info "Interface events";
        container port {
          tailf:info "Port level events";
          container linkstatus {
            tailf:alt-name "link-status";
            tailf:info "UPDOWN and CHANGE messages";
            presence "UPDOWN and CHANGE messages";
            leaf "default" {
              tailf:info "Use the global default value";
              type empty;
            }
          }
          container trunk-status {
            tailf:info "TRUNK status messages";
            presence "TRUNK status messages";
            leaf "default" {
              tailf:info "Use the global default value";
              type empty;
            }
          }
        }
      }
    }

    container mac {
      tailf:info "MAC configuration commands";
      container port {
        tailf:info "Port policy";
        leaf access-group {
          tailf:info "Specify access control for packets";
          type string {
            length "1..64";
            tailf:info "WORD;;List name (Max Size 64)";
          }
        }
      }
    }

    leaf mac-address {
      tailf:info "Configure interface mac address";
      tailf:cli-full-command;
      type mac-address-type;
    }

    container priority-flow-control {
      tailf:info "Enable/Disable PFC";
      leaf mode {
        tailf:info "PFC Mode";
        type enumeration {
          enum auto {
            tailf:code-name prio_flow_control_auto;
            tailf:info "Set Auto Mode";
          }
          enum off {
            tailf:code-name prio_flow_off;
            tailf:info "Force PFC to Off";
          }
          enum on {
            tailf:code-name prio_flow_on;
            tailf:info "Force PFC to Of";
          }
        }
      }
    }

    container service-policy {
      tailf:info "Configure service policy for an interface";
      tailf:cli-sequence-commands;
      tailf:cli-compact-syntax;
      leaf type {
        tailf:cli-optional-in-sequence;
        tailf:cli-incomplete-command;
        type enumeration {
          enum qos {
            tailf:code-name service_policy_qos;
            tailf:info "Qos policy";
          }
          enum network-qos {
            tailf:code-name service_policy_network_qos;
            tailf:info "Network Qos policy";
          }
          enum queuing {
            tailf:code-name service_policy_queuing;
            tailf:info "Queuing policy";
          }
        }
        default "qos";
      }
      container input {
        when "../type = 'qos' or ../type = 'queueing'" {
          tailf:dependency "../type";
        }
        tailf:info "Input Service Policy";
        tailf:cli-break-sequence-commands;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        leaf name {
          tailf:cli-drop-node-name;
          // FIXME:: should be leaf-ref to policy-map?
          type string {
            tailf:info "Policy-map name (alphanumeric) "
            +"(Max Size 40)";
          }
        }
        leaf no-stats {
          tailf:info "Disable statistics for this policy";
          type empty;
        }
      }
      container output {
        when "../type = 'qos'";
        tailf:info "Output Service Policy";
        tailf:cli-break-sequence-commands;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        leaf name {
          tailf:cli-drop-node-name;
          // FIXME:: should be leaf-ref to policy-map?
          type string {
            tailf:info "Policy-map name (alphanumeric) "
            +"(Max Size 40)";
          }
        }
        leaf no-stats {
          tailf:info "Disable statistics for this policy";
          type empty;
        }
      }
      leaf name {
        when "../type = 'network-qos'";
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        // FIXME:: should be leaf-ref to policy-map?
        type string {
          tailf:info "Policy-map name (alphanumeric) "
          +"(Max Size 40)";
        }
      }
    }

    container snmp {
      tailf:info "Modify SNMP interface parameters";
      leaf trap {
        tailf:info "Allow a specific SNMP trap";
        type enumeration {
          enum link-status {
            tailf:info "Allow SNMP LINKUP and LINKDOWN traps";
          }
        }
      }
    }

    container spanning-tree {
      tailf:info "Spanning Tre Subsystem";

      leaf bpdufilter {
        tailf:info "Don't send or receive BPDUs on this interface";
        tailf:cli-full-command;
        type enumeration {
          enum disable {
            tailf:code-name bdufilter_disable;
            tailf:info "Disable BPDU filtering for this "
            +"interface";
          }
          enum enable {
            tailf:code-name bdufilter_enable;
            tailf:info "Enable BPDU filtering for this "
            +"interface";
          }
        }
      }
      leaf bpduguard {
        tailf:info "Don't accept BPDUs on this interface";
        tailf:cli-full-command;
        type enumeration {
          enum disable {
            tailf:code-name bduguard_disable;
            tailf:info "Disable BPDU Guard for this interface";
          }
          enum enable {
            tailf:code-name bduguard_enable;
            tailf:info "Enable BPDU Guard for this interface";
          }
        }
      }
      leaf cost {
        tailf:info "Change an interface's spanning tree port path "
        +"cost";
        // <1-2000000000> | auto
        type spanning-tree-cost-type;
      }
      leaf guard {
        tailf:info "Change an interface's spanning tree guard mode";
        tailf:cli-full-command;
        type enumeration {
          enum loop {
            tailf:info "Set guard mode to loop guard on "
            +"interface";
          }
          enum none {
            tailf:info "Set guard mode to none";
          }
          enum root {
            tailf:info "Set guard mode to root guard on "
            +"interface";
          }
        }
      }
      leaf link-type {
        tailf:info "Specify a link type for spanning tree tree "
        +"protocol use";
        tailf:cli-full-command;
        type enumeration {
          enum auto {
            tailf:code-name link_type_auto;
            tailf:info "Determine link type based on media "
            +"duplex of this interface";
          }
          enum none {
            tailf:info "Consider the interface as point-to-"
            +"point";
          }
          enum root {
            tailf:info "Consider the interface as shared";
          }

        }
      }
      container mst {
        tailf:info "Multiple spanning tree configuration";
        // FIXME: fix range problem, check cost/port-priority
        // for example
        // spanning-tree mst 2,4 port-priority 0
        // spanning-tree mst 1,3 cost 10
        // spanning-tree mst 2 cost 100
        //
        // then doing
        // spanning-tree mst 2 cost 10
        //
        // spanning-tree mst 2,4 port-priority 0
        // spanning-tree mst 1-3 cost 10
        //
        // doing
        // spanning-tree mst 2 cost 100
        //
        // spanning-tree mst 2,4 port-priority 0
        // spanning-tree mst 1,3 cost 10
        // spanning-tree mst 2 cost 100
        //
        // doing
        // spanning-tree mst 1 port-priority 0
        // spanning-tree mst 3 port-priority 0
        // spanning-tree mst 2 port-priority 32
        //
        // spanning-tree mst 1,3-4 port-priority 0
        // spanning-tree mst 2 port-priority 32
        // spanning-tree mst 1,3 cost 10
        // spanning-tree mst 2 cost 100
        //
        // no spanning-tree mst 1 cost
        // no spanning-tree mst 1 port-priority
        list port {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          tailf:cli-suppress-mode;
          key "range";

          leaf range {
            type string {
              pattern "\d+(\-\d+)?(,\d+(\-\d+)?)*";
              tailf:info "<0-4094>;;MST instance list, "
              +"example 0,2-4,6,8-12";
            }
          }
          leaf cost {
            tailf:cli-full-command;
            tailf:info "Change an interface's spanning tree "
            +"port path cost";
            type mst-cost-type;
          }
          leaf port-priority {
            tailf:cli-full-command;
            tailf:info "Change an interface's spanning tree "
            +"port priority";
            type uint8 {
              range "0..240";
              tailf:info "<0-240>;;Port priority in "
              +"increments of 32";
            }
          }
        }
        leaf pre-standard {
          tailf:cli-full-command;
          tailf:info "Force pre-standard MST BPDU transmission "
          +"on port";
          type empty;
        }
        container simulate {
          tailf:info "Enable spanning tree simulation";
          container pvst {
            tailf:info "Enable PVST simulation";
            presence "Enable PVST simulation";
            leaf disable {
              tailf:info "Disable PVST simulation on this "
              +"interface";
              type empty;
            }
          }
        }
      }

      container port {
        tailf:info "Spanning tree port options";
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        leaf "type" {
          tailf:info "Specify a port type for spanning tree "
          +"protocol use";
          type enumeration {
            enum edge {
              tailf:info "Consider the interface as edge "
              +"port (enable portfast)";
            }
            enum network {
              tailf:info "Consider the interface as inter-"
              +"switch link";
            }
            enum normal {
              tailf:info "Consider the interface as normal "
              +"spanning tree port";
            }
          }
        }
        leaf trunk {
          when "../type != 'normal'";
          tailf:info "Consider the interface as edge port "
          +"(enable portfast) even in trunk mode";
          type empty;
        }
      }
      leaf port-priority {
        tailf:info "Change an interface's spanning tree port "
        +"priority";
        type uint8 {
          range "0|32|64|96|128|160|192|224";
          tailf:info "<0-224>;;Port priority in increments of 32";
        }
      }
    }

    leaf speed {
      tailf:info "Enter the port speed";
      tailf:cli-full-command;
      type enumeration {
        enum "10" {
          tailf:info "10Mb/s";
        }
        enum "100" {
          tailf:code-name speed_100;
          tailf:info "100Mb/s";
        }
        enum "1000" {
          tailf:info "1Gb/s";
        }
        enum "auto" {
          tailf:code-name ethernet-settings-grouping_auto;
          tailf:info "Auto negotiate speed";
        }
      }
    }

    container storm-control {
      tailf:info "Configure Interface storm control";

      container broadcast {
        tailf:info "Broadcast";
        presence "Broadcast";
        leaf level {
          type decimal64 {
            fraction-digits "2";
            range "0..100";
            tailf:info "<0-100>;;Percentage";
          }
          default "100";
        }
      }
      container unicast {
        tailf:info "Unicast";
        presence "Unicast";
        leaf level {
          type decimal64 {
            fraction-digits "2";
            range "0..100";
            tailf:info "<0-100>;;Percentage";
          }
          default "100";
        }
      }
      container multicast {
        tailf:info "Multicast";
        presence "Multicast";
        leaf level {
          type decimal64 {
            fraction-digits "2";
            range "0..100";
            tailf:info "<0-100>;;Percentage";
          }
          default "100";
        }
      }
    }

    container untagged {
      tailf:info "Default to use for untagged packets on interface";
      leaf cos {
        tailf:info "IEEE 802.1Q class of service for QoS "
        +"classification";
        type uint8 {
          range "0..7";
          tailf:info "<0-7>;;COS value";
        }
      }
    }

    container switchport {
      tailf:cli-delete-when-empty;
      tailf:info "Configure switchport parameters";
      presence "Configure switchport parameters";

      container access {
        tailf:info "Set access mode characteristics of the "
        +"interface";
        leaf vlan {
          tailf:info "Set VLAN when interface is in access mode";
          type uint16 {
            range "1..3967|4048..4093";
            tailf:info "<1-3967,4048-4093>;;VLAN ID of the "
            +"VLAN when this port is in access mode";
          }
        }
      }
      leaf block {
        tailf:info "Block specified outbound traffic for all VLANs";
        tailf:cli-full-command;
        type enumeration {
          enum multicast {
            tailf:code-name block_multicast;
            tailf:info "Block mulitcast traffic";
          }
          enum unicast {
            tailf:code-name block_unicast;
            tailf:info "Block unknown unicast traffic";
          }
        }
      }
      leaf description {
        tailf:info "Enter description of maximum 80 characters";
        tailf:cli-full-command;
        tailf:cli-multi-value;
        type string {
          length "1..80";
        }
      }
      leaf host {
        tailf:info "Set port host";
        type empty;
      }

      leaf mode {
        tailf:info "Enter the port mode";
        tailf:cli-full-command;
        type enumeration {
          enum access {
            tailf:code-name mode_access;
            tailf:info "Port mode access";
          }
          enum fex-fabric {
            tailf:info "Port mode FEX fabric";
          }
          enum trunk {
            tailf:code-name mode_trunk;
            tailf:info "Port mode trunk";
          }
        }
      }
      leaf monitor {
        tailf:info "Configures an interface as span-destination";
        tailf:cli-full-command;
        type empty;
      }
      container trunk {
        tailf:info "Set trunking characteristics of the interface";
        container allowed {
          tailf:info "Set allowed VLAN characteristics when "
          +"interface is in trunking mode";
          // to suppor the add,remove custom CLI command
          // should be used.
          container vlan {
            tailf:info "Set allowed VLANs when interface is "
            +"in trunking mode";
            choice vlan-choice {
              leaf-list ids {
                tailf:cli-drop-node-name;
                tailf:cli-range-list-syntax;
                type vlan-list-type;
              }
              leaf fixed {
                tailf:cli-drop-node-name;
                type enumeration {
                  enum all {
                    tailf:info "All VLANs";
                  }
                  enum none {
                    tailf:info "No VLANs";
                  }
                }
              }
              leaf-list except {
                tailf:cli-range-list-syntax;
                tailf:info " VLAN IDs of the allowed VLANs "
                +"when this port in trunking mode";
                type vlan-list-type;
              }
            }
          }
        }
        container native {
          tailf:info "Set trunking native characteristics when "
          +"interface is in trunking mode";
          leaf vlan {
            tailf:info "Set native VLAN when interface is in "
            +"trunking mode";
            type uint16 {
              range "1..3967|4048..4093";
              tailf:info "<1-3967,4048-4093>;;VLAN ID of the "
              +"native VLAN when this port is in "
              +"trunking mode";
            }
          }
        }
      }
    }
    leaf shutdown {
      tailf:info "Enable/disable an interface";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
      default "true";
    }

    container vmware {
      container dvport {
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }

        leaf port {
          tailf:cli-drop-node-name;
          type uint32;
        }
        leaf dvswitch {
          type empty;
        }
        leaf uuid {
          type string;
        }
      }
      container vm {
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf mac {
          type string;
        }
      }
    }
  }

  grouping port-channel-settings-grouping {
    container bandwidth {
      tailf:info "Set bandwidth information parameter";
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-compact-syntax;
      leaf inherit {
        tailf:cli-optional-in-sequence;
        tailf:info "Specify that bandwith is inherited";
        type empty;
      }
      leaf bandwidth {
        tailf:cli-drop-node-name;
        type uint32 {
          range "1..10000000";
          tailf:info "<1-10000000>;;Bandwidth in kilobits";
        }
      }
    }

    leaf delay {
      tailf:info "Specify interface throughput delay";
      tailf:cli-full-command;
      type uint32 {
        range "1..16777215";
        tailf:info "<1-16777215>;;Throughput delay (tens of "
        +"microseconds)";
      }
    }

    leaf "description" {
      tailf:info "Enter description of maximum 80 characters";
      tailf:cli-full-command;
      tailf:cli-multi-value;
      type string {
        length "1..80";
      }
    }

    leaf duplex {
      tailf:info "Enter the port duplex mode";
      tailf:cli-full-command;
      type enumeration {
        enum auto {
          tailf:code-name  port-channel-settings-grouping-duplex_auto;
          tailf:info "Auto";
        }
        enum full {
          tailf:info "Full";
        }
        enum half {
          tailf:info "Half";
        }
      }
    }

    container fex {
      tailf:info "Configure FEX fabric";
      leaf associate {
        tailf:info "Associate the port to a FEX";
        type uint8 {
          tailf:info "<100-199>;;FEX number";
          range "100..199";
        }
      }
    }

    container flowcontrol {
      tailf:info "Configure interface flowcontrol";
      leaf receive {
        tailf:info "Receive pause frames";
        tailf:cli-full-command;
        type enumeration {
          enum off {
            tailf:code-name flowcontrol_receive_off;
            tailf:info "Receive OFF";
          }
          enum on {
            tailf:code-name flowcontrol_receive_on;
            tailf:info "Receive ON";
          }
        }
      }
      leaf send {
        tailf:info "Send pause frames";
        tailf:cli-full-command;
        type enumeration {
          enum off {
            tailf:code-name flowcontrol_send_off;
            tailf:info "Send OFF";
          }
          enum on {
            tailf:code-name flowcontrol_send_on;
            tailf:info "Send ON";
          }
        }
      }
    }

    container hardware {
      tailf:info "Hardware specific configuration";
      leaf multicast {
        tailf:info "Multicast traffic configuration";
        type enumeration {
          enum hw-hash {
            tailf:info "Use hardware hashing for multicast traffic "
            +"(default is software selection)";
          }
        }
      }
    }

    container inherit {
      tailf:info "Inherit a port-profile";
      leaf port-profile {
        tailf:info "Inherit a port-profile";

        type string {
          tailf:info "WORD;;Enter the name of the profile";
        }
      }
    }

    container ip {
      tailf:info "Configure IP features";
      container port {
        tailf:info "Port policy";
        container access-group {
          tailf:info "Specify access control for packets";
          tailf:cli-sequence-commands;
          tailf:cli-compact-syntax;
          leaf name {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type string {
              length "1..64";
              tailf:info "WORD;;List name (Max Size 64)";
            }
          }
          leaf inout {
            tailf:cli-drop-node-name;
            type enumeration {
              enum in {
                tailf:info "Inbound packets";
              }
              enum out {
                tailf:info "Outbound packets";
              }
            }
          }
        }
      }
    }

    container ipv6 {
      tailf:info "Configure IPv6 features";
      container port {
        tailf:info "Port policy";
        container traffic-filter {
          tailf:info "Specify access control for packets";
          tailf:cli-sequence-commands;
          tailf:cli-compact-syntax;
          leaf name {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type string {
              length "1..64";
              tailf:info "WORD;;List name (Max Size 64)";
            }
          }
          leaf inout {
            tailf:cli-drop-node-name;
            type enumeration {
              enum in {
                tailf:info "Inbound packets";
              }
            }
          }
        }
      }
    }

    leaf lacp {
      tailf:info "Set LACP parameters for the interface";
      tailf:cli-full-command;
      type enumeration {
        enum graceful-convergence {
          tailf:info "Configure port-channel lacp graceful "
          +"convergence. Disable this only with lacp ports "
          +"connected to Non-Nexus peer. Disabling this with "
          +"Nexus peer can lead to port suspension";
        }
        enum suspend-individual {
          tailf:info "Configure lacp port-channel state. Enabling "
          +"this will cause lacp to put the port to suspend "
          +"instead of individual state in case it does not get "
          +"LACP BPDU from the peer ports in the port-channel";
        }
      }
      default "graceful-convergence";
    }

    leaf link-state-trap {
      tailf:info "Enable/disable link state change traps";
      tailf:cli-full-command;
      type empty;
    }

    container load-interval {
      tailf:info "Specify interval for load calculation for an "
      +"interface";
      leaf interval {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        type uint16 {
          range "30..300";
          tailf:info "<30-300>;;Load interval delay in seconds";
        }
      }
      list counter {
        tailf:info "Specify counter for this load interval";
        tailf:cli-incomplete-command;
        tailf:cli-suppress-mode;
        key "id";
        leaf id {
          type uint8 {
            range "1..3";
            tailf:info "<1-3>;;Specify counter for this load "
            +"interval";
          }
        }
        leaf interval {
          tailf:cli-drop-node-name;
          type uint16 {
            range "30..300";
            tailf:info "<30-300>;;Load interval delay in "
            +"seconds";
          }
        }
      }
    }

    container logging {
      tailf:info "Configure logging for interface";
      container event {
        tailf:info "Interface events";
        container port {
          tailf:info "Port level events";
          container linkstatus {
            tailf:alt-name "link-status";
            tailf:info "UPDOWN and CHANGE messages";
            presence "UPDOWN and CHANGE messages";
            leaf "default" {
              tailf:info "Use the global default value";
              type empty;
            }
          }
          container trunk-status {
            tailf:info "TRUNK status messages";
            presence "TRUNK status messages";
            leaf "default" {
              tailf:info "Use the global default value";
              type empty;
            }
          }
        }
      }
    }

    container mac {
      tailf:info "MAC configuration commands";
      container port {
        tailf:info "Port policy";
        leaf access-group {
          tailf:info "Specify access control for packets";
          type string {
            length "1..64";
            tailf:info "WORD;;List name (Max Size 64)";
          }
        }
      }
    }

    leaf mac-address {
      tailf:info "Configure interface mac address";
      tailf:cli-full-command;
      type mac-address-type;
    }

    leaf medium {
      tailf:info "Configure interface medium mode";
      tailf:cli-full-command;
      type enumeration {
        enum broadcast {
          tailf:code-name medium_broadcast;
          tailf:info "Broadcast medium";
        }
        enum p2p {
          tailf:info "Point-to-Point medium";
        }
      }
    }

    container priority-flow-control {
      tailf:info "Enable/Disable PFC";
      leaf mode {
        tailf:info "PFC Mode";
        type enumeration {
          enum auto {
            tailf:code-name
            port-channel-settings-grouping_prio_flow_control_auto;
            tailf:info "Set Auto Mode";
          }
          enum off {
            tailf:code-name flowcontrol_mode_off;
            tailf:info "Force PFC to Off";
          }
          enum on {
            tailf:code-name flowcontrol_mode_on;
            tailf:info "Force PFC to Of";
          }
        }
      }
    }

    // FIXME: validate towards Nexus 5000
    container service-policy {
      tailf:info "Configure service policy for an interface";
      container input-map {
        tailf:cli-drop-node-name;
        tailf:cli-sequence-commands;
        tailf:cli-compact-syntax;
        leaf type {
          tailf:cli-optional-in-sequence;
          tailf:cli-incomplete-command;
          type enumeration {
            enum qos {
              tailf:code-name input_map_qos;
              tailf:info "Qos policy";
            }
            enum network-qos {
              tailf:code-name input_map_network_qos;
              tailf:info "Network Qos policy";
            }
            enum queuing {
              tailf:code-name input_map_queuing;
              tailf:info "Queuing policy";
            }
          }
          default "qos";
        }
        leaf input {
          when "../type = 'qos' or ../type = 'queueing'" {
            tailf:dependency "../type";
          }
          tailf:info "Input Service Policy";
          type string {
            tailf:info "Policy-map name (alphanumeric) "
            +"(Max Size 40)";
          }
        }
        leaf no-stats {
          when "../type = 'qos'";
          tailf:info "Disable statistics for this policy";
          type empty;
        }
        leaf name {
          when "../type = 'network-qos'";
          tailf:cli-drop-node-name;
          tailf:cli-full-command;
          // FIXME:: should be leaf-ref to policy-map?
          type string {
            tailf:info "Policy-map name (alphanumeric) "
            +"(Max Size 40)";
          }
        }
      }
      container output-map {
        tailf:cli-drop-node-name;
        tailf:cli-sequence-commands;
        tailf:cli-compact-syntax;
        leaf type {
          tailf:cli-optional-in-sequence;
          tailf:cli-incomplete-command;
          type enumeration {
            enum qos {
              tailf:code-name output_map_qos;
              tailf:info "Qos policy";
            }
            enum network-qos {
              tailf:code-name output_map_network_qos;
              tailf:info "Network Qos policy";
            }
            enum queuing {
              tailf:code-name output_map_queuing;
              tailf:info "Queuing policy";
            }
          }
          default "qos";
        }
        leaf output {
          when "../type = 'qos'";
          tailf:info "Output Service Policy";
          // FIXME:: should be leaf-ref to policy-map?
          type string {
            tailf:info "Policy-map name (alphanumeric) "
            +"(Max Size 40)";
          }
        }
        leaf no-stats {
          when "../type = 'qos'";
          tailf:info "Disable statistics for this policy";
          type empty;
        }
        leaf name {
          when "../type = 'network-qos'";
          tailf:cli-drop-node-name;
          tailf:cli-full-command;
          // FIXME:: should be leaf-ref to policy-map?
          type string {
            tailf:info "Policy-map name (alphanumeric) "
            +"(Max Size 40)";
          }
        }
      }
    }

    leaf shutdown {
      tailf:info "Enable/disable an interface";
      tailf:cli-boolean-no;
      type boolean;
      default "true";
    }

    container spanning-tree {
      tailf:info "Spanning Tre Subsystem";

      leaf bpdufilter {
        tailf:info "Don't send or receive BPDUs on this interface";
        tailf:cli-full-command;
        type enumeration {
          enum disable {
            tailf:code-name spanning-tree-bdufilter_disable;
            tailf:info "Disable BPDU filtering for this "
            +"interface";
          }
          enum enable {
            tailf:code-name spanning-tree-bdufilter_enable;
            tailf:info "Enable BPDU filtering for this "
            +"interface";
          }
        }
      }
      leaf bpduguard {
        tailf:info "Don't accept BPDUs on this interface";
        tailf:cli-full-command;
        type enumeration {
          enum disable {
            tailf:code-name spanning-tree-bduguard_disable;
            tailf:info "Disable BPDU Guard for this interface";
          }
          enum enable {
            tailf:code-name spanning-tree-bduguard_enable;
            tailf:info "Enable BPDU Guard for this interface";
          }
        }
      }
      leaf cost {
        tailf:info "Change an interface's spanning tree port path "
        +"cost";
        // <1-2000000000> | auto
        type spanning-tree-cost-type;
      }
      leaf guard {
        tailf:info "Change an interface's spanning tree guard mode";
        tailf:cli-full-command;
        type enumeration {
          enum loop {
            tailf:info "Set guard mode to loop guard on "
            +"interface";
          }
          enum none {
            tailf:info "Set guard mode to none";
          }
          enum root {
            tailf:info "Set guard mode to root guard on "
            +"interface";
          }
        }
      }
      leaf link-type {
        tailf:info "Specify a link type for spanning tree tree "
        +"protocol use";
        tailf:cli-full-command;
        type enumeration {
          enum auto {
            tailf:code-name link_type_auto;
            tailf:info "Determine link type based on media "
            +"duplex of this interface";
          }
          enum none {
            tailf:info "Consider the interface as point-to-"
            +"point";
          }
          enum root {
            tailf:info "Consider the interface as shared";
          }

        }
      }
      container mst {
        tailf:info "Multiple spanning tree configuration";
        // FIXME: fixe range problem, check cost/port-priority
        list port {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          tailf:cli-suppress-mode;
          key "range";

          leaf range {
            type string {
              pattern "\d+(\-\d+)?(,\d+(\-\d+)?)*";
              tailf:info "<0-4094>;;MST instance list, "
              +"example 0,2-4,6,8-12";
            }
          }
          leaf cost {
            tailf:cli-full-command;
            tailf:info "Change an interface's spanning tree "
            +"port path cost";
            type mst-cost-type;
          }
          leaf port-priority {
            tailf:cli-full-command;
            tailf:info "Change an interface's spanning tree "
            +"port priority";
            type uint8 {
              range "0..240";
              tailf:info "<0-240>;;Port priority in "
              +"increments of 32";
            }
          }
        }
        leaf pre-standard {
          tailf:cli-full-command;
          tailf:info "Force pre-standard MST BPDU transmission "
          +"on port";
          type empty;
        }
        container simulate {
          tailf:info "Enable spanning tree simulation";
          container pvst {
            tailf:info "Enable PVST simulation";
            presence "Enable PVST simulation";
            leaf disable {
              tailf:info "Disable PVST simulation on this "
              +"interface";
              type empty;
            }
          }
        }
      }

      container port {
        tailf:info "Spanning tree port options";
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        leaf "type" {
          tailf:info "Specify a port type for spanning tree "
          +"protocol use";
          type enumeration {
            enum edge {
              tailf:info "Consider the interface as edge "
              +"port (enable portfast)";
            }
            enum network {
              tailf:info "Consider the interface as inter-"
              +"switch link";
            }
            enum normal {
              tailf:info "Consider the interface as normal "
              +"spanning tree port";
            }
          }
        }
        leaf trunk {
          when "../type != 'normal'";
          tailf:info "Consider the interface as edge port "
          +"(enable portfast) even in trunk mode";
          type empty;
        }
      }
      leaf port-priority {
        tailf:info "Change an interface's spanning tree port "
        +"priority";
        type uint8 {
          range "0|32|64|96|128|160|192|224";
          tailf:info "<0-224>;;Port priority in increments of 32";
        }
      }
    }

    leaf speed {
      tailf:info "Enter the port speed";
      tailf:cli-full-command;
      type enumeration {
        enum "100" {
          tailf:code-name  port_cahnnels-settings_grouping_speed_100;
          tailf:info "100Mb/s";
        }
        enum "1000" {
          tailf:code-name  port_cahnnels-settings_grouping_speed_1000;
          tailf:info "1Gb/s";
        }
        enum "10000" {
          tailf:info "10Gb/s";
        }
        enum "auto" {
          tailf:code-name  port_cahnnels-settings_grouping_auto;
          tailf:info "Auto";
        }
      }
    }
    container storm-control {
      tailf:info "Configure Interface storm control";

      container broadcast {
        tailf:info "Broadcast";
        presence "Broadcast";
        leaf level {
          type decimal64 {
            fraction-digits "2";
            range "0..100";
            tailf:info "<0-100>;;Percentage";
          }
          default "100";
        }
      }
      container unicast {
        tailf:info "Unicast";
        presence "Unicast";
        leaf level {
          type decimal64 {
            fraction-digits "2";
            range "0..100";
            tailf:info "<0-100>;;Percentage";
          }
          default "100";
        }
      }
      container multicast {
        tailf:info "Multicast";
        presence "Multicast";
        leaf level {
          type decimal64 {
            fraction-digits "2";
            range "0..100";
            tailf:info "<0-100>;;Percentage";
          }
          default "100";
        }
      }
    }
    container switchport {
      tailf:info "Configure switchport parameters";
      presence "Configure switchport parameters";

      container access {
        tailf:info "Set access mode characteristics of the "
        +"interface";
        leaf vlan {
          tailf:info "Set VLAN when interface is in access mode";
          type uint16 {
            range "1..3967|4048..4093";
            tailf:info "<1-3967,4048-4093>;;VLAN ID of the "
            +"VLAN when this port is in access mode";
          }
        }
      }
      leaf block {
        tailf:info "Block specified outbound traffic for all VLANs";
        tailf:cli-full-command;
        type enumeration {
          enum multicast {
            tailf:code-name switchport_block_multicast;
            tailf:info "Block mulitcast traffic";
          }
          enum unicast {
            tailf:code-name switchport_block_unicast;
            tailf:info "Block unknown unicast traffic";
          }
        }
      }
      leaf description {
        tailf:info "Enter description of maximum 80 characters";
        tailf:cli-full-command;
        tailf:cli-multi-value;
        type string {
          length "1..80";
        }
      }
      leaf host {
        tailf:info "Set port host";
        type empty;
      }

      leaf mode {
        tailf:info "Enter the port mode";
        tailf:cli-full-command;
        type enumeration {
          enum access {
            tailf:code-name switchport_mode_access;
            tailf:info "Port mode access";
          }
          enum fex-fabric {
            tailf:info "Port mode FEX fabric";
          }
          enum trunk {
            tailf:code-name switchport_mode_trunk;
            tailf:info "Port mode trunk";
          }
        }
      }
      leaf monitor {
        tailf:info "Configures an interface as span-destination";
        tailf:cli-full-command;
        type empty;
      }
      container trunk {
        tailf:info "Set trunking characteristics of the interface";
        container allowed {
          tailf:info "Set allowed VLAN characteristics when "
          +"interface is in trunking mode";
          // to suppor the add,remove custom CLI command
          // should be used.
          container vlan {
            tailf:info "Set allowed VLANs when interface is "
            +"in trunking mode";
            choice vlan-choice {
              leaf-list ids {
                tailf:cli-drop-node-name;
                tailf:cli-range-list-syntax;
                type vlan-list-type;
              }
              leaf fixed {
                tailf:cli-drop-node-name;
                type enumeration {
                  enum all {
                    tailf:info "All VLANs";
                  }
                  enum none {
                    tailf:info "No VLANs";
                  }
                }
              }
              leaf-list except {
                tailf:cli-range-list-syntax;
                tailf:info " VLAN IDs of the allowed VLANs "
                +"when this port in trunking mode";
                type vlan-list-type;
              }
            }
          }
        }
        container native {
          tailf:info "Set trunking native characteristics when "
          +"interface is in trunking mode";
          leaf vlan {
            tailf:info "Set native VLAN when interface is in "
            +"trunking mode";
            type uint16 {
              range "1..3967|4048..4093";
              tailf:info "<1-3967,4048-4093>;;VLAN ID of the "
              +"native VLAN when this port is in "
              +"trunking mode";
            }
          }
        }
      }
    }
    container untagged {
      tailf:info "Default to use for untagged packets on interface";
      leaf cos {
        tailf:info "IEEE 802.1Q class of service for QoS "
        +"classification";
        type uint8 {
          range "0..7";
          tailf:info "<0-7>;;COS value";
        }
      }
    }

    container vpc {
      tailf:info "Virtual Port Channel configuration";
      presence true;
      leaf port-channel-number {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<1-4096>;;Specify a Virtual Port Channel number";
        }
      }
      leaf peer-link {
        tailf:info "Specify if this link is used for peer communication";
        type empty;
      }
    }

    leaf vem {
      type uint16;
    }

  }

  grouping mgmt-settings-grouping {
    leaf "description" {
      tailf:info "Enter description of maximum 80 characters";
      tailf:cli-full-command;
      tailf:cli-multi-value;
      type string {
        length "1..80";
      }
    }

    leaf cdp {
      tailf:info "Configure CDP interface parameters";
      tailf:cli-full-command;
      type enumeration {
        enum enable {
          tailf:code-name cdp_enable;
          tailf:info "Enable/disable CDP on the interface";
        }
      }
    }

    leaf duplex {
      tailf:info "Enter the port duplex mode";
      tailf:cli-full-command;
      type enumeration {
        enum auto {
          tailf:code-name mgmt_duplex_auto;
          tailf:info "Auto";
        }
        enum full {
          tailf:info "Full";
        }
        enum half {
          tailf:info "Half";
        }
      }
    }

    container ip {
      tailf:info "Configure IP features";

      container access-group {
        tailf:info "Specify access control for packets";
        tailf:cli-sequence-commands;
        tailf:cli-compact-syntax;
        leaf name {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type string {
            length "1..64";
            tailf:info "WORD;;List name (Max Size 64)";
          }
        }
        leaf inout {
          tailf:cli-drop-node-name;
          type enumeration {
            enum in {
              tailf:info "Inbound packets";
            }
            enum out {
              tailf:info "Outbound packets";
            }
          }
        }
      }

      leaf address {
        tailf:info "Configure IP address on interface";
        tailf:cli-full-command;
        type ip-mask {
          tailf:info "A.B.C.D/LEN;;IP prefix and network mask length "
          +"in format x.x.x.x/m";
        }
      }

      container arp {
        tailf:info "Configure ARP parameters";
        tailf:cli-sequence-commands;
        tailf:cli-compact-syntax;
        leaf address {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP address";
          }
        }
        leaf mac {
          tailf:cli-drop-node-name;
          type mac-address-type2;
        }
      }

      leaf directed-broadcast {
        tailf:info "IP directed-broadcast";
        tailf:cli-full-command;
        type empty;
      }

      leaf port-unreachable {
        tailf:info "Enable sending ICMP port-unreachable";
        tailf:cli-full-command;
        type empty;
      }

      leaf redirects {
        tailf:info "Send ICMP Redirect messages";
        tailf:cli-full-command;
        type boolean;
        tailf:cli-boolean-no;
        default "true";
        tailf:cli-trim-default;
        tailf:cli-show-with-default;
      }

      leaf unreachables {
        tailf:info "Enable sending ICMP unreachables (other than "
        +"port-unreachable)";
        tailf:cli-full-command;
        type empty;
      }

      container port {
        tailf:info "Port policy";
        container access-group {
          tailf:info "Specify access control for packets";
          tailf:cli-sequence-commands;
          tailf:cli-compact-syntax;
          leaf name {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type string {
              length "1..64";
              tailf:info "WORD;;List name (Max Size 64)";
            }
          }
          leaf inout {
            tailf:cli-drop-node-name;
            type enumeration {
              enum in {
                tailf:info "Inbound packets";
              }
              enum out {
                tailf:info "Outbound packets";
              }
            }
          }
        }
      }

      container router {
        tailf:cli-compact-syntax;
        leaf ospf {
          type uint16 {
            range "1..65535";
            tailf:info "<1-65535>;;Process ID";
          }
        }

        leaf area {
          type ospf-area-type;

        }
      }
    }

    container ipv6 {
      tailf:info "Configure IPv6 features";
      leaf address {
        tailf:info "Configure IPv6 address on interface";
        type union {
          type ipv6-prefix {
            tailf:info "A:B::C:D/LEN;;IPv6 prefix format: xxxx:xxxx/ml, xxxx:"
            +"xxxx::/ml, xxxx::xx/128";
          }
          type enumeration {
            enum use-link-local-only {
              tailf:info "Enable IPv6 on interface using only a single link-"
              +"local address";
            }
          }
        }
      }
      leaf link-local {
        tailf:info "Change format of link-local address";
        type inet:ipv6-address {
          tailf:info "A:B::C:D;;IPv6 address format: aaaa:bbbb:cccc:dddd:eeee:"
          +"ffff:gggg:hhhh, aaaa::bbbb";

        }
      }
      leaf nd {
        tailf:info "ICMPv6 Neighbor Discovery commands";
        type enumeration {
          enum redirects {
            tailf:info "Enable sending ICMPv6 Redirect messages";
          }
        }
      }
      container neighbor {
        tailf:info "Configure IPv6 address to layer-2 address mapping";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf address {
          tailf:cli-drop-node-name;
          type inet:ipv6-address {
            tailf:info "A:B::C:D;;IPv6 address format: aaaa:bbbb:cccc:dddd:"
            +"eeee:ffff:gggg:hhhh, aaaa::bbbb";
          }
        }
        leaf mac {
          tailf:cli-drop-node-name;
          type union {
            type string {
              tailf:info "E.E.E;;Layer-2 MAC address (Option 1)";
            }
            type string {
              tailf:info "EE-EE-EE-EE-EE-EE;;Layer-2 MAC address (Option 2)";
            }
            type string {
              tailf:info "EE:EE:EE:EE:EE:EE;;Layer-2 MAC address (Option 3)";
            }
            type string {
              tailf:info "EEEE.EEEE.EEEE;;Layer-2 MAC address (Option 4)";
            }
          }
        }
      }
      leaf redirects {
        tailf:info "Enable sending ICMPv6 Redirect messages";
        type empty;
      }
      //  traffic-filter  Specify access control for packets
      container port {
        tailf:info "Port policy";
        container traffic-filter {
          tailf:info "Specify access control for packets";
          tailf:cli-sequence-commands;
          tailf:cli-compact-syntax;
          leaf name {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type string {
              length "1..64";
              tailf:info "WORD;;List name (Max Size 64)";
            }
          }
          leaf inout {
            tailf:cli-drop-node-name;
            type enumeration {
              enum in {
                tailf:info "Inbound packets";
              }
            }
          }
        }
      }
    }

    leaf lldp {
      tailf:info "Configure Interface LLDP parameters";
      tailf:cli-full-command;
      type enumeration {
        enum receive {
          tailf:code-name mgmt_lldp_receive;
          tailf:info "Enable LLDP reception on interface";
        }
        enum transmit {
          tailf:info "Enable LLDP transmission on interface";
        }
      }
    }

    container snmp {
      tailf:info "Modify SNMP interface parameters";
      leaf trap {
        tailf:info "Allow a specific SNMP trap";
        type enumeration {
          enum link-status {
            tailf:info "Allow SNMP LINKUP and LINKDOWN traps";
          }
        }
      }
    }

    leaf shutdown {
      type boolean;
      tailf:cli-boolean-no;
    }

    leaf speed {
      tailf:info "Enter the port speed";
      tailf:cli-full-command;
      type enumeration {
        enum "1000" {
          tailf:code-name  mgmt-settings-grouping-speed_1000;
          tailf:info "1Gb/s";
        }
        enum "auto" {
          tailf:code-name  mgmt-settings-grouping-auto;
          tailf:info "Auto negotiate speed";
        }
      }
    }

    container vrf {
      tailf:info "Configure VRF parameters";
      leaf member {
        tailf:info "Set interface's VRF membership";
        type vrf-member-type;
      }
    }
    container hsrp {
      leaf version {
        type uint16;
      }
      list hsrp-list {
        tailf:cli-drop-node-name;
        key id;

        leaf id {
          type uint16;
        }

        leaf ip {
          type inet:ipv4-address;
        }
        container timers {

          tailf:cli-sequence-commands;
          tailf:cli-compact-syntax;

          leaf timer1 {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint32 {
              range "0 .. 600000";
              tailf:info "<0-600000>;;Delay between first and second "
              +"SPF calculation in milliseconds";
            }
          }
          leaf timer2 {
            tailf:cli-drop-node-name;
            type uint32 {
              range "0 .. 600000";
              tailf:info "<0-600000>;;Maximum wait time in milliseconds "
              +"for SPF calculations";
            }
          }
        }

        container preempt {
          tailf:info "Overthrow lower priority Active routers";
          presence true;
          container delay {
            tailf:info "Wait before preempting";
            tailf:cli-compact-syntax;
            leaf minimum {
              tailf:info "Delay at least this long";
              type uint16 {
                tailf:info "<0-3600>;;Number of seconds for minimum delay";
                range "0..3600";
              }
            }
          }
        }
        leaf priority {
          tailf:info "Priority level";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<0-255>;;Priority value";
          }
        }
      }
    }
  }

  grouping common-interface-settings-grouping {

  }


  grouping switchport-grouping {
    container switchport {
      tailf:info "Configure switchport parameters";
      presence "Configure switchport parameters";

      leaf beacon {
        tailf:info "Disable/enable the beacon for an interface";
        tailf:cli-full-command;
        type empty;
      }

      container fcrxbbcredit {
        tailf:info "Configure receive BB_credit for the port";
        choice bbcredit-choice {
          container creds {
            tailf:cli-drop-node-name;
            leaf credit {
              tailf:cli-drop-node-name;
              tailf:cli-reset-container;
              tailf:cli-full-command;
              type uint8 {
                range "1..64";
                tailf:info "<1-64>;;Enter receive BB_credit";
              }
            }
            container ecreds {
              tailf:cli-drop-node-name;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              tailf:cli-compact-syntax;
              tailf:cli-incomplete-command;
              presence "true";
              leaf credit {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type uint8 {
                  range "1..64";
                  tailf:info "<1-64>;;Enter receive "
                  +"BB_credit";
                }
              }
              leaf mode {
                tailf:info "Configure receive BB_credit for "
                +"specific mode";
                type enumeration {
                  enum E {
                    tailf:info "Configure receive BB_credit"
                    +" for E or TE mode";
                  }
                }
              }
            }
            container fcreds {
              tailf:cli-drop-node-name;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              tailf:cli-compact-syntax;
              presence "true";
              tailf:cli-incomplete-command;
              leaf credit {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type uint8 {
                  range "1..64";
                  tailf:info "<1-64>;;Enter receive "
                  +"BB_credit";
                }
              }
              leaf mode {
                tailf:info "Configure receive BB_credit for "
                +"specific mode";
                tailf:cli-value-display-template "F";
                type enumeration {
                  // Bug in Cisco Nexus, displays
                  // Fx but does not accept Fx as input!!
                  enum Fx {
                    tailf:info "Configure receive BB_credit"
                    +" for F mode";
                  }
                }
              }
            }
          }
          leaf "default" {
            tailf:info "Default receive BB_credit";
            type empty;
          }
        }
      }

      leaf description {
        tailf:info "Enter description of maximum 80 characters";
        tailf:cli-full-command;
        tailf:cli-multi-value;
        type string {
          length "1..80";
        }
      }

      container ignore {
        tailf:info "Enter parameter to be ignored";
        leaf bit-error {
          tailf:info "Ignore big-error";
          type empty;
        }
      }

      leaf mode {
        tailf:info "Enter the port mode";
        tailf:cli-full-command;
        type enumeration {
          enum E {
            tailf:info "E mode";
          }
          enum F {
            tailf:info "F mode";
          }
          enum SD {
            tailf:info "SD mode";
          }
          enum auto {
            tailf:code-name switchport-grouping_mode_auto;
            tailf:info "Auto mode";
          }
        }
      }

      leaf speed {
        tailf:info "Enter the port speed";
        tailf:cli-full-command;
        type enumeration {
          enum 1000 {
            tailf:code-name switchport-grouping_1000;
            tailf:info "1000 Mbps speed";
          }
          enum 2000 {
            tailf:info "2000 Mbps speed";
          }
          enum 4000 {
            tailf:info "4000 Mbps speed";
          }
          enum 8000 {
            tailf:info "8000 Mbps speed";
          }
          enum auto {
            tailf:code-name switchport-grouping_speed_auto;
            tailf:info "Auto negotiate speed";
          }
        }
      }

      container trunk {
        tailf:info "Set trunking characteristics of the interface";
        container allowed {
          tailf:info "Set allowed VLAN characteristics when "
          +"interface is in trunking mode";
          // to suppor the add,remove custom CLI command
          // should be used.
          container vlan {
            tailf:info "Set allowed VLANs when interface is "
            +"in trunking mode";
            choice vlan-choice {
              leaf-list ids {
                tailf:cli-drop-node-name;
                tailf:cli-range-list-syntax;
                type vlan-list-type;
              }
              leaf fixed {
                tailf:cli-drop-node-name;
                type enumeration {
                  enum all {
                    tailf:info "All VLANs";
                  }
                  enum none {
                    tailf:info "No VLANs";
                  }
                }
              }
              leaf-list except {
                tailf:info " VLAN IDs of the allowed VLANs "
                +"when this port in trunking mode";
                tailf:cli-range-list-syntax;
                type vlan-list-type;
              }
            }
          }
        }
        container native {
          tailf:info "Set trunking native characteristics when "
          +"interface is in trunking mode";
          leaf vlan {
            tailf:info "Set native VLAN when interface is in "
            +"trunking mode";
            type uint16 {
              range "1..3967|4048..4093";
              tailf:info "<1-3967,4048-4093>;;VLAN ID of the "
              +"native VLAN when this port is in "
              +"trunking mode";
            }
          }
        }
      }
    }
  }

  grouping fc-settings-grouping {
    container channel-group {
      tailf:info "Add to/remove from a san-port-channel";
      choice channel-group-choice {
        list port {
          tailf:cli-drop-node-name;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-compact-syntax;
          max-elements "1";

          key nr;
          leaf nr {
            type uint16 {
              range "1..256";
              tailf:info "<1-256>;;Specify a san-port-channel "
              +"number";
            }
          }
          leaf force {
            tailf:info "Forcefully add aport";
            type empty;
          }
        }
        leaf auto {
          tailf:info "Enable Auto Creation of Port Channel";
          type empty;
        }
      }
    }
    container fcdomain {
      tailf:info "Configure fcdomain parameters";
      container rcf-reject {
        tailf:info "Configure the rcf-reject flag";
        leaf vsan {
          tailf:info "Specify the vsan range";
          type string {
            pattern "([0-9]+)(\-[0-9]+)?";
            tailf:info "1-4093;; VSAN id range";
          }
        }
      }
    }
    container fspf {
      tailf:info "Configure FSPF parameters";
      container cost {
        tailf:info "Configure FSPF link cost";
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        leaf cost {
          tailf:cli-incomplete-command;
          tailf:cli-drop-node-name;
          type uint16 {
            range "1..30000";
            tailf:info "FSPF link cost";
          }
        }
        leaf vsan {
          tailf:info "Enter VSAN";
          type string {
            pattern "([0-9]+)(\-[0-9]+)?";
            tailf:info "1-4093;; VSAN id range";
          }
        }
      }
      container dead-interval {
        tailf:info "Configure FSPF dead interval";
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        leaf cost {
          tailf:cli-incomplete-command;
          tailf:cli-drop-node-name;
          type uint16 {
            range "2..65535";
            tailf:info "Dead interval (in sec)";
          }
        }
        leaf vsan {
          tailf:info "Enter VSAN";
          type string {
            pattern "([0-9]+)(\-[0-9]+)?";
            tailf:info "1-4093;; VSAN id range";
          }
        }
      }
      container hello-interval {
        tailf:info "Configure FSPF hello-interval";
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        leaf cost {
          tailf:cli-incomplete-command;
          tailf:cli-drop-node-name;
          type uint16 {
            range "1..65534";
            tailf:info "Hello interval (in sec)";
          }
        }
        leaf vsan {
          tailf:info "Enter VSAN";
          type string {
            pattern "([0-9]+)(\-[0-9]+)?";
            tailf:info "1-4093;; VSAN id range";
          }
        }
      }
      container passive {
        tailf:info "Enable/disable FSPF on the interface";
        leaf vsan {
          tailf:info "Enter VSAN";
          type string {
            pattern "([0-9]+)(\-[0-9]+)?";
            tailf:info "1-4093;; VSAN id range";
          }
        }
      }
      container retransmit-interval {
        tailf:info "Configure FSPF retransmit interval";
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        leaf cost {
          tailf:cli-incomplete-command;
          tailf:cli-drop-node-name;
          type uint16 {
            range "1..65535";
            tailf:info "Retransmit interval (in sec)";
          }
        }
        leaf vsan {
          tailf:info "Enter VSAN";
          type string {
            pattern "([0-9]+)(\-[0-9]+)?";
            tailf:info "1-4093;; VSAN id range";
          }
        }
      }
    }
    container out-of-service {
      tailf:info "Put an interface out of service.";
      presence "Put an interface out of service.";
      leaf force {
        tailf:info "put an interface out of service";
        type empty;
      }
    }
    leaf shutdown {
      tailf:info "Enable/disable an interface";
      tailf:cli-boolean-no;
      type boolean;
      default "true";
    }

    uses switchport-grouping;
  }



  grouping san-settings-grouping {
    container channel {
      tailf:info "Set the channel mode for the san-port-channel "
      +"interface";
      leaf mode {
        tailf:info "Set the channel mode for the san-port-channel "
        +"interface";
        type enumeration {
          enum active {
            tailf:info "Configure ACTIVE san-port-channel";
          }
        }
      }
    }

    container fcdomain {
      tailf:info "Configure fcdomain parameters";
      container rcf-reject {
        tailf:info "Configure the rcf-reject flag";
        leaf vsan {
          tailf:info "Enter VSAN";
          type string {
            pattern "([0-9]+)(\-[0-9]+)?";
            tailf:info "1-4093;; VSAN id range";
          }
        }
      }
    }

    container fspf {
      tailf:info "Configure FSPF parameters";
      container cost {
        tailf:info "Configure FSPF link cost";
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        leaf cost {
          tailf:cli-incomplete-command;
          tailf:cli-drop-node-name;
          type uint16 {
            range "1..30000";
            tailf:info "FSPF link cost";
          }
        }
        leaf vsan {
          tailf:info "Enter VSAN";
          type string {
            pattern "([0-9]+)(\-[0-9]+)?";
            tailf:info "1-4093;; VSAN id range";
          }
        }
      }
      container dead-interval {
        tailf:info "Configure FSPF dead interval";
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        leaf cost {
          tailf:cli-incomplete-command;
          tailf:cli-drop-node-name;
          type uint16 {
            range "2..65535";
            tailf:info "Dead interval (in sec)";
          }
        }
        leaf vsan {
          tailf:info "Enter VSAN";
          type string {
            pattern "(([0-9])+)(\-([0-9])+)?";
            tailf:info "1-4093;; VSAN id range";
          }
        }
      }
      container hello-interval {
        tailf:info "Configure FSPF hello-interval";
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        leaf cost {
          tailf:cli-incomplete-command;
          tailf:cli-drop-node-name;
          type uint16 {
            range "1..65534";
            tailf:info "Hello interval (in sec)";
          }
        }
        leaf vsan {
          tailf:info "Enter VSAN";
          type string {
            pattern "(([0-9])+)(\-([0-9])+)?";
            tailf:info "1-4093;; VSAN id range";
          }
        }
      }
      container passive {
        tailf:info "Enable/disable FSPF on the interface";
        leaf vsan {
          tailf:info "Enter VSAN";
          type string {
            pattern "(([0-9])+)(\-([0-9])+)?";
            tailf:info "1-4093;; VSAN id range";
          }
        }
      }
      container retransmit-interval {
        tailf:info "Configure FSPF retransmit interval";
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        leaf cost {
          tailf:cli-incomplete-command;
          tailf:cli-drop-node-name;
          type uint16 {
            range "1..65535";
            tailf:info "Retransmit interval (in sec)";
          }
        }
        leaf vsan {
          tailf:info "Enter VSAN";
          type string {
            pattern "(([0-9])+)(\-([0-9])+)?";
            tailf:info "1-4093;; VSAN id range";
          }
        }
      }
    }

    leaf shutdown {
      tailf:info "Enable/disable an interface";
      tailf:cli-boolean-no;
      type boolean;
      default "true";
    }

    uses switchport-grouping;
  }

  // /version
  leaf version {
    tailf:info "Version";
    type string {
      tailf:info "WORD;;Version number";
    }
  }

  // /hostname
  leaf hostname {
    tailf:info "Set system's network name";
    type string {
      tailf:info "This system's network name";
    }
  }

  container cfs {
    tailf:info "CFS configuration commands";
    leaf distribute {
      tailf:info "Enable fabric wide distribution";
      type empty;
    }
    container eth {
      tailf:info "ETH configurations";
      leaf distribute {
        tailf:info "Enable CFS distribution over Ethernet";
        type empty;
      }
    }
    container ipv4 {
      tailf:info "IPv4 configurations";
      leaf distribute {
        tailf:info "Enable CFS distribution over IPv4";
        type empty;
      }
      leaf mcast-address {
        tailf:info "Configure IPv4 multicast address";
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Admin scope [239.255/16, 239.192/16-239.251/16]";
        }
      }
    }
    leaf region {
      tailf:info "Regions to limit the distribution scope of application(s)";
      type uint8 {
        tailf:info ";;<1-200>  Region Id";
        range "1..200";
      }
    }
    leaf static-peers {
      tailf:info "Enable Static peers configuration mode";
      type empty;
    }
  }

  container banner {
    //FIXME: 'c' delimiter support (in java code)
    tailf:info "Define a login banner";
    container exec {
      tailf:info "Set EXEC process creation banner";
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-compact-syntax;

      leaf start-marker {
        tailf:cli-drop-node-name;
        type string;
      }

      leaf message {
        tailf:cli-drop-node-name;
        type string;
      }

      leaf end-marker {
        tailf:cli-drop-node-name;
        type string;
        must "../end-marker = ../start-marker" {
          tailf:dependency "../start-marker";
        }
      }
    }
    container login {
      tailf:info "Set login banner";
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-compact-syntax;

      leaf start-marker {
        tailf:cli-drop-node-name;
        type string;
      }

      leaf message {
        tailf:cli-drop-node-name;
        type string;
      }

      leaf end-marker {
        tailf:cli-drop-node-name;
        type string;
        must "../end-marker = ../start-marker" {
          tailf:dependency "../start-marker";
        }
      }
    }
    container prompt-timeout {
      tailf:info "Set Message for login authentication timeout";
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-compact-syntax;

      leaf start-marker {
        tailf:cli-drop-node-name;
        type string;
      }

      leaf message {
        tailf:cli-drop-node-name;
        type string;
      }

      leaf end-marker {
        tailf:cli-drop-node-name;
        type string;
        must "../end-marker = ../start-marker" {
          tailf:dependency "../start-marker";
        }
      }
    }
    container motd {
      tailf:info "Set Message of the Day banner";
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-compact-syntax;

      leaf start-marker {
        tailf:cli-drop-node-name;
        type string;
      }

      leaf message {
        tailf:cli-drop-node-name;
        type string;
      }

      leaf end-marker {
        tailf:cli-drop-node-name;
        type string;
        must "../end-marker = ../start-marker" {
          tailf:dependency "../start-marker";
        }
      }
    }
  }

  container ssh {
    container key {
      leaf rsa {
        type uint16;
      }
    }
  }

  container errdisable {
    container recovery {
      container cause {
        leaf failed-port-state {
          type empty;
        }
      }
    }
  }

  list vem {
    key id;

    leaf id {
      type uint16;
    }

    container host {
      container vmware {
        leaf id {
          type string;
        }
      }
    }
  }


  container snmp-server {
    tailf:cli-compact-syntax;
    tailf:cli-sequence-commands;
    list user {
      tailf:cli-suppress-mode;
      key name;

      leaf name {
        type string;
      }

      leaf role {
        tailf:cli-drop-node-name;
        type enumeration {
          enum network-admin;
        }
      }

      container auth {
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf md5 {
          type string;
        }
        leaf localizedkey {
          type empty;
        }
      }
    }
  }




  container feature-set {
    leaf mpls {
      type empty;
    }
  }

  container "feature" {
    tailf:info "Command to enable/disable features";
    leaf bgp {
      tailf:info "Enable/Disable Border Gateway Protocol (BGP)";
      type empty;
    }
    leaf bfd {
      type empty;
    }
    leaf cts {
      tailf:info "Enable/Disable CTS";
      type empty;
    }
    leaf dot1x {
      tailf:info "Enable/Disable dot1x";
      type empty;
    }
    leaf eigrp {
      tailf:info "Enable/Disable Enhanced Interior Gateway Routing Protocol ("
      +"EIGRP)";
      type empty;
    }
    leaf fcoe {
      tailf:info "Enable/Disable FCoE/FC feature";
      type empty;
    }
    leaf fcoe-npv {
      tailf:info "Enable/Disable FCoE NPV feature";
      type empty;
    }
    leaf fex {
      tailf:info "Enable/Disable FEX";
      type empty;
    }
    leaf flexlink {
      tailf:info "Enable/Disable Flexlink";
      type empty;
    }
    leaf hsrp {
      tailf:info "Enable/Disable Hot Standby Router Protocol (HSRP)";
      type empty;
    }
    leaf msdp {
      tailf:info "Enable/Disable Multicast Source Discovery Protocol (MSDP)";
      type empty;
    }
    container mpls {
      leaf l3vpn {
        type empty;
      }
      leaf ldp {
        type empty;
      }
    }
    leaf ntp {
      tailf:info "Enable/Disable NTP";
      type empty;
    }
    leaf lldp {
      type empty;
    }
    leaf ospf {
      tailf:info "Enable/Disable Open Shortest Path First Protocol (OSPF)";
      type empty;
    }
    leaf ospfv3 {
      tailf:info "Enable/Disable Open Shortest Path First Version 3 Protocol ("
      +"OSPFv3)";
      type empty;
    }
    leaf pim {
      tailf:info "Enable/Disable Protocol Independent Multicast (PIM)";
      type empty;
    }
    leaf port-security {
      tailf:info "Enable/Disable port-security";
      type empty;
    }
    leaf privilege {
      tailf:info "Enable/Disable IOS type privilege level support";
      type empty;
    }
    leaf ptp {
      tailf:info "Enable/Disable PTP";
      type empty;
    }
    leaf rip {
      tailf:info "Enable/Disable Routing Information Protocol (RIP)";
      type empty;
    }
    leaf scp-server {
      tailf:info "Enable/Disable SCP server";
      type empty;
    }
    leaf sftp-server {
      tailf:info "Enable/Disable SFTP server";
      type empty;
    }
    leaf udld {
      tailf:info "Enable/Disable UDLD";
      type empty;
    }
    leaf vpc {
      tailf:info "Enable/Disable VPC (Virtual Port Channel)";
      type empty;
    }
    leaf vrrp {
      tailf:info "Enable/Disable Virtual Router Redundancy Protocol (VRRP)";
      type empty;
    }
    leaf vtp {
      tailf:info "Enable/Disable Vlan Trunking Protocol (VTP)";
      type empty;
    }
    leaf dhcp {
      tailf:info "Enable/Disable DHCP Snooping";
      type empty;
    }

    leaf http-server {
      type empty;
      tailf:info "Enable/Disable http-server";
    }
    leaf interface-vlan {
      tailf:info "Enable/Disable interface vlan";
      type empty;
    }
    leaf lacp {
      type empty;
      tailf:info "Enable/Disable LACP";
    }
    leaf netflow {
      type empty;
      tailf:info "Enable/Disable NetFlow";
    }
    leaf port-profile-roles {
      type empty;
      tailf:info "Enable/Disable Port-profile Roles Feature";
    }
    leaf private-vlan {
      type empty;
      tailf:info "Enable/Disable private-vlan";
    }
    leaf ssh {
      type empty;
      tailf:cli-show-no;
      tailf:info "Enable/Disable ssh";
    }
    leaf tacacs-plus {
      tailf:alt-name "tacacs+";
      type empty;
      tailf:info "Enable/Disable tacacs+";
    }
    leaf telnet {
      type empty;
      tailf:cli-show-no;
      tailf:info "Enable/Disable telnet";
    }
    leaf vpd {
      type empty;
      tailf:info "Enable/Disable VPC";
    }
  }

  // /username
  list username {
    tailf:info "Establish User Name Authentication";
    tailf:cli-suppress-mode;
    tailf:cli-compact-syntax;

    key name;

    leaf name {
      type string {
        tailf:info "WORD;;User name";
      }
    }

    //  access-class            Restrict access by access-class
    //  autocommand Automatically issue a command after the user logs in
    //  callback-dialstring     Callback dialstring
    //  callback-line           Associate a specific line with this callback
    //  callback-rotary         Associate a rotary group with this callback
    //  common-criteria-policy  Enter the common-criteria policy name
    //  dnis                    Do not require password when obtained via DNIS
    //  nocallback-verify       Do not require authentication after callback
    //  noescape                Prevent the user from using an escape character
    //  nohangup                Do not disconnect after an automatic command
    //  nopassword              No password is required for the user to log in
    container password {
      tailf:info "Specify the password for the user";
      tailf:cli-compact-syntax;
      tailf:cli-flatten-container;
      tailf:cli-sequence-commands;
      tailf:cli-reset-container;
      leaf "encryption" {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum "0" {
            tailf:info "Specifies an UNENCRYPTED password will follow";
          }
          enum "5" {
            tailf:info "Specifies a HIDDEN password will follow";
          }
        }
      }
      leaf "password" {
        tailf:cli-drop-node-name;
        tailf:cli-trim-default;
        tailf:cli-disallow-value "5|0";
        type string {
          tailf:info "WORD;;The HIDDEN user password string";
        }
      }
    }
    leaf role {
      tailf:info "Role which the user is to be assigned to";
      type enumeration {
        enum network-admin {
          tailf:info "System configured role";
        }
        enum network-operator {
          tailf:info "System configured role";
        }
        enum priv-0 {
          tailf:info "Privilege role";
        }
        enum priv-1 {
          tailf:info "Privilege role";
        }
        enum priv-10 {
          tailf:info "Privilege role";
        }
        enum priv-11 {
          tailf:info "Privilege role";
        }
        enum priv-12 {
          tailf:info "Privilege role";
        }
        enum priv-13 {
          tailf:info "Privilege role";
        }
        enum priv-14 {
          tailf:info "Privilege role";
        }
        enum priv-15 {
          tailf:info "Privilege role";
        }
        enum priv-2 {
          tailf:info "Privilege role";
        }
        enum priv-3 {
          tailf:info "Privilege role";
        }
        enum priv-4 {
          tailf:info "Privilege role";
        }
        enum priv-5 {
          tailf:info "Privilege role";
        }
        enum priv-6 {
          tailf:info "Privilege role";
        }
        enum priv-7 {
          tailf:info "Privilege role";
        }
        enum priv-8 {
          tailf:info "Privilege role";
        }
        enum priv-9 {
          tailf:info "Privilege role";
        }
        enum san-admin {
          tailf:info "System configured role";
        }
        enum vdc-admin {
          tailf:info "System configured role";
        }
        enum vdc-operator {
          tailf:info "System configured role";
        }
      }
    }

    leaf expire {
      tailf:info "Expiry date for this user account(in YYYY-MM-DD format)";
      type string {
        tailf:info "WORD;;Expiry in YYYY-MM-DD format (Max Size 10)";
      }
    }
  } // username

  container password {
    tailf:info "Password for the user";
    leaf strength-check {
      tailf:info "Strength check of password";
      tailf:cli-boolean-no;
      type boolean;
      default true;
    }
  }

  container ip {
    tailf:info "Configure IP features";
    //   access-list        Configure access list
    //   adjacency          Configure Adjmgr
    //   adjmgr             AM information
    //   arp                Configure ARP parameters
    //   as-path            BGP autonomous system path filter
    //   auto-discard       Auto 0.0.0.0/0 discard route
    //   community-list     Add a community list entry
    //   dns                Configure dns client

    container dhcp {
      leaf relay {
        type boolean;
        tailf:cli-boolean-no;
      }
    }

    leaf domain-list {
      tailf:info "Add additional domain names";
      type string {
        tailf:info "WORD;;Enter a domain (Max Size 64)";
        length "1..64";
      }
    }
    leaf domain-lookup {
      tailf:info "Enable/Disable DNS";
      type empty;
    }
    leaf domain-name {
      tailf:info "Specify default domain name";
      type string {
        tailf:info "WORD;;Enter the default domain (Max Size 64)";
        length "1..64";

      }
    }
    //   extcommunity-list  Add a extcommunity list entry
    list host {
      tailf:info "Add an entry to the ip hostname table";
      tailf:cli-suppress-mode;
      key "id";
      leaf id {
        type string {
        }
      }
      leaf address {
        tailf:cli-drop-node-name;
        type inet:ipv4-address;
      }
    }
    //   igmp               IGMP global configuration commands
    //   internal           Commands for internal use
    //   load-sharing       ECMP load-sharing
    //   mfwd               Configures Global IP Multicast Forwarding
    //   mroute             Configure multicast RPF static route
    //   multicast          Configure IP multicast global parameters
    container name-server {
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf-list servers {
        tailf:cli-drop-node-name;
        tailf:info "Specify nameserver address";
        tailf:cli-flat-list-syntax;
        type union {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Enter an IPv4 address";
          }
          type inet:ipv4-address {
            tailf:info "A:B::C:D;;Enter an IPv6 address";
          }
        }
      }
      leaf use-vrf {
        tailf:info "Display per-VRF information";
        type union {
          type string {
            tailf:info "WORD;;VRF name (Max Size 32)";
          }
          type enumeration {
            enum default {
              tailf:info "Known VRF name";
            }
            enum management {
              tailf:info "Known VRF name";
            }
          }
        }
      }
    }
    //   prefix-list        Build a prefix list
    //   radius             Radius server
    //   route              Route information
    //   routing            Routing information
    //   source-route       IP source routing option
    //   tcp                Global TCP parameters
    //   telnet             Configure telnet
    //   tftp               Configure TFTP client
  }

  container ipv6 {
    tailf:info "Configure IPv6 features";
    //  access-list            Configure access list
    //  adjacency              Configure Adjmgr
    //  adjacency-stale-timer  When probing for an adjacency begins
    list host {
      tailf:info "Add an entry to the ip hostname table";
      key "name ip";
      leaf name {
        type string {
          tailf:info "WORD;;Name of Host (Max Size 64)";
        }
      }
      leaf ip {
        type inet:ipv6-address {
          tailf:info "A:B::C:D;;Enter an IPv6 address";
        }
      }
    }
    //  icmp                   Configure icmp parameters
    //  internal               Commands for internal use
    //  prefix-list            Build a prefix list
    //  queue-packets          Queue 1 packet when triggered NS is sent
    list route {
      tailf:info "Configure IPv6 unicast static route";
      key "id";
      leaf id {
        type ipv6-prefix {
          tailf:info "A:B::C:D/LEN;;IPv6 prefix format: xxxx:xxxx/ml, xxxx:"
          +"xxxx::/ml, xxxx::xx/128";
        }
      }
      leaf next-hop {
        tailf:cli-drop-node-name;
        type union {
          type inet:ipv6-address {
            tailf:info "A:B::C:D      Link-local next-hop requires interface "
            +"also";
          }
          type inet:ipv6-address {
            tailf:info "A:B::C:D;;IPv6 address format: aaaa:bbbb:cccc:dddd:"
            +"eeee:ffff:gggg:hhhh, aaaa::bbbb";
          }
          type ipv6-prefix {
            tailf:info "A:B::C:D/LEN;;IPv6 prefix format: xxxx:xxxx/ml, xxxx:"
            +"xxxx::/ml, xxxx::xx/128";
          }
        }
      }
    }
    //  routing                Routing information
  }


  // FIXME: check on Nexus 5000

  list fex {
    key id;

    leaf id {
      type uint16;
    }

    container pinning {
      leaf max-links {
        type uint16;
      }
    }

    leaf description {
      tailf:info "Enter description of maximum 80 characters";
      tailf:cli-full-command;
      tailf:cli-multi-value;
      type string {
        length "1..80";
      }
    }
  }

  // FIXME: check on Nexus 5000
  container vlan {
    tailf:info "Vlan commands";

    list vlan-list {
      tailf:cli-drop-node-name;
      tailf:cli-mode-name "config-vlan";
      tailf:cli-range-list-syntax;
      key id;

      leaf id {
        type uint16 {
          range "1..3967|4048..4093";
          tailf:info "<1-3967,4048-4093>;;VLAN ID 1-4094 or "
          +"range(s): 1-5, 10 or 2-5,7-19";
        }
      }

      container ip {
        tailf:info "Configure IP features";
        container igmp {
          tailf:info "IGMP configuration commands";
          container snooping {
            tailf:info "Configures IGMP Snooping";
            presence "Configures IGMP Snooping";

            leaf explicit-tracking {
              tailf:info "Configures Explicit Host tracking for "
              +"vlan";
              tailf:cli-full-command;
              type empty;
            }
            leaf fast-leave {
              tailf:info "Configures Fast leave for the vlan";
              tailf:cli-full-command;
              type empty;
            }
            leaf last-member-query-interval {
              tailf:info "Configures interval between group-"
              +"specific Query transmissions";
              tailf:cli-full-command;
              type uint8 {
                range "1..25";
                tailf:info "<1-25>  Interval in seconds "
                +"(Default value is 1)";
              }
              default "1";
            }
            leaf link-local-groups-suppression {
              tailf:info "Configures Vlan link-local groups "
              +"suppression";
              tailf:cli-full-command;
              type empty;
            }
            container mrouter {
              tailf:info "Configures static multicast router "
              +"interface";
              container "interface" {
                tailf:info "Specify interface for "
                +"static-mrouter";
                list Ethernet {
                  tailf:info "Ethernet IEEE 802.3z";
                  tailf:cli-allow-join-with-key {
                    tailf:cli-display-joined;
                  }
                  tailf:cli-suppress-mode;
                  key "name";
                  leaf name {
                    type string {
                      pattern "([0-9])+/([0-9])+(/([0-9])+)?";
                      tailf:info "<1-66>/<1-128>;;Slot number/Port number";
                    }
                  }
                }
                list port-channel {
                  tailf:info "Port Channel interface";
                  tailf:cli-suppress-mode;
                  tailf:cli-allow-join-with-key {
                    tailf:cli-display-joined;
                  }
                  key "name";

                  leaf name {
                    type uint16 {
                      range "1..4096";
                      tailf:info "<1-4096>;;Port Channel "
                      +"number";
                    }
                  }
                }
              }
            }
            leaf static-group {
              tailf:info "Configures static group membership";
              tailf:cli-full-command;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Group IP Address";
              }
            }
          }
        }
      }

      leaf name {
        tailf:info "Ascii name of the VLAN";
        tailf:cli-full-command;
        tailf:cli-multi-value;
        type string {
          length "1..32";
          tailf:info "The ascii name for the VLAN (Max Size 32)";
        }
      }

      // FIXME: validate towards Nexus 5000
      container service-policy {
        tailf:info "Configure service policy for an interface";
        container input-map {
          tailf:cli-drop-node-name;
          tailf:cli-sequence-commands;
          tailf:cli-compact-syntax;
          leaf type {
            tailf:cli-optional-in-sequence;
            tailf:cli-incomplete-command;
            type enumeration {
              enum qos {
                tailf:code-name service_policy_input_map_qos;
                tailf:info "Qos policy";
              }
              enum network-qos {
                tailf:code-name service_policy_input_map_network_qos;
                tailf:info "Network Qos policy";
              }
              enum queuing {
                tailf:code-name service_policy_input_map_queuing;
                tailf:info "Queuing policy";
              }
            }
            default "qos";
          }
          leaf input {
            when "../type = 'qos' or ../type = 'queueing'" {
              tailf:dependency "../type";
            }
            tailf:info "Input Service Policy";
            type string {
              tailf:info "Policy-map name (alphanumeric) "
              +"(Max Size 40)";
            }
          }
          leaf no-stats {
            when "../type = 'qos'";
            tailf:info "Disable statistics for this policy";
            type empty;
          }
          leaf name {
            when "../type = 'network-qos'";
            tailf:cli-drop-node-name;
            tailf:cli-full-command;
            type leafref {
              path "/nx:policy-map/type/network-qos/name";
              tailf:info "Policy-map name (alphanumeric) "
              +"(Max Size 40)";
            }
          }
        }
        container output-map {
          tailf:cli-drop-node-name;
          tailf:cli-sequence-commands;
          tailf:cli-compact-syntax;
          leaf type {
            tailf:cli-optional-in-sequence;
            tailf:cli-incomplete-command;
            type enumeration {
              enum qos {
                tailf:code-name service_policy_output_map_qos;
                tailf:info "Qos policy";
              }
              enum network-qos {
                tailf:code-name service_policy_output_map_network_qos;
                tailf:info "Network Qos policy";
              }
              enum queuing {
                tailf:code-name service_policy_output_map_queuing;
                tailf:info "Queuing policy";
              }
            }
            default "qos";
          }
          leaf output {
            when "../type = 'qos'";
            tailf:info "Output Service Policy";
            type leafref {
              path "/nx:policy-map/type/qos/name";
              tailf:info "Policy-map name (alphanumeric) "
              +"(Max Size 40)";
            }
          }
          leaf no-stats {
            when "../type = 'qos'";
            tailf:info "Disable statistics for this policy";
            type empty;
          }
          leaf name {
            when "../type = 'network-qos'";
            tailf:cli-drop-node-name;
            tailf:cli-full-command;
            type leafref {
              path "/nx:policy-map/type/network-qos/name";
              tailf:info "Policy-map name (alphanumeric) "
              +"(Max Size 40)";
            }
          }
        }
      }
      leaf shutdown {
        tailf:info "Shutdown VLAN switching";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default "false";
      }
      leaf state {
        tailf:info "Operational state of the VLAN";
        tailf:cli-full-command;
        type enumeration {
          enum active {
            tailf:info "VLAN Active State";
          }
          enum suspend {
            tailf:info "VLAN Suspended State";
          }
        }
        default "active";
      }
    }
  }


  list route-map {
    key name;

    leaf name {
      type string;
    }

    leaf permit {
      tailf:cli-hide-in-submode;
      type uint16;
    }

    container match {
      container ip {
        container address {
          leaf prefix-list {
            type string;
          }
        }
      }
    }
  }

  typedef dscp-type {
    type uint16 {
      range "0..63";
      tailf:info "<0-63>;;List of DSCP values";
    }
  }

  // this model works well in NCS but may not be what you
  // want in a CLI since you would also want to support
  // typeing "class-map foo" without reqiering the type xx
  // prefix. However, this could easily be supported with
  // a clispec custom command.

  grouping match-grouping {
    container access-group {
      tailf:info "Access group";
      leaf-list name {
        tailf:info "Named Access List";
        tailf:cli-list-syntax;
        type string {
          length "1..64";
          tailf:info "WORD;;Access List name (Max Size 64)";
        }
      }
    }
    leaf-list cos {
      tailf:info "IEEE 802.1Q class of service";
      tailf:cli-range-list-syntax;
      type uint16 {
        range "0..7";
        tailf:info "<0-7>;;List of class-of-service values";
      }
    }
    leaf-list dscp {
      tailf:info "Match DSCP in IP(v4) and IPv6 packets";
      tailf:cli-range-list-syntax;
      type dscp-type;
    }
    container ip {
      tailf:info "IP";
      leaf-list rtp {
        tailf:cli-range-list-syntax;
        tailf:info "Real Time Protocol";
        type uint16 {
          range "2000..65535";
          tailf:info "<2000-65535>;;UDP port list that are using RTP";
        }
      }
    }
    leaf-list precedence {
      tailf:cli-full-command;
      tailf:info "Precedence in IP(v4) and IPv6 packets";
      type uint8 {
        range "0..7";
        tailf:info "<0-7>;;List of precedence values";
      }
    }
    container protocol {
      tailf:info "Protocol";
      leaf arp {
        type empty;
        tailf:info "IP ARP";
      }
      leaf clns_es {
        type empty;
        tailf:info "ISO CLNS End System";
      }
      leaf clns_is {
        type empty;
        tailf:info "ISO CLNS Intermediate System";
      }
      leaf dhcp {
        type empty;
        tailf:info "Dynamic Host Configuration";
      }
      leaf ldp {
        type empty;
        tailf:info "Label Distribution Protocol";
      }
      leaf netbios {
        type empty;
        tailf:info "NetBIOS";
      }
    }
  }

  container class-map {
    tailf:info "Configure a class-map";
    container type {
      tailf:info "Specify the type of this class-map";
      list qos {
        tailf:info "Qos class";
        tailf:cli-mode-name "config-cmap-qos";
        key name;

        leaf name {
          type string {
            length "1..40";
            tailf:info "WORD;;Class-map name (Max Size 40)";
          }
        }
        leaf prematch {
          tailf:cli-prefix-key;
          tailf:cli-drop-node-name;
          type enumeration {
            enum match-all {
              tailf:info "Logical-AND all matching statements under "+
              "this classmap";
            }
            enum match-any {
              tailf:info "Logical-OR all matching statements under "
              +"this classmap";
            }
          }
          default match-all;
        }

        leaf description {
          tailf:info "Class-Map description";
          tailf:cli-multi-value;
          type string {
            tailf:info "LINE;;Description of this class-map (up to 200 "+
            "characters)";
          }
        }
        container match {
          tailf:info "Classification criteria";
          uses match-grouping;
        }
      }
      list network-qos {
        tailf:info "Network Qos class";
        tailf:cli-mode-name "config-cmap-nq";
        key name;

        leaf name {
          type string {
            length "1..40";
            tailf:info "WORD;;Class-map name (Max Size 40)";
          }
        }
        leaf description {
          tailf:info "Class-Map description";
          tailf:cli-multi-value;
          type string {
            tailf:info "LINE;;Description of this class-map (up to 200 "+
            "characters)";
          }
        }
        container match {
          tailf:info "Classification criteria";
          leaf qos-group {
            tailf:info "QoS-group";
            type uint8 {
              range "1..5";
              tailf:info "<1-5>;;QoS-group value";
            }
          }
        }
      }
      list queuing {
        tailf:info "Queuing class";
        tailf:cli-mode-name "config-cmap-que";
        key name;

        leaf name {
          type string {
            length "1..40";
            tailf:info "WORD;;Class-map name (Max Size 40)";
          }
        }
        leaf description {
          tailf:info "Class-Map description";
          tailf:cli-multi-value;
          type string {
            tailf:info "LINE;;Description of this class-map (up to 200 "+
            "characters)";
          }
        }
        container match {
          tailf:info "Classification criteria";
          leaf qos-group {
            tailf:info "QoS-group";
            type uint8 {
              range "1..5";
              tailf:info "<1-5>;;QoS-group value";
            }
          }
        }
      }
    }
  }

  typedef class-name-type {
    type union {
      type string {
        length "1..40";
        tailf:info "WORD;;Class map name (Max Size 40)";
      }
      type enumeration {
        enum class-default {
          tailf:info "System default class matching otherwise "+
          "unclassified packet";
        }
      }
    }
  }

  grouping policy-map-class-qos-grouping {
    list class {
      tailf:info "Policy Criteria";
      tailf:cli-mode-name "config-pmap-c-qos";
      key "name";
      leaf name {
        type class-name-type;
      }

      container set {
        tailf:info "Set attribute";
        leaf dscp {
          tailf:info "Set DSCP in IP(v4) and IPv6 packets";
          tailf:cli-full-command;
          type dscp-type;
        }
        leaf precedence {
          tailf:info "Precedence in IP(v4) and IPv6 packets";
          tailf:cli-full-command;
          type uint8 {
            range "0..7";
            tailf:info "<0-7>;;List of precedence values";
          }
        }
        leaf qos-group {
          tailf:info "QoS-group";
          tailf:cli-full-command;
          type uint8 {
            range "1..5";
            tailf:info "<1-5>;;QoS-group value";
          }
        }
      }
    }
  }

  grouping policy-map-class-network-qos-grouping {
    container class {
      tailf:info "Policy Criteria";
      container type {
        tailf:info "Specify the type class";
        list network-qos {
          tailf:info "Network Qos policy";
          tailf:cli-mode-name "config-pmap-nq-c";

          key "name";
          leaf name {
            type class-name-type;
          }

          leaf mtu {
            tailf:info "MTU for the CoS";
            tailf:cli-full-command;
            type uint16 {
              range "1500..9216";
              tailf:info "<1500-9216>;;MTU value";
            }
          }

          leaf multicast-optimize {
            tailf:info "Optimize multicast traffic distribution";
            tailf:cli-full-command;
            type empty;
          }

          container pause {
            tailf:info "PAUSE charecteristics (CBFC)";
            container no-drop {
              tailf:info "Enable no-drop for the CoS";
              presence "Enable no-drop for the CoS";
              tailf:cli-sequence-commands {
                tailf:cli-reset-all-siblings;
              }
              tailf:cli-compact-syntax;
              leaf buffer-size {
                tailf:info "Ingress buffer size in bytes";
                tailf:cli-optional-in-sequence;
                tailf:cli-incomplete-command;
                type uint32 {
                  range "10240..490880";
                  tailf:info "<10240-490880>;;Ingress buffer of the "
                  +"no-drop class in bytes";
                }
              }
              leaf pause-threshold {
                tailf:info "Buffer limit for pausing in bytes";
                tailf:cli-incomplete-command;
                when "../buffer-size" {
                  tailf:dependency "../buffer-size";
                }
                type uint32 {
                  range "0..490880";
                  tailf:info "<0-490880>;;Buffer limit at which"
                  +" the port pauses the peer";
                }
              }
              leaf resume-threshold {
                tailf:info "Buffer limit at which to resume in "
                +"bytes";
                when "../buffer-size" {
                  tailf:dependency "../buffer-size";
                }
                type uint32 {
                  range "0..490880";
                  tailf:info "<0-490880>;;Buffer limit at which "
                  +"the port resumes the peer";
                }
              }
              leaf-list pfc-cos {
                tailf:info "Cos values to assert PFC on";
                tailf:cli-range-list-syntax;
                type uint8 {
                  range "0..7";
                  tailf:info "<0-7>;;PFC COS bitmap";
                }
              }
            }
          }

          container queue-limit {
            tailf:info "Configure queue size fo the class";
            tailf:cli-sequence-commands;
            tailf:cli-compact-syntax;
            leaf count {
              tailf:cli-incomplete-command;
              tailf:cli-drop-node-name;
              type uint32 {
                range "20480..204800";
                tailf:info "<20480-204800>;;Queue size in bytes";
              }
              must "../bytes";
            }
            // must be set if the count is set
            leaf bytes {
              tailf:info "Bytes";
              type empty;
            }
          }

          container set {
            tailf:info "Set attribute";
            leaf qos {
              tailf:info "IEEE 802.1Q class of service";
              type uint8 {
                range "0..7";
                tailf:info "<0-7>;;IEEE 802.1Q Class of Service value";
              }
            }
          }
        }
      }
    }
  }

  grouping policy-map-class-queuing-grouping {
    container class {
      tailf:info "Policy Criteria";
      container type {
        tailf:info "Specify the type of class";
        list queuing {
          tailf:info "Match on Queuing class";
          tailf:cli-mode-name "config-pmap-c-que";

          key "name";
          leaf name {
            type class-name-type;
          }

          container bandwidth {
            tailf:info "Specify bandwidth for the class";
            leaf percent {
              tailf:info "Percentage of available bandwidth";
              type uint8 {
                range "0..100";
                tailf:info "<0-100>;;Value in percentage";
              }
            }
          }
          leaf priority {
            tailf:info "Configure traffic class priority";
            tailf:cli-full-command;
            type empty;
          }
        }
      }
    }
  }

  container control-plane {
    tailf:cli-add-mode;
    tailf:info "Enter to control-plane sub-mode";

    container scale-factor {
      tailf:info "Scale factor";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf scale {
        tailf:cli-drop-node-name;
        type decimal64 {
          fraction-digits "2";
          tailf:info "<whole>.<decimal>;;Specify scale factor value from 0.10 "
          +"to 2.00";
          range "0..2";
        }
      }

      leaf module {
        tailf:info "Module";
        type uint8 {
          tailf:info "<1-3>;;Specify module number";
          range "1..3";
        }
      }
    }
    container service-policy {
      tailf:info "Attach a policy to control-plane interface";
      leaf input {
        tailf:info "Input the policy name";
        type string {
          tailf:info "WORD;;Name of the policy (Max Size 64)";
        }
      }
    }
  }

  container ntp {
    tailf:info "NTP Configuration";
    //  abort               Abort the ntp configuration
    //  authenticate        Enable/Disable authentication
    //  authentication-key  NTP authentication key
    leaf commit {
      tailf:info "Commit the ntp configuration";
      type empty;
    }
    leaf distribute {
      tailf:info "Enable NTP configuration distribution";
      type empty;
    }
    //  logging             Enable/Disable logging of NTPD Events
    list peer {
      tailf:info "NTP Peer address";
      tailf:cli-suppress-mode;
      key "id";
      leaf id {
        type inet:ipv4-address;
      }
    }
    list server {
      tailf:info "NTP server address";
      tailf:cli-suppress-mode;
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      key "id";
      leaf id {
        type string {
          tailf:info "A.B.C.D|WORD;;Hostname/IP address of the NTP Server";
        }
      }
      //  key      Keyid to be used while communicating to this server
      //  maxpoll  Maximum interval to poll a server
      //  minpoll  Minimum interval to poll a server
      //  prefer   Preferred Server
      leaf use-vrf {
        tailf:info "Display per-VRF information";
        type union {
          type string {
            tailf:info "WORD;;VRF name (Max Size 32)";
          }
          type enumeration {
            enum default {
              tailf:info "Known VRF name";
            }
            enum management {
              tailf:info "Known VRF name";
            }
          }
        }
      }
    }
    //  source              Source of NTP packets
    leaf source-interface {
      tailf:info "Source interface sending NTP packets";
      type string;
    }
    //  trusted-key         NTP trusted-key
  }

  container vrf {
    tailf:info "Configure VRF parameters";
    list context {
      tailf:info "Create VRF and enter VRF mode";
      key "id";
      leaf id {
        type union {
          type string {
            tailf:info "WORD;;VRF name (Max Size 32)";
          }
          type enumeration {
            enum management {
              tailf:info "(no abbrev)  Configurable VRF name";
            }
          }
        }
      }

      leaf rd {
        type string;
      }

      container address-family {
        container ipv4 {
          container unicast {
            tailf:cli-add-mode;

            container route-target {
              leaf "import" {
                type string;
              }
              leaf "export" {
                type string;
              }
            }
          }
        }
      }

      //  address-family  Configure address family
      container ip {
        tailf:info "Configure IP features";
        //  auto-discard  Auto 0.0.0.0/0 discard route
        //  domain-list   Add additional domain names
        //  domain-name   Specify default domain name
        //  igmp          IGMP global configuration commands
        //  mroute        Configure multicast RPF static route
        //  multicast     Configure IP multicast global parameters
        //  name-server   Specify nameserver address
        list route {
          tailf:info "Route information";
          tailf:cli-suppress-mode;
          key "id";
          leaf id {
            type ipv4-prefix {
              tailf:info "A.B.C.D/LEN;;IP prefix and network mask length in "
              +"format x.x.x.x/m";
            }
          }
          leaf next-hop {
            tailf:cli-drop-node-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP next-hop address in format i.i.i.i";
            }
          }
        }
      }
      //  ipv6            Configure IPv6 features
      //  shutdown        Shutdown current VRF
    }
  }

  container vpc {
    tailf:info "Vpc";
    list domain {
      tailf:info "Specify domain";
      key "id";
      leaf id {
        type uint16 {
          tailf:info ";;<1-1000>  Domain id";
          range "1..1000";
        }
      }
      leaf auto-recovery {
        tailf:info "VPC settings to enable auto recovery if peer is presumed "
        +"non-operational";
        type empty;
      }
      container delay {
        tailf:info "Initialization delay";
        leaf restore {
          type uint16;
        }
      }
      //  dual-active       Configuration when peer link is down but peer
      //                    is alive
      //  graceful                  Enable graceful features
      container ip {
        tailf:info "Configure IP features";
        leaf arp {
          type enumeration {
            enum synchronize;
          }
        }
      }
      //  peer-config-check-bypass  Ignore type checks on primary, when
      //                            MCT is down
      leaf peer-gateway {
        tailf:info "Enable L3 forwarding for packets destined to peer's "
        +"gateway mac-address";
        type empty;
      }
      container peer-keepalive {
        tailf:info "Keepalive/Hello with peer switch";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf destination {
          tailf:info "Specify destination ip address of peer switch";
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IPv4 address (A.B.C.D) of destination";
          }
        }
        //  hold-timeout  Hold timeout to ignore stale peer alive messages
        //  interval      Enter interval in milleseconds
        //  precedence    Precedence
        //  source        Source interface for hello
        //  tos           Type of Service
        //  tos-byte      Type of Service Byte
        //  udp-port      Enter UDP port number used for hello
        //  vrf           Vrf to be used for hello messages
      }
      leaf peer-switch {
        tailf:info "Enable peer switch on vPC pair switches";
        type empty;
      }
      //  role                      Role related configuration
      //  system-mac                Configure system mac address
      //  system-priority           Configure system priority
      //  track                     Tracking object to suspend vPC if
      //                            object goes down
    }

  }

  container lacp {
    leaf offload {
      type empty;
    }
  }

  container port-channel {
    container load-balance {
      leaf ethernet {
        type enumeration {
          enum source-mac;
        }
      }
    }
  }

  container port-profile {

    container default {
      leaf max-ports {
        tailf:cli-hide-in-submode;
        tailf:info "Configure default max-ports";
        type uint16 {
          tailf:info "<1-1024>;;Enter the default max-number of ports for "
          +"vethernet port-profiles";
          range "1..1024";
        }
      }
    }

    list profiles {
      tailf:cli-drop-node-name;
      tailf:info "Configure a port-profile";
      key "id";
      leaf id {
        tailf:cli-disallow-value "default";
        type string {
          tailf:info "WORD;;Enter the name of the profile (Max Size 80)";
        }
      }

      leaf "type" {
        tailf:cli-prefix-key;

        type enumeration {
          enum ethernet;
          enum vethernet;
        }
      }

      // type     Configure type of the profile
      leaf max-ports {
        type uint16 {
          range "1..1024";
        }
      }

      leaf capability {
        type enumeration {
          enum l3control;
        }
      }

      leaf vmware {
        type enumeration {
          enum port-group;
        }
      }

      leaf shutdown {
        type empty;
        tailf:cli-show-no;
      }

      leaf description {
        tailf:cli-multi-value;
        type string;
      }

      leaf state {
        type enumeration {
          enum enabled;
          enum disabled;
        }
      }

      container switchport {
        leaf mode {
          type enumeration {
            enum access;
            enum trunk;
          }
        }

        container access {
          when "../mode = 'access'" {
            tailf:dependency "../mode";
          }
          leaf vlan {
            type uint16;
          }
        }

        container trunk {
          when "../mode = 'trunk'" {
            tailf:dependency "../mode";
          }
          container allowed {
            leaf-list vlan {
              tailf:cli-range-list-syntax;
              type uint16;
            }
          }
        }

        container port-security {
          presence true;
          tailf:cli-display-separated;

          leaf maximum {
            type uint16;
          }
        }
      }

      leaf org {
        type string;
      }

      container ip {
        container verify {
          leaf source {
            type enumeration {
              enum dhcp-snooping-vlan;
            }
          }
        }
      }

      container vn-service {
        tailf:cli-compact-syntax;
        leaf ip-address {
          type inet:ipv4-address;
        }
        leaf l3-mode {
          type empty;
        }
        leaf security-profile {
          type string;
        }
      }

      container channel-group {
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;

        leaf auto {
          type empty;
        }

        leaf mode {
          type enumeration {
            enum on;
            enum off;
          }
        }

        leaf mac-pinning {
          type empty;
        }
      }

      container system {
        leaf vlan {
          type uint16;
        }
      }

    }
  }

  container system {
    container storage-loss {
      container log {
        leaf time {
          type uint16;
        }
      }
    }
  }

  list vdc {
    key "name id";

    leaf name {
      type string;
    }
    leaf id {
      tailf:cli-expose-key-name;
      type uint16;
    }

    container limit-resource {
      container vlan {
        tailf:cli-compact-syntax;
        leaf minimum {
          type uint16;
        }
        leaf maximum {
          type uint16;
        }
      }
      container monitor-session {
        tailf:cli-compact-syntax;
        leaf minimum {
          type uint16;
        }
        leaf maximum {
          type uint16;
        }
      }
      container vrf-session {
        tailf:cli-compact-syntax;
        leaf minimum {
          type uint16;
        }
        leaf maximum {
          type uint16;
        }
      }
      container port-channel {
        tailf:cli-compact-syntax;
        leaf minimum {
          type uint16;
        }
        leaf maximum {
          type uint16;
        }
      }
      container u4route-mem {
        tailf:cli-compact-syntax;
        leaf minimum {
          type uint16;
        }
        leaf maximum {
          type uint16;
        }
      }
      container u6route-mem {
        tailf:cli-compact-syntax;
        leaf minimum {
          type uint16;
        }
        leaf maximum {
          type uint16;
        }
      }
      container m4route-mem {
        tailf:cli-compact-syntax;
        leaf minimum {
          type uint16;
        }
        leaf maximum {
          type uint16;
        }
      }
      container m6route-mem {
        tailf:cli-compact-syntax;
        leaf minimum {
          type uint16;
        }
        leaf maximum {
          type uint16;
        }
      }
    }
  }

  container policy-map {
    tailf:info "Configure a policy map";
    container type {
      tailf:info "Specify the type of this policy-map";
      list control-plane {
        tailf:info "Control-Plane";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Policy-map name (alphanumeric) (Max Size 64)";
            length "1..64";
          }
        }
        list class {
          tailf:info "Policy Criteria";
          tailf:cli-mode-name "config-pmap-c-qos";
          key "name";
          leaf name {
            type class-name-type;
          }
          container police {
            tailf:info "Police";
            tailf:cli-sequence-commands;
            tailf:cli-compact-syntax;
            leaf cir {
              tailf:info "Specify committed information rate";
              type uint16 {
                tailf:info "<1-20480>;;Committed Information Rate in kbps";
                range "1..20480";
              }
            }
            leaf kbps {
              tailf:cli-optional-in-sequence;
              tailf:info "Kilo Bits per second";
              type empty;
            }
            leaf bc {
              tailf:info "Specify committed burst";
              type uint32 {
                tailf:info "<1500-6400000>;;Committed Burst Size in bytes";
                range "1500..6400000";
              }
            }
            leaf bytes {
              tailf:info "Bytes";
              type empty;
            }
          }
        }
      }

      list qos {
        tailf:info "Qos class";
        tailf:cli-mode-name "policy-pmap-qos";
        key name;

        leaf name {
          type string {
            length "1..40";
            tailf:info "WORD;;Policy-map name (Max Size 40)";
          }
        }

        leaf description {
          tailf:info "Policy-Map description";
          tailf:cli-multi-value;
          type string {
            tailf:info "LINE;;Description of this policy-map (up to 200 "+
            "characters)";
          }
        }
        uses policy-map-class-qos-grouping;
      }
      list network-qos {
        tailf:info "Network Qos class";
        tailf:cli-mode-name "config-cmap-nq";
        key name;

        leaf name {
          type string {
            length "1..40";
            tailf:info "WORD;;Policy-map name (Max Size 40)";
          }
        }
        leaf description {
          tailf:info "Policy-Map description";
          tailf:cli-multi-value;
          type string {
            tailf:info "LINE;;Description of this policy-map (up to 200 "+
            "characters)";
          }
        }
        uses policy-map-class-network-qos-grouping;
      }
      list queuing {
        tailf:info "Queuing class";
        tailf:cli-mode-name "config-pmap-que";
        key name;

        leaf name {
          type string {
            length "1..40";
            tailf:info "WORD;;Policy-map name (Max Size 40)";
          }
        }
        leaf description {
          tailf:info "Policy-Map description";
          tailf:cli-multi-value;
          type string {
            tailf:info "LINE;;Description of this policy-map (up to 200 "+
            "characters)";
          }
        }
        uses policy-map-class-queuing-grouping;
      }
    }
  }

  container interface {
    tailf:info "Configure interfaces";

    list Ethernet {
      tailf:info "Ethernet IEEE 802.3z";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";

      key "name";

      leaf name {
        type string {
          // pattern "([0-9])+/([0-9])+(/([0-9])+)?";
          tailf:info "<1-66>/<1-128>;;Slot number/Port number";
        }
      }

      uses ethernet-settings-grouping;
    }

    list Vethernet {
      tailf:info "Ethernet IEEE 802.3z";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";

      key "name";

      leaf name {
        type string {
          // pattern "([0-9])+/([0-9])+(/([0-9])+)?";
          tailf:info "<1-66>/<1-128>;;Slot number/Port number";
        }
      }

      uses ethernet-settings-grouping;
    }

    list fc {
      tailf:info "Fiber Channel interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";

      key "name";

      leaf name {
        type string {
          pattern "[1-2]/([0-9])+";
          tailf:info "<1-2>/<1-48>;;Slot number/Port number";
        }
      }

      uses fc-settings-grouping;
    }

    list mgmt {
      tailf:info "Management interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";

      key "name";

      leaf name {
        type uint16 {
          range "0";
          tailf:info "<0-0>;;Management interface number";
        }
      }

      uses mgmt-settings-grouping;
    }

     list loopback {
      tailf:info "loopback interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";

      key "name";

      leaf name {
        type uint16 {
          range "0..255";
          tailf:info "<0-255>;;loopback interface number";
        }
      }

      uses mgmt-settings-grouping;
    }


    list control {
      tailf:info "Control interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";

      key "name";

      leaf name {
        type uint16 {
          range "0";
          tailf:info "<0-0>;;Control interface number";
        }
      }

      uses mgmt-settings-grouping;
    }

    list port-channel {
      tailf:info "Port Channel interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";

      key "name";

      leaf name {
        type uint16 {
          range "1..4096";
          tailf:info "<1-4096>;;Port Channel number";
        }
      }

      uses port-channel-settings-grouping;
    }

    list san-port-channel {
      tailf:info "SAN Port Channel interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";

      key "name";

      leaf name {
        type uint16 {
          range "1..256";
          tailf:info "<1-256>;;Port Channel number";
        }
      }
      uses san-settings-grouping;
    }

    // FIXME: check with Nexus 5000
    list Vlan {
      tailf:info "VLAN interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";

      key "name";

      leaf name {
        type uint16 {
          range "1..4096";
          tailf:info "<0-0>;;VLAN interface number";
        }
      }

      uses mgmt-settings-grouping;
      uses common-interface-settings-grouping;
    }
  }

  container logging {
    tailf:info "Modify message logging facilities";
    //  abort             Flushes cached data without committing and
    //                    releases the lock
    //  commit            Commits cached data (of all msg types) and
    //                    releases the lock
    //  console           Set console logging
    //  distribute        Enables/disables fabric distribution using cfs.
    //  event             Interface events
    //  ip                IP configuration
    container level {
      tailf:info "Facility parameter for syslog messages";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }

      leaf name {
        tailf:cli-drop-node-name;
        type string;
      }

      choice level-choice {
        leaf level {
          tailf:cli-drop-node-name;
          type uint8;
        }
        leaf-list what {
          tailf:cli-drop-node-name;
          tailf:cli-flat-list-syntax;
          type enumeration {
            enum link-up;
            enum error;
          }
        }
      }
    }
    //  logfile           Set File logging
    //  message           Interface events
    //  module            Set module(linecard) logging
    //  monitor           Set terminal line(monitor) logging level
    container server {
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf host {
        tailf:cli-drop-node-name;
        tailf:info "Enable forwarding to Remote Syslog Server";
        type string {
          tailf:info "A:B::C:D|WORD;;Hostname/IPv4/IPv6 address of the Remote "
          +"Syslog Server";
        }
      }
      leaf level {
        tailf:cli-drop-node-name;
        type uint8;
      }
    }
    //  source-interface  Enable Source-Interface for Remote Syslog Server
    //  timestamp         Set logging timestamp granularity
  }

  container radius-server {
    tailf:info "Configure RADIUS related parameters";
    leaf deadtime {
      tailf:info "Duration for which non-reachable server is skipped";
      type uint16 {
        tailf:info "<0-1440>;;Length of time, in minutes";
        range "0..1440";
      }
    }
    leaf directed-request {
      tailf:info "Enable direct authentication requests to server";
      type empty;
    }
    list host {
      tailf:info "RADIUS server's DNS name or its IP address";
      tailf:cli-suppress-mode;
      tailf:cli-compact-syntax;
      key "id";
      leaf id {
        type inet:ip-address {
          tailf:info "A:B::C:D|WORD;;IPV4/IPV6 address or DNS name";
        }
      }
      //  acct-port       RADIUS server's port for accounting
      //  auth-port       RADIUS server's port for authentication
      container key {
        tailf:info "RADIUS shared secret";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-reset-container;
        leaf "encryption" {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          tailf:cli-optional-in-sequence;
          type enumeration {
            enum "0" {
              tailf:info "Specifies an UNENCRYPTED password will follow";
            }
            enum "7" {
              tailf:info "Specifies a HIDDEN password will follow";
            }
          }
        }
        leaf "password" {
          tailf:cli-drop-node-name;
          tailf:cli-trim-default;
          type string {
            tailf:info "WORD;;The HIDDEN user password string";
          }
        }
      }
      leaf authentication {
        tailf:info "Use for authentication";
        type empty;
      }
      leaf accounting {
        tailf:info "Use for accounting";
        type empty;
      }
      leaf retransmit {
        tailf:info "RADIUS server retransmit count";
        type uint8 {
          tailf:info "<0-5>;;RADIUS server retransmit count";
          range "0..5";
        }
      }
      //  test            Parameters to send test packets
      leaf timeout {
        tailf:info "RADIUS server timeout period in seconds";
        type uint8 {
          tailf:info "<1-60>;;RADIUS server timeout period in seconds";
          range "1..60";
        }
      }
    }
    container key {
      tailf:info "Global RADIUS server shared secret";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-reset-container;
      leaf "encryption" {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum "0" {
            tailf:info "Specifies an UNENCRYPTED password will follow";
          }
          enum "7" {
            tailf:info "Specifies a HIDDEN password will follow";
          }
        }
      }
      leaf "password" {
        tailf:cli-drop-node-name;
        tailf:cli-trim-default;
        type string {
          tailf:info "WORD;;The HIDDEN user password string";
        }
      }
    }
    leaf retransmit {
      tailf:info "Global RADIUS server retransmit count";
      type uint8 {
        tailf:info "<0-5>;;Global RADIUS server retransmit count";
        range "0..5";
      }
    }
    //  test              Parameters to send test packets
    leaf timeout {
      tailf:info "Global RADIUS server timeout period in seconds";
      type uint8 {
        tailf:info "<1-60>;;RADIUS server timeout period in seconds";
        range "1..60";
      }
    }
  }

  container svs-domain {
    tailf:cli-add-mode;
    container domain {
      leaf id {
        type uint16;
      }
    }
    container control {
      leaf vlan {
        type uint16;
      }
    }
    container packet {
      leaf vlan {
        type uint16;
      }
    }
    container svs {
      leaf mode {
        type enumeration {
          enum "L2";
        }
      }
    }
  }

  container svs {
    container connection {
      container vcenter {
        tailf:cli-add-mode;
        leaf protocol {
          type enumeration {
            enum vmware-vim;
          }
        }
        container remote {
          container ip {
            tailf:cli-compact-syntax;

            leaf address {
              type inet:ipv4-address;
            }
            leaf port {
              type uint16;
            }
          }
        }
        container vmware {
          container dvs {
            tailf:cli-compact-syntax;
            leaf uuid {
              type string;
            }
            leaf datacenter-name {
              type string;
            }
          }
        }
        leaf max-ports {
          type uint16;
        }
        leaf connect {
          type empty;
        }
      }
    }
  }

  container vservice {
    container global {
      list type {
        key id;

        leaf id {
          type enumeration {
            enum vsg;
          }
        }

        container tcp {
          leaf state-checks {
            type empty;
          }
        }
      }
    }
  }

  container vnm-policy-agent {
    tailf:cli-add-mode;
    leaf registration-ip {
      type inet:ipv4-address;
    }
    leaf shared-secret {
      type string;
    }
    leaf policy-agent-image {
      type string;
    }
    leaf log-level {
      type empty;
    }
  }


  // /spanning-tree
  container spanning-tree {
    tailf:info "Spanning Tree Subsystem";

    container vlans-priority {
      tailf:cli-drop-node-name;
      list vlan {
        tailf:info "VLAN Switch Spanning Tree";
        tailf:cli-range-list-syntax;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key id;

        leaf id {
          type uint16 {
            tailf:info "WORD;;vlan range, example: 1,3-5,7,9-11";
            range "1..4096";
          }
        }
        leaf priority {
          tailf:info "Set the bridge priority for the spanning tree";
          tailf:cli-no-value-on-delete;
          tailf:cli-no-name-on-delete;
          type uint16 {
            tailf:info "<0-61440>;;bridge priority in increments of 4096";
            range "0..61440";
          }
        }
      }
    }
  }

}
