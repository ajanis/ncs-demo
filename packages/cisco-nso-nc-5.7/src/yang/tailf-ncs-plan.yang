submodule tailf-ncs-plan {
  yang-version 1.1;
  belongs-to tailf-ncs {
    prefix ncs;
  }

  import ietf-yang-types {
    prefix yang;
  }

  import tailf-common {
    prefix tailf;
  }

  include tailf-ncs-common;
  include tailf-ncs-services;
  include tailf-ncs-devices;
  include tailf-ncs-log;

  organization "Tail-f Systems";

  description
    "This submodule contains a collection of YANG definitions for
     configuring plans in NCS.

     Copyright 2016-2021 Cisco Systems, Inc.
     All rights reserved.
     Permission is hereby granted to redistribute this file without
     modification.";

  revision 2021-12-17 {
    description
      "Released as part of NCS-5.7.

       Non-backwards-compatible changes have been introduced.

       Obsoleted the usage of the 'service-commit-queue' grouping.

       Added YANG extensions 'all' and 'any'.

       Added YANG extensions 'all' and 'any' as valid substatements
       to the 'pre-condition' YANG extension.

       Added grouping 'pre-condition-grouping' that contains
       data to express nano-service pre-conditions.

       Added status obsolete to leafs 'create-monitor', 'create-trigger-expr',
       'delete-monitor' and 'delete-trigger-expr' in the 'pre-conditions'
       container in the 'nano-plan-components' grouping.

       Added containers 'create' and 'delete' to the 'pre-conditions'
       containers in the 'nano-plan-components' grouping. Both of the
       new containers contain the grouping 'pre-condition-grouping'.

       Add the converge-on-re-deploy extension.

       Updated plan-location type to yang:xpath1.0.

       Update the description of the self-as-service-status extension.";
  }

  revision 2021-09-02 {
    description
      "Released as part of NCS-5.6.

       Updated the description and added the 'sync' parameter to the
       /zombies/service/reactive-re-deploy action.

       Remove mandatory statement from status leaf in plan-state-change
       notification.

       Added commit-queue container and trace-id leaf to plan-state-change
       notification.

       Remove unique statement from /services/plan-notifications/subscription.";
  }

  revision 2021-02-09 {
    description
      "Released as part of NCS-5.5.1.

       Added the 'ncs-commit-params' grouping to the
       /zombies/service/re-deploy action input parameters.

       Added /zombies/service/latest-commit-parameters leaf.";
  }

  revision 2020-11-26 {
    description
      "Released as part of NCS-5.5.

       Add when statement to variables.

       Add self-as-service-status to plan-outline.

       Added the ncs-commit-params grouping to the force-back-track input
       parameters.

       Add new extension deprecates-component and a version leaf to
       nano components.";
  }

  revision 2020-06-25 {
    description
      "Released as part of NCS-5.4.

       Add trigger-on-delete trigger type to precondition monitors.

       Add sync option to post actions.

       Remove the experimental tag from the plan-location statement.

       Add purge action to side-effect queue and make the automatic
       cleanup of the side-effect queue configurable.

       Add force-commit to create and delete.

       Add zombies/service/pending-delete leaf.

       Add zombies/service/plan/commit-queue container.

       Use service-commit-queue grouping under zombies/service.

       Add load-device-config action under
       commit-queue/queue-item/failed-device for zombies.

       Add canceled as a valid value of side-effect-queue/status.
       The status of a side-effect is canceled if a related
       commit-queue item has failed. Canceled side-effects are
       cleaned up as part of the side-effect queue's automatic cleanup.";
  }

  revision 2019-11-28 {
    description
      "Released as part of NCS-5.3.

       Added dry-run option to the zombie resurrect action.

       Added service log and error-info to zombies.

       Added reactive-re-deploy action to revive and
       reactive-re-deploy a zombie.";

  }

  revision 2019-04-09 {
    description
      "Released as part of NCS-5.1.

       Added operation leaf to plan-state-change notification and to
       subscription list.

       Added ned-id-list in the service's private data.";
  }

  revision 2018-11-12 {
    description
      "Released as part of NCS-4.7.2.

       Major changes to nano services.";
  }

  revision 2018-06-21 {
    description
      "Released as part of NCS-4.7.

       Added commit-queue container in plan.";
  }

  revision 2017-03-16 {
    description
      "Released as part of NCS-4.4.

       Added error-info container in plan for additional error information.";
  }

  revision 2016-11-24 {
    description
      "Released as part of NCS-4.3.

       Major additions to this submodule to incorporate Nano Services.";
  }

  revision 2016-05-26 {
    description
      "Initial revision";
  }


  typedef plan-xpath {
    type yang:xpath1.0;
    description
      "This type represents an XPath 1.0 expression that is evaluated
       in the following context:

         o  The set of namespace declarations are the prefixes defined
            in all YANG modules implemented, mapped to the namespace
            defined in the corresponding module.

         o  The set of variable bindings contains all variables
            declared with 'ncs:variable' that are in scope, and all
            variables defined in the service code's 'opaque' key-value
            list (if any), and the following variables:

            'SERVICE': a nodeset with the service instance node as the
                       only member, or no nodes if the service
                       instances is being deleted.

            'ZOMBIE':  a nodeset with the service instance node as the
                       only member when it is being deleted, or no
                       nodes if the service instance exists.

            'PLAN':    a nodeset with the 'plan' container for the service
                       instance as the only member.


          o  The function library is the core function library.

          o  If this expression is in a descendant to a 'ncs:foreach'
             statement, the context node is the node in the node set
             in the 'ncs:foreach' result.  Otherwise, the context node
             is initially the service instance node.
       ";
  }

  /*
   * Plan Component Types
   */

  typedef plan-component-type-t {
    description
      "This is a base type from which all service specific plan components
       can be derived.";
    type identityref {
      base plan-component-type;
    }
  }

  identity plan-component-type {
    description
      "A service plan consists of several different plan components.
       Each plan component moves forward in the plan as the service
       comes closer to fulfillment.";
  }

  identity self {
    description
      "A service should when it constructs it's plan, include a column
       of type 'self', this column can be used by upper layer software to
       determine which state the service is in as a whole.";
    base plan-component-type;
  }


  /*
   * Plan States
   */

  typedef plan-state-name-t {
    description
      "This is a base type from which all plan component specific states can
       be derived.";
    type identityref {
      base plan-state;
    }
  }

  typedef plan-state-operation-t {
    type enumeration {
      enum created {
        tailf:code-name "plan_state_created";
      }
      enum modified {
        tailf:code-name "plan_state_modified";
      }
      enum deleted {
        tailf:code-name "plan_state_deleted";
      }
    }
  }

  typedef plan-state-status-t {
    type enumeration {
      enum not-reached;
      enum reached;
      enum failed {
        tailf:code-name "plan_failed";
      }
    }
  }

  typedef side-effect-q-status-t {
    type enumeration {
      enum not-reached;
      enum reached;
      enum failed {
        tailf:code-name "plan_failed";
      }
      enum canceled {
        tailf:code-name "effect_canceled";
      }
    }
  }

  typedef plan-state-action-status-t {
    type enumeration {
      enum not-reached;
      enum create-reached;
      enum delete-reached;
      enum failed {
        tailf:code-name "plan_action_failed";
      }
      enum create-init;
      enum delete-init;
    }
  }

  identity plan-state {
    description
      "This is the base identity for plan states. A plan component in a
       plan goes through certain states, some, such as 'init' and
       'ready', are specified here, and the application augments these
       with app specific states.";
  }

  identity init {
    description
      "The init state in all plan state lists, primarily used as a
       place holder with a time stamp.";
    base plan-state;
  }

  identity ready {
    description
      "The final state in a 'state list' in the plan";
    base plan-state;
  }

  /*
   * Plan Notifications
   */

  augment "/ncs:services" {
    container plan-notifications {
      description
        "Configuration to send plan-state-change notifications for
         plan state transitions. A notification can be configured to
         be sent when a specified service's plan component enters a
         given state.

         The built in stream 'service-state-changes' is used to send
         these notifications.";
      list subscription {
        key name;
        description
          "A list of our plan notification subscriptions.";

        leaf name {
          type string;
          description
            "A unique identifier for this subscription.";
        }
        leaf service-type {
          type tailf:node-instance-identifier;
          tailf:cli-completion-actionpoint "servicepoints-with-plan";
          description
            "The type of service. If not set, all service types are
             subscribed.";
        }
        leaf component-type {
          type plan-component-type-t;
          description
            "The type of component in the service's plan. If not set,
             all component types of the specified service types are
             subscribed.";
        }
        leaf state {
          type plan-state-name-t;
          description
            "The name of the state for the component in the service's plan.
             If not set, all states of the specified service types and
             plan components are subscribed.";
        }
        leaf operation {
          type plan-state-operation-t;
          description
            "The type of operation performed on the state(s) in the
             component(s). If not set, all operations are subscribed.";
        }
      }
    }
  }

  notification plan-state-change {
    description
      "This notification indicates that the specified service's
       plan component has entered the given state.

       This notification is not sent unless the system has been
       configured to send the notification for the service type.";
    leaf service {
      type instance-identifier;
      mandatory true;
      description
        "A reference to the service whose plan has been changed.";
    }
    leaf component {
      type string;
      description
        "Refers to the name of a component in the service's plan;
         plan/component/name.";
    }
    leaf state {
      type plan-state-name-t;
      mandatory true;
      description
        "Refers to the name of the new state for the component in
         the service's plan;
         plan/component/state";
    }
    leaf operation {
      type plan-state-operation-t;
      description
        "The type of operation performed on the given state.";
    }
    leaf status {
      type plan-state-status-t;
      description
        "Refers to the status of the new state for the component in
         the service's plan;
         plan/component/state/status";
    }
    container commit-queue {
      presence "The service is being committed through the commit queue.";
      list queue-item {
        key id;
        max-elements 1;
        leaf id {
          type uint64;
          description
            "If the queue item in the commit queue refers to this service
             this is the queue number.";
        }
        leaf tag {
          type string;
          description
            "Opaque tag set in the commit.";
        }
      }
    }
    leaf trace-id {
      type string;
      description
        "The trace id assigned to the commit that last changed
         the service instance.";
    }
  }

  /*
   * Groupings
   */

  grouping plan-data {
    description
      "This grouping contains the plan data that can show the
       progress of a Reactive FASTMAP service. This grouping is optional
       and should only be used by services i.e lists or presence containers
       that uses the ncs:servicepoint callback";
    container plan {
      config false;
      tailf:cdb-oper {
        tailf:persistent true;
      }
      uses plan-components;
      container commit-queue {
        presence "The service is being committed through the commit queue.";
        list queue-item {
          key id;
          leaf id {
            type uint64;
            description
              "If the queue item in the commit queue refers to this service
               this is the queue number.";
          }
        }
      }
      leaf failed {
        type empty;
        description
          "This leaf is present if any plan component in the plan is in
           a failed state; i.e., a state with status 'failed', or
           if the service failed to push its changes to the network.";
      }
      container error-info {
        presence "Additional info if plan has failed";
        leaf message {
          type string;
          description
            "An explanatory message for the failing plan.";
        }
        leaf log-entry {
          type instance-identifier {
            require-instance false;
          }
          description
            "Reference to a service log entry with additional information.";
        }
      }
    }
    container plan-history {
      config false;
      tailf:cdb-oper {
        tailf:persistent true;
      }
      list plan {
        key time;
        description
          "Every time the plan changes its structure, i.e., a
           plan component is added or deleted, or a state is added or
           deleted in a plan component, a copy of the old plan is stored
           in the plan history list.";

        leaf time {
          type yang:date-and-time;
          tailf:cli-value-display-template "$(.|datetime)";
        }
        uses plan-components;
      }
    }
  }

  grouping plan-components {
    description
      "This grouping contains a list of components that reflects the
       different steps or stages that a Reactive FASTMAP service comprises.";
    list component {
      ordered-by user;
      key name;
      description
        "A component has a type and a list of states.
         It is required that the first plan component is of type ncs:self.
         It is also required that the first state of a component is ncs:init
         and the last state is ncs:ready.
         A service can in addition to the 'self' component have any number of
         components. These additional components will have types that are
         defined by user specified YANG identities.";

      uses plan-component-body {
        refine "state/status" {
          mandatory true;
        }
      }
    }
  }

  grouping plan-component-body {
    leaf name {
      type string;
    }
    leaf type {
      description
        "The plan component type is defined by an YANG identity.
         It is used to identify the characteristics of a certain component.
         Therefore, if two components in the same service are of the same
         type they should be identical with respect to number, type and order
         of their contained states.";

      type plan-component-type-t;
      mandatory true;
    }
    list state {
      description
        "A plan state represents a certain step or stage that a service needs
         to execute and/or reach. It is identified as an YANG identity.
         There are two predefined states ncs:init and ncs:ready which is the
         first respectively last state of a plan component.";

      ordered-by user;
      key name;
      leaf name {
        tailf:alt-name state;
        type plan-state-name-t;
      }
      leaf status {
        description
          "A plan state is always in one of three states 'not-reached' when
           the state has not been executed, 'reached' when the state has been
           executed and 'failed' it the state execution failed.";

        type plan-state-status-t;
      }
      leaf when {
        type yang:date-and-time;
        tailf:cli-value-display-template "$(.|datetime)";
        when '../status != "not-reached"';
        description
          "The time this state was successfully reached or failed.";
      }
      leaf service-reference {
        description
          "If this component reflects the state of some other data, e.g
           an instantiated RFS, an instantiated CFS or something else, this
           optional field can be set to point to that instance";
        type instance-identifier {
          require-instance false;
        }
        tailf:display-column-name "ref";
      }
    }
  }

  /*
   * Nano-service related definitions
   */

  grouping force-back-track-action {
    tailf:action force-back-track {
      tailf:info "Force a component to back-track";
      description
        "Forces an existing component to start back-tracking";
      tailf:actionpoint ncsinternal {
        tailf:internal;
      }
      input {
        leaf back-tracking-goal {
          type leafref {
            path "../../state/name";
          }
          description
            "Target state for back-track.";
        }
        uses ncs-commit-params;
      }
      output {
        leaf result {
          type boolean;
          description
            "Set to true if the forced back tracking was successful,
             otherwise false.";
        }
        leaf info {
          type string;
          description
            "A message explaining why the forced back tracking wasn't
             successful.";
        }
      }
    }
  }

  grouping post-action-input-params {
    description
      "A Nano service post-action can choose to implement this grouping
       as its input parameters. If so the action will be invoked with:
         * opaque-props    - The list of name, value pairs in the service opaque
         * component-props - The list of component properties for
                             the invoking plan component state.

       post-actions that does not implement this grouping as its input
       parameters will be invoked with an empty parameter list.";
    list opaque-props {
      key name;
      leaf name {
        type string;
      }
      leaf value {
        type string;
      }
    }
    list component-props {
      key name;
      leaf name {
        type string;
      }
      leaf value {
        type string;
      }
    }
  }

  grouping nano-plan-data {
    description
      "This grouping is required for nano services. It replaces the
       plan-data grouping. This grouping contains an executable plan
       that has additional state data which is internally used to
       control service execution.";
    uses nano-plan;
  }

  grouping nano-plan {
    container plan {
      config false;
      tailf:cdb-oper {
        tailf:persistent true;
      }
      uses nano-plan-components {
        augment "component" {
          uses force-back-track-action;
        }
      }
      container commit-queue {
        presence "The service is being committed through the commit queue.";
        list queue-item {
          key id;
          leaf id {
            type uint64;
            description
              "If the queue item in the commit queue refers to this service
               this is the queue number.";
          }
        }
      }
      leaf failed {
        type empty;
        description
          "This leaf is present if any plan component in the plan is in
           a failed state; i.e., a state with status 'failed', or
           if the service failed to push its changes to the network.";
      }
      container error-info {
        presence "Additional info if plan has failed";
        leaf message {
          type string;
          description
            "An explanatory message for the failing plan.";
        }
        leaf log-entry {
          type instance-identifier {
            require-instance false;
          }
          description
            "Reference to a service log entry with additional information.";
        }
      }
      leaf deleting {
        tailf:hidden fastmap-private;
        type empty;
      }
      leaf service-location {
        tailf:hidden fastmap-private;
        type instance-identifier {
          require-instance false;
        }
      }
    }
  }

  grouping nano-plan-components {
    description
      "This grouping contains a list of components that reflects the
       different steps or stages that a nano service comprises.";
    list component {
      ordered-by user;
      key "type name";
      description
        "A component has a type and a list of states.  It is required
         that the first plan component is of type ncs:self.  It is
         also required that the first state of a component is ncs:init
         and the last state is ncs:ready.  A service can in addition
         to the 'self' component have any number of components. These
         additional components will have types that are defined by
         user specified YANG identities.";

      uses plan-component-body {
        augment "state" {
          leaf create-cb {
            tailf:hidden full;
            description
              "indicate if a create callback should be registered
               for this state";
            type boolean;
          }

          leaf create-force-commit {
            tailf:hidden full;
            description
              "Indicate if the current transaction should be commited before
               running any later states.";
            type boolean;
            default false;
          }

          leaf delete-cb {
            tailf:hidden full;
            description
              "indicate if a delete callback should be registered
               for this state";
            type boolean;
          }

          leaf delete-force-commit {
            tailf:hidden full;
            description
              "Indicate if the current transaction should be commited before
               running any later states.";
            type boolean;
            default false;
          }

          container pre-conditions {
            tailf:display-groups "summary";
            description
              "Pre-conditions for a state controls whether or not a
               state should be executed. There are separate conditions
               for the 'create' and 'delete' case. At create the
               create conditions checked and if possible executed with
               the ultimate goal for the state of having status
               'reached'. At the 'delete' case the delete conditions
               control whether the state changes should be deleted
               with the ultimate goal of the state having status
               'not-reached'";

            presence "Preconditions for executing the plan state";

            // Kept for backwards compatability
            leaf create-trigger-expr {
              status obsolete;
              type yang:xpath1.0;
            }

            leaf create-monitor {
              status obsolete;
              type yang:xpath1.0;
            }

            leaf delete-trigger-expr {
              status obsolete;
              type yang:xpath1.0;
            }

            leaf delete-monitor {
              status obsolete;
              type yang:xpath1.0;
            }

            grouping pre-condition-grouping {
              leaf fun {
                type enumeration {
                  enum all {
                    tailf:code-name fun-all;
                  }
                  enum any {
                    tailf:code-name fun-any;
                  }
                }
              }
              list pre-condition {
                key id;
                leaf id {
                  type string;
                }
                leaf monitor {
                  type yang:xpath1.0;
                }
                leaf trigger-expr {
                  type yang:xpath1.0;
                }
              }
            }
            container create {
              presence "Create precondition exists";
              uses pre-condition-grouping;
            }
            container delete {
              presence "Delete precondition exists";
              uses pre-condition-grouping;
            }
          }

          container post-actions {
            tailf:display-groups "summary";

            description
              "Post-actions are called after successful execution of a
               state.  These are optional and there are separate
               action that can be set for the 'create' and 'delete'
               case respectively.

               These actions are put as requests in the
               side-effect-queue and are executed asynchronously with
               respect to the original service transaction.";

            presence "Asynchronous side-effects after successful execution";
            leaf create-action-node {
              description
                "This leaf identifies the node on which a specified
                 action resides. This action is called after this state
                 as got a 'reached' status.";
              type yang:xpath1.0;
            }
            leaf create-action-name {
              description
                "The name of the action.";
              type string;
            }
            leaf create-action-result-expr {
              description
                "An action responds with a structured result. A certain
                 value could indicate an error or a successful result, e.g.
                 'result true'.

                 This statement describes an XPath expression to
                 evaluate the result of the action so that the
                 side-effect-queue can indicate action errors.

                 The result of the expression is converted to a boolean using
                 the standard XPath rules.  If the result is 'true' the action
                 is reported as successful, otherwise as failed.

                 The context for evaluating this expression is the
                 resulting xml tree of the action.

                 The set of namespace declarations are all available namespaces,
                 with the prefixes defined in the modules.";
              type yang:xpath1.0;
            }
            choice create-action-operation-mode {
              description
                "Specifies if the create post action should be run synchronously
                 or not.";
              leaf create-action-async {
                type empty;
              }
              leaf create-action-sync {
                type empty;
              }
              default create-action-async;
            }
            leaf delete-action-node {
              description
                "This leaf identifies the node on which a specified
                 action resides. This action is called after this state
                 as got a 'not-reached' status.";
              type yang:xpath1.0;
            }
            leaf delete-action-name {
              description
                "The name of the action.";
              type string;
            }
            leaf delete-action-result-expr {
              description
                "An action responds with a structured result. A certain
                 value could indicate an error or a successful result, e.g.
                 'result true'.

                 This statement describes an XPath expression to evaluate the
                 result of the action so that the side-effect-queue can
                 indicate action errors.

                 The result of the expression is converted to a boolean using
                 the standard XPath rules.  If the result is 'true' the action
                 is reported as successful, otherwise as failed.

                 The context for evaluating this expression is the
                 resulting xml tree of the action.

                 The set of namespace declarations are all available namespaces,
                 with the prefixes defined in the modules.";
              type yang:xpath1.0;
            }
            choice delete-action-operation-mode {
              description
                "Specifies if the delete post action should be run synchronously
                 or not.";
              leaf delete-action-async {
                type empty;
              }
              leaf delete-action-sync {
                type empty;
              }
              default delete-action-async;
            }
          }

          leaf post-action-status {
            when '../post-actions';
            type plan-state-action-status-t;
            description
              "This leaf is initially set to 'not-reached'.

               If a post-action was specified, and returned
               successfully, this leaf will be set to 'create-reached'
               if the component is not back-tracking, and
               'delete-reached' if it is back-tracking.

               If the post-action did not return successfully, this
               leaf is set to 'failed'.";
          }

          container modified {
            tailf:display-groups "summary";
            config false;
            tailf:callpoint ncs {
              tailf:internal;
            }
            description
              "Devices and other services this service has modified directly or
              indirectly (through another service).";
            tailf:info
              "Devices and other services this service modified directly or
               indirectly.";
            leaf-list devices {
              tailf:info
                "Devices this service modified directly or indirectly";
              type leafref {
                path "/ncs:devices/ncs:device/ncs:name";
              }
            }
            leaf-list services {
              tailf:info
                "Services this service modified directly or indirectly";
              type instance-identifier {
                require-instance false;
              }
            }
            leaf-list lsa-services {
              tailf:info
                "Services residing on remote LSA nodes this service
                has modified directly or indirectly.";
              type instance-identifier {
              require-instance false;
              }
            }
          }

          container directly-modified {
            tailf:display-groups "summary";
            config false;
            tailf:callpoint ncs {
              tailf:internal;
            }
            description
              "Devices and other services this service has explicitly
              modified.";
            tailf:info
              "Devices and other services this service has explicitly
              modified.";
            leaf-list devices {
              tailf:info
                "Devices this service has explicitly modified.";
              type leafref {
                path "/ncs:devices/ncs:device/ncs:name";
              }
            }
            leaf-list services {
              tailf:info
                "Services this service has explicitly modified.";
              type instance-identifier {
                require-instance false;
              }
            }
            leaf-list lsa-services {
              tailf:info
                "Services residing on remote LSA nodes this service
                has explicitly modified.";
              type instance-identifier {
                require-instance false;
              }
            }
          }

          uses service-get-modifications;

          container private {
            description
              "NCS service related internal data stored here.";
            tailf:hidden fastmap-private;
            ncs:ncs-service-private;
            leaf diff-set {
              description
                "Internal node use by NCS service manager to remember
                 the reverse diff for a service instance. This is the
                 data that is used by FASTMAP";
              tailf:hidden full;
              type binary;
            }
            leaf forward-diff-set {
              description
                "Internal node use by NCS service manager to remember
                 the forwards diff for a service instance. This data is
                 is used to produce the proper 'get-modifications' output";
              tailf:hidden full;
              type binary;
            }
            leaf-list device-list {
              description
                "A list of managed devices this state has manipulated.";
              tailf:hidden full;
              type string;
            }
            leaf-list ned-id-list {
              description
                "A list of NED identities this service instance has
                 manipulated.";
              tailf:hidden full;
              type string;
            }
            leaf-list service-list {
              description
                "A list of services this state has manipulated.";
              tailf:hidden full;
              type instance-identifier {
                require-instance false;
              }
            }
            leaf-list lsa-service-list {
              description
                "A list of LSA services this service instance has manipulated.";
              tailf:hidden full;
              type instance-identifier {
                require-instance false;
              }
            }
          }
        }
      }
      container private {
        description
          "NCS service related internal data stored here.";
        tailf:hidden fastmap-private;

        container property-list {
          description
            "FASTMAP service component instance data used by the
             service implementation.";
          list property {
            key name;
            leaf name {
              type string;
            }
            leaf value {
              type string;
            }
          }
        }
      }
      leaf back-track {
        type boolean;
        default false;
      }
      leaf back-track-goal {
        tailf:alt-name goal;
        type plan-state-name-t;
      }
      leaf version {
        tailf:hidden full;
        type uint32;
      }
    }
  }

  grouping nano-plan-history {
    container plan-history {
      config false;
      tailf:cdb-oper {
        tailf:persistent true;
      }
      list plan {
        key time;
        description
          "Every time the plan changes its structure, i.e., a
           plan component is added or deleted, or a state is added or
           deleted in a plan component, a copy of the old plan is stored
           in the plan history list.";

        leaf time {
          type yang:date-and-time;
          tailf:cli-value-display-template "$(.|datetime)";
        }
        uses nano-plan-components;
      }
    }
  }

  /*
   * Internal structures
   */

  container side-effect-queue {
    list side-effect {
      config false;
        tailf:cdb-oper {
        tailf:persistent true;
      }

      key id;
      leaf id {
        description
          "Unique identification of the side-effect action";
        type string;
      }
      leaf created {
        type yang:date-and-time;
      }
      leaf invoked {
        type yang:date-and-time;
      }
      leaf service {
        description
          "The service that added the side effect.";
        type string;
      }
      leaf requestor {
        description
          "Path to the requester of side-effect.
           Typically a plan state for a service.";
        type string;
      }
      leaf requestor-op {
        description
          "The base operation for the request-or when issuing the side-effect.";
        type enumeration {
          enum create {
            tailf:code-name op_create;
          }
          enum delete {
            tailf:code-name op_delete;
          }
        }
      }
      leaf action-node {
        description
          "This leaf identifies the node on which a specified
           action resides.";
        type yang:xpath1.0;
      }
      leaf action-name {
        description
          "The name of the action.";
        type yang:yang-identifier;
      }
      list variable {
        key name;
        description
          "A list of variable bindings that will be part of the
           context when the action-node path expression is evaluated.";
        leaf name {
          type string;
          description
            "The name of the variable";
        }
        leaf value {
          type yang:xpath1.0;
          mandatory true;
          description
            "An XPath expression that will be the value of the variable
             'name'. Note that both expressions and path expressions are
             allowed, which implies that literals must be quoted.";
        }
      }
      leaf result-expr {
        description
          "An action responds with a structured result. A certain
           value could indicate an error or a successful result, e.g.
           'result true'.

           This statement describes an XPath expression to evaluate the
           result of the action so that the side-effect-queue can
           indicate action errors.

           The result of the expression is converted to a boolean using
           the standard XPath rules.  If the result is 'true' the action
           is reported as successful, otherwise as failed.

           The context for evaluating this expression is the
           resulting xml tree of the action.

           There are no variable bindings in this evaluation.
           The set of namespace declarations are all available namespaces,
           with the prefixes defined in the modules.";
        type yang:xpath1.0;
      }
      leaf status {
        description
          "Resulting status to be set as the request's post-action-status.";
        type side-effect-q-status-t;
      }
      leaf error-message {
        description
          "An additional error message for the action if this is applicable.
           I.e. an error is thrown.";
        type string;
      }
      leaf u-info {
        tailf:hidden full;
        type binary;
      }
      leaf sync {
        type boolean;
      }
    }

    container settings {
      description
        "Settings related to the side effect queue.";
      container automatic-purge {
        description
          "Settings for the automatic purging of side effects.";
        container failed-queue-time {
          description
            "The time failed side effects should be kept in the queue.";
          choice failed-queue-time-choice {
            leaf forever {
              description
                "Failed side effects should be kept forever.";
              type empty;
            }
            leaf seconds {
              type uint16;
            }
            leaf minutes {
              type uint16;
            }
            leaf hours {
              type uint16;
            }
            leaf days {
              type uint16;
              default 7;
            }
            default days;
          }
        }
      }
    }

    tailf:action invoke {
      tailf:info "Invoke queued side-effects asynchronously";
      description
        "Invokes all not already executing/executed side-effects in the
         side effect queue.";
      tailf:actionpoint ncsinternal {
        tailf:internal;
      }
      input {
      }
      output {
        leaf num-invoked {
          type uint32;
        }
      }
    }

    tailf:action purge {
      tailf:info "Purge all failed side effects";
      description
        "Purge all failed side effects.";
      tailf:actionpoint ncsinternal {
        tailf:internal;
      }
      input {
      }
      output {
        leaf purged-side-effects {
          type uint16;
        }
      }
    }
  }

  container zombies {
    config false;
    tailf:cdb-oper {
      tailf:persistent true;
    }
    description
      "Container for deleted Nano Services that still perform staged deletes.";

    list service {
      key service-path;
      leaf service-path {
        description
          "The path to where the service resided that has been deleted
           and become a zombie.";
        type string;
      }
      leaf delete-path {
        description
          "The path to the node nearest to the top that was deleted and resulted
           in this service becoming a zombie.";
        type string;
      }
      leaf pending-delete {
        type empty;
      }

      leaf diffset {
        tailf:hidden full;
        type binary;
      }

      leaf latest-commit-params {
        tailf:hidden full;
        type binary;
        description
          "Latest transactions commit parameters are stored there, these are
           used in reactive-re-deploy actions that must have the same
           parameters as the original service commit.";
      }
      leaf latest-u-info {
        tailf:hidden full;
        type binary;
        description
          "Latest transactions user info is stored there, these are
           used in reactive-re-deploy actions that must be performed by
           a user with the same user info.";
      }

      container private {
        leaf-list device-list {
          description
            "A list of managed devices this state has manipulated.";
          tailf:hidden full;
          type string;
        }
      }

      container plan {
        uses nano-plan-components {
          augment "component" {
            uses force-back-track-action;
          }
        }
        container commit-queue {
          presence "The service is being committed through the commit queue.";
          list queue-item {
            key id;
            leaf id {
              type uint64;
              description
                "If the queue item in the commit queue refers to this service
                 this is the queue number.";
            }
          }
        }

        leaf failed {
          tailf:code-name "failedx";
          type empty;
        }
        container error-info {
          presence "Additional info if plan has failed";
          leaf message {
            type string;
            description
              "An explanatory message for the failing plan.";
          }
          leaf log-entry {
            type instance-identifier {
              require-instance false;
            }
            description
              "Reference to a service log entry with additional information.";
          }
        }
        leaf deleting {
          tailf:hidden fastmap-private;
          type empty;
        }
      }

      tailf:action re-deploy {
        tailf:info "revive the zombie and re-deploy it.";
        description
          "The nano service became a zombie since it was deleted but not
           all delete pre-conditions was fulfilled. This action revives the
           zombie service and re-deploys and stores it back as a zombie if
           necessary. This will be performed with the user who requested the
           action.";
        tailf:actionpoint ncsinternal {
          tailf:internal;
        }
        input {
          uses ncs-commit-params;
        }
        output {
          uses ncs-commit-result;
        }
      }
      tailf:action reactive-re-deploy {
        tailf:info "revive the zombie and reactive re-deploy it.";
        description
          "The nano service became a zombie since it was deleted but not
           all delete pre-conditions was fulfilled. This action revives the
           zombie service and re-deploys and stores it back as a zombie if
           necessary. This will be performed with the same user as the original
           commit.

           By default this action is asynchronous and returns nothing.";

        tailf:actionpoint ncsinternal {
          tailf:internal;
        }
        input {
          leaf sync {
            description
              "By default the action is asynchronous, i.e. it does not wait for
               the service to be re-deployed. Use this leaf to get synchronous
               behaviour and block until the service re-deploy transaction is
               committed. It also means that the action will possibly return
               a commit result, such as commit queue id if any, or an
               error if the transaction failed.";
            type empty;
          }
        }
        output {
          uses ncs-commit-result;
        }
      }
      tailf:action resurrect {
        tailf:info "Load the zombie back as service in current state.";
        description
          "The zombie resurrection is used to stop the progress of a staged
           nano service delete and restore current state as is.";
        tailf:actionpoint ncsinternal {
          tailf:internal;
        }
        input {
          container dry-run {
            presence "";
            leaf outformat {
              type outformat3;
            }
          }
        }
        output {
          leaf result {
            type string;
          }
          choice outformat {
            case case-xml {
              uses dry-run-xml;
            }
            case case-cli {
              uses dry-run-cli;
            }
            case case-native {
              uses dry-run-native;
            }
          }
        }
      }
      uses log-data;

      uses service-commit-queue {
        status obsolete;
        augment "commit-queue/queue-item/failed-device" {
          tailf:action load-device-config {
            tailf:display-when "../config-data != ''";
            tailf:info "Load device configuration into an open transaction.";
            description
              "Load device configuration into an open transaction.";
            tailf:actionpoint ncsinternal {
              tailf:internal;
            }
            input {
            }
            output {
              leaf result {
                type string;
              }
            }
          }
        }
      }
    }
  }

  /*
   * Plan Extension Statements
   */

  extension plan-outline {
    argument id {
      tailf:arg-type {
        type tailf:identifier;
      }
    }
    tailf:occurence "*";
    tailf:use-in "module";
    tailf:use-in "submodule";
    tailf:substatement "description";
    tailf:substatement "ncs:self-as-service-status" {
      tailf:occurence "?";
    }
    tailf:substatement "ncs:component-type" {
      tailf:occurence "+";
    }
    description
      "This statement is optionally used in a node that defines a
       service to document its plan.  It is required for a nano
       service.

       A plan is outlined by listing all component-types that the
       service can instantiate, and their related states.  Note that
       a specific service instance may instantiate zero, one, or more
       components of a certain type.

       It is required that a plan has one component of type ncs:self.";
  }

  extension self-as-service-status {
    description
      "If this statement has been set on a plan outline the self components
       init and ready states status will reflect the overall status of the
       service.

       The self components ready state will not be set to reached until all
       other components ready states have been set to reached and all post
       actions have been run successfully. Likewise when deleting a service
       the init state will not be set to not-reached (and the service deleted)
       until all other components init states have had their status
       set to not-reached and any post actions have been run successfully.

       If any state in a component, other than the self component, or post
       action have failed the ready/init state of the self component will
       also be set to failed to reflect that the service has failed.";
  }

  extension component-type {
    argument name {
      tailf:arg-type {
        type tailf:identifier-ref;
      }
    }
    tailf:substatement "description";
    tailf:substatement "ncs:state" {
      tailf:occurence "*";
    }
    description
      "This statement identifies the component type, which is a
       reference to a YANG identity.

       A component-type contains an ordered list of states which in
       also are references to YANG identities.  It is required that the
       first state in a component-type is ncs:init and the last state
       is ncs:ready.

       Each state represents a unit of work performed by the
       service when a certain pre condition is satisfied.";
  }

  extension state {
    argument name {
      tailf:arg-type {
        type tailf:identifier-ref;
      }
    }
    tailf:substatement "description";
    tailf:substatement "ncs:create" {
      tailf:occurence "?";
    }
    tailf:substatement "ncs:delete" {
      tailf:occurence "?";
    }

    description
      "This statement identifies the state, which is a reference to a
       YANG identity.

       It represents a unit of work performed by the service when a
       certain pre condition is satisfied.";
  }

  extension create {
    tailf:substatement "description";
    tailf:substatement "ncs:nano-callback" {
      tailf:occurence "?";
    }
    tailf:substatement "ncs:pre-condition" {
      tailf:occurence "?";
    }
    tailf:substatement "ncs:post-action-node" {
      tailf:occurence "?";
    }
    tailf:substatement "ncs:force-commit" {
      tailf:occurence "?";
    }

    description
      "This statement defines nano service state characteristics for
       entering this state.

       The component will advance to this state when it is not back
       tracking, it has reached its previous state, and the
       'pre-condition' is met.

       If the 'nano-callback' statement is defined, it means that
       there is a callback function (or template) that will be invoked
       before this state is entered.

       The 'post-action-node' optionally defines an action to be
       invoked when this state has been entered.";
  }

  extension delete {
    tailf:substatement "description";
    tailf:substatement "ncs:nano-callback" {
      tailf:occurence "?";
    }
    tailf:substatement "ncs:pre-condition" {
      tailf:occurence "?";
    }
    tailf:substatement "ncs:post-action-node" {
      tailf:occurence "?";
    }
    tailf:substatement "ncs:force-commit" {
      tailf:occurence "?";
    }

    description
      "This statement defines nano service state characteristics for
       leaving this state.

       The component will advance to this state when it is back
       tracking, it has reached its following state, and the
       'pre-condition' is met.

       If the 'nano-callback' statement is defined, it means that
       there is a callback function (or template) that will be invoked
       before this state is left.

       The 'post-action-node' optionally defines an action to be
       invoked when this state has been left.";
  }

  extension nano-callback {
    description
      "This statement indicates that a callback function (or a
       template) is defined for this state and operation.";
  }

  extension post-action-node {
    argument xpath {
      tailf:arg-type {
        type plan-xpath;
      }
    }
    tailf:substatement "description";
    tailf:substatement "ncs:action-name" {
      tailf:occurence "1";
    }
    tailf:substatement "ncs:result-expr" {
      tailf:occurence "?";
    }
    tailf:substatement "ncs:sync" {
      tailf:occurence "?";
    }

    description
      "This statement defined a action side-effect to be executed
       after the state has been successfully been executed.

       This statement argument is the node where the action resides.

       This action is executed asynchronously with respect to initial
       service transaction. The result is manifested as a value in
       the requesting plan states post-action-status leaf.

       The XPath expression is evaluated in the context described for
       'plan-xpath'.";
  }

  extension action-name {
    argument name {
      tailf:arg-type {
        type string;
      }
    }
    tailf:substatement "description";
    description
      "The name of the action.";
  }

  extension result-expr {
    argument xpath {
      tailf:arg-type {
        type yang:xpath1.0;
      }
    }
    tailf:substatement "description";
    description
      "An action responds with a structured result.  A certain value
       can indicate an error or a successful result, e.g.,
       'result true'.

       The result of the expression is converted to a boolean using
       the standard XPath rules.  If the result is 'true' the action
       is reported as successful, otherwise as failed.

       The context for evaluating this expression is the
       resulting xml tree of the action.

       There are no variable bindings in this evaluation.
       The set of namespace declarations are all available namespaces,
       with the prefixes defined in the modules.";
  }

  extension sync {
    description
      "Run the action synchronosly so that later states cannot proceed before
       the post action has finished running successfully.";
  }

  extension force-commit {
    description
      "Force a commit before any later states can proceed.";
  }

  /*
   * Behavior tree extensions for nano services
   */

  extension service-behavior-tree {
    argument servicepoint {
      tailf:arg-type {
        type tailf:identifier;
      }
    }
    tailf:occurence "*";
    tailf:use-in "module";
    tailf:use-in "submodule";
    tailf:substatement "description";
    tailf:substatement "ncs:plan-outline-ref" {
      tailf:occurence "1";
    }
    tailf:substatement "ncs:plan-location" {
      tailf:occurence "?";
    }
    tailf:substatement "ncs:selector" {
      tailf:occurence "*";
    }
    tailf:substatement "ncs:multiplier" {
      tailf:occurence "*";
    }
    tailf:substatement "ncs:converge-on-re-deploy" {
      tailf:occurence "?";
    }
    description
      "This statement is used to define the behavior tree for a nano
       service.

       The argument to this statement is the name of the service point
       for the nano service.

       The behavior tree consists of control flow nodes and execution
       nodes.

       There are two types of control flow nodes, defined with the
       'ncs:selector' and 'ncs:multiplier' statements.

       There is one type of execution nodes, defined with the
       'ncs:create-component' statement.

       A behavior tree is evaluated by evaluating all top control flow
       nodes, in order.  When a control flow node is evaluated, it
       checks if it should evaluate its children.  How this is done
       depend on the type of control flow node.  When an execution
       node is reached, the resulting component-type is added as a
       component to the plan and given a component-name.

       This process of dynamically instantiating a plan with its
       components by evaluation of the behavior tree is called
       synthesizing the plan.";
  }

  extension plan-outline-ref {
    argument id {
      tailf:arg-type {
        type tailf:identifier-ref;
      }
    }
    description
      "The name of the plan outline that the behavior tree will use
       to synthesize a service instance's plan.";
  }

  extension plan-location {
    argument path {
      tailf:arg-type {
        type yang:xpath1.0;
      }
    }

    description
      "XPath starting with absolute or relative path to a list or container
       where the plan is stored. Use this only if the plan is stored outside
       the service.

       The XPath expression is evaluated using the nano service as the context
       node, and the expression must return a node set.

       If the target lies within lists, all keys must be specified. A key
       either has a value, or a reference to a key of the service using the
       function current() as starting point for an XPath location path.
       For example:

         /a/b[k1='paul'][k2=current()/k]/c";
  }

  /* Control flow nodes */

  extension selector {
    tailf:substatement "description";
    tailf:substatement "ncs:pre-condition" {
      tailf:occurence "?";
    }
    tailf:substatement "ncs:observe" {
      tailf:occurence "?";
    }
    tailf:substatement "ncs:variable" {
      tailf:occurence "*";
    }
    tailf:substatement "ncs:selector" {
      tailf:occurence "*";
    }
    tailf:substatement "ncs:multiplier" {
      tailf:occurence "*";
    }
    tailf:substatement "ncs:create-component" {
      tailf:occurence "*";
    }
    description
      "This control flow node synthesizes its children
       that have their pre-conditions met.

       All 'ncs:variable' statements in this statement will have their
       XPath context node set to each node in the resulting node set.";
  }

  extension multiplier {
    tailf:substatement "description";
    tailf:substatement "ncs:pre-condition" {
      tailf:occurence "?";
    }
    tailf:substatement "ncs:observe" {
      tailf:occurence "?";
    }
    tailf:substatement "ncs:foreach" {
      tailf:occurence "1";
    }
    description
      "This control flow node synthesizes zero or more copies of
       its children.

       When this node is evaluated, it evaluates the 'foreach'
       expression.  For each node in the resulting node set, it
       synthesizes all children that have their pre-conditions
       met.";
  }

  extension foreach {
    argument xpath {
      tailf:arg-type {
        type plan-xpath;
      }
    }
    tailf:substatement "description";
    tailf:substatement "ncs:when" {
      tailf:occurence "?";
    }
    tailf:substatement "ncs:variable" {
      tailf:occurence "*";
    }
    tailf:substatement "ncs:selector" {
      tailf:occurence "*";
    }
    tailf:substatement "ncs:multiplier" {
      tailf:occurence "*";
    }
    tailf:substatement "ncs:create-component" {
      tailf:occurence "*";
    }

    description
      "This statement's argument is an XPath expression for the node set
       that is the basis for a multiplier selection.  For each node in
       the resulting node set the children will be evaluated.

       The XPath expression is evaluated in the context described for
       'plan-xpath'.";
  }

  extension when {
    argument xpath {
      tailf:arg-type {
        type plan-xpath;
      }
    }
    tailf:substatement "description";

    description
      "This optional statement describes an XPath expression that is
       used to further filter the selection of nodes from the
       node set in a multiplier component or the variables that should
       be created for a component.

       The result of the expression is converted to a boolean using
       the standard XPath rules.  If the result is 'true' the node is
       added to the node set or the variable is added to the variable
       list.

       The XPath expression is evaluated in the context described for
       'plan-xpath'.";
  }

  /* Execution nodes */

  extension create-component {
    argument name {
      tailf:arg-type {
        type plan-xpath;
      }
    }
    tailf:substatement "description";
    tailf:substatement "ncs:component-type-ref" {
      tailf:occurence "1";
    }
    tailf:substatement "ncs:pre-condition" {
      tailf:occurence "?";
    }
    tailf:substatement "ncs:observe" {
      tailf:occurence "?";
    }
    tailf:substatement "ncs:deprecates-component" {
      tailf:occurence "*";
    }

    description
      "When this execution node is evaluated, it instantiates a component
       in the service's plan.

       The name of the component is the result of evaluating the XPath
       expression and convert the result to a string.

       The XPath expression is evaluated in the context described for
       'plan-xpath'.";
  }

  extension component-type-ref {
    argument name {
      tailf:arg-type {
        type tailf:identifier-ref;
      }
    }
    description
      "This statement identifies the component type for the component.
       It must refer to a component-type defined in the plan-outline
       for the service.";
  }

  /* Common substatements */

  extension pre-condition {
    tailf:substatement "description";
    tailf:substatement "ncs:monitor" {
      tailf:occurence "?";
    }
    tailf:substatement "ncs:all" {
      tailf:occurence "?";
    }
    tailf:substatement "ncs:any" {
      tailf:occurence "?";
    }
    description
      "This statement defines a pre-condition that must hold for
       further evaluation/execution to proceed.

       If the pre-condition is not satisfied a kicker will be created
       with the same monitor to observe the changes and then
       re-deploy the service.";
  }

  extension observe {
    tailf:substatement "description";
    tailf:substatement "ncs:monitor" {
      tailf:occurence "1";
    }
    description
      "If a control flow node has been successfully evaluated, this
       statement's 'monitor' will be installed as a kicker, which will
       re-deploy the service if the monitor's trigger conditions are met.";
  }

  extension monitor {
    argument node {
      tailf:arg-type {
        type plan-xpath;
      }
    }
    tailf:substatement "description";
    tailf:substatement "ncs:trigger-on-delete" {
      tailf:occurence "?";
    }
    tailf:substatement "ncs:trigger-expr" {
      tailf:occurence "?";
    }
    description
      "If a node that matches the value of this statement and the
       'trigger' expression evaluates to true, this condition is
       satisfied. If the child statement 'trigger-on-delete' is used
       this condition will be satisfied when no nodes matches the
       value of this statement. Note that only one of 'trigger' and
       'trigger-on-delete' can be used as child statements to this
       statement.

       The argument to this statement is like an instance-identifier,
       but a list may be specified without any keys.  This is treated
       like a wildcard that matches all entries in the list.

       The XPath expression is evaluated in the context described for
       'plan-xpath'.";
  }

  extension trigger-on-delete {
    description
      "Specify if the monitored node should be checked if it has been deleted.";
  }

  extension trigger-expr {
    argument xpath {
      tailf:arg-type {
        type plan-xpath;
      }
    }
    tailf:substatement "description";

    description
      "This optional statement is used to further filter nodes
       in a given nodeset.

       The result of the expression is converted to a boolean using
       the standard XPath rules.  If the result is 'true' the condition
       is satisfied, otherwise it is not satisfied.

       The XPath expression is evaluated in the context described for
       'plan-xpath'.";
  }


  extension variable {
    argument name {
      tailf:arg-type {
        type string;
      }
    }

    tailf:substatement "description";
    tailf:substatement "ncs:when" {
      tailf:occurence "?";
    }
    tailf:substatement "ncs:value-expr" {
      tailf:occurence "?";
    }

    description
      "This statement defines an XPath variable with a name and a
       value.  The value is evaluated as an XPath expression.

       A variable called FOO can thus be retrieved as '{$FOO}'.

       These variables can for example be used in a 'multiplier'
       control flow node to create unique names of duplicated
       components.  The child components can be given names like
       'comp_{$FOO}', and when that expression is evaluated,
       the resulting component will have a name with {$FOO}
       substituted with the value of the variable 'FOO'.";
  }

  extension value-expr {
    argument xpath {
      tailf:arg-type {
        type plan-xpath;
      }
    }
    tailf:substatement "description";

    description
      "This statement defines an XPath expression that when evaluated
       constitutes a value for a variable.

       The XPath expression is evaluated in the context described for
       'plan-xpath'.";
  }

  extension deprecates-component {
    argument name {
      tailf:arg-type {
        type plan-xpath;
      }
    }

    tailf:substatement "ncs:component-type-ref" {
      tailf:occurence "?";
    }

    description
      "Indicate that the component deprecates another deleted component and
       that it will produce the same configuration as the old component. Before
       running this component the reverse diffsets for all the old components
       states will be applied and the component will be deleted.

       If the old component is still present after synthesizing the behaviour
       tree this statement will be ignored. ";
  }

  extension any {
    tailf:substatement "ncs:monitor" {
      tailf:occurence "*";
    }

    description
      "This extension is used inside of pre-condition extensions
       to allow multiple monitors inside of a single pre-condition.
       A pre-condition using this extension is satisfied if at least
       one of the monitors given as argument evaluates to true.

       This extension uses short-circuit evaluation, i.e., if one of the
       monitors given as argument evaluates to true the evaluation
       will stop.";
  }

  extension all {
    tailf:substatement "ncs:monitor" {
      tailf:occurence "*";
    }

    description
      "This extension is used inside of pre-condition extensions
       to allow multiple monitors inside of a single pre-condition.
       A pre-condition using this extension is satisfied if all
       of the monitors given as argument evaluates to true.

       This extension uses short-circuit evaluation, i.e., if one of
       the monitors given as argument evaluates to false the evaluation
       will stop.";
  }

  extension converge-on-re-deploy {
    status deprecated;
    description
      "Do not converge a service in the transaction in which it is created.
       On service creation the service will only synthesize the plan and
       schedule a reactive-re-deploy of itself.

       By default a service starts converging in the transaction in which
       it is created, but in certain scenarios this might not be the desired
       behaviour. E.g. when executing a service through the commit queue with
       error recovery set to rollback on error, this will ensure that the
       service intent is still present even when there are errors in the
       commit queue.

       Note: In a future release this behaviour will be the default and
             this setting will be removed, hence the deprecated status.";
  }
}
