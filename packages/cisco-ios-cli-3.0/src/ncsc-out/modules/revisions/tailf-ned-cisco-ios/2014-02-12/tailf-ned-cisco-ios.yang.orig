// =========================================================================
//                          CISCO-IOS NED
// =========================================================================

module tailf-ned-cisco-ios {
  namespace "urn:ios";
  prefix ios;

  import tailf-common {
    prefix tailf;
  }
  import ietf-inet-types {
    prefix inet;
  }
  import ietf-yang-types {
    prefix yang;
  }


  // =========================================================================
  // REVISION
  // =========================================================================

  revision 2014-02-12 {
    description
      "Fixed show live-status for interfaces.";
  }

  revision 2014-02-10 {
    description
      "[ip] vrf forwarding fix on interfaces.
      ";
  }

  revision 2014-02-06 {
    description
      "Fixed interface 'no ip address' bug
       Preliminary IOS XE support work
       Added 'interface Virtual-Template *'
       Added 'interface * / peer default ip' support'
       Expanded 'interface * / ppp' support'
       Merged interface encapsulation config (API change)
       Merged all fixes/adds in confd-4.3 ios-xe between r59179 and r65905.
      ";
  }

  revision 2014-01-30 {
    description
      "Merged from confd-5.0
       Expanded 'ip nat'";
  }

  revision 2014-01-28 {
    description
      "Fixed bugs in 'ip route'. API changes to list due to variable
       number of keys.";
  }

  revision 2013-12-09 {
    description
      "police and policer work";
  }

  revision 2013-11-25 {
    description
      "API-cleaning for Juniper and bugfixes
       Made cir,bc and be keywords mandatory in policy-map/class police";
  }

  revision 2013-11-12 {
    description
      "Rewrote police-map/class police command to support more combos";
  }

  revision 2013-10-14 {
    description
      "Merged all yang files to one file.";
  }

  revision 2013-08-15 {
    description
    "Added switchport commands
    Added spanning-tree top level commands
    Added a number of SNMP traps
    Added support for OSPFv3
    Added support for IPv6 prefix-lists
    ";

  }

  revision 2013-08-08 {
    description
    "Added support for Cisco 7600 constructs.";
  }

  revision 2013-06-25 {
    description
    "Renamed YANG module, submodule and namespace.";
  }

  revision 2013-04-18 {
    description
    "Restructuring using new file ios-common0.yang and
    augment(s) in order to fix order dependencies.

    Added model constructs for Cisco 2800.";
  }


  // =========================================================================
  // TYPEDEF
  // =========================================================================

  typedef percentage-type {
    type uint8 {
      tailf:info "<1-100>;;Percentage";
      range "1..100";
    }
  }

  // IPv4 prefix (address and mask length) in A.B.C.D/P format
  typedef ipv4-prefix {
    type string {
      pattern
        '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}'
        +  '([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'
        + '/(([0-9])|([1-2][0-9])|(3[0-2]))';
    }
  }

  // IPv6 prefix in standard format
  typedef ipv6-prefix {
    type string {
      pattern '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}'
        + '((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|'
        + '(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\.){3}'
        + '(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))'
        + '(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))';
      pattern '(([^:]+:){6}(([^:]+:[^:]+)|(.*\..*)))|'
        + '((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?)'
        + '(/.+)';
    }
  }

  // Host type, clean
  typedef host-type {
    type union {
      type inet:ip-address {
        tailf:info "";
      }
      type inet:domain-name {
        tailf:info "";
      }
    }
  }

  // Router Distinguisher
  typedef rd-type {
    type string {
      tailf:info "ASN:nn or IP-address:nn;;VPN Route Distinguisher";
      pattern '(\d*(.\d*)*)?:(\d*(.\d*)*)?';
    }
  }

  // VPN id type
  typedef vpn-id-type {
    type string {
      tailf:info "OUI:VPN-Index;;, format (hex) <3 bytes OUI:4 bytes "
        +"VPN_Index>";
      pattern '[0-9a-fA-F][0-9a-fA-F]?[0-9a-fA-F]?:[0-9a-fA-F]'
        +'[0-9a-fA-F]?[0-9a-fA-F]?[0-9a-fA-F]?';
    }
  }

  // ASN IP type
  typedef asn-ip-type {
    type string {
 pattern '(([0-9]+)|((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}'
        +  '([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]))):[0-9]+';
      tailf:info "ASN:nn or IP-address:nn";
    }
  }

  // Hour&minute type
  typedef hhmm-type {
    type string {
      pattern "([0-1]?[0-9]|2[0-4]):([0-5][0-9])(:[0-5][0-9])?";
    }
  }

  // Weekday type
  typedef weekday-type {
    type enumeration {
      enum Mon;
      enum Tue;
      enum Wed;
      enum Thu;
      enum Fri;
      enum Sat;
      enum Sun;
    }
  }

  // Month type
  typedef month-type {
    type enumeration {
      enum Jan;
      enum Feb;
      enum Mar;
      enum Apr;
      enum May;
      enum Jun;
      enum Jul;
      enum Aug;
      enum Sep;
      enum Oct;
      enum Nov;
      enum Dec;
    }
  }

  // Standard access list type
  typedef std-acl-type {
    type union {
      type uint16 {
        tailf:info "<1-99>;;Standard IP access-list number";
        range "1..99";
      }
      type uint16 {
        tailf:info "<1300-1999>;;Standard IP access-list "+
          "number (expanded range)";
        range "1300..1999";
      }
      type string {
        tailf:info "WORD;;Access-list name";
        pattern '[a-zA-Z].*';
      }
    }
  }

  // Extended access list type
  typedef ext-acl-type {
    type union {
      type uint16 {
        tailf:info "<100-199>;;Access list number";
        range "100..199";
      }
      type uint16 {
        tailf:info "<2000-2699>;;Access list number (expanded range)";
        range "2000..2699";
      }
      type string {
        tailf:info "WORD;;IP Named Extended Access list";
        pattern '[a-zA-Z].*';
      }
    }
  }

  // Expanded access list type
  typedef exp-acl-type {
    type union {
      type uint16 {
        tailf:info "<1-199>;;IP access list (standard or extended)";
        range "1..199";
      }
      type uint16 {
        tailf:info "<1300-2699>;;IP expanded access list "+
          "(standard or extended)";
        range "1300..2699";
      }
      type string {
        tailf:info "WORD;;Access-list name";
        pattern '[a-zA-Z].*';
      }
    }
  }

  // mdt data list type
  typedef mdt-data-list-type {
    type union {
      type uint16 {
        tailf:info "<100-199>;;Access-list number";
        range "100..199";
      }
      type uint16 {
        tailf:info "<2000-2699>;;Access list number (expanded range)";
        range "2000..2699";
      }
      type string {
        tailf:info "WORD;;IP Named Extended Access list";
        pattern '[a-fA-F].*';
      }
    }
  }

  // LDP discovery address type
  typedef ldp-discovery-address-type {
    type union {
      type enumeration {
        enum interface {
          tailf:code-name "ldp_interface";
          tailf:info "Use interface address for LDP "
            +"transport address";
        }
      }
      type inet:ipv4-address {
        tailf:info "A.B.C.D;;IP address to use for LDP "
          +"transport address";
      }
    }
  }

  // Mst cost
  typedef mst-cost-type {
    type union {
      type uint32 {
        tailf:info "<1-200000000>;;Port path cost";
        range "1..200000000";
      }
      type enumeration {
        enum auto {
          tailf:code-name mst_cost_type_auto;
          tailf:info "Determine cost based on media speed of this "
            +"interface";
        }
      }
    }
  }

  // Spanning tree cost
  typedef spanning-tree-cost-type {
    type union {
      type uint32 {
        tailf:info "<1-200000000>;;Port path cost";
        range "1..200000000";
      }
      type enumeration {
        enum auto {
          tailf:code-name spanning-tree-cost-type-auto;
          tailf:info "Determine cost based on media speed of this "
            +"interface";
        }
      }
    }
  }

  // DSCP type
  typedef dscp-type {
    type union {
      type uint8 {
        tailf:info "<0-63>;;Differentiated services codepoint value";
        range "0..63";
      }
      type enumeration {
        enum af11 {
          tailf:info "Match packets with AF11 dscp (001010)";
        }
        enum af12 {
          tailf:info "Match packets with AF12 dscp (001100)";
        }
        enum af13 {
          tailf:info "Match packets with AF13 dscp (001110)";
        }
        enum af21 {
          tailf:info "Match packets with AF21 dscp (010010)";
        }
        enum af22 {
          tailf:info "Match packets with AF22 dscp (010100)";
        }
        enum af23 {
          tailf:info "Match packets with AF23 dscp (010110)";
        }
        enum af31 {
          tailf:info "Match packets with AF31 dscp (011010)";
        }
        enum af32 {
          tailf:info "Match packets with AF32 dscp (011100)";
        }
        enum af33 {
          tailf:info "Match packets with AF33 dscp (011110)";
        }
        enum af41 {
          tailf:info "Match packets with AF41 dscp (100010)";
        }
        enum af42 {
          tailf:info "Match packets with AF42 dscp (100100)";
        }
        enum af43 {
          tailf:info "Match packets with AF43 dscp (100110)";
        }
        enum cs1 {
          tailf:info "Match packets with CS1(precedence 1) dscp"+
            " (001000)";
        }
        enum cs2 {
          tailf:info "Match packets with CS2(precedence 2) dscp"+
            " (010000)";
        }
        enum cs3 {
          tailf:info "Match packets with CS3(precedence 3) dscp"+
            " (011000)";
        }
        enum cs4 {
          tailf:info "Match packets with CS4(precedence 4) dscp"+
            " (100000)";
        }
        enum cs5 {
          tailf:info "Match packets with CS5(precedence 5) dscp"+
            " (101000)";
        }
        enum cs6 {
          tailf:info "Match packets with CS6(precedence 6) dscp"+
            " (110000)";
        }
        enum cs7 {
          tailf:info "Match packets with CS7(precedence 7) dscp"+
            " (111000)";
        }
        enum "default" {
          tailf:code-name "dscp_default";
          tailf:info "Match packets with default dscp (000000)";
        }
        enum dscp {
          tailf:info "Set packet dscp from dscp";
        }
        enum ef {
          tailf:info "Match packets with EF dscp (101110)";
        }
        enum precedence {
          tailf:info "Set packet dscp from precedence";
        }
      }
    }
  }

  // Precedence type
  typedef precedence-type {
    type union {
      type uint8 {
        tailf:info "<0-7>;;Precedence value";
        range "0..7";
      }
      type enumeration {
        enum critical {
          tailf:info "Set packets with critical precedence (5)";
        }
        enum flash {
          tailf:info "Set packets with flash precedence (3)";
        }
        enum flash-override {
          tailf:info "Set packets with flash override precedence (4)";
        }
        enum immediate {
          tailf:info "Set packets with immediate precedence (2)";
        }
        enum internet {
          tailf:code-name "prec_internet";
          tailf:info "Set packets with internetwork control"+
            " precedence (6)";
        }
        enum network {
          tailf:info "Set packets with network control precedence"+
            " (7)";
        }
        enum priority {
          tailf:code-name "prec_priority";
          tailf:info "Set packets with priority precedence (1)";
        }
        enum routine {
          tailf:info "Set packets with routine precedence (0)";
        }
      }
    }
  }

  // Precedence type2
  typedef precedence-type2 {
    type union {
      type uint8 {
        tailf:info "<0-7>;;IP precedence";
        range "0..7";
      }
      type enumeration {
        enum rsvp {
          tailf:code-name "prec_rsvp";
          tailf:info "rsvp traffic";
        }
      }
    }
  }

  // cos_value-type
  typedef cos_value-type {
    type union {
      type uint8 {
        tailf:info "<0-7>;;new cos value";
        range "0..7";
      }
      type enumeration {
        enum cos {
          tailf:info "Set packet cos from cos";
        }
        enum dscp {
          tailf:info "Set packet cos from dscp";
        }
        enum exp {
          tailf:info "Set packet cos from exp";
        }
        enum precedence {
          tailf:info "Set packet cos from precedence";
        }
      }
    }
  }

  // qos_value-type
  typedef qos_value-type {
    type union {
      type uint8 {
        tailf:info "<0-99>;;new qos-group";
        range "0..99";
      }
      type enumeration {
        enum cos {
          tailf:info "Set packet qos from cos";
        }
        enum dscp {
          tailf:info "Set packet qos from dscp";
        }
        enum exp {
          tailf:info "Set packet qos from exp";
        }
        enum precedence {
          tailf:info "Set packet qos from precedence";
        }
      }
    }
  }

  // exp_value-type
  typedef exp_value-type {
    type union {
      type uint8 {
        tailf:info "<0-7>;;new exp";
        range "0..7";
      }
      type enumeration {
        enum cos {
          tailf:info "Set packet exp from cos";
        }
        enum dscp {
          tailf:info "Set packet exp from dscp";
        }
        enum exp {
          tailf:info "Set packet exp from exp";
        }
        enum precedence {
          tailf:info "Set packet exp from precedence";
        }
      }
    }
  }

  // prec_value-type
  typedef prec_value-type {
    type union {
      type uint8 {
        tailf:info "<0-7>;;new precedence";
        range "0..7";
      }
      type enumeration {
        enum cos {
          tailf:info "Set packet precedence from cos";
        }
        enum dscp {
          tailf:info "Set packet precedence from dscp";
        }
        enum exp {
          tailf:info "Set packet precedence from exp";
        }
        enum precedence {
          tailf:info "Set packet precedence from precedence";
        }
      }
    }
  }

  // Precedence type3
  // match ip precedence ip-precedence-value [val2 val3 val4]
  //typedef precedence-type3 {
  //
  //}

  typedef access-list-standard-id-type {
    type union {
      type default-access-list-standard-id-type;
      type string {
        tailf:info "WORD;;Standard access-list name";
      }
    }
  }

  typedef default-access-list-standard-id-type {
    type union {
      type uint8 {
        tailf:info "<1-99>;;IP Standard access list number";
        range "1..99";
      }
      type uint16 {
        tailf:info "<1300-1999>;;IP Standard expanded access list number";
        range "1300..1999";
      }
    }
  }

  typedef access-list-in-out-type {
    type enumeration {
      enum in {
        tailf:info "Filter incoming routing updates";
      }
      enum out {
        tailf:info "Filter outgoing routing updates";
      }
    }
  }

  typedef redist-ospf-external-type {
    type enumeration {
      enum "1" {
        tailf:info "Redistribute external type 1 routes";
      }
      enum "2" {
        tailf:info "Redistribute external type 2 routes";
      }
    }
  }

  // Class name type
  // Used by policy-map,
  typedef class-name-type {
    type union {
      type string {
        // Note: leafref can't be used here due to part of union.
        //path "/ios:class-map/name";
        tailf:info "WORD;;class-map name";
      }
      type enumeration {
        enum class-default {
          tailf:info "System default class matching otherwise "+
            "unclassified packet";
        }
      }
    }
  }

  // Access list type
  typedef access-list-type {
    type union {
      type uint16 {
        range "1..199";
        tailf:info "<1-199>;;Access list";
      }
      type uint16 {
        range "1300..2699";
        tailf:info "<1300-2699>;;Access list (expanded range)";
      }
    }
  }

  typedef bgp-distribute-list-type {
    type union {
      type uint16 {
        range "100..199";
        tailf:info "<100-199>;;IP access-list number";
      }
      type uint16 {
        range "2000..2699";
        tailf:info "<2000-2699>;;IP expanded access list number";
      }
      type string {
        tailf:info "WORD;;Access-list name";
        pattern '[a-zA-Z].*';
      }
    }
  }

  typedef bgp-distribute-list-type2 {
    type union {
      type uint16 {
        range "1..199";
        tailf:info "<1-199>;;IP access list number";
      }
      type uint16 {
        range "1300..2699";
        tailf:info "<1300-2699>;;IP access list number (expanded "
        +"range)";
      }
      type string {
        tailf:info "WORD;;Access-list name";
        pattern '[a-zA-Z].*';
      }
    }
  }

  typedef ospf-area-type {
    type union {
      type uint32 {
        range "0 .. 4294967295";
        tailf:info "<0-4294967295>;;OSPF area ID as a decimal value";
      }
      type inet:ipv4-address {
        tailf:info "A.B.C.D;;OSPF area ID in IP address format";
      }
    }
  }

  typedef ospf-metric-type {
    type uint32 {
      range "1 .. 2";
      tailf:info "<1-2>;;OSPF Link State type";
    }
  }

  typedef limit-dc-non-dc-type {
    type union {
      type uint32 {
        range "1 .. 255";
        tailf:info "<1-255>;;The maximum number of retransmissions";
      }
      type enumeration {
        enum disable {
          tailf:info "Disable the feature";
        }
      }
    }
  }

  typedef default-access-list-id-type {
    type union {
      type uint32 {
        range "1 .. 199";
        tailf:info "<1-199>;;IP access list number";
      }
      type uint32 {
        range "1300 .. 2699";
        tailf:info "<1300-2699>;;IP expanded access list number";
      }
    }
  }

  typedef access-list-id-type {
    type union {
      type default-access-list-id-type;
      type string {
        tailf:info "WORD;;Access-list name";
        pattern '[a-zA-Z].*';
      }
    }
  }

  typedef default-offset-list-id-type {
    type union {
      type uint32 {
        range "0 .. 99";
        tailf:info "<0-99>;;Access list of networks to apply offset "
        +"(0 selects all networks)";
      }
      type uint32 {
        range "1300 .. 1999";
        tailf:info "<1300-1999>;;Access list of networks to apply offset "
        +"(expanded range)";
      }
    }
  }

  typedef offset-list-id-type {
    type union {
      type default-offset-list-id-type;
      type string {
        tailf:info "WORD;;Access-list name";
        pattern '[a-zA-Z].*';
      }
    }
  }

  typedef offset-list-in-out-type {
    type enumeration {
      enum in {
      tailf:info "Perform offset on incoming updates";
      }
      enum out {
      tailf:info "Perform offset on outgoing updates";
      }
    }
  }

  typedef isis-net {
    tailf:info "XX.XXXX. ... .XXX.XX;;Network entity title (NET)";
    type string {
      pattern "(([0-9a-fA-F]{2}\.[0-9a-fA-F]{4})|[0-9a-fA-F]{4})"
      +"\.([0-9a-fA-F]{4}\.){3,10}00";
    }
  }

  typedef isis-level-type {
    type enumeration {
      enum level-1 {
        tailf:info "Level-1 only";
      }
      enum level-1-2 {
        tailf:info "Level-1-2";
      }
      enum level-2 {
        tailf:info "Level-2 only";
      }
    }
  }

  typedef isis-routes-level-type {
    type enumeration {
      enum level-1 {
        tailf:info "IS-IS level-1 routes only";
      }
      enum level-1-2 {
        tailf:info "IS-IS level-1 and level-2 routes";
      }
      enum level-2 {
        tailf:info "IS-IS level-2 routes only";
      }
    }
  }

  typedef authentication-level-type {
    type enumeration {
      enum level-1 {
        tailf:info "ISIS authentication for level-1";
      }
      enum level-2 {
        tailf:info "ISIS authentication for level-2";
      }
    }
  }

  typedef logging-level-type {
    type union {
      type uint16 {
        tailf:info "<0-7>;;Logging severity level";
        range "0..7";
      }
      type enumeration {
        enum alerts {
          tailf:info "Immediate action needed (severity=1)";
        }
        enum critical {
          tailf:info "Critical conditions (severity=2)";
        }
        enum debugging {
          tailf:info "Debugging messages (severity=7)";
        }
        enum emergencies {
          tailf:info "System is unusable (severity=0)";
        }
        enum errors {
          tailf:info "Error conditions (severity=3)";
        }
        enum informational {
          tailf:info "Informational messages (severity=6)";
        }
        enum notifications {
          tailf:info "Normal but significant conditions "+
            "(severity=5)";
        }
        enum warnings {
          tailf:info "Warning conditions (severity=4)";
        }
      }
    }
  }

  typedef operator-type {
    type enumeration {
      enum eq {
        tailf:info "Equal to";
      }
      enum ge {
        tailf:info "Greater than or equal to";
      }
      enum gt {
        tailf:info "Greater than";
      }
      enum le {
        tailf:info "Less than or equal to";
      }
      enum lt {
        tailf:info "Less than";
      }
      enum ne {
        tailf:info "Not equal to";
      }
    }
  }

  typedef police-packets-bytes-type {
    type enumeration {
      enum packets {
        tailf:info "Treat 'burst' value as packets";
      }
      enum bytes {
        tailf:info "Treat 'burst' value as bytes";
      }
    }
  }

  typedef police-pps-bps-type {
    type enumeration {
      enum pps {
        tailf:info "pps  Treat 'rate' value in "+
          "packets-per-second";
      }
      enum bps {
        tailf:info "pps  Treat 'rate' value in "+
          "bytes-per-second";
      }
    }
  }

  // police target bit rate in bits per second (bps) type
  typedef police-bps-type {
    type uint64 {
      tailf:info "<8000-64000000000>;;Bits per second";
      range "8000..64000000000";
    }
  }

  typedef police-burst-type {
    type uint32 {
      tailf:info "<1000-512000000>;;Burst bytes";
      range "1000..512000000";
    }
  }

  // =========================================================================
  // GROUPING
  // =========================================================================

  // vrf-route-target-grouping
  grouping vrf-route-target-grouping {
    list "export" {
      tailf:info "Export Target-VPN community";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key asn-ip;
      leaf asn-ip {
        type asn-ip-type {
          tailf:info "ASN:nn or IP-address:nn;;Target VPN "+
            "Extended Community";
        }
      }
    }
    list "import" {
      tailf:info "Import Target-VPN community";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key asn-ip;
      leaf asn-ip {
        type asn-ip-type {
          tailf:info "ASN:nn or IP-address:nn;;Target VPN "+
            "Extended Community";
        }
      }
    }
  } // vrf-route-target-grouping


  // police {conform|exceed|violate}-action groupings
  grouping police-action-transmit-grouping {
    leaf transmit {
      tailf:info "transmit packet";
      type empty;
    }
  }
  grouping police-action-drop-grouping {
    leaf drop {
      tailf:info "drop packet";
      type empty;
    }
  }


  // Police conform action grouping
  grouping police-conform-action-grouping {
    container conform-set-clp-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container conform-action {
        tailf:info "action when rate is less than conform burst";
        tailf:cli-flatten-container;
        leaf set-clp-transmit {
          tailf:info "set atm clp and send it";
          type empty;
        }
      }
    }
    container conform-set-cos-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container conform-action {
        tailf:info "action when rate is less than conform burst";
        tailf:cli-flatten-container;
        leaf set-cos-transmit {
          tailf:info "rewrite packet cos and send it";
          type cos_value-type;
        }
      }
    }
    container conform-set-cos-transmit-table {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container conform-action {
        tailf:info "action when rate is less than conform burst";
        tailf:cli-compact-syntax;
        tailf:cli-flatten-container;
        tailf:cli-sequence-commands;
        leaf set-cos-transmit {
          tailf:info "rewrite packet cos and send it";
          type cos_value-type;
        }
        leaf table {
          tailf:info "Specify table-map";
          type leafref {
            path "/ios:table-map/name";
          }
        }
      }
    }
    container conform-set-discard-class-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container conform-action {
        tailf:info "action when rate is less than conform burst";
        tailf:cli-flatten-container;
        leaf set-discard-class-transmit {
          tailf:info "set discard-class and send it";
          type uint8 {
            tailf:info "<0-7>;;new discard-class";
            range "0..7";
          }
        }
      }
    }
    container conform-set-dscp-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container conform-action {
        tailf:info "action when rate is less than conform burst";
        tailf:cli-flatten-container;
        leaf set-dscp-transmit {
          tailf:info "set dscp and send it";
          type dscp-type;
        }
      }
    }
    container conform-set-dscp-transmit-table {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container conform-action {
        tailf:info "action when rate is less than conform burst";
        tailf:cli-compact-syntax;
        tailf:cli-flatten-container;
        tailf:cli-sequence-commands;
        leaf set-dscp-transmit {
          tailf:info "set dscp and send it";
          type dscp-type;
        }
        leaf table {
          tailf:info "Specify table-map";
          type leafref {
            path "/ios:table-map/name";
          }
        }
      }
    }
    container conform-set-frde-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container conform-action {
        tailf:info "action when rate is less than conform burst";
        tailf:cli-flatten-container;
        leaf set-frde-transmit {
          tailf:info "set FR DE and send it";
          type empty;
        }
      }
    }
    container conform-set-mpls-exp-imposition-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container conform-action {
        tailf:info "action when rate is less than conform burst";
        tailf:cli-flatten-container;
        leaf set-mpls-exp-imposition-transmit {
          tailf:info "set exp at tag imposition and send it";
          type exp_value-type;
        }
      }
    }
    container conform-set-mpls-exp-imposition-transmit-table {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container conform-action {
        tailf:info "action when rate is less than conform burst";
        tailf:cli-compact-syntax;
        tailf:cli-flatten-container;
        tailf:cli-sequence-commands;
        leaf set-mpls-exp-imposition-transmit {
          tailf:info "set exp at tag imposition and send it";
          type exp_value-type;
        }
        leaf table {
          tailf:info "Specify table-map";
          type leafref {
            path "/ios:table-map/name";
          }
        }
      }
    }
    container conform-set-mpls-exp-topmost-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container conform-action {
        tailf:info "action when rate is less than conform burst";
        tailf:cli-flatten-container;
        leaf set-mpls-exp-topmost-transmit {
          tailf:info "set exp on topmost label and send it";
          type exp_value-type;
        }
      }
    }
    container conform-set-mpls-exp-topmost-transmit-table {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container conform-action {
        tailf:info "action when rate is less than conform burst";
        tailf:cli-compact-syntax;
        tailf:cli-flatten-container;
        tailf:cli-sequence-commands;
        leaf set-mpls-exp-topmost-transmit {
          tailf:info "set exp on topmost label and send it";
          type exp_value-type;
        }
        leaf table {
          tailf:info "Specify table-map";
          type leafref {
            path "/ios:table-map/name";
          }
        }
      }
    }
    container conform-set-prec-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container conform-action {
        tailf:info "action when rate is less than conform burst";
        tailf:cli-flatten-container;
        leaf set-prec-transmit {
          tailf:info "rewrite packet precedence and send it";
          type prec_value-type;
        }
      }
    }
    container conform-set-prec-transmit-table {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container conform-action {
        tailf:info "action when rate is less than conform burst";
        tailf:cli-compact-syntax;
        tailf:cli-flatten-container;
        tailf:cli-sequence-commands;
        leaf set-prec-transmit {
          tailf:info "rewrite packet precedence and send it";
          type prec_value-type;
        }
        leaf table {
          tailf:info "Specify table-map";
          type leafref {
            path "/ios:table-map/name";
          }
        }
      }
    }
    container conform-set-qos-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container conform-action {
        tailf:info "action when rate is less than conform burst";
        tailf:cli-flatten-container;
        leaf set-qos-transmit {
          tailf:info "set qos-group and send it";
          type qos_value-type;
        }
      }
    }
    container conform-set-qos-transmit-table {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container conform-action {
        tailf:info "action when rate is less than conform burst";
        tailf:cli-compact-syntax;
        tailf:cli-flatten-container;
        tailf:cli-sequence-commands;
        leaf set-qos-transmit {
          tailf:info "set qos-group and send it";
          type qos_value-type;
        }
        leaf table {
          tailf:info "Specify table-map";
          type leafref {
            path "/ios:table-map/name";
          }
        }
      }
    }
    container conform-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container conform-action {
        tailf:info "action when rate is less than conform burst";
        tailf:cli-flatten-container;
        uses police-action-transmit-grouping;
      }
    }
    container conform-drop {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container conform-action {
        tailf:info "action when rate is less than conform burst";
        tailf:cli-flatten-container;
        uses police-action-drop-grouping;
      }
    }
  } // Police conform action grouping


  // Police exceed action grouping
  grouping police-exceed-action-grouping {
    container exceed-dscp {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container exceed-action {
        tailf:info "action when rate is within conform and "+
          "conform + exceed burst";
        tailf:cli-flatten-container;
        leaf dscp {
          //tailf:info
          type dscp-type;
        }
      }
    }
    container exceed-set-clp-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container exceed-action {
        tailf:info "action when rate is within conform and "+
          "conform + exceed burst";
        tailf:cli-flatten-container;
        leaf set-clp-transmit {
          tailf:info "set atm clp and send it";
          type empty;
        }
      }
    }
    container exceed-set-cos-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container exceed-action {
        tailf:info "action when rate is within conform and "+
          "conform + exceed burst";
        tailf:cli-flatten-container;
        leaf set-cos-transmit {
          tailf:info "rewrite packet cos and send it";
          type cos_value-type;
        }
      }
    }
    container exceed-set-discard-class-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container exceed-action {
        tailf:info "action when rate is within conform and "+
          "conform + exceed burst";
        tailf:cli-flatten-container;
        leaf set-discard-class-transmit {
          tailf:info "set discard-class and send it";
          type uint8 {
            tailf:info "<0-7>;;new discard-class";
            range "0..7";
          }
        }
      }
    }
    container exceed-set-dscp-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container exceed-action {
        tailf:info "action when rate is within conform and "+
          "conform + exceed burst";
        tailf:cli-flatten-container;
        leaf set-dscp-transmit {
          tailf:info "set dscp and send it";
          type dscp-type;
        }
      }
    }
    container exceed-set-frde-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container exceed-action {
        tailf:info "action when rate is within conform and "+
          "conform + exceed burst";
        tailf:cli-flatten-container;
        leaf set-frde-transmit {
          tailf:info "set FR DE and send it";
          type empty;
        }
      }
    }
    container exceed-set-mpls-exp-imposition-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container exceed-action {
        tailf:info "action when rate is within conform and "+
          "conform + exceed burst";
        tailf:cli-flatten-container;
        leaf set-mpls-exp-imposition-transmit {
          tailf:info "set exp at tag imposition and send it";
          type exp_value-type;
        }
      }
    }
    container exceed-set-mpls-exp-topmost-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container exceed-action {
        tailf:info "action when rate is within conform and "+
          "conform + exceed burst";
        tailf:cli-flatten-container;
        leaf set-mpls-exp-topmost-transmit {
          tailf:info "set exp on topmost label and send it";
          type exp_value-type;
        }
      }
    }
    container exceed-set-prec-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container exceed-action {
        tailf:info "action when rate is within conform and "+
          "conform + exceed burst";
        tailf:cli-flatten-container;
        leaf set-prec-transmit {
          tailf:info "rewrite packet precedence and send it";
          type prec_value-type;
        }
      }
    }
    container exceed-set-qos-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container exceed-action {
        tailf:info "action when rate is within conform and "+
          "conform + exceed burst";
        tailf:cli-flatten-container;
        leaf set-qos-transmit {
          tailf:info "set qos-group and send it";
          type qos_value-type;
        }
      }
    }
    container exceed-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container exceed-action {
        tailf:info "action when rate is within conform and "+
          "conform + exceed burst";
        tailf:cli-flatten-container;
        uses police-action-transmit-grouping;
      }
    }
    container exceed-drop {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container exceed-action {
        tailf:info "action when rate is within conform and "+
          "conform + exceed burst";
        tailf:cli-flatten-container;
        uses police-action-drop-grouping;
      }
    }
  }   // Police exceed action grouping


  // Police violate action grouping
  grouping police-violate-action-grouping {
    container violate-set-clp-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container violate-action {
        tailf:info "action when rate is greater than conform + "+
          "exceed burst";
        tailf:cli-flatten-container;
        leaf set-clp-transmit {
          tailf:info "set atm clp and send it";
          type empty;
        }
      }
    }
    container violate-set-cos-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container violate-action {
        tailf:info "action when rate is greater than conform + "+
          "exceed burst";
        tailf:cli-flatten-container;
        leaf set-cos-transmit {
          tailf:info "rewrite packet cos and send it";
          type cos_value-type;
        }
      }
    }
    container violate-set-discard-class-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container violate-action {
        tailf:info "action when rate is greater than conform + "+
          "exceed burst";
        tailf:cli-flatten-container;
        leaf set-discard-class-transmit {
          tailf:info "set discard-class and send it";
          type uint8 {
            tailf:info "<0-7>;;new discard-class";
            range "0..7";
          }
        }
      }
    }
    container violate-set-dscp-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container violate-action {
        tailf:info "action when rate is greater than conform + "+
          "exceed burst";
        tailf:cli-flatten-container;
        leaf set-dscp-transmit {
          tailf:info "set dscp and send it";
          type dscp-type;
        }
      }
    }
    container violate-set-frde-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container violate-action {
        tailf:info "action when rate is greater than conform + "+
          "exceed burst";
        tailf:cli-flatten-container;
        leaf set-frde-transmit {
          tailf:info "set FR DE and send it";
          type empty;
        }
      }
    }
    container violate-set-mpls-exp-imposition-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container violate-action {
        tailf:info "action when rate is greater than conform + "+
          "exceed burst";
        tailf:cli-flatten-container;
        leaf set-mpls-exp-imposition-transmit {
          tailf:info "set exp at tag imposition and send it";
          type exp_value-type;
        }
      }
    }
    container violate-set-mpls-exp-topmost-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container violate-action {
        tailf:info "action when rate is greater than conform + "+
          "exceed burst";
        tailf:cli-flatten-container;
        leaf set-mpls-exp-topmost-transmit {
          tailf:info "set exp on topmost label and send it";
          type exp_value-type;
        }
      }
    }
    container violate-set-prec-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container violate-action {
        tailf:info "action when rate is greater than conform + "+
          "exceed burst";
        tailf:cli-flatten-container;
        leaf set-prec-transmit {
          tailf:info "rewrite packet precedence and send it";
          type prec_value-type;
        }
      }
    }
    container violate-set-qos-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container violate-action {
        tailf:info "action when rate is greater than conform + "+
          "exceed burst";
        tailf:cli-flatten-container;
        leaf set-qos-transmit {
          tailf:info "set qos-group and send it";
          type qos_value-type;
        }
      }
    }
    container violate-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container violate-action {
        tailf:info "action when rate is greater than conform + "+
          "exceed burst";
        tailf:cli-flatten-container;
        uses police-action-transmit-grouping;
      }
    }
    container violate-drop {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container violate-action {
        tailf:info "action when rate is greater than conform + "+
          "exceed burst";
        tailf:cli-flatten-container;
        uses police-action-drop-grouping;
      }
    }
  } // Police violate action grouping


  // police-action-grouping
  grouping police-action-grouping {
    container actions {
      tailf:cli-break-sequence-commands;
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      // policy-map * / class * / police ? / conform-action
      uses police-conform-action-grouping;
      // policy-map * / class * / police ? / exceed-action
      uses police-exceed-action-grouping;
      // policy-map * / class * / police ? / violate-action
      uses police-violate-action-grouping;
    }
  }   // police-action-grouping


  // password-grouping
  grouping password-grouping {
    //tailf:info "Configure encryption password (key)";
    container password-container {
      tailf:cli-compact-syntax;
      tailf:cli-flatten-container;
      tailf:cli-sequence-commands;
      tailf:cli-drop-node-name;
      leaf encryption {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        tailf:cli-optional-in-sequence;
        type uint8 {
          range "0..7";
          tailf:info "<0-7>;;Encryption type (0 to disable"+
            " encryption, 7 for proprietary)";
        }
        default "0";
      }
      leaf password {
        tailf:cli-drop-node-name;
        tailf:cli-trim-default;
        type string {
          pattern "([1-680-9a-zA-Z].*)|(0.+)|(7.+)";
          //length "1..80";
          tailf:info "LINE;;The password";
        }
      }
    }
  } // password-grouping


  // distribute-list-grouping
  grouping distribute-list-grouping {
    container distribute-list {
      tailf:info "Filter networks in routing updates";
      list accesslist {
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-suppress-list-no;
        key in-out;
        leaf in-out {
          type access-list-in-out-type;
        }
      }
      list accesslist-ifname {
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-suppress-list-no;
        tailf:cli-diff-dependency "/ios:interface";
        key "in-out interface";
        leaf in-out {
          type access-list-in-out-type;
        }
        leaf interface {
          tailf:cli-expose-key-name;
          tailf:info "Interface";
          // Note: interface name must be type string since part of key
          type string {
            tailf:info "WORD;;Interface name";
          }
        }
      }
      list accesslist-prefix-gateway {
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-suppress-list-no;
        tailf:cli-sequence-commands;
        key in-out;
        leaf prefix-gateway {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          mandatory true;
          tailf:cli-prefix-key;
          type enumeration {
            enum prefix {
            tailf:info "Filter prefixes in routing updates";
            }
            enum gateway {
            tailf:info "Filtering incoming updates based on gateway";
            }
          }
        }
        leaf name {
          tailf:cli-drop-node-name;
          mandatory true;
          tailf:cli-prefix-key;
          tailf:cli-disallow-value "in|out";
          type string {
            tailf:info "WORD;;Name of an IP prefix-list";
          }
        }
        leaf in-out {
          type access-list-in-out-type;
        }
      }

      list accesslist-prefix-gateway-ifname {
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-suppress-list-no;
        tailf:cli-sequence-commands;
        key "in-out interface";
        leaf prefix-gateway {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          mandatory true;
          tailf:cli-prefix-key;
          type enumeration {
            enum prefix {
            tailf:info "Filter prefixes in routing updates";
            }
            enum gateway {
            tailf:info "Filtering incoming updates based on gateway";
            }
          }
        }
        leaf name {
          tailf:cli-drop-node-name;
          mandatory true;
          tailf:cli-prefix-key;
          tailf:cli-disallow-value "in|out";
          type string {
            tailf:info "WORD;;Name of an IP prefix-list";
          }
        }
        leaf in-out {
          type access-list-in-out-type;
        }
        // FIXME: interface container
        leaf interface {
          tailf:cli-expose-key-name;
          tailf:info "Interface";
          type string {
            tailf:info "WORD;;Interface name";
          }
        }
      }
    }
  } // distribute-list-grouping


  // passive-interface-grouping
  grouping passive-interface-grouping {
    container passive-interface {
      tailf:info "Suppress routing updates on an interface";
      choice passive-interface-choice {
        leaf "default" {
          tailf:info "Suppress routing updates on all interfaces";
          type empty;
        }
        leaf interface {
          tailf:cli-drop-node-name;
          tailf:cli-multi-value;
          type string {
            tailf:info "WORD;;Interface name";
          }
        }
      }
    }
    // Fix to handle showing "no passive-interface <interface name>"
    // when passive-interface default is configured
    // this is filtered out in the NED java code
    container disable {
      when "../passive-interface/default";
      list passive-interface {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key interface;
        leaf interface {
          tailf:cli-drop-node-name;
          tailf:cli-multi-word-key;
          type string {
            tailf:info "WORD;;Interface name";
          }
        }
      }
    }
  } // passive-interface-grouping


  // interface-grouping - all interface lists collected
  grouping interface-grouping {
    choice interface-choice {

      //  Async               Async interface
      //  Auto-Template       Auto-Template interface
      //  CTunnel             CTunnel interface
      //  Dialer              Dialer interface
      //  EsconPhy            ESCON interface

      leaf Embedded-Service-Engine {
        tailf:info "cisco embedded service engine module";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string;
        tailf:non-strict-leafref {
          path "/ios:interface/Embedded-Service-Engine/name";
        }
      }

      leaf FastEthernet {
        tailf:info "FastEthernet IEEE 802.3";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string;
        tailf:non-strict-leafref {
          path "/ios:interface/FastEthernet/name";
        }
      }

      //  Fcpa                Fiber Channel
      //  Filter              Filter interface
      //  Filtergroup         Filter Group interface
      //  GMPLS               MPLS interface

      leaf GigabitEthernet {
        tailf:info "GigabitEthernet IEEE 802.3z";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string;
        tailf:non-strict-leafref {
          path "/ios:interface/GigabitEthernet/name";
        }
      }

      //  LongReachEthernet   Long-Reach Ethernet interface

      leaf Loopback {
        tailf:info "Loopback interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string;
        tailf:non-strict-leafref {
          path "/ios:interface/Loopback/name";
        }
      }

      //  Lspvif              LSP virtual interface
      //  MFR                 Multilink Frame Relay bundle interface

      leaf Multilink {
        tailf:info "Multilink-group interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint16;
        tailf:non-strict-leafref {
          path "/ios:interface/Multilink/name";
        }
      }

      // Null                Null interface

      leaf Port-channel {
        tailf:info "Ethernet Channel of interfaces";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint32;
        tailf:non-strict-leafref {
          path "/ios:interface/Port-channel/name";
        }
      }

      //  Portgroup           Portgroup interface
      //  Pos-channel         POS Channel of interfaces
      //  SYSCLOCK            Telecom-Bus Clock Controlle

      leaf Serial {
        tailf:info "Serial interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string;
        tailf:non-strict-leafref {
          path "/ios:interface/Serial/name";
        }
      }

      leaf TenGigabitEthernet {
        tailf:info "Ten Gigabit Ethernet";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string;
        tailf:non-strict-leafref {
          path "/ios:interface/TenGigabitEthernet/name";
        }
      }

      //  Tunnel              Tunnel interface
      //  Vif                 PGM Multicast Host interface
      //  Virtual-Ethernet    Virtual Ethernet interface
      leaf Virtual-Template {
        tailf:info "Virtual Template interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint16 {
          tailf:info "<1-4095>;;Virtual-Template interface number";
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Virtual-Template/name";
        }
      }
      //  Virtual-TokenRing   Virtual TokenRing

      leaf Vlan {
        tailf:info "Iosxr Vlans";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint16;
        tailf:non-strict-leafref {
          path "/ios:interface/Vlan/name";
        }
      }

      //  VoaBypassIn         VOA-Bypass-In interface
      //  VoaBypassOut        VOA-Bypass-Out interface
      //  VoaFilterIn         VOA-Filter-In interface
      //  VoaFilterOut        VOA-Filter-Out interface
      //  VoaIn               VOA-In interface
      //  VoaOut              VOA-Out interface
    }
  } // interface-grouping - all interface lists collected


  // ethernet-grouping
  grouping ethernet-grouping {
    choice ethernet-choice {
      leaf FastEthernet {
        tailf:info "FastEthernet IEEE 802.3";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string;
        tailf:non-strict-leafref {
          path "/ios:interface/FastEthernet/name";
        }
      }
      leaf GigabitEthernet {
        tailf:info "GigabitEthernet IEEE 802.3z";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string;
        tailf:non-strict-leafref {
          path "/ios:interface/GigabitEthernet/name";
        }
      }
      leaf Port-channel {
        tailf:info "Ethernet Channel of interfaces";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint32;
        tailf:non-strict-leafref {
          path "/ios:interface/Port-channel/name";
        }
      }
      leaf TenGigabitEthernet {
        tailf:info "Ten Gigabit Ethernet";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string;
        tailf:non-strict-leafref {
          path "/ios:interface/TenGigabitEthernet/name";
        }
      }
    }
  }

  // ip-community-list-standard-grouping
  grouping ip-community-list-standard-grouping {
    container deny {
      tailf:info "Specify community to reject";
      presence "Specify community to reject";
      list deny-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key expr;
        leaf expr {
          tailf:cli-multi-word-key {
            tailf:cli-max-words 10;
          }
          type string {
            tailf:info "<1-4294967295>  community number
            aa:nn           community number
            internet        Internet (well-known community)
            local-AS        Do not send outside local AS (well-known community)
            no-advertise    Do not advertise to any peer (well-known community)
            no-export       Do not export to next AS (well-known community)
            ";
            pattern '((internet)|(local\-AS)|(no\-advertise)|'
              +'(no\-export)|(\d+:\d+)|(\d+))'
              +'( (internet)|(local\-AS)|'
              +'(no\-advertise)|(no\-export)|(\d+:\d+)|(\d+))*';
          }
        }
      }
    }

    container permit {
      tailf:info "Specify community to accept";
      presence "Specify community to accept";
      list permit-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key expr;
        leaf expr {
          tailf:cli-multi-word-key {
            tailf:cli-max-words 10;
          }
          type string {
            tailf:info "<1-4294967295>  community number
            aa:nn           community number
            internet        Internet (well-known community)
            local-AS        Do not send outside local AS (well-known community)
            no-advertise    Do not advertise to any peer (well-known community)
            no-export       Do not export to next AS (well-known community)
            ";
            pattern '((internet)|(local-AS)|(no-advertise)|'
              +'(no-export)|(\d+:\d+)|(\d+))( (internet)|'
              +'(local-AS)|(no-advertise)|(no-export)|'
              +'(\d+:\d+)|(\d+))*';
          }
        }
      }
    }
  }

  // ip-community-list-expanded-grouping
  grouping ip-community-list-expanded-grouping {
    container deny {
      tailf:info "Specify community to reject";
      presence "Specify community to reject";
      list deny-list {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-drop-node-name;
        key expr;
        leaf expr {
          tailf:info "LINE;;An ordered list as a regular-expression";
          tailf:cli-multi-word-key {
            tailf:cli-max-words 10;
          }
          type string;
        }
      }
    }
    container permit {
      tailf:info "Specify community to accept";
      presence "Specify community to accept";
      list permit-list {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-drop-node-name;
        key expr;
        leaf expr {
          tailf:info "LINE;;An ordered list as a regular-expression";
          tailf:cli-multi-word-key {
            tailf:cli-max-words 10;
          }
          type string;
        }
      }
    }
  }

  // ip-route-options-grouping
  grouping ip-route-options-grouping {
    leaf metric {
      tailf:cli-drop-node-name;
      tailf:cli-break-sequence-commands;
      type uint8 {
        tailf:info "<1-255>;;Distance metric for this route";
        range "1..255";
      }
    }
    leaf global {
      tailf:info "Next hop address is global";
      type empty;
    }
    leaf name {
      tailf:info "Specify name of the next hop";
      type string {
        tailf:info "WORD;;Name of the next hop";
      }
    }
    leaf permanent {
      tailf:info "permanent route";
      type empty;
    }
    leaf multicast {
      tailf:info "multicast route";
      type empty;
    }
    leaf dhcp {
      tailf:info "Default Gateway obtained from DHCP";
      tailf:cli-case-insensitive;
      type empty;
    }
    leaf tag {
      tailf:info "Set tag for this route";
      type uint32 {
        tailf:info "<1-4294967295>;;Tag value";
        range "1..4294967295";
      }
    }
    leaf track {
      tailf:info "Install route depending on tracked item";
      type uint16 {
        tailf:info "<1-500>;;tracked object number";
        range "1..500";
      }
    }
  }

  // ip-route-grouping
  grouping ip-route-grouping {
    list ip-route-interface-forwarding-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      key "prefix mask interface forwarding-address";
      leaf "prefix" {
        tailf:cli-disallow-value "vrf";
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Destination prefix";
        }
      }
      leaf mask {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Destination prefix mask";
        }
      }
      leaf interface {
        tailf:cli-diff-dependency "/ios:interface";
        type string {
          tailf:info "WORD;;Interface name";
        }
      }
      leaf forwarding-address {
        type union {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Forwarding router's address";
          }
          type enumeration {
            enum multicast {
               tailf:info "multicast route";
            }
          }
        }
      }
      uses ip-route-options-grouping;
    }
    list ip-route-forwarding-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      key "prefix mask forwarding-address";
      leaf "prefix" {
        tailf:cli-disallow-value "vrf";
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Destination prefix";
        }
      }
      leaf mask {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Destination prefix mask";
        }
      }
      leaf forwarding-address {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Forwarding router's address";
        }
      }
      uses ip-route-options-grouping;
    }
    list ip-route-interface-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      key "prefix mask interface";
      leaf "prefix" {
        tailf:cli-disallow-value "vrf";
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Destination prefix";
        }
      }
      leaf mask {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Destination prefix mask";
        }
      }
      leaf interface {
        tailf:cli-diff-dependency "/ios:interface";
        tailf:cli-case-insensitive;
        type union {
          type string {
            tailf:info "WORD;;Interface name";
          }
          type enumeration {
            enum dhcp {
              tailf:info "Default Gateway obtained from DHCP";
            }
          }
        }
      }
      uses ip-route-options-grouping;
    }
  }

  // ipv6-route-options-grouping
  grouping ipv6-route-options-grouping {
    leaf distance {
      tailf:cli-drop-node-name;
      type uint8 {
        tailf:info "<1-254>;;Administrative distance";
      }
    }
    choice type-choice {
      leaf multicast {
        tailf:info "Route only usable by multicast";
        tailf:cli-full-command;
        type empty;
      }
      leaf unicast {
        tailf:info "Route only usable by unicast";
        type empty;
      }
    }
    leaf tag {
      tailf:info "Tag value";
      tailf:cli-full-command;
      type uint32 {
        tailf:info "<0-4294967295>  Tag value";
      }
    }
  }

  // ipv6-route-entry-grouping
  grouping ipv6-route-entry-grouping {
    list ipv6-destination-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      key destination;
      leaf destination {
        type inet:ipv6-address {
          tailf:info "X:X:X:X::X;;IPv6 address of next-hop";
        }
      }
      uses ipv6-route-options-grouping;
    }
  }

  // ipv6-route-grouping
  grouping ipv6-route-grouping {
    list ipv6-route-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      tailf:cli-incomplete-command;
      key prefix;
      leaf prefix {
        type ipv6-prefix {
          tailf:info "X:X:X:X::X/<0-128>;;IPv6 prefix x:x::y/<z>";
        }
      }
      uses ipv6-route-entry-grouping;
      list FastEthernet {
        tailf:info "FastEthernet IEEE 802.3";
        tailf:cli-allow-join-with-key {
          tailf:cli-display-joined;
        }
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        key name;
        leaf name {
          type string {
            // pattern "([0-9])+/([0-9])+(/([0-9])+)?";
            tailf:info "<0-66>/<0-128>;;FastEthernet interface number";
          }
        }
        uses ipv6-route-entry-grouping;
        uses ipv6-route-options-grouping;
      }
      list Null {
        tailf:info "Null interface";
        tailf:cli-allow-join-with-key {
          tailf:cli-display-joined;
        }
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        key name;
        leaf name {
          type enumeration {
            enum 0 {
              tailf:info "<0-0>;;Null interface number";
            }
          }
        }
        uses ipv6-route-entry-grouping;
        uses ipv6-route-options-grouping;
      }
      //FIXME: More interfaces here. Or rework?
    }
  }

  // random-detect-grouping
  grouping random-detect-grouping {
    leaf min-threshold {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type uint16 {
        range "1..4096";
        tailf:info "<1-4096>;;minimum threshold (number of packets)";
      }
    }
    leaf max-threshold {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type uint16 {
        range "1..4096";
        tailf:info "<1-4096>;;maximum threshold (number of packets)";
      }
    }
    leaf denominator {
      tailf:cli-drop-node-name;
      type uint32 {
        range "1..65535";
        tailf:info "<1-65535>;;mark probability denominator";
      }
    }
  }

  // class-map-match-grouping
  grouping class-map-match-grouping {
    // class-map * / match access-group
    container access-group {
      tailf:info "Access group";
      leaf index {
        tailf:cli-drop-node-name;
        type uint32 {
          range "1..2699" {
            tailf:info "<1-2699>;;Access list index";
          }
        }
      }
      leaf-list name {
        tailf:info "Named Access List";
        tailf:cli-list-syntax;
        type string {
          tailf:info "WORD;;Access List name";
        }
      }
    }
    // class-map * / match any
    leaf any {
      tailf:info "Any packets";
      type empty;
    }
    // class-map * / match class-map
    leaf-list class-map {
      tailf:info "Class map";
      tailf:cli-list-syntax;
      type leafref {
        path "/ios:class-map/name";
        // tailf:info "WORD;;Match class-map name";
      }
    }
    // class-map * / match cos
    leaf-list cos {
      tailf:info "IEEE 802.1Q/ISL class of service/user priority values";
      tailf:cli-flat-list-syntax;
      type uint16 {
        range "0..7";
        tailf:info "<0-7>;;Enter up to 4 class-of-service values"+
          " separated by white-spaces";
      }
    }
    // class-map * / match destination-address
    container destination-address {
      tailf:info "Destination address";
      leaf-list mac {
        tailf:info "MAC address";
        tailf:cli-list-syntax;
        type string {
          tailf:info "H.H.H;;MAC address";
        }
      }
    }
    // class-map * / discard-class
    leaf-list discard-class {
      tailf:info "Discard behavior identifier";
      tailf:cli-list-syntax;
      type uint16 {
        range "0..7";
        tailf:info "<0-7>;;Discard Class value";
      }
    }
    // class-map * / dscp
    leaf-list dscp {
      tailf:info "Match DSCP in IP(v4) and IPv6 packets";
      tailf:cli-list-syntax;
      type dscp-type;
    }
    // class-map * / fr-de
    leaf fr-de {
      tailf:info "Match on Frame-relay DE bit";
      type empty;
    }
    // class-map * / fr-dlci
    leaf-list fr-dlci {
      tailf:info "Match on fr-dlci";
      tailf:cli-list-syntax;
      type uint16 {
        range "16..1007";
        tailf:info "<16-1007>;;frame-relay dlci number";
      }
    }
    // class-map * / input-interface
    leaf-list input-interface {
      tailf:info "Select an input interface to match";
      tailf:cli-list-syntax;
      //FIXME: interface dependency
      type string;
    }
    // class-map * / ip
    container ip {
      tailf:info "IP specific values";
      // class-map * / ip dscp
      leaf-list dscp {
        tailf:info "Match IP DSCP (DiffServ CodePoints)";
        tailf:cli-flat-list-syntax;
        type dscp-type;
      }
      // class-map * / ip precedence
      leaf-list precedence {
        tailf:info "Match IP precedence";
        tailf:cli-flat-list-syntax;
        type precedence-type;
      }
      // class-map * / ip rtp
      list rtp {
        tailf:info "Match RTP port nos";
        key "port1 port2";
        leaf port1 {
          type uint16 {
            range "2000..65535";
            tailf:info "<2000-65535>;;Lower bound of UDP"+
              " destination port";
          }
        }
        leaf port2 {
          type uint16 {
            range "0..16383";
            tailf:info "<0-16383>;;Range of UDP ports";
          }
        }
      }
    }
    // class-map * / mpls
    container mpls {
      tailf:info "Multi Protocol Label Switching specific values";
      container experimental {
        tailf:info "Match MPLS experimental";
        leaf-list topmost {
          tailf:info "Match MPLS experimental value on topmost label";
          tailf:cli-flat-list-syntax;
          type uint16 {
            range "0..7";
            tailf:info "<0-7>;;Enter up to 8 experimental values "+
              "separated by white-spaces";
          }
        }
      }
    }
    // class-map * / packet
    container packet {
      tailf:info "Layer 3 Packet length";
      container "length" {
        tailf:info "Layer 3 Packet length";
        leaf max {
          tailf:info "Maximum length of packet";
          type uint16 {
            range "1..2000";
            tailf:info "<1-2000>;;Packet length in bytes";
          }
        }
        leaf min {
          tailf:info "Minimum length of packet";
          type uint16 {
            range "1..2000";
            tailf:info "<1-2000>;;Packet length in bytes";
          }
        }
      }
    }
    // class-map * / precedence
    leaf-list precedence {
      tailf:info "Match Precedence in IP(v4) and IPv6 packets";
      tailf:cli-flat-list-syntax;
      type precedence-type;
    }
    // class-map * / protocol
    container protocol {
      tailf:info "Protocol";
      leaf x802-11-iapp {
        tailf:info "IEEE 802.11 WLANs WG IAPP";
        tailf:alt-name "802-11-iapp";
        type empty;
      }
      leaf ace-svr {
        tailf:info "ACE Server/Propagation";
        type empty;
      }
      leaf aol {
        tailf:info "America-Online Instant Messenger";
        type empty;
      }
      leaf appleqtc {
        tailf:info "Apple QuickTime";
        type empty;
      }
      leaf biff {
        tailf:info "Bliff mail notification";
        type empty;
      }
      leaf bittorrent {
        tailf:info "bittorrent";
        type empty;
      }
      leaf bootpc {
        tailf:info "Bootstrap Protocol Client";
        type empty;
      }
      leaf bootps {
        tailf:info "Bootstrap Protocol Server";
        type empty;
      }
      leaf cddbp {
        tailf:info "CD Database Protocol";
        type empty;
      }
      leaf cifs {
        tailf:info "CIFS";
        type empty;
      }
      leaf cisco-fna {
        tailf:info "Cisco FNATIVE";
        type empty;
      }
      leaf cisco-net-mgmt {
        tailf:info "cisco-net-mgmt";
        type empty;
      }
      leaf cisco-svcs {
        tailf:info "cisco license/perf/GDP/X.25/ident svcs";
        type empty;
      }
      leaf cisco-sys {
        tailf:info "Cisco SYSMAINT";
        type empty;
      }
      leaf cisco-tdp {
        tailf:info "Cisco TDP";
        type empty;
      }
      leaf cisco-tna {
        tailf:info "Cisco TNATIVE";
        type empty;
      }
      leaf citriximaclient {
        tailf:info "Citrix IMA Client";
        type empty;
      }
      leaf clp {
        tailf:info "Cisco Line Protocol";
        type empty;
      }
      leaf creativepartnr {
        tailf:info "Creative Partnr";
        type empty;
      }
      leaf creativeserver {
        tailf:info "Creative Server";
        type empty;
      }
      leaf daytime {
        tailf:info "Daytime (RFC 867)";
        type empty;
      }
      leaf dbase {
        tailf:info "dBASE Unix";
        type empty;
      }
      leaf dbcontrol_agent {
        tailf:info "Oracle dbControl Agent po";
        type empty;
      }
      leaf ddns-v3 {
        tailf:info "Dynamic DNS Version 3";
        type empty;
      }
      leaf dhcp-failover {
        tailf:info "DHCP Failover";
        type empty;
      }
      leaf directconnect {
        tailf:info "Direct Connect Version 2.0";
        type empty;
      }
      leaf discard {
        tailf:info "Discard port";
        type empty;
      }
      leaf dnsix {
        tailf:info "DNSIX Securit Attribute Token Map";
        type empty;
      }
      leaf echo {
        tailf:info "Echo port";
        type empty;
      }
      leaf entrust-svc-hdlr {
        tailf:info "Entrust KM/Admin Service Handler";
        type empty;
      }
      leaf entrust-svcs {
        tailf:info "Entrust sps/aaas/aams";
        type empty;
      }
      leaf exec {
        tailf:info "Remote Process Execution";
        type empty;
      }
      leaf fcip-port {
        tailf:info "FCIP";
        type empty;
      }
      leaf ftps {
        tailf:info "FTP over TLS/SSL";
        type empty;
      }
      leaf gdoi {
        tailf:info "GDOI";
        type empty;
      }
      leaf giop {
        tailf:info "Oracle GIOP/SSL";
        type empty;
      }
      leaf gtpv0 {
        tailf:info "GPRS Tunneling Protocol Version 0";
        type empty;
      }
      leaf gtpv1 {
        tailf:info "GPRS Tunneling Protocol Version 1";
        type empty;
      }
      leaf h225ras {
        tailf:info "H225 RAS over Unicast";
        type empty;
      }
      leaf h323callsigalt {
        tailf:info "h323 Call Signal Alternate";
        type empty;
      }
      leaf hp-alarm-mgr {
        tailf:info "HP Performance data alarm manager";
        type empty;
      }
      leaf hp-collector {
        tailf:info "HP Performance data collector";
        type empty;
      }
      leaf hp-managed-node {
        tailf:info "HP Performance data managed node";
        type empty;
      }
      leaf hsrp {
        tailf:info "Hot Standby Router Protocol";
        type empty;
      }
      leaf https {
        tailf:info "Secure Hypertext Transfer Protocol";
        type empty;
      }
      leaf ica {
        tailf:info "ica (Citrix)";
        type empty;
      }
      leaf icabrowser {
        tailf:info "icabrowser (Citrix)";
        type empty;
      }
      leaf ident {
        tailf:info "Authentication Service";
        type empty;
      }
      leaf igmpv3lite {
        tailf:info "IGMP over UDP for SSM";
        type empty;
      }
      leaf imap3 {
        tailf:info "Interactive Mail Access Protocol 3";
        type empty;
      }
      leaf imaps {
        tailf:info "IMAP over TLS/SSL";
        type empty;
      }
      leaf ipass {
        tailf:info "IPASS";
        type empty;
      }
      leaf ipsec-msft {
        tailf:info "Microsoft IPsec NAT-T";
        type empty;
      }
      leaf irc-serv {
        tailf:info "IRC-SERV";
        type empty;
      }
      leaf ircs {
        tailf:info "IRC over TLS/SSL";
        type empty;
      }
      leaf ircu {
        tailf:info "IRCU";
        type empty;
      }
      leaf isakmp {
        tailf:info "ISAKMP";
        type empty;
      }
      leaf iscsi {
        tailf:info "iSCSI";
        type empty;
      }
      leaf iscsi-target {
        tailf:info "iSCSI port";
        type empty;
      }
      leaf kermit {
        tailf:info "kermit";
        type empty;
      }
      leaf ldap-admin {
        tailf:info "LDAP admin server port";
        type empty;
      }
      leaf ldaps {
        tailf:info "LDAP over TLS/SSL";
        type empty;
      }
      leaf login {
        tailf:info "Remote login";
        type empty;
      }
      leaf lotusmtap {
        tailf:info "Lotus Mail Tracking Agent Protocol";
        type empty;
      }
      leaf lotusnote {
        tailf:info "Lotus Note";
        type empty;
      }
      leaf microsoft-ds {
        tailf:info "Microsoft-DS";
        type empty;
      }
      leaf ms-cluster-net {
        tailf:info "MS Cluster Net";
        type empty;
      }
      leaf ms-dotnetster {
        tailf:info "Microsoft .NETster Port";
        type empty;
      }
      leaf ms-sna {
        tailf:info "Microsoft SNA Server/Base";
        type empty;
      }
      leaf ms-sql {
        tailf:info "Microsoft SQL";
        type empty;
      }
      leaf ms-sql-m {
        tailf:info "Microsoft SQL Monitor";
        type empty;
      }
      leaf msexch-routing {
        tailf:info "Microsoft Exchange Routing";
        type empty;
      }
      leaf msnmsgr {
        tailf:info "MSN Instant Messenger";
        type empty;
      }
      leaf msrpc {
        tailf:info "Microsoft Remote Procedure Call";
        type empty;
      }
      leaf mysql {
        tailf:info "MySQL";
        type empty;
      }
      leaf n2h2server {
        tailf:info "N2H2 Filter Service Port";
        type empty;
      }
      leaf ncp {
        tailf:info "NCP (Novell)";
        type empty;
      }
      leaf net8-cman {
        tailf:info "Oracle Net8 Cman/Admin";
        type empty;
      }
      leaf netbios-dgm {
        tailf:info "NETBIOS Datagram Service";
        type empty;
      }
      leaf netbios-ns {
        tailf:info "NETBIOS Name Service";
        type empty;
      }
      leaf netbios-ssn {
        tailf:info "NETBIOS Session Service";
        type empty;
      }
      leaf netstat {
        tailf:info "Variant of systat";
        type empty;
      }
      leaf oem-agent {
        tailf:info "OEM Agent (Oracle)";
        type empty;
      }
      leaf oracle {
        tailf:info "Oracle";
        type empty;
      }
      leaf oracle-em-vp {
        tailf:info "Oracle EM/VP";
        type empty;
      }
      leaf oraclenames {
        tailf:info "Oracle Names";
        type empty;
      }
      leaf orasrv {
        tailf:info "Oracle SQL*Net v1/v2";
        type empty;
      }
      leaf pcanywheredata {
        tailf:info "pcANYWHEREdata";
        type empty;
      }
      leaf pcanywherestat {
        tailf:info "pcANYWHEREstat";
        type empty;
      }
      leaf pop3s {
        tailf:info "POP3 over TLS/SSL";
        type empty;
      }
      leaf pwdgen {
        tailf:info "Password  Generator Protocol";
        type empty;
      }
      leaf qmtp {
        tailf:info "Quick Mail Transfer Protocol";
        type empty;
      }
      leaf r-winsock {
        tailf:info "remote-winsock";
        type empty;
      }
      leaf radius {
        tailf:info "RADIUS & Accounting";
        type empty;
      }
      leaf rdb-dbs-disp {
        tailf:info "Oracle RDB";
        type empty;
      }
      leaf realmedia {
        tailf:info "RealNetwork's Realmedia Protocol";
        type empty;
      }
      leaf realsecure {
        tailf:info "ISS Real Secure Console Service Port";
        type empty;
      }
      leaf router {
        tailf:info "Local Routing Process";
        type empty;
      }
      leaf rsvp-encap {
        tailf:info "RSVP ENCAPSULATION-1/2";
        type empty;
      }
      leaf rsvp_tunnel {
        tailf:info "RSVP Tunnel";
        type empty;
      }
      leaf rtc-pm-port {
        tailf:info "Oracle RTC-PM port";
        type empty;
      }
      leaf rtelnet {
        tailf:info "Remote Telnet Service";
        type empty;
      }
      leaf send {
        tailf:info "SEND";
        type empty;
      }
      leaf shell {
        tailf:info "Remote command";
        type empty;
      }
      leaf sip-tls {
        tailf:info "SIP-TLS";
        type empty;
      }
      leaf sms {
        tailf:info "SMS RCINFO/XFER/CHAT";
        type empty;
      }
      leaf snmptrap {
        tailf:info "SNMP Trap";
        type empty;
      }
      leaf sql-net {
        tailf:info "SQL-NET";
        type empty;
      }
      leaf sqlserv {
        tailf:info "SQL Services";
        type empty;
      }
      leaf sqlsrv {
        tailf:info "SQL Service";
        type empty;
      }
      leaf sshell {
        tailf:info "SSLshell";
        type empty;
      }
      leaf ssp {
        tailf:info "State Sync Protocol";
        type empty;
      }
      leaf syslog-conn {
        tailf:info "Reliable Syslog Service";
        type empty;
      }
      leaf tacacs {
        tailf:info "Login Host Protocol (TACACS)";
        type empty;
      }
      leaf tacacs-ds {
        tailf:info "TACACS-Database Service";
        type empty;
      }
      leaf tarantella {
        tailf:info "Tarantella";
        type empty;
      }
      leaf tcp {
        tailf:info "TCP";
        type empty;
      }
      leaf telnets {
        tailf:info "Telnet over TLS/SSL";
        type empty;
      }
      leaf time {
        tailf:info "Time";
        type empty;
      }
      leaf timed {
        tailf:info "Time server";
        type empty;
      }
      leaf tr-rsrb {
        tailf:info "cisco RSRB";
        type empty;
      }
      leaf ttc {
        tailf:info "Oracle TTC/SSL";
        type empty;
      }
      leaf udp {
        tailf:info "UDP";
        type empty;
      }
      leaf uucp {
        tailf:info "UUCPD/UUCP-RLOGIN";
        type empty;
      }
      leaf vqp {
        tailf:info "VQP";
        type empty;
      }
      leaf webster {
        tailf:info "Network Disctionary";
        type empty;
      }
      leaf who {
        tailf:info "Who's service";
        type empty;
      }
      leaf wins {
        tailf:info "Microsoft WINS";
        type empty;
      }
      leaf x11 {
        tailf:info "X Window System";
        type empty;
      }
      leaf xdmcp {
        tailf:info "XDM Control Protocol";
        type empty;
      }
      leaf ymsgr {
        tailf:info "Yahoo! Instant Messenger";
        type empty;
      }
      leaf aarp {
        tailf:info "AppleTalk ARP";
        type empty;
      }
      leaf appletalk {
        tailf:info "AppleTalk";
        type empty;
      }
      leaf arp {
        tailf:info "IP ARP";
        type empty;
      }
      leaf bgp {
        tailf:info "Border Gateway Protocol";
        type empty;
      }
      leaf bridge {
        tailf:info "Bridging";
        type empty;
      }
      leaf bstun {
        tailf:info "Block Serial Tunnel";
        type empty;
      }
      leaf cdp {
        tailf:info "Cisco Discovery Protocol";
        type empty;
      }
      container citrix {
        tailf:info "Citrix Systems ICA protocol";
        presence "enable citrix system protocol matching";
        leaf ica-tag {
          tailf:info "Citrix ICA tag 0-high 1-medium 2-low "+
            "3-background";
          type string {
            tailf:info "WORD;;Enter a string as the sub-protocol "+
              "parameter";
          }
        }
      }
      leaf clns {
        tailf:info "ISO CLNS";
        type empty;
      }
      leaf clns_es {
        tailf:info "ISO CLNS End System";
        type empty;
      }
      leaf clns_is {
        tailf:info "ISO CLNS Intermediate System";
        type empty;
      }
      leaf cmns {
        tailf:info "ISO CMNS";
        type empty;
      }
      leaf compressedtcp {
        tailf:info "Compressed TCP (VJ";
        type empty;
      }
      leaf cuseeme {
        tailf:info "CU-SeeMe desktop video conference";
        type empty;
      }
      leaf decnet {
        tailf:info "DECnet";
        type empty;
      }
      leaf decnet_node {
        tailf:info "DECnet Node";
        type empty;
      }
      leaf decnet_router-l1 {
        tailf:info "DECnet Router L1";
        type empty;
      }
      leaf decnet_router-l2 {
        tailf:info "DECnet Router L2";
        type empty;
      }
      leaf dhcp {
        tailf:info "Dynamic Host Configuration";
        type empty;
      }
      leaf dlsw {
        type empty;
        tailf:info "Data Link Switching (Direct encapsulation only";
      }
      leaf dns {
        type empty;
        tailf:info "Domain Name Server lookup";
      }
      leaf edonkey {
        type empty;
        tailf:info "eDonkey";
      }
      leaf egp {
        type empty;
        tailf:info "Exterior Gateway Protocol";
      }
      leaf eigrp {
        type empty;
        tailf:info "Enhanced Interior Gateway Routing Protocol";
      }
      leaf exchange {
        type empty;
        tailf:info "MS-RPC for Exchange";
      }
      container fasttrack {
        tailf:info "FastTrack Traffic - KaZaA, Morpheus, Grokster";
        presence "enable fasttrack matching";
        leaf file-transfer {
          tailf:info "File transfer stream";
          type string {
            tailf:info "WORD;;Enter a string as the sub-protocol "+
              "parameter";
          }
        }
      }
      leaf finger {
        type empty;
        tailf:info "Finger";
      }
      leaf ftp {
        type empty;
        tailf:info "File Transfer Protocol";
      }
      container gnutella {
        tailf:info "Gnutella Version2 Traffic - BearShare, Shareeza, "+
          "Morpheus";
        presence "enable gnutella matching";
        leaf file-transfer {
          tailf:info "File transfer stream";
          type string {
            tailf:info "WORD;;Enter a string as the sub-protocol "+
              "parameter";
          }
        }
      }
      leaf gopher {
        type empty;
        tailf:info "Gopher";
      }
      leaf gre {
        type empty;
        tailf:info "Generic Routing Encapsulation";
      }
      leaf h323 {
        type empty;
        tailf:info "H323 Protocol";
      }
      container http {
        tailf:info "World Wide Web traffic";
        presence "enable http traffic matching";
        leaf c-header-field {
          tailf:info "Client general Header Field";
          type string {
            tailf:info "WORD;;Enter a string as the sub-protocol "+
              "parameter";
          }
        }
        leaf host {
          tailf:info "Server Host Name";
          type string {
            tailf:info "WORD;;Enter a string as the sub-protocol "+
              "parameter";
          }
        }
        leaf mime {
          tailf:info "Match MIME Type";
          type string {
            tailf:info "WORD;;Enter a string as the sub-protocol "+
              "parameter";
          }
        }
        leaf s-header-field {
          tailf:info "Server general Header Field";
          type string {
            tailf:info "WORD;;Enter a string as the sub-protocol "+
              "parameter";
          }
        }
        leaf url {
          tailf:info "Match URL String";
          type string {
            tailf:info "WORD;;Enter a string as the sub-protocol "+
              "parameter";
          }
        }
      }
      leaf icmp {
        tailf:info "Internet Control Message";
        type empty;
      }
      leaf imap {
        tailf:info "Internet Message Access Protocol";
        type empty;
      }
      leaf ip {
        tailf:info "IP";
        type empty;
      }
      leaf ipinip {
        tailf:info "IP in IP (encapsulation";
        type empty;
      }
      leaf ipsec {
        tailf:info "IP Security Protocol (ESP/AH";
        type empty;
      }
      leaf ipv6 {
        tailf:info "IPV6";
        type empty;
      }
      leaf ipx {
        tailf:info "Novell IPX";
        type empty;
      }
      leaf irc {
        type empty;
        tailf:info "Internet Relay Chat";
      }
      container kazaa2 {
        tailf:info "Kazaa Version 2";
        presence "enable kazaa version 2 matching";
        leaf file-transfer {
          tailf:info "File transfer stream";
          type string {
            tailf:info "WORD;;Enter a string as the sub-protocol "+
              "parameter";
          }
        }
      }
      leaf kerberos {
        tailf:info "Kerberos";
        type empty;
      }
      leaf l2tp {
        tailf:info "L2F/L2TP tunnel";
        type empty;
      }
      leaf ldap {
        tailf:info "Lightweight Directory Access Protocol";
        type empty;
      }
      leaf llc2 {
        tailf:info "llc2";
        type empty;
      }
      leaf mgcp {
        tailf:info "Media Gateway Control Protocol";
        type empty;
      }
      container napster {
        tailf:info "Napster Traffic";
        presence "enable napster matching";
        leaf non-std {
          tailf:info "Non-standard port advertizements";
          type empty;
        }
      }
      leaf netbios {
        tailf:info "NetBIOS";
        type empty;
      }
      leaf netshow {
        tailf:info "Microsoft Netshow";
        type empty;
      }
      leaf nfs {
        tailf:info "Network File System";
        type empty;
      }
      leaf nntp {
        tailf:info "Network News Transfer Protocol";
        type empty;
      }
      leaf notes {
        tailf:info "Lotus Notes(R";
        type empty;
      }
      leaf novadigm {
        tailf:info "Novadigm EDM";
        type empty;
      }
      leaf ntp {
        tailf:info "Network Time Protocol";
        type empty;
      }
      leaf ospf {
        tailf:info "Open Shortest Path First";
        type empty;
      }
      leaf pad {
        tailf:info "PAD links";
        type empty;
      }
      leaf pcanywhere {
        tailf:info "Symantec pcANYWHERE";
        type empty;
      }
      leaf pop3 {
        tailf:info "Post Office Protocol";
        type empty;
      }
      leaf pppoe {
        tailf:info "PPP over Ethernet";
        type empty;
      }
      leaf pptp {
        tailf:info "Point-to-Point Tunneling Protocol";
        type empty;
      }
      leaf printer {
        tailf:info "print spooler/lpd";
        type empty;
      }
      leaf qllc {
        tailf:info "qllc protocol";
        type empty;
      }
      leaf rcmd {
        tailf:info "BSD r-commands (rsh, rlogin, rexec";
        type empty;
      }
      leaf rip {
        tailf:info "Routing Information Protocol";
        type empty;
      }
      leaf rsrb {
        tailf:info "Remote Source-Route Bridging";
        type empty;
      }
      leaf rsvp {
        tailf:info "Resource Reservation Protocol";
        type empty;
      }
      leaf rtcp {
        tailf:info "Real Time Control Protocol";
        type empty;
      }
      container rtp {
        tailf:info "Real Time Protocol";
        presence "enable rtp matching";
        leaf audio {
          tailf:info "Match voice packets";
          type empty;
        }
        leaf payload-type {
          tailf:info "Match an explicit PT";
          type string {
            tailf:info "WORD;;Enter a string as the sub-protocol "+
              "parameter";
          }
        }
        leaf video {
          tailf:info "Match video packets";
          type empty;
        }
      }
      leaf rtsp {
        tailf:info "Real Time Streaming Protocol";
        type empty;
      }
      leaf secure-ftp {
        tailf:info "FTP over TLS/SSL";
        type empty;
      }
      leaf secure-http {
        tailf:info "Secured HTTP";
        type empty;
      }
      leaf secure-imap {
        tailf:info "Internet Message Access Protocol over TLS/SSL";
        type empty;
      }
      leaf secure-irc {
        tailf:info "Internet Relay Chat over TLS/SSL";
        type empty;
      }
      leaf secure-ldap {
        tailf:info "Lightweight Directory Access Protocol over TLS/SSL";
        type empty;
      }
      leaf secure-nntp {
        tailf:info "Network News Transfer Protocol over TLS/SSL";
        type empty;
      }
      leaf secure-pop3 {
        tailf:info "Post Office Protocol over TLS/SSL";
        type empty;
      }
      leaf secure-telnet {
        tailf:info "Telnet over TLS/SSL";
        type empty;
      }
      leaf sip {
        tailf:info "Session Initiation Protocol";
        type empty;
      }
      leaf skinny {
        tailf:info "Skinny Protocol";
        type empty;
      }
      leaf smtp {
        tailf:info "Simple Mail Transfer Protocol";
        type empty;
      }
      leaf snapshot {
        tailf:info "Snapshot routing support";
        type empty;
      }
      leaf snmp {
        tailf:info "Simple Network Management Protocol";
        type empty;
      }
      leaf socks {
        tailf:info "SOCKS";
        type empty;
      }
      leaf sqlnet {
        tailf:info "SQL*NET for Oracle";
        type empty;
      }
      leaf sqlserver {
        tailf:info "MS SQL Server";
        type empty;
      }
      leaf ssh {
        tailf:info "Secured Shell";
        type empty;
      }
      leaf streamwork {
        tailf:info "Xing Technology StreamWorks player";
        type empty;
      }
      leaf stun {
        tailf:info "Serial Tunnel";
        type empty;
      }
      leaf sunrpc {
        tailf:info "Sun RPC";
        type empty;
      }
      leaf syslog {
        tailf:info "System Logging Utility";
        type empty;
      }
      leaf telnet {
        tailf:info "Telnet";
        type empty;
      }
      leaf tftp {
        tailf:info "Trivial File Transfer Protocol";
        type empty;
      }
      leaf vdolive {
        tailf:info "VDOLive streaming video";
        type empty;
      }
      leaf vofr {
        tailf:info "voice over Frame Relay packets";
        type empty;
      }
      leaf winmx {
        tailf:info "WinMx file-sharing application";
        type empty;
      }
      leaf xwindows {
        tailf:info "X-Windows remote access";
        type empty;
      }
    }
    // class-map * / qos-group
    leaf-list qos-group {
      tailf:info "Qos-group";
      tailf:cli-list-syntax;
      type uint16 {
        tailf:info "<0-99>;;Qos Group value";
        range "0..99";
      }
    }
    // class-map * / source-address
    container source-address {
      tailf:info "Source address";
      leaf-list mac {
        tailf:info "MAC address";
        tailf:cli-list-syntax;
        type string {
          tailf:info "H.H.H;;MAC address";
        }
      }
    }
    // class-map * / match vlan
    leaf-list vlan {
      tailf:info "VLANs to match";
      tailf:cli-flat-list-syntax;
      type uint16 {
        tailf:info "<1-4094>;;VLAN id";
        range "1..4094";
      }
    }
  }

  // ntp-server-grouping
  grouping ntp-server-grouping {
    list server-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      key ip-address;
      leaf ip-address {
        tailf:cli-disallow-value "vrf";
        type host-type {
          tailf:info "Hostname or A.B.C.D;;IP address of peer";
        }
      }
      leaf key {
        tailf:info "Configure peer authentication key";
        type uint32 {
          tailf:info "<0-4294967295>;;Peer key number";
        }
      }
      leaf prefer {
        tailf:info "Prefer this peer when possible";
        type empty;
      }
      //FIXME: 'source' with non-vrf mode only
      leaf version {
        tailf:info "    Configure NTP version";
        type uint8 {
          tailf:info "<1-3>;;NTP version number";
        }
      }
    }
  }

  // line-grouping
  grouping line-grouping {

    // line * / access-class
    container access-class {
      tailf:info "Filter connections based on an IP access list";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-reset-container;
      tailf:cli-flatten-container;
      list acccess-list {
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key direction;
        leaf direction {
          type enumeration {
            enum "in" {
              tailf:info "Filter incoming connections";
            }
            enum "out" {
              tailf:info "Filter outgoing connections";
            }
          }
        }
        leaf access-list {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type exp-acl-type;
          mandatory true;
        }
        leaf vrf-also {
          tailf:info "Same access list is applied for all VRFs";
          type empty;
        }
      }
    }

    // line * / escape-character
    leaf escape-character {
      tailf:info "Change the current line's escape character";
      type union {
        type uint8 {
          tailf:info "ASCII decimal equivalent";
        }
        type enumeration {
          enum BREAK {
            tailf:info "Cause escape on BREAK";
          }
          enum DEFAULT {
            tailf:info "Use default escape character";
          }
          enum NONE {
            tailf:info "Disable escape entirely";
          }
        }
      }
    }

    //container exec-dummy {
    //tailf:cli-drop-node-name;
    // line * / exec
    leaf exec {
      tailf:info "Configure EXEC";
      tailf:cli-boolean-no;
      tailf:cli-trim-default;
      type boolean;
      default true;
    }
    //}

    //FIXME: BUG: Crashes netsim:
    //container exec-dummy2 {
    //tailf:cli-drop-node-name;
    //container exec {
    //tailf:info "Configure EXEC";
    //tailf:cli-incomplete-command;
    //tailf:cli-incomplete-no;
    //container prompt {
    //tailf:info "EXEC prompt";
    //leaf timestamp {
    //tailf:info "Print timestamps for show commands";
    //type empty;
    //}
    //}
    //}
    //}

    // line * / exec-timeout
    container exec-timeout {
      tailf:info "Set the EXEC timeout";
      tailf:cli-sequence-commands;
      tailf:cli-compact-syntax;
      leaf minutes {
        tailf:info "<0-35791>;;Timeout in minutes";
        tailf:cli-drop-node-name;
        type uint32;
      }
      leaf seconds {
        tailf:info "<0-2147483>;;Timeout in seconds";
        tailf:cli-drop-node-name;
        type uint32;
      }
    }

    // line * / logging
    container logging {
      tailf:info "Modify message logging facilities";
      // line * / logging synchronous
      container synchronous {
        tailf:info "Synchronized message output";
        //tailf:cli-display-separated;
        presence true;
      }
    }

    // line * / login
    container login {
      tailf:info "Enable password checking";
      tailf:cli-delete-when-empty;
      presence true;
      // line * / login local
      leaf local {
        type empty;
      }
      // line * / login authentication
      leaf authentication {
        type string;
      }
    }

    // line * / password
    container password {
      tailf:info "Set a password";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      uses password-07-grouping;
    }

    // line * / privilege
    container privilege {
      tailf:info "Change privilege level for line";
      leaf level {
        tailf:info "Assign default privilege level for line";
        type uint8 {
          tailf:info "<0-15>;;Default privilege level for line";
          range "0..15";
        }
      }
    }

    // line * / session-timeout
    container session-timeout {
      tailf:info "Set interval for closing connection when there is no "+
        "input traffic";
      tailf:cli-sequence-commands;
      tailf:cli-compact-syntax;
      leaf session-timeout-value {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<0-35791>;;Session timeout interval in minutes";
          range "0..35791";
        }
      }
      leaf "output" {
        tailf:info "Include output traffic as well as input traffic";
        type empty;
      }
    }

    // line * / stopbits
    leaf stopbits {
      tailf:info "Set async line stop bits";
      type enumeration {
        enum "1" {
          tailf:info "One stop bit";
        }
        enum "1.5" {
          tailf:info "One and one-half stop bits";
        }
        enum "2" {
          tailf:info "Two stop bits";
        }
      }
    }

    // line * / telnet
    container telnet {
      tailf:info "Telnet protocol-specific configuration";
      leaf transparent {
        tailf:info "Send a CR as a CR followed by a NULL instead of "+
          "a CR followed by a LF";
        type empty;
      }
    }

    // line * / transport
    container transport {
      tailf:info "Define transport protocols for line";
      tailf:cli-incomplete-no;
      // line * / transport input
      leaf-list "input" {
        tailf:info "Define which protocols to use when connecting "+
          "to the terminal server";
        tailf:cli-flat-list-syntax;
        tailf:cli-no-value-on-delete;
        type enumeration {
          enum all {
            tailf:info "All protocols";
          }
          enum none {
            tailf:info "No protocols";
          }
          enum ssh {
            tailf:info "TCP/IP SSH protocol";
          }
          enum telnet {
            tailf:info "TCP/IP Telnet protocol";
          }
          enum lat {
            //tailf:info
          }
          enum pad {
            tailf:info "X.3 PAD";
          }
          enum udptn {
            tailf:info "UDPTN async via UDP protocol";
          }
          enum rlogin {
            tailf:info "Unix rlogin protocol";
          }
        }
      }
      // line * / transport output
      leaf-list "output" {
        tailf:info "Define which protocols to use for outgoing connections";
        tailf:cli-flat-list-syntax;
        tailf:cli-no-value-on-delete;
        type enumeration {
          enum all {
            tailf:info "All protocols";
          }
          enum none {
            tailf:info "No protocols";
          }
          enum ssh {
            tailf:info "TCP/IP SSH protocol";
          }
          enum telnet {
            tailf:info "TCP/IP Telnet protocol";
          }
        }
      }
      // line * / transport preferred
      leaf preferred {
        tailf:info "Specify the preferred protocol to use";
        tailf:cli-no-value-on-delete;
        type enumeration {
          enum none {
            tailf:info "No protocols";
          }
          enum ssh {
            tailf:info "TCP/IP SSH protocol";
          }
          enum telnet {
            tailf:info "TCP/IP Telnet protocol";
          }
        }
      }
    }
  }

  // queue-size-grouping
  grouping queue-size-grouping {
    leaf queue-size-1 {
      tailf:cli-drop-node-name;
      type uint8 {
        tailf:info "<1-100>;;enter percent of queue size between 1 "
          +"and 100";
        range "1..100";
      }
    }
    leaf queue-size-2 {
      tailf:cli-drop-node-name;
      type uint8 {
        tailf:info "<1-100>;;enter percent of queue size between 1 "
          +"and 100";
        range "1..100";
      }
    }
    leaf queue-size-3 {
      tailf:cli-drop-node-name;
      type uint8 {
        tailf:info "<1-100>;;enter percent of queue size between 1 "
          +"and 100";
        range "1..100";
      }
    }
    leaf queue-size-4 {
      tailf:cli-drop-node-name;
      type uint8 {
        tailf:info "<1-100>;;enter percent of queue size between 1 "
          +"and 100";
        range "1..100";
      }
    }
    leaf queue-size-5 {
      tailf:cli-drop-node-name;
      type uint8 {
        tailf:info "<1-100>;;enter percent of queue size between 1 "
          +"and 100";
        range "1..100";
      }
    }
    leaf queue-size-6 {
      tailf:cli-drop-node-name;
      type uint8 {
        tailf:info "<1-100>;;enter percent of queue size between 1 "
          +"and 100";
        range "1..100";
      }
    }
    leaf queue-size-7 {
      tailf:cli-drop-node-name;
      type uint8 {
        tailf:info "<1-100>;;enter percent of queue size between 1 "
          +"and 100";
        range "1..100";
      }
    }
    leaf queue-size-8 {
      tailf:cli-drop-node-name;
      type uint8 {
        tailf:info "<1-100>;;enter percent of queue size between 1 "
          +"and 100";
        range "1..100";
      }
    }
  }

  // grouping interface-common-grouping
  grouping interface-common-grouping {

    // interface * / description
    leaf "description" {
      tailf:info "Interface specific description";
      tailf:cli-multi-value;
      tailf:cli-full-command;
      type string {
        length "0..240";
      }
    }

    // interface * / authentication
    // NOTE: Called 'dot1x' on some versions
    container authentication {
      tailf:info "set the port-control value";
      leaf port-control {
        type enumeration {
          enum auto {
            tailf:info "PortState will be set to AUTO";
          }
          enum force-authorized {
            tailf:info "PortState set to Authorized";
          }
          enum force-unauthorized {
            tailf:info "PortState will be set to UnAuthorized";
          }
        }
      }
    }

    // interface * / mab
    container mab {
      presence true;
      leaf eap {
        type empty;
      }
    }

    // interface * / l2protocol-tunnel
    container l2protocol-tunnel {
      tailf:info "Tunnel Layer2 protocols";
      tailf:cli-delete-when-empty;
      presence true;
      leaf cdp {
        tailf:info "Cisco Discovery Protocol";
        type empty;
      }
      container drop-threshold {
        tailf:info "Set drop threshold for protocol packets";
        leaf packet-rate {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-4096>;;Packets/sec rate beyond which protocol "
              +"packets will be dropped";
            range "1..4096";
          }
        }
        leaf cdp {
          tailf:info "Cisco Discovery Protocol";
          type uint16 {
            tailf:info "<1-4096>;;Packets/sec rate beyond which protocol "
              +"packets will be dropped";
            range "1..4096";
          }
        }
        leaf stp {
          tailf:info "Spanning Tree Protocol";
          type uint16 {
            tailf:info "<1-4096>;;Packets/sec rate beyond which protocol "
              +"packets will be dropped";
            range "1..4096";
          }
        }
        leaf vtp {
          tailf:info "Vlan Trunking Protocol";
          type uint16 {
            tailf:info "<1-4096>;;Packets/sec rate beyond which protocol "
              +"packets will be dropped";
            range "1..4096";
          }
        }
      }
      container shutdown-threshold {
        tailf:info "Set shutdown threshold for protocol packets";
        leaf packet-rate {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-4096>;;Packets/sec rate beyond which interface is "
              +"put to err-disable";
            range "1..4096";
          }
        }
        leaf cdp {
          tailf:info "Cisco Discovery Protocol";
          type uint16 {
            tailf:info "<1-4096>;;Packets/sec rate beyond which interface is "
              +"put to err-disable";
            range "1..4096";
          }
        }
        leaf stp {
          tailf:info "Spanning Tree Protocol";
          type uint16 {
            tailf:info "<1-4096>;;Packets/sec rate beyond which interface is "
              +"put to err-disable";
            range "1..4096";
          }
        }
        leaf vtp {
          tailf:info "Vlan Trunking Protocol";
          type uint16 {
            tailf:info "<1-4096>;;Packets/sec rate beyond which interface is "
              +"put to err-disable";
            range "1..4096";
          }
        }
      }
      leaf stp {
        tailf:info "Spanning Tree Protocol";
        type empty;
      }
      leaf vtp {
        tailf:info "Vlan Trunking Protocol";
        type empty;
      }
    }

    // interface * / encapsulation
    container encapsulation {
      tailf:info "Set encapsulation type for an interface";
      // interface * / encapsulation dot1Q
      container dot1Q {
        tailf:info "IEEE 802.1Q Virtual LAN";
        tailf:cli-sequence-commands;
        tailf:cli-compact-syntax;
        leaf vlan-id {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-4094>;;IEEE 802.1Q VLAN ID required";
            range "1..4094";
          }
        }
        leaf native {
          tailf:info "Make this as native vlan";
          type empty;
        }
      }
      // interface * / encapsulation isl
      container isl {
        tailf:info "Inter Switch Link - Virtual LAN encapsulation";
        tailf:cli-sequence-commands;
        tailf:cli-compact-syntax;
        leaf vlan-id {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-4095>;;Virtual LAN Identifier.";
            range "1..4095";
          }
        }
      }
      // interface * / encapsulation ppp
      container ppp {
        tailf:info "Point-to-Point protocol";
        presence true;
      }
      // interface * / encapsulation slip
      container slip {
        tailf:info "Serial Line IP";
        presence true;
      }
      // interface * / encapsulation frame-relay
      container frame-relay {
        tailf:info "Frame Relay networks";
        tailf:cli-delete-when-empty;
        presence true;
        leaf ietf {
          tailf:info "Use RFC1490/RFC2427 encapsulation";
          type empty;
        }
      }
    }

    // interface * / no fair-queue
    container fair-queue-conf {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      when "not(../name[contains(.,'.')])" {
        tailf:dependency "../name";
      }
      leaf fair-queue {
        tailf:cli-boolean-no;
        tailf:cli-trim-default;
        type boolean;
        default true;
      }
    }

    // interface * / fair-queue
    container fair-queue {
      tailf:info "Enable Fair Queuing on an Interface";
      tailf:cli-incomplete-no;
      //FIXME: config varies, hard to know which to implement
      leaf incomplete {
        type empty;
      }
    }

    // interface * / flowcontrol
    container flowcontrol {
      tailf:info "Configure flow operation.";
      leaf receive {
        tailf:info "Configure receiving flow operation";
        type enumeration {
          enum desired {
            tailf:info "Allow but do not require flow-control packets on port";
          }
          enum off {
            tailf:info "Disable flow-control packets on port";
          }
          enum on {
            tailf:info "Enable flow-control packets on port";
          }
        }
      }
      leaf send {
        tailf:info "Configure sending flow operation";
        type enumeration {
          enum desired {
            tailf:info "Allow but do not require flow-control packets on port";
          }
          enum off {
            tailf:info "Disable flow-control packets on port";
          }
          enum on {
            tailf:info "Enable flow-control packets on port";
          }
        }
      }
    }

    // interface * / full-duplex
    // results in "duplex full"

    // interface * / keepalive
    choice keepalive-choice {
      leaf keepalive {
        tailf:info "Enable keepalive";
        tailf:cli-boolean-no;
        type boolean;
      }
      container keepalive-settings {
        tailf:cli-drop-node-name;
        container keepalive {
          tailf:info "Enable keepalive";
          leaf period {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<0-32767>;;Keepalive period (default 10 seconds)";
              range "0..32767";
            }
          }
        }
      }
    }

    // interface * / snmp
    container snmp {
      tailf:info "Modify SNMP interface parameters";
      container ifindex {
        tailf:info "Persist ifindex for the interface";
        choice ifindex-choice {
          leaf persist {
            tailf:info "Enable/Disable ifIndex persistence ";
            type empty;
          }
          leaf clear {
            tailf:info "Clear Enable/Disable ifIndex persistence";
            tailf:cli-trim-default;
            tailf:cli-boolean-no;
            type boolean;
            default true;
          }
        }
      }
      // interface * / snmp trap
      container trap {
        tailf:info "Allow a specific SNMP trap";
        //  ip           internet protocol
        leaf link-status {
          tailf:info "Allow SNMP LINKUP and LINKDOWN traps";
          tailf:cli-boolean-no;
          tailf:cli-trim-default;
          tailf:cli-full-command;
          type boolean;
          default true;
        }
        container link-status-capas {
          tailf:cli-drop-node-name;
          container link-status {
            tailf:info "Allow SNMP LINKUP and LINKDOWN traps";
            container permit {
              tailf:info "Permit the following capability";
              leaf duplicates {
                tailf:info "Permit duplicate SNMP LINKUP and LINKDOWN traps";
                type empty;
              }
            }
          }
        }
      }
    }

    // interface * / bfd
    container bfd {
      tailf:info "BFD interface configuration commands";
      leaf echo {
        tailf:info "Use echo adjunct as bfd detection mechanism";
        type empty;
      }
      container interval {
        tailf:info "Transmit interval between BFD packets";
        tailf:cli-reset-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf msecs {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<100-999>;;Milliseconds";
            range "100..999";
          }
        }
        leaf min_rx {
          tailf:info "Minimum receive interval capability";
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<100-999>;;Milliseconds";
            range "100..999";
          }
        }
        leaf multiplier {
          tailf:info "Multiplier value used to compute holddown";
          type uint8 {
            tailf:info "<3-50>;;value used to multiply the interval";
            range "3..50";
          }
        }
      }
    }

    // interface * / bandwidth
    container bandwidth {
      tailf:info "Set bandwidth informational parameter";
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-compact-syntax;

      leaf inherit {
        tailf:cli-optional-in-sequence;
        tailf:info "Specify how bandwidth is inherited";
        type empty;
      }

      leaf kilobits {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<1-10000000>;;Bandwidth in kilobits";
          range "1..10000000";
        }
      }
    }

    // interface * / cdp
    container cdp {
      tailf:info "CDP interface subcommands";
      // interface * / cdp enable
      leaf enable {
        tailf:info "Enable CDP on interface";
        tailf:cli-boolean-no;
        tailf:cli-trim-default;
        tailf:cli-full-command;
        type boolean;
        default true;
      }
      // interface * / cdp tlv
      container tlv {
        tailf:info "Enable exchange of specific tlv information";
        container app {
          tailf:info "Enable/Configure Application TLV";
          tailf:cli-display-separated;
          tailf:cli-compact-syntax;
          tailf:cli-reset-container;
          tailf:cli-sequence-commands;
          presence true;
          leaf tlvtype {
            tailf:info "Configure APP TLV";
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "Configure App TLV Type information";
              range "1001..65535";
            }
          }
          leaf "value" {
            tailf:info "Configure App TLV Value information";
            type string {
              tailf:info "WORD;;Configure App TLV value information";
            }
          }
        }
        leaf server-location {
          tailf:info "Enable CDP location server on interface";
          tailf:cli-full-command;
          type empty;
        }
        leaf location {
          tailf:info "Exchange location information";
          tailf:cli-full-command;
          type empty;
        }
        // log
      }
    }

    // interface * / dampening
    container dampening {
      tailf:info "Enable event dampening";
      presence "true";
      leaf dampening-time {
        tailf:cli-drop-node-name;
        tailf:cli-delete-container-on-delete;
        tailf:info "<1-30>;;Half-life time for penalty";
        type uint16 {
          range 1..30;
        }
      }
    }

    // interface * / hold-queue
    container hold-queue {
      tailf:info "Set hold queue depth";
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      tailf:cli-sequence-commands;
      leaf queue-length {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<0-4096>;;Queue length";
          range "0..4096";
        }
      }
      leaf direction {
        tailf:cli-drop-node-name;
        type enumeration {
          enum in {
            tailf:info "Input queue";
          }
          enum out {
            tailf:info "Output queue";
          }
        }
      }
    }

    // interface * / mpls
    container mpls {
      tailf:info "Configure MPLS interface parameters";
      container accounting {
        tailf:info "Enable MPLS accounting on this interface";
        container experimental {
          tailf:info "Count packets by MPLS experimental value on "
            +"this interface";
          leaf input {
            tailf:info "received packets";
            type empty;
          }
          leaf output {
            tailf:info "transmitted packets";
            type empty;
          }
        }
      }
      container bgp {
        tailf:info "MPLS BGP";
        leaf forwarding {
          tailf:info "Configure MPLS forwarding for directly "
            +"connected BGP peers";
          type empty;
        }
      }
      leaf ip {
        tailf:info "Configure dynamic MPLS forwarding for IP";
        tailf:cli-full-command;
        type empty;
      }
      container label {
        tailf:info "Label properties";
        leaf protocol {
          tailf:info "Configure label/tag distribution "
            +"protocol (LDP/TDP)";
          type enumeration {
            enum both {
              tailf:info "Use LDP or TDP (Adapt to peer "
                +"on multiaccess interface)";
            }
            enum ldp {
              tailf:code-name "lab_ldp";
              tailf:info "Use LDP (default)";
            }
            enum tdp {
              tailf:code-name "lab_tdp";
              tailf:info "Use TDP";
            }
          }
        }
      }
      container ldp {
        tailf:info "Configure Label Distribution Protocol "
          +"(LDP) parameters";
        container discovery {
          tailf:info "Configure interface LDP Discovery parameters";
          leaf transport-address {
            tailf:info "Specify interface LDP transport address";
            type ldp-discovery-address-type;
          }
        }
      }
      leaf mtu {
        tailf:info "Set MPLS Maximum Transmission Unit";
        tailf:cli-full-command;
        type union {
          type uint16 {
            range "1501..1524";
            tailf:info "<1501-1524>;;MTU (baby giants bytes)";
          }
          type uint16 {
            range "64..1500";
            tailf:info "<64-1500>;;MTU (bytes)";
          }
          type uint16 {
            tailf:info "<64-9216>;;MTU size in bytes";
            range "64..9216";
          }
        }
      }
      container traffic-eng {
        tailf:info "Configure Traffic Engineering parameters";
        leaf administrative-weight {
          tailf:info "Set the administrative weight for the "
            +"interface";
          tailf:cli-full-command;
          type uint32 {
            range "0..4294967295";
            tailf:info "<0-4294967295>;;Weight";
          }
        }
        leaf attribute-flags {
          tailf:info "Set user-defined interface "
            +"attibute flags";
          tailf:cli-full-command;
          type string {
            tailf:info "<0x0-0xFFFFFFFF>;;Attribute flags";
          }
        }
        container flooding {
          tailf:info "Set flooding parameters";
          container thresholds {
            tailf:info "Set flooding thresholds";
            leaf-list down {
              tailf:info "Set the thresholds for decreased "
                +"resource availability";
              tailf:cli-flat-list-syntax;
              type uint8 {
                range "0..100";
                tailf:info "<0-100>;;decreased bandwidth "
                  +"usage (percent)";
              }
            }
            leaf-list up {
              tailf:info "Set the thresholds for increased "
                +"resource availability";
              tailf:cli-flat-list-syntax;
              type uint8 {
                range "0..100";
                tailf:info "<0-100>;;increased bandwidth usage "
                  +"(percent)";
              }
            }
          }
        }
        leaf tunnels {
          tailf:info "enable MPLS Traffic Engineering tunnels";
          tailf:cli-full-command;
          type empty;
        }
      }
    }

    // interface * / vrf forwarding
    // interface * / ip vrf forwarding
    choice vrf-choice {
      container ip-vrf {
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        container ip {
          container vrf {
            leaf forwarding {
              tailf:info "Configure forwarding table";
              type string {
                tailf:info "WORD;;VRF name";
              }
              tailf:non-strict-leafref {
                path "/ios:ip/vrf/name";
              }
            }
          }
        }
      }
      container vrf {
        tailf:info "VPN Routing/Forwarding parameters on the interface";
        // interface * / vrf forwarding
        leaf forwarding {
          tailf:info "Configure forwarding table";
          type string {
            tailf:info "WORD;;VRF name";
          }
          tailf:non-strict-leafref {
            path "/ios:vrf/definition/name";
          }
        }
      }
    }

    // interface * / ip
    container ip {
      tailf:info "Interface Internet Protocol config commands";

      // interface * / ip access-group
      container access-group {
        tailf:info "Specify access control for packets";
        tailf:cli-sequence-commands;
        tailf:cli-compact-syntax;

        leaf access-list {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type exp-acl-type;
        }

        leaf direction {
          tailf:cli-drop-node-name;
          tailf:cli-full-command;
          type enumeration {
            enum in {
              tailf:code-name "access_group_direction_in";
              tailf:info "inbound packets";
            }
            enum out {
              tailf:code-name "access_group_direction_out";
              tailf:info "outbound packets";
            }
          }
        }
      }

      // interface * / ip vrf
      container vrf {
        tailf:info "VPN Routing/Forwarding parameters on the interface";
        leaf receive {
          tailf:info "Add Interface Address into VRF Table";
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;Table name";
          }
        }
        leaf sitemap {
          tailf:info "Configure route-map for routes"+
            "received from this site";
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;Name of the route-map";
          }
          // Note: no dependency to /ios:route-map
        }
      }

      // interface * / ip address
      choice address-choice {
        // interface * / ip unnumbered
        leaf unnumbered {
          tailf:info "Enable IP processing without an explicit address";
          type string;
        }
        // interface * / no ip address
        container no-address {
          tailf:cli-drop-node-name;
          leaf address {
            tailf:cli-boolean-no;
            tailf:cli-trim-default;
            type boolean;
            default true;
          }
        }
        // interface * / ip address XXX
        container address {
          tailf:info "Set the IP address of an interface";
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          choice address-choice {
            case fixed-case {
              container primary {
                tailf:cli-drop-node-name;
                tailf:cli-sequence-commands;
                tailf:cli-compact-syntax;
                tailf:cli-incomplete-command;
                tailf:cli-incomplete-no;
                leaf address {
                  tailf:cli-incomplete-command;
                  tailf:cli-drop-node-name;
                  tailf:cli-incomplete-no;
                  tailf:cli-diff-dependency
                    "/ios:vrf/definition/address-family/ipv4";
                  tailf:cli-diff-dependency "../../../../vrf/forwarding";
                  mandatory true;
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;IP address";
                  }
                }
                leaf mask {
                  tailf:cli-drop-node-name;
                  mandatory true;
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;IP subnet mask";
                  }
                }
              }
              list secondary {
                key address;
                tailf:cli-incomplete-command;
                tailf:cli-sequence-commands;
                tailf:cli-compact-syntax;
                tailf:cli-drop-node-name;
                tailf:cli-suppress-mode;
                tailf:cli-incomplete-no;
                leaf address {
                  tailf:cli-incomplete-no;
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;IP address";
                  }
                }
                leaf mask {
                  tailf:cli-drop-node-name;
                  tailf:cli-incomplete-command;
                  mandatory true;
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;IP subnet mask";
                  }
                }
                leaf secondary {
                  tailf:info "Make this IP address a secondary address";
                  type empty;
                }
              }
            }
            case dhcp-case {
              container dhcp {
                tailf:info "IP Address negotiated via DHCP";
                presence "IP Address negotiated via DHCP";
                tailf:cli-sequence-commands;
                container client-id {
                  tailf:info "Specify client-id to use";
                  tailf:cli-flatten-container;
                  tailf:cli-optional-in-sequence;
                  tailf:cli-diff-dependency "/ios:interface";
                  uses ethernet-grouping;
                }
                leaf hostname {
                  tailf:info "Specify value for hostname option";
                  type string {
                    tailf:info "WORD;;hostname string";
                  }
                }
              }
            }
          }
        }
      }

      // interface * / ip flow
      container flow {
        tailf:info "NetFlow related commands";
        leaf ingress {
          tailf:info "Enable inbound NetFlow";
          type empty;
        }
        leaf egress {
          tailf:info "Enable outbound NetFlow";
          type empty;
        }
        // monitor
      }

      // interface * / ip helper-address
      container helper-address {
        tailf:info "Specify a destination address for UDP broadcasts";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        choice helper-choice {
          leaf global {
            tailf:info "Helper-address is global";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          leaf vrf {
            tailf:info "VRF name for helper-address (if different from "+
              "interface VRF)";
            tailf:cli-optional-in-sequence;
            tailf:cli-diff-dependency "/ios:ip/vrf";
            tailf:cli-diff-dependency "/ios:vrf/definition";
            type string {
              tailf:info "WORD;;VPN Routing/Forwarding instance name";
            }
          }
        }
        leaf address {
          tailf:cli-drop-node-name;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP destination address";
          }
        }
      }

      // interface * / ip ospf
      container ospf {
        tailf:info "OSPF interface commands";

        // interface * / ip ospf *
        list process-id {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-incomplete-command;
          tailf:cli-reset-container;
          tailf:cli-sequence-commands;
          key id;
          leaf id {
            type uint16 {
              tailf:info "<1-65535>;;Process ID";
            }
          }
          leaf area {
            type union {
              type uint32 {
                tailf:info "<0-4294967295>;;OSPF area ID as a decimal value";
              }
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;OSPF area ID in IP address format";
              }
            }
          }
          leaf secondaries {
            tailf:info "Include or exclude secondary IP addresses";
            type empty;
          }
          leaf none {
            tailf:info "Do not include secondary IP addresses";
            type empty;
          }
        }

        // interface * / ip ospf network
        leaf network {
          tailf:info "Network type";
          type enumeration {
            enum broadcast {
              tailf:info "Specify OSPF broadcast multi-access network";
            }
            enum non-broadcast {
              tailf:info "Specify OSPF NBMA network";
            }
            enum point-to-multipoint {
              tailf:info "Specify OSPF point-to-multipoint network";
            }
            enum point-to-point {
              tailf:info "Specify OSPF point-to-point network";
            }
          }
        }

        // interface * / ip ospf bfd
        container bfd {
          tailf:info "BFD interface configuration commands";
          presence true;
          leaf enable {
            tailf:cli-full-command;
            tailf:cli-drop-node-name;
            type enumeration {
              enum disable {
                tailf:info "Disable BFD for this interface";
              }
            }
          }
        }

        // interface * / ip ospf cost
        leaf cost {
          tailf:info "Interface cost";
          type uint16 {
            tailf:info "<1-65535>;;Cost";
            range "1..65535";
          }
        }
      }

      // interface * / ip pim
      container pim {
        tailf:info "PIM interface commands";
        // interface * / ip pim sparse-mode
        leaf sparse-mode {
          tailf:info "Enable PIM sparse-mode operation";
          //tailf:cli-diff-dependency "/ios:ip/multicast-routing";
          type empty;
        }
        // interface * / ip pim dr-priority
        leaf dr-priority {
          tailf:info "PIM router DR priority";
          type uint32 {
            tailf:info "<0-4294967294>;;DR priority, preference given to "+
              "larger value";
          }
        }
      }

      // interface * / ip policy
      container policy {
        tailf:info "Enable policy routing";
        // interface * / ip policy route-map
        leaf route-map {
          tailf:info "Policy route-map";
          type string {
            tailf:info "WORD;;Route map name";
          }
        }
      }

      // interface * / ip proxy-arp
      leaf proxy-arp {
        tailf:info "Enable proxy ARP";
        tailf:cli-boolean-no;
        tailf:cli-trim-default;
        type boolean;
        default true;
      }

      // interface * / no ip route-cache
      container route-cache-conf {
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        leaf route-cache {
          tailf:cli-boolean-no;
          tailf:cli-trim-default;
          type boolean;
          default true;
        }
      }

      // interface * / ip route-cache
      container route-cache {
        tailf:info "Enable fast-switching cache for outgoing packets";
        tailf:cli-incomplete-no;
        // interface * / ip route-cache cef
        leaf cef {
          tailf:info "Enable Cisco Express Forwarding";
          tailf:cli-boolean-no;
          tailf:cli-trim-default;
          type boolean;
          default true;
        }
        // interface * / ip route-cache flow
        leaf flow {
          tailf:info "Enable Flow fast-switching cache";
          tailf:cli-boolean-no;
          tailf:cli-trim-default;
          type boolean;
          default false;
        }
        // interface * / ip route-cache policy
        leaf policy {
          tailf:info "Enable fast-switching policy cache for outgoing packets";
          tailf:cli-boolean-no;
          tailf:cli-trim-default;
          type boolean;
          default false;
        }
        // interface * / ip route-cache same-interface
        leaf same-interface {
          tailf:info "Enable fast-switching on the same interface";
          tailf:cli-boolean-no;
          tailf:cli-trim-default;
          type boolean;
          default false;
        }
      }

      // interface * / ip igmp
      container igmp {
        tailf:info "IGMP interface commands";
        container static-group {
          tailf:info "IGMP static multicast group";
          list groups {
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-drop-node-name;
            key name;
            leaf name {
              tailf:cli-suppress-range;
              type union {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IP group address";
                }
                type enumeration {
                  enum "*" {
                    tailf:info "Populated for all groups";
                  }
                }
              }
            }
          }
          list class-map {
            tailf:info "Class map of type multicast-flows";
            key id;
            leaf id {
              type leafref {
                path "/ios:class-map/name";
              }
            }
          }
        }
      }

      // interface * / ip redirects
      leaf redirects {
        tailf:info "Enable sending ICMP Redirect messages";
        type empty;
      }

      // interface * / ip tcp
      container tcp {
        tailf:info "TCP header compression and other parameters";
        leaf adjust-mss {
          tailf:info "Adjust the mss of transit packets";
          type uint16 {
            tailf:info "<500-1460>;;Maximum segment size in bytes";
            range "500..1460";
          }
        }
      }

      // interface * / ip virtual-reassembly
      container virtual-reassembly {
        tailf:cli-compact-syntax;
        leaf max-reassemblies {
          type uint32; // number
        }
        leaf max-fragments {
          type uint32; // number
        }
        leaf timeout {
          type uint32; // seconds
        }
        leaf drop-fragments {
          type empty;
        }
        leaf in {
          type empty;
        }
      }

      // interface * / ip dhcp
      container dhcp {
        tailf:info "Configure DHCP parameters for this interface";
        //  client    DHCP client configuration
        //  limit     Limit DHCP Lease
        container relay {
          tailf:info "DHCP relay configuration parameters";
          container information {
            tailf:info "DHCP relay information option";
            container check-reply {
              tailf:info "Validate relay information in BOOTREPLY";
              presence true;
              leaf none {
                tailf:info "Set to none";
                type empty;
              }
            }
            container option {
              tailf:info "DHCP relay information option";
              leaf subscriber-id {
                tailf:info "Subscriber identifier sub option";
                type string {
                  tailf:info "WORD;;Subscriber identifier string";
                }
              }
            }
            container option-insert {
              tailf:info "Insert relay information in BOOTREQUEST";
              presence true;
              leaf none {
                tailf:info "Set to none";
                type empty;
              }
            }
            leaf policy-action {
              tailf:info "Define reforwarding policy";
              type enumeration {
                enum drop {
                  tailf:info "Do not forward BOOTREQUEST message";
                }
                enum encapsulate {
                  tailf:info "Encapsulate existing information";
                }
                enum keep {
                  tailf:info "Leave existing information alone";
                }
                enum replace {
                  tailf:info "Replace existing information";
                }
              }
            }
            leaf trusted {
              tailf:info "Received DHCP packet may contain relay info option "
                +"with zero giaddr";
              type empty;
            }
          }
        }
        container snooping {
          tailf:info "DHCP Snooping";
          container limit {
            tailf:info "DHCP Snooping limit";
            leaf rate {
              tailf:info "DHCP Snooping limit";
              type uint16 {
                tailf:info "<1-2048>;;DHCP snooping rate limit";
                range "1..2048";
              }
            }
          }
          leaf trust {
            tailf:info "DHCP Snooping trust config";
            type empty;
          }
          list vlan {
            tailf:info "DHCP Snooping vlan";
            key id;
            max-elements 1;
            leaf id {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<1-4094>;;DHCP Snooping vlan";
                range "1..4094";
              }
            }
            container information {
              tailf:info "DHCP Snooping information";
              container option {
                tailf:info "DHCP Snooping information option";
                container format-type {
                  tailf:info "Option 82 information format";
                  container circuit-id {
                    tailf:info "Circuit id option 82 format";
                    leaf string {
                      tailf:info "User defined string for circuit id";
                      type string {
                        tailf:info "WORD;;Use string for circuit id (3-63 "
                          +"chars)";
                        length "3..63";
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }

      // interface * / ip mtu
      leaf mtu {
        tailf:info "Set IP Maximum Transmission Unit";
        type uint16 {
          tailf:info "<68-9198>;;MTU (bytes)";
          range "68..9198";
        }
      }

      // interface * / ip nat
      container nat {
        tailf:info "NAT interface commands";
        leaf allow-static-host {
          tailf:info "Allow static-ip clients";
          type empty;
        }
        leaf enable {
          tailf:info "Enable Address Translation (NVI)";
          type empty;
        }
        choice nat-choice {
          leaf inside {
            tailf:info "Inside interface for address translation";
            type empty;
          }
          leaf outside {
            tailf:info "Outside interface for address translation";
            type empty;
          }
        }
      }
    }

    // interface * / ipv6
    container ipv6 {
      tailf:info "IPv6 interface subcommands";

      // interface * / ipv6 address
      container address {
        tailf:info "Configure IPv6 address on interface";
        choice address-choice {
          case autoconfig-case {
            container autoconfig {
              tailf:info "Obtain address using autoconfiguration";
              presence true;
              leaf default {
                tailf:info "Insert default route";
                type empty;
              }
            }
          }
          case manual-case {
            list prefix-list {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key prefix;
              leaf prefix {
                type ios:ipv6-prefix {
                  tailf:info "X:X:X:X::X/<0-128>;;"+
                    "IPv6 prefix";

                }
              }
              leaf anycast {
                tailf:info "Configure as an anycast";
                tailf:cli-full-command;
                type empty;
              }
              leaf eui-64 {
                tailf:info "Use eui-64 interface identifier";
                tailf:cli-full-command;
                type empty;
              }
            }
          }
        }
      }

      // interface * / ipv6 enable
      leaf enable {
        tailf:info "Enable IPv6 on interface";
        type empty;
      }

      // interface * / ipv6 ospf
      container ospf {
        tailf:info "OSPF interface commands";
        // interface * / ipv6 ospf *
        list process {
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-drop-node-name;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          key id;
          leaf id {
            type uint16 {
              tailf:info "<1-65535>;;Process ID";
              range "1..65535";
            }
          }
          leaf area {
            tailf:info "Set the OSPF area ID";
            type union {
              type uint32 {
                tailf:info "<0-4294967295>;;OSPF area ID as a decimal value";
                range "0..4294967295";
              }
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;OSPF area ID in IP address format";
              }
            }
          }
          leaf instance {
            tailf:info "Set the OSPF instance";
            type union {
              type uint8 {
                tailf:info "<0-31>;;Instance ID";
                range "0..31";
              }
              type uint8 {
                tailf:info "<32-255>;;Instance ID (DEPRECATED!)";
                range "32..255";
              }
            }
          }
        }
        //  authentication       Enable authentication

        // interface * / ipv6 ospf bfd
        container bfd {
          tailf:info "Enable BFD on this interface";
          presence true;
          leaf disable {
            tailf:info "Disable BFD on this interface";
            type empty;
          }
        }

        // interface * / ipv6 ospf cost
        leaf cost {
          tailf:info "Route cost of this interface";
          type uint16 {
            tailf:info "<1-65535>;;Route cost of this interface";
            range "1..65535";
          }
        }

        // interface * / ipv6 ospf database-filter
        container database-filter {
          tailf:info "Filter OSPF LSA during synchronization and flooding";
          choice database {
            leaf all {
              tailf:info "Filter all LSA";
              type enumeration {
                enum out {
                  tailf:info "Outgoing LSA";
                }
              }
            }
            leaf disable {
              tailf:info "Disable LSA Filter on this interface";
              type empty;
            }
          }
        }

        // interface * / ipv6 ospf dead-interval
        leaf dead-interval {
          tailf:info "Interval after which a neighbor is declared dead";
          type uint16 {
            tailf:info "<1-65535>;;Seconds";
            range "1..65535";
          }
        }

        // interface * / ipv6 ospf demand-circuit
        container demand-circuit {
          tailf:info "OSPF demand circuit";
          presence true;
          leaf disable {
            tailf:info "Disable demand circuit on this interface";
            type empty;
          }
        }
        //  encryption           Enable encryption

        // interface * / ipv6 ospf flood-reduction
        container flood-reduction {
          tailf:info "OSPF Flood Reduction";
          presence true;
          leaf disable {
            tailf:info "Disable Flood Reduction on this interface";
            type empty;
          }
        }

        // interface * / ipv6 ospf hello-interval
        leaf hello-interval {
          tailf:info "Time between HELLO packets";
          type uint16 {
            tailf:info "<1-65535>;;Seconds";
            range "1..65535";
          }
        }

        // interface * / ipv6 ospf mtu-ignore
        container mtu-ignore {
          tailf:info "Ignores the MTU in DBD packets";
          presence true;
          leaf disable {
            tailf:info "Disable Ingore MTU on this interface";
            type empty;
          }
        }
        //  neighbor             OSPF neighbor
        //  network              Network type

        // interface * / ipv6 ospf priority
        leaf priority {
          tailf:info "Router priority";
          type uint16 {
            tailf:info "<0-255>;;Priority";
            range "0..255";
          }
        }

        // interface * / ipv6 ospf retransmit-interval
        leaf retransmit-interval {
          tailf:info "Time between retransmitting lost link state "+
            "advertisements";
          type uint16 {
            tailf:info "<1-65535>;;Seconds";
            range "1..65535";
          }
        }

        // interface * / ipv6 ospf retransmit-interval
        leaf transmit-delay {
          tailf:info "Link state transmit delay";
          type uint16 {
            tailf:info "<1-65535>;;Seconds";
            range "1..65535";
          }
        }
      }

      // interface * / ipv6 mtu
      leaf mtu {
        tailf:info "Set IPv6 Maximum Transmission Unit";
        type uint16 {
          tailf:info "<1280-9198>;;MTU (bytes)";
          range "1280..9198";
        }
      }
    }

    // interface * / load-interval
    leaf load-interval {
      tailf:info "Specify interval for load calculation for an interface";
      type uint16 {
        tailf:info "<30-600>;;Load interval delay in seconds";
        range "0..600";
      }
    }

    // interface * / max-reserved-bandwidth
    leaf max-reserved-bandwidth {
      tailf:info "Maximum Reservable Bandwidth on an Interface";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<1-100>;;Max. reservable bandwidth as percent of "+
          "interface bandwidth";
        range "1..100";
      }
    }

    // interface * / mls
    container mls {
      tailf:info "mls sub/interface commands";
      // rp
      // qos
      container qos {
        tailf:info "qos command keyword";
        leaf channel-consistency {
          tailf:info "enable or disable qos consistency checks";
          tailf:cli-full-command;
          tailf:cli-boolean-no;
          tailf:cli-trim-default;
          type boolean;
          default true;
        }
        leaf trust {
          tailf:info "trust keyword";
          tailf:cli-full-command;
          type enumeration {
            enum "cos" {
              tailf:info "cos keyword";
            }
            enum "dscp" {
              tailf:info "dscp keyword";
            }
            enum ip-precedence {
              tailf:info "ip-precedence keyword";
            }
          }
        }
        leaf vlan-based {
          tailf:info "vlan-based keyword";
          tailf:cli-full-command;
          type empty;
        }
      }
    }

    // interface * / mtu
    leaf mtu {
      tailf:info "Set the interface Maximum Transmission Unit (MTU)";
      tailf:cli-full-command;
      type uint16 {
        range "64..18000";
        tailf:info "<64-18000>;;MTU size in bytes";
      }
    }

    // interface * / power
    container power {
      //tailf:info
      container inline {
        //tailf:info
        leaf consumption {
          tailf:cli-full-command;
          type uint16 {
            //tailf:info
            range "4000..15400";
          }
        }
      }
    }

    // interface * / service-policy
    container service-policy {
      tailf:info "Configure QoS Service Policy";
      leaf history {
        tailf:cli-full-command;
        tailf:info "Keep history of QoS metrics";
        type empty;
      }
      leaf "input" {
        tailf:cli-full-command;
        tailf:info "Assign policy-map to the input of an interface";
        type string {
          tailf:info "WORD;;policy-map name";
        }
        tailf:non-strict-leafref {
          path "/ios:policy-map/ios:name";
        }
      }
      leaf "output" {
        tailf:cli-full-command;
        tailf:info "Assign policy-map to the output of an interface";
        type string {
          tailf:info "WORD;;policy-map name";
        }
        tailf:non-strict-leafref {
          path "/ios:policy-map/ios:name";
        }
      }
      container "type" {
        tailf:info "Configure CPL Service Policy";
        container performance-monitor {
          tailf:info "Configure media monitor service-policy type";
          tailf:cli-sequence-commands;
          tailf:cli-compact-syntax;
          leaf direction {
            tailf:cli-drop-node-name;
            type enumeration {
              enum "input" {
                tailf:info "Assign policy-map to the input of an interfcae";
              }
              enum "output" {
                tailf:info "Assign policy-map to the output of an interfcae";
              }
            }
          }
          leaf name {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;policy-map name";
            }
            tailf:non-strict-leafref {
              path "/ios:policy-map/name";
            }
          }
        }
      }
    }

    // interface * / service
    //container service {
    //}

    // interface * / shutdown
    leaf shutdown {
      tailf:info "Shutdown the selected interface";
      tailf:cli-full-command;
      type empty;
    }

    // interface * / standby
    container standby {
      tailf:info "HSRP interface configuration commands";
      // interface * / standby version
      leaf version {
        tailf:info "HSRP version";
        tailf:cli-full-command;
        type enumeration {
          tailf:info "<1-2>;;Version number";
          enum "1";
          enum "2";
        }
      }
      // interface * / standby bfd
      leaf bfd {
        tailf:info "Enable HSRP BFD";
        type empty;
      }
      // interface * / standby delay
      container delay {
        tailf:info "HSRP initialisation delay";
        tailf:cli-compact-syntax;
        leaf minimum {
          tailf:info "Minimum delay";
          type uint16 {
            tailf:info "<0-10000>;;Delay in seconds";
            range "0..10000";
          }
        }
        leaf reload {
          tailf:info "Delay after reload";
          type uint16 {
            tailf:info "<0-10000>;;Delay in seconds";
            range "0..10000";
          }
        }
      }
      // interface * / standby mac-refresh
      leaf mac-refresh {
        tailf:info "Refresh MAC cache on switch by periodically sending packet "
          +"from virtual mac address";
        type uint8 {
          tailf:info "<0-255>;;Interval to refresh MAC cache";
          range "0..255";
        }
      }
      // interface * / standby use-bia
      container use-bia {
        tailf:info "HSRP uses interface's burned in address";
        presence true;
        container scope {
          tailf:info "Specify the scope of use-bia";
          leaf interface {
            tailf:info "Use-bia applies to all groups on this interface or sub-"
              +"interface";
            type empty;
          }
        }
      }
      // interface * / standby *
      list standby-list {
        //FIXME: key 0 can be ignored (default)
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key group-number;
        leaf group-number {
          tailf:cli-suppress-range;
          type uint16 {
            tailf:info "<0-255>;;group number";
          }
        }
        container authentication {
          tailf:info "Authentication";
          choice auth {
            leaf word {
              tailf:cli-drop-node-name;
              tailf:cli-disallow-value "md5|text";
              type string {
                tailf:info "WORD;;Plain text authentication string "
                  +"(8 chars max)";
              }
            }
            container md5 {
              tailf:info "Use MD5 authentication";
              leaf key-chain {
                tailf:info "Set key chain";
                type string {
                  tailf:info "WORD;;Name of key-chain";
                }
              }
              container key-string {
                tailf:info "Set key string";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                leaf encrypt {
                  tailf:cli-drop-node-name;
                  type enumeration {
                    enum 0 {
                      tailf:info "Specifies an UNENCRYPTED key string will "
                      +"follow";
                    }
                    enum 7 {
                      tailf:info "Specifies a HIDDEN key string will follow";
                    }
                  }
                }
                leaf string {
                  tailf:cli-drop-node-name;
                  type string {
                    tailf:info "WORD;;Key string (64 chars max)";
                  }
                }
                leaf timeout {
                  tailf:info "Set timeout";
                  type uint16 {
                    tailf:info "<0-32767>;;Timeout until only accepting "
                      +"new key (seconds)";
                    range "0..32767";
                  }
                }
              }
            }
            leaf text {
              tailf:info "Plain text authentication";
              type string {
                tailf:info "WORD;;Plain text authentication string "
                  +"(8 chars max)";
              }
            }
          }
        }
        leaf follow {
          tailf:info "Name of HSRP group to follow";
          type string {
            tailf:info "WORD;;name string (25 chars. max)";
          }
        }
        container ip {
          tailf:info "Enable HSRP and set the virtual IP address";
          tailf:cli-sequence-commands;
          tailf:cli-compact-syntax;
          presence true;
          leaf address {
            tailf:cli-drop-node-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Virtual IP address";
            }
          }
          leaf secondary {
            tailf:info "Make this IP address a secondary virtual IP address";
            type empty;
          }
        }
        leaf ipv6 {
          tailf:info "Enable HSRP IPv6";
          type union {
            type inet:ipv6-address {
              tailf:info "X:X:X:X::X;;IPv6 link-local address";
            }
            type ios:ipv6-prefix;
            type enumeration {
              enum autoconfig {
                tailf:info "Obtain address using autoconfiguration";
              }
            }
          }
        }
        leaf mac-address {
          tailf:info "Virtual MAC address";
          type string {
            tailf:info "H.H.H;;MAC address";
          }
        }
        leaf name {
          tailf:info "Redundancy name string";
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;name string";
          }
        }
        container preempt {
          tailf:info "Overthrow lower priority Active routers";
          presence true;
          container delay {
            tailf:info "Wait before preempting";
            tailf:cli-compact-syntax;
            leaf minimum {
              tailf:info "Delay at least this long";
              type uint16 {
                tailf:info "<0-3600>;;Number of seconds for minimum delay";
                range "0..3600";
              }
            }
            leaf reload {
              tailf:info "Delay after reload";
              type uint16 {
                tailf:info "<0-3600>;;Number of seconds for reload delay";
                range "0..3600";
              }
            }
            leaf sync {
              tailf:info "Wait for IP redundancy client";
              type uint16 {
                tailf:info "<0-3600>;;Number of seconds for sync delay";
                range "0..3600";
              }
            }
          }
        }
        leaf priority {
          tailf:info "Priority level";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<0-255>;;Priority value";
          }
        }
        container redirect {
          tailf:info "Configure sending of ICMP Redirect messages with an HSRP "
            +"virtual IP address as the gateway IP address";
          container advertisement {
            tailf:info "Redirect advertisement messages";
            container authentication {
              tailf:info "Authentication";
              container md5 {
                tailf:info "Use MD5 authentication";
                leaf key-chain {
                  tailf:info "Set key chain";
                  type string {
                    tailf:info "WORD;;Name of key-chain";
                  }
                }
                container key-string {
                  tailf:info "Set key string";
                  tailf:cli-compact-syntax;
                  tailf:cli-sequence-commands {
                    tailf:cli-reset-siblings;
                  }
                  leaf encrypt {
                    tailf:cli-drop-node-name;
                    type enumeration {
                      enum 0 {
                        tailf:info "Specifies an UNENCRYPTED key string will "
                        +"follow";
                      }
                      enum 7 {
                        tailf:info "Specifies a HIDDEN key string will follow";
                      }
                    }
                  }
                  leaf string {
                    tailf:cli-drop-node-name;
                    type string {
                      tailf:info "WORD;;Key string (64 chars max)";
                    }
                  }
                  leaf timeout {
                    tailf:info "Set timeout";
                    type uint16 {
                      tailf:info "<0-32767>;;Timeout until only accepting "
                        +"new key (seconds)";
                      range "0..32767";
                    }
                  }
                }
              }
            }
          }
          container timers {
            tailf:info "Adjust redirect timers";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf advertisement {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<10-180>;;Passive router advertisement interval in "
                  +"seconds";
                range "10..180";
              }
            }
            leaf holddown {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<30-3600>;;Passive router holddown interval in "
                  +"seconds";
                range "30..3600";
              }
            }
          }
          leaf unknown {
            tailf:info "Redirect to non-HSRP routers";
            type empty;
          }
        }
        container timers {
          tailf:info "Hello and hold timers";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          container hello-interval {
            tailf:cli-drop-node-name;
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            choice hello-interval-choice {
              leaf seconds {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type uint8 {
                  tailf:info "<1-254>;;Hello interval in seconds";
                  range "1..254";
                }
              }
              leaf msec {
                tailf:info "Specify hello interval in milliseconds";
                tailf:cli-incomplete-command;
                type uint16 {
                  tailf:info "<15-999>;;Hello interval in milliseconds";
                  range "15..999";
                }
              }
            }
          }
          container hold-time {
            tailf:cli-drop-node-name;
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            choice hold-time-choice {
              leaf seconds {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<1-255>;;Hold time in seconds";
                  range "1..255";
                }
              }
              leaf msec {
                tailf:info "Specify hold time in milliseconds";
                type uint16 {
                  tailf:info "<50-3000>;;Hello interval in milliseconds";
                  range "50..3000";
                }
              }
            }
          }
        }
        // track
      }
    }

    // interface * / storm-control
    container storm-control {
      tailf:info "storm configuration";
      container action {
        tailf:info "Action to take for storm..control;";
        leaf level {
          tailf:info "Set storm suppression level on this interface";
          type decimal64 {
            fraction-digits 2;
            tailf:info "<0-100>;;Enter Integer part of level as percentage "+
              "of bandwidth";
            range "0..100";
          }
        }
      }
      container broadcast {
        tailf:info "Broadcast address storm control";
        leaf level {
          tailf:info "Set storm suppression level on this interface";
          type decimal64 {
            fraction-digits 2;
            tailf:info "<0-100>;;Enter Integer part of level as percentage "+
              "of bandwidth";
            range "0..100";
          }
        }
      }
      container multicast {
        tailf:info "Multicast address storm control";
        leaf level {
          tailf:info "Set storm suppression level on this interface";
          type decimal64 {
            fraction-digits 2;
            tailf:info "<0-100>;;Enter Integer part of level as "+
              "percentage of bandwidth";
            range "0..100";
          }
        }
      }
      container unicast {
        tailf:info "Unicast address storm control";
        leaf level {
          tailf:info "Set storm suppression level on this interface";
          type decimal64 {
            fraction-digits 2;
            tailf:info "<0-100>;;Enter Integer part of level as "+
              "percentage of bandwidth";
            range "0..100";
          }
        }
      }
    }

    // interface * / wrr-queue
    container wrr-queue {
      tailf:info "Configure weighted round-robin xmt queues";
      container bandwidth {
        tailf:info "Configure WRR minimum bandwidth with weights or "
          +"percentages";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        choice bandwidth-choice {
          case a {
            leaf weight-1 {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<0-255>;;enter bandwidth weight";
                range "0..255";
              }
            }
            leaf weight-2 {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<0-255>;;enter bandwidth weight";
                range "0..255";
              }
            }
            leaf weight-3 {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<0-255>;;enter bandwidth weight";
                range "0..255";
              }
            }
            leaf weight-4 {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<0-255>;;enter bandwidth weight";
                range "0..255";
              }
            }
            leaf weight-5 {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<0-255>;;enter bandwidth weight";
                range "0..255";
              }
            }
            leaf weight-6 {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<0-255>;;enter bandwidth weight";
                range "0..255";
              }
            }
            leaf weight-7 {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<0-255>;;enter bandwidth weight";
                range "0..255";
              }
            }
          }
          case b {
            container percent {
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf percent-1 {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<0-100>;;enter bandwidth percent";
                  range "0..100";
                }
              }
              leaf percent-2 {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<0-100>;;enter bandwidth percent";
                  range "0..100";
                }
              }
              leaf percent-3 {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<0-100>;;enter bandwidth percent";
                  range "0..100";
                }
              }
              leaf percent-4 {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<0-100>;;enter bandwidth percent";
                  range "0..100";
                }
              }
              leaf percent-5 {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<0-100>;;enter bandwidth percent";
                  range "0..100";
                }
              }
              leaf percent-6 {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<0-100>;;enter bandwidth percent";
                  range "0..100";
                }
              }
              leaf percent-7 {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<0-100>;;enter bandwidth percent";
                  range "0..100";
                }
              }
            }
          }
        }
      }
      list cos-map {
        tailf:info "Configure cos-map for a queue threshold";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key "queue-id threshold-id";
        leaf queue-id {
          type uint8 {
            tailf:info "<1-3>;;enter cos-map queue id";
            range "1..3";
          }
        }
        leaf threshold-id {
          type uint8 {
            tailf:info "<1-8>;;enter cos-map threshhold id";
            range "1..8";
          }
        }
        leaf-list cos-values {
          tailf:cli-drop-node-name;
          tailf:cli-flat-list-syntax;
          max-elements 8;
          type uint8 {
            tailf:info "<0-7>;;cos values separated by spaces (up to 8 values "
              +"total)";
            range "0..7";
          }
        }
      }
      container queue-limit {
        tailf:info "Configure queue-limit";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf weight-a {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<0-100>;;enter queue size weight";
            range "0..100";
          }
        }
        leaf weight-b {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<0-100>;;enter queue size weight";
            range "0..100";
          }
        }
        leaf weight-c {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<0-100>;;enter queue size weight";
            range "0..100";
          }
        }
      }
      container random-detect {
        tailf:info "Configure random-detect";
        list max-threshold {
          tailf:info "Max threshold for WRED";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          key id;
          leaf id {
            type uint8 {
              tailf:info "<1-3>;;enter queue id";
              range "1..3";
            }
          }

          uses queue-size-grouping;
        }
        list min-threshold {
          tailf:info "Min threshold for WRED";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          key id;
          leaf id {
            type uint8 {
              tailf:info "<1-3>;;enter queue id";
              range "1..3";
            }
          }

          uses queue-size-grouping;

        }
      }
      list threshold {
        tailf:info "Configure queue tail-drop thresholds";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key id;
        leaf id {
          type uint8 {
            tailf:info "<1-3>;;enter queue id";
            range "1..3";
          }
        }

        uses queue-size-grouping;
      }
    }

    // interface * / priority-queue
    container priority-queue {
      tailf:info "Configure priority scheduling";
      container cos-map {
        tailf:info "Configure cos-map for a queue";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }

        leaf id {
          tailf:cli-drop-node-name;
          type uint8;
        }

        leaf-list cos-values {
          tailf:cli-drop-node-name;
          tailf:cli-flat-list-syntax;
          max-elements 8;
          type uint8 {
            tailf:info "<0-7>;;cos values separated by spaces (up to 8 values "
              +"total)";
            range "0..7";
          }
        }
      }
      leaf out { // switch 3550
        tailf:info "egress priority queue";
        tailf:cli-full-command;
        type empty;
      }
      //  queue-limit  Configure priority queue limit
    }

    // interface * / rep
    container rep {
      tailf:info "Resilient Ethernet Protocol characteristics";

      container block {
        tailf:info "Block port & VLANs for VLAN Load-balancing";
        container port {
          tailf:info "Specify port for VLAN Load-balancing";
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-compact-syntax;
          choice port-choice {
            leaf neighbor-offset {
              tailf:cli-drop-node-name;
              type int16 {
                tailf:info "<-256 - 256>;;Neighbor offset";
                range "-256..256";
              }
            }
            leaf id {
              tailf:info "REP port ID";
              type string {
                tailf:info "WORD;;REP port ID (16 digit hexadecimal number)";
              }
            }
            leaf preferred {
              tailf:info "Preferred flag";
              type empty;
            }
          }
          leaf vlan {
            tailf:info "VLANs to block";
            type union {
              type string {
                tailf:info "WORD;;VLAN list (1-4094) ex: 1-65,72,300-320";
              }
              type enumeration {
                enum all {
                  tailf:info "All VLANs";
                }
              }
            }
          }
        }
      }
      container preempt {
        tailf:info "Preemption options";
        leaf delay {
          tailf:info "Delay timer in seconds";
          type uint16 {
            tailf:info "<15-300>;;number of seconds before automatic "
              +"preemption takes place";
            range "15..300";
          }
        }
      }
      container segment {
        tailf:info "REP segment ID";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf id {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-1024>;;Between 1 and 1024";
            range "1..1024";
          }
        }
        leaf edge {
          tailf:info "Edge Port";
          tailf:cli-optional-in-sequence;
          type empty;
        }
        leaf primary {
          tailf:info "Primary Edge Port";
          tailf:cli-optional-in-sequence;
          when "../edge" {
            tailf:dependency "../edge";
          }
          type empty;
        }
        leaf preferred {
          tailf:info "Preferred Alternate Port";
          type empty;
        }
      }
      container stcn {
        tailf:info "Segment Topology Change Notification";
        //  interface  for interface
        leaf segment {
          tailf:info "for REP segment";
          type string {
            tailf:info "WORD;;segment ID list (1-1024) ex: 1-3,6-9";
          }
        }
        leaf stp {
          tailf:info "for STP network";
          type empty;
        }
      }
    }

    // interface * / rcv-queue
    container rcv-queue {
      tailf:info "Configure receive queue(s)";
      list cos-map {
        tailf:info "Configure cos-map for a queue threshold";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key "queue-id threshold-id";
        leaf queue-id {
          type uint8 {
            tailf:info "<1-3>;;enter cos-map queue id";
            range "1..3";
          }
        }
        leaf threshold-id {
          type uint8 {
            tailf:info "<1-8>;;enter cos-map threshhold id";
            range "1..8";
          }
        }
        leaf-list cos-values {
          tailf:cli-drop-node-name;
          tailf:cli-flat-list-syntax;
          max-elements 8;
          type uint8 {
            tailf:info "<0-7>;;cos values separated by spaces (up to 8 values "
              +"total)";
            range "0..7";
          }
        }
      }
    }

    // interface * / udld
    container udld {
      tailf:info "Configure UDLD enabled or disabled and ignore global UDLD "
        +"setting";
      container port {
        tailf:info "Enable UDLD protocol on this interface despite global UDLD "
          +"setting";
        tailf:cli-delete-when-empty;
        presence true;
        choice port-choice {
          leaf aggressive {
            tailf:info "Enable UDLD protocol in aggressive mode on this "
              +"interface despite global UDLD setting";
            type empty;
          }
          leaf disable {
            tailf:info "Disable UDLD protocol on this interface despite global "
              +"UDLD setting";
            type empty;
          }
        }
      }
    }

    // interface * / peer
    container peer {
      tailf:info "Peer parameters for point to point interfaces";
      container "default" {
        tailf:info "Specify default parameters";
        container ip {
          tailf:info "Specify default IP parameters";
          // interface * / peer default ip address
          container address {
            tailf:info "Specify default IP address";
            choice address-choice {
              leaf dhcp {
                tailf:info "Use DHCP proxy client mechanism to allocate a peer "
                  +"IP address";
                type empty;
              }
              container dhcp-pool {
                tailf:info "Use local DHCP pools to allocate a peer IP address";
                presence true;
                leaf pools {
                  tailf:cli-drop-node-name;
                  tailf:cli-multi-value;
                  type string {
                    tailf:info "LINE;;List of one or more DHCP address pools";
                  }
                }
              }
              container pool {
                tailf:info "Use IP pool mechanism to allocate a peer IP "
                  +"address";
                presence true;
                leaf pools {
                  tailf:cli-drop-node-name;
                  tailf:cli-multi-value;
                  type string {
                    tailf:info "LINE;;List of one or more DHCP address pools";
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  // grouping interface-common-grouping


  // interface-ethernet-grouping
  grouping interface-ethernet-grouping {

    // interface * / carrier-delay
    container carrier-delay {
      tailf:info "Specify delay for interface transitions";
      choice delay-choice {
        leaf seconds {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<0-60>  Carrier Transitions delay seconds";
            range "0..60";
          }
        }
        leaf msec {
          tailf:info "delay specified in milliseconds";
          type uint16 {
            tailf:info "<0-1000>;;Carrier Transitions delay milliseconds";
            range "0..1000";
          }
        }
      }
    }

    // interface * / channel-group
    container channel-group {
      tailf:info "Add this interface to an Etherchannel group";
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-compact-syntax;
      leaf number {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint16 {
          tailf:info "<1-512>;;Channel group number";
          range "1..512";
        }
      }
      leaf mode {
        tailf:info "Etherchannel Mode of the interface";
        type enumeration {
          enum active {
            tailf:info "Enable LACP unconditionally";
          }
          enum auto {
            tailf:info "Enable PAgP only if a PAgP device is detected";
          }
          enum desirable {
            tailf:info "Enable PAgP unconditionally";
          }
          enum on {
            tailf:info "Enable Etherchannel only";
          }
          enum passive {
            tailf:info "Enable LACP only if a LACP device is detected";
          }
        }
      }
    }

    // interface * / channel-protocol
    leaf channel-protocol {
      tailf:info "Select the channel protocol (LACP, PAgP)";
      type enumeration {
        enum lacp {
          tailf:info "Prepare interface for LACP protocol";
        }
        enum pagp {
          tailf:info "Prepare interface for PAgP protocol";
        }
      }
    }

    // interface * / ethernet
    container ethernet {
      tailf:info "Ethernet interface parameters";
      container oam {
        tailf:info "To enable Ethernet Link OAM";
        presence true;
        leaf max-rate {
          type uint8 {
            tailf:info "Maximum number of OAM PDUs sent per second";
            range "1..10";
          }
        }
        leaf min-rate {
          type uint8 {
            tailf:info "Minimum transmission rate in seconds";
            range "1..10";
          }
        }
        leaf mode {
          type enumeration {
            enum "active" {
              tailf:info "Active OAM client mode";
            }
            enum "passive" {
              tailf:info "Passive OAM client mode";
            }
          }
        }
        leaf timeout {
          type uint8 {
            tailf:info "OAM client timeout in seconds";
            range "2..30";
          }
        }
      }
    }

    // interface * / negotiation
    leaf negotiation {
      tailf:info "Select autonegotiation mode";
      type enumeration {
        tailf:info "Enable link autonegotiation";
        enum auto {

        }
      }
    }

    // interface * / duplex
    leaf duplex {
      tailf:info "Configure duplex operation.";
      type enumeration {
        enum auto {
          tailf:code-name "duplex_auto";
          tailf:info "Enable AUTO duplex configuration";
        }
        enum full {
          tailf:code-name "duplex_full";
          tailf:info "Force full duplex operation";
        }
        enum half {
          tailf:code-name "duplex_half";
          tailf:info "Force half-duplex operation";
        }
      }

    }

    // interface * / speed
    leaf speed {
      tailf:info "Configure speed operation.";
      type enumeration {
        enum "10" {
          tailf:info "Force 10 Mbps operation";
        }
        enum "100" {
          tailf:info "Force 100 Mbps operation";
        }
        enum "1000" {
          tailf:info "Enable AUTO speed configuration";
        }
        enum "nonegotiate" {
          //FIXME
        }
        enum "auto" {
          tailf:info "Enable AUTO speed configuration";
        }
      }
    }

    // interface * / xconnect
    container xconnect {
      tailf:info "Xconnect commands";
      tailf:cli-sequence-commands;
      tailf:cli-compact-syntax;
      leaf address {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;IP address of peer";
        }
      }
      leaf vcid {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint32 {
          tailf:info "<1-4294967295>;;Enter VC ID value";
          range "1..4294967295";
        }
      }
      // interface * / xconnect encapsulation
      leaf encapsulation {
        tailf:info "Data encapsulation method";
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum mpls {
            tailf:code-name "encap_mpls";
            tailf:info "Use MPLS encapsulation";
          }
          enum l2tpv3 {
            tailf:info "Use L2TPv3 encapsulation";
          }
        }
      }
      leaf manual {
        tailf:info "Manually configure L2TP session parameters";
        tailf:cli-optional-in-sequence;
        when "../encapsulation = 'l2tpv3'";
        type empty;
      }
      leaf sequence {
        tailf:info "Configure sequencing options for xconnect";
        tailf:cli-full-command;
        tailf:cli-optional-in-sequence;
        when "../encapsulation = 'l2tpv3'";
        type enumeration {
          enum both {
            tailf:info "Transmit and receive sequence numbers";
          }
          enum receive {
            tailf:info "Receive sequence numbers";
          }
          enum transmit {
            tailf:info "Transmit sequence numbers";
          }
        }
      }
      leaf pw-class {
        tailf:info "Pseudowire-class to use for encapsulation "
          +"and protocol "
          +"configuration";
        type string {
          tailf:info "WORD;;Pseudowire-class name";
        }
      }
    }

    // interface * / pppoe
    container pppoe {
      tailf:info "pppoe interface subcommands";
      container enable {
        tailf:info "Enable pppoe";
        presence true;
        leaf group {
          tailf:info "attach a BBA group";
          type union {
            type string {
              tailf:info "WORD;;BBA Group name";
            }
            type enumeration {
              enum global {
                tailf:info "Attach global PPPoE group";
              }
            }
          }
        }
      }
      leaf max-sessions {
        tailf:info "Maximum PPPOE sessions";
        type uint16 {
          tailf:info "<1-4085>;;Maximum PPPOE sessions";
          range "1..4085";
        }
      }
    }

  } // interface-ethernet-grouping


  // interface-zone-member-grouping
  grouping interface-zone-member-grouping {
    // interface * / zone-member
    container zone-member {
      tailf:info "Apply zone name";
      leaf security {
        tailf:info "Security zone";
        type string;
        tailf:non-strict-leafref {
          path "/ios:zone/security/id";
        }
      }
    }
  }   // interface-zone-member-grouping


  // interface-pointtopoint-grouping
  grouping interface-pointtopoint-grouping {

    // interface * / ppp
    container ppp {
      tailf:info "Point-to-Point Protocol";
      // interface * / ppp accounting
      leaf accounting {
        tailf:info "Set PPP network accounting method";
        type union {
          type string {
            tailf:info "WORD;;Named accounting list.";
          }
          type enumeration {
            enum "default" {
              tailf:info "The default accounting list.";
            }
          }
        }
      }
      // interface * / ppp authentication
      container authentication {
        tailf:info "Set PPP link authentication method";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf method {
          tailf:cli-drop-node-name;
          type enumeration {
            enum chap {
              tailf:info "Challenge Handshake Authentication Protocol (CHAP)";
            }
            enum eap {
              tailf:info "Extensible Authentication Protocol (EAP)";
            }
            enum ms-chap {
              tailf:info "Microsoft Challenge Handshake Authentication "
                +"Protocol (MS-CHAP)";
            }
            enum ms-chap-v2 {
              tailf:info "Microsoft CHAP Version 2 (MS-CHAP-V2)";
            }
            enum pap {
              tailf:info "Password Authentication Protocol (PAP)";
            }
          }
        }
        leaf list-name {
          tailf:cli-break-sequence-commands;
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;Use an authentication list with this name";
          }
          tailf:cli-disallow-value "(callback)|(callin)|(callout)|(default)|"
            +"(eap)|(ms-chap)|(ms-chap-v2)|(one-time)|(optional)|(pap)";
        }
        leaf chap {
          when "not(../method = 'chap')" {
            tailf:dependency "../method";
          }
          tailf:info "Challenge Handshake Authentication Protocol (CHAP)";
          type empty;
        }
        leaf callback {
          tailf:info "Authenticate remote on callback only";
          type empty;
        }
        leaf callin {
          tailf:info "Authenticate remote on incoming call only";
          type empty;
        }
        leaf callout {
          tailf:info "Authenticate remote on outgoing call only";
          type empty;
        }
        leaf "default" {
          tailf:info "Use the default authentication list";
          type empty;
        }
        leaf eap {
          when "not(../method = 'eap')" {
            tailf:dependency "../method";
          }
          tailf:info "Extensible Authentication Protocol (EAP)";
          type empty;
        }
        leaf ms-chap {
          when "not(../method = 'ms-chap')" {
            tailf:dependency "../method";
          }
          tailf:info "Microsoft Challenge Handshake Authentication Protocol ("
            +"MS-CHAP)";
          type empty;
        }
        leaf ms-chap-v2 {
          when "not(../method = 'ms-chap-v2')" {
            tailf:dependency "../method";
          }
          tailf:info "Microsoft CHAP Version 2 (MS-CHAP-V2)";
          type empty;
        }
        leaf one-time {
          tailf:info "Allow use of username*OTP for one-time passwords";
          type empty;
        }
        leaf optional {
          tailf:info "Allow peer to refuse to authenticate";
          type empty;
        }
        leaf pap {
          when "not(../method = 'pap')" {
            tailf:dependency "../method";
          }
          tailf:info "Password Authentication Protocol (PAP)";
          type empty;
        }
      }
      // interface * / ppp authorization
      leaf authorization {
        tailf:info "Set PPP network authorization method";
        type union {
          type string {
            tailf:info "WORD;;Named authorization list.";
          }
          type enumeration {
            enum "default" {
              tailf:info "The default authorization list.";
            }
          }
        }
      }
      // interface * / ppp ipcp
      container ipcp {
        tailf:info "Set IPCP negotiation options";
        container dns {
          tailf:info "Specify DNS negotiation options";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf primary {
            tailf:cli-drop-node-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Primary DNS IP address";
            }
          }
        }
      }
      // interface * / ppp multilink
      container multilink {
        tailf:info "Make interface multilink capable";
        tailf:cli-display-separated;
        presence true;
        // interface * / ppp multilink links
        container links {
          tailf:info "Specify the limits on the number of links in a bundle";
          container minimum {
            tailf:info "Minimum number of links desired in the bundle";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-all-siblings;
            }
            leaf minimum-value {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<1-255>;;Specify minimum desired number of "+
                  "links in a bundle";
              }
            }
            leaf mandatory {
              tailf:info "Disable network layer until minimum number of "+
                "links is reach";
              type empty;
            }
          }
        }
        // interface * / ppp multilink group
        leaf group {
          tailf:info "Put interface in a multilink bundle";
          type uint32 {
            tailf:info "<1-2147483647>;;Multilink group number";
            range "1..2147483647";
          }
        }
        // interface * / ppp multilink fragment
        container fragment {
          tailf:info "Specify fragmentation parameters";
          container delay {
            tailf:info "Specify the maximum delay for each fragment";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf delay-value {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<0-1000>;;Delay in milliseconds";
                range "0..1000";
              }
            }
            leaf additional-delay-value {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<1-999>;;Additional delay in microseconds";
                range "1..999";
              }
            }
          }
        }
      }
    }
  } // interface-pointtopoint-grouping


  // crypto pki token grouping
  grouping crypto-pki-token-grouping {
    // max-retries  maximum number of consecutive login failures permitted
    container removal {
      tailf:info "actions to take after token removal";
      leaf timeout {
        tailf:info "seconds after token removal at which keys "
          +"from the token are cleared";
        type uint16 {
          tailf:info "<0-480>;;Token key timeout in seconds";
          range "0..480";
        }
      }
    }
    // secondary    token-specific configuration files
    // user-pin     PIN to access token
  }

  // max-path-grouping
  grouping max-path-grouping {
    container max-path {
      tailf:cli-drop-node-name;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf max {
        tailf:cli-drop-node-name;
        type uint16 {
          range "1..16";
          tailf:info "<1-16>;;Number of paths";
        }
        default "1";
      }
      leaf import {
        tailf:info "Maximum import paths";
        type uint16 {
          range "1..16";
          tailf:info "<1-16>;;Number of import paths";
        }
      }
    }
  }

  // metric-route-map-grouping
  grouping metric-route-map-grouping {
    leaf metric {
      tailf:cli-break-sequence-commands;
      tailf:info "Metric for redistributed routes";
      type uint32 {
        range "0..4294967295";
        tailf:info "<0-4294967295>;;Default metric";
      }
    }
    leaf route-map {
      tailf:info "Route map reference";
      type string {
        tailf:info "WORD;;Pointer to route-map entries";
      }
    }
  }

  // route-map-metric-grouping
  grouping route-map-metric-grouping {
    leaf route-map {
      tailf:info "Route map reference";
      type string {
        tailf:info "WORD;;Pointer to route-map entries";
      }
    }
    leaf metric {
      tailf:info "Metric for redistributed routes";
      type uint32 {
        range "0..4294967295";
        tailf:info "<0-4294967295>;;Default metric";
      }
    }
  }

  // redistribute-isis-grouping
  grouping redistribute-isis-grouping {
    choice osi-ip-choice {
      leaf ip {
        tailf:info "Redistribution of IP dynamic routes";
        type empty;
      }
      leaf clns {
        tailf:info "Redistribution of OSI dynamic routes";
        type empty;
      }
    }
    leaf routes {
      tailf:cli-drop-node-name;
      type enumeration {
        enum level-1 {
          tailf:info "IS-IS level-1 routes only";
        }
        enum level-2 {
          tailf:info "IS-IS level-2 routes only";
        }
        enum level-1-2 {
          tailf:info "IS-IS level-1 and level-2 routes";
        }
      }
    }
    uses metric-route-map-grouping;
  }

  // bgp-address-family-grouping
  grouping bgp-address-family-grouping {
    container aggregate-address {
      tailf:info "Configure BGP aggregate entries";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      leaf address {
        tailf:cli-drop-node-name;
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Aggregate address";
        }
      }
      leaf mask {
        tailf:cli-drop-node-name;
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Aggregate mask";
        }
      }
      leaf advertise-map {
        tailf:cli-break-sequence-commands;
        tailf:info "Set condition to advertise attribute";
        type string {
          tailf:info "WORD;;Route map to control attribute "
          +"advertisement";
        }
      }
      leaf as-set {
        tailf:info "Generate AS set path information";
        type empty;
      }
      leaf attribute-map {
        type string {
          tailf:info "WORD;;Route map for parameter control";
        }
      }
      leaf as-override {
        tailf:info "Override matching AS-number while sending update";
        type empty;
      }
      leaf route-map {
        type string {
          tailf:info "WORD;;Route map for parameter control";
        }
      }
      leaf summary-only {
        tailf:info "Filter more specific routes from updates";
        type empty;
      }
      leaf suppress-map {
        tailf:info "Conditionally filter more specific routes from "
        +"updates";
        type string {
          tailf:info "WORD;;Route map for suppression";
        }
      }
    }

    // router bgp * / bgp
    container bgp {
      tailf:info "BGP specific commands";
      //tailf:cli-incomplete-command;

      // router bgp * / bgp router-id
      leaf router-id {
        tailf:cli-full-command;
        tailf:info "Override configured router identifier (peers will "
        +"reset)";
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Manually configured router identifier";
        }
      }

      // router bgp * / bgp always-compare-med
      leaf always-compare-med {
        tailf:info "Allow comparing MED from different neighbors";
        tailf:cli-full-command;
        type empty;
      }

      // router bgp * / bgp bestpath
      container bestpath {
        tailf:info "Change the default bestpath selection";
        leaf compare-routerid {
          tailf:cli-full-command;
          tailf:info "Compare router-id for identical EBGP paths";
          type empty;
        }
        container cost-community {
          tailf:info "cost community";
          leaf ignore {
            tailf:info "Ignore cost communities in bestpath "
            +"selection";
            type empty;
          }
        }
        container med {
          tailf:info "MED attribute";
          choice med-choice {
            container confed {
              tailf:info "Compare MED among confederation paths";
              presence "Compare MED among confederation paths";
              leaf missing-at-worst {
                tailf:info "Treat missing MED as the least "
                +"preferred one";
                type empty;
              }
            }
            leaf missing-at-worst {
              tailf:info "Treat missing MED as the least "
              +"preferred one";
              type empty;
            }
          }
        }
      }

      // router bgp * / bgp client-to-client
      container client-to-client {
        tailf:info "Configure client to client route reflection";
        leaf reflection {
          tailf:info "reflection of routes allowed";
          type empty;
        }
      }

      // router bgp * / bgp cluster-id
      leaf cluster-id {
        tailf:cli-full-command;
        type union {
          type uint32 {
            range "1..4294967295";
            tailf:info "<1-4294967295>;;Route-Reflector Cluster-id "
            +"as 32 bit quantity";
          }
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Route-Reflector Cluster-id in IP "
            +"address format";
          }
        }
      }

      // router bgp * / bgp confederation
      container confederation {
        tailf:info "AS confederation parameters";
        leaf identifier {
          tailf:cli-full-command;
          tailf:info "as number";
          type uint16 {
            range "1..65535";
            tailf:info "<1-65535>;;Set routing domain "
            +"confederation AS";
          }
        }
        container peers {
          tailf:info "Peer ASs in BGP confederation";
          presence "Peer ASs in BGP confederation";
          leaf-list peers-as {
            tailf:cli-drop-node-name;
            tailf:cli-flat-list-syntax;
            type uint16 {
              range "1..65535";
              tailf:info "AS number";
            }
          }
        }
      }

      // router bgp * / bgp dampening
      container dampening {
        tailf:info "Enable route-flap dampening";
        presence "enable bgp route-flap dampening";
        choice dampening-choice {
          leaf route-map {
            tailf:info "Route-map to specify criteria for "
            +"dampening";
            type string {
              tailf:info "WORD;;route-map name";
            }
          }
          container dampen {
            tailf:cli-drop-node-name;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf half-life-time {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint8 {
                range "1 .. 45";
                tailf:info "<1-45>;;Half-life time for the "
                +"penalty";
              }
            }
            leaf reuse-time {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint16 {
                range "1 .. 20000";
                tailf:info "<1-20000>;;Value to start reusing "
                +"a route";
              }
            }
            leaf suppress-time {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint16 {
                range "1 .. 20000";
                tailf:info "<1-20000>;;Value to start "
                +"suppressing a route";
              }
            }
            leaf max-suppress-time {
              tailf:cli-drop-node-name;
              type uint8 {
                range "1 .. 255";
                tailf:info "<1-255>  Maximum duration to "
                +"suppress a stable route";
              }
            }
          }
        }
      }

      // router bgp * / bgp default
      container "default" {
        tailf:info "Configure BGP defaults";
        choice default-choice {
          leaf ipv4-unicast {
            tailf:info "Activate ipv4-unicast for a peer by default";
            tailf:cli-boolean-no;
            tailf:cli-trim-default;
            type boolean;
            default true;
          }
          leaf local-preference {
            tailf:info "local preference (higher=more preferred)";
            type uint32 {
              range "1..4294967295";
              tailf:info "<0-4294967295>;;Configure default "
              +"local preference value";
            }
          }
          leaf route-target {
            tailf:info "Control behavior based on Route-Target "
            +"attributes";
            type enumeration {
              enum filter {
                tailf:info "Control automatic VPN Route-Target "
                +"filtering";
              }
            }
          }
        }
      }

      // router bgp * / bgp deterministic-med
      leaf deterministic-med {
        tailf:cli-full-command;
        tailf:info "Pick the best-MED path among paths advertised from "
        +"the neighboring AS";
        type empty;
      }

      // router bgp * / bgp dmzlink-bw
      leaf dmzlink-bw {
        tailf:cli-full-command;
        tailf:info "Use DMZ Link Bandwidth as weight for BGP "
          +"multipaths";
        type empty;
      }

      // router bgp * / bgp enforce-first-as
      leaf enforce-first-as {
        tailf:cli-full-command;
        tailf:info "Enforce the first AS for EBGP routes(default)";
        type empty;
      }

      // router bgp * / bgp fast-external-fallover
      leaf fast-external-fallover {
        tailf:cli-full-command;
        tailf:info "Immediately reset session if a link to a directly "
        +"connected external peer goes down";
        type empty;
      }

      // router bgp * / bgp graceful-restart
      container graceful-restart {
        tailf:info "Graceful restart capability parameters";
        presence "Graceful restart capability parameters";
        leaf restart-time {
          tailf:cli-full-command;
          tailf:info "Set the max time needed to restart and come "
          +"back up";
          type uint16 {
            range "1..3600";
            tailf:info "<1-3600>;;Delay value (seconds)";
          }
        }
        leaf stalepath-time {
          tailf:info "Set the max time to hold onto restarting "
          +"peer's stale paths";
          type uint16 {
            range "1..3600";
            tailf:info "<1-3600>;;Delay value (seconds)";
          }
        }
      }

      // router bgp * / bgp inject-map *
      list inject-map {
        tailf:info "Routemap which specifies prefixes to inject";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;route-map name";
          }
        }
        leaf exist-map {
          tailf:info "Routemap which specifies exist condition";
          type string {
            tailf:info "WORD;;route-map name";
          }
        }
        leaf copy-attributes {
          tailf:info "Copy attributes from aggregate";
          type empty;
        }
      }

      // router bgp * / bgp log-neighbor-changes
      leaf log-neighbor-changes {
        tailf:info "Log neighbor up/down and reset reason";
        tailf:cli-full-command;
        type empty;
      }

      // router bgp * / bgp maxas-limit
      leaf maxas-limit {
        tailf:info "Allow AS-PATH attribute from any neighbor imposing "
        +"a limit on number of ASes";
        tailf:cli-full-command;
        type uint16 {
          range "1..2000";
          tailf:info "<1-2000>;;Number of ASes in the AS-PATH "
          +"attribute";
        }
      }

      // router bgp * / bgp nexthop
      container nexthop {
        tailf:info "Nexthop tracking commands";
        container trigger {
          tailf:info "Nexthop triggering";
          leaf delay {
            tailf:cli-full-command;
            tailf:info "Set the delay to tigger nexthop tracking";
            type uint8 {
              range "0..100";
              tailf:info "<0-100>;;Delay value (seconds)";
            }
          }
          leaf enable {
            tailf:info "Enable nexthop tracking";
            tailf:cli-full-command;
            tailf:cli-boolean-no;
            type boolean;
            default true;
          }
        }
      }

      // router bgp * / bgp redistribute-internal
      leaf redistribute-internal {
        tailf:info "Allow redistribution of iBGP into IGPs (dangerous)";
        tailf:cli-full-command;
        type empty;
      }

      // router bgp * / bgp regexp
      container regexp {
        tailf:info "Select regular expression engine";
        leaf deterministic {
          tailf:info "Enable bounded-execution-time regular "
          +"expression engine";
          type empty;
        }
      }

      // router bgp * / bgp scan-time
      leaf scan-time {
        tailf:cli-full-command;
        tailf:info "Configure background scanner interval";
        type uint8 {
          range "5..60";
          tailf:info "<5-60>;;Scanner interval (seconds)";
        }
      }

      // router bgp * / bgp soft-reconfig-backup
      leaf soft-reconfig-backup {
        tailf:info "Use soft-reconfiguration inbound only when route-"
        +"refresh is not negotiated";
        tailf:cli-full-command;
        type empty;
      }

      // router bgp * / bgp suppress-inactive
      leaf suppress-inactive {
        tailf:info "Suppress routes that are not in the routing table";
        tailf:cli-full-command;
        type empty;
      }

      // router bgp * / bgp update-delay
      leaf update-delay {
        tailf:cli-full-command;
        tailf:info "Set the max initial delay for sending update";
        type uint16 {
          range "1..3600";
          tailf:info "<1-3600>;;Delay value (seconds)";
        }
      }
    }

    // router bgp * / default-information
    container default-information {
      tailf:info "Control distribution of default information";
      leaf originate {
        tailf:info "Distribute a default route";
        type empty;
      }
    }

    // router bgp * / default-metric
    leaf default-metric {
      tailf:info "Set metric of redistributed routes";
      tailf:cli-full-command;
      type uint32 {
        range "1..4294967295";
        tailf:info "<1-4294967295>;;Default metric";
      }
    }

    // router bgp * / distance
    container distance {
      tailf:info "Define an administrative distance";
      container bgp {
        tailf:info "BGP distance";
        tailf:cli-sequence-commands;
        tailf:cli-compact-syntax;
        leaf extern-as {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<1-255>;;Distance for routes external to "
            +"the AS";
            range "1..255";
          }
        }
        leaf internal-as {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<1-255>;;Distance for routes internal to "
              +"the AS";
            range "1..255";
          }
        }
        leaf local {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-255>;;Distance for local routes";
            range "1..255";
          }
        }
      }
      list adm-distance {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "distance srcip wildbits";
        leaf distance {
          type uint16 {
            tailf:info "<1-255>;;Administrative distance";
            range "1..255";
          }
        }
        leaf srcip {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP Source address";
          }
        }
        leaf wildbits {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Wildcard bits";
          }
        }
        leaf acl {
          tailf:cli-drop-node-name;
          type union {
            type uint16 {
              range "1..99" {
                tailf:info "<1-99>;;IP Standard access list "
                +"number";
              }
            }
            type uint16 {
              range "1300..1999" {
                tailf:info "<1300-1999>;;IP Standard expanded "
                +"access list number";
              }
            }
            type string {
              pattern '[a-zA-Z].*';
              tailf:info "WORD;;Standard access-list name";
            }
          }
        }
      }
    }

    // router bgp * / distribute-list
    list distribute-list {
      tailf:info "Filter networks in routing updates";
      tailf:cli-compact-syntax;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key id;
      leaf id {
        tailf:cli-incomplete-command;
        type bgp-distribute-list-type;
      }
      choice in-out-choice {
        container in {
          presence "enable incoming routing updates";
          tailf:info "Filter incoming routing updates";
          leaf interface {
            // FIXME: interface container
            type string;
          }
        }
        container out {
          presence "enable outgoing routing updates";
          tailf:info "Filter outgoing routing updates";
          leaf interface {
            // FIXME: interface container + routing protocols
            type string;
          }
        }
      }
    }

    // router bgp * / maximum-paths
    container maximum-paths {
      tailf:info "Forward packets over multiple paths";
      choice max-path-choice {
        case eibgp-case {
          container eibgp {
            tailf:info "Both eBGP and iBGP paths as multipath";
            uses max-path-grouping;
          }
        }
        case ibgp-case {
          container ibgp {
            tailf:info "iBGP-multipath";
            choice ibgp-choice {
              case a {
                container unequal-cost {
                  tailf:info "Perform Un-Equal cost multipath selection";
                  uses max-path-grouping;
                }
              }
              case b {
                uses max-path-grouping;
              }
            }
          }
        }
        case none-case {
          uses max-path-grouping;
        }
        case import-case {
          leaf import {
            tailf:info "Maximum import paths";
            type uint16 {
              range "1..16";
              tailf:info "<1-16>;;Number of import paths";
            }
          }
        }
      }
    }

    // router bgp * / neighbor *
    list neighbor {
      tailf:info "Specify a neighbor router";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      ordered-by "user";
      must "count(*) > 1" {
        tailf:dependency ".";
      }
      key id;
      leaf id {
        type union {
          type string {
            tailf:info "WORD;;Neighbor tag";
          }
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Neighbor address";
          }
          type inet:ipv6-address {
            tailf:info "X:X:X:X::X;;Neighbor IPv6 address";
          }
        }
      }
      // router bgp * / neighbor * peer-group
      container peer-group {
        tailf:info "Member of the peer-group";
        tailf:cli-delete-when-empty;
        presence true;
        leaf peer-group-name {
          tailf:info "WORD;;peer-group name";
          tailf:cli-drop-node-name;
          tailf:cli-delete-container-on-delete;
          tailf:cli-full-command;
          type string;
        }
      }
      // router bgp * / neighbor * remote-as
      leaf remote-as {
        tailf:info "Specify a BGP neighbor";
        tailf:cli-full-command;
        tailf:cli-delete-container-on-delete;
        type uint16 {
          tailf:info "<1-65535>  AS of remote neighbor";
          range "1..65535";
        }
      }
      // router bgp * / neighbor * local-as
      container local-as {
        tailf:info "Specify a local-as number";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-delete-when-empty;
        presence "Specify a local-as number";
        leaf as-no {
          tailf:cli-drop-node-name;
          type uint16 {
            range "1..65535";
            tailf:info "<1-65535>;;AS number used as local AS";
          }
        }
        leaf no-prepend {
          tailf:info "Do not prepend local-as to updates from ebgp "
          +"peers";
          type empty;
        }
        leaf replace-as {
          tailf:info "Replace real AS with local AS in the EBGP "
          +"updates";
          type empty;
        }
        leaf dual-as {
          tailf:info "Accept either real AS or local AS from the "
          +"ebgp peer";
          type empty;
        }
      }
      // router bgp * / neighbor * activate
      leaf activate {
        tailf:info "Enable the Address Family for this Neighbor";
        tailf:cli-full-command;
        //must "(../remote-as or ../peer-group)" {
        //  tailf:dependency "../remote-as";
        //  tailf:dependency "../peer-group";
       // }
        type empty;
      }
      // router bgp * / neighbor * advertisement-interval
      leaf advertisement-interval {
        tailf:info "Minimum interval between sending BGP routing "
        +"updates";
        tailf:cli-full-command;
        type uint16 {
          range "0..600";
          tailf:info "<0-600>;;time in seconds";
        }
      }
      // router bgp * / neighbor * allowas-in
      container allowas-in {
        tailf:info "Accept as-path with my AS present in it";
        presence "accept as-paths";
        tailf:cli-delete-when-empty;
        leaf as-number {
          tailf:cli-drop-node-name;
          type uint8 {
            range "1..10";
            tailf:info "<1-10>  Number of occurances of AS number";
          }
        }
      }
      // router bgp * / neighbor * as-override
      container as-override {
        tailf:info "Override matching AS-number while sending update";
        tailf:cli-delete-when-empty;
        presence true;
        leaf disable {
          type empty;
        }
      }
      // router bgp * / neighbor * capability
      container capability {
        tailf:info "Advertise capability to the peer";
        container orf {
          tailf:info "Advertise ORF capability to the peer";
          leaf-list prefix-list {
            tailf:cli-flat-list-syntax;
            tailf:info "Advertise prefixlist ORF capability to "
            +"this neighbor";
            max-elements 1;
            type enumeration {
              enum both {
                tailf:info "Capability to SEND and RECEIVE the "
                +"ORF to/from this neighbor";
              }
              enum receive {
                tailf:info "Capability to RECEIVE the ORF from "
                +"this neighbor";
              }
              enum send {
                tailf:info "Capability to SEND the ORF to this "
                +"neighbor";
              }
            }
          }
        }
      }
      // router bgp * / neighbor * default-originate
      container default-originate {
        tailf:info "Originate default route to this neighbour";
        tailf:cli-delete-when-empty;
        presence "enable originate default route to this neighbour";
        leaf route-map {
          tailf:info "Route-map to specify criteria to originate "
          +"default";
          type string {
            tailf:info "WORD;;route-map name";
          }
        }
      }
      // router bgp * / neighbor * description
      leaf "description" {
        tailf:info "Neighbor specific description";
        tailf:cli-full-command;
        tailf:cli-multi-value;
        type string {
          tailf:info "LINE;;Up to 80 characters describing this "
          +"neighbor";
        }
      }
      // router bgp * / neighbor * disable-connected-check
      leaf disable-connected-check {
        tailf:info "One-hop away EBGP peer using loopback address";
        tailf:cli-full-command;
        type empty;
      }
      // router bgp * / neighbor * distribute-list *
      list distribute-list {
        tailf:info "Filter updates to/from this neighbor";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key inout;
        leaf inout {
          type enumeration {
            enum in {
              tailf:code-name "dist_in";
              tailf:info "Filter incoming updates";
            }
            enum out {
              tailf:code-name "dist_out";
              tailf:info "Filter outgoing updates";
            }
          }
        }
        leaf accesslist {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type bgp-distribute-list-type2;
          mandatory true;
        }
      }
      // router bgp * / neighbor * dmzlink-bw
      leaf dmzlink-bw {
        tailf:info "Propagate the DMZ link bandwidth";
        tailf:cli-full-command;
        type empty;
      }
      // router bgp * / neighbor * ebgp-multihop
      container ebgp-multihop {
        tailf:info "Allow EBGP neighbors not on directly connected "
          +"networks";
        tailf:cli-delete-when-empty;
        presence "Allow EBGP neighbors not on directly connected "
          +"networks";
        leaf max-hop {
          tailf:cli-drop-node-name;
          type uint8 {
            range "1..255";
            tailf:info "<1-255>;;maximum hop count";
          }
        }
      }
      // router bgp * / neighbor * fall-over
      leaf fall-over {
        tailf:info "session fall on peer route lost";
        tailf:cli-full-command;
        type empty;
      }
      // router bgp * / neighbor * filter-list *
      list filter-list {
        tailf:info "Establish BGP filters";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key inout;
        leaf inout {
          type enumeration {
            enum in {
              tailf:code-name "filter_in";
              tailf:info "Filter incoming routes";
            }
            enum out {
              tailf:code-name "filter_out";
              tailf:info "Filter outgoing routes";
            }
          }
        }
        leaf as-path-list {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type uint16 {
            range "1..500";
            tailf:info "<1-500>;;AS path access list";
          }
          mandatory true;
        }
      }
      // router bgp * / neighbor * inherit
      container inherit {
        tailf:info "Inherit a template";
        leaf peer-policy {
          tailf:info "Inherit a peer-policy template";
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;Template name";
          }
        }
        leaf peer-session {
          tailf:info "Inherit a peer-session template";
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;Template name";
          }
        }
      }
      // router bgp * / neighbor * maximum-prefix
      container maximum-prefix {
        tailf:info "Maximum number of prefixes accepted from this peer";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        leaf max-prefix-no {
          tailf:cli-drop-node-name;
          type uint32 {
            range "1..2147483647";
            tailf:info "<1-2147483647>;;maximum no. of prefix "
            +"limit";
          }
        }
        leaf threshold {
          tailf:cli-drop-node-name;
          tailf:cli-break-sequence-commands;
          type uint8 {
            range "1..100";
            tailf:info "<1-100>;;Threshold value (%) at which to "
            +"generate a warning msg";
          }
        }
        leaf restart {
          tailf:cli-full-command;
          tailf:info "Restart bgp connection after limit is exceeded";
          type uint16 {
            range "1..65535";
            tailf:info "<1-65535>  Restart interval in minutes";
          }
        }
        leaf warning-only {
          tailf:cli-full-command;
          tailf:info "Only give warning message when limit "
          +"is exceeded";
          type empty;
        }
      }
      // router bgp * / neighbor * next-hop-self
      leaf next-hop-self {
        tailf:cli-full-command;
        tailf:info "Disable the next hop calculation for this neighbor";
        type empty;
      }
      // router bgp * / neighbor * next-hop-unchanged
      leaf next-hop-unchanged {
        tailf:cli-full-command;
        tailf:info "Propagate the iBGP paths's next hop unchanged "
        +"for this neighbor";
        type empty;
      }
      // router bgp * / neighbor * password
      container password {
        // FIXME: better text pattern and reset siblings
        // also when configuration the text
        tailf:info "Set a password";
        tailf:cli-compact-syntax;
        leaf enctype {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          tailf:cli-reset-container;
          type uint8 {
            range "0..7";
            tailf:info "<0-7>;;Encryption type (0 to disable "
            +"encryption, 7 for proprietary)";
          }
          default "0";
        }
        leaf text {
          tailf:cli-drop-node-name;
          tailf:cli-full-command;
          tailf:cli-multi-value;
          tailf:cli-reset-container;
          type string {
            tailf:info "LINE;;The password";
          }
        }
      }
      // router bgp * / neighbor * prefix-list *
      list prefix-list {
        tailf:info "Filter updates to/from this neighbor";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key inout;
        leaf inout {
          type enumeration {
            enum in {
              tailf:code-name "prefix_in";
              tailf:info "Filter incoming updates";
            }
            enum out {
              tailf:code-name "prefix_out";
              tailf:info "Filter outgoing updates";
            }
          }
        }
        leaf prefix-list-name {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type string {
            tailf:info "WORD;;Name of a prefix list";
          }
          mandatory true;
        }
      }
      // router bgp * / neighbor * remove-private-as
      leaf remove-private-as {
        tailf:cli-full-command;
        tailf:info "Remove private AS number from outbound updates";
        type empty;
      }
      // router bgp * / neighbor * route-map *
      list route-map {
        tailf:info "Apply route map to neighbor";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key inout;
        leaf inout {
          type enumeration {
            enum in {
              tailf:code-name "route_in";
              tailf:info "Apply map to incoming routes";
            }
            enum out {
              tailf:code-name "route_out";
              tailf:info "Apply map to outbound routes";
            }
          }
        }
        leaf route-map-name {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type string {
            tailf:info "WORD;;Name of route map";
          }
          mandatory true;
        }
      }
      // router bgp * / neighbor * route-reflector-client
      leaf route-reflector-client {
        tailf:cli-full-command;
        tailf:info "Configure a neighbor as Route Reflector client";
        type empty;
      }
      // router bgp * / neighbor * send-community
      container send-community {
        tailf:info "Send Community attribute to this neighbor";
        tailf:cli-delete-when-empty;
        presence true;
        leaf send-community-where {
          tailf:cli-drop-node-name;
          type enumeration {
            enum both {
              tailf:info "Send Standard and Extended Community "
              +"attributes";
            }
            enum extended {
              tailf:info "Send Extended Community attribute";
            }
            enum standard {
              tailf:code-name "send_standard";
              tailf:info "Send Standard Community attribute";
            }
          }
        }
      }
      // router bgp * / neighbor * send-label
      container send-label {
        tailf:info "Send NLRI + MPLS Label to this peer";
        leaf send-label-explicit {
          tailf:cli-drop-node-name;
          type enumeration {
            enum explicit-null {
              tailf:code-name "send_explicit_null";
              tailf:info "Advertise Explicit Null label in place "
              +"of Implicit Null";
            }
          }
        }
      }
      // router bgp * / neighbor * shutdown
      leaf shutdown {
        tailf:cli-full-command;
        tailf:info "Administratively shut down this neighbor";
        type empty;
      }
      // router bgp * / neighbor * soft-reconfiguration
      leaf soft-reconfiguration {
        tailf:cli-full-command;
        tailf:info "Per neighbor soft reconfiguration";
        type enumeration {
          enum inbound {
            tailf:info "Allow inbound soft reconfiguration for "
            +"this neighbor";
          }
        }
      }
      // router bgp * / neighbor * timers
      container timers {
        tailf:info "BGP per neighbor timers";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf keepalive-interval {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint16 {
            range "0..65535";
            tailf:info "<0-65535>;;Keepalive interval";
          }
        }
        leaf holdtime {
          tailf:cli-drop-node-name;
          type uint16 {
            range "0..65535";
            tailf:info "<0-65535>;;Holdtime";
          }
        }
        leaf minimum-neighbor-hold {
          tailf:cli-drop-node-name;
          type uint16 {
            range "0..65535";
            tailf:info "<0-65535>  Minimum hold time from neighbor";
          }
        }
      }
      // router bgp * / neighbor * translate-update
      container translate-update {
        tailf:info "Translate Update to MBGP format";
        container ipv4 {
          tailf:info "Address Family";
          container multicast {
            tailf:info "Address Family modifier";
            tailf:cli-delete-when-empty;
            presence "Address Family modifier";
            leaf unicast {
              tailf:info "Address Family modifier";
              type empty;
            }
          }
        }
      }
      // router bgp * / neighbor * transport
      container transport {
        tailf:info "Transport options";
        leaf connection-mode {
          tailf:info "Specify passive or active connection";
          type enumeration {
            enum active {
              tailf:info "Actively establish the TCP session";
            }
            enum passive {
              tailf:info "Passively establish the TCP session";
            }
          }
        }
      }
      // router bgp * / neighbor * ttl-security
      container ttl-security {
        tailf:info "BGP ttl security check";
        leaf hops {
          tailf:info "IP hops";
          type uint8 {
            range "1..254";
            tailf:info "<1-254>;;maximum number of hops";
          }
        }
      }
      // router bgp * / neighbor * unsuppress-map
      leaf unsuppress-map {
        tailf:info "Route-map to selectively unsuppress suppressed "
        +"routes";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;Name of route map";
        }
      }
      // router bgp * / neighbor * update-source
      container update-source {
        tailf:info "Source of routing updates";
        tailf:cli-diff-dependency "/ios:interface";
        uses interface-grouping;
      }
      // router bgp * / neighbor * version
      leaf version {
        tailf:cli-full-command;
        tailf:info "Set the BGP version to match a neighbor";
        type uint16 {
          range "4";
          tailf:info "<4-4>;;Neighbor's BGP version";
        }
      }
      // router bgp * / neighbor * version
      leaf weight {
        tailf:cli-full-command;
        tailf:info "Set default weight for routes from this neighbor";
        type uint16 {
          range "0..65535";
          tailf:info "<0-65535>;;default weight";
        }
      }
      // router bgp * / neighbor * ha-mode
      container ha-mode {
        tailf:info "high availability mode";
        container graceful-restart {
          tailf:info "graceful-restart for this peer";
          presence true;
          leaf disable {
            tailf:info "disable graceful-restart";
            type empty;
          }
        }
        container sso {
          tailf:info "stateful-switchover support for this peer";
          presence "true";
          leaf disable {
            tailf:info "disable stateful-switchover";
            type empty;
          }
        }
      }
    }

    // router bgp * / network
    list network {
      tailf:info "Specify a network to announce via BGP";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      key number;
      leaf number {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Network number";
        }
      }
      leaf backdoor {
        tailf:info "Specify a BGP backdoor route";
        tailf:cli-full-command;
        type empty;
      }
      leaf mask {
        tailf:info "Network mask";
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Network mask";
        }
      }
      leaf route-map {
        tailf:info "Route-map to modify the attributes";
        type string {
          tailf:info "WORD;;Name of the route map";
        }
      }
    }

    // router bgp * / redistribute
    container redistribute {
      tailf:info "Redistribute information from another routing protocol";
      container bgp {
        tailf:info "Border Gateway Protocol (BGP)";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        leaf as-no {
          tailf:cli-drop-node-name;
          type uint16 {
            range "1..65535";
            tailf:info "<1-65535>;;Autonomous system number";
          }
        }
        uses metric-route-map-grouping;
      }
      container connected {
        tailf:info "Connected";
        tailf:cli-delete-when-empty;
        presence "Connected";
        uses metric-route-map-grouping;
      }
      container dvmrp {
        tailf:info "Redistribution of DVMRP into BGP IPv4 Multicast";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-delete-when-empty;
        presence "Redistribution of DVMRP into BGP IPv4 Multicast";
        uses route-map-metric-grouping;
      }
      container eigrp {
        tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        leaf as-no {
          tailf:cli-drop-node-name;
          type uint16 {
            range "1..65535";
            tailf:info "<1-65535>;;Autonomous system number";
          }
        }
        uses metric-route-map-grouping;
      }
      container isis {
        // FIXME: need special treatment in GW case
        // The Cisco CLI is inconsisten for this container
        // to go from level-1-2 to level-1 you do "no level-2",
        // for example. Also the metric and route-map settings
        // are not consistently available when they should be.
        tailf:info "ISO IS-IS";
        list isis-area {
          tailf:cli-drop-node-name;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;ISO routing area tag";
              // match all but 'ip', 'level-.*', 'metric', and
              // 'route-map'
              pattern '^([^mlir].*)|(i[^p].*)|(ip..*)|(l[^e].*)'
              +'|(le[^v].*)|(lev[^e].*)|(leve[^l].*)|'
              +'(level[^\-].*)|(m[^e].*)|(me[^t].*)|'
              +'(met[^r].*)|(metr[^i].*)|(metri[^c].*)|'
              +'(metric..*)*(r[^o].*)|(ro[^u].*)|(rou[^t].*)|'
              +'(rout[^e].*)|(route[^\-].*)|(route-[^m].*)|'
              +'(route-m[^a].*)|(route-ma[^p].*)|'
              +'(route-map..*)$';
            }
          }
          uses redistribute-isis-grouping;
        }
        container "default" {
          tailf:cli-drop-node-name;
          uses redistribute-isis-grouping;
        }
      }
      container iso-igrp {
        tailf:info "IGRP for OSI networks";
        list iso-igrp-area {
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-drop-node-name;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Pointer to route-map entries";
              // match any but route-map
              pattern '^([^r].*)|(r^[o].*)|(ro[^u].*)|'
              +'(rou[^t].*)|(rout[^e].*)|(route[^\-].*)|'
              +'(route-[^m].*)|(route-m[^a].*)|'
              +'(route-ma[^p])|(route-map..*)';
            }
          }
          uses route-map-metric-grouping;
        }
        container "default" {
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          uses route-map-metric-grouping;
        }
      }
      container mobile {
        presence "Mobile routes";
        tailf:info "Mobile routes";
        uses metric-route-map-grouping;
      }
      container odr {
        presence "On Demand stub Routes";
        tailf:info "On Demand stub Routes";
        uses metric-route-map-grouping;
      }

      list ospf {
        tailf:info "Open Shortest Path First (OSPF)";
        key id;
        leaf id {
          type uint16 {
            range "1..65535";
            tailf:info "<1-65535>;;Process ID";
          }
        }
        list vrf {
          tailf:info "VPN Routing/Forwarding Instance";
          tailf:cli-diff-dependency "/ios:ip/vrf";
          tailf:cli-diff-dependency "/ios:vrf/definition";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;VPN Routing/Forwarding Instance (VRF) name";
            }
          }
          container match {
            // FIXME: incomplete and confused
            tailf:info "Redistribution of OSPF routes";
          }
          uses metric-route-map-grouping;
        }
        container non-vrf {
          tailf:cli-drop-node-name;
          container match {
            // FIXME: incomplete and confused
            tailf:info "Redistribution of OSPF routes";
          }
          uses metric-route-map-grouping;
        }
      }
      container rip {
        presence "Routing Information Protocol (RIP)";
        tailf:info "Routing Information Protocol (RIP)";
        uses metric-route-map-grouping;
      }
      container static {
        // FIXME: there are two other options: ip and clns but
        // it is highly unclear what they mean. If you set them
        // in the 7200 box, nothing is shown. Seems broken or I'm
        // missing neccessary parts in my config for them to be
        // displayed.
        presence "Static routes";
        tailf:info "Static routes";
        uses metric-route-map-grouping;
      }
    }

    // router bgp * / synchronization
    leaf synchronization {
      tailf:info "Perform IGP synchronization";
      tailf:cli-full-command;
      type empty;
    }

    // router bgp * / auto-summary
    leaf auto-summary {
      tailf:info "Enable automatic network number summarization";
      tailf:cli-boolean-no;
      tailf:cli-trim-default;
      tailf:cli-full-command;
      type boolean;
      default false;
    }

    // router bgp * / table-map
    leaf table-map {
      tailf:info "Map external entry attributes into routing table";
      tailf:cli-full-command;
      type string {
        tailf:info "WORD;;route-map name";
      }
    }

    // router bgp * / timers
    container timers {
      tailf:info "Adjust routing timers";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf keepalive-interval {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint16 {
          range "0..65535";
          tailf:info "<0-65535>;;Keepalive interval";
        }
      }
      leaf holdtime {
        tailf:cli-drop-node-name;
        type uint16 {
          range "0..65535";
          tailf:info "<0-65535>;;Holdtime";
        }
      }
      leaf minimum-neighbor-hold {
        tailf:cli-drop-node-name;
        type uint16 {
          range "0..65535";
          tailf:info "<0-65535>  Minimum hold time from neighbor";
        }
      }
    }
  }

  grouping ospf-ospfv3-common-address-family-grouping {
    container default-information {
      tailf:info "Control distribution of default information";
      container originate {
        tailf:info "Distribute a default route";
        presence "Distribute a default route";
        leaf always {
          tailf:info "Always advertise default route";
          type empty;
        }
        leaf metric {
          tailf:info "OSPF default metric";
          type uint32 {
            range "0 .. 16777214";
            tailf:info "<0-16777214>;;OSPF metric";
          }
          tailf:cli-no-value-on-delete;
        }
        leaf metric-type {
          tailf:info "OSPF metric type for default routes";
          type ospf-metric-type;
          tailf:cli-no-value-on-delete;
        }
        leaf route-map {
          tailf:info "Route map reference";
          type string {
            tailf:info "WORD;;Route map name";
          }
          tailf:cli-no-value-on-delete;
        }
      }
    }

    leaf default-metric {
      tailf:info "Set metric of redistributed routes";
      tailf:cli-full-command;
      type uint32 {
        range "1 .. 16777214";
        tailf:info "<1-16777214>;;OSPF default metric";
      }
    }

    container discard-route {
      tailf:info "Enable or disable discard-route installation";
      presence "Enable or disable discard-route installation";
      tailf:cli-compact-syntax;
      leaf external {
        tailf:info "Discard route for redistributed summarised routes";
        type uint32 {
          range "1 .. 255";
          tailf:info "<1-255>;;Administrative distance for "
          +"redistributed summarised routes";
        }
      }
      leaf internal {
        tailf:info "Discard route for summarised internal routes";
        type uint32 {
          range "1 .. 255";
          tailf:info "<1-255>;;Administrative distance for "
          +"summarised internal routes";
        }
      }
    }

    container distance {
      tailf:cli-compact-syntax;
      tailf:info "Define an administrative distance";
      container ospf-distance {
        tailf:cli-compact-syntax;
        tailf:cli-drop-node-name;
        leaf distance {
          tailf:cli-drop-node-name;
          type uint32 {
            range "1 .. 255";
            tailf:info "<1-255>;;OSPF Administrative distance";
          }
        }
        tailf:cli-sequence-commands;
        leaf ip {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP source address";
          }
        }

        leaf wildcard {
          tailf:cli-drop-node-name;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Wildcard bits";
          }
        }

        leaf acl-name {
          tailf:cli-drop-node-name;
          type access-list-standard-id-type;
          tailf:cli-no-value-on-delete;
        }
      }

      container ospf {
        tailf:info "OSPF routes Administrative distance";
        leaf external {
          tailf:info "External routes";
          type uint32 {
            range "1 .. 255";
            tailf:info "<1-255>;;Distance for external routes";
          }
          tailf:cli-suppress-no;
          tailf:cli-no-value-on-delete;
          tailf:cli-no-name-on-delete;
        }
        leaf inter-area {
          tailf:info "Inter-area routes";
          type uint32 {
            range "1 .. 255";
            tailf:info "<1-255>;;Distance for inter-area routes";
          }
          tailf:cli-suppress-no;
          tailf:cli-no-name-on-delete;
          tailf:cli-no-value-on-delete;
        }
        leaf intra-area {
          tailf:info "Intra-area routes";
          type uint32 {
            range "1 .. 255";
            tailf:info "<1-255>;;Distance for intra-area routes";
          }
          tailf:cli-suppress-no;
          tailf:cli-no-name-on-delete;
          tailf:cli-no-value-on-delete;
        }
      }
    }


    leaf maximum-paths {
      tailf:info "Forward packets over multiple paths";
      tailf:cli-full-command;
      type uint32 {
        range "1 .. 32";
        tailf:info "<1-32>;;Number of paths";
      }
    }

    container redistribute {
      tailf:info "Redistribute information from another routing protocol";
      uses ospf-redistribute-grouping;
      container bgp {
        tailf:info "Border Gateway Protocol (BGP)";
        tailf:cli-sequence-commands;
        uses ospf-redistribute-bgp-grouping;
      }
      container connected {
        tailf:info "Connected";
        presence "Connected";
        uses ospf-redistribute-grouping;
      }
      container eigrp {
        tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
        tailf:cli-sequence-commands;
        uses ospf-redistribute-bgp-grouping;
      }

      container isis {
        presence "ISO IS-IS";
        tailf:info "ISO IS-IS";
        choice isis-level-routes-isis-area-choice {
          leaf isis-level-routes {
            tailf:cli-drop-node-name;
            type enumeration {
              enum level-1 {
                tailf:info "IS-IS level-1 routes only";
              }
              enum level-2 {
                tailf:info "IS-IS level-2 routes only";
              }
              enum level-1-2 {
                tailf:info "IS-IS level-1 and level-2 routes";
              }
            }
          }
          list isis-area {
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-drop-node-name;
            key name;
            leaf name {
              tailf:cli-disallow-value "level-1|level-2|level-1-2|metric|"
              +"metric-type|route-map|subnets|tag";
              type string {
                tailf:info "WORD;;ISO routing area tag";
              }
            }
            uses ospf-redistribute-grouping;
          }
        }
        uses ospf-redistribute-grouping;
      }

      container iso-igrp {
        tailf:info "IGRP for OSI networks";
        presence "IGRP for OSI networks";
        tailf:cli-sequence-commands;
        choice area-tag-route-map-choice {
          container area-tag-route-map-container {
            tailf:cli-drop-node-name;
            tailf:cli-flatten-container;
            tailf:cli-sequence-commands;
            leaf area-tag {
              tailf:cli-drop-node-name;
              tailf:cli-disallow-value "route-map";
              type string {
                tailf:info "WORD;;ISO routing area tag";
              }
            }
            leaf route-map {
              tailf:info "Route map reference";
              type string {
                tailf:info "WORD;;Pointer to route-map entries";
              }
            }
          }
          leaf route-map {
            tailf:info "Route map reference";
            type string {
              tailf:info "WORD;;Pointer to route-map entries";
            }
          }
        }
        container iso-igrp-container {
          tailf:cli-drop-node-name;
          tailf:cli-compact-syntax;
          uses ospf-iso-igrp-redistribute-grouping;
        }
      }


      container maximum-prefix {
        tailf:info "Maximum number of prefixes redistributed to protocol";
        tailf:cli-sequence-commands;
        tailf:cli-compact-syntax;
        leaf number {
          tailf:cli-drop-node-name;
          type uint32 {
            range "1 .. 4294967295";
            tailf:info "<1-4294967295>;;Maximum number of IP "
            +"prefixes redistributed";
          }
        }
        container threshold-warning-only-container {
          tailf:cli-compact-syntax;
          tailf:cli-drop-node-name;
          leaf threshold {
            tailf:cli-drop-node-name;
            type uint32 {
              range "1 .. 100";
              tailf:info "<1-100>;;Threshold value (%) at which "
              +"to generate a warning message";
            }
          }
          leaf warning-only {
            tailf:info "Only give warning message when limit is exceeded";
            tailf:cli-full-command;
            type empty;
          }
        }
      }
      container mobile {
        tailf:info "Mobile routes";
        presence "Mobile routes";
        uses ospf-redistribute-grouping;
      }
      container odr {
        tailf:info "On Demand stub Routes";
        presence "On Demand stub Routes";
        uses ospf-redistribute-grouping;
      }

      list ospf {
        tailf:info "Open Shortest Path First (OSPF)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key id;
        leaf id {
          tailf:cli-suppress-range;
          type uint32 {
            range "1 .. 65535";
            tailf:info "<1-65535>;;Process ID";
          }
        }
        container match {
          tailf:cli-compact-syntax;
          tailf:cli-flatten-container;
          tailf:info "Redistribution of OSPF routes";
          container internal {
            presence "Redistribute OSPF internal routes";
            tailf:info "Redistribute OSPF internal routes";
            tailf:cli-compact-syntax;
            tailf:cli-flatten-container;
            uses ospf-redistribute-match-grouping;
          }
          container external {
            tailf:info "Redistribute OSPF external routes";
            presence "Redistribute OSPF external routes";
            tailf:cli-compact-syntax;
            tailf:cli-flatten-container;
            leaf external-routes {
              tailf:cli-drop-node-name;
              type redist-ospf-external-type;
            }
            uses ospf-redistribute-match-grouping;
          }
          container nssa-external {
            tailf:info "Redistribute OSPF NSSA external routes";
            presence "Redistribute OSPF NSSA external routes";
            tailf:cli-compact-syntax;
            tailf:cli-flatten-container;
            leaf nssa-external-routes {
              tailf:cli-drop-node-name;
              type redist-ospf-external-type;
            }
            uses ospf-redistribute-match-grouping;
          }
        }
        uses ospf-redistribute-grouping;
        leaf vrf {
          tailf:info "VPN Routing/Forwarding Instance";
          tailf:cli-diff-dependency "/ios:ip/vrf";
          tailf:cli-diff-dependency "/ios:vrf/definition";
          type string {
            tailf:info "WORD;;VPN Routing/Forwarding Instance (VRF) name";
          }
        }
      }

      container rip {
        tailf:info "Routing Information Protocol (RIP)";
        presence "Routing Information Protocol (RIP)";
        uses ospf-redistribute-grouping;
      }
      container static {
        tailf:info "Static routes";
        presence "Static routes";
        uses ospf-redistribute-grouping;
      }
    }
  }

  // ospf-ospfv3-common-grouping
  grouping ospf-ospfv3-common-grouping {
    list area {
      tailf:info "OSPF area parameters";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      key id;
      leaf id {
        tailf:cli-suppress-range;
        type ospf-area-type;
      }

      container authentication {
        tailf:info "Enable authentication";
        presence true;
        leaf message-digest {
          tailf:info "Use message-digest authentication";
          type empty;
        }
      }
      leaf default-cost {
        tailf:info "Set the summary default-cost of a NSSA/stub area";
        tailf:cli-full-command;
        tailf:cli-no-value-on-delete;
        type uint32 {
          range "0 .. 16777215";
          tailf:info "<0-16777215;;Stub's advertised external route metric";
        }
      }
      list filter-list {
        tailf:info "Filter networks between OSPF areas";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key "in-out";
        leaf "prefix" {
          tailf:cli-prefix-key;
          mandatory true;
          tailf:info "Filter prefixes between OSPF areas";
          type string {
            tailf:info "WORD;;Name of an IP prefix-list";
          }
        }
        leaf in-out {
          type enumeration {
            enum in {
              tailf:info "Filter networks sent to this area";
            }
            enum out {
              tailf:info "Filter networks sent from this area";
            }
          }
        }
      }
      container nssa {
        tailf:info "Specify a NSSA area";
        presence "Specify a NSSA area";
        container default-information-originate {
          tailf:cli-flatten-container;
          tailf:info "Originate Type 7 default into NSSA area";
          presence "Originate Type 7 default into NSSA area";
          leaf metric {
            tailf:info "OSPF default metric";
            type int32 {
              range "0 .. 16777214";
              tailf:info "<0-16777214>;;OSPF metric";
            }
            tailf:cli-no-value-on-delete;
            tailf:cli-no-name-on-delete;
            tailf:cli-suppress-no;
          }
          leaf metric-type {
            tailf:info "OSPF metric type for default routes";
            type ospf-metric-type;
          }
        }
        leaf no-ext-capability {
          tailf:info "Do not send domain specific capabilities into NSSA";
          type empty;
        }
        leaf no-redistribution {
          tailf:info "No redistribution into this NSSA area";
          type empty;
        }
        leaf no-summary {
          tailf:info "Do not send summary LSA into NSSA";
          type empty;
        }
        container translate {
          tailf:info "Translate LSA";
          container type7 {
            tailf:info "From Type 7 to Type 5";
            leaf suppress-fa {
              tailf:info "Suppress forwarding address in translated LSAs";
              type empty;
            }
          }
        }
      }
      list "range" {
        tailf:info "Summarize routes matching address/mask "
        +"(border routers only)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "ip mask";
        leaf ip {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP address to match";
          }
        }
        leaf mask {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP mask for address";
          }
        }
        choice advertise-choice {
          leaf advertise {
            tailf:info "Advertise this range (default)";
            type empty;
          }
          leaf not-advertise {
            tailf:info "DoNotAdvertise this range";
            type empty;
          }
        }
        leaf cost {
          tailf:info "User specified metric for this range";
          tailf:cli-full-command;
          type uint32 {
            range "0 .. 16777215";
            tailf:info "<0-16777215>;;Advertised metric for this range";
          }
        }
      }
      list sham-link {
        tailf:info "Define a sham link and its parameters";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "source dest";
        leaf source {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP addr associated with sham-link source";
          }
        }
        leaf dest {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP addr associated with "
            +"sham-link destination";
          }
        }
        leaf cost {
          tailf:info "Associate a cost with the sham-link";
          type uint16 {
            range "0 .. 65535";
            tailf:info "<1-65535>;;Cost of the sham-link";
          }
        }
      }
      container stub {
        tailf:info "Specify a stub area";
        presence "Specify a stub area";
        leaf no-ext-capability {
          tailf:info "Do not send domain specific capabilities "
          +"into stub area";
          type empty;
        }
        leaf no-summary {
          tailf:info "Do not send summary LSA into stub area";
          tailf:cli-full-command;
          type empty;
        }
      }
      list virtual-link {
        //FIXME COMPILER ERROR:
        //must "not(../nssa)" {
        //error-message "The area is configured as NSSA area already";
        //}
        //FIXME COMPILER ERROR:
        //must "not(../stub)" {
        //error-message "The area is configured as stub area already";
        //}
        tailf:info "Define a virtual link and its parameters";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key id;
        leaf id {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;ID (IP addr) associated with "
            +"virtual link neighbor";
          }
        }
        leaf authentication {
          tailf:info "Set authentication type";
          type empty;
        }
        container authentication-key {
          tailf:info "Set authentication key";
          leaf auth-type {
            tailf:cli-drop-node-name;
            type uint8 {
              range "0 .. 7";
              tailf:info "<0-7>;;Encryption type (0 for not yet encrypted, "
              +"7 for proprietary)";
            }
          }
          leaf auth-key {
            tailf:cli-drop-node-name;
            tailf:cli-full-command;
            type string {
              length "1 .. 8";
              tailf:info "WORD;;Authentication key (8 chars)";
            }
          }
        }
        leaf dead-interval {
          tailf:info "Dead router detection time";
          tailf:cli-no-value-on-delete;
          type uint16 {
            range "1 .. 8192";
            tailf:info "<1-8192;;Seconds>";
          }
        }
        leaf hello-interval {
          tailf:info "Hello packet interval";
          tailf:cli-no-value-on-delete;
          type int32 {
            range "1 .. 8192";
            tailf:info "<1-8192;;Seconds>";
          }
        }

        list message-digest-key {
          tailf:info "Set message digest key";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          key id;
          leaf id {
            tailf:cli-suppress-range;
            type uint8 {
              range "1 .. 255";
              tailf:info "<1-255>;;Key ID";
            }
          }
          container md5 {
            tailf:info "Use MD5 algorithm";
            tailf:cli-sequence-commands;
            leaf auth-type {
              tailf:cli-drop-node-name;
              tailf:cli-optional-in-sequence;
              type uint8 {
                range "0 .. 7";
                tailf:info "<0-7>;;Encryption type (0 for not "
                +"yet encrypted, 7 for proprietary)";
              }
            }
            leaf auth-key {
              tailf:cli-drop-node-name;
              type string {
                length "1 .. 16";
                tailf:info "WORD;;Authentication key (16 chars)";
              }
            }
          }
        }
        leaf retransmit-interval {
          tailf:info "LSA retransmit interval";
          type uint16 {
            range "1 .. 8192";
            tailf:info "<1-8192>;;Seconds";
          }
          tailf:cli-no-value-on-delete;
        }
        leaf transmit-delay {
          tailf:info "LSA transmission delay";
          type uint16 {
            range "1 .. 8192";
            tailf:info "<1-8192>;;Seconds";
          }
          tailf:cli-no-value-on-delete;
        }
      }
    }
    container auto-cost {
      tailf:info "Calculate OSPF interface cost according to bandwidth";
      presence "Calculate OSPF interface cost according to bandwidth";
      leaf reference-bandwidth {
        tailf:info "Use reference bandwidth method to assign OSPF cost";
        type uint32 {
          tailf:info "<1-4294967>;;The reference bandwidth in terms "
          +"of Mbits per second";
          range "1 .. 4294967";
        }
      }
    }
    container bfd {
      tailf:info "BFD configuration commands";
      leaf all-interfaces {
        tailf:info "Enable BFD on all interfaces";
        type empty;
      }
    }
    container interface-id {
      tailf:info "Source of the interface ID";
      leaf snmp-if-index {
        tailf:info "SNMP MIB ifIndex";
        type empty;
      }
    }
    container log-adjacency-changes {
      tailf:info "Log changes in adjacency state";
      presence true;
      leaf detail {
        tailf:info "Log all state changes";
        type empty;
      }
    }
    container max-lsa {
      tailf:info "maximum number of LSAs OSPF process will receive";
      tailf:cli-sequence-commands;
      leaf number {
        tailf:cli-drop-node-name;
        type uint32 {
          range "1 .. 4294967294";
          tailf:info "<1-4294967294>;;Maximum number of non self-generated "
          +"LSAs this process can receive";
        }
      }
      container options {
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        leaf threshold-value {
          tailf:cli-drop-node-name;
          type uint32 {
            range "1 .. 100";
            tailf:info "<1-100>;;Threshold value (%) at which "
            +"to generate a warning msg";
          }
        }
        leaf ignore-count {
          tailf:info "maximum number of times adjacencies "
          +"can be suppressed";
          type uint32 {
            range "1 .. 65534";
            tailf:info "<1-65534>;;count on how many times "
            +"adjacencies can be suppressed";
          }
        }
        leaf ignore-time {
          tailf:info "time during which all adjacencies are suppressed";
          type uint32 {
            range "1 .. 17895";
            tailf:info "<1-17895>;;number of minutes during which "
            +"all adjacencies are suppressed";
          }
        }
        leaf reset-time {
          tailf:info "time after which ignore-count is reset to zero";
          type uint32 {
            range "2 .. 35791";
            tailf:info "<2-35791>;;number of minutes after which "
            +"ignore-count is reset to zero";
          }
        }
        leaf warning-only {
          tailf:info "Only give warning message when limit is exceeded";
          tailf:cli-full-command;
          type empty;
        }
      }
    }
    uses passive-interface-grouping;
    container queue-depth {
      tailf:info "OSPF Hello/Router process queue depth";
      container hello {
        tailf:info "OSPF Hello process queue depth";
        uses queue-depth-grouping;
      }
      container update {
        tailf:info "OSPF Router process queue depth";
        uses queue-depth-grouping;
      }
    }
    container timers {
      tailf:info "Adjust routing timers";
      container lsa {
        tailf:info "OSPF LSA timers";
        leaf arrival {
          tailf:info "OSPF LSA arrival timer";
          type uint32 {
            range "0 .. 600000";
            tailf:info "<0-600000>;;The minimum interval in milliseconds "
            +"between accepting the same LSA";
          }
        }
      }
      container pacing {
        tailf:info "OSPF pacing timers";
        leaf flood {
          tailf:info "OSPF flood pacing timer";
          tailf:cli-full-command;
          type uint32 {
            range "5 .. 100";
            tailf:info "<5-100>;;The minimum interval in msec "
            +"to pace limit flooding on interface";
          }
        }
        leaf lsa-group {
          tailf:info "OSPF LSA group pacing timer";
          tailf:cli-full-command;
          type uint32 {
            range "10 .. 1800";
            tailf:info "<10-1800>;;Interval in sec between group "
            +"of LSA being refreshed or maxaged";
          }
        }
        leaf retransmission {
          tailf:info "OSPF retransmission pacing timer";
          tailf:cli-full-command;
          type uint32 {
            range "5 .. 200";
            tailf:info "<5-200>;;The minimum interval in msec "
            +"between neighbor retransmissions";
          }
        }
      }
      container throttle {
        tailf:info "OSPF throttle timers";
        container lsa {
          tailf:info "OSPF LSA throttle timers";
          container all {
            tailf:info "For all type of OSPF LSAs";
            tailf:cli-sequence-commands;
            tailf:cli-compact-syntax;
            leaf delay {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint32 {
                range "0 .. 600000";
                tailf:info "<0-600000>;;Delay to generate first occurrence "
                +"of LSA in milliseconds";
              }
            }
            leaf min-delay {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint32 {
                range "0 .. 600000";
                tailf:info "<0-600000>;;Minimum delay between originating "
                +"the same LSA in milliseconds";
              }
            }
            leaf max-delay {
              tailf:cli-drop-node-name;
              type uint32 {
                range "0 .. 600000";
                tailf:info "<0-600000>;;Maximum delay between originating "
                +"the same LSA in milliseconds";
              }
            }
          }
        }
        container spf {
          tailf:info "OSPF SPF throttle timers";
          tailf:cli-sequence-commands;
          tailf:cli-compact-syntax;
          leaf delay {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint32 {
              range "0 .. 600000";
              tailf:info "<0-600000>;;Delay between receiving a change "
              +"to SPF calculation in milliseconds";
            }
          }
          leaf min-delay {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint32 {
              range "0 .. 600000";
              tailf:info "<0-600000>;;Delay between first and second "
              +"SPF calculation in milliseconds";
            }
          }
          leaf max-delay {
            tailf:cli-drop-node-name;
            type uint32 {
              range "0 .. 600000";
              tailf:info "<0-600000>;;Maximum wait time in milliseconds "
              +"for SPF calculations";
            }
          }
        }
      }
    }

    leaf router-id {
      tailf:cli-full-command;
      tailf:info "Override configured router identifier (peers will "
      +"reset)";
      type inet:ipv4-address {
        tailf:info "A.B.C.D;;Manually configured router identifier";
      }
    }

  }

  // ospfv3-address-family-grouping
  grouping ospfv3-address-family-grouping {
    // distribute-list
  }

  // queue-depth-grouping
  grouping queue-depth-grouping {
    leaf options {
      tailf:cli-drop-node-name;
      tailf:cli-full-command;
      tailf:cli-trim-default;
      type union {
        type uint32 {
          range "1 .. 2147483647";
          tailf:info "<1-2147483647>;;maximum numer of packets in the queue";
        }
        type enumeration {
          enum "unlimited" {
            tailf:info "Unlimited queue depth";
          }
        }
      }
      default "unlimited";
    }
  }

  // ospf-redistribute-match-grouping
  grouping ospf-redistribute-match-grouping {
    leaf metric {
      tailf:info "Metric for redistributed routes";
      type uint32 {
        tailf:info "<0-16777214>;;OSPF default metric";
      }
    }
    leaf subnets {
      tailf:info "Consider subnets for redistribution into OSPF";
      type empty;
    }
    leaf route-map {
      tailf:info "Route map reference";
      type string {
        tailf:info "WORD;;Pointer to route-map entries";
      }
    }
    leaf tag {
      tailf:info "Set tag for routes redistributed into OSPF";
      type uint32 {
        range "0 .. 4294967295";
        tailf:info "<0-4294967295>;;32-bit tag value";
      }
    }
  }

  // ospf-iso-igrp-redistribute-grouping
  grouping ospf-iso-igrp-redistribute-grouping {
    leaf metric {
      tailf:info "Metric for redistributed routes";
      type uint32 {
        tailf:info "<0-16777214>;;OSPF default metric";
      }
    }
    leaf metric-type {
      tailf:info "OSPF/IS-IS exterior metric type "
      +"for redistributed routes";
      type enumeration {
        enum "1" {
          tailf:info "Set OSPF External Type 1 metrics";
        }
        enum "2" {
          tailf:info "Set OSPF External Type 2 metrics";
        }
      }
    }
    leaf tag {
      tailf:info "Set tag for routes redistributed into OSPF";
      type uint32 {
        range "0 .. 4294967295";
        tailf:info "<0-4294967295>;;32-bit tag value";
      }
    }
    leaf subnets {
      tailf:info "Consider subnets for redistribution into OSPF";
      type empty;
    }
  }

  // ospf-redistribute-grouping
  grouping ospf-redistribute-grouping {
    container redist-options {
      tailf:cli-drop-node-name;
      tailf:cli-compact-syntax;
      uses ospf-iso-igrp-redistribute-grouping;
      leaf route-map {
        tailf:info "Route map reference";
        type string {
          tailf:info "WORD;;Pointer to route-map entries";
        }
      }
    }
  }

  // ospf-redistribute-bgp-grouping
  grouping ospf-redistribute-bgp-grouping {
    leaf as-number {
      tailf:cli-drop-node-name;
      type uint32 {
        range "1 .. 65535";
        tailf:info "<1-65535>;;Autonomous system number";
      }
    }
    uses ospf-redistribute-grouping;
  }

  // router-rip-grouping
  grouping router-rip-grouping {
    uses address-family-vrf-grouping;
    leaf flash-update-threshold {
      tailf:info "Specify flash update threshold in second";
      tailf:cli-full-command;
      type uint8 {
        range "0 .. 30";
        tailf:info "<0-30>;;threshold in seconds";
      }
    }
    leaf input-queue {
      tailf:info "Specify input queue depth";
      tailf:cli-full-command;
      type uint16 {
        range "0 .. 1024";
        tailf:info "0-1024;;queue depth";
      }
    }
    leaf output-delay {
      tailf:info "Interpacket delay for RIP updates";
      tailf:cli-full-command;
      type uint8 {
        range "8 .. 50";
        tailf:info "8-50;;Delay in milliseconds";
      }
    }
    uses passive-interface-grouping;
    container traffic-share {
      tailf:info "How to compute traffic share over alternate paths";
      container min {
        tailf:info "All traffic shared among min metric paths";
        leaf across-interfaces {
          tailf:info "Use different interfaces for equal-cost paths";
          type empty;
        }
      }
    }
  }

  grouping default-redistribute-grouping {
    container connected {
      presence "Connected";
      tailf:info "Connected";
      uses rip-metric-route-map-grouping;
    }
    list bgp {
      tailf:info "Border Gateway Protocol (BGP)";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key as-number;
      leaf as-number {
        type uint16 {
          range "1 .. 65535";
          tailf:info "<1-65535>;;Autonomous system number";
        }
      }
      uses rip-metric-route-map-grouping;
    }
    list eigrp {
      tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key as-number;
      leaf as-number {
        type uint16 {
          range "1 .. 65535";
          tailf:info "<1-65535>;;Autonomous system number";
        }
      }
      uses rip-metric-route-map-grouping;
    }
    container isis {
      presence "ISO IS-IS";
      tailf:info "ISO IS-IS";
      list isis-area {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-drop-node-name;
        key name;
        leaf name {
          tailf:cli-disallow-value "level-1|level-2|level-1-2|metric|route-map";
          type string {
            tailf:info "WORD;;ISO routing area tag";
          }
        }
        uses redist-isis-grouping;
      }
      uses redist-isis-grouping;
    }
    container iso-igrp {
      presence "IGRP for OSI networks";
      tailf:info "IGRP for OSI networks";
      list isoigrp-list {
        tailf:info "Border Gateway Protocol (BGP)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-drop-node-name;
        key iso-area-tag;
        leaf iso-area-tag {
          tailf:cli-disallow-value "route-map";
          type string {
            tailf:info "WORD;;ISO routing area tag";
          }
        }
        uses rip-iso-igrp-metric-route-map-grouping;
      }
      uses rip-iso-igrp-metric-route-map-grouping;
    }
    container mobile {
      presence "Mobile routes";
      tailf:info "Mobile routes";
      uses rip-metric-route-map-grouping;
    }
    container odr {
      presence "On Demand stub Routes";
      tailf:info "On Demand stub Routes";
      uses rip-metric-route-map-grouping;
    }
    list ospf {
      tailf:info "Open Shortest Path First (OSPF)";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key process-id;
      leaf process-id {
        tailf:cli-suppress-range;
        type uint16 {
          range "1 .. 65535";
          tailf:info "<1-65535>;;Process ID";
        }
      }
      list vrf {
        tailf:info "VPN Routing/Forwarding Instance";
        tailf:cli-diff-dependency "/ios:ip/vrf";
        tailf:cli-diff-dependency "/ios:vrf/definition";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;VPN Routing/Forwarding Instance (VRF) name";
          }
        }
      }
      //FIXME: the doc is not clear
      container match {
        tailf:cli-compact-syntax;
        tailf:cli-flatten-container;
        tailf:info "Redistribution of OSPF routes";
        container internal {
          presence "Redistribute OSPF internal routes";
          tailf:info "Redistribute OSPF internal routes";
          tailf:cli-compact-syntax;
          tailf:cli-flatten-container;
          uses rip-metric-route-map-grouping;
        }
        container external {
          tailf:info "Redistribute OSPF external routes";
          presence "Redistribute OSPF external routes";
          tailf:cli-compact-syntax;
          tailf:cli-flatten-container;
          leaf external-routes {
            tailf:cli-drop-node-name;
            type redist-ospf-external-type;
          }
          uses rip-metric-route-map-grouping;
        }
        container nssa-external {
          tailf:info "Redistribute OSPF NSSA external routes";
          presence "Redistribute OSPF NSSA external routes";
          tailf:cli-compact-syntax;
          tailf:cli-flatten-container;
          leaf nssa-external-routes {
            tailf:cli-drop-node-name;
            type redist-ospf-external-type;
          }
          uses rip-metric-route-map-grouping;
        }
      }
      uses rip-metric-route-map-grouping;
    }
    container static {
      presence "Static routes";
      tailf:info "Static routes";
      uses rip-metric-route-map-grouping;
    }
    container rip {
      presence "Routing Information Protocol (RIP)";
      tailf:info "Routing Information Protocol (RIP)";
      uses rip-metric-route-map-grouping;
    }
  }

  grouping distance-grouping {
    container distance {
      tailf:cli-compact-syntax;
      tailf:info "Define an administrative distance";
      leaf distance-leaf {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        type uint8 {
          range "1..255";
          tailf:info "1-255;;Administrative distance";
        }
      }
      list distance-list {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-drop-node-name;
        key "number ip mask";
        leaf number {
          tailf:cli-suppress-range;
          type uint8 {
            range "1 .. 255";
            tailf:info "1-255;;Administrative distance";
          }
        }
        leaf ip {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP source address";
          }
        }
        leaf mask {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Wildcard bits";
          }
        }
      }
    }
  }

  grouping offset-list-grouping {
    list offset-list {
      tailf:info "Add or subtract offset from RIP metrics";
      tailf:cli-compact-syntax;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-suppress-list-no;
      tailf:cli-sequence-commands;
      key in-out;
      leaf in-out {
        tailf:cli-incomplete-command;
        type offset-list-in-out-type;
      }
      leaf offset {
        tailf:cli-drop-node-name;
        mandatory true;
        type uint8 {
          range "0 .. 16";
          tailf:info "<0-16>;;Offset";
        }
      }
    }
  }

  grouping default-router-rip-grouping {
    leaf auto-summary {
      tailf:info "Enable automatic network number summarization";
      type empty;
    }
    leaf maximum-paths {
      tailf:cli-full-command;
      tailf:info "Forward packets over multiple paths";
      type uint8 {
        range "1 .. 32";
        tailf:info "1-32;;Number of paths";
      }
    }
    list neighbor {
      tailf:info "Specify a neighbor router";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key ip;
      leaf ip {
        type inet:ipv4-address;
        tailf:info "A.B.C.D;;Neighbor address";
      }
    }
    list network {
      tailf:info "Enable routing on an IP network";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key ip;
      leaf ip {
        type inet:ipv4-address;
        tailf:info "A.B.C.D;;Network number";
      }
    }
    leaf validate-update-source {
      tailf:info "Perform sanity checks against source address of "
        +"routing updates";
      tailf:cli-full-command;
      tailf:cli-boolean-no;
      tailf:cli-trim-default;
      type boolean;
      default true;
    }
  }

  grouping address-family-vrf-grouping {
    uses default-router-rip-grouping;
    container default-information {
      tailf:cli-incomplete-no;
      tailf:info "Control distribution of default information";
      container originate {
        tailf:cli-full-no;
        presence "Distribute a default route";
        tailf:info "Distribute a default route";
        leaf route-map {
          tailf:info "Route-map reference";
          tailf:cli-no-value-on-delete;
          type string {
            tailf:info "WORD;;Route map name";
          }
        }
      }
    }
    leaf default-metric {
      tailf:info "Set metric of redistributed routes";
      tailf:cli-full-command;
      type uint32 {
        range "1..4294967295";
        tailf:info "<1-4294967295>;;Default metric";
      }
    }
    uses distance-grouping;
    uses distribute-list-grouping;
    uses offset-list-grouping;
    container redistribute {
      tailf:info "Redistribute information from another routing protocol";
      uses rip-metric-route-map-grouping;
      uses default-redistribute-grouping;
    }
    container timers {
      tailf:info "Adjust routing timers";
      tailf:cli-incomplete-no;
      tailf:cli-compact-syntax;
      container basic {
        tailf:info "Basic routing protocol update timers";
        tailf:cli-sequence-commands;
        tailf:cli-full-no;
        leaf updates {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          tailf:cli-no-value-on-delete;
          type uint32 {
            range "1 .. 4294967295";
            tailf:info "1-4294967295;;Interval between updates for RIP";
          }
        }
        leaf invalid {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          tailf:cli-no-value-on-delete;
          type uint32 {
            range "1 .. 4294967295";
            tailf:info "1-4294967295;;Invalid";
          }
        }
        leaf holddown {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          tailf:cli-no-value-on-delete;
          type uint32 {
            range "1 .. 4294967295";
            tailf:info "1-4294967295;;Holddown";
          }
        }
        leaf flush {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          tailf:cli-no-value-on-delete;
          type uint32 {
            range "1 .. 4294967295";
            tailf:info "1-4294967295;;Flush";
          }
        }
        leaf sleep {
          tailf:cli-drop-node-name;
          tailf:cli-no-value-on-delete;
          type uint32 {
            range "1 .. 4294967295";
            tailf:info "1-4294967295;;Sleep time, in milliseconds";
          }
        }
      }
    }
    leaf version {
      tailf:info "Set routing protocol version";
      type uint8 {
        range "1 .. 2";
        tailf:info "1-2;;rip version 1 or 2";
      }
    }
  }

  grouping redist-isis-grouping {
    container rip-isis-redist {
      tailf:cli-drop-node-name;
      leaf isis-level-routes {
        tailf:cli-drop-node-name;
        type enumeration {
          enum level-1 {
            tailf:info "IS-IS level-1 routes only";
          }
          enum level-2 {
            tailf:info "IS-IS level-2 routes only";
          }
          enum level-1-2 {
            tailf:info "IS-IS level-1 and level-2 routes";
          }
        }
      }
      uses rip-metric-route-map-grouping;
    }
  }

  grouping rip-metric-route-map-grouping {
    container rip-metric-route-map {
      tailf:cli-drop-node-name;
      tailf:cli-compact-syntax;
      container metric {
        tailf:cli-compact-syntax;
        tailf:cli-flatten-container;
        tailf:info "Metric for redistributed routes";
        choice metric-transparent-choice {
          leaf metric-value {
            tailf:cli-drop-node-name;
            tailf:info "Metric for redistributed routes";
            type uint32 {
              range "0 .. 16";
              tailf:info "<0-16>;;Default metric";
            }
          }
          leaf transparent {
            tailf:info "Transparently redistribute metric";
            type empty;
          }
        }
      }
      leaf route-map {
        tailf:info "Route map reference";
        type string {
          tailf:info "WORD;;Pointer to route-map entries";
        }
      }
    }
  }

  grouping rip-iso-igrp-metric-route-map-grouping {
    container rip-metric-route-map {
      tailf:cli-drop-node-name;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf route-map {
        tailf:info "Route map reference";
        type string {
          tailf:info "WORD;;Pointer to route-map entries";
        }
      }
      container metric {
        tailf:cli-compact-syntax;
        tailf:info "Metric for redistributed routes";
        choice metric-transparent-choice {
          leaf metric-value {
            tailf:cli-drop-node-name;
            tailf:info "Metric for redistributed routes";
            type uint32 {
              range "0 .. 16";
              tailf:info "<0-16>;;Default metric";
            }
          }
          leaf transparent {
            tailf:info "Transparently redistribute metric";
            type empty;
          }
        }
      }
    }
  }

  // router/isis grouping
  grouping narrow-wide-transition-grouping {
    leaf narrow-wide {
      tailf:cli-drop-node-name;
      tailf:cli-full-command;
      type isis-level-type;
    }
    leaf transition {
      tailf:info "Accept both styles of TLVs during transition";
      type isis-level-type;
      tailf:cli-full-command;
    }
  }

  // router/isis grouping
  grouping spf-intervals-grouping {
    leaf interval {
      tailf:cli-drop-node-name;
      type uint32 {
        range "1 .. 120";
        tailf:info "<1-120>;;Interval between consecutive SPFs in seconds";
      }
    }
    leaf initial-wait {
      tailf:cli-drop-node-name;
      type uint32 {
        range "1 .. 120000";
        tailf:info "<1-120000>;;Initial wait before first SPF in milliseconds";
      }
    }
    leaf minimum-wait {
      tailf:cli-drop-node-name;
      type uint32 {
        range "1 .. 120000";
        tailf:info "<1-120000>;;Minimum wait between first and "
        +"second SPF in milliseconds";
      }
    }
  }

  // router/isis grouping
  grouping authenticate-snp-grouping {
    leaf authenticate {
      tailf:info "Authentication";
      tailf:cli-incomplete-command;
      type empty;
    }
    leaf snp {
      tailf:info "SNP PDUs";
      type enumeration {
        enum send-only {
          tailf:info "Send but do not check PDUs on receiving";
        }
        enum validate {
        tailf:info "Send and check PDUs on receiving";
        }
      }
    }
  }

  // router/isis grouping
  grouping lsp-gen-interval-grouping {
    leaf interval {
      tailf:cli-drop-node-name;
      type uint32 {
        range "1 .. 120";
        tailf:info "<1-120>;;Interval in seconds";
      }
    }
    leaf initial-wait {
      tailf:cli-drop-node-name;
      type uint32 {
        range "1 .. 120000";
        tailf:info "<1-120000>;;Initial wait in milliseconds";
      }
    }
    leaf wait {
      tailf:cli-drop-node-name;
      type uint32 {
        range "1 .. 120000";
        tailf:info "<1-120000>;;Wait between first and second "
        +"lsp generation in milliseconds";
      }
    }
  }

  // router/isis grouping
  grouping set-overload-bit-suppress-grouping {
    leaf external {
      tailf:info "If overload-bit set, don't advertise "
      +"IP prefixes learned from other protocols";
      tailf:cli-break-sequence-commands;
      type empty;
    }
    leaf interlevel {
      tailf:info "If overload-bit set, don't advertise "
      +"IP prefixes learned from another ISIS level";
      type empty;
    }
  }

  // router/isis grouping
  grouping summary-address-metric-tag-grouping {
    leaf metric {
      tailf:info "Set metric for summay route";
      tailf:cli-full-command;
      type uint32 {
        range "1 .. 4294967295";
        tailf:info "<1-4294967295>;;metric";
      }
    }
    leaf tag {
      tailf:info "Set tag";
      type uint32 {
        range "1 .. 4294967295";
        tailf:info "<1-4294967295>;;32-bit tag value";
      }
    }
  }

  // router/isis grouping
  grouping authentication-level-grouping {
    leaf levels {
      tailf:cli-drop-node-name;
      type authentication-level-type;
    }
  }

  // router/isis grouping
  grouping redist-level-grouping {
    leaf levels {
      tailf:cli-drop-node-name;
      tailf:cli-break-sequence-commands;
      type isis-routes-level-type;
    }
  }

  // router/isis grouping
  grouping isis-redist-container-content-grouping {
    uses redist-level-grouping;
    leaf metric {
      tailf:info "ISIS default metric";
      type uint32 {
        range "0 .. 4294967295";
        tailf:info "<0-4294967295>;;ISIS default metric";
      }
    }
    leaf metric-type {
      tailf:info "OSPF/IS-IS exterior metric type for redistributed routes";
      type enumeration {
        enum external {
        tailf:info "Set IS-IS External metric type";
        }
        enum internal {
        tailf:info "Set IS-IS Internal metric type";
        }
      }
    }
    leaf route-map {
      tailf:info "Route map reference";
      type string {
        tailf:info "WORD;;Pointer to route-map entries";
      }
    }
  }

  // router/isis grouping
  grouping isis-redist-grouping {
    container isis-redist-container {
      tailf:cli-drop-node-name;
      uses isis-redist-container-content-grouping;
    }
  }

  // router/isis grouping
  grouping isis-redist-af-grouping {
    container isis-redist-af-container {
      tailf:cli-drop-node-name;
      leaf include-connected {
        tailf:info "Include connected";
        type empty;
      }
      uses isis-redist-container-content-grouping;
    }
  }

  // router/isis grouping
  grouping isis-redist-ospf-match-grouping {
    uses redist-level-grouping;
    leaf metric {
      tailf:info "ISIS default metric";
      type uint32 {
        range "0 .. 4294967295";
        tailf:info "<0-4294967295>;;ISIS default metric";
      }
    }
    leaf route-map {
      tailf:info "Route map reference";
      type string {
        tailf:info "WORD;;Pointer to route-map entries";
      }
    }
  }

  // router/isis grouping
  grouping isis-redist-clns-ip-grouping {
    uses isis-redist-grouping;
    container clns {
      tailf:info "Redistribution of BGP NSAP routes";
      presence "Redistribution of BGP NSAP routes";
      leaf route-map {
        tailf:info "Route map reference";
        type string {
          tailf:info "WORD;;Pointer to route-map entries";
        }
      }
    }
    leaf ip {
      tailf:info "Redistribution of BGP IP routes";
      type empty;
    }
  }

  // router/isis grouping
  grouping isis-address-family-grouping {
    leaf adjacency-check {
      tailf:info "Check ISIS neighbor protocol support";
      type empty;
      tailf:cli-full-command;
    }
    container default-information {
      tailf:cli-incomplete-no;
      tailf:info "Control distribution of default information";
      container originate {
        tailf:cli-full-no;
        presence "Distribute a default route";
        tailf:info "Distribute a default route";
        leaf route-map {
          tailf:info "Route-map reference";
          tailf:cli-no-value-on-delete;
          type string {
            tailf:info "WORD;;Route map name";
          }
        }
      }
    }
    leaf maximum-paths {
      tailf:info "Forward packets over multiple paths";
      tailf:cli-full-command;
      type uint32 {
        range "1 .. 32";
        tailf:info "<1-32>;;Number of paths";
      }
    }
    container metric {
      tailf:info "Set ISIS metric for all interfaces";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf default {
        tailf:cli-drop-node-name;
        type uint32 {
          range "1 .. 63";
          tailf:info "<1-63>;;Default metric";
        }
      }
      leaf level-1-2 {
        tailf:cli-drop-node-name;
        type enumeration {
          enum level-1 {
            tailf:info "Apply metric to level-1 links";
          }
          enum level-2 {
            tailf:info "Apply metric to level-2 links";
          }
        }
      }
    }
    container prc-interval {
      tailf:info "Minimum interval between partial route calculations";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf interval {
        tailf:cli-drop-node-name;
        type uint32 {
          range "1 .. 120";
          tailf:info "<1-120>;;PRC interval in seconds";
        }
      }
      leaf initial-wait {
        tailf:cli-drop-node-name;
        type uint32 {
          range "1 .. 120000";
          tailf:info "<1-120000>;;Initial wait for PRC in milliseconds";
        }
      }
      leaf minimum-wait {
        tailf:cli-drop-node-name;
        type uint32 {
          range "1 .. 120000";
          tailf:info "<1-120000>;;Minimum wait between first and "
          +"second PRC in milliseconds";
        }
      }
    }

    container set-overload-bit {
      tailf:info "Signal other routers not to use us in SPF";
      choice set-overload-bit-choice {
        container on-startup {
          tailf:info "Set overload-bit only temporarily after reboot";
          choice on-startup-choice {
            container time {
              tailf:cli-drop-node-name;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              leaf time {
                tailf:cli-drop-node-name;
                type uint32 {
                  range "5 .. 86400";
                  tailf:info "<5-86400>;;Time in seconds to advertise "
                  +"ourself as overloaded after reboot";
                }
              }
              leaf suppress {
                tailf:info "If overload-bit set, suppress the following "
                +"types of IP prefixes";
                tailf:cli-incomplete-command;
                type empty;
              }
              uses set-overload-bit-suppress-grouping;
            }
            container wait-for-bgp {
              tailf:info "Let BGP decide when to unset the overload bit";
              presence "Let BGP decide when to unset the overload bitW";
              container suppress {
                tailf:info "If overload-bit set, suppress the following "
                +"types of IP prefixes";
                tailf:cli-compact-syntax;
                uses set-overload-bit-suppress-grouping;
              }
            }
          }
        }
        container suppress {
          tailf:info "If overload-bit set, suppress the following "
          +"types of IP prefixes";
          tailf:cli-compact-syntax;
          uses set-overload-bit-suppress-grouping;
        }
      }
    }

    container spf-interval {
      tailf:info "Minimum interval between SPF calculations";
      tailf:cli-compact-syntax;
      choice spf-interval-choice {
        list level-1-2 {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-incomplete-command;
          key level;
          leaf level {
            type enumeration {
              enum level-1 {
                tailf:info "Set interval for level 1 only";
              }
              enum level-2 {
                tailf:info "Set interval for level 2 only";
              }
            }
          }
          uses spf-intervals-grouping;
        }
        container intervals {
          tailf:cli-drop-node-name;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          uses spf-intervals-grouping;
        }
      }
    }
    container traffic-share {
      tailf:info "How to compute traffic share over alternate paths";
      container min {
        tailf:info "All traffic shared among min metric paths";
        leaf across-interface {
          tailf:info "Use different interfaces for equal-cost paths";
          type empty;
        }
      }
    }
  }

  // router/isis grouping
  grouping isis-main-grouping {
    container isis-main-container {
      tailf:cli-full-command;
      tailf:cli-drop-node-name;

      uses isis-address-family-grouping;
      container address-family {
        tailf:info "Enter Address Family command mode";
        container ipv6 {
          tailf:info "Address family";
          container unicast {
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-router-af";
            tailf:info "Address Family Modifier";
            tailf:cli-full-command;
            tailf:cli-exit-command "exit-address-family" {
              tailf:info "Exit from Address Family configuration "
              +"mode";
            }
            uses isis-address-family-grouping;
            leaf distance {
              tailf:info "Administrative distance";
              tailf:cli-full-command;
              type uint32 {
                range "1 .. 255";
                tailf:info "<1-255>;;OSPF Administrative distance";
              }
            }
            container multi-topology {
              tailf:info "Enable multi-topology mode";
              presence "Enable multi-topology mode";
              leaf transition {
                tailf:info "Accept and generate both IS-IS "
                +"IPv6 and Multi-topology IPv6 TLVs";
                type empty;
              }
            }

            container redistribute {
              tailf:info "Redistribute IPv6 prefixes from another "
              +"routing protocol";
              container bgp {
                tailf:info "Border Gateway Protocol (BGP)";
                tailf:cli-sequence-commands;
                tailf:cli-compact-syntax;
                leaf as-number {
                  tailf:cli-drop-node-name;
                  type uint32 {
                    range "1 .. 65535";
                    tailf:info "<1-65535>;;Autonomous system number";
                  }
                }
                uses isis-redist-af-grouping;
              }
              container connected {
                tailf:info "Connected";
                presence "Connected";
                uses isis-redist-grouping;
              }
              list eigrp {
                tailf:info "Enhanced Interior Gateway Routing "
                +"Protocol (EIGRP)";
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                key as-number;
                leaf as-number {
                  tailf:cli-drop-node-name;
                  type uint32 {
                    range "1 .. 65535";
                    tailf:info "<1-65535>;;Autonomous system number";
                  }
                }
                uses isis-redist-af-grouping;
              }

              container isis {
                tailf:info "ISO IS-IS";
                tailf:cli-compact-syntax;
                leaf area-tag {
                  tailf:cli-drop-node-name;
                  tailf:cli-disallow-value "level-1|level-2";
                  type string {
                    tailf:info "WORD;;IPv6 process name";
                  }
                }
                container levels {
                  tailf:cli-drop-node-name;
                  tailf:cli-sequence-commands;
                  leaf isis-redist-levels1 {
                    tailf:cli-drop-node-name;
                    tailf:cli-incomplete-command;
                    type enumeration {
                      enum level-1 {
                        tailf:info "Inter-area routes from level-1";
                      }
                      enum level-2 {
                        tailf:info "Inter-area routes from level-2";
                      }
                    }
                  }
                  leaf into {
                    tailf:info "from level-n into level-m";
                    tailf:cli-incomplete-command;
                    type empty;
                  }
                  leaf isis-redist-levels2 {
                    tailf:cli-drop-node-name;
                    tailf:cli-incomplete-command;
                    type enumeration {
                      enum level-1 {
                        tailf:info "Inter-area routes from level-1";
                      }
                      enum level-2 {
                        tailf:info "Inter-area routes from level-2";
                      }
                    }
                  }
                  leaf distribute-list {
                    tailf:info "select routes";
                    type string {
                      tailf:info "WORD;;IPv6 prefix-list name";
                    }
                  }
                }
              }

              container nemo {
                tailf:info "Network Mobility (NEMO)";
                tailf:cli-compact-syntax;
                uses isis-redist-af-grouping;
              }

              list ospf {
                tailf:info "Open Shortest Path First (OSPF)";
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                key process-id;
                leaf process-id {
                  tailf:cli-suppress-range;
                  type uint32 {
                    range "1 .. 65535";
                    tailf:info "<1-65535>;;Process ID";
                  }
                }
                uses isis-redist-af-grouping;
                container match {
                  tailf:cli-compact-syntax;
                  tailf:cli-flatten-container;
                  tailf:info "Redistribution of OSPF routes";
                  container internal {
                    presence "Redistribute OSPF internal routes";
                    tailf:info "Redistribute OSPF internal routes";
                    tailf:cli-compact-syntax;
                    tailf:cli-flatten-container;
                    uses isis-redist-ospf-match-grouping;
                  }
                  container external {
                    tailf:info "Redistribute OSPF external routes";
                    presence "Redistribute OSPF external routes";
                    tailf:cli-compact-syntax;
                    tailf:cli-flatten-container;
                    leaf external-routes {
                      tailf:cli-drop-node-name;
                      type redist-ospf-external-type;
                    }
                    uses isis-redist-ospf-match-grouping;
                  }
                  container nssa-external {
                    tailf:info "Redistribute OSPF NSSA external routes";
                    presence "Redistribute OSPF NSSA external routes";
                    tailf:cli-compact-syntax;
                    tailf:cli-flatten-container;
                    leaf nssa-external-routes {
                      tailf:cli-drop-node-name;
                      type redist-ospf-external-type;
                    }
                    uses isis-redist-ospf-match-grouping;
                  }
                }
              }

              list rip {
                tailf:info "IPv6 Routing Information Protocol (RIPv6)";
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                key process;
                leaf process {
                  type string {
                    tailf:info "WORD;;User selected string identifying "
                    +"this process";
                  }
                }
                uses isis-redist-af-grouping;
              }

              container static {
                tailf:info "Static routes";
                presence "Static routes";
                uses isis-redist-grouping;
              }

            }

            list summary-prefix {
              tailf:info "Configure IPv6 summary prefix";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key "prefix";
              leaf "prefix" {
                type inet:ipv6-prefix {
                  tailf:info "X:X:X:X::X/<0-128>;;IPv6 prefix x:x::y/<z>";
                }
              }
              leaf levels {
                tailf:cli-drop-node-name;
                type enumeration {
                  enum level-1 {
                    tailf:info "Summarize into level-1 area";
                  }
                  enum level-1-2 {
                    tailf:info "Summarize into both area and sub-domain";
                  }
                  enum level-2 {
                    tailf:info "Summarize into level-2 sub-domain";
                  }
                }
              }
            }
          }
        }
      }

      container advertise {
        tailf:info "Control which IP routes flow in L1 and L2 LSPs";
        leaf passive-only {
          tailf:info "only interface address of passive interfaces";
          type empty;
        }
      }

      container area-password {
        tailf:info "Configure the authentication password for an area";
        tailf:cli-sequence-commands;
        tailf:cli-compact-syntax;
        leaf name {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;Area password";
          }
        }
        uses authenticate-snp-grouping;
      }

      container authentication {
        tailf:info "ISIS authentication for LSPs";
        container mode {
          tailf:info "Authentication mode";
          container md5 {
            tailf:info "Keyed message digest";
            presence "Keyed message digest";
            uses authentication-level-grouping;
          }
          container text {
            tailf:info "Clear text password";
            presence "Clear text password";
            uses authentication-level-grouping;
          }
        }
        container key-chain {
          tailf:info "Authentication key-chain";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf name {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;Name of key-chain";
            }
          }
          uses authentication-level-grouping;
        }
        container send-only {
          tailf:info "Authentication send only, receive ignore";
          presence "Authentication send only, receive ignore";
          uses authentication-level-grouping;
        }
      }

      container bfd {
        tailf:info "BFD configuration commands";
        leaf all-interfaces {
          tailf:info "Enable BFD on all interfaces";
          type empty;
        }
      }

      container distance {
        tailf:info "Define an administrative distance";
        tailf:cli-compact-syntax;
        container clns-container {
          tailf:cli-drop-node-name;
          tailf:cli-sequence-commands;
          leaf distance {
            tailf:cli-drop-node-name;
            type uint32 {
              range "1 .. 255";
              tailf:info "<1-255>;;OSPF Administrative distance";
            }
          }
          leaf clns {
            tailf:info "Distance applied for CLNS derived routes";
            tailf:cli-full-command;
            type empty;
          }
        }
        container ip-container {
          tailf:cli-drop-node-name;
          tailf:cli-sequence-commands;
          leaf distance {
            tailf:cli-drop-node-name;
            type uint32 {
              range "1 .. 255";
              tailf:info "<1-255>;;OSPF Administrative distance";
            }
          }
          leaf ip {
            tailf:info "Distance applied for IP derived routes";
            tailf:cli-full-command;
            type empty;
          }
        }
        container acl-container {
          tailf:cli-drop-node-name;
          tailf:cli-sequence-commands;
          leaf distance {
            tailf:cli-drop-node-name;
            type uint32 {
              range "1 .. 255";
              tailf:info "<1-255>;;OSPF Administrative distance";
            }
          }
          list acl {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key "ip wildcard";
            leaf ip {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IP source address";
              }
            }
            leaf wildcard {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Wildcard bits";
              }
            }
            leaf acl-name {
              tailf:cli-drop-node-name;
              type access-list-standard-id-type;
              tailf:cli-no-value-on-delete;
            }
          }
        }
      }

      container domain-password {
        tailf:info "Set the authentication password for a routing domain";
        tailf:cli-sequence-commands;
        tailf:cli-compact-syntax;
        leaf name {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;Routing domain password";
          }
        }
        uses authenticate-snp-grouping;
      }

      container fast-flood {
        tailf:info "Flood LSPs (that triggered SPF) before running SPF";
        presence "Flood LSPs (that triggered SPF) before running SPF";
        leaf number {
          tailf:cli-drop-node-name;
          type uint32 {
            range "1 .. 15";
            tailf:info "<1-15>;;number of LSPs to be flooded "
            +"before starting SPF";
          }
        }
      }

      container hello {
        tailf:info "Pad ISIS hello PDUs to full MTU";
        container padding {
          tailf:info "Pad hello PDU";
          presence "Pad hello PDU";
          leaf pad-type {
            tailf:cli-drop-node-name;
            type enumeration {
              enum multi-point {
                tailf:info "Pad LAN hello PDUs";
              }
              enum point-to-point {
                tailf:info "Pad point-to-point hello PDUs";
              }
            }
          }
        }
      }

      container hostname {
        tailf:info "Dynamic hostname for IS-IS";
        leaf dynamic {
          tailf:info "Dynamic hostname";
          type empty;
        }
      }

      leaf ignore-lsp-errors {
        tailf:info "Ignore LSPs with bad checksums";
        tailf:cli-full-command;
        type empty;
      }

      container ip {
        tailf:info "IP specific commands";
        container route {
          tailf:info "ISIS IP routes";
          container priority {
            tailf:info "Assign priority to IP prefixes";
            container high {
              tailf:info "Assign high priority to important IP "
              +"prefixes in ISIS IP local RIB";
              leaf tag {
                tailf:info "Assign high priority to IP prefixes "
                +"with a specific route tag";
                type uint32 {
                  range "1 .. 4294967295";
                  tailf:info "<1-4294967295>;;tag value";
                }
              }
            }
          }
        }
      }

      leaf is-type {
        tailf:info "IS Level for this routing process (OSI only)";
        tailf:cli-full-command;
        type enumeration {
          enum level-1 {
            tailf:info "Act as a station router only";
          }
          enum level-1-2 {
            tailf:info "Act as both a station router and an area router";
          }
          enum level-2-only {
            tailf:info "Act as an area router only";
          }
        }
      }

      container ispf {
        tailf:info "Configure execution of incremental SPF";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf level {
          tailf:cli-drop-node-name;
          type enumeration {
            enum level-1 {
              tailf:info "Do incremental SPF for level-1";
            }
            enum level-1-2 {
              tailf:info "Do incremental SPF for both levels";
            }
            enum level-2 {
              tailf:info "Do incremental SPF for level-2";
            }
          }
        }
        leaf number {
          tailf:cli-drop-node-name;
          type uint32 {
            range "1 .. 600";
            tailf:info "<1-600>;;Number of seconds before "
            +"activating incremental-spf";
          }
        }
      }

      container log-adjacency-changes {
        tailf:info "Log changes in adjacency state";
        presence "Log changes in adjacency state";
        leaf all {
          tailf:info "Include changes generated by non-IIH event";
          type empty;
        }
      }

      container lsp-full {
        tailf:info "If we run out of LSP fragments";
        container suppress {
          tailf:info "suppress the following types of IP prefixes";
          choice lsp-full-choince {
            container external-interlevel-container {
              tailf:cli-drop-node-name;
              tailf:cli-compact-syntax;
              leaf external {
                tailf:info "don't advertise IP prefixes learned "
                +"from other protocols";
                type empty;
              }
              leaf interlevel {
                tailf:info "don't advertise IP prefixes learned "
                +"from another ISIS level";
                type empty;
              }
            }
            leaf none {
              tailf:info "don't suppress any prefixes";
              type empty;
            }
          }
        }
      }

      container lsp-gen-interval {
        tailf:info "Minimum interval between regenerating same LSP";
        choice lsp-gen-interval-choice {
          container intervals {
            tailf:cli-drop-node-name;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            uses lsp-gen-interval-grouping;
          }
          container intervals-levels {
            tailf:cli-drop-node-name;
            container intervals-level-1 {
              tailf:cli-drop-node-name;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              leaf level-1 {
                tailf:info "Set interval for level 1 only";
                type empty;
              }
              uses lsp-gen-interval-grouping;
            }
            container intervals-level-2 {
              tailf:cli-drop-node-name;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              leaf level-2 {
                tailf:info "Set interval for level 2 only";
                type empty;
              }
              uses lsp-gen-interval-grouping;
            }
          }
        }
      }

      leaf lsp-mtu {
        tailf:info "Set maximum LSP size";
        tailf:cli-full-command;
        type uint32 {
          range "128 .. 4352";
          tailf:info "<128-4352>;;Max LSP size in bytes";
        }
      }

      leaf lsp-refresh-interval {
        tailf:info "Set LSP refresh interval";
        tailf:cli-full-command;
        type uint32 {
          range "1 .. 65535";
          tailf:info "<1-65535>;;LSP refresh time in seconds";
        }
      }

      leaf max-area-addresses {
        tailf:info "Allow configuration of more manual area addresses";
        tailf:cli-full-command;
        type uint32 {
          range "3 .. 254";
          tailf:info "<3-254>;;Max number of manual area addresses";
        }
      }

      leaf max-lsp-lifetime {
        tailf:info "Set maximum LSP lifetime";
        tailf:cli-full-command;
        type uint32 {
          range "1 .. 65535";
          tailf:info "<1-65535>;;Maximum LSP lifetime in seconds";
        }
      }

      container metric-style {
        tailf:info "Use old-style (ISO 10589) or new-style packet formats";
        choice metric-style-choice {
          container narrow {
            tailf:info "Use old style of TLVs with narrow metric";
            presence true;
            uses narrow-wide-transition-grouping;
          }
          container transition {
            tailf:info "Send and accept both styles of TLVs "
            +"during transition";
            presence true;
            leaf transition {
              type isis-level-type;
              tailf:cli-drop-node-name;
            }
          }
          container wide {
            tailf:info "Use new style of TLVs to carry wider metric";
            presence true;
            uses narrow-wide-transition-grouping;
          }
        }
      }

      container mpls {
        tailf:info "Configure MPLS routing protocol parameters";
        container traffic-eng {
          tailf:info "routing protocol commands for MPLS Traffic Engineering";
          leaf level-1 {
            tailf:info "Run MPLS TE on IS-IS level 1 only";
            tailf:cli-full-command;
            type empty;
          }
          leaf level-2 {
            tailf:info "Run MPLS TE on IS-IS level 2 only";
            tailf:cli-full-command;
            type empty;
          }
          leaf multicast-intact {
            tailf:info "MPLS TE and PIM interaction";
            tailf:cli-full-command;
            type empty;
          }

          container router-id {
            tailf:info "Traffic Engineering stable IP address for system";
            tailf:cli-diff-dependency "/ios:interface";
            uses interface-grouping;
          }

          container scanner {
            tailf:info "Timer parameters for TE database";
            presence "Timer parameters for TE database";
            tailf:cli-compact-syntax;
            leaf interval {
              tailf:info "time (secs) between LSPDB walks for TE";
              type uint32 {
                range "1 .. 60";
                tailf:info "<1-60>;;interval between LSPDB walks "
                +"for TE TLVs extraction";
              }
            }
            leaf max-flash {
              tailf:info "Number of ISIS LSPs to be processed with no delay";
              type uint32 {
                range "0 .. 200";
                tailf:info "<0-200>;;Max. number of LSPs ISIS may send to "
                +"TE db without delay";
              }
            }
          }
        }
      }

      list net {
        tailf:info "A Network Entity Title for this process (OSI only)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key tag;
        leaf tag {
          type isis-net;
        }
      }

      container partition {
        tailf:info "CLNS area partition";
        leaf avoidance {
          tailf:info "Withdraw area prefix if partition detected";
          type empty;
        }
      }

      uses passive-interface-grouping;

      container protocol {
        tailf:info "Set protocol's administrative state";
        leaf shutdown {
          tailf:info "Set protocol's administrative state to disable";
          type empty;
        }
      }

      container redistribute {
        tailf:info "Redistribute information from another routing protocol";
        uses isis-redist-grouping;
        container bgp {
          tailf:info "Border Gateway Protocol (BGP)";
          tailf:cli-sequence-commands;
          tailf:cli-compact-syntax;
          leaf as-number {
            tailf:cli-drop-node-name;
            type uint32 {
              range "1 .. 65535";
              tailf:info "<1-65535>;;Autonomous system number";
            }
          }
          uses isis-redist-clns-ip-grouping;
        }

        container connected {
          tailf:info "Connected";
          presence "Connected";
          uses isis-redist-grouping;
        }
        list eigrp {
          tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key as-number;
          leaf as-number {
            tailf:cli-drop-node-name;
            type uint32 {
              range "1 .. 65535";
              tailf:info "<1-65535>;;Autonomous system number";
            }
          }
          uses isis-redist-grouping;
        }

        container isis {
          tailf:info "ISO IS-IS";
          tailf:cli-compact-syntax;
          leaf area-tag {
            tailf:cli-full-command;
            tailf:cli-drop-node-name;
            tailf:cli-disallow-value "ip";
            type string {
              tailf:info "WORD;;ISO routing area tag";
            }
          }
          container ip {
            tailf:info "Redistribution of IP routes between levels";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf isis-redist-levels1 {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type enumeration {
                enum level-1 {
                  tailf:info "Inter-area routes from level-1";
                }
                enum level-2 {
                  tailf:info "Inter-area routes from level-2";
                }
              }
            }
            leaf into {
              tailf:info "from level-n into level-m";
              tailf:cli-incomplete-command;
              type empty;
            }
            leaf isis-redist-levels2 {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type enumeration {
                enum level-1 {
                  tailf:info "Inter-area routes from level-1";
                }
                enum level-2 {
                  tailf:info "Inter-area routes from level-2";
                }
              }
            }
            choice isis-redist-isis-ip-choice {
              leaf distribute-list {
                tailf:info "select routes";
                type uint32 {
                  range "100 .. 199";
                  tailf:info "<100-199>;;IP extended acces-list number";
                }
              }
              leaf route-map {
                tailf:info "Route map for route matching";
                type string {
                  tailf:info "WORD;;Name of the route-map";
                }
              }
            }
          }
        }

        container iso-igrp {
          tailf:info "IGRP for OSI networks";
          presence "IGRP for OSI networks";
          tailf:cli-sequence-commands;
          choice iso-igrp-choice {
            container area-tag-route-map-container {
              tailf:cli-drop-node-name;
              tailf:cli-sequence-commands;
              tailf:cli-flatten-container;
              leaf area-tag {
                tailf:cli-drop-node-name;
                tailf:cli-disallow-value "route-map";
                type string {
                  tailf:info "WORD;;ISO routing area tag";
                }
              }
              leaf route-map {
                tailf:info "Route map reference";
                type string {
                  tailf:info "WORD;;Pointer to route-map entries";
                }
              }
            }
            leaf route-map {
              tailf:info "Route map reference";
              type string {
                tailf:info "WORD;;Pointer to route-map entries";
              }
            }
          }
          uses redist-level-grouping;
          leaf metric {
            tailf:info "ISIS default metric";
            type uint32 {
              range "0 .. 4294967295";
              tailf:info "<0-4294967295>;;ISIS default metric";
            }
          }
          leaf metric-type {
            tailf:info "OSPF/IS-IS exterior metric type for "
            +"redistributed routes";
            type enumeration {
              enum external {
              tailf:info "Set IS-IS External metric type";
              }
              enum internal {
              tailf:info "Set IS-IS Internal metric type";
              }
            }
          }
        }

        container maximum-prefix {
          tailf:info "Maximum number of prefixes redistributed to protocol";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf number {
            tailf:cli-drop-node-name;
            type uint32 {
              range "1 .. 4294967295";
              tailf:info "<1-4294967295>;;Maximum number of IP "
              +"prefixes redistributed";
            }
          }
          leaf threshold-value {
            tailf:cli-drop-node-name;
            tailf:cli-break-sequence-commands;
            type uint32 {
              range "1 .. 100";
              tailf:info "<1-100>;;Threshold value (%) at which to "
              +"generate a warning message";
            }
          }
          leaf warning-only {
            tailf:info "Only give warning message when limit is exceeded";
            tailf:cli-full-command;
            type empty;
          }
          leaf withdraw {
            tailf:info "Withdraw redistibuted prefixes";
            tailf:cli-full-command;
            type empty;
          }
        }

        container mobile {
          tailf:info "Mobile routes";
          presence "Mobile routes";
          uses isis-redist-grouping;
        }

        container odr {
          tailf:info "On Demand stub Routes";
          presence "On Demand stub Routes";
          uses isis-redist-grouping;
        }

        list ospf {
          tailf:info "Open Shortest Path First (OSPF)";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key process-id;
          leaf process-id {
            tailf:cli-suppress-range;
            type uint32 {
              range "1 .. 65535";
              tailf:info "<1-65535>;;Process ID";
            }
          }
          uses isis-redist-grouping;
          container match {
            tailf:cli-compact-syntax;
            tailf:cli-flatten-container;
            tailf:info "Redistribution of OSPF routes";
            container internal {
              presence "Redistribute OSPF internal routes";
              tailf:info "Redistribute OSPF internal routes";
              tailf:cli-compact-syntax;
              tailf:cli-flatten-container;
              uses isis-redist-ospf-match-grouping;
            }
            container external {
              tailf:info "Redistribute OSPF external routes";
              presence "Redistribute OSPF external routes";
              tailf:cli-compact-syntax;
              tailf:cli-flatten-container;
              leaf external-routes {
                tailf:cli-drop-node-name;
                type redist-ospf-external-type;
              }
              uses isis-redist-ospf-match-grouping;
            }
            container nssa-external {
              tailf:info "Redistribute OSPF NSSA external routes";
              presence "Redistribute OSPF NSSA external routes";
              tailf:cli-compact-syntax;
              tailf:cli-flatten-container;
              leaf nssa-external-routes {
                tailf:cli-drop-node-name;
                type redist-ospf-external-type;
              }
              uses isis-redist-ospf-match-grouping;
            }
          }
          leaf vrf {
            tailf:info "VPN Routing/Forwarding Instance";
            tailf:cli-diff-dependency "/ios:ip/vrf";
            tailf:cli-diff-dependency "/ios:vrf/definition";
            type string {
              tailf:info "WORD;;VPN Routing/Forwarding Instance (VRF) name";
            }
          }
        }

        container rip {
          tailf:info "Routing Information Protocol (RIP)";
          presence "Routing Information Protocol (RIP)";
          uses isis-redist-grouping;
        }

        container static {
          tailf:info "Static routes";
          presence "Static routes";
          uses isis-redist-clns-ip-grouping;
        }
      }

      container set-attached-bit {
        tailf:info "Conditionally advertise us as attached to L2";
        leaf route-map {
          tailf:info "Route-map reference";
          type string {
            tailf:info "WORD;;Route map name";
          }
        }
      }

      list summary-address {
        tailf:info "Configure IP address summaries";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "ip mask";
        leaf ip {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP summary address";
          }
        }
        leaf mask {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Summary mask";
          }
        }
        container level-1 {
          tailf:info "Summarize into level-1 area";
          presence "Summarize into level-1 area";
          tailf:cli-compact-syntax;
          uses summary-address-metric-tag-grouping;
        }
        container level-1-2 {
          tailf:info "Summarize into both area and sub-domain";
          presence "Summarize into both area and sub-domain";
          tailf:cli-compact-syntax;
          uses summary-address-metric-tag-grouping;
        }
        container level-2 {
          tailf:info "Summarize into level-2 sub-domain";
          presence "Summarize into level-2 sub-domain";
          tailf:cli-compact-syntax;
          uses summary-address-metric-tag-grouping;
        }
        container metric-tag-container {
          tailf:cli-drop-node-name;
          tailf:cli-compact-syntax;
          uses summary-address-metric-tag-grouping;
        }
      }

      leaf update-queue-depth {
        tailf:info "Set Update process queue depth";
        type uint32 {
          range "1 .. 2147483647";
          tailf:info "<1-2147483647>;;Max queue depth";
        }
      }

      container use {
        tailf:info "Use different algorithms during SPF";
        leaf external-metrics {
          tailf:info "Honour external metrics during SPF";
          type empty;
        }
      }
    }
  }

  // grouping interface-switch-grouping
  grouping interface-switch-grouping {
    // this should probably only be a part of Catalyst
    // device models.

    // interface * / no switchport
    container switchport-conf {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      leaf switchport {
        tailf:cli-boolean-no;
        //tailf:cli-trim-default;
        type boolean;
        //default true;
      }
    }

    // interface * / switchport
    container switchport {
      tailf:info "Set switching mode characteristics";
      tailf:cli-incomplete-no;
      // interface * / switchport access
      container access {
        tailf:info "Set access mode characteristics of the interface";
        leaf vlan {
          tailf:info "Set VLAN when interface is in access mode";
          // Note: Can't use leafref cause of 'dynamic' keyword
          tailf:cli-diff-dependency "/ios:vlan/vlan-list/id";
          type union {
            type uint16 {
              tailf:info "<1-4094>;;VLAN ID of the VLAN when this port "+
                "is in access mode";
              range "1..4094";
            }
            type enumeration {
              enum dynamic {
                tailf:info "When in access mode, this interfaces VLAN is "+
                  "controlled by VMPS";
              }
            }
          }
        }
      }

      //  backup         Set backup for the interface

      // interface * / switchport block
      container block {
        tailf:info "Disable forwarding of unknown uni/multi cast addresses";
        leaf multicast {
          tailf:info "Block unknown multicast addresses";
          tailf:cli-full-command;
          type empty;
        }
        leaf unicast {
          tailf:cli-full-command;
          tailf:info "Block unknown unicast addresses";
          type empty;
        }
      }

      //  dot1q          Set interface dot1q properties

      // interface * / switchport mode
      container mode {
        tailf:info "Set trunking mode of the interface";
        choice mode-choice {
          container access {
            presence "true";
            tailf:info "Set trunking mode to ACCESS unconditionally";
          }
          container dot1q-tunnel {
            presence "true";
            tailf:info "set trunking mode to TUNNEL unconditionally";
          }
          leaf dynamic {
            tailf:info "Set trunking mode to dynamically negotiate access "+
              "or trunk mode";
            type enumeration {
              enum auto {
                tailf:info "Set trunking mode dynamic negotiation parameter "+
                "to AUTO";
              }
              enum desirable {
                tailf:info "Set trunking mode dynamic negotiation parameter "+
                "to DESIRABLE";
              }
            }
          }
          container trunk {
            presence "true";
            tailf:info "Set trunking mode to TRUNK unconditionally";
          }
        }
      }

      // interface * / switchport nonegotiate
      leaf nonegotiate {
        tailf:info "Device will not engage in negotiation protocol "+
          "on this interface";
        type empty;
      }

      // interface * / switchport port-security
      container port-security {
        tailf:info "Security related command";
        presence true;
        container aging {
          tailf:info "Port-security aging commands";
          leaf time {
            tailf:info "Port-security aging time";
            type uint16 {
              tailf:info "<1-1440>;;Aging time in minutes. Enter a value "
              +"between 1 and 1440";
              range "1..1440";
            }
          }
          leaf type {
            tailf:info "Port-security aging type";
            type enumeration {
              enum absolute {
                tailf:info "Absolute aging (default)";
              }
              enum inactivity {
                tailf:info "Aging based on inactivity time period";
              }
            }
          }
        }
        container mac-address {
          tailf:info "Secure mac address";
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-compact-syntax;
          leaf sticky {
            tailf:info "Configure dynamic secure addresses as sticky";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          leaf hw-address {
            tailf:cli-drop-node-name;
            type yang:mac-address {
              tailf:info "H.H.H;;48 bit mac address";
            }
          }
          leaf vlan {
            tailf:info "set VLAN ID of the VLAN on which this address can be "
            +"learned";
            type uint16 {
              tailf:info "<1-4094>;;VLAN ID on which this address can be "
              +"learned";
              range "1..4094";
            }
          }
        }
        container maximum {
          tailf:info "Max secure addresses";
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-compact-syntax;

          leaf max-addresses {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<1-4097>;;Maximum addresses";
              range "1..4097";
            }
          }

          leaf vlan {
            tailf:info "Max secure addresses per vlan";
            type string {
              tailf:info "WORD;;VLAN IDs to which this maximum applies";
            }
          }
        }
        leaf violation {
          tailf:info "Security violation mode";
          type enumeration {
            enum protect {
              tailf:info "Security violation protect mode";
            }
            enum restrict {
              tailf:info "Security violation restrict mode";
            }
            enum shutdown {
              tailf:info "Security violation shutdown mode";
            }
          }
        }
      }

      // interface * / switchport trunk
      container trunk {
        tailf:info "Set trunking characteristics of the interface";

        // interface * / switchport trunk allowed
        container allowed {
          tailf:info "Set allowed VLAN characteristics when interface "+
            "is in trunking mode";
          // interface * / switchport trunk allowed vlan
          container vlan {
            tailf:info "Set allowed VLANs when interface is in trunking mode";
            choice vlan-choice {
              leaf-list vlans {
                tailf:cli-replace-all;
                tailf:cli-range-list-syntax;
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "WORD;;VLAN IDs of the allowed VLANs "
                  +"when this port is in trunking mode";
                }
              }
              leaf all {
                tailf:info "all VLANs";
                type empty;
              }
              leaf-list except {
                tailf:info "all VLANs except the following";
                tailf:cli-range-list-syntax;
                type uint16 {
                  tailf:info "WORD;;VLAN IDs of the allowed VLANs "
                    +"when this port is in trunking mode";
                }
              }
              leaf none {
                tailf:info "no VLANs";
                type empty;
              }
            }
          }
        }

        // interface * / switchport trunk encapsulation
        leaf encapsulation {
          tailf:info "Set encapsulation format on trunk port";
          type enumeration {
            enum "dot1q";
            enum "isl";
            enum "negotiate";
          }
        }

        // interface * / switchport trunk native
        container native {
          tailf:info "Set trunking native characteristics when interface "+
            "is in trunking mode";
          leaf vlan {
            tailf:info "Set native VLAN when interface is in trunking mode";
            type union {
              type enumeration {
                enum tag {
                  tailf:info "Set native VLAN tagging state";
                }
              }
              type uint16 {
                tailf:info "<1-4094>;;VLAN ID of the native VLAN when "
                  +"this port is in trunking mode";
                range "1..4094";
              }
            }
          }
        }

        // interface * / switchport trunk pruning
        container pruning {
          tailf:info "Set pruning VLAN characteristics when interface is in "+
            "trunking mode";
          container vlan {
            tailf:info "Set VLANs enabled for pruning when interface is in "+
              "trunking mode";
            choice vlan-choice {
              leaf-list vlans {
                tailf:cli-range-list-syntax;
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "WORD;;VLAN IDs of the allowed VLANs "
                    +"when this port is in trunking mode";
                }
              }
              leaf-list except {
                tailf:info "all VLANs except the following";
                tailf:cli-range-list-syntax;
                type uint16 {
                  tailf:info "WORD;;VLAN IDs of the allowed VLANs "
                    +"when this port is in trunking mode";
                }
              }
              leaf none {
                tailf:info "no VLANs";
                type empty;
              }
            }
          }
        }
      }

      // interface * / switchport voice
      container voice {
        tailf:info "Voice appliance attributes";
        leaf vlan {
          tailf:info "Vlan for voice traffic";
          type union {
            type enumeration {
              enum dot1p {
                tailf:info "Priority tagged on PVID";
              }
              enum none {
                tailf:info "Don't tell telephone about voice vlan";
              }
              enum untagged {
                tailf:info "Untagged on PVID";
              }
            }
            type uint16 {
              tailf:info "<1-4094>;;Vlan for voice traffic";
              range "1..4094";
            }
          }
        }
        container detect {
          tailf:info "detection enhancement keyword";
          tailf:cli-incomplete-command;
          container cisco-phone {
            tailf:info "Cisco IP phone";
            presence true;
            leaf full-duplex {
              tailf:info "full duplex keyword";
              type empty;
            }
          }
        }
      }

      // interface * / switchport priority
      container priority {
        tailf:info "Set appliance 802.1p priority";
        tailf:cli-incomplete-command;

        container extend {
          tailf:info "Set appliance 802.1p priority";
          tailf:cli-incomplete-command;
          choice trust-choice {
            leaf trust {
              tailf:cli-full-command;
              tailf:info "Trust 802.1p priorities of devices on appliance";
              type empty;
            }
            leaf cos {
              tailf:info "Override 802.1p priority of devices on appliance";
              tailf:cli-full-command;
              type uint8 {
                tailf:info "<0-7>;;Priority for devices on appliance";
                range "0..7";
              }
            }
          }
        }
      }

      // interface * / switchport autostate
      container autostate {
        tailf:info "Include or exclude this port from vlan link up calculation";
        tailf:cli-incomplete-command;
        leaf exclude {
          tailf:info "Exclude this port from vlan link up calculation";
          type empty;
        }
      }

      // interface * / switchport protected
      leaf protected {
        tailf:info "Configure an interface to be a protected port";
        type empty;
      }

      // interface * / switchport host
      leaf host {
        tailf:info "Set port host";
        type empty;
      }
    }

    // no                      Negate a command or set its defaults
    // ntp                     Configure NTP
    // priority-group          Assign a priority group to an interface
    // random-detect     Enable Weighted Random Early Detection (WRED) on an
    //                         Interface
    // rate-limit              Rate Limit
    // rmon                    Configure Remote Monitoring on an interface
    // shutdown                Shutdown the selected interface
    // snapshot                Configure snapshot support on the interface
    // snmp                    Modify SNMP interface parameters

    // interface * / spanning-tree
    container spanning-tree {
      tailf:info "Spanning Tree Subsystem";
      // interface * / spanning-tree bpdufilter
      leaf bpdufilter {
        tailf:info "Don't send or receive BPDUs on this interface";
        type enumeration {
          enum disable {
            tailf:info "Disable BPDU filtering for this interface";
          }
          enum enable {
            tailf:info "Enable BPDU filtering for this interface";
          }
        }
      }
      // interface * / spanning-tree bpduguard
      container bpduguard {
        tailf:info "Don't accept BPDUs on this interface";
        choice bpduguard-choice {
          leaf disable {
            tailf:info "Disable BPDU guard for this interface";
            type empty;
          }
          leaf enable {
            type empty;
            tailf:info "Enable BPDU guard for this interface";
          }
        }
      }
      // interface * / spanning-tree cost
      leaf cost {
        tailf:info "To set the path cost of the interface";
        tailf:cli-full-command;
        type uint32 {
          range "1..200000000";
        }
      }
      // interface * / spanning-tree guard
      leaf guard {
        tailf:info "Change an interface's spanning tree guard mode";
        tailf:cli-full-command;
        type enumeration {
          enum loop {
            tailf:info "Set guard mode to loop guard on "
            +"interface";
          }
          enum none {
            tailf:info "Set guard mode to none";
          }
          enum root {
            tailf:info "Set guard mode to root guard on "
            +"interface";
          }
        }
      }
      // interface * / spanning-tree link-type
      leaf link-type {
        tailf:info "Specify a link type for spanning tree tree "
        +"protocol use";
        tailf:cli-full-command;
        type enumeration {
          enum auto {
            tailf:code-name link_type_auto;
            tailf:info "Determine link type based on media "
            +"duplex of this interface";
          }
          enum none {
            tailf:info "Consider the interface as point-to-"
            +"point";
          }
          enum point-to-point {
            tailf:info "Consider the interface as point-to-"
            +"point";
          }
          enum root {
            tailf:info "Consider the interface as shared";
          }
        }
      }
      // interface * / spanning-tree portfast
      container portfast {
        tailf:info "Spanning tree portfast options";
        tailf:cli-delete-when-empty;
        presence true;
        leaf enable {
          tailf:cli-full-command;
          tailf:cli-drop-node-name;
          type enumeration {
            enum disable {
              tailf:info "Disable portfast for this interface";
            }
          }
        }
        leaf trunk {
          //FIXME: tailf:info
          type empty;
        }
      }
      // interface * / spanning-tree loopguard default
      container loopguard {
        tailf:info "Spanning tree loopguard options";
        leaf default {
          tailf:info "Enable loopguard by default on all ports";
          type empty;
        }
      }
    }

    // interface * / srr-queue
    container srr-queue {
      //tailf:info
      container bandwidth {
        //tailf:info
      // interface * / srr-queue bandwidth shape
        container shape {
          //tailf:info
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-reset-container;
          leaf weight1 {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
              //tailf:info
            }
          }
          leaf weight2 {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
              //tailf:info
            }
          }
          leaf weight3 {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
              //tailf:info
            }
          }
          leaf weight4 {
            tailf:cli-drop-node-name;
            type uint16 {
              //tailf:info
            }
          }
        }
        // interface * / srr-queue bandwidth share
        container share {
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-reset-container;
          //tailf:info
          leaf weight1 {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              range "1..255";
            }
          }
          leaf weight2 {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              range "1..255";
            }
          }
          leaf weight3 {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              range "1..255";
            }
          }
          leaf weight4 {
            tailf:cli-drop-node-name;
            type uint8 {
              range "1..255";
            }
          }
        }
      }
    }
  }

  // password-07-grouping
  grouping password-07-grouping {
    leaf level {
      tailf:info "Set exec level password";
      tailf:cli-optional-in-sequence;
      type uint8 {
        tailf:info "<1-15>;;Level number";
      }
    }
    leaf "type" {
      tailf:cli-drop-node-name;
      tailf:cli-optional-in-sequence;
      type enumeration {
        enum "0" {
          tailf:info "Specifies an UNENCRYPTED password will follow";
        }
        enum "7" {
          tailf:info "Specifies a HIDDEN password will follow";
        }
      }
    }
    leaf secret {
      tailf:cli-drop-node-name;
      type string {
        tailf:info "LINE;;The UNENCRYPTED (cleartext) password";
      }
    }
  }

  // aaa-authentication-dot1x-grouping
  grouping aaa-authentication-dot1x-grouping {
    leaf group {
      tailf:info "Use Server-group";
      type union {
        type string {
          tailf:info "Server-group name";
        }
        type enumeration {
          enum radius {
            tailf:info "Use list of all Radius hosts.";
          }
          enum "tacacs+" {
            tailf:info "Use list of all Tacacs+ hosts.";
          }
        }
      }
    }
  }


  // =========================================================================
  //                        MODEL
  // =========================================================================


  /// ========================================================================
  /// version
  /// ========================================================================

  leaf version {
    tailf:info "Version";
    type string {
      tailf:info "WORD;;Version number";
    }
  }


  /// ========================================================================
  /// service
  /// ========================================================================

  container service {
    tailf:info "Modify use of network based services";

    // service pad
    container pad {
      tailf:info "Enable PAD commands";
      tailf:cli-show-no;
      presence true;
      leaf cmns {
        tailf:info "Enable PAD over CMNS connections";
        type empty;
      }
      leaf from-xot {
        tailf:info "Accept XOT to PAD connections";
        type empty;
      }
      leaf to-xot {
        tailf:info "Allow outgoing PAD over XOT connections";
        type empty;
      }
    }

    // service password-encryption
    leaf password-encryption {
      tailf:info "Encrypt system passwords";
      tailf:cli-full-command;
      type empty;
    }

    // service timestamps
    container timestamps {
      tailf:info "Timestamp debug/log messages";
      tailf:cli-compact-syntax;
      tailf:cli-delete-when-empty;
      presence true;
      // service timestamps debug
      container debug {
        tailf:info "Timestamp debug messages";
        // service timestamps datetime
        container datetime {
          tailf:info "Timestamp with date and time";
          tailf:cli-compact-syntax;
          tailf:cli-delete-when-empty;
          presence true;
          leaf localtime {
            tailf:info "Use local time zone for timestamps";
            type empty;
          }
          // service timestamps datetime msec
          leaf msec {
            tailf:info "Include milliseconds in timestamp";
            type empty;
          }
          leaf show-timezone {
            tailf:info "Add time zone information to timestamp";
            type empty;
          }
          leaf year {
            tailf:info "Include year in timestamp";
            type empty;
          }
        }
        leaf uptime {
          tailf:info "Timestamp with system uptime";
          type empty;
        }
      }

      // service timestamps log
      container log {
        tailf:info "Timestamp log messages";
        container datetime {
          tailf:info "Timestamp with date and time";
          tailf:cli-compact-syntax;
          tailf:cli-delete-when-empty;
          presence true;
          leaf localtime {
            tailf:info "Use local time zone for timestamps";
            type empty;
          }
          leaf msec {
            tailf:info "Include milliseconds in timestamp";
            type empty;
          }
          leaf show-timezone {
            tailf:info "Add time zone information to timestamp";
            type empty;
          }
          leaf year {
            tailf:info "Include year in timestamp";
            type empty;
          }
        }
        leaf uptime {
          tailf:info "Timestamp with system uptime";
          type empty;
        }
      }
    }

    // service alignment
    container alignment {
      tailf:info "Control alignment correction and logging";
      leaf detection {
        tailf:info "Enable detection of alignment issues";
        type empty;
      }
      leaf logging {
        tailf:info "Enable logging of alignment issues";
        type empty;
      }
    }

    // service call-home
    leaf call-home {
      tailf:info "Enable call-home service";
      tailf:cli-full-command;
      type empty;
    }

    // service compress-config
    leaf compress-config {
      tailf:info "Compress the configuration file";
      tailf:cli-full-command;
      type empty;
    }

    leaf "config" {
      tailf:info "TFTP load config files";
      tailf:cli-full-command;
      type empty;
    }

    // service counters
    container counters {
      tailf:info "Control aging of interface counters";
      container max {
        tailf:info "Maximum counter aging threshold";

        leaf age {
          tailf:info "Aging threshold";
          type uint8 {
            tailf:info "<0-60>;;Aging threshold value in seconds";
            range "0..60";
          }
        }
      }
    }

    // service dhcp
    leaf dhcp {
      tailf:info "Enable DHCP server and relay agent";
      tailf:cli-full-command;
      type empty;
    }

    // service disable-ip-fast-frag
    leaf disable-ip-fast-frag {
      tailf:info "Disable IP particle-based fast fragmentation";
      tailf:cli-full-command;
      type empty;
    }

    // service exec-callback
    leaf exec-callback {
      tailf:info "Enable exec callback";
      tailf:cli-full-command;
      type empty;
    }

    // service exec-wait
    leaf exec-wait {
      tailf:info "Delay EXEC startup on noisy lines";
      tailf:cli-full-command;
      type empty;
    }

    // service finger
    leaf finger {
      tailf:info "Allow responses to finger requests";
      tailf:cli-full-command;
      type empty;
    }

    // service heartbeat
    container heartbeat {
      tailf:info "Enable heartbeat processing";
      leaf fatal-count {
        tailf:info "Set heartbeat fatal count";
        type uint8 {
          tailf:info "<1-60>;;Number of timeouts until fatal error occurs";
          range "1..60";
        }
      }
      leaf interrupt-interval {
        tailf:info "Set heartbeat interrupt test interval";
        type uint8 {
          tailf:info "<0-60>;;Interval between interrupt level tests";
          range "0..60";
        }
      }
      leaf interrupt-max {
        tailf:info "Set maximum message count from interrupt test";
        type uint8 {
          tailf:info "<0-60>;;Maximum number of messages from interrupt test";
          range "0..60";
        }
      }
      leaf transmit-interval {
        tailf:info "Set heartbeat transmit interval";
        type uint8 {
          tailf:info "<1-30>;;Interval between heartbeat transmissions";
          range "1..30";
        }
      }
      leaf warning-timeout {
        tailf:info "Set heartbeat warning timeout interval";
        type uint8 {
          tailf:info "<5-60>;;Interval between heartbeat timeout warnings";
          range "5..60";
        }
      }
    }

    // service hide-telnet-addresses
    leaf hide-telnet-addresses {
      tailf:info "Hide destination addresses in telnet command";
      tailf:cli-full-command;
      type empty;
    }
    //  image-version          image-version

    // service linenumber
    leaf linenumber {
      tailf:info "enable line number banner for each exec";
      tailf:cli-full-command;
      type empty;
    }

    // service nagle
    leaf nagle {
      tailf:info "Enable Nagle's congestion control algorithm";
      tailf:cli-full-command;
      type empty;
    }

    // service old-slip-prompts
    leaf old-slip-prompts {
      tailf:info "Allow old scripts to operate with slip/ppp";
      tailf:cli-full-command;
      type empty;
    }
    //  prompt                 Enable mode specific prompt

    // service pt-vty-logging
    leaf pt-vty-logging {
      tailf:info "Log significant VTY-Async events";
      tailf:cli-full-command;
      type empty;
    }

    // service sequence-numbers
    leaf sequence-numbers {
      tailf:info "Stamp logger messages with a sequence number";
      tailf:cli-full-command;
      type empty;
    }

    // service slave-log
    leaf slave-log {
      tailf:info "Enable log capability of slave IPs";
      tailf:cli-full-command;
      type empty;
    }

    // service tcp-keepalives-in
    leaf tcp-keepalives-in {
      tailf:info "Generate keepalives on idle incoming network connections";
      tailf:cli-full-command;
      type empty;
    }

    // service tcp-keepalives-out
    leaf tcp-keepalives-out {
      tailf:info "Generate keepalives on idle outgoing network connections";
      tailf:cli-full-command;
      type empty;
    }
    //  telnet-zeroidle        Set TCP window 0 when connection is idle
    //  timestamps             Timestamp debug/log messages
    //  udp-small-servers      Enable small UDP servers (e.g., ECHO)

    // service unsupported-transceiver
    leaf unsupported-transceiver {
      tailf:info "";
      tailf:cli-full-command;
      type empty;
    }
  }


  /// ========================================================================
  /// platform
  /// ========================================================================

  container platform {
    tailf:info "platform specific configuration";

    leaf atm-cdvt {
      tailf:info "Configure platform atm cdvt";
      tailf:cli-boolean-no;
      type boolean;
    }
    container bfd {
      tailf:info "Platform specific BFD commands";
      leaf disable-offload {
        tailf:info "Disable bfd hw offload";
        type empty;
      }
      // platform bfd allow-svi
      leaf allow-svi {
        tailf:cli-full-command;
        type empty;
      }

      // platform bfd enable-offload
      leaf enable-offload {
        tailf:cli-full-command;
        type empty;
      }
    }
    container console {
      tailf:info "Direct IOS output to console";
      presence true;
      leaf output {
        tailf:cli-drop-node-name;
        type enumeration {
          enum serial {
            tailf:info "Direct IOS output to serial port";
          }
          enum virtual {
            tailf:info "Direct IOS output to virtual console";
          }
        }
      }
    }
    container hardware {
      tailf:info "Configure platform hardware";
      container throughput {
        tailf:info "Configure throughput";
        choice throughput-choice {
          leaf disable {
            tailf:info "Disable throughput upgrade licenses";
            type enumeration {
              enum internal-license {
                tailf:info "Disable throughput internal license";
              }
            }
          }
          container level {
            tailf:info "Configure the current traffic throughput level";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf kbps {
              tailf:cli-drop-node-name;
              type enumeration {
                enum 10000 {
                  tailf:info "throughput in kbps";
                }
                enum 25000 {
                  tailf:info "throughput in kbps";
                }
                enum 50000 {
                  tailf:info "throughput in kbps";
                }
              }
            }
            leaf eval-only {
              tailf:info "Use only evaluation license";
              type empty;
            }
          }
        }
      }
    }
    container ipsec {
      tailf:info "Platform specific ipsec command";
      leaf fips-mode {
        tailf:info "enable FIPS mode";
        type empty;
      }
      leaf gdoi {
        tailf:info "gdoi";
        type enumeration {
          enum accept-both {
            tailf:info "7200 like behaviour";
          }
        }
      }
      container llq {
        tailf:info "config LLQ";
        leaf qos-group {
          tailf:info "config LLQ QoS Group";
          type uint8 {
            tailf:info "<1-99>;;QoS group";
            range "1..99";
          }
        }
      }
      container reassemble {
        tailf:info "reassemble packets";
        leaf transit {
          tailf:info "transit IPSEC packets";
          type empty;
        }
      }
    }
    container multicast {
      tailf:info "Configure multicast";
      container mgre {
        tailf:info "Multi-point GRE tunnel";
        leaf injection {
          tailf:info "Enable packet injection";
          type empty;
        }
      }
      container oce {
        tailf:info "multicast oce";
        container flag {
          tailf:info "multicast oce flag";
          leaf suppress {
            tailf:info "Enable oce flag suppress";
            type empty;
          }
        }
      }
    }
    container punt-keepalive {
      tailf:info "punt-keepalive messages";
      leaf disable-kernel-core {
        tailf:info "Disable IOSXE kernel core generation for keepalive fault";
        type boolean;
        tailf:cli-boolean-no;
      }
      container settings {
        tailf:info "Set the keepalive parameters";
        leaf fatal-count {
          tailf:info "Set punt-inject keepalive fatal count";
          type uint16 {
            tailf:info "<15-60>;;Number of timeouts until fatal error occurs";
            range "15..60";
          }
        }
        leaf transmit-interval {
          tailf:info "Set punt-inject keepalive transmit interval";
          type uint16 {
            tailf:info "<2-30>;;Interval between punt/inject keepalive "
              +"transmissions";
            range "2..30";
          }
        }
        leaf warning-count {
          tailf:info "Set punt-inject keepalive warning count";
          type uint16 {
            tailf:info "<10-60>;;Interval between punt/inject keepalive "
              +"timeout warnings";
            range "10..60";
          }
        }
      }
    }
    container punt-policer {
      tailf:info "Configures punt policers";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf cause {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-89>;;Punt cause to be policed";
          range "1..89";
        }
      }
      leaf max-rate {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<10-32000>;;max punt rate for cause MPLS ICMP Can't Frag";
          range "10..32000";
        }
      }
      leaf high {
        tailf:info "High priority traffic only";
        type empty;
      }
    }
    container qos {
      tailf:info "Platform specific qos configuration";
      leaf marker-statistics {
        tailf:info "Configure marking statistics";
        type empty;
      }
      container match-statistics {
        tailf:info "Configure match stats";
        leaf per-filter {
          tailf:info "Configure per-filter match statistics";
          type empty;
        }
      }
      leaf performance-monitor {
        tailf:info "Configure performance-monitor statistics";
        type empty;
      }
    }
    container reload {
      tailf:info "Platform specific reload command";
      leaf immediate {
        tailf:info "Immediately stop forwarding traffic";
        type empty;
      }
    }
    leaf shell {
      tailf:info "Control platform shell access command availability";
      type boolean;
      tailf:cli-boolean-no;
    }
  }


  /// ========================================================================
  /// hostname
  /// ========================================================================

  leaf hostname {
    tailf:info "Set system's network name";
    type string {
      tailf:info "This system's network name";
    }
  }


  /// ========================================================================
  /// enable
  /// ========================================================================

  container enable {
    tailf:info "Modify enable password parameters";

    // enable password
    container password {
      tailf:info "Assign the privileged level password (MAX of 25 characters)";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-reset-container;
      uses password-07-grouping;
    }

    // enable last-resort
    leaf last-resort {
      tailf:info "Define enable action if no TACACS servers respond";
      tailf:cli-full-command;
      type enumeration {
        enum password {
          tailf:info "Enable by giving the local enable password";
        }
        enum succeed {
          tailf:info "Enable without further question";
        }
      }
    }

    // enable secret
    container secret {
      tailf:info "Assign the privileged level secret";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf level {
        tailf:info "Set exec level password";
        tailf:cli-optional-in-sequence;
        type uint8 {
          tailf:info "<1-15>;;Level number";
        }
      }
      leaf "type" {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum "0" {
            tailf:info "Specifies an UNENCRYPTED password will follow";
          }
          enum "4" {
            //FIXME what type of secret is this?
          }
          enum "5" {
            tailf:info "Specifies an ENCRYPTED secret will follow";
          }
        }
      }
      leaf secret {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "LINE;;The UNENCRYPTED (cleartext) 'enable' secret";
        }
      }
    }

    // enable use-tacacs
    leaf use-tacacs {
      tailf:info "Use TACACS to check enable passwords";
      tailf:cli-full-command;
      type empty;
    }

  }


  /// ========================================================================
  /// archive
  /// ========================================================================

  container archive {
    tailf:info "Archive the configuration";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-archive";
    // archive log
    container log {
      tailf:info "Logging commands";
      container "config" {
        tailf:info "Logging changes to the running configuration";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-archive-log-cfg";
        leaf hidekeys {
          tailf:info "suppress output (e.g. passwords) when "+
            "displaying logged commands";
          type empty;
        }
      }
    }
  }


  /// ========================================================================
  /// username
  /// ========================================================================

  list username {
    tailf:info "Establish User Name Authentication";
    tailf:cli-suppress-mode;
    tailf:cli-delete-when-empty;
    tailf:cli-compact-syntax;
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;User name";
      }
    }

    //  access-class            Restrict access by access-class
    //  autocommand Automatically issue a command after the user logs in
    //  callback-dialstring     Callback dialstring
    //  callback-line           Associate a specific line with this callback
    //  callback-rotary         Associate a rotary group with this callback
    //  common-criteria-policy  Enter the common-criteria policy name
    //  dnis                    Do not require password when obtained via DNIS
    //  nocallback-verify       Do not require authentication after callback
    //  noescape                Prevent the user from using an escape character
    //  nohangup                Do not disconnect after an automatic command
    //  nopassword              No password is required for the user to log in

    // username * password
    container password {
      tailf:info "Specify the password for the user";
      tailf:cli-compact-syntax;
      tailf:cli-flatten-container;
      tailf:cli-sequence-commands;
      tailf:cli-reset-container;
      leaf "encryption" {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum "0" {
            tailf:info "Specifies an UNENCRYPTED password will follow";
          }
          enum "7" {
            tailf:info "Specifies a HIDDEN password will follow";
          }
        }
      }
      leaf "password" {
        tailf:cli-drop-node-name;
        tailf:cli-trim-default;
        type string {
          tailf:info "WORD;;The HIDDEN user password string";
        }
      }
    }

    // username * privilege
    leaf privilege {
      tailf:info "Set user privilege level";
      type uint8 {
        tailf:info "<0-15>;;User privilege level";
        range "0..15";
      }
    }

    // username * secret
    container secret {
      tailf:info "Specify the secret for the user";
      tailf:cli-compact-syntax;
      tailf:cli-flatten-container;
      tailf:cli-sequence-commands;
      tailf:cli-reset-container;
      leaf "encryption" {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum "0" {
            tailf:info "Specifies an UNENCRYPTED secret will follow";
          }
          enum "5" {
            tailf:info "Specifies a HIDDEN secret will follow";
          }
        }
      }
      leaf "secret" {
        tailf:cli-drop-node-name;
        tailf:cli-trim-default;
        type string {
          tailf:info "WORD;;The HIDDEN user secret string";
        }
      }
    }
    //  user-maxlinks           Limit the user's number of inbound links
    //  view                    Set view name
  }


  /// ========================================================================
  /// controller
  /// ========================================================================
  //!!FIXME: info strings

  list controller {
    tailf:info "Configure controller";
    tailf:cli-mode-name "config-controller";
    //FIXME: doublecheck syntax, not found in emulator
    key "name number";
    leaf name {
      type enumeration {
        tailf:info "Controller name";
        enum t1 {
        }
        enum e1 {
        }
        enum t3 {
        }
      }
    }
    leaf number {
      // Depending on device type:
      // slot/port
      // number
      // dial-shelf/slot/t3-port:t1-num
      // dial-shelf/slot/t3-port
      // slot/port-adapter/port
      type string;
    }

    // controller * / framing
    leaf framing {
      tailf:cli-full-command;
      type string;
    }

    // controller * / clock
    container clock {
      // controller * / clock source
      container source {
        choice source-choice {
          container line {
            presence true;
            leaf line-mode {
              tailf:cli-drop-node-name;
              tailf:cli-full-command;
              type enumeration {
                enum primary {
                }
                enum secondary {
                }
              }
            }
          }
          leaf internal {
            tailf:cli-full-command;
            type empty;
          }
          leaf loop-timed {
            tailf:cli-full-command;
            type empty;
          }
        }
      }
    }

    // controller * / linecode
    leaf linecode {
      tailf:cli-full-command;
      type enumeration {
        enum ami {  // Both (default for T1)
        }
        enum b8zs { // T1 only
        }
        enum hdb3 { // E1 only (default)
        }
      }
    }

    // controller * / cablelength
    container cablelength {
      choice cablelength-choice {
        leaf long {
          tailf:cli-full-command;
          type string;
        }
        leaf short {
          tailf:cli-full-command;
          type string;
        }
      }
    }

    // controller * / channel-group
    list channel-group {
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key number;
      leaf number {
        type uint8 {
          range "0..30";
        }
      }
      leaf-list timeslots {
        tailf:cli-replace-all;
        tailf:cli-range-list-syntax;
        type uint16;
      }
    }
  }


  /// ========================================================================
  /// vrf
  /// ========================================================================
  // Note: /vrf must be before /ip and /ipv6

  container vrf {
    tailf:info "VRF commands";

    // vrf definition *
    list definition {
      tailf:info "VRF definition mode";
      tailf:cli-full-command;
      tailf:cli-mode-name "config-vrf";
      key name;
      leaf name {
        tailf:info "WORD;;VRF name";
        type string;
      }
      // vrf definition * / description
      leaf "description" {
        tailf:info "VRF specific description";
        tailf:cli-multi-value;
        type string {
          tailf:info "LINE;;Up to 244 characters describing this VRF";
          length "1..244";
        }
      }
      // vrf definition * / rd
      leaf rd {
        tailf:info "Specify Route Distinguisher";
        tailf:cli-full-command;
        type union {
          type string {
            tailf:info "ASN:nn or IP-address:nn;;VPN Route Distinguisher";
            pattern "[0-9]+:[0-9]+";
          }
          type inet:ipv4-address;
        }
      }
      // vrf definition * / address-family
      container address-family {
        tailf:info "Enter Address Family command mode";
        // vrf definition * / address-family ipv4
        container ipv4 {
          tailf:info "Address family";
          tailf:cli-exit-command "exit-address-family";
          tailf:cli-add-mode;
          presence true;
          //  bgp                  Commands pertaining to BGP
          //  default              Set a command to its defaults
          container export {
            tailf:info "VRF export";
            tailf:cli-incomplete-command;
            leaf map {
              tailf:info "WORD;;Route-map reference";
              type string {
                //FIXME leafref: path "/ios:route-map/name";
              }
            }
          }
          //  import               VRF import
          //  inter-as-hybrid      Inter AS hybrid mode
          //  maximum              Set a limit
          // vrf definition * / address-family ipv4 mdt
          container mdt {
            tailf:info "Backbone Multicast Distribution Tree";
            container "default" {
              tailf:info "The default group";
              leaf address {
                tailf:cli-drop-node-name;
                tailf:cli-full-command;
                tailf:cli-remove-before-change;
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IP multicast group address";
                }
              }
              container mpls {
                tailf:info "MPLS tunnel options";
                leaf mldp {
                  tailf:info "Use a MLDP LSP to create the default MDT";
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;MP2MP LSP root address";
                  }
                }
              }
            }

            container data {
              tailf:info "MDT data trees";
              list multicast {
                tailf:cli-drop-node-name;
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                key "address wildcard";
                leaf address {
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;  IP multicast group address";
                  }
                }
                leaf wildcard {
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;Wildcard bits";
                  }
                }
              }
              leaf list {
                tailf:info "Access-list";
                type ext-acl-type;
                  }
              // mpls     MPLS tunnel options
              leaf threshold {
                tailf:info "MDT switching threshold";
                type uint32 {
                  tailf:info "<1-4294967>;;Traffic rate in kilobits per second";
                }
              }
            }
            leaf log-reuse {
              tailf:info "Event logging for data MDT reuse";
              type empty;
            }
            leaf-list preference {
              tailf:info "MDT preference (default pim mldp)";
              tailf:cli-flat-list-syntax {
                tailf:cli-replace-all;
              }
              type enumeration {
                enum mldp {
                  tailf:info "MDT preference mLDP";
                }
                enum pim {
                  tailf:info "MDT preference PIM";
                }
              }
            }
          } // mdt

          //  route-replicate      Replicate (import) routes..
          // ..from another topology (and another VRF)
          container route-target {
            tailf:info "Specify Target VPN Extended Communities";
            uses vrf-route-target-grouping;
          }

          //  snmp                 Modify snmp parameters
        }
        // vrf definition * / address-family ipv6
        container ipv6 {
          tailf:info "Address family";
          tailf:cli-exit-command "exit-address-family";
          tailf:cli-add-mode;
          presence true;
          //  default              Set a command to its defaults
          //  exit-address-family  Exit from vrf
          //                       address-family configuration submode
          //  export               VRF export
          //  import               VRF import
          //  inter-as-hybrid      Inter AS hybrid mode
          //  maximum              Set a limit
          //  route-target         Specify Target VPN Extended Communities
          container route-target {
            tailf:info "Specify Target VPN Extended Communities";
            uses vrf-route-target-grouping;
          }
          //  snmp                 Modify snmp parameters
        }
      }

      //  default         Set a command to its defaults

      // vrf definition * / route-target
      container route-target {
        tailf:info "Specify Target VPN Extended Communities";
        uses vrf-route-target-grouping;
      }

      //  vnet            Virtual NETworking configuration
      //  vpn             Configure VPN ID as specified in rfc2685
    }

    // list "list" {
    //   tailf:info "List of VRFs";
    //   key id;
    // }
    //  selection    selection criteria
    //  upgrade-cli  upgrade cli

  }


  /// ========================================================================
  /// ip
  /// ========================================================================

  container ip {
    tailf:info "Global IP configuration subcommands";

    // ip subnet-zero
    leaf subnet-zero {
      tailf:info "Allow 'subnet zero' subnets";
      type empty;
    }

    // ip vrf *
    list vrf {
      tailf:info "Configure an IP VPN Routing/Forwarding instance";
      tailf:cli-mode-name "config-vrf";
      key name;
      leaf name {
        tailf:info "WORD;;VPN Routing/Forwarding instance name";
        type string;
      }
      // ip vrf * / bgp
      container bgp {
        tailf:info "Commands pertaining to BGP";
        container next-hop {
          tailf:info "Next-hop for the routes of a VRF in the backbone";
          leaf Loopback {
            tailf:info "Loopback interface number";
            // FIXME: merge key and value, ie Loopback 3
            // should become Loopback3
            type uint32 {
              tailf:info "<0-2147483647>;;Loopback interface number";
              range "0..2147483647";
            }
          }
        }
      }
      // ip vrf * / context
      leaf context {
        tailf:info "Associate SNMP context with this vrf";
        type string {
          tailf:info "WORD;;SNMP Context Name";
        }
      }
      //FIXME: The 'default' command should be added as a clispec command
      // ip vrf * / description
      leaf "description" {
        tailf:info "VRF specific description";
        tailf:cli-multi-value;
        type string {
          length "1..244";
          tailf:info "LINE;;Up to 244 characters describing this VRF";
        }
      }
      // ip vrf * / export
      container export {
        tailf:info "VRF export";
        leaf map {
          tailf:info "Route-map based VRF export";
          type string {
            tailf:info "WORD;;VRF export route-map name";
          }
        }
      }
      // ip vrf * / import
      container "import" {
        // NOTE: needs special treatment when talking to backend
        // broken in real c7200 CLI
        tailf:info "VRF import";
        choice import-choice {
          leaf map {
            tailf:info "Route-map based VRF import";
            type string {
              tailf:info "WORD;;VRF import route-map name";
            }
          }
          container ipv4 {
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            tailf:info "Address family based VRF import";
            leaf ipv4-type {
              tailf:cli-drop-node-name;
              type enumeration {
                enum unicast {
                  tailf:code-name "ipv41_unicast";
                  tailf:info "Import prefixes from IPv4 "
                    +"Unicast table";
                }
                enum multicast {
                  tailf:code-name "ipv41_multicast";
                  tailf:info "Import prefixes from IPv4 "
                    +"Multicast tabl";
                }
              }
            }
            leaf upper-limit {
              tailf:cli-break-sequence-commands;
              tailf:cli-drop-node-name;
              type uint32 {
                range "1..2147483647";
                tailf:info "<1-2147483647>;;Upper limit"
                  +" on import prefixes without "
                  +"hogging memory";
              }
            }
            leaf map {
              tailf:info "Route-map based VRF import";
              type string {
                tailf:info "WORD;;VRF import route-map "
                  +"name";
              }
            }
          }
        }
      }
      // ip vrf * / maximum
      container maximum {
        tailf:info "Maximum number of routes allowed in this routing "
          +"table";
        tailf:cli-incomplete-command;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        presence "Maximum number of routes allowed in this routing "
          +"table";
        leaf routes {
          tailf:info "Maximum number of routes allowed in this "
            +"routing table";
          tailf:cli-incomplete-command;
          type uint32 {
            range "1..4294967295";
            tailf:info "<1-4294967295>;;Maximum number of routes "
              +"allowed";
          }
        }
        choice maximum-choice {
          mandatory true;
          case threshold-case {
            leaf threshold {
              tailf:cli-drop-node-name;
              tailf:info "";
              type uint16 {
                range "1..100";
                tailf:info "<1-100>;;Threshold value (%) at "
                  +"which to generate a warning msg";
              }
            }
            leaf reinstall {
              tailf:info "Reinstall previous rejected route due "
                +"to over maximum route limit";
              type uint16 {
                range "1..100";
                tailf:info "<1-100>;;Threshold value (%) at "
                  +"which to reinstall routes back to VRF";
              }
            }
          }
          case warning-case {
            leaf warning-only {
              tailf:info "Only give a warning message if is "
                +"limit exceeded";
              type empty;
            }
          }
        }
      }
      // ip vrf * / mdt
      container mdt {
        tailf:info "Backbone Multicast Distribution Tree";
        tailf:cli-incomplete-command;
        presence "Backbone Multicast Distribution Tree";
        leaf default {
          tailf:info "The default group";
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP multicast group address";
          }
        }
        leaf log-reuse {
          tailf:info "Event logging for data MDT reuse";
          type empty;
        }
        container data {
          tailf:info "MDT data group range";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-incomplete-command;
          leaf mulicast-address {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP multicast group address";
            }
          }
          leaf wildcard-bits {
            tailf:cli-drop-node-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Wildcard bits";
            }
          }
          choice mdt-data-choice {
            case mdt-data-threshold {
              leaf threshold {
                tailf:info "MDT switching threshold";
                type uint32 {
                  tailf:info "<1-4294967>;;Traffic rate in "
                    +"kilobits per second";
                  range "1..4294967";
                }
              }
              leaf threshold-list {
                tailf:alt-name "list";
                tailf:info "Access-list";
                type mdt-data-list-type;
              }
            }
            case mdt-data-list {
              leaf list {
                tailf:info "Access-list";
                type mdt-data-list-type;
              }
            }
          }
        }
      }
      // ip vrf * / rd
      leaf rd {
        tailf:info "Specify Route Distinguisher";
        type rd-type;
      }
      // ip vrf * / route-target
      list route-target {
        tailf:info "Specify Target VPN Extended Communities";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "direction target";
        // NOTE: the Cisco CLI does not require you to give
        // the direction, it will default to 'export' if not
        // given.
        leaf direction {
          type enumeration {
            enum "both" {
              tailf:info "Both import and export Target-VPN "
                +"community";
            }
            enum "export" {
              tailf:code-name "direction_export";
              tailf:info "Export Target-VPN community";
            }
            enum "import" {
              tailf:code-name "direction_import";
              tailf:info "Import Target-VPN community";
            }
          }
        }

        leaf target {
          type rd-type {
            tailf:info "ASN:nn or IP-address:nn;;Target VPN "
              +"Extended Community";
          }
        }
      }
      // ip vrf * / vpn
      container vpn {
        tailf:info "Configure VPN ID as specified in rfc2685";
        leaf id {
          tailf:info "Configure VPN ID in rfc2685 format";
          type vpn-id-type;
        }
      }
    }

    // ip multicast-routing
    container mcr-conf {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      leaf multicast-routing {
        tailf:info "Enable IP multicast forwarding";
        type empty;
      }
    }

    container multicast-routing {
      tailf:info "Enable IP multicast forwarding";
      tailf:cli-incomplete-no;
      tailf:cli-incomplete-command;
      tailf:cli-diff-dependency "/ios:ip/vrf";
      tailf:cli-diff-dependency "/ios:vrf/definition";
      tailf:cli-diff-dependency "../mcr-conf/multicast-routing";
      // ip multicast-routing vrf *
      list vrf {
        tailf:info "Select VPN Routing/Forwarding instance";
        tailf:cli-suppress-list-no;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-diff-dependency "../../mcr-conf/multicast-routing";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;VPN Routing/Forwarding instance name";
          }
        }
        leaf distributed {
          tailf:info "Distributed multicast switching";
          type empty;
        }
      }
      // ip multicast-routing distributed
      leaf distributed {
        tailf:info "Distributed multicast switching";
        tailf:cli-full-command;
        type empty;
      }
    }

    // ip as-path
    container as-path {
      tailf:info "BGP autonomous system path filter";
      // ip as-path access-list *
      list access-list {
        tailf:info "Specify an access list number";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        tailf:cli-compact-syntax;
        key name;
        leaf name {
          tailf:cli-incomplete-command;
          type uint16 {
            range "1..500";
            tailf:info "<1-500>;;AS path access list number";
          }
        }
        list as-path-rule {
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-drop-node-name;
          tailf:cli-compact-syntax;
          tailf:cli-show-long-obu-diffs;
          ordered-by user;
          key "operation rule";
          leaf operation {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type enumeration {
              enum deny {
                tailf:code-name "operation_deny";
                tailf:info "Specify packets to reject";
              }
              enum permit {
                tailf:code-name "operation_permit";
                tailf:info "Specify packets to forward";
              }
            }
          }
          leaf rule {
            tailf:cli-drop-node-name;
            tailf:cli-multi-value;
            tailf:cli-full-command;
            type string {
              tailf:info "LINE;;A regular-expression to match"+
                " BGP AS paths.";
            }
          }
        }
      }
    }

    // ip local
    container local {
      tailf:info "Specify local options";
      // ip local pool *
      list pool {
        tailf:info "IP Local address pool lists";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key id;
        leaf id {
          type union {
            type string {
              tailf:info "WORD;;Create named local address pool";
            }
            type enumeration {
              enum "default" {
                tailf:info "Create default local address pool";
              }
            }
          }
        }
        leaf start {
          tailf:cli-drop-node-name;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;First IP address of range";
          }
        }
        leaf last {
          tailf:cli-drop-node-name;
          tailf:cli-optional-in-sequence;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Last IP address of range";
          }
        }
        leaf group {
          tailf:info "Create ip local pool group";
          type string {
            tailf:info "WORD;;Group name for this named local address pool";
          }
        }
      }
    }

    // ip cef
    container cef {
      tailf:info "Cisco Express Forwarding";
      presence true;
      leaf distributed {
        tailf:info "Distributed Cisco Express Forwarding";
        tailf:cli-full-command;
        type empty;
      }
      //accounting          Enable CEF accounting
      //event-log           CEF event log commands
      //load-sharing        Load sharing
      //table               Set CEF forwarding table characteristics
      //traffic-statistics  Enable collection of traffic statistics
    }

    // ip classless
    leaf classless {
      tailf:info "Follow classless routing forwarding rules";
      type empty;
    }

    // ip community-list
    container community-list {
      tailf:info "Add a community list entry";
      // FIXME: in the GW case we need special treatment of 'no'
      // For example, no ip community-list 1 deny internet will
      // actually delete the community-list 1 instance.
      list number-standard {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key no;
        leaf no {
          type uint16 {
            range "1..99";
            tailf:info "<1-99>;;Community list number (standard)";
          }
        }
        uses ip-community-list-standard-grouping;
      }
      list number-expanded {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key no;
        leaf no {
          type uint16 {
            range "100..500";
            tailf:info "<100-500>;;Community list number "
              +"(expanded)";
          }
        }
        uses ip-community-list-expanded-grouping;
      }
      list expanded {
        tailf:info "Add an expanded community-list entry";
        tailf:cli-incomplete-command;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Community list name";
          }
        }
        uses ip-community-list-expanded-grouping;
      }
      list standard {
        tailf:info "Add a standard community-list entry";
        tailf:cli-incomplete-command;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Community list name";
          }
        }
        uses ip-community-list-standard-grouping;
      }
    }

    //FIXME: investigate ip domain-lookup vs ip domain lookup
    // ip domain
    container domain {
      tailf:info "IP DNS Resolver";
      leaf "list" {
        tailf:info "Domain name to complete unqualified host names";
        type string {
          tailf:info "WORD;;A domain name";
        }
      }

      // ip domain lookup
      leaf lookup {
        tailf:info "Enable IP Domain Name System hostname translation";
        tailf:cli-boolean-no;
        tailf:cli-trim-default;
        type boolean;
        default true;
      }
      container lookup-settings {
        tailf:cli-drop-node-name;
        container lookup {
          tailf:info "Enable IP Domain Name System hostname translation";
          leaf nsap {
            tailf:info "Enable IP DNS queries for CLNS NSAP addresses";
            tailf:cli-full-command;
            type empty;
          }
          container source-interface {
            tailf:info "Specify source interface for DNS resolver";
            tailf:cli-diff-dependency "/ios:interface";
            uses interface-grouping;
          }
        }
        leaf name {
          tailf:info "Define the default domain name";
          type string {
            tailf:info "WORD;;Default domain name";
          }
        }
      }
      // ip domain name
      leaf name {
        tailf:info "Define the default domain name";
        type string {
          tailf:info "WORD;;Default domain name";
        }
      }
    }

    // ip domain-lookup
    container domain-lookup {
      tailf:info "Enable IP Domain Name System hostname translation";
      tailf:cli-show-no;
      presence true;
      leaf nsap {
        tailf:info "Enable IP DNS queries for CLNS NSAP addresses";
        type empty;
      }
      container source-interface {
        tailf:info "Specify source interface for DNS resolver";
        tailf:cli-diff-dependency "/ios:interface";
        uses interface-grouping;
      }
    }

    // ip domain-name
    leaf domain-name {
      tailf:info "Define the default domain name";
      type string {
        tailf:info "WORD;;Default domain name";
      }
    }

    // ip dns
    container dns {
      tailf:info "Configure DNS server for a zone";
      // ip dns server
      container server {
        tailf:info "Enable DNS server";
        presence true;
      }
    }

    // ip default-gateway
    leaf default-gateway {
      tailf:info "Specify default gateway (if not routing IP)";
      type inet:ipv4-address {
        tailf:info "A.B.C.D;;IP address of default gateway";
      }
    }

    // ip dhcp
    container dhcp {
      tailf:info "Configure DHCP server and relay parameters";
      // ip dhcp class *
      list class {
        tailf:info "Configure DHCP classes";
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;Class name";
          }
        }
        // ip dhcp class * / relay
        container relay {
          tailf:info "Enter relay agent information option configuration "
            +"submode";
          container agent {
            tailf:info "Enter relay agent information option configuration "
              +"submode";
            leaf information {
              tailf:info "Enter relay agent information option configuration "
                +"submode";
              type empty;
            }
          }
        }
        // ip dhcp class * / remark
        leaf remark {
          tailf:info "Specify a remark for this class";
          tailf:cli-multi-value;
          type string {
            tailf:info "LINE;;Up to 240 characters describing this class";
            length "1..240";
          }
        }
      }

      //  compatibility              Compatibility configuration
      //  conflict                   DHCP address conflict parameters
      //  database                   Configure DHCP database agents
      //  excluded-address        Prevent DHCP from assigning certain addresses
      //  limit                      Limit DHCP Lease
      //  limited-broadcast-address  Use all 1's broadcast address
      //  ping                       Specify ping parameters used by DHCP

      // ip dhcp pool *
      list pool {
        tailf:info "Configure DHCP address pools";
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;Pool name";
          }
        }
        //  accounting           Send Accounting Start/Stop messages
        //  bootfile             Boot file name
        //  class                Specify a DHCP class
        //  client-identifier    Client identifier
        //  client-name          Client name
        //  default-router       Default routers
        //  dns-server           DNS servers
        //  domain-name          Domain name
        //  exit                 Exit from DHCP pool configuration mode
        //  hardware-address     Client hardware address
        //  host                 Client IP address and mask
        //  lease                Address lease time
        //  netbios-name-server  NetBIOS (WINS) name servers
        //  netbios-node-type    NetBIOS node type
        //  network              Network number and mask
        //  next-server          Next server in boot process
        //  no                   Negate a command or set its defaults
        //  option               Raw DHCP options
        //  origin               Configure the origin of the pool
        //  relay                Function as a DHCP relay
        //  renew                Configure renewal policy
        //  server               Configure the server ID option value
        //  subnet               Subnet allocation commands
        //  update               Dynamic updates
        //  utilization          Configure various utilization parameters
        //  vrf                  Associate this pool with a VRF
      }

      //  relay                      DHCP relay agent parameters
      //  route  Specify the type of routes for clients on unnumbered interfaces

      // ip dhcp smart-relay
      leaf smart-relay {
        tailf:info "Enable Smart Relay feature";
        type empty;
      }

      // ip dhcp snooping
      container snooping {
        tailf:info "DHCP Snooping";
        presence true;
        tailf:cli-display-separated;
        //  database     DHCP snooping database agent
        container information {
          tailf:info "DHCP Snooping information";
          container option {
            tailf:info "DHCP Snooping information option";
            presence true;
            leaf allow-untrusted {
              tailf:info "DHCP Snooping information option allow-untrusted";
              type empty;
            }
            container format {
              tailf:info "Option 82 information format";
              container remote-id {
                tailf:info "Remote id option 82 format";
                choice remote-id-choice {
                  leaf hostname {
                    tailf:info "Use configured hostname for remote id";
                    type empty;
                  }
                  leaf string {
                    tailf:info "User defined string for remote id";
                    type string {
                      tailf:info "WORD;;Use string for remote id (max length "
                        +"63)";
                    }
                  }
                }
              }
            }
          }
        }
        container track {
          tailf:info "DHCP snooping track";
          leaf host {
            tailf:info "DHCP snooping track host";
            type empty;
          }
        }
        container verify {
          tailf:info "DHCP snooping verify";
          leaf mac-address {
            tailf:info "DHCP snooping verify mac-address";
            type empty;
          }
          leaf no-relay-agent-address {
            tailf:info "DHCP snooping verify giaddr";
            type empty;
          }
        }
        leaf-list vlan {
          tailf:info "DHCP Snooping vlan";
          type uint16 {
            tailf:info "WORD;;DHCP Snooping vlan fist number or vlan range, "
              +"example: 1,3-5,7,9-11";
          }
        }
      }
      //  use        Configure use of certain parameters during allocation
    }

    // ip flow-cache
    container flow-cache {
      tailf:info "Configure netflow cache parameters";
      container timeout {
        tailf:info "Specify flow cache timeout parameters";
        leaf active {
          tailf:info "Specify the active flow timeout";
          type uint16 {
            tailf:info "<1-60>;;Timeout in minutes";
            range "1..60";
          }
        }
      }
    }

    // ip flow-export
    container flow-export {
      tailf:info "Specify host/port to send flow statistics";
      // ip flow-export destination
      container destination  {
        tailf:info "Specify the Destination IP address";
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        tailf:cli-compact-syntax;
        leaf ip {
          tailf:cli-drop-node-name;
          type host-type {
            tailf:info "Hostname or A.B.C.D  Destination IP address";
          }
        }
        leaf port {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-65535>;;UDP port number";
            range "1..65535";
          }
        }
      }
      // ip flow-export source
      container source {
        tailf:info "Specify the interface for source address";
        tailf:cli-diff-dependency "/ios:interface";
        uses interface-grouping;
      }
      //template     Specify the template specific configurations
      // ip flow-export version
      leaf version {
        tailf:info "Specify the version number";
        type enumeration {
          enum 1;
          enum 5;
          enum 9;
        }
      }
    }

    // ip forward-protocol
    container forward-protocol {
      tailf:info "Controls forwarding of physical and directed IP broadcasts";
      choice protocol-choice {
        leaf protocol {
          tailf:cli-drop-node-name;
          type enumeration {
            enum nd {
              tailf:info "Sun's Network Disk protocol";
            }
            enum sdns {
              tailf:info "Network Security Protocol";
            }
            enum turbo-flood {
              tailf:info "Fast flooding of UDP broadcasts";
            }
          }
        }
        container spanning-tree {
          tailf:info "Use transparent bridging to flood UDP broadcasts";
          presence true;
          leaf any-local-broadcast {
            tailf:info "Accept any local broadcast when flooding";
            type empty;
          }
        }
        leaf udp {
          tailf:info "Packets to a specific UDP port";
          type string; //FIXME
        }
      }
    }

    // ip ftp
    container ftp {
      tailf:info "FTP configuration commands";
      container source-interface {
        tailf:info "Specify interface for source address in"+
          " FTP connections";
        tailf:cli-diff-dependency "/ios:interface";
        uses interface-grouping;
      }
      leaf passive {
        tailf:info "Connect using passive mode";
        type empty;
      }
      container password {
        tailf:info "Specify password for FTP connections;";
        uses password-grouping;
      }
      leaf username {
        tailf:info "Specify username for FTP connections";
        type string;
      }
    }

    // ip telnet
    container telnet {
      tailf:info "Specify telnet options";
      leaf source-interface {
        tailf:info "Specify source interface";
        type string;
      }
    }

    // ip http
    container http {
      tailf:info "HTTP server configuration";
      leaf access-class {
        tailf:info "Restrict http server access by access-class";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<1-99>;;Access list number";
          range "1..99";
        }
      }
      // ip http authentication
      container authentication {
        tailf:info "Set http server authentication method";
        choice authentication-choice {
          // ip http authentication aaa
          leaf aaa {
            tailf:info "Use AAA access control methods";
            tailf:cli-full-command;
            type empty;
          }
          // ip http authentication local
          leaf local {
            tailf:info "Use local username and passwords";
            tailf:cli-full-command;
            type empty;
          }
        }
      }
      // ip http server
      leaf server {
        tailf:info "Enable http server";
        tailf:cli-boolean-no;
        tailf:cli-show-with-default;
        tailf:cli-full-command;
        type boolean;
        // Note: default varies on different devices
      }
      // ip http secure-server
      leaf secure-server {
        tailf:info "Enable HTTP secure server";
        tailf:cli-boolean-no;
        tailf:cli-show-with-default;
        tailf:cli-full-command;
        type boolean;
        default false;
      }
      container timeout-policy {
        tailf:info "Set http server time-out policy parameters";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-sequence-commands;
        leaf idle {
          tailf:info "Idle time-out of a http server connection in seconds";
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<1-600>;;Connection idle time-out value in seconds";
            range "1..600";
          }
        }
        leaf life {
          tailf:info "Life time of a http server connection in seconds";
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<1-86400>;;Connection life time value in seconds";
            range "1..86400";
          }
        }
        leaf requests {
          tailf:info "Maximum number of requests allowed on a http server "+
            "connection";
          type uint32 {
            tailf:info "<1-86400>;;Maximum number of requests allowed on a "+
              "http server connection";
            range "1..86400";
          }
        }
      }
      container client {
        tailf:info "Set http client parameters";
        tailf:cli-incomplete-command;
        leaf source-interface {
          tailf:cli-full-command;
          tailf:cli-multi-value;
          tailf:info "Specify interface for source address in all "
          +"HTTP(S) client connections";
          type string {
            tailf:info "WORD;;Interface name";
          }
        }
      }
    }

    // ip igmp
    container igmp {
      tailf:info "IGMP global configuration";
      container snooping {
        tailf:info "Global IGMP Snooping enable for Catalyst Vlans";
        presence true;
        leaf l2-entry-limit {
          tailf:info "limit on the l2 entry that can be installed by IGMP "
          +"snooping";
          type uint32 {
            tailf:info "<1-100000>;;maximum number of l2 entries";
            range "1..100000";
          }
        }
      }
    }

    // ip multicast
    container multicast {
      tailf:info "Global IP Multicast Commands";
      leaf multipath {
        tailf:info "RPF across equal-cost paths";
        type empty;
      }
    }

    // ip nat
    container nat {
      tailf:info "NAT configuration commands";
      tailf:cli-diff-dependency "/ios:ip/vrf";
      tailf:cli-diff-dependency "/ios:vrf/definition";
      tailf:cli-diff-dependency "/ios:vrf/definition/address-family";

      // ip nat pool *
      list pool {
        tailf:info "Define pool of addresses";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;Pool name";
          }
        }
        leaf start-address {
          tailf:cli-drop-node-name;
          tailf:cli-optional-in-sequence;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Start IP address";
          }
        }
        leaf end-address {
          tailf:cli-drop-node-name;
          when "../start-address" {
            tailf:dependency "../start-address";
          }
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;End IP address";
          }
        }
        choice prefix-choice {
          leaf netmask {
            tailf:info "Specify the network mask";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Network mask";
            }
          }
          leaf prefix-length {
            tailf:info "Specify the prefix length";
            type uint8 {
              tailf:info "<1-32>;;Prefix length";
              range "1..32";
            }
          }
        }
        leaf accounting {
          tailf:cli-optional-in-sequence;
          tailf:info "Specify the accounting";
          type string {
            tailf:info "WORD;;Accounting method-list name";
          }
        }
        choice nat-choice {
          leaf arp-ping {
            tailf:info "WLAN ARP Ping";
            type empty;
          }
          leaf "type" {
            tailf:info "Specify the pool type";
            type enumeration {
              enum match-host {
                tailf:info "Keep host numbers the same after translation";
              }
              enum rotary {
                tailf:info "Rotary address pool";
              }
            }
          }
          leaf add-route {
            tailf:info "Add special route to Virtual Interface";
            type empty;
          }
        }
      }

      // ip nat inside
      container inside {
        tailf:info "Inside address translation";

        // ip nat inside source
        container source {
          tailf:info "Source address translation";
          // ip nat inside source list *
          list "list" {
            tailf:info "Specify access list describing local addresses";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-all-siblings;
            }
            tailf:cli-incomplete-command;
            key id;
            leaf id {
              type union {
                type uint16 {
                  tailf:info "<1-2699>;;Access list number for global "
                    +"addresses";
                  range "1..2699";
                }
                type string {
                  tailf:info "WORD;;Access list name for global addresses";
                }
              }
            }
            choice pool-or-interface {
              // ip nat inside source list * pool
              case pool-choice {
                leaf pool {
                  tailf:info "Name pool of global addresses";
                  type string;
                  tailf:non-strict-leafref {
                    path "/ios:ip/nat/pool/id";
                  }
                }
                // [ redundancy <rg-id> ]
                leaf redundancy {
                  tailf:info "NAT redundancy operation";
                  tailf:cli-optional-in-sequence;
                  type uint8 {
                    tailf:info "<1-2>;;IP redundancy ID";
                    range "1..2";
                  }
                }
                // [ mapping-id <map-id> ]
                leaf mapping-id {
                  tailf:info "Associate a mapping id to this mapping";
                  tailf:cli-optional-in-sequence;
                  type uint32 {
                    tailf:info "<1-2147483647>;;Stateful NAT mapping id";
                    range "1..2147483647";
                  }
                }
              }
              // ip nat inside source list * interface
              case interface-choice {
                container interface {
                  tailf:info "Specify interface for global address";
                  tailf:cli-compact-syntax;
                  tailf:cli-flatten-container;
                  uses interface-grouping;
                }
              }
            }
            // [no-payload]
            leaf no-payload {
              tailf:info "No translation of embedded address/port in the "+
                "payload";
              tailf:cli-optional-in-sequence;
              type empty;
            }
            // [reversible]
            leaf reversible {
              tailf:cli-optional-in-sequence;
              type empty;
            }
            // [ vrf name [match-in-vrf] ]
            leaf vrf {
              tailf:info "Specify vrf";
              tailf:cli-optional-in-sequence;
              type string {
                tailf:info "WORD;;vrf name";
              }
            }
            leaf match-in-vrf {
              when "../vrf";
              tailf:info "Match incoming vrf";
              tailf:cli-optional-in-sequence;
              type empty;
            }
            // [overload]
            leaf overload {
              //tailf:cli-break-sequence-commands;
              tailf:info "Overload an address translation";
              tailf:cli-optional-in-sequence;
              type empty;
            }
            // [oer]
            leaf oer {
              tailf:info "Use with vtemplate only. On new translation, "+
                "if OER BR is UP, OER will select IP from outgoing Interface."+
                " All packets matching translation are forwarded over "+
                "Interface for duration of translation.";
              type empty;
            }
            // [ portmap name ]
          }
          // ip nat inside source static
          container static {
            tailf:info "Specify static local->global mapping";
            list nat-static-transport-list {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              key "proto local-ip local-port global-ip global-port";
              leaf proto {
                type enumeration {
                  enum tcp {
                    tailf:info "Transmission Control Protocol";
                  }
                  enum udp {
                    tailf:info "User Datagram Protocol";
                  }
                }
              }
              leaf local-ip {
                tailf:cli-drop-node-name;
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Inside local IP address";
                }
              }
              leaf local-port {
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<1-65535>;;Local UDP/TCP port";
                  range "1..65535";
                }
              }
              leaf global-ip {
                tailf:cli-drop-node-name;
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Inside global IP address";
                }
              }
              leaf global-port {
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<1-65535>;;Global UDP/TCP port";
                  range "1..65535";
                }
              }
              // [extendable]
              leaf extendable {
                tailf:info "Extend this translation when used";
                tailf:cli-optional-in-sequence;
                type empty;
              }
              // [no-alias]
              leaf no-alias {
                tailf:info "Do not create an alias for the global address";
                tailf:cli-optional-in-sequence;
                type empty;
              }
              // [no-payload]
              leaf no-payload {
                tailf:info "No translation of embedded address/port in the "+
                  "payload";
                tailf:cli-optional-in-sequence;
                type empty;
              }
              //TODO: [ route-map name [reversible] ]
              leaf route-map {
                tailf:info "Specify route-map";
                tailf:cli-optional-in-sequence;
                type string {
                  tailf:info "WORD;;Route-map name";
                }
              }
              leaf reversible {
                when "../route-map";
                tailf:cli-optional-in-sequence;
                type empty;
              }
              //[ redundancy { group-name | rg-id mapping-id mapping-id } ]
              leaf redundancy {
                tailf:info "NAT redundancy operation";
                tailf:cli-optional-in-sequence;
                type union {
                  type uint8 {
                    tailf:info "<1-2>;IP redundancy ID";
                  }
                  type string {
                    tailf:info "WORD;;IP redundancy name";
                  }
                }
              }
              leaf mapping-id {
                when "../redundancy";
                tailf:info "Associate a mapping id to this mapping";
                tailf:cli-optional-in-sequence;
                type uint32 {
                  tailf:info "<1-2147483647>;;Stateful NAT mapping id";
                  range "1..2147483647";
                }
              }
              // [ vrf name [match-in-vrf] ]
              leaf vrf {
                tailf:info "Specify vrf";
                tailf:cli-optional-in-sequence;
                type string {
                  tailf:info "WORD;;vrf name";
                }
              }
              leaf match-in-vrf {
                when "../vrf";
                tailf:info "Match incoming vrf";
                tailf:cli-optional-in-sequence;
                type empty;
              }
              // [forced]
              leaf forced {
                tailf:info "Delete this entry and its children, "+
                  "even if in use";
                tailf:cli-optional-in-sequence;
                type empty;
              }
              //?? overload
              leaf overload {
                tailf:info "Overload an address translation";
                type empty;
              }
            }
            list nat-static-transport-interface-list {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              tailf:cli-incomplete-command;
              key "proto local-ip local-port";
              leaf proto {
                type enumeration {
                  enum tcp {
                    tailf:info "Transmission Control Protocol";
                  }
                  enum udp {
                    tailf:info "User Datagram Protocol";
                  }
                }
              }
              leaf local-ip {
                tailf:cli-drop-node-name;
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Inside local IP address";
                }
              }
              leaf local-port {
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<1-65535>;;Local UDP/TCP port";
                  range "1..65535";
                }
              }
              container interface {
                tailf:info "Specify interface for global address";
                tailf:cli-compact-syntax;
                tailf:cli-flatten-container;
                uses interface-grouping;
              }
              leaf global-port {
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<1-65535>;;Global UDP/TCP port";
                  range "1..65535";
                }
              }
            }
          }
        }

        // ip nat inside destination
        container destination {
          tailf:info "Destination address translation";
          // ip nat inside destination list *
          list "list" {
            tailf:info "Specify access list describing global addresses";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            tailf:cli-incomplete-command;
            key id;
            leaf id {
              type union {
                type uint16 {
                  tailf:info "<1-2699>;;Access list number for global "
                    +"addresses";
                  range "1..2699";
                }
                type string {
                  tailf:info "WORD;;Access list name for global addresses";
                }
              }
            }
            // ip nat inside destination list * pool *
            leaf pool {
              tailf:info "Name pool of local addresses";
              type string;
              tailf:non-strict-leafref {
                path "/ios:ip/nat/pool/id";
              }
            }
            // [ redundancy redundancy-id ]
            leaf redundancy {
              tailf:info "NAT redundancy operation";
              tailf:cli-optional-in-sequence;
              type uint8 {
                tailf:info "<1-2>;;IP redundancy ID";
                range "1..2";
              }
            }
            // [ mapping-id map-id ]
            leaf mapping-id {
              tailf:info "Associate a mapping id to this mapping";
              type uint32 {
                tailf:info "<1-2147483647>;;Stateful NAT mapping id";
                range "1..2147483647";
              }
            }
          }
        }
      }

      // ip nat outside
      container outside {
        tailf:info "Outside address translation";
        list "list" {
          tailf:info "Specify access list describing global addresses";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          key id;
          leaf id {
            type union {
              type uint16 {
                tailf:info "<1-2699>;;Access list number for global "
                  +"addresses";
                range "1..2699";
              }
              type string {
                tailf:info "WORD;;Access list name for global addresses";
              }
            }
          }
          leaf pool {
            tailf:info "Name pool of local addresses";
            type string;
            tailf:non-strict-leafref {
              path "/ios:ip/nat/pool/id";
            }
          }
          leaf mapping-id {
            tailf:info "Associate a mapping id to this mapping";
            tailf:cli-optional-in-sequence;
            type uint32 {
              tailf:info "<1-2147483647>;;Stateful NAT mapping id";
              range "1..2147483647";
            }
          }
          leaf vrf {
            tailf:info "Specify vrf";
            tailf:cli-optional-in-sequence;
            type string {
              tailf:info "WORD;;vrf name";
            }
          }
          leaf add-route {
            tailf:info "Add a static route for outside local address";
            type empty;
          }
        }
        list route-map {
          tailf:info "Specify route-map";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          key id;
          leaf id {
            type string {
              tailf:info "WORD;;Route-map name";
            }
          }
          leaf pool {
            tailf:info "Name pool of local addresses";
            type string;
            tailf:non-strict-leafref {
              path "/ios:ip/nat/pool/id";
            }
          }
          leaf mapping-id {
            tailf:info "Associate a mapping id to this mapping";
            tailf:cli-optional-in-sequence;
            type uint32 {
              tailf:info "<1-2147483647>;;Stateful NAT mapping id";
              range "1..2147483647";
            }
          }
          leaf vrf {
            tailf:info "Specify vrf";
            tailf:cli-optional-in-sequence;
            type string {
              tailf:info "WORD;;vrf name";
            }
          }
          leaf add-route {
            tailf:info "Add a static route for outside local address";
            type empty;
          }
        }
      }
    }

    // ip name-server
    leaf-list name-server {
      tailf:info "Specify address of name server to use";
      tailf:cli-flat-list-syntax;
      type union {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Domain server IP address (maximum of 6)";
        }
        type inet:ipv6-address {
          tailf:info "X:X:X:X::X;;Domain server IPv6 address (maximum of 6)";
        }
      }
    }

    // ip pim
    container pim {
      tailf:info "PIM global commands";
      tailf:cli-diff-dependency "/ios:ip/vrf";
      tailf:cli-diff-dependency "/ios:vrf/definition";
      tailf:cli-diff-dependency "/ios:vrf/definition/address-family";

      // ip pim ssm
      container ssm {
        tailf:info "Configure Source Specific Multicast";
        leaf "range" {
          type union {
            type uint16 {
              tailf:info "<1-99>;;Access list number";
              range "1..99";
            }
            type string {
              tailf:info "WORD;;IP named access list";
              pattern '[a-zA-Z].*';
            }
          }
        }
      }

      // ip pim vrf *
      list vrf {
        tailf:info "Select VPN Routing/Forwarding instance";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;VPN Routing/Forwarding instance name";
          }
        }
        container rp-address {
          tailf:info "PIM RP-address (Rendezvous Point)";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf address {
            tailf:cli-drop-node-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP address of Rendezvous-point for group";
            }
          }
          leaf access-list {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            type union {
              type uint16 {
                tailf:info "<1-99>;;Access-list reference for group";
                range "1..99";
              }
              type uint16 {
                tailf:info "<1300-1999>;;Access-list reference for group ("
                  +"expanded range)";
                range "1300..1999";
              }
              type string {
                tailf:info "WORD;;IP Named Standard Access list";
              }
            }
          }
          leaf override {
            tailf:info "Overrides dynamically learnt RP mappings";
            type empty;
          }
        }
      }
    }

    // ip prefix-list
    container prefix-list {
      tailf:info "Build a prefix list";

      // ip prefix-list *
      list prefixes {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of a prefix list";
            pattern '([^s].*)|(s[^e].*)|(se[^q].*)'
            +'(seq[^u].*)|(sequ[^e].*)|(seque[^n].*)|'
            +'(sequen[^c].*)|(sequenc[^e].*)|(sequence'
            +'[^\-].*)|(sequence\-[^n].*)|(sequence\-n'
            +'[^u].*)|(sequence\-nu[^m].*)|(sequence\-'
            +'num[^b].*)|(sequence\-numb[^e].*)|'
            +'(sequence\-numbe[^r].*)|(sequence\-number..*)';
          }
        }

        // ip prefix-list * description
        leaf "description" {
          tailf:info "Prefix-list specific description";
          tailf:cli-multi-value;
          tailf:cli-full-command;
          type string {
            tailf:info "LINE;;Up to 80 characters describing this prefix-list";
            length "1..80";
          }
        }

        // ip prefix-list * permit
        leaf permit {
          tailf:info "Specify packets to forward";
          type ios:ipv4-prefix {
            tailf:info "A.B.C.D  IP prefix <network>/<length>, "+
              "e.g., 35.0.0.0/8";
          }
        }

        // ip prefix-list * seq *
        list seq {
          // NOTE: the seq element is not actually mandatory
          // in the Cisco CLI. If it isn't give
          tailf:info "sequence number of an entry";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key no;
          leaf no {
            type uint32 {
              range "1..4294967294";
              tailf:info "<1-4294967294>;;Sequence number";
            }
            tailf:key-default "10";
          }

          // ip prefix-list * seq * deny
          container deny {
            tailf:info "Specify packets to reject";
            tailf:cli-sequence-commands {
              tailf:cli-reset-all-siblings;
            }
            tailf:cli-compact-syntax;
            leaf ip {
              tailf:cli-drop-node-name;
              type ios:ipv4-prefix {
                tailf:info "A.B.C.D;;IP prefix <network>/"
                +"<length>, e.g., 35.0.0.0/8";
              }
            }
            leaf ge {
              tailf:info "Minimum prefix length to be matched";
              tailf:cli-break-sequence-commands;
              type uint8 {
                range "1..32";
                tailf:info "<1-32>;;Minimum prefix length";
              }
            }
            leaf le {
              tailf:info "Maximum prefix length to be matched";
              tailf:cli-full-command;
              type uint8 {
                range "1..32";
                tailf:info "<1-32>;;Maximum prefix length";
              }
            }
          }

          // ip prefix-list * seq * permit
          container permit {
            tailf:info "Specify packets to forward";
            tailf:cli-sequence-commands {
              tailf:cli-reset-all-siblings;
            }
            tailf:cli-compact-syntax;
            leaf ip {
              tailf:cli-drop-node-name;
              type ios:ipv4-prefix {
                tailf:info "A.B.C.D;;IP prefix <network>/"
                +"<length>, e.g., 35.0.0.0/8";
              }
            }
            leaf ge {
              tailf:info "Minimum prefix length to be matched";
              tailf:cli-break-sequence-commands;
              type uint8 {
                range "1..32";
                tailf:info "<1-32>;;Minimum prefix length";
              }
            }
            leaf le {
              tailf:info "Maximum prefix length to be matched";
              tailf:cli-full-command;
              type uint8 {
                range "1..32";
                tailf:info "<1-32>;;Maximum prefix length";
              }
            }
          }
        }
      }

      // ip prefix-list sequence-number
      leaf sequence-number {
        tailf:info "Include/exclude sequence numbers in NVGEN";
        tailf:cli-full-command;
        type empty;
      }
    }

    // ip route
    container route {
      tailf:info "Establish static routes";

      // ip route ?
      uses ip-route-grouping;

      // ip route profile
      leaf profile {
        tailf:info "Enable IP routing table profile";
        tailf:cli-full-command;
        type empty;
      }

      // ip route static
      container static {
        tailf:info "Allow static routes";
        leaf adjust-time {
          tailf:info "Time period for adjusting static routes";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<1-60>;;Adjustment time in seconds";
            range "1..60";
          }
        }
        leaf inter-vrf {
          tailf:info "Across VRF interfaces";
          tailf:cli-full-command;
          type empty;
        }
      }

      // ip route vrf *
      list vrf {
        tailf:info "Configure static route for a VPN Routing/Forwarding "+
        "instance";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-incomplete-command;
        tailf:cli-diff-dependency "/ios:ip/vrf";
        tailf:cli-diff-dependency "/ios:vrf/definition";
        tailf:cli-diff-dependency "/ios:vrf/definition/address-family";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;VPN Routing/Forwarding instance name";
          }
        }
        uses ip-route-grouping;
      }
    }

    // ip routing
    leaf routing {
      tailf:info "Enable IP routing";
      tailf:cli-full-command;
      type empty;
    }

    // ip scp
    container scp {
      tailf:info "Scp commands";
      container server {
        tailf:info "Configure SCP server-side functionality";
        leaf enable {
          tailf:info "Enable server side of SCP";
          type empty;
        }
      }
    }

    // ip sla
    container sla {
      tailf:info "IP Service Level Agreement";
      // ip sla enable
      container enable {
        //FIXME: info
        leaf reaction-alerts {
          type empty;
        }
      }
      // ip sla responder
      leaf responder {
        type empty;
      }
    }

    // ip bootp
    container bootp {
      tailf:info "Config BOOTP services";
      leaf server {
        tailf:info "Enable BOOTP server";
        tailf:cli-boolean-no;
        tailf:cli-trim-default;
        type boolean;
        default true;
      }
    }

    // ip source-route
    leaf source-route {
      tailf:info "Process packets with source routing header options";
      tailf:cli-boolean-no;
      tailf:cli-show-with-default;
      tailf:cli-full-command;
      type boolean;
      default true;
    }

    // ip ssh
    container ssh {
      tailf:info "Configure ssh options";
      leaf authentication-retries {
        tailf:info "Specify number of authentication retries";
        type uint8 {
          tailf:info "<0-5>;;Number of authentication retries";
          range "0..5";
        }
      }
      leaf dscp {
        tailf:info "IP DSCP value for SSH traffic";
        type uint8 {
          tailf:info "<0-63>;;ip dscp value (default value 0 )";
          range "0..63";
        }
      }
      container logging {
        tailf:info "Configure logging for SSH";
        leaf events {
          tailf:info "Log SSH events";
          type empty;
        }
      }
      leaf precedence {
        tailf:info "IP Precedence value for SSH traffic";
        type uint8 {
          tailf:info "<0-7>;;ip precedence value (default value 0 )";
          range "0..7";
        }
      }
      //  source-interface Specify interface for source address in
      //  SSH connections
      leaf time-out {
        tailf:info "Specify SSH time-out interval";
        type uint8 {
          tailf:info "<1-120>;;SSH time-out interval (secs)";
          range "1..120";
        }
      }
      leaf version {
        tailf:info "Specify protocol version supported";
        type uint8 {
          tailf:info "<1-2>;;Protocol version";
          range "1..2";
        }
      }
    }

    // ip tacacs
    container tacacs {
      tailf:info "TACACS configuration commands";
      container source-interface {
        tailf:info "Specify interface for source address in "+
        "TACACS packets";
        tailf:cli-diff-dependency "/ios:interface";
        uses interface-grouping;
      }
    }

    // ip tcp
    container tcp {
      tailf:info "Global TCP parameters";
      container path-mtu-discovery {
        tailf:info "Enable path-MTU discovery on new TCP connections";
        presence true;
        leaf age-timer {
          tailf:info "Set PMTU aging timer";
          type union {
            type enumeration {
              enum "infinite" {
                tailf:info "Disable pathmtu aging timer";
              }
            }
            type uint8 {
              tailf:info "<10-30>;;Aging time";
              range "10..30";
            }
          }
        }
      }
    }

    // ip tftp
    container tftp {
      tailf:info "tftp configuration commands";
      container boot-interface {
        tailf:info "Force interface to use for TFTP booting";
        tailf:cli-diff-dependency "/ios:interface";
        uses interface-grouping;
      }
      container source-interface {
        tailf:info "Specify interface for source address in"+
        " TFTP connections";
        tailf:cli-diff-dependency "/ios:interface";
        uses interface-grouping;
      }
    }

    // ip access-list
    container access-list {
      tailf:info "Named access list";
      tailf:cli-incomplete-command;
      tailf:cli-compact-syntax;

      // ip access-list standard *
      container standard {
        tailf:info "Standard Access List";
        tailf:cli-incomplete-command;
        list std-named-acl {
          tailf:cli-drop-node-name;
          tailf:cli-full-command;
          tailf:cli-no-key-completion;
          tailf:cli-mode-name "config-std-nacl";
          key name;
          leaf name {
            type std-acl-type;
          }
          list std-access-list-rule {
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-drop-node-name;
            tailf:cli-compact-syntax;
            tailf:cli-show-long-obu-diffs;
            ordered-by user;
            key rule;
            leaf rule {
              tailf:cli-drop-node-name;
              tailf:cli-multi-word-key;
              type string {
                pattern "(deny.*)|(permit.*)|(remark.*)|(no.*)";
                tailf:info "deny;;Specify packets to reject\n"+
                "permit;;Specify packets to forwards\n"+
                "remark;;Access list entry comment";
              }
            }
          }
        }
      }

      //  ip access-list extended *
      container extended {
        tailf:info "Extended Access List";
        tailf:cli-incomplete-command;
        list ext-named-acl {
          tailf:cli-drop-node-name;
          tailf:cli-full-command;
          tailf:cli-mode-name "config-std-nacl";
          key name;
          leaf name {
            tailf:info "WORD;;Access-list name";
            type string;
          }
          list ext-access-list-rule {
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-drop-node-name;
            tailf:cli-compact-syntax;
            tailf:cli-show-long-obu-diffs;
            ordered-by user;
            key rule;
            leaf rule {
              tailf:cli-drop-node-name;
              tailf:cli-multi-word-key;
              type string {
                pattern "(permit.*)|(deny.*)|(no.*)|(remark.*)";
                tailf:info "deny;;Specify packets to reject\n"+
                "permit;;Specify packets to forwards\n"+
                "remark;;Access list entry comment";
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// vmps
  /// ========================================================================

  container vmps {
    tailf:info "VMPS settings";

    // vmps reconfirm
    leaf reconfirm {
      tailf:info "Set VMPS reconfirm interval";
      type uint8 {
        tailf:info "Number of minutes between reconfirmations";
        range "0..120";
      }
    }

    // vmps retry
    leaf retry {
      tailf:info "Set VMPS retry count";
      type uint8 {
        tailf:info "<1-10>;;Retry count per server";
        range "1..10";
      }
    }

    // vmps server *
    list server {
      tailf:info "Configure server IP address";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key name;
      leaf name {
        type host-type {
          tailf:info "Hostname or A.B.C.D;;IP address";
        }
      }
      // vmps server * primary
      leaf primary {
        tailf:info "Specify primary server";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// ipv6
  /// ========================================================================

  container ipv6 {
    tailf:info "Global IPv6 configuration commands";

    container access-list {
      tailf:info "Configure access lists";
      tailf:cli-incomplete-command;
      tailf:cli-compact-syntax;

      // ipv6 access-list *
      list named-acl {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        tailf:cli-no-key-completion;
        tailf:cli-mode-name "config-ipv6-acl";
        key name;
        leaf name {
          type string {
            tailf:info "User selected string identifying this access list";
          }
        }
        list access-list-rule {
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-drop-node-name;
          tailf:cli-compact-syntax;
          tailf:cli-show-long-obu-diffs;
          ordered-by user;
          key rule;
          leaf rule {
            tailf:cli-drop-node-name;
            tailf:cli-multi-word-key;
            type string {
              pattern "(deny.*)|(permit.*)|(remark.*)|(no.*)";
              tailf:info "deny;;Specify packets to reject\n"+
              "permit;;Specify packets to forwards\n"+
              "remark;;Access list entry comment";
            }
          }
        }
      }
    }

    // ipv6 unicast-routing
    leaf unicast-routing {
      tailf:info "Enable unicast routing";
      type empty;
    }

    // ipv6 multicast
    container multicast {
      tailf:info "Configure multicast related commands";
      //  group-range         Enable/disable multicasting for selected
      //                      group ranges
      //  limit               Configure global multicast limit
      //  multipath           RPF across equal-cost paths
      //  pim-passive-enable  Enable PIM Passive feature
      container rpf {
        tailf:info "Configure multicast RPF related commands";
        container backoff {
          tailf:info "Backoff delay after unicast routing change";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf initial-delay {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<200-65535>;;Initial RPF backoff delay in "
                +"milliseconds";
              range "200..65535";
            }
          }
          leaf max-delay {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<200-65535>;;Maximum RPF backoff delay in "
                +"milliseconds";
              range "200..65535";
            }
          }
        }
        leaf use-bgp {
          tailf:info "Use BGP routes for multicast RPF lookup";
          type empty;
        }

      }
    }

    // ipv6 cef
    container cef {
      tailf:info "Cisco Express Forwarding";
      tailf:cli-delete-when-empty;
      //tailf:cli-diff-dependency "/ios:ipv6/unicast-routing";
      //must "../unicast-routing" { tailf:dependency "."; }
      presence true;
      container accounting {
        tailf:info "Enable CEF accounting";
        leaf per-prefix {
          tailf:info "Enable per prefix accounting";
          type empty;
        }
        leaf prefix-length {
          tailf:info "Enable prefix length accounting";
          type empty;
        }
      }
      leaf distributed {
        tailf:info "Distributed Cisco Express Forwarding";
        tailf:cli-full-command;
        type empty;
      }
    }

    // dhcp               Configure IPv6 DHCP
    // flow-aggregation   Configure flow aggregation
    // flow-cache         Configure netflow cache parameters
    // flow-capture       Capture additional netflow information
    // flow-export        Specify host/port to send flow statistics
    // general-prefix     Configure a general IPv6 prefix
    // hop-limit          Configure hop count limit
    // host               Configure static hostnames
    // icmp               Configure ICMP parameters
    // inspect            Context-based Access Control Engine
    // local              Specify local options
    // mfib               Multicast Forwarding
    // mobile             Mobile IPv6
    // multicast-routing  Enable IPv6 multicast
    // nat                NAT-PT Configuration commands
    // neighbor           Neighbor
    // ospf               OSPF
    // pim                Configure Protocol Independent Multicast
    // port-map  Port to application mapping (PAM) configuration commands

    // ipv6 route
    container route {
      tailf:info "Configure static routes";

      // ipv6 route prefix
      uses ipv6-route-grouping;

      // ipv6 route vrf *
      list vrf {
        tailf:info "Configure static route for a VPN Routing/Forwarding "+
        "instance";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-incomplete-command;
        tailf:cli-diff-dependency "/ios:vrf/definition";
        tailf:cli-diff-dependency "/ios:vrf/definition/address-family";
        //tailf:cli-diff-dependency "/ios:ip/vrf";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;VRF name";
          }
        }
        uses ipv6-route-grouping;
      }
    }

    // router             Enable an IPV6 routing process
    // source-route       Process packets with source routing header options

    // ipv6 prefix-list
    container prefix-list {
      tailf:info "Build a prefix list";
      list prefixes {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of a prefix list";
            pattern '([^s].*)|(s[^e].*)|(se[^q].*)'
            +'(seq[^u].*)|(sequ[^e].*)|(seque[^n].*)|'
            +'(sequen[^c].*)|(sequenc[^e].*)|(sequence'
            +'[^\-].*)|(sequence\-[^n].*)|(sequence\-n'
            +'[^u].*)|(sequence\-nu[^m].*)|(sequence\-'
            +'num[^b].*)|(sequence\-numb[^e].*)|'
            +'(sequence\-numbe[^r].*)|(sequence\-number..*)';
          }
        }
        leaf description {
          tailf:info "Prefix-list specific description";
          tailf:cli-multi-value;
          tailf:cli-full-command;
          type string {
            length "1..80";
            tailf:info "LINE;;Up to 80 characters describing this "
            +"prefix-list";
          }
        }
        leaf permit {
          tailf:info "Specify packets to forward";
          type ios:ipv6-prefix {
            tailf:info "X:X:X:X::X/<0-128>  IPv6 prefix"
            +"<network>/<length>";
          }
        }
        list seq {
          // NOTE: the seq element is not actually mandatory
          // in the Cisco CLI. If it isn't give
          tailf:info "sequence number of an entry";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key no;
          leaf no {
            type uint32 {
              range "1..4294967294";
              tailf:info "<1-4294967294>;;Sequence number";
            }
            tailf:key-default "10";
          }
          container deny {
            tailf:info "Specify packets to reject";
            tailf:cli-sequence-commands {
              tailf:cli-reset-all-siblings;
            }
            tailf:cli-compact-syntax;
            leaf ip {
              tailf:cli-drop-node-name;
              type ios:ipv6-prefix {
                tailf:info "X:X:X:X::X/<0-128>  IPv6 prefix"
                +"<network>/<length>";
              }
            }
            leaf ge {
              tailf:info "Minimum prefix length to be matched";
              tailf:cli-break-sequence-commands;
              type uint16 {
                range "1..128";
                tailf:info "<1-128>;;Minimum prefix length";
              }
            }
            leaf le {
              tailf:info "Maximum prefix length to be matched";
              tailf:cli-full-command;
              type uint16 {
                range "1..128";
                tailf:info "<1-128>;;Maximum prefix length";
              }
            }
          }
          container permit {
            tailf:info "Specify packets to forward";
            tailf:cli-sequence-commands {
              tailf:cli-reset-all-siblings;
            }
            tailf:cli-compact-syntax;
            leaf ip {
              tailf:cli-drop-node-name;
              type ios:ipv6-prefix {
                tailf:info "X:X:X:X::X/<0-128>  IPv6 prefix"
                +"<network>/<length>";
              }
            }
            leaf ge {
              tailf:info "Minimum prefix length to be matched";
              tailf:cli-break-sequence-commands;
              type uint16 {
                range "1..128";
                tailf:info "<1-128>;;Minimum prefix length";
              }
            }
            leaf le {
              tailf:info "Maximum prefix length to be matched";
              tailf:cli-full-command;
              type uint16 {
                range "1..128";
                tailf:info "<1-128>;;Maximum prefix length";
              }
            }
          }
        }
      }
      leaf sequence-number {
        tailf:info "Include/exclude sequence numbers in NVGEN";
        tailf:cli-full-command;
        type empty;
      }
    }

  }


  /// ========================================================================
  /// vlan
  /// ========================================================================

  container vlan {
    tailf:info "VLAN commands";

    // vlan accounting
    container accounting {
      tailf:info "VLAN accounting configuration";
    }

    // vlan internal
    container internal {
      tailf:info "internal VLAN";
      container allocation {
        tailf:info "internal VLAN allocation";
        leaf policy {
          type enumeration {
            enum ascending {
              tailf:info "Allocates internal VLANs from 1006 to 4094";
            }
            enum descending {
              tailf:info "Allocates internal VLANs from 4094 to 1006.";
            }
          }
        }
      }
    }

    // vlan dot1q
    container dot1q {
      tailf:info "dot1q parameters";
      container tag {
        tailf:info "tag parameters";
        leaf native {
          tailf:info "tag native vlan";
          type empty;
        }
      }
    }

    // vlan access-log
    container access-log {
      tailf:info "Configure VACL logging";
      leaf maxflow {
        tailf:info "Set vacl logging maximum flow number";
        type uint16 {
          tailf:info "<0-2048>;;Maximum flow number";
          range "0..2048";
        }
      }
      leaf ratelimit {
        tailf:info "Set vacl logging rate limiter";
        type uint16 {
          tailf:info "<10-5000>;;Maximum number of packets logged per second";
          range "10..5000";
        }
      }
      leaf threshold {
        tailf:info "Set vacl log-update threshold";
        type uint32 {
          tailf:info "<0-2147483647>;;log-update threshold (number of hits)";
          range "0..2147483647";
        }
      }
    }

    // vlan <id>
    list vlan-list {
      tailf:cli-drop-node-name;
      tailf:cli-mode-name "config-vlan";
      tailf:cli-range-list-syntax;
      key id;
      leaf id {
        type uint16 {
          range "1..4094";
          tailf:info "<1-3967,4048-4094>;;VLAN ID 1-4094 or "
            +"range(s): 1-5, 10 or 2-5,7-19";
        }
      }
      leaf name {
        tailf:info "Ascii name of the VLAN";
        tailf:cli-full-command;
        tailf:cli-multi-value;
        type string {
          length "1..32";
          tailf:info "The ascii name for the VLAN (Max Size 32)";
        }
      }
      leaf uni-vlan {
        tailf:info "Configure a UNI VLAN";
        tailf:cli-full-command;
        type enumeration {
          enum community {
            tailf:info "UNI/ENI community VLAN";
          }
          enum isolated {
            tailf:info "UNI/ENI isolated VLAN";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// interface
  /// ========================================================================

  container interface {
    tailf:info "Configure interfaces";
    tailf:cli-diff-dependency "/ios:vrf";
    tailf:cli-explicit-exit;

    // interface Embedded-Service-Engine
    list Embedded-Service-Engine {
      tailf:info "cisco embedded service engine module";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      // tailf:cli-full-command;
      key name;
      leaf name {
        type string {
          tailf:info "<0-2>/<0-0>;;Embedded-Service-Engine interface number";
        }
      }
      uses interface-common-grouping;
    }

    // interface FastEthernet
    list FastEthernet {
      tailf:info "FastEthernet IEEE 802.3";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      // tailf:cli-full-command;
      key name;
      leaf name {
        type string {
          //pattern "([0-9])+(/([0-9])+)*";
          tailf:info "<0-66>/<0-128>;;FastEthernet interface number";
        }
      }
      uses interface-ethernet-grouping;
      uses interface-common-grouping;
      uses interface-zone-member-grouping;
      uses interface-switch-grouping; //CATALYST
    }

    // interface GigabitEthernet
    list GigabitEthernet {
      tailf:info "GigabitEthernet IEEE 802.3z";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      // tailf:cli-full-command;
      key name;
      leaf name {
        type string {
          //pattern "([0-9])+(/([0-9])+)*";
          tailf:info "<0-66>/<0-128>;;"+
            "GigabitEthernet interface number";
        }
      }
      leaf media-type {
        tailf:info "Media type";
        type enumeration {
          enum rj45 {
            tailf:info "Copper";
          }
          enum sfp {
            tailf:info "Fiber";
          }
        }
      }
      leaf port-type {
        //FIXME: tailf:info
        //FIXME: 3600 only?
        type enumeration {
          enum nni;
        }
      }
      uses interface-ethernet-grouping;
      uses interface-common-grouping;
      uses interface-zone-member-grouping;
      uses interface-switch-grouping; //CATALYST
    }

    // interface TenGigabitEthernet
    list TenGigabitEthernet {
      tailf:info "Ten Gigabit Ethernet";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      // tailf:cli-full-command;
      key name;
      leaf name {
        type string {
          //pattern "([0-9])+(/([0-9])+)*";
          tailf:info "<0-66>/<0-128>;;"+
            "TenGigabitEthernet interface number";
        }
      }
      leaf media-type {
        tailf:info "Media type";
        type enumeration {
          enum rj45 {
            tailf:info "Copper";
          }
          enum sfp {
            tailf:info "Fiber";
          }
        }
      }
      leaf port-type {
        //FIXME: tailf:info
        //FIXME: 3600 only?
        type enumeration {
          enum nni;
        }
      }
      uses interface-ethernet-grouping;
      uses interface-common-grouping;
      uses interface-zone-member-grouping;
      uses interface-switch-grouping; //CATALYST
    }

    // interface Loopback
    list Loopback {
      tailf:info "Loopback interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      // tailf:cli-full-command;
      key name;
      leaf name {
        type string {
          // pattern "([0-9])+/([0-9])+(/([0-9])+)?";
          tailf:info "<0-2147483647>;;Loopback interface number";
        }
      }
      uses interface-common-grouping;
    }

    // interface Port-channel
    list Port-channel {
      tailf:info "Ethernet Channel of interfaces";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      // tailf:cli-full-command;
      key name;
      leaf name {
        type uint32 {
          tailf:info "<1-512>;;Port-channel interface number";
          range "1..512";
        }
      }
      leaf speed {
        tailf:info "Configure speed operation.";
        type enumeration {
          enum "10" {
            tailf:info "Force 10 Mbps operation";
          }
          enum "100" {
            tailf:info "Force 100 Mbps operation";
          }
          enum "1000" {
            tailf:info "Enable AUTO speed configuration";
          }
          enum "nonegotiate" {
            //FIXME
          }
          enum "auto" {
            tailf:info "Enable AUTO speed configuration";
          }
        }
      }
      uses interface-common-grouping;
      uses interface-switch-grouping; //CATALYST
    }

    // interface Vlan
    list Vlan {
      tailf:info "Catalyst Vlans";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      key name;
      leaf name {
        type uint16 {
          tailf:info "<1-4094>;;Vlan interface number";
          range "1..4094";
        }
      }
      uses interface-common-grouping;
      uses interface-zone-member-grouping;
    }

    // interface Group-Async
    list Group-Async {
      tailf:info "Async Group interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      key name;
      leaf name {
        type uint16 {
          tailf:info "<0-64>;;Group-Async interface number";
          range "0..64";
        }
      }
      leaf physical-layer {
        tailf:info "Configure sync or async physical layer on serial "+
          "interface";
        type enumeration {
          enum async {
            tailf:info "Configure asynchronous physical layer on serial "
              +"interface";
          }
          enum sync {
            tailf:info "Configure synchronous physical layer on serial "+
              "interface";
          }
        }
      }
      uses interface-common-grouping;
    }

    // interface Multilink
    list Multilink {
      tailf:info "Multilink-group interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-full-command;
      key name;
      leaf name {
        type uint16 {
          tailf:info "<1-65535>;;Multilink interface number";
          range "1..65535";
        }
      }
      uses interface-common-grouping;
      uses interface-pointtopoint-grouping;
    }

    // interface Serial
    list Serial {
      tailf:info "Serial interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-full-command;
      key name;
      leaf name {
        type string {
          //FIXME: info + syntax
        }
      }
      uses interface-common-grouping;
      uses interface-pointtopoint-grouping;
    }

    // interface Virtual-Template
    list Virtual-Template {
      tailf:info "Virtual Template interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-full-command;
      tailf:cli-explicit-exit;
      key name;
      leaf name {
        type uint16 {
          tailf:info "<1-4095>;;Virtual-Template interface number";
          range "1..4095";
        }
      }
      uses interface-ethernet-grouping;
      uses interface-common-grouping;
      uses interface-zone-member-grouping;
      uses interface-switch-grouping; //CATALYST
      uses interface-pointtopoint-grouping;
    }
  }


  /// ========================================================================
  /// route-map
  /// ========================================================================

  list route-map {
    tailf:info "Route map tag";
    tailf:cli-mode-name "config-route-map";
    tailf:cli-compact-syntax;
    tailf:cli-full-command;
    key "name sequence" ;
    leaf name {
      tailf:info "WORD;;Route map tag";
      type string;
    }
    // route-map * #
    leaf sequence {
      tailf:cli-drop-node-name;
      type uint16 {
        tailf:info "<0-65535>;;Sequence to insert to/delete from "
          +"existing route-map entry";
        range "0..65535";
      }
    }
    // route-map * permit
    // route-map * deny
    leaf operation {
      tailf:cli-drop-node-name;
      tailf:cli-prefix-key {
        tailf:cli-before-key 2;
      }
      type enumeration {
        enum deny {
          tailf:code-name "op_deny";
          tailf:info "Route map denies set operations";
        }
        enum permit {
          tailf:code-name "op_internet";
          tailf:info "Route map permits set operations";
        }
      }
      default permit;
    }

    // route-map * / set
    container set {
      tailf:info "Set values in destination routing protocol";
      // route-map * / set as-path
      container as-path {
        tailf:info "Prepend string for a BGP AS-path attribute";
        container prepend {
          tailf:info "Prepend to the as-path";
          container as-container {
            tailf:cli-drop-node-name;
            leaf as-number {
              tailf:info "<1-65535>;;AS number";
              tailf:cli-drop-node-name;
              tailf:cli-multi-value;
              type string {
                tailf:info "<1-65535>;;AS number";
              }
            }
          }
          container last-as-cont {
            tailf:cli-drop-node-name;
            leaf last-as {
              type uint16 {
                tailf:info "<1..10>;;number of last-AS prepends";
                range "1..10";
              }
            }
          }
        }
        container tag {
          tailf:info "Set the tag as an AS-path attribute";
          tailf:cli-full-command;
          presence "tag";
        }
      }
      // route-map * / set community
      container community {
        tailf:info "BGP community attribute";
        choice community-choice {
          case community-numberi-case {
            leaf community-number {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<1-4294967295>;;community number";
                range "1..4294967295";
              }
            }

            leaf community-number-alt-format {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "aa:nn;;community number in aa:nn format";
                pattern "(\d+:\d+)";
              }
            }
          }
          case well-known-community-case {
            leaf well-known-communities {
              tailf:cli-drop-node-name;
              type enumeration {
                enum internet {
                  tailf:info "Internet (well-known community)";
                }
                enum local-AS {
                  tailf:info "Do not send outside local AS "
                    +"(well-known community)";
                }
                enum no-advertise {
                  tailf:info "Do not advertise to any peer "
                    +"(well-known community)";
                }
                enum no-export {
                  tailf:info "Do not export to next AS "
                    +"(well-known community)";
                }
                enum none {
                  tailf:info "No community attribute";
                }
              }
            }
          }
        }
        leaf additive {
          tailf:info "Add to the existing community";
          type empty;
        }
      }
      // route-map * / set comm-list
      container comm-list {
        tailf:info "set BGP community list (for deletion)";
        tailf:cli-sequence-commands;
        choice comm-list-choice {
          leaf comm-list-standard {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<1-99>;;Community-list number (standard)";
              range "1..99";
            }
          }
          leaf comm-list-expanded {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<100-500>;;Community-list number (expanded)";
              range "100..500";
            }
          }
          leaf comm-list-name {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type string {
              tailf:info "WORD;;Community-list name";
            }
          }
        }
        leaf delete {
          tailf:cli-full-command;
          tailf:info "Delete matching communities";
          type empty;
        }
      }
      // route-map * / set extcommunity
      container extcommunity {
        tailf:info "BGP extended community attribute";
        leaf-list rt {
          tailf:info "Route Target extended community";
          tailf:cli-flat-list-syntax;
          type asn-ip-type {
            tailf:info "ASN:nn or IP-address:nn;;VPN extended community";
          }
        }
      }
      // route-map * / set ip
      container ip {
        tailf:info "IP specific information";
        container next-hop {
          tailf:info "Next hop address";
          choice next-hop-choice {
            leaf-list address {
              tailf:cli-drop-node-name;
              tailf:cli-flat-list-syntax;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IP address of next hop";
              }
            }
            container dynamic {
              tailf:info "application dynamically sets next hop";
              leaf dhcp {
                tailf:info "DHCP learned next hop";
                type empty;
              }
            }
            leaf peer-address {
              tailf:info "Use peer address (for BGP only)";
              type empty;
            }
          }
        }
      }
      // route-map * / set metric
      leaf metric {
        tailf:info "Metric value for destination routing protocol";
        type string {
          tailf:info "+/-<metric>;;Add or subtract metric
          <0-4294967295>;;Metric value or Bandwidth in Kbits per second";
          pattern '[+-]?[0-9].*';
        }
      }
      // route-map * / set metric-type
      leaf metric-type {
        tailf:info "Type of metric for destination routing protocol";
        type enumeration {
          enum external {
            tailf:info "IS-IS external metric";
          }
          enum internal {
            tailf:info "IS-IS internal metric or Use IGP metric "
              +"as the MED for BGP";
          }
          enum type-1 {
            tailf:info "OSPF external type 1 metric";
          }
          enum type-2 {
            tailf:info "OSPF external type 2 metric";
          }
        }
      }
      // route-map * / set weight
      leaf weight {
        tailf:info "BGP weight for routing table";
        type uint32 {
          tailf:info "<0-65535>;;Weight value";
          range "0..65535";
        }
      }
      // route-map * / set origin
      container origin {
        tailf:info "BGP origin code";
        choice origin-choice {
          leaf origin-value {
            tailf:cli-drop-node-name;
            type enumeration {
              enum igp {
                tailf:info "local IGP";
              }
              enum incomplete {
                tailf:info "unknown heritage";
              }
            }
          }
          leaf egp {
                tailf:info "remote EGP";
            type uint32 {
              tailf:info "<0-65535>;;remote AS";
              range "0..65535";
            }
          }
        }
      }
    }

    // route-map * / match
    container match {
      tailf:info "Match values from routing table";
      container community {
        tailf:info "Match BGP community list";
        leaf-list name {
          tailf:info "Named Access List";
          tailf:cli-drop-node-name;
          tailf:cli-flat-list-syntax;
          type string {
            tailf:info "<1-99>       Community-list number (standard)
            <100-500>       Community-list number (expanded)
            WORD            Community-list name
            exact-match     Do exact matching of communities
            ";
          }
        }
      }

      container ip {
        tailf:info "IP specific information";
        container address {
          tailf:info "Match address of route or match packet";
          choice address-choice {
            leaf access-list {
              tailf:cli-drop-node-name;
              type exp-acl-type;
            }
            leaf prefix-list {
              tailf:info "Match entries of prefix-lists";
              type string;
              tailf:non-strict-leafref {
                path "/ios:ip/prefix-list/prefixes/name";
              }
            }
          }
        }
      }

      container ipv6 {
        tailf:info "IPv6 specific information";
        //next-hop
        //route-source
        container address {
          tailf:info "Match address of route";
          choice address-choice {
            leaf access-list {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "WORD;;IPv6 access-list name";
                pattern '[a-zA-Z].*';
              }
            }

            leaf prefix-list {
              tailf:info "IPv6 prefix-list";
              type string;
              tailf:non-strict-leafref {
                path "/ios:ipv6/prefix-list/prefixes/name";
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// authentication
  /// ========================================================================

  container authentication {
    //FIXME: info+syntax
    //FIXME: 3600 only

    container mac-move {
      leaf permit {
        type empty;
      }
    }
  }


  /// ========================================================================
  /// banner
  /// ========================================================================

  container banner {
    //FIXME: 'c' delimiter support (in java code)
    tailf:info "Define a login banner";
    container exec {
      tailf:info "Set EXEC process creation banner";
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-compact-syntax;

      leaf start-marker {
        tailf:cli-drop-node-name;
        type string;
      }

      leaf message {
        tailf:cli-drop-node-name;
        type string;
      }

      leaf end-marker {
        tailf:cli-drop-node-name;
        type string;
        must "../end-marker = ../start-marker" {
          tailf:dependency "../start-marker";
        }
      }
    }
    container login {
      tailf:info "Set login banner";
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-compact-syntax;

      leaf start-marker {
        tailf:cli-drop-node-name;
        type string;
      }

      leaf message {
        tailf:cli-drop-node-name;
        type string;
      }

      leaf end-marker {
        tailf:cli-drop-node-name;
        type string;
        must "../end-marker = ../start-marker" {
          tailf:dependency "../start-marker";
        }
      }
    }
    container prompt-timeout {
      tailf:info "Set Message for login authentication timeout";
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-compact-syntax;

      leaf start-marker {
        tailf:cli-drop-node-name;
        type string;
      }

      leaf message {
        tailf:cli-drop-node-name;
        type string;
      }

      leaf end-marker {
        tailf:cli-drop-node-name;
        type string;
        must "../end-marker = ../start-marker" {
          tailf:dependency "../start-marker";
        }
      }
    }
    container motd {
      tailf:info "Set Message of the Day banner";
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-compact-syntax;

      leaf start-marker {
        tailf:cli-drop-node-name;
        type string;
      }

      leaf message {
        tailf:cli-drop-node-name;
        type string;
      }

      leaf end-marker {
        tailf:cli-drop-node-name;
        type string;
        must "../end-marker = ../start-marker" {
          tailf:dependency "../start-marker";
        }
      }
    }
  }


  /// ========================================================================
  /// table-map
  /// ========================================================================
  // Note: Must come before policer aggregate

  list table-map {
    tailf:info "Configure Table Map";
    tailf:cli-mode-name "config-tablemap";
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;table-map name";
      }
    }

    // table-map * / default
    leaf default {
      tailf:info "the default behavior for setting value not found in the "+
        "table map";
      type union {
        type uint8 {
          tailf:info "tablemap default value";
          range "0..63";
        }
        type enumeration {
          enum copy {
            tailf:info "set the default behavior for value not found in "+
              "the table map to copy";
          }
          enum ignore {
            tailf:info "set the default behavior for value not found in "+
              "the table map to ignore";
          }
        }
      }
    }

    // table-map * / map from * to *
    list map {
      tailf:info "map to_value from from_value";
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key "from to";
      leaf from {
        tailf:info "map from value";
        tailf:cli-expose-key-name;
        type uint8 {
          tailf:info "<0-63>;;tablemap from value";
          range "0..63";
        }
      }
      leaf to {
        tailf:info "map to value";
        tailf:cli-expose-key-name;
        type uint8 {
          tailf:info "<0-63>;;tablemap to value";
          range "0..63";
        }
      }
    }
  }


  /// ========================================================================
  /// mls
  /// ========================================================================
  // Note: must come before class-map and policy-map.

  container mls {
    tailf:info "mls global commands";
    tailf:cli-incomplete-no;

    // mls acl
    container acl {
      tailf:info "MLS ACL operation";
      // mls acl tcam
      container tcam {
        tailf:info "ACL TCAM";
        leaf default-result {
          tailf:info "Default result to be used during tcam programming";
          type enumeration {
            enum bridge {
              tailf:info "Bridge result";
            }
            enum deny {
              tailf:info "Deny result";
            }
            enum permit {
              tailf:info "Permit result";
            }
          }
        }
        container log-update {
          tailf:info "Log TCAM updates";
          presence true;
          leaf rate-limit-msg {
            tailf:info "Enable/Disable syslog ratelimiting";
            type enumeration {
              enum disable {
                tailf:info "Disable ratelimiting syslog";
              }
              enum enable {
                tailf:info "Enable syslog ratelimiting at 1 per second";
              }
            }
          }
        }
        leaf share-global {
          tailf:info "share global deny or permit any entries";
          tailf:cli-boolean-no;
          tailf:cli-trim-default;
          type boolean;
          default true;
        }
      }
    }

    //  aging       L3 aging

    // mls cef
    container cef {
      tailf:info "cef keyword";
      container error {
        leaf action {
          type enumeration {
            enum reset;
          }
        }
      }
      //  maximum-routes  Configure route allocation for protocols
      //  tunnel          Allow tunnel fragmentation
    }
    //  erm         FIB Exception Recovery Manager
    //  exclude     exclude keyword

    // mls flow
    container flow {
      tailf:info "flowmask keyword";
      leaf ip {
        tailf:info "flowmask ip keyword";
        type enumeration {
          enum interface-destination {
            tailf:info "interface-destination flow keyword";
          }
          enum interface-destination-source {
            tailf:info "interface-destination-source flow keyword";
          }
          enum interface-full {
            tailf:info "interface-full flow keyword";
          }
          enum interface-source {
            tailf:info "interface-source only flow keyword";
          }
        }
      }
    }

    // mls ip
    container ip {
      tailf:info "ip keyword";
      //  cef        cef keyword
      //  inspect    inspect

      // mls ip multicast
      container multicast {
        tailf:info "multicast keyword";
        tailf:cli-display-separated;
        presence true;
        //  bidir              Bidir commands
        //  connected          Enable download of interface/mask entry
        container consistency-check {
          tailf:info "Set consistency checking characteristics";
          presence true;
          leaf settle-time {
            tailf:info "Settle time for entry/oif for consistancy-checker";
            type uint16 {
              tailf:info "<2-3600>;;Settle time for entry/oif in seconds";
              range "2..3600";
            }
          }
          //  type         Set consistency checker type
        }
        //  egress             Set egress replication options
        leaf flow-stat-timer {
          tailf:info "timer for flow statistic used by mls-msc and mlsm";
          type uint8 {
            tailf:info "<1-100>;;#seconds between one batch and another";
            range "1..100";
          }
        }
        //  met-optimization   Enable or disable met optimisation
        //  non-rpf            Enable rate-limiting of non-RPF traffic
        //  replication-mode   Disable auto-detection mode for egress
        //  sso                Stateful switchover parameters
        //  threshold          Threshold rate for installing h/w shortcuts
      }
      //  nat        nat keyword
      //  slb        Server Load Balancing
    }
    //  nde         netflow data export (nde) keyword
    //  netflow     netflow keyword

    // mls qos
    container mls-qos-conf {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      leaf qos {
        type empty;
      }
    }

    // mls qos
    container qos {
      tailf:info "QoS parameters";
      tailf:cli-incomplete-command;
      tailf:cli-incomplete-no;

      // mls qos aggregate-policer *
      list aggregate-policer {
        tailf:info "Assign aggregate policer";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;aggregate policer name";
          }
        }
        leaf target-bit-rate {
          tailf:cli-drop-node-name;
          type uint64 {
            tailf:info "<32000-60000000000>;;Target Bit Rate (bits per "
              +"second) (postfix k, m, g optional; decimal point allowed)";
            range "32000..60000000000";
          }
        }
        leaf burst-normal {
          tailf:cli-drop-node-name;
          tailf:cli-optional-in-sequence;
          type uint32 {
            tailf:info "<1000-31250000>;;Normal burst bytes";
            range "1000..31250000";
          }
        }
        leaf burst-max {
          tailf:cli-drop-node-name;
          tailf:cli-optional-in-sequence;
          when "../burst-normal" {
            tailf:dependency "../burst-normal";
          }
          type uint32 {
            tailf:info "<1000-31250000>;;Maximum burst bytes";
            range "1000..31250000";
          }
        }
        leaf pir {
          tailf:info "PIR";
          tailf:cli-optional-in-sequence;
          type uint64 {
            tailf:info "<32000-60000000000>;;Target Bit Rate (bits per "
              +"second) (postfix k, m, g optional; decimal point allowed)";
            range "32000..60000000000";
          }
        }
        container conform-action {
          tailf:info "action when rate is not exceeded";
          tailf:cli-optional-in-sequence;
          tailf:cli-compact-syntax;
          tailf:cli-flatten-container;
          choice action-choice {
            leaf drop {
              tailf:info "drop packet";
              type empty;
            }
            leaf set-dscp-transmit {
              tailf:info "set dscp and send it";
              type dscp-type;
            }
            leaf set-mpls-exp-imposition-transmit {
              tailf:info "set exp at tag imposition and send it";
              type uint8 {
                tailf:info "<0-7>;;new exp";
                range "0..7";
              }
            }
            leaf set-prec-transmit {
              tailf:info "rewrite packet precedence and send it";
              type uint8 {
                tailf:info "<0-7>;;new precedence";
                range "0..7";
              }
            }
            leaf transmit {
              tailf:info "transmit packet";
              type empty;
            }
          }
        }
        leaf exceed-action {
          tailf:info "action when rate is exceeded";
          tailf:cli-optional-in-sequence;
          type enumeration {
            enum drop {
              tailf:info "drop packet";
            }
            enum policed-dscp-transmit {
              tailf:info "change dscp per policed-dscp map and send it";
            }
            enum transmit {
              tailf:info "transmit packet";
            }
          }
        }
        leaf violate-action {
          tailf:info "action when rate violated";
          type enumeration {
            enum drop {
              tailf:info "drop packet";
            }
            enum policed-dscp-transmit {
              tailf:info "change dscp per policed-dscp map and send it";
            }
            enum transmit {
              tailf:info "transmit packet";
            }
          }
        }
      }
      //  map                Define QoS mapping
      //  marking            marking keyword
      //  police             police keyword
      //  protocol           protocol keyword
      //  queueing-only      queueing-only (no QoS rewrite,  no policing)
      //  recirc             recirculate path

      // mls qos rewrite
      container rewrite {
        tailf:info "packet qos rewrite enable/disable";
        container ip {
          tailf:info "ip packet qos rewrite enable/disable";
          container dscp {
            tailf:info "packet ip dscp rewrite enable/disable";
            presence true;
            leaf slot {
              tailf:info "slot number";
              type string {
                tailf:info "WORD;;Slots seperated by commas. Valid slots: 1,2,"
                  +"3,4,5,6,7,8,9";
              }
            }
          }
        }
      }
    }

    //  statistics-export  qos statistics data export

    // mls rate-limit
    container rate-limit {
      tailf:info "Rate limit different behaviors";
      //  all        Rate Limiting for both Unicast and Multicast packets
      container layer2 {
        tailf:info "layer2 protocol cases";
        //  ip-admission   IP admission on Layer2 ports
        container l2pt {
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:info "layer2 protocol tunnelling packets";

          leaf packets-per-second {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<10-1000000>;;packets per second";
              range "10..1000000";
            }
          }

          leaf packets-in-burst {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-255>;;packets in burst";
              range "1..255";
            }
          }
        }
        //  mac-security   Mac security traffics
        container pdu {
          tailf:info "layer2 protocol data unit packets";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf packets-per-second {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<10-1000000>;;packets per second";
              range "10..1000000";
            }
          }

          leaf packets-in-burst {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-255>;;packets in burst";
              range "1..255";
            }
          }
        }
        //  port-security  Port security traffics
      }
      //  multicast  Rate limiting for Multicast packets
      //  unicast    Rate limiting for Unicast packets
    }

    //  rp          rp
    //  sampling    sampling keyword

    // mls verify
    container verify {
      tailf:info "enable hardware packet parsing error checks";
      container ip {
        tailf:info "check on IP packets";
        leaf checksum {
          tailf:info "check for packet checksum errors";
            tailf:cli-boolean-no;
            tailf:cli-trim-default;
            type boolean;
            default true;
        }
        container "length" {
          tailf:info "check for packet length errors";
          leaf consistent {
            tailf:info "check length in header against physical frame length";
            tailf:cli-boolean-no;
            tailf:cli-trim-default;
            type boolean;
            default true;
          }
          leaf minimum {
            tailf:info "check for minimum packet length";
            tailf:cli-boolean-no;
            tailf:cli-trim-default;
            type boolean;
            default true;
          }
        }
        leaf same-address {
          tailf:info "check for packet having equal source and destination IP "
            +"addresses";
          type empty;
        }
        leaf syslog {
          tailf:info "syslog packet parse errors";
          type empty;
        }
      }
    }
  }


  /// ========================================================================
  /// policer
  /// ========================================================================
  // Note: must come before class-map and policy-map.

  container policer {
    tailf:info "Switch policer";

    // policer aggregate *
    list aggregate {
      tailf:info "Named aggregate policer";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;aggregate policer Name";
        }
      }
      // cir <cir-bps>
      leaf cir {
        tailf:info "Committed information rate";
        type uint32 {
          tailf:info "<8000-1000000000>;;Bits per second";
          range "8000..1000000000";
        }
      }
      // bc <burst>
      leaf bc {
        tailf:info "Conform burst";
        tailf:cli-optional-in-sequence;
        type uint32 {
          tailf:info "<8000-1000000000>;;Burst bytes";
          range "8000..1000000000";
        }
      }
      // conform-action
      leaf conform-action {
        tailf:info "action when rate is within conform and conform + "+
          "exceed burst";
        tailf:cli-optional-in-sequence;
        type empty;
      }
      leaf set-qos-transmit {
        tailf:info "set qos-group and send it";
        when "../conform-action";
        tailf:cli-optional-in-sequence;
        type uint8 {
          tailf:info "<0-99>;;new qos-group";
          range "0..99";
        }
      }
      leaf set-dot1ad-dei-transmit {
        tailf:info "set dei and send it";
        when "../conform-action";
        tailf:cli-optional-in-sequence;
        type uint8 {
          tailf:info "<0-1>;;new dei value";
          range "0..1";
        }
      }
      leaf set-prec-transmit {
        tailf:info "rewrite packet precedence and send it";
        when "../conform-action";
        tailf:cli-optional-in-sequence;
        type prec_value-type;
      }
      container set-prec-transmit-table {
        when "../set-prec-transmit";
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        tailf:cli-flatten-container;
        leaf table {
          tailf:info "Set packet cos from cos based on table map";
          tailf:cli-optional-in-sequence;
          type string;
          tailf:non-strict-leafref {
            path "/ios:table-map/name";
          }
        }
      }
      leaf set-dscp-transmit {
        tailf:info "set dscp and send it";
        when "../conform-action";
        tailf:cli-optional-in-sequence;
        type dscp-type;
      }
      container set-dscp-transmit-table {
        when "../set-dscp-transmit";
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        tailf:cli-flatten-container;
        leaf table {
          tailf:info "Set packet cos from cos based on table map";
          tailf:cli-optional-in-sequence;
          type string;
          tailf:non-strict-leafref {
            path "/ios:table-map/name";
          }
        }
      }
      leaf set-cos-transmit {
        tailf:info "set cos and send it";
        when "../conform-action";
        tailf:cli-optional-in-sequence;
        type cos_value-type;
      }
      container set-cos-transmit-table {
        when "../set-cos-transmit";
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        tailf:cli-flatten-container;
        leaf table {
          tailf:info "Set packet cos from cos based on table map";
          tailf:cli-optional-in-sequence;
          type string;
          tailf:non-strict-leafref {
            path "/ios:table-map/name";
          }
        }
      }
      leaf transmit {
        tailf:info "transmit packet";
        when "../conform-action";
        tailf:cli-optional-in-sequence;
        type empty;
      }
      // exceed-action
      leaf exceed-action {
        tailf:info "action when rate is within conform and conform + "+
          "exceed burst";
        type empty;
      }
      leaf drop {
        tailf:info "drop packet";
        when "../exceed-action";
        tailf:cli-optional-in-sequence;
        tailf:cli-full-command;
        type empty;
      }
      container exceed-transmit {
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        tailf:cli-flatten-container;
        leaf transmit {
          tailf:info "transmit packet";
          when "../../exceed-action";
          tailf:cli-optional-in-sequence;
          type empty;
        }
      }
    }
  }


  /// ========================================================================
  /// class-map
  /// ========================================================================

  list class-map {
    tailf:info "Configure QoS Class Map";
    tailf:cli-mode-name "config-cmap";
    tailf:cli-suppress-list-no;
    tailf:cli-delete-when-empty;
    tailf:cli-no-key-completion;

    // class-map *
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;class-map name";
      }
      tailf:cli-disallow-value "type";
    }

    // class-map * type inspect
    leaf "type" {
      tailf:info "type of the class-map";
      tailf:cli-prefix-key;
      type enumeration {
        enum inspect;
      }
    }

    // class-map * <protocol>
    leaf protocol {
      // when "../type = 'inspect'";
      tailf:cli-drop-node-name;
      tailf:cli-prefix-key;
      type enumeration {
        enum aol {
          tailf:info "Configure CBAC class-map for IM-AOL protocol";
        }
        enum edonkey {
          tailf:info "eDonkey";
        }
        enum fasttrack {
          tailf:info "FastTrack Traffic - KaZaA, Morpheus, Grokster...";
        }
        enum gnutella {
          tailf:info "Gnutella Version2 Traffic - BearShare, Shareeza, "
            +"Morpheus ...";
        }
        enum http {
          tailf:info "Configure CBAC class-map for HTTP protocol";
        }
        enum imap {
          tailf:info "Configure CBAC class-map for IMAP protocol";
        }
        enum kazaa2 {
          tailf:info "Kazaa Version 2";
        }
        enum msnmsgr {
          tailf:info "Configure CBAC class-map for IM-MSN protocol";
        }
        enum pop3 {
          tailf:info "Configure CBAC class-map for POP3 protocol";
        }
        enum smtp {
          tailf:info "Configure CBAC class-map for SMTP protocol";
        }
        enum sunrpc {
          tailf:info "Configure CBAC class-map for RPC protocol";
        }
        enum ymsgr {
          tailf:info "Configure CBAC class-map for IM-YAHOO protocol";
        }
      }
    }

    // class-map * <match-any|match-all>
    leaf prematch {
      tailf:cli-no-keyword;
      tailf:cli-prefix-key;
      tailf:cli-drop-node-name;
      type enumeration {
        enum match-all {
          tailf:info "Logical-AND all matching statements under "+
            "this classmap";
        }
        enum match-any {
          tailf:info "Logical-OR all matching statements under this "+
            "classmap";
        }
      }
      mandatory true;
    }

    // class-map * / description
    leaf "description" {
      tailf:info "Class-Map description";
      tailf:cli-multi-value;
      type string {
        tailf:info "LINE;;Description of this class-map (up to 200 "+
          "characters)";
      }
    }

    // class-map * / match
    container match {
      tailf:info "classification criteria";
      uses class-map-match-grouping;
      container not {
        tailf:info "Negate this match result";
        uses class-map-match-grouping;
      }
    }
  }


  /// ========================================================================
  /// policy-map
  /// ========================================================================

  list policy-map {
    tailf:info "Configure QoS Policy Map";
    tailf:cli-mode-name "config-pmap";
    tailf:cli-diff-dependency "/ios:class-map";
    tailf:cli-diff-dependency "/ios:table-map";
    tailf:cli-diff-dependency "/ios:mls/qos/aggregate-policer";
    tailf:cli-diff-dependency "/ios:policer/aggregate";
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;policy-map name";
      }
      tailf:cli-disallow-value
        "(type)|(http)|(im)|(imap)|(p2p)|(pop3)|(smtp)|(sunrpc)";
    }

    leaf "type" {
      tailf:info "type of the policy-map";
      tailf:cli-prefix-key;
      type enumeration {
        enum inspect;
      }
    }

    leaf protocol {
      tailf:cli-drop-node-name;
      tailf:cli-prefix-key;
      type enumeration {
        enum http {
          tailf:info "Configure CBAC policy-map for HTTP protocol";
        }
        enum im {
          tailf:info "Configure CBAC policy-map for IM protocol";
        }
        enum imap {
          tailf:info "Configure CBAC policy-map for IMAP protocol";
        }
        enum p2p {
          tailf:info "Configure CBAC policy-map for P2P protocols";
        }
        enum pop3 {
          tailf:info "Configure CBAC policy-map for POP3 protocol";
        }
        enum smtp {
          tailf:info "Configure CBAC policy-map for SMTP protocol";
        }
        enum sunrpc {
          tailf:info "Configure CBAC policy-map for RPC protocol";
        }
      }
    }

    // policy-map * / class *
    list class {
      tailf:info "policy criteria";
      tailf:cli-mode-name "config-pmap-c";
      key name;
      leaf name {
        tailf:cli-disallow-value "type";
        type class-name-type;
      }
      // policy-map * / class * / type
      leaf "type" {
        tailf:info "type of the class-map";
        tailf:cli-prefix-key;
        type enumeration {
          enum inspect {
            tailf:info "Configure CBAC Class Map";
          }
        }
      }
      // policy-map * / class * / policy
      container policy {
        when "../../type = 'inspect'";
        tailf:cli-drop-node-name;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf action {
          tailf:cli-drop-node-name;
          tailf:cli-remove-before-change;
          type enumeration {
            enum drop {
              tailf:info "Drop the packet";
            }
            enum inspect {
              tailf:info "Context-based Access Control Engine";
            }
            enum pass {
              tailf:info "Pass the packet";
            }
          }
        }
        leaf log {
          tailf:info "Send logging message for drop";
          when "../action = 'drop'";
          type empty;
        }
        leaf parameter-map {
          tailf:cli-drop-node-name;
          when "../action = 'inspect'";
          type string;
          tailf:non-strict-leafref {
            path "/ios:parameter-map/type/inspect/id";
          }
        }
      }
      // policy-map * / class * / inspect-police
      container inspect-police {
        when "../policy/action = 'inspect'";
        tailf:cli-drop-node-name;
        container police {
          tailf:info "Police";
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-compact-syntax;
          leaf rate {
            tailf:info "Specify police rate";
            type uint32 {
              tailf:info "<8000-2000000000>;;Rate value in bps";
              range "8000..2000000000";
            }
          }
          leaf burst {
            tailf:info "Specify 'burst' parameter";
            type uint32 {
              tailf:info "<1000-512000000>;;Burst value in bytes";
              range "1000..512000000";
            }
          }
        }
      }
      // policy-map * / class * / bandwidth
      container bandwidth {
        tailf:info "Bandwidth";
        leaf bits {
          tailf:cli-drop-node-name;
          type uint32 {
            range "8..2000000";
            tailf:info "<8-2000000>;;Kilo Bits per second";
          }
        }
        leaf percent {
          tailf:info "% of total Bandwidth";
          type percentage-type;
        }
        container remaining {
          tailf:info "% of the remaining bandwidth";
          leaf percent {
            tailf:info "% of the remaining bandwidth";
            type percentage-type;
          }
        }
      }
      // policy-map * / class * / compression
      container compression {
        tailf:info "Activate Compression";
        presence "Activate Compression";
        container header {
          tailf:info "configure header compression";
          presence "configure header compression";
          leaf ip {
            tailf:info "configure ip header compression";
            type enumeration {
              enum rtp {
                tailf:code-name "header_rtp";
                tailf:info "configure rtp header compression";
              }
              enum tcp {
                tailf:info "configure tcp header compression";
              }
            }
          }
        }
      }
      // policy-map * / class * / drop
      leaf drop {
        tailf:info "Drop all packets";
        tailf:cli-full-command;
        type empty;
      }
      // policy-map * / class * / estimate
      container estimate {
        tailf:info "estimate resources required for this class";
        container bandwidth {
          presence "bandwidth required to service this class";
          tailf:info "bandwidth required to service this class";
          tailf:cli-sequence-commands;
          tailf:cli-compact-syntax;
          container delay-one-in {
            tailf:info "specify QoS target delay";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf doi {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint32 {
                range "50..1000000";
                tailf:info "<50-1000000>;;delay one packet "+
                  "of N";
              }
            }

            leaf milliseconds {
              type uint32 {
                range "8..1000" {
                  tailf:info "<8-1000>;;worst-case "+
                    "milliseconds of delay";
                }
              }
            }
          }
          leaf drop-one-in {
            tailf:info "specify QoS target loss rate";
            type uint32 {
              tailf:info "<50-1000000>;;drop one packet of N";
            }
          }
        }
      }
      // policy-map * / class * / fair-queue
      // class-default: fair-queue [number-of-dynamic-queues]
      // DWFQ: fair-queue
      // policy-map: fair-queue [queue-limit queue-value]
      // NOT SUPPORTED:
      // air-queue [congestive-discard-threshold [dynamic-q [reservable-q]]]
      container fair-queue {
        tailf:info "Enable Flow-based Fair Queuing in this Class";
        tailf:cli-reset-container;
        presence true;
        leaf dynamic-queues {
          tailf:cli-drop-node-name;
          tailf:cli-full-command;
          type uint32 {
            range "16|32|64|128|256|512|1024|2048|4096" {
              tailf:info "<16-4096>;;Number Dynamic Conversation "+
                "Queues";
            }
          }
        }
        leaf queue-limit {
          tailf:info "per flow queue limit";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<1-32768>;;packets";
            range "1..32768";
          }
        }
      }
      // policy-map * / class * / netflow-sampler
      leaf netflow-sampler {
        tailf:info "NetFlow action";
        tailf:cli-full-command;
        // should be leafref to sampler
        type string {
          tailf:info "WORD;;Name of the flow sampler";
        }
      }

      // policy-map * / class * / police ?
      choice police-choice {

        // policy-map * / class * / police aggregate
        case police-aggregate-case {
          container police-aggregate {
            tailf:cli-no-keyword;
            tailf:cli-drop-node-name;
            container police {
              tailf:info "Police";
              leaf aggregate {
                tailf:info "Choose aggregate policer for current class";
                type string {
                  tailf:info "WORD;;enter aggregate-policer name";
                }
              }
            }
          }
        }

        // police (policy-map)
        // police cir <bps> [[bc <burst-normal>] [be <burst-max>]]
        //        [pir <bps> [be <burst-bytes>]] ACTIONS
        // NOTE: cir, bc & be keywords are mandatory in this model.
        //       Java code will add missing cir,bc and be in show().
        case police-policy-map-case {
          container police-policy-map {
            tailf:cli-no-keyword;
            tailf:cli-drop-node-name;
            container police {
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-pmap-c-police";
              tailf:cli-flatten-container;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              // cir <bps>
              leaf cir {
                tailf:info "Committed information rate";
                tailf:cli-hide-in-submode;
                type police-bps-type;
              }
              // [bc <burst-normal>]
              leaf bc {
                tailf:info "Conform burst";
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                type police-burst-type;
              }
              // [be <burst-max>]
              leaf be {
                when "../bc";
                tailf:info "Excess burst";
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                type police-burst-type;
              }
              // [pir <bps> [be <burst-bytes>]]
              leaf pir {
                tailf:info "Peak Information Rate";
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                type police-bps-type;
              }
              container pir-be {
                when "../pir";
                tailf:cli-no-keyword;
                tailf:cli-drop-node-name;
                tailf:cli-optional-in-sequence;
                tailf:cli-flatten-container;
                tailf:cli-hide-in-submode;
                leaf be {
                  tailf:info "Excess burst";
                  type police-burst-type;
                }
              }
              // conform-action | exceed-action | violate-action
              uses police-action-grouping;
            }
          }
        }

        // police cir percent (combo of percent & policy-map versions)
        // police cir percent <percentage>
        //    [bc] <burst> ms] [be [<burst> ms]
        //    [pir percent <percentage> [be <burst> ms]] ACTIONS
        case police-cir-percent-case {
          container police-cir-percent {
            tailf:cli-no-keyword;
            tailf:cli-drop-node-name;
            container police {
              container cir {
                tailf:info "Committed information rate";
                container percent {
                  tailf:info "% of interface bandwidth for Committed "+
                    "information rate";
                  tailf:cli-add-mode;
                  tailf:cli-mode-name "config-pmap-c-police";
                  tailf:cli-incomplete-command;
                  tailf:cli-flatten-container;
                  tailf:cli-sequence-commands {
                    tailf:cli-reset-siblings;
                  }
                  // percent <percentage>
                  leaf percentage {
                    tailf:cli-drop-node-name;
                    tailf:cli-hide-in-submode;
                    type percentage-type;
                  }
                  // [bc <burst> ms]
                  leaf bc {
                    tailf:info "Conform burst";
                    tailf:cli-optional-in-sequence;
                    tailf:cli-hide-in-submode;
                    type uint16 {
                      tailf:info "<1-2000>;;Burst ms";
                    }
                  }
                  container bc-ms {
                    when "../bc";
                    tailf:cli-no-keyword;
                    tailf:cli-drop-node-name;
                    tailf:cli-optional-in-sequence;
                    tailf:cli-hide-in-submode;
                    tailf:cli-compact-syntax;
                    tailf:cli-flatten-container;
                    leaf ms {
                      tailf:info "Milli seconds";
                      tailf:cli-no-keyword;
                      type empty;
                    }
                  }
                  // [be [<burst> ms]
                  leaf be {
                    when "../bc-ms/ms" {
                      tailf:dependency "../bc-ms/ms";
                    }
                    tailf:info "Excess burst";
                    tailf:cli-optional-in-sequence;
                    tailf:cli-hide-in-submode;
                    type uint16 {
                      tailf:info "<1-2000>;;Burst ms";
                    }
                  }
                  container be-ms {
                    when "../be";
                    tailf:cli-no-keyword;
                    tailf:cli-drop-node-name;
                    tailf:cli-hide-in-submode;
                    tailf:cli-compact-syntax;
                    tailf:cli-flatten-container;
                    leaf ms {
                      tailf:info "Milli seconds";
                      tailf:cli-no-keyword;
                      type empty;
                    }
                  }
                  // [pir percent <percentage> [be <burst> ms]]
                  container pir {
                    tailf:info "Peak Information Rate";
                    tailf:cli-compact-syntax;
                    tailf:cli-flatten-container;
                    tailf:cli-hide-in-submode;
                    tailf:cli-optional-in-sequence;
                    leaf percent {
                      tailf:info "% of interface bandwidth for Peak "+
                        "Information Rate";
                      type percentage-type;
                    }
                  }
                  container pir-be {
                    when "../pir";
                    tailf:cli-no-keyword;
                    tailf:cli-drop-node-name;
                    tailf:cli-optional-in-sequence;
                    tailf:cli-flatten-container;
                    tailf:cli-hide-in-submode;
                    leaf be {
                      tailf:info "Excess burst";
                      type uint16 {
                        tailf:info "<1-2000>;;Burst ms";
                      }
                    }
                  }
                  container pir-be-ms {
                    when "../pir-be/be" {
                      tailf:dependency "../pir-be/be";
                    }
                    tailf:cli-no-keyword;
                    tailf:cli-drop-node-name;
                    tailf:cli-optional-in-sequence;
                    tailf:cli-hide-in-submode;
                    tailf:cli-flatten-container;
                    leaf ms {
                      tailf:info "Milli seconds";
                      tailf:cli-no-keyword;
                      type empty;
                    }
                  }
                  // conform-action | exceed-action | violate-action
                  uses police-action-grouping;
                }
              }
            }
          }
        }

        // police rate (control-plane)
        // police rate <units> <pps|bps> [burst <burst-in-x> <packets|bytes>]
        //   [peak-rate <peak-rate-in-xps> <pps|bps>]
        //   [peak-burst <peak-burst-in-x> <packets|bytes>]
        //   [conform-action <action>]
        case police-rate-unit-case {
          container police-rate-unit {
            tailf:cli-no-keyword;
            tailf:cli-drop-node-name;
            container police {
              container rate {
                tailf:info "Specify police rate";
                tailf:cli-add-mode;
                tailf:cli-mode-name "config-pmap-c-police";
                tailf:cli-flatten-container;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                // <units>
                leaf "units" {
                  tailf:cli-drop-node-name;
                  tailf:cli-hide-in-submode;
                  type uint64 {
                    tailf:info "<1-2000000000>;;Rate value in the range "+
                      "8000-2,000,000,000 bps or 1-2,000,000 pps";
                  }
                }
                // <pps|bps>
                leaf xps {
                  tailf:cli-no-keyword;
                  tailf:cli-drop-node-name;
                  tailf:cli-hide-in-submode;
                  type police-pps-bps-type;
                }
                // [burst <burst-in-x> <packets|bytes>]
                container burst {
                  tailf:info "Specify 'burst' parameter";
                  tailf:cli-optional-in-sequence;
                  tailf:cli-compact-syntax;
                  tailf:cli-hide-in-submode;
                  tailf:cli-flatten-container;
                  tailf:cli-sequence-commands;
                  leaf burst-value {
                    tailf:cli-no-keyword;
                    tailf:cli-drop-node-name;
                    tailf:cli-incomplete-command;
                    type uint32 {
                      tailf:info "<1-512000000>;;Burst value in "+
                        "packets/bytes";
                    }
                  }
                  leaf burst-type {
                    tailf:cli-no-keyword;
                    tailf:cli-drop-node-name;
                    tailf:cli-hide-in-submode;
                    type police-packets-bytes-type;
                  }
                }
                // [peak-rate <peak-rate-in-xps> <pps|bps>]
                container peak-rate {
                  tailf:info "Specify peak rate";
                  tailf:cli-optional-in-sequence;
                  tailf:cli-compact-syntax;
                  tailf:cli-flatten-container;
                  tailf:cli-hide-in-submode;
                  tailf:cli-sequence-commands;
                  leaf peak-rate-value {
                    tailf:cli-no-keyword;
                    tailf:cli-drop-node-name;
                    tailf:cli-incomplete-command;
                    type uint32 {
                      tailf:info "<1-512000000>;;Peak-rate value in "+
                        "packets or bytes per second";
                      range "1..512000000";
                    }
                  }
                  leaf xps {
                    tailf:cli-no-keyword;
                    tailf:cli-drop-node-name;
                    type police-pps-bps-type;
                  }
                }
                // [peak-burst <peak-burst-in-x> <packets|bytes>]
                container peak-burst {
                  tailf:info "Specify 'peak-burst' parameter for peak-rate";
                  tailf:cli-optional-in-sequence;
                  tailf:cli-compact-syntax;
                  tailf:cli-flatten-container;
                  tailf:cli-hide-in-submode;
                  tailf:cli-sequence-commands;
                  leaf burst-value {
                    tailf:cli-no-keyword;
                    tailf:cli-drop-node-name;
                    tailf:cli-incomplete-command;
                    type uint32 {
                      tailf:info "<1-512000000>;;Burst value in "+
                        "packets/bytes";
                    }
                  }
                  leaf burst-type {
                    tailf:cli-no-keyword;
                    tailf:cli-drop-node-name;
                    type police-packets-bytes-type;
                  }
                }
                // conform-action | exceed-action | violate-action
                uses police-action-grouping;
              }
            }
          }
        }


        // police rate percent (control-plane)
        // police rate percent <percentage> [burst <ms> ms]
        //    [peak-rate percent <percentage>] [peak-burst <ms> ms]
        case police-rate-percent-case {
          container police-rate-percent {
            tailf:cli-no-keyword;
            tailf:cli-drop-node-name;
            container police {
              container rate {
                tailf:info "Specify police rate";
                container percent {
                  tailf:info "% of interface bandwidth for rate";
                  tailf:cli-add-mode;
                  tailf:cli-mode-name "config-pmap-c-police";
                  tailf:cli-flatten-container;
                  tailf:cli-sequence-commands {
                    tailf:cli-reset-siblings;
                  }
                  // <percentage>
                  leaf percentage {
                    tailf:cli-drop-node-name;
                    tailf:cli-hide-in-submode;
                    type percentage-type;
                  }
                  // [burst <ms> ms]
                  leaf burst {
                    tailf:info "Specify 'burst' parameter";
                    tailf:cli-optional-in-sequence;
                    tailf:cli-hide-in-submode;
                    type uint16 {
                      tailf:info "<1-2000>;;Burst value in milliseconds";
                    }
                  }
                  leaf ms {
                    when "../burst";
                    tailf:info "Treat 'burst' value in milliseconds";
                    tailf:cli-hide-in-submode;
                    type empty;
                  }
                  // [peak-rate percent <percentage>]
                  container peak-rate {
                    tailf:info "Specify peak rate";
                    tailf:cli-hide-in-submode;
                    tailf:cli-optional-in-sequence;
                    tailf:cli-flatten-container;
                    leaf percent {
                      tailf:info "% of interface bandwidth for peak-rate";
                      type percentage-type;
                    }
                  }
                  // [peak-burst <ms> ms]
                  leaf peak-burst {
                    tailf:info "Specify 'peak-burst' parameter for "+
                      "'peak-rate'";
                    tailf:cli-hide-in-submode;
                    tailf:cli-optional-in-sequence;
                    type uint16 {
                      tailf:info "<1-2000>;;Peak burst value in "+
                        "milliseconds";
                    }
                  }
                  container peak-burst-ms {
                    when "../peak-burst";
                    tailf:cli-no-keyword;
                    tailf:cli-drop-node-name;
                    tailf:cli-optional-in-sequence;
                    tailf:cli-hide-in-submode;
                    tailf:cli-flatten-container;
                    leaf ms {
                      tailf:info "Milli seconds";
                      tailf:cli-no-keyword;
                      type empty;
                    }
                  }
                  // conform-action | exceed-action | violate-action
                  uses police-action-grouping;
                }
              }
            }
          }
        }

        // police rate pdp
        // police rate pdp [burst <bytes>]
        //    [peak-rate pdp [peak-burst <bytes>]] ACTIONS
        case police-rate-pdp-case {
          container police-rate-pdp {
            tailf:cli-no-keyword;
            tailf:cli-drop-node-name;
            container police {
              container rate {
                tailf:info "Specify police rate";
                container pdp {
                  tailf:info "% of interface bandwidth for rate";
                  tailf:cli-add-mode;
                  tailf:cli-mode-name "config-pmap-c-police";
                  tailf:cli-flatten-container;
                  tailf:cli-sequence-commands {
                    tailf:cli-reset-siblings;
                  }
                  // [burst <bytes>]
                  leaf burst {
                    tailf:info "Conform burst";
                    tailf:cli-hide-in-submode;
                    tailf:cli-optional-in-sequence;
                    type police-burst-type;
                  }
                  // [peak-rate pdp [peak-burst <bytes>]]
                  leaf peak-rate {
                    tailf:info "Specify peak rate";
                    tailf:cli-hide-in-submode;
                    tailf:cli-optional-in-sequence;
                    type enumeration {
                      enum "pdp" {
                      }
                    }
                  }
                  leaf peak-burst {
                    when "../peak-rate";
                    tailf:info "Specify 'peak-burst' parameter for "+
                      "'peak-rate'";
                    tailf:cli-hide-in-submode;
                    tailf:cli-optional-in-sequence;
                    type police-burst-type;
                  }
                  // conform-action | exceed-action | violate-action
                  uses police-action-grouping;
                }
              }
            }
          }
        }

        // police flow (policy-map)
        // police flow [mask {dest-only | full-flow | src-only}]
        //    <bps> [<burst-normal>] ACTIONS
        case police-flow-case {
          container police-flow {
            tailf:cli-no-keyword;
            tailf:cli-drop-node-name;
            container police {
              container flow {
                tailf:info "police each flow";
                tailf:cli-add-mode;
                tailf:cli-mode-name "config-pmap-c-police";
                tailf:cli-flatten-container;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                // [mask {dest-only | full-flow | src-only}]
                leaf mask {
                  tailf:info "flow mask to be used for policing";
                  tailf:cli-hide-in-submode;
                  tailf:cli-optional-in-sequence;
                  type enumeration {
                    enum dest-only {
                      tailf:info "destination-address only flow mask";
                    }
                    enum full-flow {
                      tailf:info "full flow mask";
                    }
                    enum src-only {
                      tailf:info "source-address only flow mask";
                    }
                  }
                }
                // <bps>
                leaf bps {
                  tailf:cli-drop-node-name;
                  tailf:cli-hide-in-submode;
                  type police-bps-type;
                }
                // [<burst-normal>]
                leaf burst-normal {
                  when "../bps";
                  tailf:cli-drop-node-name;
                  tailf:cli-hide-in-submode;
                  tailf:cli-optional-in-sequence;
                  type police-burst-type;
                }
                // conform-action | exceed-action | violate-action
                uses police-action-grouping;
              }
            }
          }
        }

        // police (Catalyst 4500)
        // police <bps> bps <byte> byte ACTIONS
        case police-catalyst-case {
          container police-catalyst {
            tailf:cli-no-keyword;
            tailf:cli-drop-node-name;
            container police {
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-pmap-c-police";
              tailf:cli-flatten-container;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              // <bps> bps
              leaf bps-value {
                tailf:cli-no-keyword;
                tailf:cli-drop-node-name;
                tailf:cli-hide-in-submode;
                tailf:cli-incomplete-command;
                type string {
                  tailf:info "<32000-32000000000>;;Rate in bits per second "+
                    "(postfix k, m, g optional; decimal point allowed)";
                }
              }
              leaf bps {
                tailf:cli-hide-in-submode;
                tailf:cli-incomplete-command;
                type empty;
              }
              // <byte> byte
              leaf byte-value {
                tailf:cli-no-keyword;
                tailf:cli-drop-node-name;
                tailf:cli-hide-in-submode;
                tailf:cli-incomplete-command;
                type string {
                  tailf:info "<32000-32000000000>;;(postfix k, m, g "+
                    "optional; decimal point allowed)";
                }
              }
              leaf byte {
                tailf:cli-hide-in-submode;
                type empty;
              }
              // conform-action | exceed-action | violate-action
              container actions {
                tailf:cli-no-keyword;
                tailf:cli-break-sequence-commands;
                tailf:cli-drop-node-name;
                tailf:cli-flatten-container;
                tailf:cli-hide-in-submode;
                // policy-map * / class * / police ? / conform-action
                uses police-conform-action-grouping;
                // policy-map * / class * / police ? / exceed-action
                uses police-exceed-action-grouping;
                // policy-map * / class * / police ? / violate-action
                uses police-violate-action-grouping;
              }
            }
          }
        }

        // police (Catalyst C3550)
        // police <bps> <burst> exceed-action {drop | policed-dscp-transmit}]
        case police-switch-case {
          container police-switch {
            tailf:cli-no-keyword;
            tailf:cli-drop-node-name;
            container police {
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              // <cir>
              leaf cir {
                tailf:cli-incomplete-command;
                tailf:cli-drop-node-name;
                type uint32 {
                  tailf:info "<8000-1000000000>;;Bits per second";
                  range "8000..1000000000";
                }
              }
              // <bc>
              leaf bc {
                tailf:cli-drop-node-name;
                type uint32 {
                  tailf:info "<8000-2000000>;;Normal burst bytes";
                  range "8000..2000000";
                }
              }
              // exceed-action
              leaf exceed-action {
                tailf:info "action when rate is exceeded";
                type enumeration {
                  enum drop {
                    tailf:info "drop packet";
                  }
                  enum policed-dscp-transmit {
                    tailf:info "change dscp per policed-dscp map and send it";
                  }
                }
              }
            }
          }
        }
      }

      // policy-map * / class * / priority
      container priority {
        tailf:info "Strict Scheduling Priority for this Class";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        presence true;
        leaf level {
          tailf:info "Multi-Level Priority Queue";
          tailf:cli-optional-in-sequence;
          type uint8 {
            tailf:info "<1-2>;;Multi-Level Priority Queue";
            range "1..2";
          }
        }
        choice priority-type {
          leaf kilo-bits {
            tailf:cli-drop-node-name;
            type uint32 {
              range "8..2000000";
              tailf:info "<8-2000000>;;Kilo Bits per second";
            }
          }
          leaf percent {
            tailf:info "% of total bandwidth";
            type uint16 {
              range "1..100";
              tailf:info "<1-100>;;percentage";
            }
          }
        }
        leaf burst {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<32-64000000>;;Burst in bytes";
            range "32..64000000";
          }
        }
      }
      // policy-map * / class * / queue-limit
      container queue-limit {
        tailf:info "Queue Max Threshold for Tail Drop";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf queue-limit-value {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-8192000>  in bytes, <1-3400> in ms, "+
              "<1-32768> in packets by default";
            range "1..8192000";
          }
        }
        leaf queue-limit-type {
          tailf:cli-drop-node-name;
          type enumeration {
            enum bytes {
              tailf:info "in bytes";
            }
            enum ms {
              tailf:info "in milliseconds";
            }
            enum packets {
              tailf:info "in packets";
            }
          }
        }
      }
      // policy-map * / class * / random-detect
      container random-detect {
        tailf:info "Enable Random Early Detection as drop policy";
        presence true;
        container aggregate {
          tailf:info "aggregate subclasses";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          presence true;
          leaf minimum-thresh {
            tailf:info "minimum threshold for red aggregate";
            type uint32 {
              tailf:info "<0-1000000>;;minimum threshold (number of packets)";
              range "0..1000000";
            }
          }
          leaf maximum-thresh {
            tailf:info "maximum threshold for red aggregate";
            type uint32 {
              tailf:info "<0-1000000>;;maximum threshold (number of packets)";
              range "0..1000000";
            }
          }
          leaf mark-probability {
            tailf:info "mark-probability for red aggregate";
            type empty;
          }
          leaf denominator {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<0-65535>;;mark probability denominator";
              range "0..65535";
            }
          }
        }
        container discard-class {
          tailf:info "parameters for each discard-class value";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf dclass {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
              range "0..7";
              tailf:info "<0-7>;;discard-class value";
            }
          }
          uses random-detect-grouping;
        }
        leaf discard-class-based {
          tailf:info "Enable discard-class-based WRED as drop policy";
          tailf:cli-full-command;
          type empty;
        }
        container dscp {
          tailf:info "parameters for each dscp value";
          tailf:cli-sequence-commands;
          tailf:cli-compact-syntax;
          leaf dscp-val {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type dscp-type;
          }
          uses random-detect-grouping;
        }
        leaf dscp-based {
          tailf:info "Enable dscp-based WRED as drop policy";
          tailf:cli-full-command;
          type empty;
        }
        leaf ecn {
          tailf:info "explicit congestion notification";
          tailf:cli-full-command;
          type empty;
        }
        leaf exponential-weighting-constant {
          tailf:info "weight for mean queue depth calculation";
          tailf:cli-full-command;
          type uint16 {
            range "1..16";
            tailf:info "<1-16>;;integer in 1..16 used in weighted "+
              "average to mean 2^number";
          }
        }
        leaf prec-based {
          tailf:info "Enable precedence-based WRED as drop policy";
          tailf:cli-full-command;
          type empty;
        }
        container precedence {
          tailf:info "parameters for each precedence value";
          tailf:cli-sequence-commands;
          tailf:cli-compact-syntax;
          leaf prec {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type precedence-type2;
          }
          uses random-detect-grouping;
        }
      }
      // policy-map * / class * / service-policy
      leaf service-policy {
        tailf:info "Configure Flow Next";
        tailf:cli-full-command;
        type string;
        tailf:non-strict-leafref {
          path "/ios:policy-map/name";
        }
      }
      // policy-map * / class * / set
      container set {
        tailf:info "Set QoS values";
        // policy-map * / class * / set atm-clp
        leaf atm-clp {
          tailf:info "Set ATM CLP bit to 1";
          tailf:cli-full-command;
          type empty;
        }
        // policy-map * / class * / set cos
        container cos {
          tailf:info "Set IEEE 802.1Q/ISL class of service/user "+
            "priority";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          choice cos-type {
            case a {
              leaf val {
                tailf:cli-drop-node-name;
                type uint16 {
                  range "0..7";
                  tailf:info "<0-7>;;cos value";
                }
              }
            }
            case b {
              leaf pack {
                tailf:cli-drop-node-name;
                type enumeration {
                  enum dscp {
                    tailf:code-name "pack_dscp";
                    tailf:info "Set value from packet dscp";
                  }
                  enum precedence {
                    tailf:code-name "pack_precedence";
                    tailf:info "Set value from packet "+
                      "precedence.";
                  }
                }
              }
              leaf table {
                tailf:info "Set codepoint value based on tablemap.";
                type string {
                  tailf:info "WORD;;table-map name";
                }
                tailf:non-strict-leafref {
                  path "/ios:table-map/name";
                }
              }
            }
          }
        }
        // policy-map * / class * / set discard-class
        leaf discard-class {
          tailf:info "Discard behavior identifier";
          tailf:cli-full-command;
          type uint16 {
            range "0..7";
            tailf:info "<0-7>;;Discard Class value";
          }
        }
        // policy-map * / class * / set dscp
        leaf dscp {
          tailf:info "Set DSCP in IP(v4) and IPv6 packets";
          tailf:cli-full-command;
          type dscp-type;
        }
        // policy-map * / class * / set fr-de
        leaf fr-de {
          tailf:info "Set FR DE bit to 1";
          tailf:cli-full-command;
          type empty;
        }
        // policy-map * / class * / set ip
        container ip {
          tailf:info "Set IP specific values";
          choice ip-choice {
            leaf dscp {
              tailf:info "Set IP DSCP (DiffServ CodePointint)";
              type dscp-type;
            }
            container precedence {
              tailf:info "Set IP precedence";
              presence "Set IP precedence";
              leaf precedence-val {
                tailf:cli-drop-node-name;
                type precedence-type;
              }
            }
          }
        }
        // policy-map * / class * / set mpls
        container mpls {
          tailf:info "Set MPLS specific values";
          container experimental {
            tailf:info "Set Experimental value";
            // 0-7
            container imposition {
              tailf:info "Set Experimental value at tag imposition";
              leaf exp-value {
                tailf:cli-drop-node-name;
                tailf:cli-full-command;
                type uint8 {
                  tailf:info "<0-7>;;Experimental value";
                  range "0..7";
                }
              }
              // dscp
              // precedence
            }
              // topmost
          }
        }
        // policy-map * / class * / set qos-group
        container qos-group {
          tailf:info "Set QoS Group";
          leaf qos-group-value {
            tailf:cli-drop-node-name;
            tailf:cli-full-command;
            type uint8 {
              range "0..99";
            }
          }
          // dscp
          // mpls
          // precedence
        }
      }
      // policy-map * / class * / shape
      container shape {
        tailf:info "Traffic Shaping";
        // policy-map * / class * / shape adaptive
        leaf adaptive {
          tailf:info "Enable Traffic Shaping adaptation to BECN";
          tailf:cli-full-command;
          type uint32 {
            range "8000..154400000";
            tailf:info "<8000-154400000>;;Lower Bound Target Bit "+
              "Rate (bits per second)";
          }
        }
        // policy-map * / class * / shape average
        container average {
          tailf:info "configure token bucket: CIR (bps) [Bc (bits) "+
            "[Be (bits)]], send out Bc only per interval";
          tailf:cli-sequence-commands;
          tailf:cli-compact-syntax;
          choice average-choice {
            case a {
              leaf bit-rate {
                tailf:cli-drop-node-name;
                type uint32 {
                  //range "8000..154400000";
                  //FIXME: what is range max?
                  tailf:info "<8000-max>;;Target Bit "+
                    "Rate (bits per second), the value "+
                    "needs to be a multiple of 8000";
                }
              }
              leaf bits-per-interval-sustained {
                tailf:cli-drop-node-name;
                type uint32 {
                  range "256..154400000";
                  tailf:info "<256-154400000>;;bits per "+
                    "interval, sustained. Needs to be "+
                    "multiple of 128. Recommend not to "+
                    "configure it, the algorithm will "+
                    "find out the best value";
                }
              }
              leaf bits-per-interval-excess {
                tailf:cli-drop-node-name;
                type uint32 {
                  range "0..154400000";
                  tailf:info "<0-154400000>;;bits per "+
                    "interval, excess. Needs to be "+
                    "multiple of 128. Bc will be used if "+
                    "you don't configure it.";
                }
              }
            }
            case b {
              leaf percent {
                tailf:info "% of interface bandwidth for "+
                  "Committed information rate";
                type percentage-type;
              }
              leaf burst-size-sustained {
                tailf:cli-incomplete-command;
                tailf:cli-drop-node-name;
                type uint16 {
                  range "10..2000";
                  tailf:info "<10-2000>;;Sustained burst "+
                    "size in msec";
                }
              }
              leaf ms {
                tailf:info "milliseconds";
                type empty;
              }
              container bse {
                tailf:cli-drop-node-name;
                tailf:cli-flatten-container;
                tailf:cli-sequence-commands;
                tailf:cli-compact-syntax;
                leaf burst-size-excess {
                  tailf:cli-incomplete-command;
                  type uint16 {
                    range "10..2000";
                    tailf:info "<10-2000>;;Excess burst "+
                      "size in msec";
                  }
                }
                leaf ms {
                  tailf:info "milliseconds";
                  type empty;
                }
              }
            }
          }
        }
        // policy-map * / class * / shape fecn-adapt
        leaf fecn-adapt {
          tailf:info "Enable Traffic Shaping reflection of FECN as "+
            "BECN";
          tailf:cli-full-command;
          type empty;
        }
        // policy-map * / class * / shape fr-voice-adapt
        container fr-voice-adapt {
          tailf:info "Enable rate adjustment depending on voice "+
            "presence";
          presence "Enable rate adjustment depending on voice "+
            "presence" ;
          leaf deactivation {
            type uint16 {
              range "1..10000";
              tailf:info "<1-10000>;;de-activation delay in "+
                "seconds";
            }
          }
        }
        // policy-map * / class * / shape max-buffers
        leaf max-buffers {
          tailf:cli-full-command;
          tailf:info "Set Maximum Buffer Limit";
          type uint16 {
            range "1..4096";
            tailf:info "<1-4096>;;Maximum Buffer Limit";
          }
        }
      }
      // policy-map * / class * / trust
      leaf trust {
        tailf:info "Set trust value for the class";
        type enumeration {
          enum cos {
            tailf:info "trust value for the class";
          }
          enum dscp {
            tailf:info "trust value for the class";
          }
          enum ip-precedence {
            tailf:info "trust value for the class";
          }
        }
      }
    }

    // policy-map * / description
    leaf "description" {
      tailf:info "Policy-Map description";
      tailf:cli-multi-value;
      type string {
        length "1..200";
        tailf:info "LINE;;Description of this policy-map (up to "
          +"200 characters)";
      }
    }
  }


  /// ========================================================================
  /// control-plane
  /// ========================================================================

  container control-plane {
    tailf:info "Configure control plane services";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-cp";
    presence true;

    // control-plane service-policy
    container service-policy {
      leaf "input" {
        tailf:info "Assign policy-map to the input of an interface";
        type string {
          tailf:info "WORD;;Policy map name";
        }
        tailf:non-strict-leafref {
          path "/ios:policy-map/name";
        }
      }
      leaf "output" {
        tailf:info "Assign policy-map to the output of an interface";
        type string {
          tailf:info "WORD;;Policy map name";
        }
        tailf:non-strict-leafref {
          path "/ios:policy-map/name";
        }
      }
    }
  }


  /// ========================================================================
  /// config-register
  /// ========================================================================

  leaf config-register {
    tailf:info "Define the configuration register";
    type string {
      tailf:info "<0x0-0xFFFF>  Config register number";
      pattern "[0-9xXa-fA-F].*";
    }
  }


  /// ========================================================================
  /// clock
  /// ========================================================================

  container clock {
    tailf:info "Configure time-of-day clock";

    // clock calendar-valid
    container calendar-valid {
      tailf:info "Calendar time is authoritative";
      presence true; //FIXME
    }

    // clock summer-time
    container summer-time {
      tailf:info "Configure summer (daylight savings) time";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf zone {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        tailf:cli-disallow-value "date|recurring";
        type string {
          tailf:info "WORD;;name of time zone in summer";
        }
      }
      choice summer-choice {
        case date-case {
          leaf date {
            tailf:info "Configure absolute summer time";
            type empty;
          }
        }
        case recurring-case {
          leaf recurring {
            tailf:info "Configure recurring summer time";
            type empty;
          }
          leaf start {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type union {
              type uint8 {
                tailf:info "<1-4>;;Week number to start";
                range "1..4";
              }
              type enumeration {
                enum first {
                  tailf:info "First week of the month";
                }
                enum last {
                  tailf:info "Last week of the month";
                }
              }
            }
          }
          leaf start-day {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type weekday-type {
              tailf:info "DAY;;Weekday to start";
            }
          }
          leaf start-month {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type month-type {
              tailf:info "MONTH;;Month to start";
            }
          }
          leaf start-time {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type hhmm-type {
              tailf:info "hh:mm;;Time to start (hh:mm)";
            }
          }
          leaf end {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type union {
              type uint8 {
                tailf:info "<1-4>;;Week number to end";
                range "1..4";
              }
              type enumeration {
                enum first {
                  tailf:info "First week of the month";
                }
                enum last {
                  tailf:info "Last week of the month";
                }
              }
            }
          }
          leaf end-day {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type weekday-type {
              tailf:info "DAY;;Weekday to end";
            }
          }
          leaf end-month {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type month-type {
              tailf:info "MONTH;;Month to end";
            }
          }
          leaf end-time {
            tailf:cli-drop-node-name;
            type hhmm-type {
              tailf:info "hh:mm;;Time to end (hh:mm)";
            }
          }
        }
      }
    }

    // clock timezone
    container timezone {
      tailf:info "Configure time zone";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf zone {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type string {
          tailf:info "WORD;;name of time zone";
        }
      }
      leaf offset {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        tailf:cli-incomplete-command;
        type enumeration {
          enum +;
          enum -;
        }
      }
      leaf hours {
        tailf:cli-drop-node-name;
        type int8 {
          tailf:info "<-23 - 23>;;Hours offset from UTC";
          range "-23..23";
        }
      }
      leaf minutes {
        tailf:cli-drop-node-name;
        type int8 {
          tailf:info "<0-59>;;Minutes ofset from UTC";
          range "0..59";
        }
      }
    }
  }


  /// ========================================================================
  /// gatekeeper
  /// ========================================================================

  container gatekeeper {
    tailf:info "Enter gatekeeper configuration mode";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-gk";

    // gatekeeper shutdown
    leaf shutdown {
      tailf:info "Shutdown Gatekeeper";
      type empty;
    }
    // more..
  }


  /// ========================================================================
  /// line
  /// ========================================================================

  container line {
    tailf:info "Configure a terminal line";

    // line aux 0
    list aux {
      tailf:info "Auxiliary line";
      tailf:cli-full-command;
      tailf:cli-mode-name "config-line";
      key first;
      max-elements 1;
      leaf first {
        type enumeration {
          enum "0" {
            tailf:info "<0-0>;;First Line number";
          }
        }
      }
      uses line-grouping;
    }

    // line con(sole) 0
    list console {
      tailf:info "Primary terminal line";
      tailf:cli-full-command;
      tailf:cli-mode-name "config-line";
      tailf:cli-allow-key-abbreviation;
      key first;
      max-elements 1;
      leaf first {
        type enumeration {
          enum "0" {
            tailf:info "<0-0>;;First Line number";
          }
        }
      }
      uses line-grouping;
    }

    container vty-single {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      // line vty *
      list vty {
        tailf:info "Virtual terminal";
        tailf:cli-full-command;
        tailf:cli-mode-name "config-line";
        key first;
        leaf first {
          type uint16 {
            tailf:info "<0-1869>;;First Line number";
            range "0..1869";
          }
        }
        uses line-grouping;
      }
    }

    // line vty * *
    list vty {
      tailf:info "Virtual terminal";
      tailf:cli-full-command;
      tailf:cli-mode-name "config-line";
      key "first last";
      leaf first {
        type uint16 {
          tailf:info "<0-1869>;;First Line number";
          range "0..1869";
        }
      }
      leaf last {
        type uint16 {
          tailf:info "<1-1869>;;Last Line number";
          range "1..1869";
        }
      }
      uses line-grouping;
    }
    //<0-6>    First Line number
  }


  /// ========================================================================
  /// logging
  /// ========================================================================

  container logging {
    tailf:info "Modify message logging facilities";

    // logging alarm
    leaf alarm {
      tailf:info "Configure syslog for alarms";
      tailf:cli-full-command;
      type union {
        type uint8 {
          tailf:info "<1-4>;;Alarm Logging severity level";
          range "1..4";
        }
        type enumeration {
          enum critical {
            tailf:info "Service affecting Condition       (severity=1)";
          }
          enum informational {
            tailf:info "Informational messages            (severity=4)";
          }
          enum major {
            tailf:info "Immediate action needed           (severity=2)";
          }
          enum minor {
            tailf:info "Minor warning conditions          (severity=3)";
          }
        }
      }
    }

    // logging buffered
    container buffered {
      tailf:info "Set buffered logging parameters";
      leaf size {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<4096-2147483647>;;Logging buffer size";
          range "4096..2147483647";
        }
      }
      leaf severity {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        type logging-level-type;
      }
      leaf xxml {
        tailf:alt-name xml;
        tailf:info "Enable logging in XML to XML logging buffer";
        tailf:cli-full-command;
        type uint32 {
          tailf:info "<4096-2147483647>;;XML logging buffer size";
          range "4096..2147483647";
        }
      }
    }

    // logging console
    leaf console {
      tailf:info "Set console logging parameters";
      type enumeration {
        enum alerts {
          tailf:info "Immediate action needed           (severity=1)";
        }
        enum critical {
          tailf:info "Critical conditions               (severity=2)";
        }
        enum debugging {
          tailf:info "Debugging messages                (severity=7)";
        }
        enum discriminator {
          tailf:info "Establish MD-Console association";
        }
        enum emergencies {
          tailf:info "System is unusable                (severity=0)";
        }
        enum errors {
          tailf:info "Error conditions                  (severity=3)";
        }
        enum filtered {
          tailf:info "Enable filtered logging";
        }
        enum guaranteed {
          tailf:info "Guarantee console messages";
        }
        enum informational {
          tailf:info "Informational messages            (severity=6)";
        }
        enum notifications {
          tailf:info "Normal but significant conditions (severity=5)";
        }
        enum warnings {
          tailf:info "Warning conditions                (severity=4)";
        }
        enum xml {
          tailf:info "Enable logging in XML";
        }
      }
    }

    // logging event
    container event {
      tailf:info "Global interface events";
      // logging event link-status
      container link-status {
        tailf:info "Globally enable/disable link UPDOWN message";
        leaf boot {
          tailf:info "Supress/Allow link UPDOWN messages during boot";
          type empty;
        }
        leaf global {
          type empty;
        }
        leaf "default" {
          tailf:info "Link UPDOWN messages for all interfaces";
          type empty;
        }
      }
    }

    // logging esm
    container esm {
      tailf:info "Set ESM filter restrictions";
      leaf "config" {
        tailf:info "Permit/Deny configuration changes from ESM filters";
        tailf:cli-full-command;
        type empty;
      }
    }

    // logging facility
    leaf facility {
      tailf:info "Facility parameter for syslog messages";
      type enumeration {
        enum auth {
          tailf:info "Authorization system";
        }
        enum cron {
          tailf:info "Cron/at facility";
        }
        enum daemon {
          tailf:info "System daemons";
        }
        enum kern {
          tailf:info "Kernel";
        }
        enum local0 {
          tailf:info "Local use";
        }
        enum local1 {
          tailf:info "Local use";
        }
        enum local2 {
          tailf:info "Local use";
        }
        enum local3 {
          tailf:info "Local use";
        }
        enum local4 {
          tailf:info "Local use";
        }
        enum local5 {
          tailf:info "Local use";
        }
        enum local6 {
          tailf:info "Local use";
        }
        enum local7 {
          tailf:info "Local use";
        }
        enum lpr {
          tailf:info "Line printer system";
        }
        enum mail {
          tailf:info "Mail system";
        }
        enum news {
          tailf:info "USENET news";
        }
        enum sys10 {
          tailf:info "System use";
        }
        enum sys11 {
          tailf:info "System use";
        }
        enum sys12 {
          tailf:info "System use";
        }
        enum sys13 {
          tailf:info "System use";
        }
        enum sys14 {
          tailf:info "System use";
        }
        enum sys9 {
          tailf:info "System use";
        }
        enum syslog {
          tailf:info "Syslog itself";
        }
        enum user {
          tailf:info "User process";
        }
        enum uucp {
          tailf:info "Unix-to-Unix copy system";
        }
      }
    }

    // logging history
    container history {
      tailf:info "Configure syslog history table";
      leaf size {
        tailf:info "Set history table size";
        type uint16 {
          tailf:info "<0-500>;History size";
        }
      }
      leaf severity-level {
        tailf:cli-drop-node-name;
        type union {
          type uint8 {
            tailf:info "<0-7>;;Logging severity level";
            range "0..7";
          }
          type enumeration {
            enum alerts {
              tailf:info "Immediate action needed           (severity=1)";
            }
            enum critical {
              tailf:info "Critical conditions               (severity=2)";
            }
            enum debugging {
              tailf:info "Debugging messages                (severity=7)";
            }
            enum emergencies {
              tailf:info "System is unusable                (severity=0)";
            }
            enum errors {
              tailf:info "Error conditions                  (severity=3)";
            }
            enum informational {
              tailf:info "Informational messages            (severity=6)";
            }
            enum notifications {
              tailf:info "Normal but significant conditions (severity=5)";
            }
            enum warnings {
              tailf:info "Warning conditions                (severity=4)";
            }
          }
        }
      }
    }

    // logging *
    list hostname {
      tailf:info "Hostname or A.B.C.D;;IP address of the logging host";
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key host;
      leaf host {
        tailf:cli-disallow-value "esm|alarm|buffered|facility"+
          "|history|rate-limit|source-interface|host|console";
        tailf:cli-full-command;
        type inet:host {
          tailf:info "Hostname or A.B.C.D";
        }
      }
    }

    // logging host *
    list host {
      tailf:info "Set syslog server IP address and parameters";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key host;
      leaf host {
        tailf:cli-disallow-value "esm|alarm|buffered|facility"+
          "|history|rate-limit|source-interface|host";
        tailf:cli-full-command;
        type inet:host {
          tailf:info "Hostname or A.B.C.D";
        }
      }

      leaf vrf {
        tailf:info "Set VRF option";
        type string {
          tailf:info "WORD;;VPN Routing/Forwarding instance name";
        }
      }

      leaf discriminator {
        tailf:info "Specify a message discriminator identifier for this "
          +"logging session";
        type string {
          tailf:info "WORD;;Message discriminator identifier for this logging "
            +"session (8 chars. max)";
        }
      }
      //  filtered              Enable filtered logging
      //  sequence-num-session  Include session sequence number tag in
      //                        syslog message
      //  session-id            Specify syslog message session ID tagging
      //  transport             Specify the transport protocol (default=UDP)
      //  xml                   Enable logging in XML
    }

    // logging rate-limit
    container rate-limit {
      tailf:info "Set messages per second limit";
      tailf:cli-sequence-commands;
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      leaf console {
        tailf:info "Rate limit only console messages";
        tailf:cli-optional-in-sequence;
        tailf:cli-incomplete-command;
        type empty;
      }
      leaf all {
        tailf:info "Rate limit all messages, including debug messages";
        tailf:cli-optional-in-sequence;
        tailf:cli-incomplete-command;
        type empty;
      }
      leaf rate {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<1-10000>;;Messages per second";
        }
      }
    }

    // logging source-interface
    container source-interface {
      tailf:info "Specify interface for source address in logging transactions";
      tailf:cli-diff-dependency "/ios:interface";
      uses interface-grouping;
    }

    // logging trap
    leaf trap {
      tailf:info "Set syslog server logging level";
      tailf:cli-full-command;
      type logging-level-type;
    }
  }


  /// ========================================================================
  /// mgcp
  /// ========================================================================

  container mgcp {
    tailf:info "Enable Media Gateway Control Protocol";

    container fax {
      tailf:info "Configure MGCP Fax Parameters";
      container t38 {
        tailf:info "Configure MGCP Fax T.38 Parameters";
        leaf ecm {
          tailf:info "Enable Error Correction Mode (ECM)";
          tailf:cli-full-command;
          type empty;
        }
      }
    }

    container profile {
      tailf:info "MGCP profile configuration mode";
      // WORD;;Enter the name(is limited to 32 characters) of the profile
      leaf default {
        tailf:info "Configure MGCP default profile";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// multilink
  /// ========================================================================

  container multilink {
    tailf:info "PPP multilink global configuration";

    // multilink bundle-name
    leaf bundle-name {
      tailf:info "Select method for naming multilink bundles";
      tailf:cli-full-command;
      type enumeration {
        enum authenticated {
          tailf:info "Use peer's authenticated name";
        }
        enum both {
          tailf:info "Use peer's authenticated name and endpoint "+
            "discriminator";
        }
        enum endpoint {
          tailf:info "Use peer's endpoint discriminator";
        }
        enum rfc {
          tailf:info "Use peer and local authenticated name and endpoint "+
            "discriminator";
        }
      }
    }

    // multilink virtual-template
    leaf virtual-template {
      tailf:info "virtual-template interface";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<1-4095>;;virtual template number";
        range "1..4095";
      }
    }
  }


  /// ========================================================================
  /// ntp
  /// ========================================================================

  container ntp {
    tailf:info "Configure NTP";
    tailf:cli-diff-dependency "/ios:interface";

    // ntp access-group
    container access-group {
      tailf:info "Control NTP access";
      leaf peer {
        tailf:info "Provide full access";
        type union {
          type uint16 {
            tailf:info "<1-99>;;Standard IP access list";
            range "1..99";
          }
          type uint16 {
            tailf:info "<1300-1999>;;Standard IP access list (expanded range)";
            range "1300..1999";
          }
        }
      }
      //  query-only  Allow only control queries
      leaf serve {
        tailf:info "Provide server and query access";
        type union {
          type uint16 {
            tailf:info "<1-99>;;Standard IP access list";
            range "1..99";
          }
          type uint16 {
            tailf:info "<1300-1999>;;Standard IP access list (expanded range)";
            range "1300..1999";
          }
        }
      }
      //  serve-only  Provide only server access
    }

    // authenticate  Authenticate time sources
    // authentication-key Authentication key for trusted time sources
    // broadcastdelay  Estimated round-trip delay

    // should be ignored, stripped by the java code
    // leaf clock-period {
    //   tailf:info "Length of hardware clock tick";
    //   type uint32 {
    //     tailf:info "<0-4294967295>;;Clock period in 2^-32 seconds";
    //   }
    // }
    // logging Enable NTP message logging
    // master Act as NTP master clock
    // max-associations Set maximum number of associations
    // peer Configure NTP peer

    // ntp server
    container server {
      tailf:info "Configure NTP server";
      uses ntp-server-grouping;
      list vrf {
        tailf:info "VPN Routing/Forwarding Information";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-incomplete-command;
        tailf:cli-diff-dependency "/ios:vrf/definition";
        tailf:cli-diff-dependency "/ios:ip/vrf";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;VPN Routing/Forwarding instance name";
          }
        }
        uses ntp-server-grouping;
      }
    }

    // ntp source
    container source {
      tailf:info "Configure interface for source address";
      uses interface-grouping;
    }

    // trusted-key Key numbers for trusted time sources

    // ntp update-calender
    leaf update-calendar {
      tailf:info "Periodically update calendar with NTP time";
      type empty;
    }
  }


  /// ========================================================================
  /// no mac-address-table
  /// ========================================================================

  container no {
    // Note: dirty construction
    container mac-address-table {
      tailf:info "Configure the MAC address table";
      container learning {
        tailf:info "Enable a MAC table learning feature";
        list vlan {
          tailf:info "Layer 2 table learning per VLAN";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key id;
          leaf id {
            type uint16 {
              tailf:info "<1-4094>;;VLAN ID";
              range "1..4094";
            }
          }
          leaf "module" {
            tailf:info "Layer 2 table learning per VLAN per module";
            type uint8 {
              tailf:info "<1-9>;;Module";
              range "1..9";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// privilege
  /// ========================================================================

  container privilege {
    tailf:info "Command privilege parameters";
    // privilege exec
    container exec {
      tailf:info "Exec mode";
      // privilege exec level
      list level {
        tailf:info "Set privilege level of command";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        tailf:cli-no-key-completion;
        key privilege;
        leaf privilege {
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          tailf:cli-suppress-range;
          type uint8 {
            tailf:info "<0-15>;;Privilege level";
          }
        }
        list command-list {
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-drop-node-name;
          tailf:cli-compact-syntax;
          tailf:cli-show-long-obu-diffs;
          tailf:cli-no-key-completion;
          tailf:cli-suppress-key-abbreviation;
          tailf:cli-no-match-completion;
          ordered-by user;
          key command;
          leaf command {
            tailf:cli-drop-node-name;
            tailf:cli-multi-word-key;
            type string {
              tailf:info "LINE;;Initial keywords of the command to modify";
              pattern "(show.*)|(write.*)";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// redundancy
  /// ========================================================================

  container redundancy {
    tailf:info "Enter redundancy mode";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-red";

    // redundancy maintenance-mode
    leaf maintenance-mode {
      tailf:info "Enable/Disable maintenance mode ";
      //FIXME: conform hook
      type empty;
    }
    //FIXME:  inter-device Configure redundancy parameters
    // for inter-device redundancy

    // redundancy main-cpu
    container main-cpu {
      tailf:info "Enter main-cpu mode";
      tailf:cli-add-mode;
      container auto-sync {
        leaf running-config {
          type empty;
        }
        leaf config-register {
          type empty;
        }
        leaf bootvar {
          type empty;
        }
      }
    }

    // redundancy mode
    leaf mode {
      tailf:info "redundancy mode for this chassis";
      type enumeration {
        enum rpr {
          tailf:info "Route Processor Redundancy";
        }
        enum rpr-plus {
          tailf:info "Route Processor Redundancy Plus";
        }
        enum sso {
          tailf:info "Stateful Switchover";
        }
        enum none {
          tailf:info "None";
        }
      }
    }
  }


  /// ========================================================================
  /// scheduler
  /// ========================================================================

  container scheduler {
    tailf:info "Scheduler parameters";
    // scheduler allocate
    container allocate {
      tailf:cli-sequence-commands;
      tailf:cli-compact-syntax;
      tailf:info "Guarantee CPU time for processes";
      leaf interrupt-time {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint16 {
          tailf:info "<400-60000>;;Microseconds handling network interrupts";
          range "400..60000";
        }
      }
      leaf process-time {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<100-4000>;;Microseconds running processes";
          range "100..4000";
        }
      }
      //heapcheck  Extra checking to validate memory
      //isr-watchdog Detect ISR Hang
      //process-watchdog Action for looping processes
    }
  }


  /// ========================================================================
  /// spanning-tree
  /// ========================================================================

  container spanning-tree {
    tailf:info "Spanning Tree Subsystem";
    // FIXME: syntax+info
    //  backbonefast  Enable BackboneFast Feature

    // spanning-tree etherchannel
    container etherchannel {
      tailf:info "Spanning tree etherchannel specific configuration";
      container guard {
        tailf:info "Configure guard features for etherchannel";
        leaf misconfig {
          tailf:info "Enable guard to protect against etherchannel "
            +"misconfiguration";
          type empty;
        }
      }
    }

    // spanning-tree extend
    container extend {
      tailf:info "Spanning Tree 802.1t extensions";
      leaf system-id {
        tailf:info "Extend system-id into priority portion of the bridge id ("
          +"PVST & Rapid PVST only)";
        type empty;
      }
    }
    //  logging       Enable Spanning tree logging

    // spanning-tree loopguard
    container loopguard {
      tailf:info "Spanning tree loopguard options";
      leaf "default" {
        tailf:info "Enable loopguard by default on all ports";
        type empty;
      }
    }

    // spanning-tree mst
    container mst {
      tailf:info "Multiple spanning tree configuration";
      list instance-range {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        tailf:cli-range-list-syntax;
        key id;
        leaf id {
          type uint16 {
          }
        }
        leaf priority {
          tailf:info "Set the bridge priority for the spanning tree";
          type uint16 {
            tailf:info "<0-61440>;;bridge priority in increments of 4096";
            range "0..61440";
          }
        }
        //  root      Configure switch as root
      }

      // spanning-tree mst configuration
      container configuration {
        tailf:info "Enter MST configuration submode";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-mst";
        // spanning-tree mst configuration / name
        leaf name {
          tailf:info "Set configuration name";
          type string {
            tailf:info "WORD;;Configuration name";
          }
        }
        // spanning-tree mst configuration / instance
        list instance {
          tailf:info "Map vlans to an MST instance";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key id;
          leaf id {
            type uint16 {
              tailf:info "<0-4094>;;MST instance id";
              range "0..4094";
            }
          }
          leaf-list vlan {
            tailf:info "Range of vlans to add to the instance mapping";
            tailf:cli-range-list-syntax;
            type uint16 {
              tailf:info "LINE;;vlan range ex: 1-65, 72, 300 -200";
            }
          }
        }
        //  private-vlan  Set private-vlan synchronization
        //  revision      Set configuration revision number
      }
      //  forward-time   Set the forward delay for the spanning tree
      //  hello-time     Set the hello interval for the spanning tree
      //  max-age        Set the max age interval for the spanning tree
      //  max-hops       Set the max hops value for the spanning tree
    }

    // spanning-tree optimize
    container optimize {
      // FIXME: does not exist on box but show running-config show it. Broken
      // spanning-tree optimize bpdu
      container bpdu {
        // spanning-tree optimize bpdu transmission
        leaf transmission {
          tailf:cli-boolean-no;
          tailf:cli-show-no; //??
          type boolean;
        }
      }
    }
    //  pathcost      Spanning tree pathcost options

    // spanning-tree portfast
    container portfast {
      tailf:info "Spanning tree portfast options";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf bdpu {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum bpdufilter {
            tailf:info "Enable portfast bdpu filter on this switch";
          }
          enum bpduguard {
            tailf:info "Enable portfast bpdu guard on this switch";
          }
        }
      }
      leaf "default" {
        tailf:info "Enable portfast by default on all access ports";
        type empty;
      }
    }
    //  transmit      STP transmit parameters
    //  uplinkfast    Enable UplinkFast Feature
    //  vlan          VLAN Switch Spanning Tree

    // spanning-tree mode
    leaf mode {
      tailf:info "Spanning tree operating mode";
      tailf:cli-show-with-default;
      tailf:cli-full-command;
      type enumeration {
        enum mst {
          tailf:info "Multiple spanning tree mode";
        }
        enum pvst {
          tailf:info "Per-Vlan spanning tree mode";
        }
        enum rapid-pvst {
          tailf:info "Per-Vlan rapid spanning tree mode";
        }
      }
    }

    // spanning-tree vlans-max-age
    container vlans-max-age {
      tailf:cli-drop-node-name;
      list vlan {
        tailf:info "VLAN Switch Spanning Tree";
        tailf:cli-range-list-syntax;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key id;
        leaf id {
          type uint16 {
            tailf:info "WORD;;vlan range, example: 1,3-5,7,9-11";
            range "1..4096";
          }
        }
        leaf max-age {
          tailf:info "Set the max age interval for the spanning tree";
          type uint8 {
            tailf:info "<6-40>;;maximum number of seconds the information in a "
              +"BPDU is valid";
            range "6..40";
          }
        }
      }
    }

    // spanning-tree vlans-forward-time
    container vlans-forward-time {
      tailf:cli-drop-node-name;
      list vlan {
        tailf:info "VLAN Switch Spanning Tree";
        tailf:cli-range-list-syntax;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key id;
        leaf id {
          type uint16 {
            tailf:info "WORD;;vlan range, example: 1,3-5,7,9-11";
            range "1..4096";
          }
        }
        leaf forward-time {
          tailf:info "Set the forward delay for the spanning tree";
          type uint8 {
            tailf:info "<4-30>;;number of seconds for the forward delay timer";
            range "4..30";
          }
        }
      }
    }

    // spanning-tree vlans-hello-time
    container vlans-hello-time {
      tailf:cli-drop-node-name;
      list vlan {
        tailf:info "VLAN Switch Spanning Tree";
        tailf:cli-range-list-syntax;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key id;
        leaf id {
          type uint16 {
            tailf:info "WORD;;vlan range, example: 1,3-5,7,9-11";
            range "1..4096";
          }
        }
        leaf hello-time {
          tailf:info "Set the hello interval for the spanning tree";
          type uint8 {
            tailf:info "<1-10>;;number of seconds between generation of config "
              +"BPDUs";
            range "1..10";
          }
        }
      }
    }

    // spanning-tree vlans-priority
    container vlans-priority {
      tailf:cli-drop-node-name;
      list vlan {
        tailf:info "VLAN Switch Spanning Tree";
        tailf:cli-range-list-syntax;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key id;
        leaf id {
          type uint16 {
            tailf:info "WORD;;vlan range, example: 1,3-5,7,9-11";
            range "1..4096";
          }
        }
        leaf priority {
          tailf:info "Set the bridge priority for the spanning tree";
          type uint16 {
            tailf:info "<0-61440>;;bridge priority in increments of 4096";
            range "0..61440";
          }
        }
      }
    }

    // spanning-tree vlans-root
    container vlans-root {
      tailf:cli-drop-node-name;
      list vlan {
        tailf:info "VLAN Switch Spanning Tree";
        tailf:cli-range-list-syntax;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key id;
        leaf id {
          type uint16 {
            tailf:info "WORD;;vlan range, example: 1,3-5,7,9-11";
            range "1..4096";
          }
        }
        container root {
          tailf:info "Configure switch as root";
          container primary {
            tailf:info "Configure this switch as primary root for this "
              +"spanning tree";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf diameter {
              tailf:info "Network diameter of this spanning tree";
              type uint8 {
                tailf:info "<2-7>;;Maximum number of bridges between any two "
                  +"end nodes";
                range "2..7";
              }
            }
            leaf hello-time {
              tailf:info "Hello interval for this spanning tree";
              type uint8 {
                tailf:info "<1-10>;;Hello interval in seconds";
                range "1..10";
              }
            }
          }
          container secondary {
            tailf:info "Configure switch as secondary root";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf diameter {
              tailf:info "Network diameter of this spanning tree";
              type uint8 {
                tailf:info "<2-7>;;Maximum number of bridges between any two "
                  +"end nodes";
                range "2..7";
              }
            }
            leaf hello-time {
              tailf:info "Hello interval for this spanning tree";
              type uint8 {
                tailf:info "<1-10>;;Hello interval in seconds";
                range "1..10";
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// dot1x
  /// ========================================================================

  container dot1x {
    tailf:info "IEEE 802.1X Global Configuration Commands";
    // dot1x critical
    container critical {
      tailf:info "Set 802.1x Critical Authentication parameters";
      leaf eapol {
        tailf:info "Send EAPOL-Success on successful Critical Authentication";
        type empty;
      }
      container recovery {
        tailf:info "Set 802.1x Critical Authentication Recovery parameters";
        leaf delay {
          tailf:info "Set 802.1x Critical Authentication Recovery Delay period";
          type uint16 {
            tailf:info "<1-10000>;;802.1x Critical Authentication Recovery "
              +"delay in milliseconds";
            range "1..10000";
          }
        }
      }
    }
    // dot1x system-auth-control
    leaf system-auth-control {
      tailf:info "Enable or Disable SysAuthControl";
      type empty;
    }
  }


  /// ========================================================================
  /// power
  /// ========================================================================

  container power {
    tailf:info "Power configure";

    //  cycle            power cycle a module (deprecated)
    //  enable           module slot power control

    leaf redundancy-mode {
      tailf:info "set power supply redundancy mode";
      type enumeration {
        enum combined {
          tailf:info "combine power supply outputs (no redundancy)";
        }
        enum redundant {
          tailf:info "either power supply can operate system (redundancy)";
        }
      }
    }
  }


  /// ========================================================================
  /// parameter-map
  /// ========================================================================

  container parameter-map {
    tailf:info "parameter map";

    container "type" {
      tailf:info "parameter map type";
      list inspect {
        tailf:info "inspect parameter-map";
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;parameter-map name";
          }
        }
        leaf alert {
          tailf:info "Turn on/off alert";
          type enumeration {
            enum off {
              tailf:info "Turn off alert";
            }
            enum on {
              tailf:info "Turn on alert";
            }
          }
        }
        leaf audit-trail {
          tailf:info "Turn on/off audit trail";
          type enumeration {
            enum off {
              tailf:info "Turn off audit trail";
            }
            enum on {
              tailf:info "Turn on audit trail";
            }
          }
        }
        leaf dns-timeout {
          tailf:info "Specify timeout for DNS";
          type uint32 {
            tailf:info "<1-2147483>;;Timeout in seconds";
            range "1..2147483";
          }
        }
        container icmp {
          tailf:info "Config timeout values for icmp";
          leaf idle-time {
            tailf:info "Specify timeout for icmp";
            type uint32 {
              tailf:info "<1-2147483>;;Timeout in seconds";
              range "1..2147483";
            }
          }
        }
        container max-incomplete {
          tailf:info "Specify maximum number of incomplete connections before "
            +"clamping";
          leaf high {
            tailf:info "Specify high-watermark for clamping";
            type uint32 {
              tailf:info "<1-2147483647>;;Number of connections";
              range "1..2147483647";
            }
          }
          leaf low {
            tailf:info "Specify low-watermark for clamping";
            type uint32 {
              tailf:info "<1-2147483647>;;Number of connections";
              range "1..2147483647";
            }
          }
        }
        container one-minute {
          tailf:info "Specify one-minute-sample watermarks for clamping";
          leaf high {
            tailf:info "Specify high-watermark for clamping";
            type uint32 {
              tailf:info "<1-2147483647>;;Number of connections";
              range "1..2147483647";
            }
          }
          leaf low {
            tailf:info "Specify low-watermark for clamping";
            type uint32 {
              tailf:info "<1-2147483647>;;Number of connections";
              range "1..2147483647";
            }
          }
        }
        container sessions {
          tailf:info "Maximum number of inspect sessions";
          leaf maximum {
            tailf:info "Maximum sessions";
            type uint32 {
              tailf:info "<1-2147483647>;;Number of sessions";
              range "1..2147483647";
            }
          }
        }
        container tcp {
          tailf:info "Config timeout values for tcp connections";
          leaf finwait-time {
            tailf:info "Specify timeout for TCP connections after a FIN";
            type uint32 {
              tailf:info "<1-2147483>;;Timeout in seconds";
              range "1..2147483";
            }
          }
          leaf idle-time {
            tailf:info "Specify idle timeout for tcp connections";
            type uint32 {
              tailf:info "<1-2147483>;;Timeout in seconds";
              range "1..2147483";
            }
          }
          container max-incomplete {
            tailf:info "Specify max half-open connection per host";
            leaf host {
              tailf:info "Specify max half-open connection per host";
              type uint32 {
                tailf:info "<1-4294967295>;;half-open sessions";
                range "1..4294967295";
              }
            }
          }
          leaf synwait-time {
            tailf:info "Specify timeout for TCP connections after a SYN and no";
            type uint32 {
              tailf:info "<1-2147483>;;Timeout in seconds";
              range "1..2147483";
            }
          }
        }
        container udp {
          tailf:info "Config timeout values for udp flows";
          leaf idle-time {
            tailf:info "Specify idle timeout for udp";
            type uint32 {
              tailf:info "<1-2147483>;;Timeout in seconds";
              range "1..2147483";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// vpdn
  /// ========================================================================

  container vpdn {
    tailf:info "Virtual Private Dialup Network";

    leaf authen-before-forward {
      tailf:info "Authenticate a user locally before tunnelling";
      type empty;
    }
    leaf enable {
      tailf:info "Enable VPDN";
      type empty;
    }
    leaf-list search-order {
      ordered-by user;
      tailf:info "Configure the order to search different VPDN tunnel types";
      type enumeration {
        enum dnis {
          tailf:info "Tunnel based on DNIS";
        }
        enum domain {
          tailf:info "Tunnel based on domain";
        }
        enum multihop-hostname {
          tailf:info "Tunnel based on peer hostname from ingress tunnel";
        }
      }
    }
  }


  /// ========================================================================
  /// bba-group
  /// ========================================================================

  container bba-group {
    tailf:info "Configure BBA Group";

    // bba-group pppoe *
    list pppoe {
      tailf:info "PPPoE type";
      key id;
      leaf id {
        type union {
          type string {
            tailf:info "WORD;;BBA Group name";
          }
          type enumeration {
            enum global {
              tailf:info "PPPoE global group";
            }
          }
        }
      }
      container vendor-tag {
        tailf:info "PPPoE Vendor Specific Tag";
        container circuit-id {
          tailf:info "Circuit-Id";
          leaf service {
            tailf:info "Enable processing";
            type empty;
          }
        }
        container dsl-sync-rate {
          tailf:info "DSL-Sync-Rate";
          leaf service {
            tailf:info "Enable processing";
            type empty;
          }
        }
        container remote-id {
          tailf:info "Remote-Id";
          leaf service {
            tailf:info "Enable processing";
            type empty;
          }
        }
        leaf strip {
          tailf:info "Strip all vendor tags";
          type empty;
        }
      }
      leaf virtual-template {
        tailf:info "BBA virtual template command";
        type uint16 {
          tailf:info "<1-4095>;;Virtual Template interface number";
          range "1..4095";
        }
      }
    }
  }


  /// ========================================================================
  /// mac
  /// ========================================================================

  container mac {
    tailf:info "Global MAC configuration subcommands";
    container access-list {
      tailf:info "Named access-list";
      list extended {
        tailf:info "Extended Access List";
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;access-list name";
          }
        }
        //  default  Set a command to its defaults
        container deny {
          tailf:info "Specify packets to reject";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          container source {
            tailf:cli-compact-syntax;
            tailf:cli-flatten-container;
            tailf:cli-drop-node-name;
            choice target-choice {
              leaf any {
                tailf:info "any source MAC address";
                type empty;
              }
              leaf host {
                tailf:info "A single source host";
                type string {
                  tailf:info "H.H.H;;48-bit source MAC address";
                }
              }
            }
          }
          container dest {
            tailf:cli-compact-syntax;
            tailf:cli-flatten-container;
            tailf:cli-drop-node-name;
            choice target-choice {
              leaf any {
                tailf:info "any destination MAC address";
                type empty;
              }
              leaf host {
                tailf:info "A single destination host";
                type string {
                  tailf:info "H.H.H;;48-bit destination MAC address";
                }
              }
            }
          }
        }
        container permit {
          tailf:info "Specify packets to forward";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          container source {
            tailf:cli-compact-syntax;
            tailf:cli-flatten-container;
            tailf:cli-drop-node-name;
            choice target-choice {
              leaf any {
                tailf:info "any source MAC address";
                type empty;
              }
              leaf host {
                tailf:info "A single source host";
                type string {
                  tailf:info "H.H.H;;48-bit source MAC address";
                }
              }
            }
          }
          container dest {
            tailf:cli-compact-syntax;
            tailf:cli-flatten-container;
            tailf:cli-drop-node-name;
            choice target-choice {
              leaf any {
                tailf:info "any destination MAC address";
                type empty;
              }
              leaf host {
                tailf:info "A single destination host";
                type string {
                  tailf:info "H.H.H;;48-bit destination MAC address";
                }
              }
            }
          }
        }
      }
    }
    //   address-table    Configure the MAC address table
    //   packet-classify  packet classification by mac ACL
  }


  /// ========================================================================
  /// tacacs-server
  /// ========================================================================

  container tacacs-server {
    tailf:info "Modify TACACS query parameters";

    // tacacs-server host *
    list host {
      tailf:info "Specify a TACACS server";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      key name;
      leaf name {
        type host-type {
          tailf:info "Hostname or A.B.C.D;;IP address of TACACS server";
        }
      }
      // tacacs-server host * port
      leaf port {
        tailf:info "TCP port for TACACS+ server (default is 49)";
        type uint16 {
          tailf:info "<1-65535>;;Port number";
          range "1..65535";
        }
      }
      // tacacs-server host * timeout
      leaf timeout {
        tailf:info "Time to wait for this TACACS server to reply "+
          "(overrides default)";
        type uint16 {
          tailf:info "<1-1000>;;Timeout value in seconds to wait for "+
            "server to reply";
          range "1..1000";
        }
      }
    }

    // tacacs-server timeout
    leaf timeout {
      tailf:info "Time to wait for a TACACS server to reply";
      type uint16 {
        tailf:info "<1-1000>;;Wait time (default 5 seconds)";
        range "1..1000";
      }
      default 5;
    }

    // tacacs-server directed-request
    container directed-request {
      tailf:info "Allow user to specify tacacs server to use with `@server'";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      presence true;
      leaf restricted {
        tailf:info "restrict queries to directed request servers only";
        tailf:cli-optional-in-sequence;
        type empty;
      }
      leaf no-truncate {
        tailf:info "Do not truncate the @hostname from username.";
        type empty;
      }
    }

    // tacacs-server key
    container "key" {
      tailf:info "Set TACACS+ encryption key.";
      tailf:cli-compact-syntax;
      //tailf:cli-flatten-container; (makes 'tacacs-server' disappear)
      tailf:cli-sequence-commands;
      leaf encryption {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum 0 {
            tailf:info "Specifies an UNENCRYPTED key will follow";
          }
          enum 7 {
            tailf:info "Specifies HIDDEN key will follow";
          }
        }
      }
      leaf "key" {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        tailf:cli-multi-value;
        type string {
          tailf:info "LINE;;The UNENCRYPTED (cleartext) shared key";
        }
      }
    }
  }


  /// ========================================================================
  /// upgrade
  /// ========================================================================

  container upgrade {
    tailf:info "Global upgrade configuration subcommands";

    // upgrade fpd
    container fpd {
      tailf:info "Configure field programmable devices upgrade options";
      // upgrade fpd auto
      leaf auto {
        tailf:info "Auto upgrade all FPD images";
        type empty;
      }
      // upgrade fpd path
      leaf "path" {
        tailf:info "Set path to locate the FPD image package file for auto "+
          "upgrade";
        type string;
      }
    }
  }


  /// ========================================================================
  /// vtp
  /// ========================================================================

  container vtp {
    tailf:info "Configure global VTP state";

    // vtp file
    leaf file {
      tailf:info "Configure IFS filesystem file where VTP configuration is "
        +"stored.";
      type string {
        tailf:info "WORD;;The ascii name of the IFS filesystem file where VTP "
          +"configuration is stored.";
      }
    }

    // vtp interface
    leaf interface {
      tailf:info "Configure interface as the preferred source for the VTP IP "
        +"updater address.";
      type string {
        tailf:info "WORD;;The name of the interface providing the VTP updater "
          +"ID for this device.";
      }
    }

    // vtp password
    leaf password {
      tailf:info "Set the password for the VTP administrative domain";
      type string {
        tailf:info "WORD;;The ascii password for the VTP administrative "
          +"domain.";
      }
    }

    // vtp pruning
    leaf pruning {
      tailf:info "Set the adminstrative domain to permit pruning";
      type empty;
    }

    // vtp version
    leaf version {
      tailf:info "Set the adminstrative domain to VTP version";
      type uint8 {
        tailf:info "<1-3>;;Set the adminstrative domain VTP version number";
        range "1..3";
      }
    }

    // vtp domain
    leaf domain {
      tailf:info "Set the name of the VTP administrative domain.";
      type string;
    }

    // vtp mode
    leaf mode {
      tailf:info "Configure VTP device mode";
      type enumeration {
        enum client {
          tailf:info "Set the device to client mode.";
        }
        enum off {
          tailf:info "Set the device to off mode.";
        }
        enum server {
          tailf:info "Set the device to server mode.";
        }
        enum transparent {
          tailf:info "Set the device to transparent mode.";
        }
      }
    }

  }


  /// ========================================================================
  /// rep
  /// ========================================================================

  container rep {
    tailf:info "Resilient Ethernet Protocol characteristics";

    // rep admin
    container admin {
      tailf:info "administrative configuration";
      list vlan {
        tailf:info "VLAN";
        key name;
        leaf name {
          type uint16 {
            tailf:info "<2-4094>;;between 2 and 4094";
            range "2..4094";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// xconnect
  /// ========================================================================

  container xconnect {
    container logging {

      // xconnect pseudowire
      container pseudowire {
        leaf "status" {
          tailf:cli-full-command;
          type empty;
        }
      }

      // xconnect redundancy2
      leaf redundancy {
        tailf:cli-full-command;
        type empty;
      }
    }
  }


  /// ========================================================================
  /// fabric
  /// ========================================================================

  container fabric {
    tailf:info "Catalyst 6000 crossbar fabric configuration commands";
    //  buffer-reserve  Reserve FIFO buffer
    //  clear-block     Enable clear-block congestion control for
    //                  fabric channels
    //  error-recovery  Fabric error-recovery
    //  required        Fabric required for system to operate

    // fabric switching-mode
    container switching-mode {
      tailf:info "Switching mode settings";
      container allow {
        tailf:info "Allow settings";
        choice allow-choice {
          leaf bus-mode {
            tailf:info "Allow switching in bus mode for modules";
            type empty;
          }
          container truncated {
            tailf:info "Truncated switching mode";
            presence true;
            leaf threshold {
              tailf:info "Number of SFM-capable modules for truncated "
                +"switching mode. Switch applies the threshold only when the "
                +"mode is disallowed. Switch ignores the threshold when the "
                +"truncated mode is allowed";
              type uint8 {
                tailf:info "<1-9>;;Threshold for truncated switching mode.";
                range "1..9";
              }
            }
          }
        }
      }
      container force {
        tailf:info "Force modules to different switching modes";
        leaf bus-mode {
          tailf:info "Switching mode of service modules will be forced to bus-"
            +"mode by powercycling it.";
          type empty;
        }
      }
    }
    //  timer           set poll time (in Seconds) for drop counter
    //                  timestamp and peak utilization
  }


  /// ========================================================================
  /// port-channel
  /// ========================================================================

  container port-channel {
    tailf:info "EtherChannel configuration";
    //  hash-distribution  Hash Distribution method

    // port-channel load-balance
    leaf load-balance {
      tailf:info "Load Balancing method";
      type enumeration {
        enum dst-ip {
          tailf:info "Dst IP Addr";
        }
        enum dst-mac {
          tailf:info "Dst Mac Addr";
        }
        enum dst-mixed-ip-port {
          tailf:info "Dst IP Addr and TCP/UDP Port";
        }
        enum dst-port {
          tailf:info "Dst TCP/UDP Port";
        }
        enum mpls {
          tailf:info "Load Balancing for MPLS packets";
        }
        enum src-dst-ip {
          tailf:info "Src XOR Dst IP Addr";
        }
        enum src-dst-mac {
          tailf:info "Src XOR Dst Mac Addr";
        }
        enum src-dst-mixed-ip-port {
          tailf:info "Src XOR Dst IP Addr and TCP/UDP Port";
        }
        enum src-dst-port {
          tailf:info "Src XOR Dst TCP/UDP Port";
        }
        enum src-ip {
          tailf:info "Src IP Addr";
        }
        enum src-mac {
          tailf:info "Src Mac Addr";
        }
        enum src-mixed-ip-port {
          tailf:info "Src IP Addr and TCP/UDP Port";
        }
        enum src-port {
          tailf:info "Src TCP/UDP Port";
        }
      }
    }
    //  per-module         per-module configuration
  }


  /// ========================================================================
  /// l2
  /// ========================================================================

  container l2 {
    tailf:info "Layer 2 configuration";

    // l2 vfi *
    list vfi {
      tailf:info "Configure a virtual forwarding instance";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;VFI name";
        }
      }
      // l2 vfi * point-to-point
      leaf point-to-point {
        tailf:info "Point-to-point configuration mode";
        tailf:cli-full-command;
        type empty;
      }
      // autodiscovery  Multipoint autodiscovery configuration mode
    }
  }


  /// ========================================================================
  /// l2protocol-tunnel
  /// ========================================================================

  container l2protocol-tunnel {
    tailf:info "Tunnel Layer2 protocols";

    // l2protocol-tunnel cos
    leaf cos {
      tailf:info "Class of Service";
      type uint8 {
        tailf:info "<0-7>;;priority value";
        range "0..7";
      }
    }

    // l2protocol-tunnel global
    container global {
      tailf:info "Global settings";
      leaf drop-threshold {
        tailf:info "L2PT packets drop threshold";
        type uint16 {
          tailf:info "<100-20000>;;Packets per second";
          range "100..20000";
        }
      }
    }
  }


  /// ========================================================================
  /// system
  /// ========================================================================

  container system {
    tailf:info "Set the system configuration";

    // system env
    container env {
      tailf:info "Set the system environment settings";
      container temperature {
        tailf:info "Set the system temperature settings";
        container threshold {
          tailf:info "Set the system temperature thresholds";
          leaf yellow {
            tailf:info "Set the yellow threshold";
            type uint8 {
              tailf:info "<0-25>;;Delta value from Red threshold in Degree "
                +"Celsius";
              range "0..25";
            }
          }
        }
      }
    }

    // system mtu
    container mtu {
      tailf:info "Set the system Maximum Transmission Unit (MTU)";
      leaf size {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<1500-1998>;;MTU size in bytes";
          range "1500..1998";

        }
      }
      leaf jumbo {
        tailf:info "Set Jumbo MTU value for GigabitEthernet or "
          +"TenGigabitEthernet interfaces";
        type uint16 {
          tailf:info "<1500-9000>;;Jumbo MTU size in bytes";
          range "1500..9000";
        }
      }
      leaf routing {
        tailf:info "Set the Routing MTU for the system";
        type uint16 {
          tailf:info "<1500-1500>;;MTU size in bytes";
          range "1500";
        }
      }
    }
  }


  /// ========================================================================
  /// errdisable
  /// ========================================================================

  container errdisable {
    tailf:info "Error disable";

    // errdisable detect
    container detect {
      tailf:info "Error disable detection";
      container cause {
        tailf:info "Enable error disable detection for application";
        leaf all {
          tailf:info "Enable error detection on all cases";
          tailf:cli-full-command;
          type empty;
        }
        leaf arp-inspection {
          tailf:info "Enable error detection for arp inspection";
          tailf:cli-full-command;
          type empty;
        }
        leaf bpduguard {
          tailf:info "Enable error detection on bpdu-guard";
          tailf:cli-full-command;
          type empty;
        }
        leaf dhcp-rate-limit {
          tailf:info "Enable error detection on dhcp-rate-limit";
          tailf:cli-full-command;
          type empty;
        }
        leaf dtp-flap {
          tailf:info "Enable error detection on dtp-flapping";
          tailf:cli-full-command;
          type empty;
        }
        leaf gbic-invalid {
          tailf:info "Enable error detection on gbic-invalid";
          tailf:cli-full-command;
          type empty;
        }
        leaf inline-power {
          tailf:info "Enable error detection for inline-power";
          tailf:cli-full-command;
          type empty;
        }
        leaf l2ptguard {
          tailf:info "Enable timer to recover from l2protocol-tunnel error "+
            "disable state";
          tailf:cli-full-command;
          type empty;
        }
        leaf link-flap {
          tailf:info "Enable error detection on linkstate-flapping";
          tailf:cli-full-command;
          type empty;
        }
        leaf loopback {
          tailf:info "Enable error detection on loopback";
          tailf:cli-full-command;
          type empty;
        }
        leaf mlacp-minlink {
          tailf:cli-full-command;
          type empty;
        }
        leaf pagp-flap {
          tailf:info "Enable error detection on pagp-flapping";
          tailf:cli-full-command;
          type empty;
        }
        leaf pppoe-ia-rate-limit {
          tailf:info "Enable error detection on PPPoE IA rate-limit";
          tailf:cli-full-command;
          type empty;
        }
        leaf security-violation {
          tailf:info "Enable error detection on 802.1x-guard";
          tailf:cli-full-command;
          type empty;
        }
        leaf sfp-config-mismatch {
          tailf:info "Enable error detection on SFP config mismatch";
          tailf:cli-full-command;
          type empty;
        }
        leaf small-frame {
          tailf:info "Enable error detection on small_frame";
          tailf:cli-full-command;
          type empty;
        }
      }
    }

    // errdisable flap-setting
    container flap-setting {
      tailf:info "Error disable flap detection setting";
      container cause {
        tailf:info "Set error disable flap parameters for application";
        container dtp-flap {
          tailf:info "Set the variables related to detection of dtp flaps";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf max-flaps {
            tailf:info "maximum flaps allowed before setting to errdisable";
            type uint8 {
              tailf:info "<1-100>;;flap count";
              range "1..100";
            }
          }
          leaf time {
            tailf:info "time period the flaps are counted";
            type uint8 {
              tailf:info "<1-120>;;flap count time";
              range "1..120";
            }
          }
        }
        container link-flap {
          tailf:info "Set the variables related to detection of link flaps";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf max-flaps {
            tailf:info "maximum flaps allowed before setting to errdisable";
            type uint8 {
              tailf:info "<1-100>;;flap count";
              range "1..100";
            }
          }
          leaf time {
            tailf:info "time period the flaps are counted";
            type uint8 {
              tailf:info "<1-120>;;flap count time";
              range "1..120";
            }
          }
        }
        container pagp-flap {
          tailf:info "Set the variables related to detection of pagp flaps";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf max-flaps {
            tailf:info "maximum flaps allowed before setting to errdisable";
            type uint8 {
              tailf:info "<1-100>;;flap count";
              range "1..100";
            }
          }
          leaf time {
            tailf:info "time period the flaps are counted";
            type uint8 {
              tailf:info "<1-120>;;flap count time";
              range "1..120";
            }
          }
        }
      }
    }

    // errdisable recovery
    container recovery {
      tailf:info "Error disable recovery";
      // errdisable recovery cause
      container cause {
        tailf:info "Enable error disable recovery for application";
        leaf all {
          tailf:info "Enable timer to recover from all error causes";
          type empty;
        }
        leaf arp-inspection {
          tailf:info "Enable timer to recover from arp inspection error "
            +"disable state";
          type empty;
        }
        leaf bpduguard {
          tailf:info "Enable timer to recover from BPDU Guard error";
          type empty;
        }
        leaf channel-misconfig {
          tailf:info "(STP)  Enable timer to recover from channel misconfig "
            +"error";
          type empty;
        }
        leaf dhcp-rate-limit {
          tailf:info "Enable timer to recover from dhcp-rate-limit error";
          type empty;
        }
        leaf dtp-flap {
          tailf:info "Enable timer to recover from dtp-flap error";
          type empty;
        }
        leaf gbic-invalid {
          tailf:info "Enable timer to recover from invalid GBIC error";
          type empty;
        }
        leaf inline-power {
          tailf:info "Enable timer to recover from inline-power error";
          type empty;
        }
        leaf l2ptguard {
          tailf:info "Enable timer to recover from l2protocol-tunnel error "
            +"disable state";
          type empty;
        }
        leaf link-flap {
          tailf:info "Enable timer to recover from link-flap error";
          type empty;
        }
        leaf link-monitor-failure {
          type empty;
        }
        leaf loopback {
          tailf:info "Enable timer to recover from loopback error";
          type empty;
        }
        leaf mac-limit {
          tailf:info "Enable timer to recover from mac limit disable state";
          type empty;
        }
        leaf mlacp-minlink {
          tailf:cli-full-command;
          type empty;
        }
        container oam-remote-failure {
          tailf:cli-display-separated;
          presence true;
          leaf critical-event {
            tailf:cli-full-command;
            type empty;
          }
          leaf dying-gasp {
            tailf:cli-full-command;
            type empty;
          }
          leaf link-fault {
            tailf:cli-full-command;
            type empty;
          }
        }
        leaf pagp-flap {
          tailf:info "Enable timer to recover from pagp-flap error";
          type empty;
        }
        leaf port-mode-failure {
          tailf:info "Enable timer to recover from port mode change failure";
          type empty;
        }
        leaf pppoe-ia-rate-limit {
          tailf:info "Enable timer to recover from PPPoE IA rate-limit error";
          type empty;
        }
        leaf psp {
          type empty;
        }
        leaf psecure-violation {
          tailf:info "Enable timer to recover from psecure violation error";
          type empty;
        }
        leaf security-violation {
          tailf:info "Enable timer to recover from 802.1x violation error";
          type empty;
        }
        leaf sfp-config-mismatch {
          tailf:info "Enable timer to recover from SFP config mismatch error";
          type empty;
        }
        leaf small-frame {
          tailf:info "Enable timer to recover from small frame error";
          type empty;
        }
        leaf storm-control {
          tailf:info "Enable timer to recover from storm-control error";
          type empty;
        }
        leaf udld {
          tailf:info "Enable timer to recover from udld error";
          type empty;
        }
        leaf unicast-flood {
          //fixme tailf:info
          type empty;
        }
        leaf vmps {
          tailf:info "Enable timer to recover from vmps shutdown error";
          type empty;
        }
      }
      leaf interval {
        tailf:info "Error disable recovery timer value";
        type uint32 {
          tailf:info "<30-86400>;;timer-interval(sec)";
          range "30..86400";
        }
      }
    }
  }


  /// ========================================================================
  /// monitor
  /// ========================================================================

  container monitor {
    tailf:info "Monitoring different system events";

    // monitor event-trace
    container event-trace {
      tailf:info "Tracing of system events";
      //  all-traces       Configure merged event traces
      //  datainteg        Data integrity events
      //  ipv6             IPv6
      //  sequence-number  Display event trace entries with sequence number
      //  stacktrace       Display stack trace stored with event trace entries
      //  timestamps       Format of event trace timestamps
    }

    // monitor session *
    list session {
      tailf:info "Configure a SPAN session";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-incomplete-command;
      key id;
      leaf id {
        type uint8 {
          tailf:info "<1-66>;;SPAN session number";
          range "1..66";
        }
      }
      // monitor session * destination
      container destination {
        tailf:info "SPAN destination interface or VLAN";
        leaf interface {
          tailf:info "SPAN destination interface";
          type string;
        }
        // monitor session * destination encapsulation
        leaf encapsulation {
          tailf:cli-hide-in-submode;
          tailf:info "Set encapsulation for destination interface";
          type enumeration {
            enum dot1q {
              tailf:info "interface uses only dot1q encapsulation";
            }
            enum isl {
              tailf:info "interface uses only isl encapsulation";
            }
            enum replicate {
              tailf:info "interface replicates source encapsulation";
            }
          }
        }

        leaf ingress {
          tailf:info "Enable ingress traffic forwarding";
          tailf:cli-hide-in-submode;
          type empty;
        }

        leaf ingress-encap {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          when "../ingress" {
            tailf:dependency "../ingress";
          }
          type enumeration {
            enum dot1q {
              tailf:info "ingress forwarding using dot1q encapsulation";
            }
            enum isl {
              tailf:info "ingress forwarding using isl encapsulation";
            }
            enum untagged {
              tailf:info "ingress forwarding using untagged encapsulation";
            }
          }
        }

        leaf vlan {
          tailf:info "Set default VLAN for untagged ingress traffic";
          tailf:cli-hide-in-submode;
          when "../ingress" {
            tailf:dependency "../ingress";
          }
          type uint16 {
            tailf:info "<1-4094>;;Default VLAN for untagged ingress traffic";
            range "1..4094";
          }
        }
        //  remote     SPAN destination Remote
      }

      //  filter       SPAN filter VLAN
      // monitor session * source
      container source {
        tailf:info "SPAN source interface, VLAN ";
        container interface {
          tailf:info "SPAN source interface";
          tailf:cli-diff-dependency "/ios:interface";
          uses interface-grouping;
        }
        container vlan {
          tailf:info "SPAN source VLAN";
          tailf:cli-compact-syntax;
          tailf:cli-flatten-container;
          tailf:cli-sequence-commands;
          leaf vlan {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<1-4094>;;SPAN source VLAN";
              range "1..4094";
            }
          }
          // ,     Specify another range of VLANs
          // -     Specify a range of VLANs
          leaf direction {
            tailf:cli-drop-node-name;
            type enumeration {
              enum both {
                tailf:info "Monitor received and transmitted traffic";
              }
              enum rx {
                tailf:info "Monitor received traffic only";
              }
              enum tx {
                tailf:info "Monitor transmitted traffic only";
              }
            }
          }
        }
        //  remote     SPAN source Remote
      }
    }
  }


  /// ========================================================================
  /// tftp-server
  /// ========================================================================

  list tftp-server {
    tailf:info "Provide TFTP service for netload requests";
    tailf:cli-suppress-mode;
    tailf:cli-delete-when-empty;
    tailf:cli-compact-syntax;
    key name;
    leaf name {
      type string;
    }
    //TODO
  }


  /// ========================================================================
  /// radius-server
  /// ========================================================================

  container radius-server {
    tailf:info "Modify RADIUS query parameters";

    //  attribute           Customize selected radius attributes
    //  authorization       Authorization processing information
    //  backoff             Retry backoff pattern(Default is retransmits with
    //                      constant delay)
    //  cache               AAA auth cache default server group
    //  challenge-noecho    Data echoing to screen is disabled during
    //                      Access-Challenge
    //  configure-nas       Attempt to upload static routes and IP pools
    //                      at startup
    //  dead-criteria       Set the criteria used to decide when a radius
    //                      server is marked dead
    //  deadtime            Time to stop using a server that doesn't respond
    //  directed-request    Allow user to specify radius server to use
    //                      with `@server'
    //  domain-stripping    Strip the domain from the username

    // radius-server host *
    list host {
      tailf:info "Specify a RADIUS server";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key id;
      leaf id {
        type string {
          tailf:info "Hostname or A.B.C.D;;IP address of RADIUS server";
        }
      }
      // radius-server host * acct-port
      leaf acct-port {
        tailf:info "UDP port for RADIUS accounting server (default is 1646)";
        type uint16 {
          tailf:info "<0-65535>;;Port number";
          range "0..65535";
        }
      }
      //  alias         1-8 aliases for this server (max. 8)
      // radius-server host * auth-port
      leaf auth-port {
        tailf:info "UDP port for RADIUS authentication server (default is "
          +"1645)";
        type uint16 {
          tailf:info "<0-65535>;;Port number";
          range "0..65535";
        }
      }
      //  backoff       Retry backoff pattern (Default is retransmits with
      //                constant delay)
      // radius-server host * key
      leaf "key" {
        tailf:info "per-server encryption key (overrides default)";
        type string {
          tailf:info "LINE;;The UNENCRYPTED (cleartext) server key";
        }
      }
      //  non-standard  Parse attributes that violate the RADIUS standard
      //  retransmit    Specify the number of retries to active server
      //                (overrides default)
      //  test          Configure server automated testing.
      //  timeout       Time to wait for this RADIUS server to reply
      //                (overrides default)
    }
    //  key                 encryption key shared with the radius servers
    //  load-balance        Radius load-balancing options.
    //  optional-passwords  The first RADIUS request can be made without
    //                      requesting a password
    //  retransmit          Specify the number of retries to active server
    //  retry               Specify how the next packet is sent after timeout.
    //  source-ports        source ports used for sending out RADIUS requests
    //  timeout             Time to wait for a RADIUS server to reply
    //  transaction         Specify per-transaction parameters
    //  unique-ident        Higher order bits of Acct-Session-Id
    //  vsa                 Vendor specific attribute configuration

  }


  /// ========================================================================
  /// radius
  /// ========================================================================

  container radius {
    tailf:info "RADIUS server configuration command";

    // radius filter *
    list filter {
      tailf:info "Packet filter configuration";
      key id;
      leaf id {
        type string {
          tailf:info "WORD;;Name of the filter (max 31 characters, longer will "
            +"be rejected";
        }
      }
      leaf match {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        type enumeration {
          enum match-all {
            tailf:info "Filter if all of the attributes matches";
          }
          enum match-any {
            tailf:info "Filter if any of the attributes matches";
          }
        }
      }
    }

    // radius server *
    list server {
      tailf:info "Server configuration";
      key "id";
      leaf id {
        type string {
          tailf:info "WORD;;Name for the radius server configuration";
        }
      }
      container address {
        tailf:info "Specify the radius server address";
        container ipv4 {
          tailf:info "IPv4 Address";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf host {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "Hostname or A.B.C.D;;IPv4 Address of radius server";
            }
          }
          // alias      1-8 aliases for this server (max. 8)
          leaf auth-port {
            tailf:info "UDP port for RADIUS authentication server (default is "
              +"1645)";
            tailf:cli-optional-in-sequence;
            type uint16 {
              tailf:info "<0-65535>;;Port number";
              range "0..65535";
            }
          }
          leaf acct-port {
            tailf:info "UDP port for RADIUS accounting server (default is "
              +"1646)";
            type uint16 {
              tailf:info "<0-65535>;;Port number";
              range "0..65535";
            }
          }
        }
        //  ipv6  IPv6 Address
      }
      container backoff {
        tailf:info "Retry backoff pattern(Default is retransmits with constant "
          +"delay)";
        container exponential {
          tailf:info "Exponential retransmit backoff";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          presence true;
          leaf max-delay {
            tailf:cli-optional-in-sequence;
            tailf:info "Max delay between retransmits(default is 3 min)";
            type uint8 {
              tailf:info "<1-120>;;Max time (in minutes) to delay between "
                +"retransmits";
              range "1..120";
            }
          }
          leaf backoff-retry {
            tailf:info "Exponential backoff retry number(default is 8)";
            type uint8 {
              tailf:info "<1-50>;;Number of retransmits in the exponential "
                +"backoff mode";
              range "1..50";
            }
          }
        }
      }
      container "key" {
        tailf:info "Per-server encryption key";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf "encryption" {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          tailf:cli-optional-in-sequence;
          type enumeration {
            enum "0" {
              tailf:info "Specifies an UNENCRYPTED key will follow";
            }
            enum "5" {
              tailf:info "Specifies a HIDDEN key will follow";
            }
          }
        }
        leaf key {
          tailf:cli-drop-node-name;
          tailf:cli-multi-value;
          type string {
            tailf:info "LINE;;The UNCRYPTED (cleartext) shared key";
          }
        }
      }
    }

  }


  /// ========================================================================
  /// zone
  /// ========================================================================

  container zone {
    tailf:info "FW with zoning";

    // zone security *
    list security {
      tailf:info "Security zone";
      tailf:cli-mode-name "config-sec-zone";
      tailf:cli-full-command;
      key id;
      leaf id {
        type string {
          tailf:info "WORD;;Name of security zone";
        }
      }
      leaf "description" {
        tailf:info "Zone description";
        tailf:cli-multi-value;
        type string {
          tailf:info "LINE;;Description of zone (up to 200 characters)";
        }
      }
    }
  }


  /// ========================================================================
  /// zone-pair
  /// ========================================================================

  container zone-pair {
    tailf:info "Zone pair command";

    // zone-pair security *
    list security {
      tailf:info "Zone-pair name";
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-mode-name "config-sec-zone-pair";
      key id;
      leaf id {
        type string {
          tailf:info "WORD;;Name of zone-pair";
        }
      }
      leaf source {
        tailf:info "Source zone";
        tailf:cli-hide-in-submode;
        tailf:non-strict-leafref {
          path "/ios:zone/security/id";
        }
        type string {
          tailf:info "WORD;;Name of source zone";
        }
      }
      leaf destination {
        tailf:info "Destination zone";
        tailf:cli-hide-in-submode;
        tailf:non-strict-leafref {
          path "/ios:zone/security/id";
        }
        type string {
          tailf:info "WORD;;Name of destination zone";
        }
      }
      leaf "description" {
        tailf:info "Zone description";
        tailf:cli-break-sequence-commands;
        tailf:cli-multi-value;
        type string {
          tailf:info "LINE;;Description of zone (up to 200 characters)";
          length "1..200";
        }
      }
      container service-policy {
        tailf:info "Configure CBAC Service Policy";
        container type {
          tailf:info "Service Policy type";
          leaf inspect {
            tailf:info "Configure CBAC Service Policy type inspect";
            type string;
            tailf:non-strict-leafref {
              path "/ios:policy-map/name";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// aaa
  /// ========================================================================

  container aaa {
    tailf:info "Authentication, Authorization and Accounting.";
    tailf:cli-incomplete-command;

    // aaa new-model
    leaf new-model {
      tailf:info "Enable NEW access control commands and functions."+
        "(Disables OLD commands.)";
      type empty;
    }

    // aaa group
    container group {
      tailf:info "AAA group definitions";
      tailf:cli-diff-dependency "/ios:aaa/new-model";
      // aaa group server
      container server {
        tailf:info "AAA Server group definitions";
        // aaa group server tacacs+ *
        list "tacacsplus" {
          tailf:alt-name "tacacs+";
          tailf:info "Tacacs+ server-group definition";
          tailf:cli-full-command;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Server-group name";
            }
          }
          list server-private {
            tailf:info "Define a private TACACS server (per group)";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            tailf:cli-reset-container;
            key name;
            leaf name {
              type host-type {
                tailf:info "Hostname or A.B.C.D;;IP address of TACACS server";
              }
            }
            leaf timeout {
              tailf:info "Time to wait for this TACACS server to reply "+
                "(overrides default)";
              tailf:cli-optional-in-sequence;
              type uint16 {
                tailf:info "<1-1000>;;Timeout value in seconds to wait "+
                  "for server to reply";
                range "1..1000";
              }
            }
            container "key" {
              tailf:info "per-server encryption key (overrides default)";
              tailf:cli-compact-syntax;
              tailf:cli-flatten-container;
              tailf:cli-sequence-commands;
              leaf encryption {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                tailf:cli-optional-in-sequence;
                type enumeration {
                  enum 0 {
                    tailf:info "Specifies an UNENCRYPTED key will follow";
                  }
                  enum 7 {
                    tailf:info "Specifies HIDDEN key will follow";
                  }
                }
              }
              leaf key {
                tailf:cli-drop-node-name;
                tailf:cli-full-command;
                tailf:cli-multi-value;
                type string {
                  tailf:info "LINE;;The UNENCRYPTED (cleartext) shared key";
                }
              }
            }
            //nat  To send client's post NAT address to tacacs+ server
            //port TCP port for TACACS+ server (default is 49)
            //single-connection Multiplex all packets over a single..
            //..tcp connection to server (for CiscoSecure)
          }
          container ip {
            tailf:info "Internet Protocol config commands";
            container tacacs {
              tailf:info "TACACS configuration commands";
              container source-interface {
                tailf:info "Specify interface for source address in "+
                  "TACACS packets";
                tailf:cli-diff-dependency "/ios:interface";
                uses interface-grouping;
              }
            }
          }
        }
        // aaa group server radius *
        list radius {
          tailf:info "Radius server-group definition";
          tailf:cli-mode-name "config-sg-radius";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Server-group name";
            }
          }
          // aaa group server radius * / server
          container server {
            tailf:info "Specify a RADIUS server";
            // aaa group server radius * / server name
            list name {
              tailf:info "Name of radius server";
              tailf:cli-suppress-mode;
              key name;
              leaf name {
                type string;
                tailf:non-strict-leafref {
                  path "/ios:aaa/group/server/radius/name";
                }
              }
            }
            // aaa group server radius * / server *
            list direct {
              tailf:cli-drop-node-name;
              tailf:cli-compact-syntax;
              tailf:cli-suppress-mode;
              key name;
              leaf name {
                type inet:host {
                  tailf:info "Hostname or A.B.C.D;;IP address of RADIUS server";
                }
                tailf:cli-disallow-value "name";
              }
              leaf auth-port {
                tailf:info "UDP port for RADIUS authentication server "+
                  "(default is 1645)";
                type uint16 {
                  tailf:info "<0-65535>;;Port number";
                  range "0..65535";
                }
              }
              leaf acct-port {
                tailf:info "UDP port for RADIUS accounting server "+
                  "(default is 1646)";
                type uint16 {
                  tailf:info "<0-65535>;;Port number";
                  range "0..65535";
                }
              }
            }
          }
          container ip {
            tailf:info "Internet Protocol config commands";
            container radius {
              tailf:info "RADIUS configuration commands";
              leaf source-interface {
                // FIXME: interface container
                tailf:info "Specify interface for source address in RADIUS "
                  +"packets";
                type string;
              }
            }
            container vrf {
              tailf:info "Set VPN Routing Forwarding to use with the servers";
              leaf forwarding {
                tailf:info "Configure forwarding table";
                tailf:cli-diff-dependency "/ios:ip/vrf";
                tailf:cli-diff-dependency "/ios:vrf/definition";
                type string {
                  tailf:info "WORD;;Table name";
                }
              }
            }
          }
          //  server-private Define a private RADIUS server (per group)
          //  subscriber Configures MAC Filtering RADIUS Compatibility mode
          //  throttle Throttle requests to radius server

        }
      }
    }

    // aaa authentication
    container authentication {
      tailf:info "Authentication configurations parameters.";
      tailf:cli-diff-dependency "/ios:aaa/new-model";
      //  arap             Set authentication lists for arap.
      //  attempts         Set the maximum number of authentication attempts
      //  banner           Message to use when starting login/authentication.

      // aaa authentication dot1x
      container dot1x {
        tailf:info "Set authentication lists for IEEE 802.1x.";
        list dot1x-list {
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Named authentication list";
            }
          }
          uses aaa-authentication-dot1x-grouping;
        }
        container default {
          tailf:info "The default authentication list.";
          uses aaa-authentication-dot1x-grouping;
        }
      }

      // aaa authentication enable
      container enable {
        tailf:info "Set authentication list for enable.";
        container default {
          tailf:info "The default authentication list.";
          tailf:cli-compact-syntax;
          leaf enable {
            tailf:info "Use enable password for authentication.";
            type empty;
          }
          leaf group {
            tailf:info "Use Server-group";
            type union {
              type string {
                tailf:info "WORD;;Server-group name";
              }
              type enumeration {
                enum radius {
                  tailf:info "Use list of all Radius hosts.";
                }
                enum "tacacs+" {
                  tailf:info "+  Use list of all Tacacs+ hosts.";
                }
              }
            }
          }
          leaf line {
            tailf:info "Use line password for authentication.";
            type empty;
          }
          leaf none {
            tailf:info "No authentication.";
            tailf:cli-full-command;
            type empty;
          }
        }
      }
      //  eou              Set authentication lists for EAPoUDP
      //  fail-message     Message to use for failed login/authentication.

      // aaa authentication login *
      list login {
        tailf:info "Set authentication lists for logins.";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Named authentication list (max 31 characters,"
              +"longer will be rejected).";
            length "1..31";
          }
        }
        // aaa authentication login * group
        leaf group {
          tailf:info "Use Server-group";
          type union {
            type string {
              tailf:info "WORD;;Server-group name";
            }
            type enumeration {
              enum ldap {
                tailf:info "Use list of all LDAP hosts.";
              }
              enum radius {
                tailf:info "Use list of all Radius hosts.";
              }
              enum tacacs {
                tailf:info "+  Use list of all Tacacs+ hosts.";
              }
            }
          }
        }
        // aaa authentication login * local
        leaf local {
          tailf:info "Use local username authentication.";
          type empty;
        }
        // aaa authentication login * none
        leaf none {
          tailf:info "NO authentication.";
          tailf:cli-full-command;
          type empty;
        }
      }

      // aaa authentication ppp *
      list ppp {
        tailf:info "Set authentication lists for ppp.";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;Named authentication list (max 31 characters, "
              +"longer will be rejected).";
            length "1..31";
          }
        }
        container a1 {
          tailf:cli-drop-node-name;
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          choice auth-choice {
            leaf if-needed {
              tailf:info "Only authenticate if needed.";
              tailf:cli-optional-in-sequence;
              type empty;
            }
            leaf none {
              tailf:info "NO authentication.";
              type empty;
            }
            leaf krb5 {
              tailf:info "Use Kerberos 5 authentication.";
              type empty;
            }
            leaf local {
              tailf:info "Use local username authentication.";
              type empty;
            }
            leaf local-case {
              tailf:info "Use case-sensitive local username authentication.";
              type empty;
            }
            leaf group {
              tailf:info "Use Server-group";
              type union {
                type string {
                  tailf:info "WORD;;Server-group name";
                }
                type enumeration {
                  enum radius {
                    tailf:info "Use list of all Radius hosts.";
                  }
                  enum tacacs+ {
                    tailf:info "Use list of all Tacacs+ hosts.";
                  }
                }
              }
            }
            leaf cache {
              tailf:info "Use Cached-group";
              type union {
                type string {
                  tailf:info "WORD;;Server-group name";
                }
                type enumeration {
                  enum radius {
                    tailf:info "Use list of all Radius hosts.";
                  }
                  enum tacacs+ {
                    tailf:info "Use list of all Tacacs+ hosts.";
                  }
                }
              }
            }
          }
        }
        container a2 {
          when "not(../a1/none)" {
            tailf:dependency "../a1/none";
          }
          tailf:cli-drop-node-name;
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          choice auth-choice {
            leaf group {
              tailf:info "Use Server-group";
              type union {
                type string {
                  tailf:info "WORD;;Server-group name";
                }
                type enumeration {
                  enum radius {
                    tailf:info "Use list of all Radius hosts.";
                  }
                  enum tacacs+ {
                    tailf:info "Use list of all Tacacs+ hosts.";
                  }
                }
              }
            }
            leaf cache {
              tailf:info "Use Cached-group";
              type union {
                type string {
                  tailf:info "WORD;;Server-group name";
                }
                type enumeration {
                  enum radius {
                    tailf:info "Use list of all Radius hosts.";
                  }
                  enum tacacs+ {
                    tailf:info "Use list of all Tacacs+ hosts.";
                  }
                }
              }
            }
            leaf none {
              tailf:info "NO authentication.";
              type empty;
            }
            leaf krb5 {
              when "not(../../a1/krb5)" {
                tailf:dependency "../../a1/krb5";
              }
              tailf:info "Use Kerberos 5 authentication.";
              type empty;
            }
            leaf local {
              when "not(../../a1/local) and not(../../a1/local-case)" {
                tailf:dependency "../../a1/local";
                tailf:dependency "../../a1/local-case";
              }
              tailf:info "Use local username authentication.";
              type empty;
            }
            leaf local-case {
              when "not(../../a1/local) and not(../../a1/local-case)" {
                tailf:dependency "../../a1/local";
                tailf:dependency "../../a1/local-case";
              }
              tailf:info "Use case-sensitive local username authentication.";
              type empty;
            }
          }
        }
        container a3 {
          when "not(../a2/none) and not (../a1/none)" {
            tailf:dependency "../a1/none";
            tailf:dependency "../a2/none";
          }
          tailf:cli-drop-node-name;
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          choice auth-choice {
            leaf group {
              tailf:info "Use Server-group";
              type union {
                type string {
                  tailf:info "WORD;;Server-group name";
                }
                type enumeration {
                  enum radius {
                    tailf:info "Use list of all Radius hosts.";
                  }
                  enum tacacs+ {
                    tailf:info "Use list of all Tacacs+ hosts.";
                  }
                }
              }
            }
            leaf cache {
              tailf:info "Use Cached-group";
              type union {
                type string {
                  tailf:info "WORD;;Server-group name";
                }
                type enumeration {
                  enum radius {
                    tailf:info "Use list of all Radius hosts.";
                  }
                  enum tacacs+ {
                    tailf:info "Use list of all Tacacs+ hosts.";
                  }
                }
              }
            }
            leaf none {
              tailf:info "NO authentication.";
              type empty;
            }
            leaf krb5 {
              when "not(../../a1/krb5) and not(../../a2/krb5)" {
                tailf:dependency "../../a1/krb5";
                tailf:dependency "../../a2/krb5";
              }
              tailf:info "Use Kerberos 5 authentication.";
              type empty;
            }
            leaf local {
              when "not(../../a1/local) and not(../../a1/local-case) and "
                +"not(../../a2/local) and not(../../a2/local-case)" {
                tailf:dependency "../../a1/local";
                tailf:dependency "../../a1/local-case";
                tailf:dependency "../../a2/local";
                tailf:dependency "../../a2/local-case";
              }
              tailf:info "Use local username authentication.";
              type empty;
            }
            leaf local-case {
              when "not(../../a1/local) and not(../../a1/local-case) and "
                +"not(../../a2/local) and not(../../a2/local-case)" {
                tailf:dependency "../../a1/local";
                tailf:dependency "../../a1/local-case";
                tailf:dependency "../../a2/local";
                tailf:dependency "../../a2/local-case";
              }
              tailf:info "Use case-sensitive local username authentication.";
              type empty;
            }
          }
        }
        container a4 {
          when "not(../a2/none) and not(../a1/none) and not(../a3/none)" {
            tailf:dependency "../a1/none";
            tailf:dependency "../a2/none";
            tailf:dependency "../a3/none";
          }
          tailf:cli-drop-node-name;
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          choice auth-choice {
            leaf group {
              tailf:info "Use Server-group";
              type union {
                type string {
                  tailf:info "WORD;;Server-group name";
                }
                type enumeration {
                  enum radius {
                    tailf:info "Use list of all Radius hosts.";
                  }
                  enum tacacs+ {
                    tailf:info "Use list of all Tacacs+ hosts.";
                  }
                }
              }
            }
            leaf cache {
              tailf:info "Use Cached-group";
              type union {
                type string {
                  tailf:info "WORD;;Server-group name";
                }
                type enumeration {
                  enum radius {
                    tailf:info "Use list of all Radius hosts.";
                  }
                  enum tacacs+ {
                    tailf:info "Use list of all Tacacs+ hosts.";
                  }
                }
              }
            }
            leaf none {
              tailf:info "NO authentication.";
              type empty;
            }
            leaf krb5 {
              when "not(../../a1/krb5) and not(../../a2/krb5) and "
                +"not(../../a3/krb5)" {
                tailf:dependency "../../a1/krb5";
                tailf:dependency "../../a2/krb5";
                tailf:dependency "../../a3/krb5";
              }
              tailf:info "Use Kerberos 5 authentication.";
              type empty;
            }
            leaf local {
              when "not(../../a1/local) and not(../../a1/local-case) and "
                +"not(../../a2/local) and not(../../a2/local-case) and "
                +"not(../../a3/local) and not(../../a3/local-case)" {
                tailf:dependency "../../a1/local";
                tailf:dependency "../../a1/local-case";
                tailf:dependency "../../a2/local";
                tailf:dependency "../../a2/local-case";
                tailf:dependency "../../a3/local";
                tailf:dependency "../../a3/local-case";
              }
              tailf:info "Use local username authentication.";
              type empty;
            }
            leaf local-case {
              when "not(../../a1/local) and not(../../a1/local-case) and "
                +"not(../../a2/local) and not(../../a2/local-case) and "
                +"not(../../a3/local) and not(../../a3/local-case)" {
                tailf:dependency "../../a1/local";
                tailf:dependency "../../a1/local-case";
                tailf:dependency "../../a2/local";
                tailf:dependency "../../a2/local-case";
                tailf:dependency "../../a3/local";
                tailf:dependency "../../a3/local-case";
              }
              tailf:info "Use case-sensitive local username authentication.";
              type empty;
            }
          }
        }
      }

    }

    // aaa authorization
    container authorization {
      tailf:info "Authorization configurations parameters.";
      tailf:cli-incomplete-command;
      tailf:cli-diff-dependency "/ios:aaa/new-model";

      // aaa authorization commands *
      list commands {
        tailf:info "For exec (shell) commands.";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key "level list-name";
        leaf level {
          tailf:info "Enable level";
          type uint8 {
            range "0..15";
          }
        }
        leaf list-name {
          tailf:cli-incomplete-command;
          tailf:cli-disallow-value "group";
          type union {
            type enumeration {
              enum "default" {
                tailf:info "The default authorization list.";
              }
            }
            type string {
              tailf:info "WORD;;Named authorization list.";
            }
          }
        }
        leaf group {
          tailf:info "Use server-group.";
          tailf:cli-disallow-value "if-authenticated|local|none";
          type union {
            type enumeration {
              enum "tacacs+" {
                tailf:info "Use list of all Tacacs+ hosts.";
              }
            }
            type string {
              tailf:info "WORD;;Server-group name";
            }
          }
        }
        leaf if-authenticated {
          tailf:info "Succeed if user has authenticated.";
          type empty;
        }
        leaf local {
          tailf:info "Use local database.";
          type empty;
        }
        leaf none {
          tailf:info "No authorization (always succeeds).";
          type empty;
        }
      }

      // aaa authorization console
      leaf console {
        type empty;
      }

      // aaa authorization config-commands
      leaf config-commands {
        tailf:info "For configuration mode commands.";
        type empty;
      }

      //  configuration For downloading configurations from AAA server
      //  console For enabling console authorization
      //  credential-download  For downloading EAP credential
      //                       from Local/RADIUS/LDAP

      // aaa authorization exec *
      list exec {
        tailf:info "For starting an exec (shell).";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Named authorization list (max 31 characters, "
              +"longer will be rejected).";
          }
        }
        //  cache             Use Cached-group
        leaf group {
          tailf:info "Use server-group.";
          type union {
            type string {
              tailf:info "WORD;;Server-group name";
            }
            type enumeration {
              enum ldap {
                tailf:info "Use list of all LDAP hosts.";
              }
              enum radius {
                tailf:info "Use list of all Radius hosts.";
              }
              enum tacacs {
                tailf:info "+  Use list of all Tacacs+ hosts.";
              }
            }
          }
        }
        //  if-authenticated  Succeed if user has authenticated.
        //  krb5-instance     Use Kerberos instance privilege maps.
        leaf local {
          tailf:info "Use local database.";
          type empty;
        }
        leaf none {
          tailf:info "No authorization (always succeeds).";
          type empty;
        }
      }

      // aaa authorization eventmanager *
      list eventmanager {
        tailf:info "For starting an exec (shell).";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Named authorization list (max 31 characters, "
              +"longer will be rejected).";
          }
        }
        //  cache             Use Cached-group
        leaf group {
          tailf:info "Use server-group.";
          type union {
            type string {
              tailf:info "WORD;;Server-group name";
            }
            type enumeration {
              enum ldap {
                tailf:info "Use list of all LDAP hosts.";
              }
              enum radius {
                tailf:info "Use list of all Radius hosts.";
              }
              enum tacacs {
                tailf:info "+  Use list of all Tacacs+ hosts.";
              }
            }
          }
        }
        //  if-authenticated  Succeed if user has authenticated.
        //  krb5-instance     Use Kerberos instance privilege maps.
        leaf local {
          tailf:info "Use local database.";
          type empty;
        }
        leaf none {
          tailf:info "No authorization (always succeeds).";
          type empty;
        }
      }

      // aaa authorization network *
      list network {
        tailf:info "For network services. (PPP, SLIP, ARAP)";
        tailf:cli-suppress-mode;
        key id;
        leaf id {
          type union {
            type enumeration {
              enum default {
                tailf:info "The default authorization list.";
              }
            }
            type string {
              tailf:info "WORD;;Named authorization list.";
              length "1..31";
            }
          }
        }
        container a1 {
          tailf:cli-drop-node-name;
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          choice auth-choice {
            leaf if-authenticated {
              tailf:info "Succeed if user has authenticated.";
              type empty;
            }
            leaf none {
              tailf:info "NO authentication.";
              type empty;
            }
            leaf local {
              tailf:info "Use local username authentication.";
              type empty;
            }
            leaf group {
              tailf:info "Use Server-group";
              type union {
                type string {
                  tailf:info "WORD;;Server-group name";
                }
                type enumeration {
                  enum radius {
                    tailf:info "Use list of all Radius hosts.";
                  }
                  enum tacacs+ {
                    tailf:info "Use list of all Tacacs+ hosts.";
                  }
                }
              }
            }
            leaf cache {
              tailf:info "Use Cached-group";
              type union {
                type string {
                  tailf:info "WORD;;Server-group name";
                }
                type enumeration {
                  enum radius {
                    tailf:info "Use list of all Radius hosts.";
                  }
                  enum tacacs+ {
                    tailf:info "Use list of all Tacacs+ hosts.";
                  }
                }
              }
            }
          }
        }
        container a2 {
          when "not(../a1/none) and not(../a1/if-authenticated)" {
            tailf:dependency "../a1/none";
            tailf:dependency "../a1/if-authenticated";
          }
          tailf:cli-drop-node-name;
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          choice auth-choice {
            leaf group {
              tailf:info "Use Server-group";
              type union {
                type string {
                  tailf:info "WORD;;Server-group name";
                }
                type enumeration {
                  enum radius {
                    tailf:info "Use list of all Radius hosts.";
                  }
                  enum tacacs+ {
                    tailf:info "Use list of all Tacacs+ hosts.";
                  }
                }
              }
            }
            leaf cache {
              tailf:info "Use Cached-group";
              type union {
                type string {
                  tailf:info "WORD;;Server-group name";
                }
                type enumeration {
                  enum radius {
                    tailf:info "Use list of all Radius hosts.";
                  }
                  enum tacacs+ {
                    tailf:info "Use list of all Tacacs+ hosts.";
                  }
                }
              }
            }
            leaf if-authenticated {
              tailf:info "Succeed if user has authenticated.";
              type empty;
            }
            leaf none {
              tailf:info "NO authentication.";
              type empty;
            }
            leaf local {
              when "not(../../a1/local)" {
                tailf:dependency "../../a1/local";
              }
              tailf:info "Use local username authentication.";
              type empty;
            }
          }
        }
        container a3 {
          when "not(../a2/none) and not (../a1/none) and "
            +"not(../a2/if-authenticated) and not(../a1/if-authenticated)" {
            tailf:dependency "../a1/none";
            tailf:dependency "../a2/none";
            tailf:dependency "../a1/if-authenticated";
            tailf:dependency "../a2/if-authenticated";
          }
          tailf:cli-drop-node-name;
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          choice auth-choice {
            leaf group {
              tailf:info "Use Server-group";
              type union {
                type string {
                  tailf:info "WORD;;Server-group name";
                }
                type enumeration {
                  enum radius {
                    tailf:info "Use list of all Radius hosts.";
                  }
                  enum tacacs+ {
                    tailf:info "Use list of all Tacacs+ hosts.";
                  }
                }
              }
            }
            leaf cache {
              tailf:info "Use Cached-group";
              type union {
                type string {
                  tailf:info "WORD;;Server-group name";
                }
                type enumeration {
                  enum radius {
                    tailf:info "Use list of all Radius hosts.";
                  }
                  enum tacacs+ {
                    tailf:info "Use list of all Tacacs+ hosts.";
                  }
                }
              }
            }
            leaf none {
              tailf:info "NO authentication.";
              type empty;
            }
            leaf if-authenticated {
              tailf:info "Succeed if user has authenticated.";
              type empty;
            }
            leaf local {
              when "not(../../a1/local) and not(../../a2/local)" {
                tailf:dependency "../../a1/local";
                tailf:dependency "../../a2/local";
              }
              tailf:info "Use local username authentication.";
              type empty;
            }
          }
        }
        container a4 {
          when "not(../a2/none) and not(../a1/none) and not(../a3/none) and "
            +"not(../a2/if-authenticated) and not(../a1/if-authenticated) and "
            +"not(../a3/if-authenticated)" {
            tailf:dependency "../a1/none";
            tailf:dependency "../a2/none";
            tailf:dependency "../a3/none";
            tailf:dependency "../a1/if-authenticated";
            tailf:dependency "../a2/if-authenticated";
            tailf:dependency "../a3/if-authenticated";
          }

          tailf:cli-drop-node-name;
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          choice auth-choice {
            leaf group {
              tailf:info "Use Server-group";
              type union {
                type string {
                  tailf:info "WORD;;Server-group name";
                }
                type enumeration {
                  enum radius {
                    tailf:info "Use list of all Radius hosts.";
                  }
                  enum tacacs+ {
                    tailf:info "Use list of all Tacacs+ hosts.";
                  }
                }
              }
            }
            leaf cache {
              tailf:info "Use Cached-group";
              type union {
                type string {
                  tailf:info "WORD;;Server-group name";
                }
                type enumeration {
                  enum radius {
                    tailf:info "Use list of all Radius hosts.";
                  }
                  enum tacacs+ {
                    tailf:info "Use list of all Tacacs+ hosts.";
                  }
                }
              }
            }
            leaf none {
              tailf:info "NO authentication.";
              type empty;
            }
            leaf if-authenticated {
              tailf:info "Succeed if user has authenticated.";
              type empty;
            }
            leaf local {
              when "not(../../a1/local) and "
                +"not(../../a2/local) and "
                +"not(../../a3/local)" {
                tailf:dependency "../../a1/local";
                tailf:dependency "../../a2/local";
                tailf:dependency "../../a3/local";
              }
              tailf:info "Use local username authentication.";
              type empty;
            }
          }
        }
      }
    }

    // aaa accounting
    container accounting {
      tailf:info "Accounting configurations parameters.";
      tailf:cli-incomplete-command;
      tailf:cli-diff-dependency "/ios:aaa/new-model";
      // aaa accounting commands *
      list commands {
        tailf:info "For exec (shell) commands.";
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        tailf:cli-sequence-commands;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        //FIXME: command accepts another version where you set
        //       leafs in submode as well.
        //tailf:cli-mode-name "cfg-acct-mlist";
        key "level list-name";
        leaf level {
          tailf:info "Enable level";
          type uint8 {
            range "0..15";
          }
        }
        leaf list-name {
          type union {
            type enumeration {
              enum "default" {
                tailf:info "The default accounting list.";
              }
            }
            type string {
              tailf:info "WORD;;Named Accounting list. "+
                "(max 31 characters)";
              length "1..31";
            }
          }
        }
        leaf action-type {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type enumeration {
            enum none {
              tailf:info "No accounting.";
            }
            enum start-stop  {
              tailf:info "Record start and stop without waiting";
            }
            enum stop-only {
              tailf:info "Record stop when service terminates.";
            }
          }
        }
        leaf broadcast {
          tailf:info "Use Broadcast for Accounting";
          tailf:cli-optional-in-sequence;
          tailf:cli-incomplete-command;
          type empty;
        }
        leaf group {
          tailf:info "Use Server-group";
          tailf:cli-full-command;
          type union {
            type string {
              tailf:info "WORD;;Server-group name";
            }
            type enumeration {
              enum "tacacs+" {
                tailf:info "Use list of all Tacacs+ hosts.";
              }
            }
          }
        }
      }
      // aaa accounting exec *
      list exec {
        tailf:info "For starting an exec (shell).";
        tailf:cli-mode-name "cfg-acct-mlist";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Named Accounting list (max 31 characters, "
              +"longer will be rejected).";
          }
        }
        choice accounting-choice {
          leaf none {
            tailf:info "No accounting.";
            type empty;
          }
          container start-stop {
            tailf:info "Record start and stop without waiting";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            tailf:cli-reset-container;
            leaf broadcast {
              tailf:info "Use Broadcast for Accounting";
              tailf:cli-optional-in-sequence;
              type empty;
            }
            leaf group {
              tailf:info "Use Server-group";
              type union {
                type string {
                  tailf:info "WORD;;Server-group name";
                }
                type enumeration {
                  enum radius {
                    tailf:info "Use list of all Radius hosts.";
                  }
                  enum tacacs {
                    tailf:info "+  Use list of all Tacacs+ hosts.";
                  }
                }
              }
            }
          }
          container stop-only {
            tailf:info "Record stop when service terminates.";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            tailf:cli-reset-container;
            leaf broadcast {
              tailf:info "Use Broadcast for Accounting";
              tailf:cli-optional-in-sequence;
              type empty;
            }
            leaf group {
              tailf:info "Use Server-group";
              type union {
                type string {
                  tailf:info "WORD;;Server-group name";
                }
                type enumeration {
                  enum radius {
                    tailf:info "Use list of all Radius hosts.";
                  }
                  enum tacacs {
                    tailf:info "+  Use list of all Tacacs+ hosts.";
                  }
                }
              }
            }
          }
        }
      }
      // aaa accounting network *
      list network {
        tailf:info "For network services. (PPP, SLIP, ARAP)";
        tailf:cli-suppress-mode;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key id;
        leaf id {
          type union {
            type enumeration {
              enum default {
                tailf:info "The default accounting list.";
              }
            }
            type string {
              tailf:info "WORD;;Named Accounting list.";
              length "1..31";
            }
          }
        }
        choice network-choice {
          case a {
            leaf none {
              tailf:info "No accounting.";
              type empty;
            }
          }
          case b {
            leaf mode {
              tailf:cli-drop-node-name;
              type enumeration {
                enum start-stop {
                  tailf:info "Record start and stop without waiting";
                }
                enum stop-only {
                  tailf:info "Record stop when service terminates.";
                }
              }
            }
            leaf broadcast {
              tailf:info "Use Broadcast for Accounting";
              tailf:cli-optional-in-sequence;
              type empty;
            }
            container a1 {
              tailf:cli-compact-syntax;
              tailf:cli-drop-node-name;
              tailf:cli-flatten-container;
              leaf group {
                tailf:info "Use server-group.";
                type union {
                  type string {
                    tailf:info "WORD;;Server-group name";
                  }
                  type enumeration {
                    enum ldap {
                      tailf:info "Use list of all LDAP hosts.";
                    }
                    enum radius {
                      tailf:info "Use list of all Radius hosts.";
                    }
                    enum tacacs {
                      tailf:info "+  Use list of all Tacacs+ hosts.";
                    }
                  }
                }
              }
            }
            container a2 {
              tailf:cli-compact-syntax;
              tailf:cli-drop-node-name;
              tailf:cli-flatten-container;
              leaf group {
                tailf:info "Use server-group.";
                type union {
                  type string {
                    tailf:info "WORD;;Server-group name";
                  }
                  type enumeration {
                    enum ldap {
                      tailf:info "Use list of all LDAP hosts.";
                    }
                    enum radius {
                      tailf:info "Use list of all Radius hosts.";
                    }
                    enum tacacs {
                      tailf:info "+  Use list of all Tacacs+ hosts.";
                    }
                  }
                }
              }
            }
            container a3 {
              tailf:cli-compact-syntax;
              tailf:cli-drop-node-name;
              tailf:cli-flatten-container;
              leaf group {
                tailf:info "Use server-group.";
                type union {
                  type string {
                    tailf:info "WORD;;Server-group name";
                  }
                  type enumeration {
                    enum ldap {
                      tailf:info "Use list of all LDAP hosts.";
                    }
                    enum radius {
                      tailf:info "Use list of all Radius hosts.";
                    }
                    enum tacacs {
                      tailf:info "+  Use list of all Tacacs+ hosts.";
                    }
                  }
                }
              }
            }
            container a4 {
              tailf:cli-compact-syntax;
              tailf:cli-drop-node-name;
              tailf:cli-flatten-container;
              leaf group {
                tailf:info "Use server-group.";
                type union {
                  type string {
                    tailf:info "WORD;;Server-group name";
                  }
                  type enumeration {
                    enum ldap {
                      tailf:info "Use list of all LDAP hosts.";
                    }
                    enum radius {
                      tailf:info "Use list of all Radius hosts.";
                    }
                    enum tacacs {
                      tailf:info "+  Use list of all Tacacs+ hosts.";
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // aaa session-id
    leaf session-id {
      tailf:info "AAA Session ID";
      tailf:cli-diff-dependency "/ios:aaa/new-model";
      type enumeration {
        enum common {
          tailf:info "Common Session ID";
        }
        enum "unique" {
          tailf:info "Unique Session ID for different accounting types";
        }
      }
    }
  }


  /// ========================================================================
  /// ethernet
  /// ========================================================================

  container ethernet {
    tailf:info "Ethernet configuration";

    // ethernet evc
    list evc {
      //FIXME: guessing info etc.
      tailf:info "define an Ethernet virtual connection (EVC)";
      tailf:cli-compact-syntax;
      tailf:cli-full-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;EVC id";
          length "1..100";
        }
      }
      // submode commands:
      // default
      // uni count
      // oam protocol
    }

    // ethernet cfm
    container cfm {
      tailf:info "Connectivity Fault Management";

      // ethernet cfm ieee
      leaf ieee {
        tailf:info "CFM IEEE enable";
        tailf:cli-full-command;
        type empty;
      }

      // ethernet cfm global
      leaf global {
        tailf:info "CFM global enable";
        tailf:cli-full-command;
        type empty;
      }

      list domain {
        tailf:info "Configure a domain";
        tailf:cli-mode-name "config-ecfm";
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;maintenance domain name";
          }
        }
        // ethernet cfm domain * level
        leaf level {
          tailf:info "Maintenance Level";
          tailf:cli-hide-in-submode;
          type uint8 {
            tailf:info "<0-7>  maintenance level number";
          }
        }
        // ethernet cfm domain * level / service
        leaf service {
          tailf:info "Maintenance Association within Domain";
          type string;
        }
        // ethernet cfm domain * level / evc
        leaf evc {
          type string;
          tailf:non-strict-leafref {
            path "/ios:ethernet/evc/name";
          }
        }
        // ethernet cfm domain * level / vlan
        leaf vlan {
          tailf:info "VLAN id";
          type uint16 {
            tailf:info "<1-4094>;;between 1 and 4094";
            range "1..4094";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// alarm-contact
  /// ========================================================================
  //FIXME: info strings

  list alarm-contact {
    tailf:cli-suppress-mode;
    tailf:cli-delete-when-empty;
    key name;
    leaf name {
      type uint8 {
        tailf:info "WORD;;Contact number";
        range "1..4";
      }
    }
    leaf "description" {
      tailf:cli-multi-value;
      type string {
        length "1..80";
      }
    }
    leaf severity {
      type enumeration {
        enum critical {
        }
        enum major {
        }
        enum minor {
        }
      }
    }
    leaf trigger {
      type enumeration {
        enum open {
        }
        enum closed {
        }
      }
    }
  }


  /// ========================================================================
  /// access-list
  /// ========================================================================

  container access-list {
    tailf:cli-incomplete-command;
    tailf:cli-compact-syntax;
    tailf:info "Add an access list entry";

    // acess-list *
    list access-list-standard-range {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-incomplete-command;
      key listnumber;
      leaf listnumber {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        tailf:cli-suppress-range;
        type uint16 {
          range "1..99";
          tailf:info "<1..99>;;IP standard access list";
        }
      }
      list std-access-list-rule {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        tailf:cli-show-long-obu-diffs;
        ordered-by user;
        key rule;
        leaf rule {
          tailf:cli-drop-node-name;
          tailf:cli-multi-word-key;
          type string {
            tailf:info "deny;;Specify packets to reject\n"+
                        "permit;;Specify packets to forwards\n"+
                        "remark;;Access list entry comment";
          }
        }
      }
    }

    // acess-list *
    list access-list-extended-range {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-incomplete-command;
      key listnumber;
      leaf listnumber {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        tailf:cli-suppress-range;
        type uint16 {
          range "100..199";
          tailf:info "<100..199>;;IP extended access list";
        }
      }
      list ext-access-list-rule {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        tailf:cli-show-long-obu-diffs;
        ordered-by user;
        key rule;
        leaf rule {
          tailf:cli-drop-node-name;
          tailf:cli-multi-word-key;
          type string {
            tailf:info "deny;;Specify packets to reject"+
                        "dynamic;;Specify DYNAMIC list of PERMITs or DENYs"+
                        "permit;;Specify packets to forwards"+
                        "remark;;Access list entry comment";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// crypto
  /// ========================================================================

  container crypto {
    tailf:info "Encryption module";

    // crypto pki
    container pki {
      tailf:info "Public Key components";

      // crypto pki trustpoint *
      list trustpoint {
        tailf:info "Define a CA trustpoint";
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;CA Server Name";
          }
        }
        //  authorization     Authorization parameters.
        //  auto-enroll       Automatically enroll this router identity
        //  certificate       certificate options
        //  chain-validation  Validation parameters
        //  crl               CRL options
        //  default           Set a command to its defaults
        container enrollment {
          tailf:info "Enrollment parameters";
          leaf http-proxy {
            tailf:info "HTTP proxy server for enrollment";
            type string {
              tailf:info "WORD;;host-name";
            }
          }
          container mode {
            tailf:info "Mode supported by the Certificate Authority";
            leaf ra {
              tailf:info "Registration Authority mode";
              type empty;
            }
          }
          leaf profile {
            tailf:info "Specify an profile for enrollment";
            type string {
              tailf:info "WORD;;Profile name";
            }
          }
          container retry {
            tailf:info "Polling parameters";
            leaf count {
              tailf:info "How many times to poll CA for our certificate";
              type uint8 {
                tailf:info "<1-100>;;Number of times to poll a CA for a "
                  +"certificate";
                range "1..100";
              }
            }
            leaf period {
              tailf:info "How long to wait between requests to CA for our "
                +"certificate";
              type uint8 {
                tailf:info "<1-60>;;Period in minutes between attempts to "
                  +"contact a CA";
                range "1..60";
              }
            }
          }
          leaf selfsigned {
            tailf:info "Generate a Self Signed Certificate";
            type empty;
          }
          container terminal {
            tailf:info "Enroll via the terminal (cut-and-paste)";
            presence true;
            leaf pem {
              tailf:info "Include PEM encapsulation boundaries";
              type empty;
            }
          }
          leaf url {
            tailf:info "CA server enrollment URL";
            type string {
              tailf:info "WORD;;HTTP URL";
            }
          }
        }
        //  exit              Exit from certificate authority trustpoint
        //                    entry mode
        //  fingerprint       CA Certificate Fingerprint
        //  fqdn              include fully-qualified domain name
        //  hash              Hash algorithm
        //  ip-address        include ip address
        //  ip-extension      RFC3779 IP extension for device certificate
        //                    request
        //  match             Match a certificate map
        //  no                Negate a command or set its defaults
        //  ocsp              OCSP parameters
        //  on                create keypair on device.
        //  password          revocation password
        //  primary           Specify trustpoint as primary
        //  query             Query parameters
        //  regenerate        Regenerate keys on re-enrollment
        leaf revocation-check {
          tailf:info "Revocation checking options";
          type enumeration {
            enum none;
          }
        }
        //  root              Protocol to get CA certificate
        leaf rsakeypair {
          tailf:info "Specify rsakeypair for this identity";
          type string;
        }
        //  serial-number     include serial number
        //  show              Show this router trustpoint
        //  source            Specify source
        //  storage           key and certificate storage location to use
        //                    with this trustpoint.
        leaf subject-name {
          tailf:info "Subject Name";
          type string;
        }
        //  usage             Certificate Usage
        //  vrf               vrf to use for enrollment and obtaining CRLs
      }

      // crypto pki certificate
      container certificate {
        tailf:info "Actions on certificates";
        // crypto pki certificate chain *
        list chain {
          tailf:info "Identify certificates";
          tailf:cli-mode-name "config-cert-chain";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;CA Server Name";
            }
          }
          // crypto pki certificate chain * / certificate *
          list certificate {
            tailf:info "Certificate issued by the CA";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key serial;
            leaf serial {
              type string {
                tailf:info "WORD;;Certificate serial number";
                pattern "[0-9]+";
              }
            }
            leaf certtype {
              tailf:cli-drop-node-name;
              tailf:cli-prefix-key;
              type enumeration {
                enum ca {
                  tailf:info "CA certificate";
                }
                enum ra-encrypt {
                  tailf:info "RA encryption certificate";
                }
                enum ra-general {
                  tailf:info "RA general purpose certificate";
                }
                enum ra-sign {
                  tailf:info "RA signing certificate";
                }
                enum rollover {
                  tailf:info "Shadow rollover certificate";
                }
                enum self-signed {
                  tailf:info "Self-signed certificate";
                }
              }
            }
            leaf cert {
              tailf:cli-drop-node-name;
              type string;
            }
          }
        }
      }

      // crypto pki token *
      container token {
        tailf:info "Configure cryptographic token";
        list token-name {
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-drop-node-name;
          tailf:cli-compact-syntax;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;token name";
            }
          }
          uses crypto-pki-token-grouping;
        }
      }

      // crypto pki default
      container "default" {
        tailf:info "set default values for tokens";
        uses crypto-pki-token-grouping;
      }
    }
  }


  /// ========================================================================
  /// mpls
  /// ========================================================================

  container mpls {
    tailf:info "Configure MPLS parameters";

    // mpls atm
    container atm {
      tailf:info "Configure ATM options";
      leaf disable-headend-vc {
        tailf:info "Dedicated lsc capability: In this mode "
          +"headend Tag VCs are disabled.";
        type empty;
      }
    }

    // mpls cos-map
    leaf cos-map {
      tailf:info "Configure MPLS CoS ATM Multi-VC CoS Map";
      tailf:cli-full-command;
      type uint8 {
        range "1..255" {
          tailf:info "<1-255>;;cos-map number";
        }
      }
    }

    // mpls ip
    container ip {
      tailf:info "Dynamic MPLS forwarding for IP";
      leaf default-route {
        tailf:info "Allow MPLS forwarding for ip default route";
        tailf:cli-full-command;
        type empty;
      }
      container conf {
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        // mpls ip propagate-ttl
        leaf propagate-ttl {
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }
      }
      container conf-arg {
        tailf:cli-drop-node-name;
        container propagate-ttl {
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          // mpls ip propagate-ttl forwarded
          leaf forwarded {
            tailf:cli-boolean-no;
            tailf:cli-show-with-default;
            type boolean;
            //default "true";
          }
        }
      }
      // mpls ip ttl-expiration
      container ttl-expiration {
        tailf:info "Control MPLS TTL expiration behavior";
        leaf pop {
          tailf:info "Popping labels on TTL expiration";
          type uint8 {
            range "1..6";
            tailf:info "<1-6>;;Popping all labels if original "
              +"packet has less than N labels";
          }
        }
      }
    }

    // mpls label
    container label {
      tailf:info "Label properties";
      // mpls label atm
      container atm {
        tailf:info "Configure ATM options";
        leaf disable-headend-vc {
          tailf:info "Dedicated lsc capability: In this mode "
            +"headend Tag VCs are disabled.";
          type empty;
        }
      }
      // mpls label protocol
      leaf protocol {
        tailf:info "Set platform default label distribution protocol";
        tailf:cli-full-command;
        type enumeration {
          enum ldp {
            tailf:code-name "label_ldp";
            tailf:info "Use LDP (default)";
          }
          enum tdp: {
            tailf:code-name "label_tdp";
            tailf:info "Use TDP";
          }
        }
        default ldp;
      }
      // mpls label range
      container "range" {
        tailf:info "Label range";
        tailf:cli-sequence-commands;
        tailf:cli-compact-syntax;
        leaf min {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint32 {
            range "16..1048575";
            tailf:info "<16-1048575>  Minimum label value";
          }
        }
        leaf max {
          tailf:cli-drop-node-name;
          type uint32 {
            range "16..1048575";
            tailf:info "<16-1048575>  Maximum label value";
          }
        }
      }
    }

    // mpls ldp
    container ldp {
      tailf:info "Label Distribution Protocol";
      container enable {
        tailf:cli-drop-node-name;
        // mpls ldp advertise-labels
        leaf advertise-labels {
          tailf:cli-boolean-no;
          tailf:cli-trim-default;
          tailf:cli-show-no; //??
          type boolean;
          default true;
        }
      }
      container enable2 {
        tailf:cli-drop-node-name;
        container advertise-labels {
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          tailf:info "Label advertisements";
          container "for" {
            tailf:info "Access-list specifying controls on "
              +"destination prefixes";
            tailf:cli-sequence-commands;
            tailf:cli-compact-syntax;
            leaf from {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "WORD;;IP access-list"+
                  " for destination"+
                  " prefixes; name or number (1-99)";
              }
            }
            leaf to {
              tailf:info "Access-list specifying controls on LDP "
                +"peers";
              type string {
                tailf:info "WORD;;IP access-list for LDP peers;"
                  +" name or number (1-99)";
              }
            }
          }
          container interface {
            tailf:info "Advertise /32 interface address";
            list FastEthernet {
              tailf:info "FastEthernet IEEE 802.3";
              tailf:cli-allow-join-with-key {
                tailf:cli-display-joined;
              }
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key name;
              leaf name {
                type string;
                tailf:non-strict-leafref {
                  path "/ios:interface/FastEthernet/name";
                }
              }
            }
            // FIXME: add all other types of supported interfaces
          }
          leaf oldstyle {
            tailf:info "Use old style (TDP) method for matching "
              +"prefix acl";
            tailf:cli-full-command;
            type empty;
          }
        }


      }


      container atm {
        tailf:info "Configure ATM MPLS options";
        leaf control-mode {
          tailf:info "Select LSP setup control mode for MPLS VCs";
          tailf:cli-full-command;
          type enumeration {
            enum independent {
              tailf:info "Independent Downstream on Demand "
                +"Label VC setup";
            }
            enum ordered {
              tailf:info "Ordered Dowstream on Demand Label "
                +"VC setup";
            }
          }
          default "ordered";
          tailf:cli-trim-default;
        }
        leaf vc-merge {
          tailf:info "Select VC merge capability";
          tailf:cli-full-command;
          tailf:cli-boolean-no;
          tailf:cli-trim-default;
          type boolean;
          default "true";
        }
      }
      container backoff {
        tailf:info "Set LDP session backoff parameters";
        tailf:cli-sequence-commands;
        tailf:cli-compact-syntax;
        leaf initial {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<5-2147483>;;Initial session backoff "
              +"time (seconds)";
            range "5..2147483";
          }
        }
        leaf max {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<5-2147483>;;Maximum session backoff "
              +"time (seconds)";
            range "5..2147483";
          }
        }
      }
      container discovery {
        tailf:info "LDP discovery";
        container hello {
          tailf:info "LDP discovery Hello";
          leaf holdtime {
            tailf:info "LDP discovery Hello holdtime";
            type uint16 {
              tailf:info "<1-65535>;;Holdtime in seconds";
              range "1..65535";
            }
          }
          leaf interval {
            tailf:info "LDP discovery Hello interval";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<1-65535>;;Hello interval in "
                +"seconds";
              range "1..65535";
            }
          }
        }
        container targeted-hello {
          tailf:info "LDP discovery Targeted Hello";
          container accept {
            tailf:info "Accept targeted hellos";
            presence "Accept targeted hellos";
            leaf from {
              tailf:info "Access list to specify acceptable "
                +"targeted hello sources";
              type string {
                tailf:info "WORD;;IP access-list for "
                  +"acceptable targeted hello sources";
              }
            }
          }
          leaf holdtime {
            tailf:info "LDP discovery Hello holdtime";
            type uint16 {
              tailf:info "<1-65535>;;Holdtime in seconds";
              range "1..65535";
            }
          }
          leaf interval {
            tailf:info "LDP discovery Hello interval";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<1-65535>;;Hello interval in "
                +"seconds";
              range "1..65535";
            }
          }
        }
      }
      container explicit-null {
        tailf:info "Advertise Explicit Null label in place of "
          +"Implicit Null";
        presence "Advertise Explicit Null label in place of "
          +"Implicit Null";
        leaf "for" {
          tailf:info "Access-list specifying controls on "
            +"destination prefixes";
          type string {
            tailf:info "WORD;;IP access-list for destination "
              +"prefixes; name or number (1-99)";
          }
        }
        leaf "to" {
          tailf:info "Access-list specifying controls on LDP peers";
          type string {
            tailf:info "WORD;;IP access-list for LDP "
              +"peers; name or number (1-99)";
          }
        }
      }
      container graceful-restart {
        tailf:info "Configure Graceful Restart timers";
        presence "Configure Graceful Restart timers";
        container timers {
          tailf:info "Configure Graceful Restart timers";
          leaf forwarding-holding {
            tailf:info "Forwarding State Holding time";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<30-600>;;seconds";
              range "30..600";
            }
          }
          leaf max-recovery {
            tailf:info "Max-Recovery time";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<15-600>;;seconds";
              range "15..600";
            }
          }
          leaf neighbor-liveness {
            tailf:info "Neighbor-Liveness time";
            tailf:cli-full-command;
            type uint16 {
              range "5..600";
              tailf:info "<5-300>;;seconds";
            }
          }
        }
      }
      leaf holdtime {
        tailf:info "LDP session holdtime";
        tailf:cli-full-command;
        type uint32 {
          tailf:info "<15-2147483>;;Holdtime in seconds";
          range "15..2147483";
        }
      }
      container logging {
        tailf:info "Enable LDP logging";
        leaf neighbor-changes {
          tailf:info "Log LDP neighbor state changes";
          type empty;
        }
      }
      leaf loop-detection {
        tailf:info "Enable LDP Loop Detection";
        tailf:cli-full-command;
        type empty;
      }
      leaf maxhops {
        tailf:info "Limit hop count for LDP LSP setup";
        tailf:cli-full-command;
        type uint8 {
          range "0..255";
          tailf:info "<1-255>;;Maximum hop count value";
        }
      }
      list neighbor {
        tailf:info "Configure neighbor parameters";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key address;
        leaf address {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP address for LDP neighbor";
          }
        }
        leaf implicit-withdraw {
          tailf:info "Enable LDP Implicit Withdraw Label";
          tailf:cli-full-command;
          type empty;
        }
        container lables {
          tailf:info "Configure label binding exchange controls";

          leaf accept {
            tailf:info "Specify label bindings to accept";
            type string {
              tailf:info "WORD;;IP access-list for LDP "
                +"peers; name or number (1-99)";
            }
          }
        }
        container password {
          // FIXME: better text pattern and reset siblings
          // also when configuration the text
          tailf:info "Set a password";
          tailf:cli-compact-syntax;
          leaf enctype {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            tailf:cli-reset-container;
            type uint8 {
              range "0..7";
              tailf:info "<0-7>;;Encryption type (0 to disable "
                +"encryption, 7 for proprietary)";
            }
            default "0";
          }
          leaf text {
            tailf:cli-drop-node-name;
            tailf:cli-full-command;
            tailf:cli-multi-value;
            tailf:cli-reset-container;
            type string {
              pattern '[a-zA-Z].*';
              tailf:info "LINE;;The password";
            }
          }
        }
        container targeted {
          tailf:info "Establish targeted session";
          presence "Establish targeted session";
          leaf protocol {
            tailf:cli-drop-node-name;
            type enumeration {
              enum ldp {
                tailf:code-name "target_ldp";
                tailf:info "User LDP";
              }
              enum tdp {
                tailf:code-name "target_tdp";
                tailf:info "Use TDP";
              }
            }
          }
        }
      }
      container request-labels {
        tailf:info "Access list to specify valid downstream "
          +"on demand destinations.";
        leaf "for" {
          tailf:info "Access list to specify acceptable "
            +"downstream on demand destinations";
          type string {
            tailf:info "WORD;;IP access-list for destination "
              +"prefixes; name or number (1-99)";
          }
        }
      }
      container router-id {
        tailf:info "Select interface to prefer for LDP "
          +"identifier address";
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        leaf interface {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;intrace name";
          }
        }
        leaf force {
          tailf:info "Forcibly change the LDP router id";
          type empty;
        }
      }
    }

    // mpls prefix-map
    container prefix-map {
      tailf:info "Configure MPLS CoS Tag-VC Multi-VC Prefix Map";
      tailf:cli-sequence-commands;
      tailf:cli-compact-syntax;
      leaf nr {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint8 {
          range "1..255";
          tailf:info "<1-255>;;prefix-map number";
        }
      }
      leaf access-list {
        tailf:info "Configure access-list for this prefix-map";
        tailf:cli-incomplete-command;
        type uint8 {
          range "1..255";
          tailf:info "<1-255>;;access-list number";
        }
      }
      leaf cos-map {
        tailf:info "Configure cos-map for this prefix-map";
        type uint8 {
          range "1..255";
          tailf:info "<1-255>;;cos-map number";
        }
      }
    }

    // mpls traffic-eng
    container traffic-eng {
      tailf:info "Configure Traffic Engineering parameters";
      container auto-bw {
        tailf:info "auto-bw parameters";
        container timers {
          tailf:info "Enable auto-bw Timers Collection and "
            +"Application";
          presence "Enable auto-bw Timers Collection and Application";
          leaf frequency {
            tailf:info "Interval between auto-bw data collection";
            type uint32 {
              tailf:info "<1-604800>;;seconds between auto-bw";
              range "1..604800";
            }
          }
        }
      }
      container link-management {
        tailf:info "Link Management configuration";
        container timers {
          tailf:info "Link Management timers configuration";
          leaf bandwidth-hold {
            tailf:info "Link Management bandwidth hold timer";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<1-300>;;seconds";
              range "1..300";
            }
          }
          leaf periodic-flooding {
            tailf:info "Link Management periodic flooding interval";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<0-3600>;;seconds";
              range "0..3600";
            }
          }
        }
      }
      container logging {
        tailf:info "Trap logging configuration";
        container lsp {
          tailf:info "LSP-specific traps logging configuration";
          container path-errors {
            tailf:info "Log LSP Path Error traps";
            presence "Log LSP Path Error traps";
            leaf access-list {
              tailf:cli-drop-node-name;
              type access-list-type;
            }
          }
          container preemption {
            tailf:info "Log LSP Preemption traps";
            presence "Log LSP Preemption traps";
            leaf access-list {
              tailf:cli-drop-node-name;
              type access-list-type;
            }
          }
          container reservation-errors {
            tailf:info "Log LSP Reservation Error traps";
            presence "Log LSP Reservation Error traps";
            leaf access-list {
              tailf:cli-drop-node-name;
              type access-list-type;
            }
          }
          container setups {
            tailf:info "Log LSP Establishment Traps";
            presence "Log LSP Establishment Traps";
            leaf access-list {
              tailf:cli-drop-node-name;
              type access-list-type;
            }
          }
          container teardowns {
            tailf:info "Log LSP Teardown Traps";
            presence "Log LSP Teardown Traps";
            leaf access-list {
              tailf:cli-drop-node-name;
              type access-list-type;
            }
          }
        }
        container tunnel {
          tailf:info "Tunnel-specific traps logging configuration";
          container lsp-selection {
            tailf:info "Log Tunnel LSP Selection traps";
            presence "Log Tunnel LSP Selection traps";
            leaf access-list {
              tailf:cli-drop-node-name;
              type access-list-type;
            }
          }
          container "path" {
            tailf:info "Log Tunnel Path-related traps";
            container change {
              tailf:info "Log Tunnel Path change traps";
              presence "Log Tunnel Path change traps";
              leaf access-list {
                tailf:cli-drop-node-name;
                type access-list-type;
              }
            }
          }
        }
      }
      container path-selection {
        tailf:info "Path Selection Configuration";

        leaf metric {
          tailf:info "Metric Type Configuration";
          tailf:cli-full-command;
          type enumeration {
            enum igp {
              tailf:info "Use IGP metric";
            }
            enum te {
              tailf:info "User TE metric";
            }
          }
        }
        container overload {
          tailf:info "Overload Node Configuration";
          container allow {
            tailf:info "Allow overloaded nodes in CSPFs";
            tailf:cli-sequence-commands;
            leaf head {
              tailf:info "Allow overloaded head node in TE CSPF";
              tailf:cli-optional-in-sequence;
              tailf:cli-reset-container;
              type empty;
            }
            leaf middle {
              tailf:info "Allow overloaded middle node in TE "
                +"CSPF";
              tailf:cli-optional-in-sequence;
              tailf:cli-reset-container;
              type empty;
            }
            leaf tail {
              tailf:info "Allow overloaded middle node in TE "
                +"CSPF";
              tailf:cli-optional-in-sequence;
              tailf:cli-reset-container;
              type empty;
            }
          }
        }
      }
      container reoptimize {
        tailf:info "Reoptimization parameters";
        container events {
          tailf:info "Reoptimization triggers";
          leaf link-up {
            tailf:info "Reoptimize tunnels on link up events";
            type empty;
          }
        }
        container timers {
          tailf:info "Reoptimization timers";
          container delay {
            tailf:info "Delay reoptimization action";
            leaf cleanup {
              tailf:info "Delay cleanup of reoptimized LSP";
              tailf:cli-full-command;
              type uint8 {
                range "0..60";
                tailf:info "<0-60>;;seconds to delay "
                  +"cleanup of replaced tunnel LSP";
              }
            }
            leaf installation {
              tailf:info "Delay replacement of current LSP "
                +"by reoptimized LSP";
              tailf:cli-full-command;
              type uint16 {
                range "0..3600";
                tailf:info "<0-3600>;;seconds to delay "
                  +"replacement of tunnel LSP";
              }
            }
          }
          leaf frequency {
            tailf:info "Interval between reoptimization scans";
            tailf:cli-full-command;
            type uint32 {
              tailf:info "<0-604800>;;seconds between "
                +"reoptimizations (0 disables reoptimization)";
              range "0..604800";
            }
          }
        }
      }
      container signalling {
        tailf:info "Traffic Engineering Signalling Parameters";
        container advertise {
          tailf:info "Signalling advertisement parameters";
          container implicit-null {
            tailf:info "Use MPLS encoding for Implicit-Null "
              +"Label in signalling messages";
            presence  "Use MPLS encoding for Implicit-Null "
              +"Label in signalling messages";
            leaf nr {
              tailf:cli-drop-node-name;
              type uint8 {
                range "1..99";
                tailf:info "<1-99>;;Number of IP access-list "
                  +"to determine applicable signalling peers";
              }
            }
          }
        }
        container forwarding {
          tailf:info "Control interaction of LSP signalling and "
            +"LFIB maintenance";
          leaf sync {
            tailf:info "Program linecard LFIBs before signalling "
              +"LSP label upstream";
            type empty;
          }
        }
        container restart {
          tailf:info "Signalling restart parameters";
          container neighbors {
            tailf:info "Identify signalling restart capable "
              +"neighbors";
            presence "Identify signalling restart capable "
              +"neighbors";
            leaf nr {
              tailf:cli-drop-node-name;
              type uint8 {
                range "1..99";
                tailf:info "<1-99>;;Number of IP access-list "
                  +"to determine applicable signalling peers";
              }
            }
          }
        }
      }
      container topology {
        tailf:info "Topology Database Configuration";
        container holddown {
          tailf:info "Topology Database hold down timers";

          leaf sigerr {
            tailf:info "Link hold down time for signalling errors";
            type uint16 {
              range "0..300";
              tailf:info "<0-300>;;Hold down time in seconds";
            }
          }
        }
      }
      leaf tunnels {
        tailf:info "Traffic Engineering tunnels";
        tailf:cli-full-command;
        type empty;
      }
    }
  }


  /// ========================================================================
  /// router
  /// ========================================================================

  container router {
    tailf:info "Enable a routing process";

    // router bgp *
    list bgp {
      tailf:info "Border Gateway Protocol (BGP)";
      tailf:cli-mode-name "config-router";
      tailf:cli-diff-dependency "/ios:vrf/definition";
      tailf:cli-diff-dependency "/ios:ip/vrf";
      key as-no;
      max-elements 1;
      leaf as-no {
        tailf:cli-suppress-range;
        type uint16 {
          range "1..65535";
          tailf:info "<1-65535>;;Autonomous system number";
        }
      }

      uses bgp-address-family-grouping;

      // router bgp * / address-family
      container address-family {
        tailf:info "Enter Address Family command mode";

        // router bgp * / address-family ipv4
        container no-vrf {
          tailf:cli-drop-node-name;
          list ipv4 {
            tailf:info "Address family";
            tailf:cli-full-command;
            tailf:cli-delete-when-empty;
            tailf:cli-exit-command "exit-address-family" {
              tailf:info "Exit from Address Family configuration "
                +"mode";
            }
            key unicast-multicast;
            leaf unicast-multicast {
              type enumeration {
                enum unicast {
                  tailf:code-name "ipv4_unicast";
                  tailf:info "Address Family modifier";
                }
                enum multicast {
                  tailf:code-name "ipv4_multicast";
                  tailf:info "Address Family modifier";
                }
                enum mdt {
                  tailf:info "IPv4 multicast distribution tree (MDT)";
                }
                enum tunnel {
                  tailf:info "IPv4 tunnel address prefixes.";
                }
                enum labeled-unicast {
                  tailf:info "IPv4 labeled-unicast address prefixes";
                }
              }
              tailf:key-default "unicast";
            }
            uses bgp-address-family-grouping;
          }
        }

        // router bgp * / address-family ipv4 vrf
        container with-vrf {
          tailf:cli-drop-node-name;
          list ipv4 {
            tailf:info "Address family";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key unicast-multicast;
            leaf unicast-multicast {
              type enumeration {
                enum unicast {
                  tailf:code-name "ipv4_unicast";
                  tailf:info "Address Family modifier";
                }
                enum multicast {
                  tailf:code-name "ipv4_multicast";
                  tailf:info "Address Family modifier";
                }
                enum mdt {
                  tailf:info "IPv4 multicast distribution tree (MDT)";
                }
                enum tunnel {
                  tailf:info "IPv4 tunnel address prefixes.";
                }
                enum labeled-unicast {
                  tailf:info "IPv4 labeled-unicast address prefixes";
                }
              }
              tailf:key-default "unicast";
            }
            // router bgp * / address-family ipv4 vrf *
            list vrf {
              tailf:cli-mode-name "config-router-af";
              tailf:cli-full-command;
              tailf:cli-diff-dependency "/ios:ip/vrf";
              tailf:cli-diff-dependency "/ios:vrf/definition";
              tailf:cli-exit-command "exit-address-family" {
                tailf:info "Exit from Address Family configuration "
                  +"mode";
              }
              key name;
              leaf name {
                type string {
                  tailf:info "WORD;;VPN Routing/Forwarding instance name";
                }
              }
              uses bgp-address-family-grouping;
            }
          }
        }

        // router bgp * / address-family ipv6
        list ipv6 {
          tailf:info "Address family";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          key unicast-multicast;
          leaf unicast-multicast {
            type enumeration {
              enum unicast {
                tailf:code-name "ipv6_unicast";
                tailf:info "Address Family modifier";
              }
              enum multicast {
                tailf:code-name "ipv6_multicast";
                tailf:info "Address Family modifier";
              }
            }
            tailf:key-default "unicast";
          }
          list vrf {
            tailf:cli-full-command;
            //tailf:cli-diff-dependency "/ios:ip/vrf";
            tailf:cli-diff-dependency "/ios:vrf/definition";
            tailf:cli-exit-command "exit-address-family" {
              tailf:info "Exit from Address Family configuration mode";
            }
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;VPN Routing/Forwarding "
                  +"instance name";
              }
            }
            uses bgp-address-family-grouping;
          }
          uses bgp-address-family-grouping;
        }

        // router bgp * / address-family vpnv4
        list vpnv4 {
          tailf:info "Address family";
          tailf:cli-exit-command "exit-address-family" {
            tailf:info "Exit from Address Family configuration "
            +"mode";
          }
          key unicast-multicast;
          leaf unicast-multicast {
            type enumeration {
              enum unicast {
                tailf:code-name "vpnv4_unicast";
                tailf:info "Address Family modifier";
              }
            }
            tailf:key-default "unicast";
          }
          uses bgp-address-family-grouping;
        }

        // router bgp * / address-family vpnv6
        list vpnv6 {
          tailf:info "Address family";
          tailf:cli-exit-command "exit-address-family" {
            tailf:info "Exit from Address Family configuration "
            +"mode";
          }
          key unicast-multicast;
          leaf unicast-multicast {
            type enumeration {
              enum unicast {
                tailf:code-name "vpnv6_unicast";
                tailf:info "Address Family modifier";
              }
            }
            tailf:key-default "unicast";
          }
          uses bgp-address-family-grouping;
        }

        // router bgp * / address-family nsap
        list nsap {
          tailf:info "Address family";
          tailf:cli-exit-command "exit-address-family" {
            tailf:info "Exit from Address Family configuration "
            +"mode";
          }
          key unicast-multicast;
          leaf unicast-multicast {
            type enumeration {
              enum unicast {
                tailf:code-name "nsap_unicast";
                tailf:info "Address Family modifier";
              }
            }
            tailf:key-default "unicast";
          }
          uses bgp-address-family-grouping;
        }
      }

      // router bgp * / template
      container template {
        tailf:info "Enter template command mode";
        list peer-policy {
          tailf:info "Template configuration for policy parameters";
          tailf:cli-exit-command "exit-peer-policy" {
            tailf:info "Exit from template configuration mode";
          }
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Name of peer-policy template";
            }
          }
          // FIXME: essentailly neighbour settings
        }
        list peer-session {
          tailf:info "Template configuration for session parameters";
          tailf:cli-exit-command "exit-peer-session" {
            tailf:info "Exit from template configuration mode";
          }
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Name of peer-session template";
            }
          }
          // FIXME: essentailly neighbour settings
        }
      }
    }

    // router ospfv3 *
    list ospfv3 {
      tailf:cli-mode-name "config-router";
      tailf:info "OSPFv3";
      key id;
      leaf id {
        tailf:cli-suppress-range;
        type uint16 {
          range "1..65535";
          tailf:info "<1-65535>;;Process ID";
        }
      }
      uses ospf-ospfv3-common-grouping;

      // router ospfv3 * / address-family
      container address-family {
        tailf:info "Enter Address Family command mode";
        container ipv4 {
          tailf:info "Address family";
          container unicast {
            tailf:info "Address Family Modifier";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-router-af";
            tailf:cli-full-command;
            tailf:cli-exit-command "exit-address-family" {
              tailf:info "Exit from Address Family configuration mode";
            }
            uses ospf-ospfv3-common-grouping;
            uses ospf-ospfv3-common-address-family-grouping;
          }
        }
        container ipv6 {
          tailf:info "Address family";
          container unicast {
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-router-af";
            tailf:info "Address Family Modifier";
            tailf:cli-full-command;
            tailf:cli-exit-command "exit-address-family" {
              tailf:info "Exit from Address Family configuration mode";
            }
            uses ospf-ospfv3-common-grouping;
            uses ospf-ospfv3-common-address-family-grouping;
          }
        }
      }
    }

    // router ospf *
    list ospf {
      tailf:cli-mode-name "config-router";
      tailf:info "Open Shortest Path First (OSPF)";
      key id;
      leaf id {
        tailf:cli-suppress-range;
        type uint16 {
          range "1..65535";
          tailf:info "<1-65535>;;Process ID";
        }
      }
      // router ospf * / vrf *
      list vrf {
        tailf:info "VPN Routing/Forwarding Instance";
        tailf:cli-full-command;
        tailf:cli-diff-dependency "/ios:ip/vrf";
        tailf:cli-diff-dependency "/ios:vrf/definition";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;VPN Routing/Forwarding Instance (VRF) name";
          }
        }
      }
      container non-vrf {
        tailf:cli-full-command;
        tailf:cli-drop-node-name;
        uses ospf-ospfv3-common-grouping;
        uses ospf-ospfv3-common-address-family-grouping;
        container capability {
          tailf:info "Enable specific OSPF feature";
          leaf capability-type {
            tailf:cli-drop-node-name;
            type enumeration {
              enum lls {
                tailf:info "Link-local Signaling (LLS) support";
              }
              enum opaque {
                tailf:info "Opaque LSA";
              }
              enum transit {
                tailf:info "Transit Area";
              }
            }
          }
        }
        container compatible {
          tailf:info "OSPF compatibility list";
          leaf rfc1583 {
            tailf:info "compatible with RFC 1583";
            type empty;
          }
        }
        uses distribute-list-grouping;
        container domain-id {
          tailf:info "OSPF domain-id";
          choice domain-id-choice {
            leaf ip-format {
              tailf:cli-drop-node-name;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;OSPF domain ID in IP address format";
              }
            }
            container ip-format-secondary {
              tailf:cli-drop-node-name;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              leaf ip {
                tailf:cli-drop-node-name;
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;OSPF domain ID in IP address format";
                }
              }
              leaf secondary {
                tailf:info "Secondary Domain-ID";
                type empty;
              }
            }
            leaf Null {
              tailf:info "Null Domain-ID";
              tailf:cli-full-command;
              type empty;
            }
            container type {
              tailf:info "OSPF domain ID type in Hex format";
              tailf:cli-sequence-commands;
              tailf:cli-compact-syntax;
              leaf type-leaf {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type enumeration {
                  enum "0005" {
                    tailf:info "Type 0x0005";
                  }
                  enum "0105" {
                    tailf:info "Type 0x0105";
                  }
                  enum "0205" {
                    tailf:info "Type 0x0205";
                  }
                  enum "8005" {
                    tailf:info "Type 0x8005";
                  }
                }
              }
              leaf value {
                tailf:info "OSPF domain ID value in Hex format";
                type string {
                  tailf:info "Hex-data;;OSPF domain ID ext. community "
                  +"value in Hex";
                  pattern '[0-9a-fA-F]{12}';
                }
              }
            }
          }
        }
        leaf domain-tag {
          tailf:info "OSPF domain-tag";
          tailf:cli-full-command;
          type uint32 {
            range "1 .. 4294967295";
            tailf:info "<1-4294967295>;;OSPF domain tag - 32-bit value";
          }
        }
        container ignore {
          tailf:info "Do not complain about specific event";
          container lsa {
            tailf:info "Do not complain upon receiving "
            +"LSA of the specified type";
            leaf mospf {
              tailf:info "MOSPF Type 6 LSA";
              type empty;
            }
          }
        }
        leaf ispf {
          tailf:info "Enable incremental SPF computation";
          tailf:cli-full-command;
          type empty;
        }

        //FIXME
        container limit {
          tailf:info "Limit a specific OSPF feature";
          tailf:cli-compact-syntax;
          container retransmissions {
            tailf:info "LS update, DBD, and LS request retransmissions";
            leaf non-dc {
              tailf:info "Non-demand-circuit retransmissions";
              type limit-dc-non-dc-type;
            }
            leaf dc {
              tailf:info "Demand circuit retransmissions";
              type limit-dc-non-dc-type;
            }
          }
        }

        container local-rib-criteria {
          tailf:info "Enable or disable usage of local RIB as route criteria";
          tailf:cli-compact-syntax;
          leaf forwarding-address {
            tailf:info "Local RIB used to validate external/NSSA "
            +"forwarding addresses";
            type empty;
          }
          leaf inter-area-summary {
            tailf:info "Local RIB used as criteria for inter-area summaries";
            type empty;
          }
          leaf nssa-translation {
            tailf:info "Local RIB used as criteria for NSSA translation";
            type empty;
          }
        }

        container max-metric {
          tailf:info "Set maximum metric";
          container router-lsa {
            tailf:info "Maximum metric in self-originated router-LSAs";
            presence "Maximum metric in self-originated router-LSAs";
            container external-lsa {
              tailf:info "Override external-lsa metric with max-metric value";
              presence "Override external-lsa metric with max-metric value";
              tailf:cli-flatten-container;
              leaf metric {
                tailf:cli-drop-node-name;
                type uint32 {
                  range "1 .. 16777215";
                  tailf:info "<1-16777215>;;Overriding metric in "
                  +"external-LSAs (default 16711680)";
                }
              }
            }
            leaf include-stub {
              tailf:info "Set maximum metric for stub links in router-LSAs";
              type empty;
            }
            container on-startup {
              tailf:info "Set maximum metric temporarily after reboot";
              presence "Set maximum metric temporarily after reboot";
              tailf:cli-flatten-container;
              choice time-wait-for-bgp-choice {
                leaf time {
                  tailf:cli-drop-node-name;
                  type uint32 {
                    range "5 .. 86400";
                    tailf:info "<5-86400>;;Time, in seconds, router-LSAs "
                    +"are originated with max-metric";
                  }
                }
                leaf wait-for-bgp {
                  tailf:info "Let BGP decide when to originate router-LSA "
                  +"with normal metric";
                  type empty;
                }
              }
            }
            container summary-lsa {
              tailf:info "Override summary-lsa metric with max-metric value";
              presence "Override summary-lsa metric with max-metric value";
              tailf:cli-flatten-container;
              leaf metric {
                tailf:cli-drop-node-name;
                type uint32 {
                  range "1 .. 16777215";
                  tailf:info " <1-16777215>;;Overriding metric in summary-LSAs "
                  +"(default 16711680)";
                }
              }
            }
          }
        }

        container mpls {
          tailf:info "Configure MPLS routing protocol parameters";
          container ldp {
            tailf:info "routing protocol commands for MPLS LDP";
            container autoconfig {
              tailf:info "Configure LDP automatic configuration";
              presence "Configure LDP automatic configuration";
              leaf area {
                tailf:info "Configure an OSPF area to run MPLS LDP";
                type ospf-area-type;
              }
            }
            container sync {
              tailf:info "Configure LDP-IGP Synchronization";
              presence "Configure LDP-IGP Synchronization";
            }
          }
          container traffic-eng {
            tailf:info "routing protocol commands for MPLS Traffic Engineering";
            tailf:cli-compact-syntax;
            leaf multicast-intact {
              tailf:info "MPLS TE and PIM interaction";
              tailf:cli-full-command;
              type empty;
            }
            leaf area {
              tailf:info "configure an ospf area to run "
              +"MPLS Traffic Engineering";
              tailf:cli-full-command;
              type ospf-area-type;
            }
            container interface {
              tailf:info "MPLS TE interface configuration "
              +"for this OSPF process";
              tailf:cli-sequence-commands;
              // FIXME: interface container
              leaf name {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type string {
                  tailf:info "WORD;;Interface name";
                }
              }
              leaf area {
                tailf:info "advertise MPLS TE information for this "
                +"interface into area";
                type uint32 {
                  tailf:info "<0-0>;;OSPF area ID as a decimal value";
                }
              }
            }
            container mesh-group-container {
              tailf:cli-drop-node-name;
              tailf:cli-sequence-commands;
              leaf mesh-group {
                tailf:info "Traffic Engineering Mesh-Group advertisement";
                tailf:cli-incomplete-command;
                type uint32 {
                  range "0 .. 4294967295";
                  tailf:info "<0-4294967295>;;Mesh Group Id";
                }
              }
              // FIXME: interface container
              leaf interface {
                tailf:info "Interface";
                tailf:cli-incomplete-command;
                type string {
                  tailf:info "WORD;;Interface name";
                }
              }
              list area {
                tailf:info "configure flooding scope as area";
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                key id;
                leaf id {
                  tailf:cli-suppress-range;
                  type ospf-area-type;
                }
              }
            }
            container router-id {
              tailf:info "Traffic Engineering stable IP address for system";
              // FIXME: interface container
              leaf interface {
                tailf:info "Interface";
                type string {
                  tailf:info "WORD;;Interface name";
                }
              }
            }
          }
        }

        list neighbor {
          tailf:info "Specify a neighbor router";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key ip;
          leaf ip {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Neighbor address";
            }
          }
          container cost-database-filter-container {
            tailf:cli-drop-node-name;
            tailf:cli-compact-syntax;
            leaf cost {
              tailf:info "OSPF cost for point-to-multipoint neighbor";
              type uint32 {
                range "1 .. 65535";
                tailf:info "<1-65535>;;metric";
              }
            }
            container database-filter {
              tailf:info "Filter OSPF LSA during synchronization and "
              +"flooding for point-to-multipoint neighbor";
              container all {
                tailf:info "Filter all LSA";
                tailf:cli-compact-syntax;
                leaf out {
                  tailf:info "Outgoing LSA";
                  type empty;
                }
              }
            }
          }
          container poll-interval-priority-container {
            tailf:cli-drop-node-name;
            tailf:cli-compact-syntax;
            leaf poll-interval {
              tailf:info "OSPF dead-router polling interval";
              type uint32 {
                range "0 .. 65535";
                tailf:info "<0-65535>;;Seconds";
              }

            }
            leaf priority {
              tailf:info "OSPF priority of non-broadcast neighbor";
              type uint32 {
                range "0 .. 255";
                tailf:info "<0-255>;;Priority";
              }
            }
          }
        }

        list network {
          tailf:info "Enable routing on an IP network";
          tailf:cli-incomplete-command;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key "ip mask";
          leaf ip {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Network number";
            }
          }
          leaf mask {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;OSPF wild card bits";
            }
          }
          leaf area {
            tailf:info "Set the OSPF area ID";
            type ospf-area-type;
          }
        }

        container nsf {
          tailf:info "Non-stop forwarding";
          container cisco {
            tailf:info "Cisco Non-stop forwarding";
            container helper {
              tailf:info "helper support";
              presence "helper support";
              leaf disable {
                tailf:cli-reset-container;
                tailf:info "disable helper support";
                type empty;
              }
            }
          }
          container ietf {
            tailf:info "IETF graceful restart";
            container helper {
              tailf:info "helper support";
              presence "helper support";
              leaf disable {
                tailf:cli-reset-container;
                tailf:cli-delete-container-on-delete;
                tailf:info "disable helper support";
                type empty;
              }
              leaf strict-lsa-checking {
                tailf:info "enable helper strict LSA checking";
                type empty;
              }
            }
          }
        }

        leaf prefix-suppression {
          tailf:info "OSPF prefix suppression";
          tailf:cli-full-command;
          type empty;
        }

        container process-min-time {
          tailf:info "Percentage of quantum to be used before releasing CPU";
          leaf percent {
            tailf:info "percent";
            type uint32 {
              range "1 .. 100";
              tailf:info "<1-100>;;Minimum CPU quantum";
            }
          }
        }

        container traffic-share {
          tailf:info "How to compute traffic share over alternate paths";
          container min {
            tailf:info "All traffic shared among min metric paths";
            leaf across-interface {
              tailf:info "Use different interfaces for equal-cost paths";
              type empty;
            }
          }
        }
        leaf shutdown {
          tailf:info "Shutdown the OSPF protocol under the current instance";
          tailf:cli-boolean-no;
          type boolean;
        }
        list summary-address {
          tailf:info "Configure IP address summaries";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key "ip wildcard";
          leaf ip {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP summary address";
            }
          }
          leaf wildcard {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Summary mask";
            }
          }
          choice tag-no-advertise-choice {
            leaf tag {
              tailf:info "Set tag";
              tailf:cli-full-command;
              type uint32 {
                range "0 .. 4294967295";
                tailf:info "<0-4294967295>;;32-bit tag value";
              }
            }
            leaf not-advertise {
              tailf:info "Do not advertise when translating OSPF type-7 LSA";
              type empty;
              tailf:cli-full-command;
            }
          }
        }
      }
    }

    // router isis
    container isis {
      tailf:cli-add-mode;
      tailf:info "ISO IS-IS";
      tailf:cli-mode-name "config-router";
      presence true;
      uses isis-main-grouping;
    }

    // router isis *
    container isis-container {
      tailf:cli-drop-node-name;
      list isis {
        tailf:info "ISO IS-IS";
        tailf:cli-mode-name "config-router";
        key area-tag;
        leaf area-tag {
          type string {
            tailf:info "WORD;;ISO routing area tag";
          }
        }
        uses isis-main-grouping;
      }
    }

    // router rip
    container rip {
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-router";
      tailf:info "Routing Information Protocol (RIP)";
      uses router-rip-grouping;
      container address-family {
        tailf:info "Enter Address Family command mode";
        container ipv4 {
          tailf:info "Address family";
          container unicast {
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-router-af";
            tailf:info "Address Family Modifier";
            tailf:cli-full-command;
            tailf:cli-exit-command "exit-address-family" {
              tailf:info "Exit from Address Family configuration mode";
            }
            uses router-rip-grouping;
          }
          list vrf {
            tailf:info "Specify parameters for a VPN Routing/Forwarding "+
              "instance";
            tailf:cli-full-command;
            tailf:cli-mode-name "config-router-af";
            tailf:cli-diff-dependency "/ios:ip/vrf";
            tailf:cli-diff-dependency "/ios:vrf/definition";
            tailf:cli-exit-command "exit-address-family" {
              tailf:info "Exit from Address Family configuration mode";
            }
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;VPN Routing/Forwarding instance name";
              }
            }
            uses address-family-vrf-grouping;
          }
        }
      }
      container "default" {
        tailf:info "Set a command to its defaults";
        container address-family {
          tailf:info "Enter Address Family command mode";
          container ipv4 {
            presence true;
            tailf:info "Address family";
            leaf unicast {
              tailf:info "Address Family Modifier";
              type empty;
            }
            list vrf {
              tailf:info "Specify parameters for a VPN Routing/Forwarding "+
                "instance";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-diff-dependency "/ios:ip/vrf";
              tailf:cli-diff-dependency "/ios:vrf/definition";
              key name;
              leaf name {
                type string {
                  tailf:info "WORD;;VPN Routing/Forwarding instance name";
                }
              }
            }
          }
        }
        uses default-router-rip-grouping;
        container default-information {
          tailf:info "Control distribution of default information";
          leaf originate {
            tailf:info "Distribute a default route";
            type empty;
          }
        }
        leaf default-metric {
          tailf:cli-full-command;
          tailf:info "Set metric of redistributed routes";
          type empty;
        }
        uses distance-grouping;
        uses distribute-list-grouping;
        leaf flash-update-threshold {
          tailf:cli-full-command;
          tailf:info "Specify flash update threshold in second";
          type empty;
        }
        leaf input-queue {
          tailf:cli-full-command;
          tailf:info "Specify input queue depth";
          type empty;
        }
        uses offset-list-grouping;
        leaf output-delay {
          tailf:cli-full-command;
          tailf:info "Interpacket delay for RIP updates";
          type empty;
        }
        uses passive-interface-grouping;
        container redistribute {
          tailf:info "Redistribute information from another routing protocol";
          uses default-redistribute-grouping;
        }
        container timers {
          tailf:info "Adjust routing timers";
          leaf basic {
            tailf:info "Basic routing protocol update timers";
            type empty;
          }
        }
        container traffic-share {
          tailf:info "How to compute traffic share over alternate paths";
          container min {
            tailf:info "All traffic shared among min metric paths";
            leaf across-interfaces {
              tailf:info "Use different interfaces for equal-cost paths";
              type empty;
            }
          }
        }
        leaf version {
          tailf:cli-full-command;
          tailf:info "Set routing protocol version";
          type empty;
        }
      }
    }

  }

  augment /router/rip/default/distribute-list/accesslist {
    leaf id {
      tailf:cli-drop-node-name;
      tailf:cli-prefix-key;
      mandatory true;
      tailf:cli-disallow-value "prefix|gateway";
      type default-access-list-id-type;
    }
  }
  augment /router/rip/distribute-list/accesslist {
    leaf id {
      tailf:cli-drop-node-name;
      tailf:cli-prefix-key;
      mandatory true;
      tailf:cli-disallow-value "prefix|gateway";
      type access-list-id-type;
    }
  }
  augment /router/rip/default/distribute-list/accesslist-ifname {
    leaf id {
      tailf:cli-drop-node-name;
      tailf:cli-prefix-key;
      mandatory true;
      tailf:cli-disallow-value "prefix|gateway";
      type default-access-list-id-type;
    }
  }
  augment /router/rip/distribute-list/accesslist-ifname {
    leaf id {
      tailf:cli-drop-node-name;
      tailf:cli-prefix-key;
      mandatory true;
      tailf:cli-disallow-value "prefix|gateway";
      type access-list-id-type;
    }
  }
  augment /router/rip/default/distance/distance-list {
    leaf access-list {
      tailf:cli-drop-node-name;
      type default-access-list-standard-id-type;
    }
  }
  augment /router/rip/distance/distance-list {
    leaf access-list {
      tailf:cli-drop-node-name;
      type access-list-standard-id-type;
    }
  }
  augment /router/rip/default/offset-list {
    leaf id {
      tailf:cli-incomplete-command;
      tailf:cli-drop-node-name;
      tailf:cli-prefix-key {
        tailf:cli-before-key 1;
      }
      mandatory true;
      tailf:cli-disallow-value "in|out";
      type default-offset-list-id-type;
    }
  }
  augment /router/rip/offset-list {
    leaf id {
      tailf:cli-incomplete-command;
      tailf:cli-drop-node-name;
      tailf:cli-prefix-key {
        tailf:cli-before-key 1;
      }
      mandatory true;
      tailf:cli-disallow-value "in|out";
      type offset-list-id-type;
    }
  }


  /// ========================================================================
  /// snmp
  /// ========================================================================

  container snmp {
    tailf:info "Modify non engine SNMP parameters";

    // snmp ifmib
    container ifmib {
      tailf:info "IF-MIB commands";
      // snmp ifmib ifindex
      container ifindex {
        tailf:info "ifindex persistence";
        leaf persist {
          tailf:info "Persist interface indices";
          type empty;
        }
      }
      // snmp ifmib ifalias long
      container ifalias {
        tailf:info "ifAlias description option, by default it is limited "+
          "to 64 character";
        leaf long {
          tailf:info "ifAlias description can be up to 256 characters";
          type empty;
        }
      }
    }

    // snmp mib
    container mib {
      tailf:info "MIB commands";
      // snmp mib bulkstat
      container bulkstat {
        tailf:info "Bulkstat Configuration commands";
        // snmp mib bulkstat object-list
        list object-list {
          tailf:info "Configure an Object List.";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Name of object list";
            }
          }
        }
      }
      // snmp mib persist
      leaf persist {
        tailf:info "Persistence for MIBS";
        tailf:cli-full-command;
        type enumeration {
          enum cbqos {
            tailf:info "CBQOS MIB index persistence";
          }
          enum circuit {
            tailf:info "Circuit MIB persistence";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// snmp-server
  /// ========================================================================

  container snmp-server {
    tailf:info "Modify SNMP engine parameters";
    // chassis-id        String to uniquely identify this chassis

    // snmp-server community *
    list community {
      tailf:info "Enable SNMP; set community string and access privs";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;SNMP community string";
        }
      }
      leaf view {
        tailf:info "Restrict this community to a named MIB view";
        tailf:cli-optional-in-sequence;
        type string {
          tailf:info "WORD;;MIB view to which this community has access";
        }
      }
      choice access-choice {
        leaf RO {
          tailf:info "Read-only access with this community string";
          tailf:cli-optional-in-sequence;
          type empty;
        }
        leaf RW {
          tailf:info "Read-write access with this community string";
          tailf:cli-optional-in-sequence;
          type empty;
        }
      }
      choice access-list-choice {
        case ipv6 {
          leaf ipv6 {
            tailf:info "Specify IPv6 Named Access-List";
            type string {
              tailf:info "WORD;;IPv6 Access-list name";
            }
          }
        }
        case ipv4 {
          leaf access-list-name {
            tailf:cli-drop-node-name;
            type std-acl-type;
          }
        }
      }
    }

    // snmp-server contact
    leaf "contact" {
      tailf:info "Text for mib object sysContact";
      tailf:cli-multi-value;
      type string {
        tailf:info "LINE;;identification of the contact person for this "
          +"managed node";
      }
    }
    // context           Create/Delete a context apart from default
    // drop              Silently drop SNMP packets

    // snmp-server enable
    container enable {
      tailf:info "Enable SNMP Traps or Informs";
      choice enable-choice {
        case informs {
          leaf informs {
            tailf:info "Enable SNMP Informs";
            type empty;
          }
        }
        case traps {
          // snmp-server enable traps
          container traps {
            tailf:info "Enable SNMP Traps";
            leaf aaa_server {
              tailf:info "Enable SNMP AAA Server traps";
              tailf:cli-full-command;
              type empty;
            }
            container alarms {
              tailf:info "Enable SNMP alarms traps";
              tailf:cli-delete-when-empty;
              presence true;
              leaf informational {
                type empty;
              }
            }
            container atm {
              tailf:info "Enable SNMP atm traps";
              container pvc {
                tailf:info "Enable SNMP atm pvc traps";
                tailf:cli-sequence-commands;
                tailf:cli-delete-when-empty;
                presence true;
                container extension {
                  tailf:info "Enable SNMP atm pvc extension traps";
                  tailf:cli-optional-in-sequence;
                  leaf down {
                    tailf:info "Enable SNMP atm pvc extended down trap";
                    tailf:cli-full-command;
                    type empty;
                  }
                  leaf up {
                    tailf:info "Enable SNMP atm pvc extended up traps";
                    tailf:cli-full-command;
                    type empty;
                  }
                  leaf mibversion {
                    tailf:info "Extension MIB version to be used";
                    tailf:cli-full-command;
                    type enumeration {
                      enum "1" {
                        tailf:info "Use Extension mibversion 1";
                      }
                      enum "2" {
                        tailf:info "Use Extension mibversion 2";
                      }
                    }
                  }
                  container oam {
                    tailf:info "Enable SNMP atm pvc extended oam trap";
                    container failure {
                      tailf:info "Enable SNMP atm pvc extended any oam "+
                        "failure trap";
                      leaf loopback {
                        tailf:info "Enable SNMP atm pvc extended oam loopback "+
                          "failure trap";
                        tailf:cli-full-command;
                        type empty;
                      }
                    }
                  }
                }
                leaf interval {
                  tailf:info "minimum period between successive traps";
                  tailf:cli-optional-in-sequence;
                  type uint16 {
                    tailf:info "<1-3600>;;minimum period between"+
                      " successive traps (in seconds)";
                    range "1..3600";
                  }
                }
                leaf fail-interval {
                  tailf:info "minimum period for storing the failed timestamp";
                  type uint16 {
                    tailf:info "<0-3600>;;minimum period for storing "+
                      "the failed timestamp (in seconds)";
                    range "0..3600";
                  }
                }
              }
              container subif {
                tailf:info "Enable SNMP atm subinterface traps";
                tailf:cli-sequence-commands;
                tailf:cli-delete-when-empty;
                presence true;
                leaf interval {
                  tailf:info "Interval duration in which to limit the number "+
                    "of traps sent";
                  tailf:cli-optional-in-sequence;
                  type uint16 {
                    tailf:info "<0-3600>;;Duration of rate-limiting interval "+
                      "(0-3600 seconds)";
                    range "0..3600";
                  }
                }
                leaf count {
                  tailf:info "Maximum number of traps sent per interval";
                  type uint16 {
                    tailf:info "<1-1000>  Maximum traps per interval (1-1000)";
                    range "1..1000";
                  }
                }
              }
            }
            leaf authenticate-fail {
              //FIXME: 2800 only?
              tailf:info "Enable SNMP 802.11 Authentication Fail Trap";
              tailf:cli-full-command;
              type empty;
            }
            container auth-framework {
              //FIXME: info+more?
              //FIXME: 3600 only?
              tailf:cli-delete-when-empty;
              presence true;
              leaf sec-violation {
                type empty;
              }
            }
            leaf bfd {
              //FIXME
              tailf:cli-full-command;
              type empty;
            }
            leaf bgp {
              //FIXME
              tailf:info "Enable BGP traps";
              tailf:cli-full-command;
              type empty;
            }
            container bridge {
              //FIXME: info+syntax?
              tailf:cli-delete-when-empty;
              presence true;
              leaf newroot {
                type empty;
              }
              leaf topologychange {
                type empty;
              }
            }
            leaf bstun {
              tailf:info "Enable SNMP BSTUN traps";
              tailf:cli-full-command;
              type empty;
            }
            container bulkstat {
              tailf:info "Enable Data-Collection-MIB Collection notifications";
              tailf:cli-compact-syntax;
              tailf:cli-delete-when-empty;
              presence true;
              leaf collection {
                tailf:info "Enable Data-Collection-MIB Collection "+
                  "notifications";
                type empty;
              }
              leaf transfer {
                tailf:info "Enable Data-Collection-MIB Transfer notifications";
                type empty;
              }
            }
            container call-home {
              tailf:info "Enable CISCO-CALLHOME-MIB traps";
              tailf:cli-delete-when-empty;
              presence true;
              leaf message-send-fail {
                type empty;
              }
              leaf server-fail {
                type empty;
              }
            }
            leaf c2900 {
              tailf:info "Enable SNMP c2900 traps";
              tailf:cli-full-command;
              type empty;
            }
            container c6kxbar {
              tailf:info "Enable SNMP CISCO-CAT6K-CROSSBAR-MIB traps";
              tailf:cli-delete-when-empty;
              presence true;
              leaf intbus-crcexcd {
                tailf:info "Enable SNMP cc6kxbarIntBusCRCErrExcdNotif "
                  +"notification";
                type empty;
              }
              leaf intbus-crcrcvrd {
                tailf:info "Enable SNMP cc6kxbarIntBusCRCErrRcvrdNotif "
                  +"notification";
                type empty;
              }
              leaf swbus {
                tailf:info "Enable SNMP cc6kxbarSwBusStatusChangeNotif "
                  +"notification";
                type empty;
              }
            }
            leaf casa {
              tailf:info "Enable SNMP casa traps";
              tailf:cli-full-command;
              type empty;
            }
            leaf ccme {
              tailf:cli-full-command;
              type empty;
            }
            container cef {
              //FIXME: info+syntax?
              leaf resource-failure {
                type empty;
              }
              leaf peer-state-change {
                type empty;
              }
              leaf peer-fib-state-change {
                type empty;
              }
              leaf inconsistency {
                type empty;
              }
            }
            leaf cluster {
              tailf:info "Enable Cluster traps";
              type empty;
            }
            leaf channel {
              //FIXME
              tailf:info "Enable SNMP channel traps";
              tailf:cli-full-command;
              type empty;
            }
            leaf chassis {
              tailf:info "Enable SNMP chassis traps";
              type empty;
            }
            leaf cnpd {
              tailf:info "Enable NBAR Protocol Discovery traps";
              tailf:cli-full-command;
              type empty;
            }
            leaf "config" {
              tailf:info "Enable SNMP config traps";
              tailf:cli-full-command;
              type empty;
            }
            leaf copy-config {
              tailf:info "Enable SNMP copy-config traps";
              tailf:cli-full-command;
              type empty;
            }
            leaf config-copy {
              tailf:info "Enable SNMP config-copy traps";
              tailf:cli-full-command;
              type empty;
            }
            leaf config-ctid {
              //FIXME:
              tailf:cli-full-command;
              type empty;
            }
            // snmp-server enable traps cpu
            container cpu {
              tailf:info "Allow cpu related traps";
              tailf:cli-delete-when-empty;
              presence true;
              leaf threshold {
                tailf:info "Allow CPU utilization threshold violation traps";
                type empty;
              }
            }
            container csg {
              tailf:info "Enable SNMP CSG traps";
              tailf:cli-delete-when-empty;
              presence true;
              leaf agent {
                tailf:info "Enable SNMP Agent Server traps";
                type empty;
              }
              leaf database {
                tailf:info "Enable SNMP CSG database traps";
                type empty;
              }
              leaf quota-server {
                tailf:info "Enable SNMP Quota Server traps";
                type empty;
              }
            }
            leaf dial {
              tailf:info "Enable SNMP dial control traps";
              tailf:cli-full-command;
              type empty;
            }
            leaf director {
              //FIXME
              tailf:info "Enable SNMP Distributed Director traps";
              tailf:cli-full-command;
              type empty;
            }
            leaf dlsw {
              //FIXME
              tailf:info "Enable SNMP dlsw traps";
              tailf:cli-full-command;
              type empty;
            }
            leaf deauthenticate {
              //FIXME: 2800 only?
              tailf:info "Enable SNMP 802.11 Deauthentication Trap";
              tailf:cli-full-command;
              type empty;
            }
            leaf disassociate {
              //FIXME: 2800 only?
              tailf:info "Enable SNMP 802.11 Disassociation Trap";
              tailf:cli-full-command;
              type empty;
            }
            leaf dnis {
              tailf:info "Enable SNMP DNIS traps";
              tailf:cli-full-command;
              type empty;
            }
            leaf dot11-qos {
              //FIXME: 2800 only?
              tailf:info "Enable SNMP 802.11 QoS Change Trap";
              tailf:cli-full-command;
              type empty;
            }
            container dot1x {
              leaf auth-fail-vlan {
                type empty;
              }
              leaf guest-vlan {
                type empty;
              }
              leaf no-auth-fail-vlan {
                type empty;
              }
              leaf no-guest-vlan {
                type empty;
              }
            }
            leaf ds0-busyout {
              //FIXME: 2800 only?
              tailf:info "Enable ds0-busyout traps";
              tailf:cli-full-command;
              type empty;
            }
            leaf ds1 {
              tailf:info "Enable SNMP DS1 traps";
              tailf:cli-full-command;
              type empty;
            }
            leaf ds1-loopback {
              //FIXME: 2800 only?
              tailf:info "Enable ds1-loopback traps";
              tailf:cli-full-command;
              type empty;
            }
            leaf ds3 {
              tailf:info "Enable SNMP DS3 traps";
              tailf:cli-full-command;
              type empty;
            }
            container dsp {
              tailf:info "Enable SNMP dsp traps";
              tailf:cli-delete-when-empty;
              presence true;
              leaf card-status {
                tailf:info "Enable SNMP card status of dsp traps";
                type empty;
              }
              leaf oper-state {
                //FIXME
                type empty;
              }
            }
            leaf eigrp {
              tailf:info "Enable SNMP EIGRP traps";
              tailf:cli-full-command;
              type empty;
            }
            container energywise {
              //FIXME: info+more?
              //FIXME: 3600 only?
              tailf:cli-delete-when-empty;
              presence true;
              leaf event-occured {
                type empty;
              }
              leaf level-change {
                type empty;
              }
              leaf neighbor-added {
                type empty;
              }
              leaf neighbor-deleted {
                type empty;
              }
            }
            leaf entity {
              tailf:info "Enable SNMP entity traps";
              tailf:cli-full-command;
              type empty;
            }
            container entity-diag {
              tailf:info "Enable SNMP CISCO-ENTITY-DIAG-MIB traps";
              tailf:cli-delete-when-empty;
              presence true;
              leaf boot-up-fail {
                tailf:info "Enable SNMP ceDiagBootUpFailedNotif traps";
                type empty;
              }
              leaf hm-test-recover {
                tailf:info "Enable SNMP ceDiagHMTestRecoverNotif traps";
                type empty;
              }
              leaf hm-thresh-reached {
                tailf:info "Enable SNMP ceDiagHMThresholdReachedNotif traps";
                type empty;
              }
              leaf scheduled-test-fail {
                tailf:info "Enable SNMP ceDiagScheduledTestFailedNotif traps";
                type empty;
              }
            }
            container envmon {
              //FIXME: info
              tailf:info "Enable SNMP environmental monitor traps";
              tailf:cli-delete-when-empty;
              presence true;
              leaf fan {
                type empty;
              }
              leaf shutdown {
                type empty;
              }
              leaf supply {
                type empty;
              }
              leaf temperature {
                type empty;
              }
              leaf status {
                type empty;
              }
            }

            container errdisable {
              tailf:info "Enable SNMP errdisable notifications";
              tailf:cli-delete-when-empty;
              presence true;
              leaf notification-rate {
                tailf:info "Number of notifications per minute";
                type uint16 {
                  tailf:info "<0-10000>;;Number of notificatios per minute";
                  range "0..10000";
                }
              }
            }

            leaf ether-oam {
              //FIXME: info+more?
              //FIXME: 3600 only?
              tailf:cli-full-command;
              type empty;
            }
            container ethernet {
              container cfm {
                leaf alarm {
                  tailf:info "Enable SNMP Ethernet CFM fault alarm trap";
                  type empty;
                }
                // snmp-server enable traps ethernet cfm cc
                container cc {
                  tailf:cli-delete-when-empty;
                  presence true;
                  leaf "config" {
                    type empty;
                  }
                  leaf cross-connect {
                    type empty;
                  }
                  leaf loop {
                    type empty;
                  }
                  leaf mep-down {
                    type empty;
                  }
                  leaf mep-up {
                    type empty;
                  }
                }
                // snmp-server enable traps ethernet cfm crosscheck
                container crosscheck {
                  tailf:cli-delete-when-empty;
                  presence true;
                  leaf mep-missing {
                    type empty;
                  }
                  leaf mep-unknown {
                    type empty;
                  }
                  leaf service-up {
                    type empty;
                  }
                }
              }
              container evc {
                tailf:info "Enable SNMP Ethernet EVC traps";
                tailf:cli-delete-when-empty;
                presence true;
                leaf create {
                  tailf:info "Enable SNMP Ethernet EVC create traps";
                  type empty;
                }
                leaf delete {
                  tailf:info "Enable SNMP Ethernet EVC delete traps";
                  type empty;
                }
                leaf status {
                  tailf:info "Enable SNMP Ethernet EVC status traps";
                  type empty;
                }
              }
            }
            leaf event-manager {
              tailf:info "Enable SNMP Embedded Event Manager traps";
              tailf:cli-full-command;
              type empty;
            }
            container firewall {
              tailf:cli-delete-when-empty;
              //MORE?
              presence true;
              leaf serverstatus {
                type empty;
              }
            }
            container flash {
              tailf:info "Enable SNMP FLASH notifications";
              tailf:cli-delete-when-empty;
              presence true;
              leaf insertion {
                tailf:info "Enable SNMP Flash Insertion notifications";
                type empty;
              }
              leaf removal {
                tailf:info "Enable SNMP Flash Removal notifications";
                type empty;
              }
            }
            leaf flowmon {
              tailf:info "Enabel SNMP flowmon notifications";
              type empty;
            }
            container flex-links {
              tailf:info "Enable SNMP FLEX Links traps";
              tailf:cli-delete-when-empty;
              presence true;
              leaf status {
                tailf:info "Enable SNMP FLEX Links status change traps";
                type empty;
              }
            }
            container frame-relay {
              tailf:info "Enable SNMP frame-relay traps";
              tailf:cli-delete-when-empty;
              presence true;
              container multilink {
                tailf:info "Enable MFR traps";
                leaf bundle-mismatch {
                  tailf:info "Enable MFR trap for inconsistent bundle event";
                  type empty;
                }
              }
              container subif {
                tailf:info "Enable SNMP frame-relay subinterface traps";
                tailf:cli-delete-when-empty;
                presence true;
                //FIXME: count, interval
              }
            }
            leaf fru-ctrl {
              tailf:info "Enable SNMP entity FRU control traps";
              tailf:cli-full-command;
              type empty;
            }
            leaf gatekeeper {
              tailf:info "Enable SNMP gatekeeper traps";
              tailf:cli-full-command;
              type empty;
            }
            leaf hsrp {
              tailf:info "Enable SNMP HSRP traps";
              tailf:cli-full-command;
              type empty;
            }
            leaf icsudsu {
              //FIXME: 2800 only?
              tailf:info "Enable SNMP ICSUDSU traps";
              tailf:cli-full-command;
              type empty;
            }
            leaf ima {
              tailf:info "Enable SNMP ATM IMA traps";
              tailf:cli-full-command;
              type empty;
            }
            leaf ipmobile {
              tailf:info "Enable SNMP ipmobile traps";
              tailf:cli-full-command;
              type empty;
            }
            leaf ipmulticast {
              tailf:info "Enable SNMP ipmulticast traps";
              tailf:cli-full-command;
              type empty;
            }
            container ipsec {
              tailf:info "Enable IPsec traps";
              container cryptomap {
                leaf add {
                  tailf:info "Enable IPsec Cryptomap add trap";
                  tailf:cli-full-command;
                  type empty;
                }
                leaf attach {
                  tailf:info "Enable IPsec Cryptomap Attach trap";
                  tailf:cli-full-command;
                  type empty;
                }
                leaf delete {
                  tailf:info "Enable IPsec Cryptomap delete trap";
                  tailf:cli-full-command;
                  type empty;
                }
                leaf detach {
                  tailf:info "Enable IPsec Cryptomap Detach trap";
                  tailf:cli-full-command;
                  type empty;
                }
              }
              container tunnel {
                tailf:info "Enable IPsec Tunnel traps";
                leaf start {
                  tailf:info "Enable IPsec Tunnel Start trap";
                  tailf:cli-full-command;
                  type empty;
                }
                leaf stop {
                  tailf:info "Enable IPsec Tunnel Stop trap";
                  tailf:cli-full-command;
                  type empty;
                }
              }
              leaf too-many-sas {
                tailf:info "Enable IPsec Tunnel Start trap";
                type empty;
              }
            }
            container isakmp {
              tailf:info "Enable ISAKMP traps traps";
              container policy {
                tailf:info "Enable ISAKMP traps";
                leaf add {
                  tailf:info "Enable ISAKMP Policy add trap";
                  type empty;
                }
                leaf delete {
                  tailf:info "Enable ISAKMP Policy delete trap";
                  type empty;
                }
              }
              container tunnel {
                tailf:info "Enable ISAKMP Tunnel traps";
                leaf start {
                  tailf:info "Enable ISAKMP Tunnel start trap";
                  type empty;
                }
                leaf stop {
                  tailf:info "Enable ISAKMP Tunnel stop trap";
                  type empty;
                }
              }
            }
            container isdn {
              tailf:info "Enable SNMP isdn traps";
              tailf:cli-delete-when-empty;
              presence true;
              leaf call-information {
                tailf:info "Enable SNMP isdn call information traps";
                type empty;
              }
              leaf chan-not-avail {
                tailf:info "Enable SNMP isdn channel not avail traps";
                type empty;
              }
              leaf ietf {
                tailf:info "Enable SNMP isdn ietf traps";
                type empty;
              }
              leaf layer2 {
                tailf:info "Enable SNMP isdn layer2 transition traps";
                type empty;
              }
            }
            leaf ipsla {
              //FIXME
              tailf:info "Enable IPSLA traps traps";
              tailf:cli-full-command;
              type empty;
            }
            leaf isis {
              //FIXME
              tailf:info "Enable ISIS traps traps";
              tailf:cli-full-command;
              type empty;
            }
            container l2tc {
              tailf:info "Enable SNMP L2 Tunnel Config traps";
              tailf:cli-delete-when-empty;
              presence true;
              tailf:cli-compact-syntax;
              leaf sys-threshold {
                tailf:info "Enable SNMP L2TC System threshold traps";
                type empty;
              }
              leaf threshold {
                tailf:info "Enable SNMP L2 Tunnel Config threshold traps";
                type empty;
              }
            }
            container l2tun {
              tailf:info "Enable SNMP L2 tunnel protocol traps";
              leaf session {
                tailf:info "Enable SNMP l2tun session traps";
                tailf:cli-full-command;
                type empty;
              }
              container pseudowire {
                leaf "status" {
                  type empty;
                }
              }
            }
            leaf license {
              //FIXME: info+more?
              //FIXME: 3600 only?
              tailf:cli-full-command;
              type empty;
            }
            container mac-notification {
              //FIXME: info+more?
              tailf:cli-delete-when-empty;
              presence true;
              container change {
                tailf:cli-delete-when-empty;
                presence true;
                leaf move {
                  type empty;
                }
                leaf threshold {
                  type empty;
                }
              }
            }
            container mac-notification2 {
              tailf:alt-name "MAC-Notification";
              //FIXME: info+more?
              tailf:cli-delete-when-empty;
              presence true;
              leaf move {
                type empty;
              }
              leaf threshold {
                type empty;
              }
            }
            container memory {
              //FIXME: 2800 only?
              tailf:info "Enable SNMP Memory traps";
              leaf bufferpeak {
                tailf:info "Enable SNMP Memory Bufferpeak traps";
                tailf:cli-full-command;
                type empty;
              }
            }
            leaf "module" {
              tailf:info "Enable SNMP module traps";
              type empty;
            }
            // snmp-server enable traps mpls
            container mpls {
              tailf:info "Enable SNMP MPLS traps";
              tailf:cli-delete-when-empty;
              presence true;
              container traffic-eng {
                tailf:cli-delete-when-empty;
                presence true;
                //FIXME: down, reroute, up
              }
              // snmp-server enable traps mpls fast-reroute
              container fast-reroute {
                tailf:cli-delete-when-empty;
                presence true;
                leaf protected {
                  type empty;
                }
              }
              container rfc {
                tailf:cli-delete-when-empty;
                presence true;
                leaf ldp {
                  type empty;
                }
              }
              container ldp {
                tailf:info "SNMP MPLS label distribution protocol traps";
                tailf:cli-delete-when-empty;
                presence true;
                leaf pv-limit {
                  tailf:info "Enable MPLS LDP path vector limit mismatch traps";
                  type empty;
                }
                leaf session-down {
                  tailf:info "Enable MPLS LDP session down traps";
                  type empty;
                }
                leaf session-up {
                  tailf:info "Enable MPLS LDP session up traps";
                  type empty;
                }
                leaf threshold {
                  tailf:info "Enable MPLS LDP threshold exceeded traps";
                  type empty;
                }
              }
              leaf vpn {
                type empty;
              }
            }
            leaf msdp {
              tailf:info "Enable SNMP MSDP traps";
              tailf:cli-full-command;
              type empty;
            }
            leaf mvpn {
              tailf:info "Enable Multicast Virtual Private Networks traps";
              tailf:cli-full-command;
              type empty;
            }
            container nhrp {
              tailf:cli-delete-when-empty;
              presence true;
              container nhs {
                presence true;
              }
              container nhc {
                presence true;
              }
              container nhp {
                presence true;
              }
              container quota-exceeded {
                presence true;
              }
            }
            container ospf {
              tailf:info "Enable OSPF traps";
              container state-change {
                tailf:info "State change traps";
                tailf:cli-delete-when-empty;
                presence true;
                leaf if-state-change {
                  tailf:info "Non-virtual interface state changes";
                  type empty;
                }
                leaf neighbor-state-change {
                  tailf:info "Non-virtual neighbor state changes";
                  type empty;
                }
                leaf virtif-state-change {
                  tailf:info "Virtual interface state changes";
                  type empty;
                }
                leaf virtneighbor-state-change {
                  tailf:info "Non-virtual neighbor state changes";
                  type empty;
                }
              }
              container errors {
                tailf:info "Error traps";
                tailf:cli-delete-when-empty;
                presence true;
                //FIXME: specifics
              }
              container retransmit {
                tailf:info "Packet retransmit traps";
                tailf:cli-delete-when-empty;
                presence true;
                leaf packets {
                  tailf:info "Packet retransmission on non-virtual interfaces";
                  type empty;
                }
                leaf virt-packets {
                  tailf:info "Packet retransmission on virtual interfaces";
                  type empty;
                }
              }
              container lsa {
                tailf:info "Lsa related traps";
                tailf:cli-delete-when-empty;
                presence true;
                leaf lsa-maxage {
                  tailf:info "Lsa aged to maxage";
                  type empty;
                }
                leaf lsa-originate {
                  tailf:info "New lsa originated";
                  type empty;
                }
              }
              container cisco-specific {
                tailf:info "Cisco specific traps";
                tailf:cli-delete-when-empty;
                presence true;
                container state-change {
                  tailf:info "State change traps";
                  tailf:cli-delete-when-empty;
                  presence true;
                  leaf nssa-trans-change {
                    tailf:info "Nssa translator state changes";
                    type empty;
                  }
                  container shamlink {
                    tailf:info "Sham link state change traps";
                    tailf:cli-delete-when-empty;
                    presence true;
                    leaf interface {
                      tailf:info "Sham link interface state changes";
                      type empty;
                    }
                    leaf interface-old {
                      tailf:info "Sham link interface state changes "+
                        "(deprecated)";
                      type empty;
                    }
                    leaf neighbor {
                      tailf:info "Sham link neighbor state changes";
                      type empty;
                    }
                  }
                }
                container errors {
                  tailf:info "Error traps";
                  tailf:cli-delete-when-empty;
                  presence true;
                  //FIXME: more
                }
                container errdisable {
                  tailf:info "Enable SNMP errdisable notifications";
                  tailf:cli-delete-when-empty;
                  presence true;
                  leaf notification-rate {
                    tailf:info "Number of notifications per minute";
                    type uint16 {
                      tailf:info "<0-10000>;;Number of notificatios per minute";
                      range "0..10000";
                    }
                  }
                }

                container retransmit {
                  tailf:info "Packet retransmit traps";
                  tailf:cli-delete-when-empty;
                  presence true;
                  //FIXME: more
                }
                container lsa {
                    tailf:info "Lsa related traps";
                  tailf:cli-delete-when-empty;
                    presence true;
                    leaf lsa-maxage {
                      tailf:info "Lsa aged to maxage";
                      type empty;
                    }
                    leaf lsa-originate {
                      tailf:info "New lsa originated";
                      type empty;
                    }
                }
              }
            }
            container pim {
              tailf:info "Enable SNMP PIM traps";
              tailf:cli-delete-when-empty;
              presence true;
              leaf invalid-pim-message {
                tailf:info "Enable invalid pim message trap";
                type empty;
              }
              leaf neighbor-change {
                tailf:info "Enable neighbor change trap";
                type empty;
              }
              leaf rp-mapping-change {
                tailf:info "Enable rp mapping change trap";
                type empty;
              }
            }
            container port-security {
              tailf:info "Enable SNMP port security traps";
              tailf:cli-delete-when-empty;
              presence true;
              leaf trap-rate {
                tailf:info "Number of traps per second";
                type uint16 {
                  tailf:info "<0-1000>;;Number of traps per second";
                  range "0..1000";
                }
              }
            }
            container power-ethernet {
              tailf:info "Enable SNMP power ethernet traps";
              leaf group {
                tailf:info "Enable SNMP inline power group based traps";
                type string {
                  tailf:info "WORD;;The group number or list";
                }
              }
              leaf police {
                tailf:info "Enable Policing Trap";
                type empty;
              }
            }

            leaf pppoe {
              tailf:info "Enable SNMP pppoe traps";
              tailf:cli-full-command;
              type empty;
            }
            container pw {
              //FIXME
              tailf:cli-delete-when-empty;
              presence true;
              leaf vc {
                type empty;
              }
            }
            leaf rep {
              //FIXME: info+more?
              //FIXME: 3600 only?
              tailf:cli-full-command;
              type empty;
            }
            leaf resource-policy {
              //FIXME
              tailf:cli-full-command;
              type empty;
            }
            leaf rf {
              tailf:info "Enable all SNMP traps defined in CISCO-RF-MIB";
              tailf:cli-full-command;
              type empty;
            }
            leaf rogue-ap {
              //FIXME: 2800 only?
              tailf:info "Enable SNMP 802.11 Rogue AP Trap";
              tailf:cli-full-command;
              type empty;
            }
            leaf rsvp {
              tailf:info "Enable RSVP flow change traps";
              tailf:cli-full-command;
              type empty;
            }
            leaf rtr {
              tailf:info "Enable SNMP Response Time Reporter traps";
              tailf:cli-full-command;
              type empty;
            }
            container slb {
              tailf:info "Enable SNMP SLB traps";
              tailf:cli-delete-when-empty;
              presence true;
              leaf csrp {
                tailf:info "Enable SNMP SLB Fault Tolerance Replication "
                  +"Protocol traps";
                type empty;
              }
              leaf real {
                tailf:info "Enable SNMP SLB Real Server traps";
                type empty;
              }
              leaf virtual {
                tailf:info "Enable SNMP SLB Virtual Server traps";
                type empty;
              }
            }
            container snmp {
              tailf:info "Enable SNMP traps";
              tailf:cli-compact-syntax;
              leaf authentication {
                tailf:info "Enable authentication trap";
                type empty;
              }
              leaf coldstart {
                tailf:info "Enable coldStart trap";
                type empty;
              }
              leaf linkdown {
                tailf:info "Enable linkDown trap";
                type empty;
              }
              leaf linkup {
                tailf:info "Enable linkUp trap";
                type empty;
              }
              leaf warmstart {
                tailf:info "Enable warmStart trap";
                type empty;
              }
            }
            leaf sonet {
              tailf:info "Enable SNMP SONET traps";
              type empty;
            }
            leaf srst {
              tailf:cli-full-command;
              type empty;
            }
            leaf srp {
              tailf:info "Enable SRP protocol traps";
              tailf:cli-full-command;
              type empty;
            }
            container stackwise {
              tailf:info "Enable SNMP stackwise traps";
              tailf:cli-delete-when-empty;
              presence true;
              leaf GLS {
                tailf:info "Enable STACKWISE stack power GLS trap";
                type empty;
              }
              leaf ILS {
                tailf:info "Enable STACKWISE stack power ILS trap";
                type empty;
              }
              leaf SRLS {
                tailf:info "Enable STACKWISE stack power SRLS trap";
                type empty;
              }
              leaf insufficient-power {
                tailf:info "Enable STACKWISE stack power unbalanced power "
                  +"supplies trap";
                type empty;
              }
              leaf invalid-input-current {
                tailf:info "Enable STACKWISE stack power invalid input current "
                  +"trap";
                type empty;
              }
              leaf invalid-output-current {
                tailf:info "Enable STACKWISE stack power invalid output "
                  +"current trap";
                type empty;
              }
              leaf member-removed {
                tailf:info "Enable STACKWISE stack member removed trap";
                type empty;
              }
              leaf member-upgrade-notification {
                tailf:info "Enable STACKWISE member to be reloaded for upgrade "
                  +"trap";
                type empty;
              }
              leaf new-master {
                tailf:info "Enable STACKWISE new master trap";
                type empty;
              }
              leaf new-member {
                tailf:info "Enable STACKWISE stack new member trap";
                type empty;
              }
              leaf port-change {
                tailf:info "Enable STACKWISE port change trap";
                type empty;
              }
              leaf power-budget-warning {
                tailf:info "Enable STACKWISE stack power budget warning trap";
                type empty;
              }
              leaf power-invalid-topology {
                tailf:info "Enable STACKWISE stack power invalid topology trap";
                type empty;
              }
              leaf power-link-status-changed {
                tailf:info "Enable STACKWISE stack power link status changed "
                  +"trap";
                type empty;
              }
              leaf power-oper-status-changed {
                tailf:info "Enable STACKWISE stack power port oper status "
                  +"changed trap";
                type empty;
              }
              leaf power-priority-conflict {
                tailf:info "Enable STACKWISE stack power priority conflict "
                  +"trap";
                type empty;
              }
              leaf power-version-mismatch {
                tailf:info "Enable STACKWISE stack power version mismatch "
                  +"discovered trap";
                type empty;
              }
              leaf ring-redundant {
                tailf:info "Enable STACKWISE stack ring redundant trap";
                type empty;
              }
              leaf stack-mismatch {
                tailf:info "Enable STACKWISE stack mismatch trap";
                type empty;
              }
              leaf unbalanced-power-supplies {
                tailf:info "Enable STACKWISE stack power unbalanced power "
                  +"supplies trap";
                type empty;
              }
              leaf under-budget {
                tailf:info "Enable STACKWISE stack power under budget trap";
                type empty;
              }
              leaf under-voltage {
                tailf:info "Enable STACKWISE stack power under voltage trap";
                type empty;
              }
            }
            container stpx {
              //FIXME: info+more?
              tailf:cli-delete-when-empty;
              presence true;
              leaf inconsistency {
                type empty;
              }
              leaf root-inconsistency {
                type empty;
              }
              leaf loop-inconsistency {
                type empty;
              }
            }
            leaf stun {
              tailf:info "Enable SNMP STUN traps";
              tailf:cli-full-command;
              type empty;
            }
            leaf switch-over {
              //FIXME: 2800 only?
              tailf:info "Enable SNMP 802.11 Standby Switch-over Trap";
              tailf:cli-full-command;
              type empty;
            }
            leaf syslog {
              tailf:info "Enable SNMP syslog traps";
              tailf:cli-full-command;
              type empty;
            }
            container transceiver {
              //FIXME: info+more?
              //FIXME: 3600 only?
              leaf all {
                type empty;
              }
            }
            leaf tty {
              tailf:info "Enable TCP connection traps";
              tailf:cli-full-command;
              type empty;
            }
            container udld {
              tailf:info "Enable SNMP CISCO-UDLDP-MIB traps";
              tailf:cli-compact-syntax;
              tailf:cli-delete-when-empty;
              presence true;
              leaf link-fail-rpt {
                tailf:info "Enable SNMP cudldpFastHelloLinkFailRptNotification "
                  +"traps";
                type empty;
              }
              leaf status-change {
                tailf:info "Enable SNMP "
                  +"cudldpFastHelloStatusChangeNotification traps";
                type empty;
              }
            }

            leaf vlancreate {
              //FIXME: info+more?
              //FIXME: 3600 only?
              tailf:cli-full-command;
              type empty;
            }
            leaf vlandelete {
              //FIXME: info+more?
              //FIXME: 3600 only?
              tailf:cli-full-command;
              type empty;
            }
            leaf vlan-mac-limit {
              tailf:info "Enable SNMP L2 Control VLAN MAC Limit notifications";
              type empty;
            }
            leaf vlan-membership {
              //FIXME: info+more?
              //FIXME: 3600 only?
              tailf:cli-full-command;
              type empty;
            }
            leaf voice {
              //FIXME
              tailf:info "Enable SNMP voice traps";
              tailf:cli-full-command;
              type empty;
            }
            container vrfmib {
              leaf vrf-up {
                type empty;
              }
              leaf vrf-down {
                type empty;
              }
              leaf vnet-trunk-up {
                type empty;
              }
              leaf vnet-trunk-down {
                type empty;
              }
            }
            leaf vrrp {
              tailf:info "Enable SNMP vrrp traps";
              tailf:cli-full-command;
              type empty;
            }
            leaf vsimaster {
              //FIXME
              tailf:info "Allow SNMP vsimaster traps";
              tailf:cli-full-command;
              type empty;
            }
            container vstack {
              tailf:info "Enable SNMP Smart Install traps";
              tailf:cli-delete-when-empty;
              presence true;
              tailf:cli-compact-syntax;
              leaf addition {
                tailf:info "Enable client added trap";
                type empty;
              }
              leaf failure {
                tailf:info "Enable file upload/download failure trap";
                type empty;
              }
              leaf lost {
                tailf:info "Enable client lost trap";
                type empty;
              }
              leaf operation {
                tailf:info "Enable operation mode change trap";
                type empty;
              }
            }
            leaf vtp {
              //FIXME: info+more?
              //FIXME: 3600 only?
              tailf:cli-full-command;
              type empty;
            }
            leaf wlan-wep {
              //FIXME: 2800 only?
              tailf:info "Enable SNMP 802.11 WLAN WEP Trap";
              tailf:cli-full-command;
              type empty;
            }
            leaf xgcp {
              tailf:info "Enable XGCP protocol traps";
              tailf:cli-full-command;
              type empty;
            }
          }
        }
      }
    }

    // snmp-server engine-id
    container engineID {
      tailf:info "Configure a local or remote SNMPv3 engineID";
      // snmp-server engine-id local
      leaf local {
        tailf:info "engineID of the local agent";
        type string {
          tailf:info "WORD;;engine ID octet string";
          length "1..24";
        }
      }
      container remote {
        tailf:info "engineID of the remote agent";
      }
    }
    // file-transfer     File transfer related commands

    // snmp-server group *
    list group {
      tailf:info "Define a User Security Model group";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      key id;
      leaf id {
        type string {
          tailf:info "WORD;;Name of the group";
        }
      }
      choice security-model {
        container v1 {
          tailf:info "group using the v1 security model";
        }
        container v2c {
          tailf:info "group using the v2c security model";
        }
        container v3 {
          tailf:info "group using the User Security Model (SNMPv3)";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf security-level {
            tailf:cli-drop-node-name;
            type enumeration {
              enum auth {
                tailf:info "group using the authNoPriv Security Level";
              }
              enum noauth {
                tailf:info "group using the noAuthNoPriv Security Level";
              }
              enum priv {
                tailf:info "group using SNMPv3 authPriv security level";
              }
            }
          }
          leaf context {
            tailf:cli-optional-in-sequence;
            tailf:info "specify a context to associate these views for the "
              +"group";
            type string {
              tailf:info "WORD;;context name";
            }
          }
          leaf match {
            tailf:cli-optional-in-sequence;
            tailf:info "context name match criteria";
            type enumeration {
              enum exact {
                tailf:info "match the exact context";
              }
              enum prefix {
                tailf:info "only match the context prefix";
              }
            }
          }
          leaf read {
            tailf:cli-optional-in-sequence;
            tailf:info "specify a read view for the group";
            type string {
              tailf:info "WORD;;read view name";
            }
          }
          leaf write {
            tailf:cli-optional-in-sequence;
            tailf:info "specify a write view for the group";
            type string {
              tailf:info "WORD;;write view name";
            }
          }
          leaf notify {
            tailf:cli-optional-in-sequence;
            tailf:info "specify a notify view for the group";
            type string {
              tailf:info "WORD;;notify view name";
            }
          }
          leaf access {
            tailf:info "specify an access-list associated with this group";
            type union {
              type uint8 {
                tailf:info "<1-99>;;Std IP accesslist allowing access with "
                  +"this group";
                range "1..99";
              }
              type string {
                tailf:info "WORD;;Access-list name";
              }
            }
          }
        }
      }
    }

    // snmp-server host *
    list host {
      tailf:info "Specify hosts to receive SNMP notifications";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-sequence-commands;
      tailf:cli-compact-syntax;
      tailf:cli-incomplete-command;
      key ip-address;
      leaf ip-address {
        type host-type {
          tailf:info "WORD;;Hostname or IP/IPv6 address of SNMP"+
            " notification host";
        }
      }
      leaf vrf {
        tailf:info "VPN Routing instance for this host";
        tailf:cli-optional-in-sequence;
        tailf:cli-incomplete-command;
        tailf:cli-diff-dependency "/ios:ip/vrf";
        tailf:cli-diff-dependency "/ios:vrf/definition";
        type string;
      }
      choice informs-traps-choice {
        leaf informs {
          tailf:info "Send Inform messages to this host";
          tailf:cli-optional-in-sequence;
          tailf:cli-incomplete-command;
          type empty;
        }
        leaf traps {
          tailf:info "Send Trap messages to this host";
          tailf:cli-optional-in-sequence;
          tailf:cli-incomplete-command;
          type empty;
        }
        default traps;
      }
      // snmp-server host * version
      container version {
        tailf:info "SNMP version to use for notification messages";
        tailf:cli-optional-in-sequence;
        tailf:cli-flatten-container;
        tailf:cli-incomplete-command;
        leaf version {
          tailf:cli-drop-node-name;
          type enumeration {
            enum "1" {
              tailf:info "Use SNMPv1";
            }
            enum "2c" {
              tailf:info "Use SNMPv2c";
            }
            enum "3" {
              tailf:info "Use SNMPv3";
            }
          }
        }
        leaf security-level {
          tailf:cli-drop-node-name;
          when "../version = '3'";
          type enumeration {
            enum auth {
              tailf:info "Use the SNMPv3 authNoPriv Security Level";
            }
            enum noauth {
              tailf:info "Use the SNMPv3 noAuthNoPriv Security Level";
            }
            enum priv {
              tailf:info "Use the SNMPv3 authPriv Security Level";
            }
          }
        }
      }
      // snmp-server host * community-string
      list community-string {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;SNMPv1/v2c community string or SNMPv3 user name";
          }
        }
        leaf aaa_server {
          tailf:info "Allow SNMP AAA traps";
          type empty;
        }
        leaf alarms {
          tailf:info "Allow SNMP alarms traps";
          type empty;
        }
        leaf atm {
          tailf:info "Allow SNMP atm traps";
          type empty;
        }
        leaf bfd {
          tailf:info "Allow SNMP BFD traps";
          type empty;
        }
        leaf bgp {
          tailf:info "Allow BGP state change traps";
          type empty;
        }
        leaf bstun {
          tailf:info "Allow bstun event traps";
          type empty;
        }
        leaf bulkstat {
          tailf:info "Allow Data-Collection-MIB traps";
          type empty;
        }
        leaf call-home {
          tailf:info "Allow SNMP CISCO-CALLHOME-MIB traps";
          type empty;
        }
        leaf casa {
          tailf:info "Allow casa event traps";
          type empty;
        }
        leaf cef {
          tailf:info "Allows cef traps";
          type empty;
        }
        leaf cnpd {
          tailf:info "Allow NBAR Protocol Discovery traps";
          type empty;
        }
        leaf config {
          tailf:info "Allow SNMP config traps";
          type empty;
        }
        leaf config-copy {
          tailf:info "Allow SNMP config-copy traps";
          type empty;
        }
        leaf config-ctid {
          tailf:info "Allow SNMP config-ctid traps";
          type empty;
        }
        leaf cpu {
          tailf:info "Allow cpu related traps";
          type empty;
        }
        leaf dhcp {
          tailf:info "Allow dhcp traps";
          type empty;
        }
        leaf dlsw {
          tailf:info "Allow dlsw traps";
          type empty;
        }
        leaf ds1 {
          tailf:info "Allow SNMP ds1 traps";
          type empty;
        }
        leaf dsp {
          tailf:info "Allow SNMP DSP traps";
          type empty;
        }
        leaf dspu {
          tailf:info "Allow dspu event traps";
          type empty;
        }
        leaf eigrp {
          tailf:info "Allow SNMP EIGRP traps";
          type empty;
        }
        leaf entity {
          tailf:info "Allow SNMP entity traps";
          type empty;
        }
        leaf entity-diag {
          tailf:info "Allow SNMP CISCO-ENTITY-DIAG-MIB traps";
          type empty;
        }
        leaf entity-qfp {
          tailf:info "Allow SNMP CISCO-ENTITY-QFP-MIB traps";
          type empty;
        }
        leaf entity-state {
          tailf:info "Allow ENTITY-STATE-MIB traps";
          type empty;
        }
        leaf ethernet-cfm {
          tailf:info "Allow SNMP Ethernet CFM traps";
          type empty;
        }
        leaf evc {
          tailf:info "Allow SNMP EVC traps";
          type empty;
        }
        leaf event-manager {
          tailf:info "Allow SNMP Embedded Event Manager traps";
          type empty;
        }
        leaf firewall {
          tailf:info "Allow SNMP Firewall traps";
          type empty;
        }
        leaf flash {
          tailf:info "Allow SNMP FLASH traps";
          type empty;
        }
        leaf flowmon {
          tailf:info "Allow SNMP flow monitor notifications";
          type empty;
        }
        leaf frame-relay {
          tailf:info "Allow SNMP frame-relay traps";
          type empty;
        }
        leaf fru-ctrl {
          tailf:info "Allow entity FRU control traps";
          type empty;
        }
        leaf gdoi {
          tailf:info "Allows gdoi traps";
          type empty;
        }
        leaf hsrp {
          tailf:info "Allow SNMP HSRP traps";
          type empty;
        }
        leaf iplocalpool {
          tailf:info "Allow SNMP IP Local Pool traps";
          type empty;
        }
        leaf ipmulticast {
          tailf:info "Allow SNMP ipmulticast traps";
          type empty;
        }
        leaf ipsec {
          tailf:info "Allow SNMP IPsec traps";
          type empty;
        }
        leaf ipsla {
          tailf:info "Allow SNMP Host IP SLA traps";
          type empty;
        }
        leaf isakmp {
          tailf:info "Allow SNMP ISAKMP traps";
          type empty;
        }
        leaf isg-mib {
          tailf:info "Allow SNMP isgmib traps";
          type empty;
        }
        leaf isis {
          tailf:info "Allow IS-IS traps";
          type empty;
        }
        leaf l2tun-pseudowire-status {
          tailf:info "Allow SNMP L2 pseudowire status traps";
          type empty;
        }
        leaf l2tun-session {
          tailf:info "Allow SNMP L2 session traps";
          type empty;
        }
        leaf license {
          tailf:info "Allow license traps";
          type empty;
        }
        leaf memory {
          tailf:info "Allow SNMP Mempool traps";
          type empty;
        }
        leaf mpls-fast-reroute {
          tailf:info "Allow SNMP MPLS traffic engineering fast reroute traps";
          type empty;
        }
        leaf mpls-ldp {
          tailf:info "Allow SNMP MPLS label distribution protocol traps";
          type empty;
        }
        leaf mpls-traffic-eng {
          tailf:info "Allow SNMP MPLS traffic engineering traps";
          type empty;
        }
        leaf mpls-vpn {
          tailf:info "Allow SNMP MPLS Virtual Private Network traps";
          type empty;
        }
        leaf msdp {
          tailf:info "Allow SNMP MSDP traps";
          type empty;
        }
        leaf mvpn {
          tailf:info "Allow Multicast Virtual Private Network traps";
          type empty;
        }
        leaf nhrp {
          tailf:info "Allow SNMP NHRP traps";
          type empty;
        }
        leaf ospf {
          tailf:info "Allow OSPF traps";
          type empty;
        }
        leaf ospfv3 {
          tailf:info "Allow OSPFv3 traps";
          type empty;
        }
        leaf pfr {
          tailf:info "Allow SNMP PfR traps";
          type empty;
        }
        leaf pim {
          tailf:info "Allow SNMP PIM traps";
          type empty;
        }
        leaf pw-vc {
          tailf:info "Allow SNMP Pseudowire VC traps";
          type empty;
        }
        leaf resource-policy {
          tailf:info "Enable CISCO-ERM-MIB notifications";
          type empty;
        }
        leaf rf {
          tailf:info "Allow all SNMP traps defined in CISCO-RF-MIB";
          type empty;
        }
        leaf rsrb {
          tailf:info "Allow rsrb event traps";
          type empty;
        }
        leaf rsvp {
          tailf:info "Allow RSVP flow change traps";
          type empty;
        }
        leaf sdlc {
          tailf:info "Allow sdlc event traps";
          type empty;
        }
        leaf sdllc {
          tailf:info "Allow sdllc event traps";
          type empty;
        }
        leaf snmp {
          tailf:info "Allow SNMP-type notifications";
          type empty;
        }
        leaf sonet {
          tailf:info "Allow SNMP SONET traps";
          type empty;
        }
        leaf srp {
          tailf:info "Allow SRP protocol traps";
          type empty;
        }
        leaf stun {
          tailf:info "Allow stun event traps";
          type empty;
        }
        leaf syslog {
          tailf:info "Allow SNMP syslog traps";
          type empty;
        }
        leaf trustsec-sxp {
          tailf:info "Allow SNMP CISCO-TRUSTSEC-SXP-MIB traps";
          type empty;
        }
        leaf tty {
          tailf:info "Allow TCP connection traps";
          type empty;
        }
        leaf udp-port {
          tailf:info "The notification host's UDP port number (default port "
            +"162)";
          type empty;
        }
        leaf voice {
          tailf:info "Allow SNMP Voice traps";
          type empty;
        }
        leaf vrfmib {
          tailf:info "Allow SNMP vrfmib traps";
          type empty;
        }
        leaf vrrp {
          tailf:info "Allow SNMP vrrp traps";
          type empty;
        }
        leaf x25 {
          tailf:info "Allow x25 event traps";
          type empty;
        }
      }
    }

    // snmp-server ip
    container ip {
      tailf:info "IP ToS configuration for SNMP traffic";
      // snmp-server ip precedence
      leaf precedence  {
        tailf:info "IP Precedence value for SNMP traffic";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<0-7>;;ip precedence value (default value 0)";
          range "0..7";
        }
      }
    }

    // snmp-server ifindex
    container ifindex {
      tailf:info "Enable ifindex persistence";
      leaf persist {
        tailf:info "Persist interface indices";
        type empty;
      }
    }
    // inform            Configure SNMP Informs options

    // snmp-server location
    leaf location {
      tailf:info "Text for mib object sysLocation";
      tailf:cli-multi-value;
      type string {
        tailf:info "LINE;;The physical location of this node";
      }
    }

    // snmp-server manager
    container manager {
      tailf:info "Modify SNMP manager parameters";
      tailf:cli-display-separated;
      presence true;
      leaf session-timeout {
        tailf:info "Timeout value for destroying sessions";
        type uint32 {
          tailf:info "<10-2147483>;;seconds";
          range "10..2147483";
        }
      }
    }

    // packetsize        Largest SNMP packet size

    // snmp-server queue-length
    leaf queue-length {
      tailf:info "Message queue length for each TRAP host";
      type uint16 {
        tailf:info "<1-5000>;;Queue length (default 10)";
        range "1..5000";
      }
    }

    // snmp-server source-interface
    container source-interface {
      tailf:info "Assign an source interface";
      container informs {
        tailf:info "source interface for informs";
        tailf:cli-diff-dependency "/ios:interface";
        uses interface-grouping;
      }
      container traps {
        tailf:info "source interface for traps";
        tailf:cli-diff-dependency "/ios:interface";
        uses interface-grouping;
      }
    }

    // system-shutdown   Enable use of the SNMP reload command
    // tftp-server-list  Limit TFTP servers used via SNMP

    // snmp-server trap
    container trap {
      tailf:info "SNMP trap options";
      leaf timeout {
        tailf:info "Set timeout for TRAP message retransmissions";
        type uint16 {
          tailf:info "<1-1000>;;Timeout (default 30 seconds)";
          range "1..1000";
        }
      }
    }

    // snmp-server trap-source
    container trap-source {
      tailf:info "Assign an interface for the source address of all traps";
      tailf:cli-diff-dependency "/ios:interface";
      uses interface-grouping;
    }

    // trap-timeout      Set timeout for TRAP message retransmissions
    // user              Define a user who can access the SNMP engine

    // snmp-server view *
    list view {
      tailf:info "Define an SNMPv2 MIB view";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key "name mib";
      leaf name {
        type string {
          tailf:info "WORD;;Name of the view";
        }
      }
      leaf mib {
        type string {
          tailf:info "WORD;;MIB view family name";
        }
      }
      leaf inc-exl {
        tailf:cli-drop-node-name;
        type enumeration {
          enum excluded {
            tailf:info "MIB family is excluded from the view";
          }
          enum included {
            tailf:info "MIB family is included in the view";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// dot11
  /// ========================================================================

  container dot11 {
    tailf:info "IEEE 802.11 config commands";

    // dot11 syslog
    leaf syslog {
      tailf:info "Enable syslog";
      tailf:cli-full-command;
      type empty;
    }
  }


  /// ========================================================================
  /// license
  /// ========================================================================

  container license {
    //FIXME: hidden on 2800?
    tailf:info "Configure license features";

    // license udi
    container udi {
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-reset-container;
      leaf pid {
        type string;
      }
      leaf sn {
        type string;
      }
    }

    // license boot
    container boot {
      tailf:info "license boot config commands";
      container level {
        tailf:info "which level to boot";
        container ipbase {
          tailf:info "ipbase level";
          tailf:cli-display-separated;
          presence true;
          leaf switch {
            tailf:info "Switch license information";
            type uint8;
          }
        }
        container ipservices {
          tailf:info "ipservices level";
          tailf:cli-display-separated;
          presence true;
          leaf switch {
            tailf:info "Switch license information";
            type empty;
          }
        }
        container lanbase {
          tailf:info "lanbase level";
          tailf:cli-display-separated;
          presence true;
          leaf switch {
            tailf:info "Switch license information";
            type empty;
          }
        }
      }
    }
    //  call-home  license call-home config commands
  }


  /// ========================================================================
  /// voice-card
  /// ========================================================================

  list voice-card {
    tailf:info "Configure a specific voice-card";
    tailf:cli-mode-name "config-voicecard";
    key slot;
    leaf slot {
      type uint8 {
        tailf:info "<0-2>;;Voice interface slot #";
        range "0..2";
      }
    }
  }


  /// ========================================================================
  /// card
  /// ========================================================================

  container card {
    tailf:cli-reset-container;
    tailf:cli-compact-syntax;
    tailf:cli-sequence-commands;
    // card type
    leaf "type" {
      tailf:cli-incomplete-command;
      tailf:cli-remove-before-change;
      type enumeration {
        enum t1 {
        }
        enum e1 {
        }
      }
    }
    leaf slot {
      tailf:cli-drop-node-name;
      type uint32;
    }
    leaf bay {
      tailf:cli-drop-node-name;
      type uint32;
    }
  }


  /// ========================================================================
  /// event
  /// ========================================================================

  container event {
    tailf:info "Event related configuration commands";

    // event manager
    container manager {
      tailf:info "Event Manager configuration commands";

      // event manager applet *
      list applet {
        tailf:info "Register an Event Manager applet";
        tailf:cli-mode-name "config-applet";
        tailf:cli-exit-command "exit" {
          tailf:info "Exit from Event Manager applet configuration submode";
        }
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of the Event Manager applet";
          }
        }
        // event manager applet * authorization
        leaf authorization  {
          tailf:info "Specify an authorization type for the applet";
          tailf:cli-hide-in-submode;
          type enumeration {
            enum bypass {
              tailf:info "EEM aaa authorization type bypass";
            }
          }
        }
        // event manager applet * class
        leaf class {
          tailf:info "Specify a class for the applet";
          tailf:cli-hide-in-submode;
          type string {
            tailf:info "Class A-Z | default - default class";
            pattern "[A-Z]|default";
          }
        }
        // event manager applet * trap
        leaf trap {
          tailf:info "Generate an SNMP trap when applet is triggered.";
          tailf:cli-hide-in-submode;
          type empty;
        }

        // event manager applet * / event
        container event {
          tailf:info "Add or modify event information";
          // event manager applet * / event snmp-notification
          container snmp-notification {
            tailf:info "SNMP Notification Event";
            tailf:cli-compact-syntax;
            tailf:cli-reset-container;
            leaf oid {
              tailf:info "Object ID of data element";
              type string {
                tailf:info "WORD;;OID string";
              }
            }
            leaf oid-val {
              tailf:info "Comparison value";
              type string {
                tailf:info "WORD;;Comparision value";
              }
            }
            leaf op {
              tailf:info "Operator";
              type operator-type;
            }
            leaf src-ip-address {
              tailf:info "Source ip address";
              type union {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Source ip address value";
                }
                type inet:ipv6-address {
                  tailf:info "X:X:X:X::X;;Source ip address value";
                }
              }
            }
            leaf dest-ip-address {
              tailf:info "Destination ip address";
              type union {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Destination ip address value";
                }
                type inet:ipv6-address {
                  tailf:info "X:X:X:X::X;;Destination ip address value";
                }
              }
            }
          }
          // event manager applet * / event syslog
          container syslog {
            tailf:info "Syslog event";
            // event manager applet * / event syslog pattern
            leaf "pattern" {
              tailf:info "Pattern match string for the entire message";
              type string {
                tailf:info "WORD;;Pattern match string for the entire message";
              }
            }
          }
        }

        // event manager applet * / action *
        list action {
          tailf:info "Add or modify an action statement";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          tailf:cli-compact-syntax;
          tailf:cli-reset-container;
          ordered-by "user";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Label";
            }
          }
          // event manager applet * / action * if
          container "if" {
            tailf:info "if conditional";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            tailf:cli-reset-container;
            leaf string-op-1 {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type string {
                tailf:info "WORD;;first operand";
              }
            }
            leaf keyword {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type operator-type;
            }
            leaf string-op-2 {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "WORD;;second operand";
              }
            }
            leaf "goto" {
              tailf:info "goto label";
              type string {
                tailf:info "WORD;;label";
              }
            }
          }
          // event manager applet * / action * info
          container info {
            tailf:info "Obtain system specific information";
            // event manager applet * / action info type
            container "type" {
              tailf:info "Type of information to obtain";
              tailf:cli-full-no;
              container snmp {
                tailf:info "SNMP information";
                // event manager applet * / action info type snmp var
                container var {
                  tailf:info "Trap variable";
                  tailf:cli-compact-syntax;
                  tailf:cli-sequence-commands;
                  tailf:cli-reset-container;
                  leaf variable-name {
                    tailf:cli-drop-node-name;
                    tailf:cli-incomplete-command;
                    type string {
                      tailf:info "WORD;;Trap variable name";
                    }
                  }
                  leaf oid {
                    tailf:info "SNMP object id";
                    tailf:cli-incomplete-command;
                    type string {
                      tailf:info "WORD;;oid string";
                    }
                  }
                  leaf oid-type {
                    tailf:cli-drop-node-name;
                    tailf:cli-incomplete-command;
                    type enumeration {
                      enum counter {
                        tailf:info "Counter value";
                      }
                      enum gauge {
                        tailf:info "Gauge value";
                      }
                      enum int {
                        tailf:info "Integer value";
                      }
                      enum ipv4 {
                        tailf:info "IPv4 address";
                      }
                      enum octet {
                        tailf:info "Octet value";
                      }
                      enum string {
                        tailf:info "String value";
                      }
                      enum uint {
                        tailf:info "Unsigned integer value";
                      }
                    }
                  }
                  leaf oid-type-value {
                    tailf:cli-drop-node-name;
                    type string;  // wildcard for many oid-types.
                  }
                }
                // event manager applet * / action info type snmp trap
                container trap {
                  tailf:info "SNMP trap";
                  tailf:cli-compact-syntax;
                  tailf:cli-sequence-commands;
                  tailf:cli-reset-container;
                  leaf enterprise-oid {
                    tailf:info "Enterprise oid";
                    tailf:cli-incomplete-command;
                    type string {
                      tailf:info "WORD;;Enterprise oid string";
                    }
                  }
                  leaf generic-trapnum {
                    tailf:info "Generic trap number";
                    tailf:cli-incomplete-command;
                    type uint32 {
                      tailf:info "<0-4294967295>;;Generic trap number";
                    }
                  }
                  leaf specific-trapnum {
                    tailf:info "Specific trap number";
                    tailf:cli-incomplete-command;
                    type uint32 {
                      tailf:info "<0-4294967295>;;Specific trap number";
                    }
                  }
                  leaf trap-oid {
                    tailf:info "Trap oid";
                    tailf:cli-incomplete-command;
                    type string {
                      tailf:info "WORD;;oid string";
                    }
                  }
                  leaf trap-var {
                    tailf:info "Trap variable";
                    type string {
                      tailf:info "WORD;;Trap variable name";
                    }
                  }
                }
              }
            }
          }
          // event manager applet * / action * end
          leaf end {
            tailf:info "end conditional block";
            type empty;
          }
          // event manager applet * / action * regexp
          container regexp {
            tailf:info "regular expression match";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            tailf:cli-reset-container;
            leaf string-pattern {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type string {
                tailf:info "WORD;;regular expression pattern";
              }
            }
            leaf string-input {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "WORD;;input string";
              }
            }
            leaf string-match {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "WORD;;match variable";
              }
            }
            leaf string-submatch1 {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "WORD;;submatch variable";
              }
            }
            leaf string-submatch2 {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "WORD;;submatch variable";
              }
            }
            leaf string-submatch3 {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "WORD;;submatch variable";
              }
            }
          }
          // event manager applet * / action * snmp-trap
          container snmp-trap {
            tailf:info "Send an SNMP trap";
            tailf:cli-compact-syntax;
            tailf:cli-delete-when-empty;
            presence true;
            leaf intdata1 {
              tailf:info "SNMP integer data1";
              type int32 {
                tailf:info "<-2147483648 - 2147483647>;;SNMP trap integer "+
                  "value1";
              }
            }
            leaf intdata2 {
              tailf:info "SNMP integer data2";
              type int32 {
                tailf:info "<-2147483648 - 2147483647>;;SNMP trap integer "+
                  "value2";
              }
            }
            leaf strdata {
              tailf:info "SNMP trap string";
              type string {
                tailf:info "WORD  SNMP trap string value";
              }
            }
          }
          // event manager applet * / action * string
          container string {
            tailf:info "string commands";
            // event manager applet * / action string trim
            leaf trim {
              tailf:info "trim characters from both ends of string";
              type string;
            }
          }
          // event manager applet * / action * syslog
          container syslog {
            tailf:info "Log a syslog message";
            tailf:cli-compact-syntax;
            leaf facility {
              tailf:info "Facility string";
              type string {
                tailf:info "WORD;;facility string";
              }
            }
            leaf msg {
              tailf:info "Syslog message";
              type string {
                tailf:info "WORD;;message string";
              }
            }
            leaf priority {
              tailf:info "Priority of syslog message";
              type logging-level-type;
            }
          }
        }

        // event manager applet * / description
        leaf "description" {
          tailf:info "Add or modify an applet description";
          tailf:cli-full-command;
          tailf:cli-multi-value;
          type string {
            tailf:info "LINE;;description";
          }
        }

        // event manager applet * / trigger
        container trigger {
          tailf:info "Enter applet trigger configuration submode";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-applet-trigger";
        }
      }
    }
  }


  /// ========================================================================
  /// disable-eadi
  /// ========================================================================

  leaf disable-eadi {
    tailf:cli-full-command;
    type empty;
  }


  /// ========================================================================
  /// memory-size
  /// ========================================================================

  container memory-size {
    tailf:info "Adjust memory size by percentage";
    leaf iomem {
      tailf:info "I/O memory";
      type uint8 {
        tailf:info "<5-25>;;percentage of DRAM to use for I/O memory: "+
          "5, 10, 15, 20, 25";
        range "5..25" {
          tailf:step 5;
        }
      }
    }
  }


  /// ========================================================================
  /// transceiver
  /// ========================================================================

  container transceiver {
    tailf:info "Select from transceiver configuration commands";
    container "type" {
      tailf:info "type keyword";

      // transceiver type all
      container all {
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-xcvr-type";
        tailf:cli-full-command;
        // transceiver type all / monitoring
        container monitoring {
          tailf:info "Enable/disable monitoring";
          presence true;
          leaf interval {
            tailf:info "Set interval for monitoring";
            type uint16 {
              tailf:info "<300-3600>;;Time interval for monitoring "+
                "transceiver in seconds";
              range "300..3600";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  //                          EOF
  /// ========================================================================

}
