// =========================================================================
//                          CISCO-IOS NED
// =========================================================================

module tailf-ned-cisco-ios {
  namespace "urn:ios";
  prefix ios;

  import tailf-common {
    prefix tailf;
  }
  import ietf-inet-types {
    prefix inet;
  }
  import ietf-yang-types {
    prefix yang;
  }
  import cliparser-extensions-v11 {
    prefix cli;
  }


  // =========================================================================
  // REVISION
  // =========================================================================

  revision 2022-01-21 {
    description "version 6.77.10, see CHANGES";
  }


  // =========================================================================
  // NSO NOTES
  // =========================================================================

  // tailf:cli-diff-*-after much faster than tailf:cli-diff-*-before


  // =========================================================================
  // MODULE-META-DATA
  // =========================================================================

  cli:module-meta-data {
    cli:forced-when-eval-in-path "^/policy-map/(class-default/)?class/inspect-police$";
    cli:forced-when-eval-in-path "^/policy-map/(class-default/)?class/police-[^/]+/police$";
    cli:forced-when-eval-in-path "^/snmp-server/community-list$";
    cli:forced-when-eval-in-path "^/policy-map/(class-default/)?class/police-[^/]+/police/cir/percent$";
    cli:forced-when-eval-in-path "^/crypto/map/seq-list/(gdoi-)?set$";
    cli:forced-when-eval-in-path "^/ip/access-list/(standard|extended|filter-list|resequence)$";
    cli:forced-when-eval-in-path "^/ip/prefix-list/.*$";
    cli:forced-when-eval-in-path "^/ipv6/prefix-list/.*$";
    cli:forced-when-eval-in-path "^/ipv6/access-list/(named-acl|filter-list)$";

    cli:forced-relaxed-parse-in-path "^/policy-map/(class-default/)?class/police-policy-map/police$";
    cli:forced-relaxed-parse-in-path "^/policy-map/(class-default/)?class/police-cir-percent/police/cir/percent$";
  }


  // =========================================================================
  // EXTENSION - FROM-DEVICE
  // =========================================================================

  /*
   * class-map * / match dscp *
   */
  extension prune-leaf-list-duplicates {
    cli:direction "from-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.ios.IOSCliExtensions.pruneLeafListDuplicates";
  }

  /*
   * interface Cable* / downstream Cable * rf-channel *
   * interface Cable* / downstream Modular-Cable * rf-channel *
   * interface Cable* / downstream Integrated-Cable * rf-channel *
   * interface Cable* / downstream Downstream-Cable * rf-channel *
   */
  extension split-range-from {
    cli:direction "from-device";
    cli:state "pre-match";
    cli:java-callback-method "com.tailf.packages.ned.ios.IOSCliExtensions.splitRangeFrom";
  }

  // cable fiber-node * / upstream sg-channel *
  extension cable-sg-channel-split-range {
    cli:direction "from-device";
    cli:state "pre-match";
    cli:java-callback-method "com.tailf.packages.ned.ios.IOSCliExtensions.cableSgChannelSplitRange";
  }

  // router isis * / authentication key-chain
  extension level-1-2-expand {
    cli:direction "from-device";
    cli:state "pre-match";
    cli:java-callback-method "com.tailf.packages.ned.ios.IOSCliExtensions.level12Expand";
  }

  /* UNUSED
    extension string-quote-input {
    cli:direction "from-device";
    cli:state "pre-match|call-once";
    cli:java-callback-method "com.tailf.packages.ned.ios.IOSCliExtensions.stringQuoteInput";
  }
  */


  // =========================================================================
  // EXTENSION - BOTH
  // =========================================================================

  extension device-range-list-last {
    cli:direction "both";
    cli:state "pre-match|post-match";
    cli:java-callback-method "com.tailf.packages.ned.ios.IOSCliExtensions.deviceRangeListLast";
  }

  extension string-multi-transform {
    cli:direction "both";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.ios.IOSCliExtensions.stringMultiTransform";
  }

  extension regex-string {
    cli:direction "both";
    cli:state "post-match|pre-match";
    cli:java-callback-method "com.tailf.packages.ned.ios.IOSCliExtensions.regexString";
  }


  // =========================================================================
  // EXTENSION - TO-DEVICE CAPTURE-CONTEXT
  // =========================================================================

  /*
   * router ospf * vrf
   */
  extension list-redeploy {
    cli:direction "to-device";
    cli:state "capture-context";
    cli:java-callback-method "com.tailf.packages.ned.ios.IOSCliExtensions.listRedeploy";
  }

  /*
   * METHOD 2 - 'ned-settings cisco-ios api new-ip-access-list true'
   * ip access-list standard *
   * ip access-list extended *
   */
  extension new-ip-acl-type-change {
    cli:direction "to-device";
    cli:state "capture-context";
    cli:java-callback-method "com.tailf.packages.ned.ios.IOSCliExtensions.NewIpAclTypeChange";
  }

  /*
   * cable fiber-node *
   */
  extension cable-fiber-node-modify {
    cli:direction "to-device";
    cli:state "capture-context";
    cli:java-callback-method "com.tailf.packages.ned.ios.IOSCliExtensions.cableFiberNodeModify";
  }

  /*
   * ap country
   */
  extension ap-dot11-shutdown {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.ios.IOSCliExtensions.apDot11Shutdown";
  }


  // =========================================================================
  // EXTENSION - TO-DEVICE MULTI-LINE
  // =========================================================================

  /*
   * interface * / vrf forwarding
   * interface * / ip vrf forwarding
   */
  extension if-vrf-restore {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.ios.IOSCliExtensions.ifVrfRestore";
  }

  /*
   * cable video / logical-edge-device * / protocol gqi
   * cable video / logical-edge-device * / protocol table-based
   * controller Integrated-Cable * / rf-chan *
   * crypto pki server *
   * crypto tls-tunnel *
   * pm-agent
   * virtual-service *
   */
  extension shutdown-before-modify {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.ios.IOSCliExtensions.shutdownBeforeModify";
  }


  // =========================================================================
  // EXTENSION - SPECIFIC SINGLE USE
  // =========================================================================

  /*
   * interface * / ip address
   * interface * / ipv6 address *
   */
  extension if-addr-move {
    cli:direction "to-device";
    cli:state "post-match|parent-context-deleted";
    cli:java-callback-method "com.tailf.packages.ned.ios.IOSCliExtensions.ifAddrMove";
  }

  /*
   * interface * / speed
   */
  extension if-patch-speed {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.ios.IOSCliExtensions.ifPatchSpeed";
  }

  /*
   * interface * / service-policy input
   * interface * / service-policy output
   */
  extension if-sp-move {
    cli:direction "to-device";
    cli:state "post-match|parent-context-deleted";
    cli:java-callback-method "com.tailf.packages.ned.ios.IOSCliExtensions.ifSPMove";
  }

  /*
   * interface * / switchport
   */
  extension if-switchport-sp-patch {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.ios.IOSCliExtensions.ifSwitchPortSpPatch";
  }

  /*
   * ip vrf * / rd
   */
  extension ip-vrf-rd-restore {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.ios.IOSCliExtensions.ipVrfRdRestore";
  }

  /*
   * aaa accounting exec|commands|network|connection|system *
   */
  extension aaa-accounting-mode-format {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.ios.IOSCliExtensions.aaaAccountingModeFormat";
  }

  /*
   * track *
   */
  extension track-remove-before-change {
    cli:direction "to-device";
    cli:state "post-match|call-once";
    cli:java-callback-method "com.tailf.packages.ned.ios.IOSCliExtensions.trackRemoveBeforeChange";
  }

  /*
   * service-insertion appnav-controller-group * / appnav-controller *
   */
   extension appnav-controller-change {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.ios.IOSCliExtensions.appnavControllerChange";
  }

   /*
    * snmp-server enable all-traps
    */
  extension snmp-server-all-traps {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.ios.IOSCliExtensions.snmpServerAllTraps";
  }

   /*
    * ethernet ring g8032 * / exclusion-list vlan-ids *
    * ethernet ring g8032 * / instance * / inclusion-list *
    */
  extension erps-inject-delete {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.ios.IOSCliExtensions.erpsInjectDelete";
  }

  /*
   * interface * / service instance *
   */
  extension if-service-evc-deleted {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.ios.IOSCliExtensions.ifServiceEvcDeleted";
  }

  /*
   * privilege *
   */
  extension privilege-redeploy {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.ios.IOSCliExtensions.privilegeRedeploy";
  }

  /*
   * router bgp * / neighbor
   */
  extension bgp-nbr-redeploy-trigger {
    cli:direction "to-device";
    cli:state "pre-match";
    cli:java-callback-method "com.tailf.packages.ned.ios.IOSCliExtensions.bgpNbrRedeployTrigger";
  }
  /*
  extension bgp-nbr-redeploy {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.ios.IOSCliExtensions.bgpNbrRedeploy";
  }
  */

  // =========================================================================
  // EXTENSION - LEAF-LIST
  // =========================================================================

  /*
   * interface * / switchport trunk allowed vlan
   * vlan * / private-vlan association *
   *  leaf-list with range-list-syntax
   */
  extension leaf-list-modify {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.ios.IOSCliExtensions.leafListModify";
  }

  /*
   * interface * / ipv6 nd inspection vlan *
   * interface * / service instance * / encapsulation dot1q
   * interface * / service instance * / encapsulation untagged
   *   leaf-list with range-list-syntax and replace-all
   */
  extension leaf-list-modify-replace {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.ios.IOSCliExtensions.leafListModifyReplace";
  }

  /*
   * ip sla group schedule *
   *   leaf-list with range-list-syntax and remove-before-change
   */
  extension leaf-list-modify-remove {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.ios.IOSCliExtensions.leafListModifyRemove";
  }


  // =========================================================================
  // EXTENSION - TO-DEVICE
  // =========================================================================

  /*
   * access-list *
   * ip community-list expanded *
   * ip community-list standard *
   * ip sla ethernet-monitor *
   * mls qos srr-queue *
   */
  extension redeploy-with-change {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.ios.IOSCliExtensions.redeployWithChange";
  }

  /*
   * interface * / switchport
   * interface * / spanning-tree
   * interface * / media-type
   */
  extension if-redeploy {
    cli:direction "to-device";
    cli:state "post-match|call-once";
    cli:java-callback-method "com.tailf.packages.ned.ios.IOSCliExtensions.ifRedeploy";
  }

  /*
   * interface Loopback *
   */
  extension if-default {
    cli:direction "to-device";
    cli:state "post-match|call-once";
    cli:java-callback-method "com.tailf.packages.ned.ios.IOSCliExtensions.ifDefault";
  }

  /*
   * interface * / ip flow monitor * input|output
   * interface * / ipv6 flow monitor * input|output
   * interface * / service-policy input|output
   * interface * / tunnel protection ipsec policy ipv4
   * interface * / service instance * / cfm mep
   * cable fiber-node * / service-group profile
   * ip sla ethernet-monitor schedule * schedule-period
   * flow monitor * / record
   * flow monitor * / exporter *
   */
  extension config-lock {
    cli:state "post-match|parent-context-deleted";
    cli:java-callback-method "com.tailf.packages.ned.ios.IOSCliExtensions.configLock";
  }
  extension config-lock2 {
    cli:state "post-match|parent-context-deleted";
    cli:java-callback-method "com.tailf.packages.ned.ios.IOSCliExtensions.configLock";
  }


  // interface * / wrr-queue cos-map *
  // interface * / rcv-queue cos-map *
  // interface * / priority-queue cos-map *
  extension ned-defaults {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.ios.IOSCliExtensions.nedDefaults";
  }

  /*
   * policy-map * / class * / priority
   */
  extension remove-before-populate {
    cli:direction "to-device";
    cli:state "post-match|call-once";
    cli:java-callback-method "com.tailf.packages.ned.ios.IOSCliExtensions.removeBeforePopulate";
  }

  /*
   * interface Multilink*
   * interface Dialer*
   * interface Tunnel*
   */
  extension shutdown-before-delete {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.ios.IOSCliExtensions.shutdownBeforeDelete";
  }

  /*
   * line * / activation-character X
   * line * / transport input *
   * line * / transport output *
   * line * / transport preferred *
   * line * / flowcontrol NONE
   * router ospf * / discard-route external
   * router ospf * / discard-route internal
   * shell processing full
   * aaa session-id
   */
  extension delete-syntax {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.ios.IOSCliExtensions.deleteSyntax";
  }

  /*
   * dial-peer voice * / voice-class sip outbound-proxy proxy-address
   */
  extension delete-with-default {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.ios.IOSCliExtensions.deleteWithDefault";
  }

  /*
   * dial-peer voice * / no voice-class sip outbound-proxy
   */
  extension boolean-delete-with-default {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.ios.IOSCliExtensions.booleanDeleteWithDefault";
  }

  /*
   * line * / activation-character
   */
  extension replace-output {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.ios.IOSCliExtensions.replaceOutput";
  }

  /*
   * policy-map * / class * / bandwidth <bits>
   * policy-map * / class * / bandwidth percent
   * policy-map * / class * / police cir
   * policy-map * / class * / priority percent
   */
  extension ned-diff-minimize-value {
    cli:direction "to-device";
    cli:state "post-match|call-once";
    cli:java-callback-method "com.tailf.packages.ned.ios.IOSCliExtensions.nedDiffMinimizeValue";
  }

  /*
   * class-map * / match cos inner *
   * class-map * / match dscp *
   * class-map * / match ip precedence *
   * interface * / wrr-queue cos-map *
   * interface * / rcv-queue cos-map *
   * interface * / mls qos monitor dscp
   * mls qos srr-queue *
   * route-map * / match interface *
   * route-map * / set ip vrf * next-hop *
   * route-map * / set ip next-hop *
   * route-map * / set ip default next-hop *
   * route-map * / set ip default vrf * next-hop *
   * route-map * / set ipv6 next-hop
   */
  extension max-values-output {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.ios.IOSCliExtensions.maxValuesOutput";
  }

  /*
   * ip nbar custom * udp|tcp *
   */
  extension space-flat-list-syntax {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.ios.IOSCliExtensions.spaceFlatListSyntax";
  }

  /*
   * ip sla ethernet-monitor * / type echo *
   * ip sla ethernet-monitor * / type jitter *
   */
  extension ignore-re-enter-mode {
    cli:direction "to-device";
    cli:state "post-match|call-once";
    cli:java-callback-method "com.tailf.packages.ned.ios.IOSCliExtensions.ignoreReEnterMode";
  }

  /*
   * utd web-filter block local-server profile * / content text
   * utd web-filter block page profile * / text
   * crypto pki server * / issuer-name
   * utd threat-inspection whitelist / signature id *
   * utd engine standard multi-tenancy / threat-inspection whitelist profile * / signature id *
   */
  extension string-remove-quotes {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.ios.IOSCliExtensions.stringRemoveQuotes";
  }

  /* UNUSED
     extension maapi-encrypted {
     cli:direction "to-device";
     cli:state "post-match";
     cli:java-callback-method "com.tailf.packages.ned.ios.IOSCliExtensions.maapiEncrypted";
     }
  */

  extension password-dequote-output {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.ios.IOSCliExtensions.passwordDequoteOutput";
  }


  /*
   * interface * / standby * preempt
   * interface * / switchport backup interface *
   */
  extension trim-delete-when-empty {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.ios.IOSCliExtensions.trimDeleteWhenEmpty";
  }

  /*
   * call-home / profile * / active
   * call-home / profile * / reporting smart-licensing-data
   * interface * / no snmp trap link-status
   */
  extension trim-when-list {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.ios.IOSCliExtensions.trimWhenList";
  }

  /*
   * interface * / standby *
   * router ospf * / area
   */
  extension trim-empty-create {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.ios.IOSCliExtensions.trimEmptyCreate";
  }

  /*
   * cable dsg tg *
   */
  extension display-separated {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.ios.IOSCliExtensions.displaySeparated";
  }

  /*
   * cable rpd * / rpd-ds * base-power
   */
  extension cable-rpd-diff-add {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.ios.IOSCliExtensions.cableRpdDiffAdd";
  }

  /*
   * aaa * <list>
   */
  extension new-aaa-list-syntax {
    cli:direction "both";
    cli:state "post-match|pre-match";
    cli:java-callback-method "com.tailf.packages.ned.ios.IOSCliExtensions.newAaaListSyntax";
  }


  // =========================================================================
  // TYPEDEF
  // =========================================================================


  typedef percentage-type {
    type uint8 {
      tailf:info "<1-100>;;Percentage";
      range "1..100";
    }
  }

  typedef ppp-auth-method {
    type enumeration {
      enum chap {
                 tailf:info "Challenge Handshake Authentication Protocol (CHAP)";
      }
      enum eap {
                tailf:info "Extensible Authentication Protocol (EAP)";
      }
      enum ms-chap {
        tailf:info "Microsoft Challenge Handshake Authentication Protocol (MS-CHAP)";
      }
      enum ms-chap-v2 {
        tailf:info "Microsoft CHAP Version 2 (MS-CHAP-V2)";
      }
      enum pap {
                tailf:info "Password Authentication Protocol (PAP)";
      }
    }
  }

  typedef mac-address-type {
    type string {
      tailf:info "H.H.H;;MAC address";
      pattern '[0-9a-fA-F]+\.[0-9a-fA-F]+\.[0-9a-fA-F]+';
    }
  }

  // Patched version of 'ipv6-address' from ietf-inet-types.yang
  // needed to support "FE80::15%GigabitEthernet0/0/4"
  // [CISCOIOS-2081]
  typedef ios-ipv6-address {
    type string {
      pattern '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}'
        + '((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|'
            + '(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\.){3}'
                + '(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))'
             + '(%.+)?';  // PATCH:  + '(%[\p{N}\p{L}]+)?';
      pattern '(([^:]+:){6}(([^:]+:[^:]+)|(.*\..*)))|'
        + '((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?)'
        + '(%.+)?';
    }
  }

  typedef all-address {
    type union {
      type inet:ipv4-address {
        tailf:info "A.B.C.D;;IPv4 address";
      }
      type inet:ipv6-address {
        tailf:info "X:X:X:X::X;;IPv6 address";
      }
      type ios-ipv6-address;
    }
  }

  // IPv4 prefix (address and mask length) in A.B.C.D/P format
  typedef ipv4-prefix {
    type tailf:ipv4-address-and-prefix-length;
  }

  // IPv6 prefix
  // Handles expanded IPv6 address format as well as any mixture
  // of upper/lower case letters in the address.
  typedef ipv6-prefix {
    type tailf:ipv6-address-and-prefix-length;
  }

  // Router Distinguisher
  typedef rd-type {
    type string {
      tailf:info "ASN:nn or IP-address:nn;;VPN Route Distinguisher";
      pattern '(\d*(.\d*)*)?:(\d*(.\d*)*)?';
    }
  }

  // VPN id type
  typedef vpn-id-type {
    type string {
      tailf:info "OUI:VPN-Index;;, format (hex) <3 bytes OUI:4 bytes VPN_Index>";
      pattern '[0-9a-fA-F]{1,6}:[0-9a-fA-F]{1,8}';
    }
  }

  // ASN IP type
  typedef asn-ip-type {
    type string {
      tailf:info "ASN:nn or IP-address:nn";
      pattern '(([0-9]+)|((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'
                           +'\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]))):[0-9]+';
    }
  }

  // Hour&minute type
  typedef hhmm-type {
    type string {
      pattern "([0-1]?[0-9]|2[0-4]):([0-5][0-9])(:[0-5][0-9])?";
    }
  }

  // Weekday type
  typedef weekday-type {
    type enumeration {
      enum Mon;
      enum Tue;
      enum Wed;
      enum Thu;
      enum Fri;
      enum Sat;
      enum Sun;
    }
  }

  // Month type
  typedef month-type {
    type enumeration {
      enum Jan;
      enum Feb;
      enum Mar;
      enum Apr;
      enum May;
      enum Jun;
      enum Jul;
      enum Aug;
      enum Sep;
      enum Oct;
      enum Nov;
      enum Dec;
    }
  }

  // Month type
  typedef month-full-type {
    type enumeration {
      enum January;
      enum February;
      enum March;
      enum April;
      enum May;
      enum June;
      enum July;
      enum August;
      enum September;
      enum October;
      enum November;
      enum December;
    }
  }

  // Standard access list type
  typedef std-acl-type {
    type union {
      type uint16 {
        tailf:info "<1-99>;;Standard access list";
        range "1..99";
      }
      type uint16 {
        tailf:info "<1300-1999>;;Standard access list (expanded range)";
        range "1300..1999";
      }
      type string {
        tailf:info "WORD;;Named access list";
      }
    }
  }

  // Extended access list type
  typedef ext-acl-type {
    type union {
      type uint16 {
        tailf:info "<100-199>;;Access list number";
        range "100..199";
      }
      type uint16 {
        tailf:info "<2000-2699>;;Access list number (expanded range)";
        range "2000..2699";
      }
      type string {
        tailf:info "WORD;;IP Named Extended Access list";
      }
    }
  }

  // Standard IP access list type
  typedef std-ip-acl-type {
    type union {
      type uint16 {
        tailf:info "<1-99>;;Standard IP access list";
        range "1..99";
      }
      type uint16 {
        tailf:info "<1300-1999>;;Standard IP access list (expanded range)";
        range "1300..1999";
      }
      type string {
        tailf:info "WORD;;Named access list";
      }
    }
  }

  typedef base-acl-type {
    type union {
      type uint16 {
        tailf:info "<1-99>;;Access list number";
        range "1..99";
      }
      type string {
        tailf:info "WORD;;IP Named Standard Access list";
      }
    }
  }

  // ip access list type
  typedef ip-acl-type {
    type union {
      type uint16 {
        tailf:info "<1-199>;;Standard or Extended IP access list number";
        range "1..199";
      }
      type string {
        tailf:info "WORD;;IP Named Access list";
      }
    }
  }

  // Extended ip access list type
  typedef ext-ip-acl-type {
    type union {
      type uint16 {
        tailf:info "<100-199>;;IP access list number";
        range "100..199";
      }
      type uint16 {
        tailf:info "<2000-2699>;;IP access list number (expanded range)";
        range "2000..2699";
      }
      type string {
        tailf:info "WORD;;Access-list name";
      }
    }
  }

  // Expanded ip access list type
  typedef exp-ip-acl-type {
    type union {
      type uint16 {
        tailf:info "<1-199>;;IP access list";
        range "1..199";
      }
      type uint16 {
        tailf:info "<1300-2699>;;IP expanded access list";
        range "1300..2699";
      }
      type string {
        tailf:info "WORD;;Access-list name";
      }
    }
  }


  typedef ip-nat-timeout-type {
    type union {
      type uint32 {
        tailf:info "<0-536870>;;Timeout in seconds";
        range "0..536870";
      }
      type enumeration {
        enum never {
                    tailf:info "Never timeout";
        }
      }
    }
  }

  // LDP discovery address type
  typedef ldp-discovery-address-type {
    type union {
      type enumeration {
        enum interface {
                        tailf:info "Use interface address for LDP transport address";
                        tailf:code-name "ldp_interface";
        }
      }
      type inet:ipv4-address {
        tailf:info "A.B.C.D;;IP address to use for LDP transport address";
      }
    }
  }

  // DSCP type
  typedef dscp-type {
    type union {
      type uint8 {
        tailf:info "<0-63>;;Differentiated services codepoint value";
        range "0..63";
      }
      type enumeration {
        enum af11 {
                   tailf:info "Match packets with AF11 dscp (001010)";
                   value 10011;
        }
        enum af12 {
                   tailf:info "Match packets with AF12 dscp (001100)";
                   value 10012;
        }
        enum af13 {
                   tailf:info "Match packets with AF13 dscp (001110)";
                   value 10013;
        }
        enum af21 {
                   tailf:info "Match packets with AF21 dscp (010010)";
                   value 10021;
        }
        enum af22 {
                   tailf:info "Match packets with AF22 dscp (010100)";
                   value 10022;
        }
        enum af23 {
                   tailf:info "Match packets with AF23 dscp (010110)";
                   value 10023;
        }
        enum af31 {
                   tailf:info "Match packets with AF31 dscp (011010)";
                   value 10031;
        }
        enum af32 {
                   tailf:info "Match packets with AF32 dscp (011100)";
                   value 10032;
        }
        enum af33 {
                   tailf:info "Match packets with AF33 dscp (011110)";
                   value 10033;
        }
        enum af41 {
                   tailf:info "Match packets with AF41 dscp (100010)";
                   value 10041;
        }
        enum af42 {
                   tailf:info "Match packets with AF42 dscp (100100)";
                   value 10042;
        }
        enum af43 {
                   tailf:info "Match packets with AF43 dscp (100110)";
                   value 10043;
        }
        enum cs1 {
                  tailf:info "Match packets with CS1(precedence 1) dscp (001000)";
                  value 10001;
        }
        enum cs2 {
                  tailf:info "Match packets with CS2(precedence 2) dscp (010000)";
                  value 10002;
        }
        enum cs3 {
                  tailf:info "Match packets with CS3(precedence 3) dscp (011000)";
                  value 10003;
        }
        enum cs4 {
                  tailf:info "Match packets with CS4(precedence 4) dscp (100000)";
                  value 10004;
        }
        enum cs5 {
                  tailf:info "Match packets with CS5(precedence 5) dscp (101000)";
                  value 10005;
        }
        enum cs6 {
                  tailf:info "Match packets with CS6(precedence 6) dscp (110000)";
                  value 10006;
        }
        enum cs7 {
                  tailf:info "Match packets with CS7(precedence 7) dscp (111000)";
                  value 10007;
        }
        enum "default" {
          tailf:info "Match packets with default dscp (000000)";
          tailf:code-name "dscp_default";
          value 1000;
        }
        enum dscp {
                   tailf:info "Set packet dscp from dscp";
                   value 1001;
        }
        enum ef {
                 tailf:info "Match packets with EF dscp (101110)";
                 value 1002;
        }
        enum precedence {
                         tailf:info "Set packet dscp from precedence";
                         value 1003;
        }
      }
    }
  }

  // Precedence type
  typedef precedence-type {
    type union {
      type uint8 {
        tailf:info "<0-7>;;Precedence value";
        range "0..7";
      }
      type enumeration {
        enum critical {
          tailf:info "Set packets with critical precedence (5)";
        }
        enum flash {
          tailf:info "Set packets with flash precedence (3)";
        }
        enum flash-override {
          tailf:info "Set packets with flash override precedence (4)";
        }
        enum immediate {
          tailf:info "Set packets with immediate precedence (2)";
        }
        enum internet {
          tailf:code-name "prec_internet";
          tailf:info "Set packets with internetwork control precedence (6)";
        }
        enum network {
          tailf:info "Set packets with network control precedence (7)";
        }
        enum priority {
          tailf:code-name "prec_priority";
          tailf:info "Set packets with priority precedence (1)";
        }
        enum routine {
          tailf:info "Set packets with routine precedence (0)";
        }
      }
    }
  }

  // cos_value-type
  typedef cos_value-type {
    type union {
      type uint8 {
        tailf:info "<0-7>;;new cos value";
        range "0..7";
      }
      type enumeration {
        enum cos {
          tailf:info "Set packet cos from cos";
          value 1001;
        }
        enum dscp {
          tailf:info "Set packet cos from dscp";
          value 1002;
        }
        enum exp {
          tailf:info "Set packet cos from exp";
          value 1003;
        }
        enum precedence {
          tailf:info "Set packet cos from precedence";
          value 1004;
        }
      }
    }
  }

  // qos_value-type
  typedef qos_value-type {
    type union {
      type uint8 {
        tailf:info "<0-99>;;new qos-group";
        range "0..99";
      }
      type enumeration {
        enum cos {
          tailf:info "Set packet qos from cos";
          value 1001;
        }
        enum dscp {
          tailf:info "Set packet qos from dscp";
          value 1002;
        }
        enum exp {
          tailf:info "Set packet qos from exp";
          value 1003;
        }
        enum precedence {
          tailf:info "Set packet qos from precedence";
          value 1004;
        }
      }
    }
  }

  // exp_value-type
  typedef exp_value-type {
    type union {
      type uint8 {
        tailf:info "<0-7>;;new exp";
        range "0..7";
      }
      type enumeration {
        enum cos {
          tailf:info "Set packet exp from cos";
          value 1001;
        }
        enum dscp {
          tailf:info "Set packet exp from dscp";
          value 1002;
        }
        enum exp {
          tailf:info "Set packet exp from exp";
          value 1003;
        }
        enum precedence {
          tailf:info "Set packet exp from precedence";
          value 1004;
        }
      }
    }
  }

  // prec_value-type
  typedef prec_value-type {
    type union {
      type uint8 {
        tailf:info "<0-7>;;new precedence";
        range "0..7";
      }
      type enumeration {
        enum cos {
          tailf:info "Set packet precedence from cos";
          value 1001;
        }
        enum dscp {
          tailf:info "Set packet precedence from dscp";
          value 1002;
        }
        enum exp {
          tailf:info "Set packet precedence from exp";
          value 1003;
        }
        enum precedence {
          tailf:info "Set packet precedence from precedence";
          value 1004;
        }
      }
    }
  }

  typedef redist-ospf-external-type {
    type enumeration {
      enum "1" {
        tailf:info "Redistribute external type 1 routes";
      }
      enum "2" {
        tailf:info "Redistribute external type 2 routes";
      }
    }
  }

  typedef ospf-area-type {
    type union {
      type uint32 {
        tailf:info "<0-4294967295>;;OSPF area ID as a decimal value";
        range "0..4294967295";
      }
      type inet:ipv4-address {
        tailf:info "A.B.C.D;;OSPF area ID in IP address format";
      }
    }
  }

  typedef ospf-metric-type {
    type uint32 {
      tailf:info "<1-2>;;OSPF Link State type";
      range "1..2";
    }
  }

  typedef limit-dc-non-dc-type {
    type union {
      type uint32 {
        tailf:info "<1-255>;;The maximum number of retransmissions";
        range "1..255";
      }
      type enumeration {
        enum disable {
          tailf:info "Disable the feature";
        }
      }
    }
  }

  typedef isis-level-type {
    type enumeration {
      enum level-1 {
        tailf:info "Level-1 only";
      }
      enum level-1-2 {
        tailf:info "Level-1-2";
      }
      enum level-2 {
        tailf:info "Level-2 only";
      }
    }
  }

  typedef logging-level-type {
    type union {
      type uint16 {
        tailf:info "<0-7>;;Logging severity level";
        range "0..7";
      }
      type enumeration {
        enum alerts {
          tailf:info "Immediate action needed (severity=1)";
          value 1;
        }
        enum critical {
          tailf:info "Critical conditions (severity=2)";
          value 2;
        }
        enum debugging {
          tailf:info "Debugging messages (severity=7)";
          value 7;
        }
        enum emergencies {
          tailf:info "System is unusable (severity=0)";
          value 0;
        }
        enum errors {
          tailf:info "Error conditions (severity=3)";
          value 3;
        }
        enum informational {
          tailf:info "Informational messages (severity=6)";
          value 6;
        }
        enum notifications {
          tailf:info "Normal but significant conditions (severity=5)";
          value 5;
        }
        enum warnings {
          tailf:info "Warning conditions (severity=4)";
          value 4;
        }
      }
    }
  }

  typedef operator-type {
    type enumeration {
      enum eq {
        tailf:info "Equal to";
      }
      enum ge {
        tailf:info "Greater than or equal to";
      }
      enum gt {
        tailf:info "Greater than";
      }
      enum le {
        tailf:info "Less than or equal to";
      }
      enum lt {
        tailf:info "Less than";
      }
      enum ne {
        tailf:info "Not equal to";
      }
    }
  }

  typedef police-packets-bytes-type {
    type enumeration {
      enum packets {
        tailf:info "Treat 'burst' value as packets";
      }
      enum bytes {
        tailf:info "Treat 'burst' value as bytes";
      }
      enum cells {
        tailf:info "Treat 'burst' value as cells";
      }
    }
  }

  typedef police-pps-bps-type {
    type enumeration {
      enum pps {
        tailf:info "pps  Treat 'rate' value in packets-per-second";
      }
      enum bps {
        tailf:info "pps  Treat 'rate' value in bytes-per-second";
      }
      enum cps {
        tailf:info "Treat 'rate' value in cells-per-second";
      }
    }
  }

  // police target bit rate in bits per second (bps) type
  typedef police-bps-type {
    type uint64 {
      tailf:info "<8000-64000000000>;;Bits per second";
      range "8000..64000000000";
    }
  }

  typedef police-burst-type {
    type uint32 {
      tailf:info "<1-512000000>;;Burst bytes";
      range "1..512000000";
    }
  }


  // aaa-authorization-name-type
  typedef aaa-authorization-name-type {
    type union {
      type enumeration {
        enum "default" {
          tailf:info "The default authorization list.";
        }
      }
      type string {
        tailf:info "WORD;;Named authorization list (max 31 characters).";
        length "1..31";
      }
    }
  }

  // aaa-authentication-name-type
  typedef aaa-authentication-name-type {
    type union {
      type enumeration {
        enum "default" {
          tailf:info "The default authentication list.";
        }
      }
      type string {
        tailf:info "WORD;;Named authentication list (max 31 characters).";
        length "1..31";
      }
    }
  }

  // aaa-accounting-name-type
  typedef aaa-accounting-name-type {
    type union {
      type enumeration {
        enum "default" {
          tailf:info "The default accounting list.";
        }
      }
      type string {
        tailf:info "WORD;;Named Accounting list (max 31 characters).";
        length "1..31";
      }
    }
  }

  // aaa-group-type
  typedef aaa-group-type {
    type union {
      type string {
        tailf:info "WORD;;Server-group name";
      }
      type enumeration {
        enum ldap {
          tailf:info "Use list of all LDAP hosts.";
        }
        enum radius {
          tailf:info "Use list of all Radius hosts.";
        }
        enum "tacacs+" {
          tailf:info "Use list of all Tacacs+ hosts.";
        }
      }
    }
  }

  // ipsec-window-size-type
  typedef ipsec-window-size-type {
    type enumeration {
      enum "1024" {
        tailf:info "Window size of 1024";
      }
      enum "128" {
        tailf:info "Window size of 128";
      }
      enum "256" {
        tailf:info "Window size of 256";
      }
      enum "512" {
        tailf:info "Window size of 512";
      }
      enum "64" {
        tailf:info "Window size of 64 (default)";
      }
    }
  }

  typedef bgp-as-no-type {
    type union {
      type uint32 {
        tailf:info "<1-4294967295>;;Autonomous system number";
        range "1..4294967295";
      }
      type string {
        tailf:info "<1.0-XX.YY>;;Autonomous system number";
        pattern '[0-9]+.*';
      }
    }
  }

  typedef eigrp-as-no-type {
    type union {
      type uint16 {
        tailf:info "<1-65535>;;Autonomous system number";
        range "1..65535";
      }
      type string {
        tailf:info "WORD;;EIGRP Virtual-Instance Name";
      }
    }
  }

  typedef l2protocol-type {
    type enumeration {
      enum cdp {
        tailf:info "Cisco Discovery Protocol";
      }
      enum dtp {
        tailf:info "Dynamic Trunking Protocol";
      }
      enum lacp {
        tailf:info "LACP Protocol";
      }
      enum stp {
        tailf:info "Spanning Tree Protocol";
      }
      enum vtp {
        tailf:info "Vlan Trunking Protocol";
      }
      enum lldp {
        tailf:info "Link Layer Discovery Protocol";
      }
      enum pagp {
        tailf:info "Port Aggregation Protocol";
      }
      enum udld {
        tailf:info "UDLD Protocol";
      }
      enum dot1x {
        tailf:info "Dot1x Protocol";
      }
      enum all {
        tailf:info "All Protocols";
      }
      enum elmi {
        tailf:info "ELMI Protocol";
      }
      enum esmc {
        tailf:info "ESMC Protocol";
      }
      enum loam {
        tailf:info "Link OAM Protocol";
      }
      enum mmrp {
        tailf:info "Multiple MAC Registration Protocol";
      }
      enum mvrp {
        tailf:info "Multiple VLAN Registration Protocol";
      }
      enum ptppd {
        tailf:info "PTP Peer Delay Protocol";
      }
      enum R4 {
        tailf:info "Reserved Protocol using DA Mac 0180.C200.0004";
      }
      enum R5 {
        tailf:info "Reserved Protocol using DA Mac 0180.C200.0005";
      }
      enum R6 {
        tailf:info "Reserved Protocol using DA Mac 0180.C200.0006";
      }
      enum R8 {
        tailf:info "Reserved Protocol using DA Mac 0180.C200.0008";
      }
      enum R9 {
        tailf:info "Reserved Protocol using DA Mac 0180.C200.0009";
      }
      enum RA {
        tailf:info "Reserved Protocol using DA Mac 0180.C200.000A";
      }
      enum RB {
        tailf:info "Reserved Protocol using DA Mac 0180.C200.000B";
      }
      enum RC {
        tailf:info "Reserved Protocol using DA Mac 0180.C200.000C";
      }
      enum RD {
        tailf:info "Reserved Protocol using DA Mac 0180.C200.000D";
      }
      enum RF {
        tailf:info "Reserved Protocol using DA Mac 0180.C200.000F";
      }
    }
  }

  typedef cable-downstream-interleaver-depth-option {
    type enumeration {
      enum I128-J1 {
        tailf:info "RFGW_MB_FEC-I-128-J-1";
      }
      enum I128-J2 {
        tailf:info "RFGW_MB_FEC-I-128-J-2";
      }
      enum I128-J3 {
        tailf:info "RFGW_MB_FEC-I-128-J-3";
      }
      enum I128-J4 {
        tailf:info "RFGW_MB_FEC-I-128-J-4";
      }
      enum I128-J5 {
        tailf:info "RFGW_MB_FEC-I-128-J-5";
      }
      enum I128-J6 {
        tailf:info "RFGW_MB_FEC-I-128-J-6";
      }
      enum I128-J7 {
        tailf:info "RFGW_MB_FEC-I-128-J-7";
      }
      enum I128-J8 {
        tailf:info "RFGW_MB_FEC-I-128-J-8";
      }
      enum I16-J8 {
        tailf:info "RFGW_MB_FEC-I-16-J-8 ";
      }
      enum I32-J4 {
        tailf:info "RFGW_MB_FEC-I-32-J-4 ";
      }
      enum I64-J2 {
        tailf:info "RFGW_MB_FEC-I-64-J-2 ";
      }
      enum I8-J16 {
        tailf:info "RFGW_MB_FEC-I-8-J-16 ";
      }
    }
  }

  typedef object-group-service-icmp-type {
    type union {
      type uint16 {
        tailf:info "<0-65535>;;Port number";
      }
      type enumeration {
        enum alternate-address {
          tailf:info "Alternate address";
        }
        enum conversion-error {
          tailf:info "Datagram conversion";
        }
        enum echo {
          tailf:info "Echo (ping)";
        }
        enum echo-reply {
          tailf:info "Echo reply";
        }
        enum information-reply {
          tailf:info "Information replies";
        }
        enum information-request {
          tailf:info "Information requests";
        }
        enum mask-reply {
          tailf:info "Mask replies";
        }
        enum mask-request {
          tailf:info "Mask requests";
        }
        enum mobile-redirect {
          tailf:info "Mobile host redirect";
        }
        enum parameter-problem {
          tailf:info "All parameter problems";
        }
        enum redirect {
          tailf:info "All redirects";
        }
        enum router-advertisement {
          tailf:info "Router discovery advertise.";
        }
        enum router-solicitation {
          tailf:info "Router discovery solicitations";
        }
        enum source-quench {
          tailf:info "Source quenches";
        }
        enum time-exceeded {
          tailf:info "All time exceededs";
        }
        enum timestamp-reply {
          tailf:info "Timestamp replies";
        }
        enum timestamp-request {
          tailf:info "Timestamp requests";
        }
        enum traceroute {
          tailf:info "Traceroute";
        }
        enum unreachable {
          tailf:info "All unreachables";
        }
      }
    }
  }

  typedef object-group-service-tcp-type {
    type union {
      type uint16 {
        tailf:info "<0-65535>;;Port number";
      }
      type enumeration {
        enum bgp {
          tailf:info "Border Gateway Protocol (179)";
        }
        enum chargen {
          tailf:info "Character generator (19)";
        }
        enum cmd {
          tailf:info "Remote commands (rcmd, 514)";
        }
        enum connectedapps-plain {
          tailf:info "ConnectedApps Cleartext (15001)";
        }
        enum connectedapps-tls {
          tailf:info "ConnectedApps TLS (15002)";
        }
        enum daytime {
          tailf:info "Daytime (13)";
        }
        enum discard {
          tailf:info "Discard (9)";
        }
        enum domain {
          tailf:info "Domain Name Service (53)";
        }
        enum echo {
          tailf:info "Echo (7)";
        }
        enum exec {
          tailf:info "Exec (rsh, 512)";
        }
        enum finger {
          tailf:info "Finger (79)";
        }
        enum ftp {
          tailf:info "File Transfer Protocol (21)";
        }
        enum ftp-data {
          tailf:info "FTP data connections (20)";
        }
        enum gopher {
          tailf:info "Gopher (70)";
        }
        enum hostname {
          tailf:info "NIC hostname server (101)";
        }
        enum ident {
          tailf:info "Ident Protocol (113)";
        }
        enum irc {
          tailf:info "Internet Relay Chat (194)";
        }
        enum klogin {
          tailf:info "Kerberos login (543)";
        }
        enum kshell {
          tailf:info "Kerberos shell (544)";
        }
        enum login {
          tailf:info "Login (rlogin, 513)";
        }
        enum lpd {
          tailf:info "Printer service (515)";
        }
        enum msrpc {
          tailf:info "MS Remote Procedure Call (135)";
        }
        enum nntp {
          tailf:info "Network News Transport Protocol (119)";
        }
        enum pim-auto-rp {
          tailf:info "PIM Auto-RP (496)";
        }
        enum pop2 {
          tailf:info "Post Office Protocol v2 (109)";
        }
        enum pop3 {
          tailf:info "Post Office Protocol v3 (110)";
        }
        enum smtp {
          tailf:info "Simple Mail Transport Protocol (25)";
        }
        enum sunrpc {
          tailf:info "Sun Remote Procedure Call (111)";
        }
        enum syslog {
          tailf:info "Syslog (514)";
        }
        enum tacacs {
          tailf:info "TAC Access Control System (49)";
        }
        enum talk {
          tailf:info "Talk (517)";
        }
        enum telnet {
          tailf:info "Telnet (23)";
        }
        enum time {
          tailf:info "Time (37)";
        }
        enum uucp {
          tailf:info "Unix-to-Unix Copy Program (540)";
        }
        enum whois {
          tailf:info "Nicname (43)";
        }
        enum www {
          tailf:info "World Wide Web (HTTP, 80)";
        }
      }
    }
  }

  typedef object-group-service-udp-type {
    type union {
      type uint16 {
        tailf:info "<0-65535>;;Port number";
      }
      type enumeration {
        enum biff {
          tailf:info "Biff (mail notification, comsat, 512)";
        }
        enum bootpc {
          tailf:info "Bootstrap Protocol (BOOTP) client (68)";
        }
        enum discard {
          tailf:info "Discard (9)";
        }
        enum dnsix {
          tailf:info "DNSIX security protocol auditing (195)";
        }
        enum domain {
          tailf:info "Domain Name Service (DNS, 53)";
        }
        enum echo {
          tailf:info "Echo (7)";
        }
        enum isakmp {
          tailf:info "Internet Security Association and Key Management Protocol (500)";
        }
        enum mobile-ip {
          tailf:info "Mobile IP registration (434)";
        }
        enum nameserver {
          tailf:info "IEN116 name service (obsolete, 42)";
        }
        enum netbios-dgm {
          tailf:info "NetBios datagram service (138)";
        }
        enum netbios-ns {
          tailf:info "NetBios name service (137)";
        }
        enum netbios-ss {
          tailf:info "NetBios session service (139)";
        }
        enum non500-isakmp {
          tailf:info "Internet Security Association and Key Management Protocol (4500)";
        }
        enum ntp {
          tailf:info "Network Time Protocol (123)";
        }
        enum pim-auto-rp {
          tailf:info "PIM Auto-RP (496)";
        }
        enum rip {
          tailf:info "Routing Information Protocol (router, in.routed, 520)";
        }
        enum ripv6 {
          tailf:info "Routing Information Protocol V6 (router, in.routed, 521)";
        }
        enum snmp {
          tailf:info "Simple Network Management Protocol (161)";
        }
        enum snmptrap {
          tailf:info "SNMP Traps (162)";
        }
        enum sunrpc {
          tailf:info "Sun Remote Procedure Call (111)";
        }
        enum syslog {
          tailf:info "System Logger (514)";
        }
        enum tacacs {
          tailf:info "TAC Access Control System (49)";
        }
        enum talk {
          tailf:info "Talk (517)";
        }
        enum tftp {
          tailf:info "Trivial File Transfer Protocol (69)";
        }
        enum time {
          tailf:info "Time (37)";
        }
        enum who {
          tailf:info "Who service (rwho, 513)";
        }
        enum xdmcp {
          tailf:info "X Display Manager Control Protocol (177)";
        }
      }
    }
  }

  typedef object-group-service-tcp-udp-type {
    type union {
      type uint16 {
        tailf:info "<0-65535>;;Port number";
      }
      type enumeration {
        enum discard {
          tailf:info "Discard (9)";
        }
        enum domain {
          tailf:info "Domain Name Service (53)";
        }
        enum echo {
          tailf:info "Echo (7)";
        }
        enum pim-auto-rp {
          tailf:info "PIM Auto-RP (496)";
        }
        enum sunrpc {
          tailf:info "Sun Remote Procedure Call (111)";
        }
        enum syslog {
          tailf:info "Syslog (514)";
        }
        enum tacacs {
          tailf:info "TAC Access Control System (49)";
        }
        enum talk {
          tailf:info "Talk (517)";
        }
      }
    }
  }

  typedef isakmp-pfs-type {
    type enumeration {
      enum group1 {
        tailf:info "D-H Group1 (768-bit modp)";
      }
      enum group14 {
        tailf:info "D-H Group14 (2048-bit modp)";
      }
      enum group15 {
        tailf:info "D-H Group15 (3072-bit modp)";
      }
      enum group16 {
        tailf:info "D-H Group16 (4096-bit modp)";
      }
      enum group19 {
        tailf:info "D-H Group19 (256-bit ecp)";
      }
      enum group2 {
        tailf:info "D-H Group2 (1024-bit modp)";
      }
      enum group20 {
        tailf:info "D-H Group20 (384-bit ecp)";
      }
      enum group21 {
        tailf:info "D-H Group21 (521-bit ecp)";
      }
      enum group24 {
        tailf:info "D-H Group24 (2048-bit modp, 256 bit subgroup)";
      }
      enum group5 {
        tailf:info "D-H Group5 (1536-bit modp)";
      }
    }
  }

  typedef qam-modulation-type {
    type enumeration {
      enum "16-QAM" {
        tailf:info "Assign 16 QAM modulation";
      }
      enum "64-QAM" {
        tailf:info "Assign 64 QAM modulation";
      }
      enum "128-QAM" {
        tailf:info "Assign 128 QAM modulation";
      }
      enum "256-QAM" {
        tailf:info "Assign 256 QAM modulation";
      }
      enum "512-QAM" {
        tailf:info "Assign 512 QAM modulation";
      }
      enum "1024-QAM" {
        tailf:info "Assign 1024 QAM modulation";
      }
      enum "2048-QAM" {
        tailf:info "Assign 2048 QAM modulation";
      }
      enum "4096-QAM" {
        tailf:info "Assign 4096 QAM modulation";
      }
    }
  }

  typedef qam-modulation-type9 {
    type enumeration {
      enum "16-QAM" {
        tailf:info "16-QAM";
      }
      enum "64-QAM" {
        tailf:info "64-QAM";
      }
      enum "128-QAM" {
        tailf:info "128-QAM";
      }
      enum "256-QAM" {
        tailf:info "256-QAM";
      }
      enum "512-QAM" {
        tailf:info "512-QAM";
      }
      enum "1024-QAM" {
        tailf:info "1024-QAM";
      }
      enum "2048-QAM" {
        tailf:info "2048-QAM";
      }
      enum "4096-QAM" {
        tailf:info "4096-QAM";
      }
      enum "QPSK" {
        tailf:info "QPSK";
      }
    }
  }

  typedef utd-category-type {
    type enumeration {
      enum abortion {
        tailf:info "Abortion";
      }
      enum abused-drugs {
        tailf:info "Abused Drugs";
      }
      enum adult-and-pornography {
        tailf:info "Adult and Pornography";
      }
      enum alcohol-and-tobacco {
        tailf:info "Alcohol and Tobacco";
      }
      enum auctions {
        tailf:info "Auctions";
      }
      enum bot-nets {
        tailf:info "Bot Nets";
      }
      enum business-and-economy {
        tailf:info "Business and Economy";
      }
      enum cdns {
        tailf:info "CDNs";
      }
      enum cheating {
        tailf:info "Cheating";
      }
      enum computer-and-internet-info {
        tailf:info "Computer and Internet Info";
      }
      enum computer-and-internet-security {
        tailf:info "Computer and Internet Security";
      }
      enum confirmed-spam-sources {
        tailf:info "Confirmed SPAM Sources";
      }
      enum cult-and-occult {
        tailf:info "Cult and Occult";
      }
      enum dating {
        tailf:info "Dating";
      }
      enum dead-sites {
        tailf:info "Dead Sites";
      }
      enum dynamic-content {
        tailf:info "Dynamic Content";
      }
      enum educational-institutions {
        tailf:info "Educational Institutions";
      }
      enum entertainment-and-arts {
        tailf:info "Entertainment and Arts";
      }
      enum fashion-and-beauty {
        tailf:info "Fashion and Beauty";
      }
      enum financial-services {
        tailf:info "Financial Services";
      }
      enum gambling {
        tailf:info "Gambling";
      }
      enum games {
        tailf:info "Games";
      }
      enum government {
        tailf:info "Government";
      }
      enum gross {
        tailf:info "Gross";
      }
      enum hacking {
        tailf:info "Hacking";
      }
      enum hate-and-racism {
        tailf:info "Hate and Racism";
      }
      enum health-and-medicine {
        tailf:info "Health & Medicine";
      }
      enum home {
        tailf:info "Home";
      }
      enum hunting-and-fishing {
        tailf:info "Hunting and Fishing";
      }
      enum illegal {
        tailf:info "Illegal";
      }
      enum image-and-video-search {
        tailf:info "Image and Video Search";
      }
      enum individual-stock-advice-and-tools {
        tailf:info "Individual Stock Advice and Tools";
      }
      enum internet-communications {
        tailf:info "Internet Communications";
      }
      enum internet-portals {
        tailf:info "Internet Portals";
      }
      enum job-search {
        tailf:info "Job Search";
      }
      enum keyloggers-and-monitoring {
        tailf:info "Keyloggers and Monitoring";
      }
      enum kids {
        tailf:info "Kids";
      }
      enum legal {
        tailf:info "Legal";
      }
      enum local-information {
        tailf:info "Local Information";
      }
      enum malware-sites {
        tailf:info "Malware Sites";
      }
      enum marijuana {
        tailf:info "Marijuana";
      }
      enum military {
        tailf:info "Military";
      }
      enum motor-vehicles {
        tailf:info "Motor Vehicles";
      }
      enum music {
        tailf:info "Music";
      }
      enum news-and-media {
        tailf:info "News and Media";
      }
      enum nudity {
        tailf:info "Nudity";
      }
      enum online-greeting-cards {
        tailf:info "Online Greeting cards";
      }
      enum online-personal-storage {
        tailf:info "Online Personal Storage";
      }
      enum open-http-proxies {
        tailf:info "Open HTTP Proxies";
      }
      enum p2p {
        tailf:info "P2P";
      }
      enum parked-sites {
        tailf:info "Parked Sites";
      }
      enum pay-to-surf {
        tailf:info "Pay to Surf";
      }
      enum personal-sites-and-blogs {
        tailf:info "Personal Sites and Blogs";
      }
      enum philosophy-and-political-advocacy {
        tailf:info "Philosophy and Political Advocacy";
      }
      enum phishing-and-other-frauds {
        tailf:info "Phishing and Other Frauds";
      }
      enum private-ip-addresses {
        tailf:info "Private IP Addresses";
      }
      enum proxy-avoid-and-anonymizers {
        tailf:info "Proxy Avoid and Anonymizers";
      }
      enum questionable {
        tailf:info "Questionable";
      }
      enum real-estate {
        tailf:info "Real Estate";
      }
      enum recreation-and-hobbies {
        tailf:info "Recreation and Hobbies";
      }
      enum reference-and-research {
        tailf:info "Reference and Research";
      }
      enum religion {
        tailf:info "Religion";
      }
      enum search-engines {
        tailf:info "Search Engines";
      }
      enum sex-education {
        tailf:info "Sex Education";
      }
      enum shareware-and-freeware {
        tailf:info "Shareware and Freeware";
      }
      enum shopping {
        tailf:info "Shopping";
      }
      enum social-network {
        tailf:info "Social Network";
      }
      enum society {
        tailf:info "Society";
      }
      enum spam-urls {
        tailf:info "SPAM URLs";
      }
      enum sports {
        tailf:info "Sports";
      }
      enum spyware-and-adware {
        tailf:info "Spyware and Adware";
      }
      enum streaming-media {
        tailf:info "Streaming Media";
      }
      enum swimsuits-and-intimate-apparel {
        tailf:info "Swimsuits & Intimate Apparel";
      }
      enum training-and-tools {
        tailf:info "Training and Tools";
      }
      enum translation {
        tailf:info "Translation";
      }
      enum travel {
        tailf:info "Travel";
      }
      enum uncategorized {
        tailf:info "Uncategorized";
      }
      enum unconfirmed-spam-sources {
        tailf:info "Unconfirmed SPAM Sources";
      }
      enum violence {
        tailf:info "Violence";
      }
      enum weapons {
        tailf:info "Weapons";
      }
      enum web-advertisements {
        tailf:info "Web Advertisements";
      }
      enum web-based-email {
        tailf:info "Web based Email";
      }
      enum web-hosting {
        tailf:info "Web Hosting";
      }
    }
  }

  typedef subjectname-type {
    type enumeration {
      enum all {
        tailf:info "entire subject name field as aaa username";
      }
      enum commonname {
        tailf:info "cert commonname field as aaa username";
      }
      enum country {
        tailf:info "cert country field as aaa username";
      }
      enum email {
        tailf:info "cert email field as aaa username";
      }
      enum ipaddress {
        tailf:info "cert ipaddress field as aaa username";
      }
      enum locality {
        tailf:info "cert locality field as aaa username";
      }
      enum organization {
        tailf:info "cert organization field as aaa username";
      }
      enum organizationalunit {
        tailf:info "cert organizationalunit field as aaa username";
      }
      enum postalcode {
        tailf:info "cert postalcode field as aaa username";
      }
      enum serialnumber {
        tailf:info "cert serialnumber field as aaa username";
      }
      enum state {
        tailf:info "cert state field as aaa username";
      }
      enum streetaddress {
        tailf:info "cert streetaddress field as aaa username";
      }
      enum title {
        tailf:info "cert title field as aaa username";
      }
      enum unstructuredname {
        tailf:info "cert unstructuredname field as aaa username";
      }
    }
  }

  typedef snmp-traps-type {
    type enumeration {
      enum aaa_server {
        tailf:info "Allow SNMP AAA traps";
      }
      enum alarms {
        tailf:info "Allow SNMP alarms traps";
      }
      enum atm {
        tailf:info "Allow SNMP atm traps";
      }
      enum bfd {
        tailf:info "Allow SNMP BFD traps";
      }
      enum bgp {
        tailf:info "Allow BGP state change traps";
      }
      enum bstun {
        tailf:info "Allow bstun event traps";
      }
      enum bulkstat {
        tailf:info "Allow Data-Collection-MIB traps";
      }
      enum cable {
        tailf:info "Allow SNMP cable traps";
      }
      enum call-home {
        tailf:info "Allow SNMP CISCO-CALLHOME-MIB traps";
      }
      enum casa {
        tailf:info "Allow casa event traps";
      }
      enum cef {
        tailf:info "Allows cef traps";
      }
      enum cnpd {
        tailf:info "Allow NBAR Protocol Discovery traps";
      }
      enum config {
        tailf:info "Allow SNMP config traps";
      }
      enum config-copy {
        tailf:info "Allow SNMP config-copy traps";
      }
      enum config-ctid {
        tailf:info "Allow SNMP config-ctid traps";
      }
      enum cpu {
        tailf:info "Allow cpu related traps";
      }
      enum dhcp {
        tailf:info "Allow dhcp traps";
      }
      enum dlsw {
        tailf:info "Allow dlsw traps";
      }
      enum ds1 {
        tailf:info "Allow SNMP ds1 traps";
      }
      enum dsp {
        tailf:info "Allow SNMP DSP traps";
      }
      enum dspu {
        tailf:info "Allow dspu event traps";
      }
      enum eigrp {
        tailf:info "Allow SNMP EIGRP traps";
      }
      enum entity {
        tailf:info "Allow SNMP entity traps";
      }
      enum entity-diag {
        tailf:info "Allow SNMP CISCO-ENTITY-DIAG-MIB traps";
      }
      enum entity-qfp {
        tailf:info "Allow SNMP CISCO-ENTITY-QFP-MIB traps";
      }
      enum entity-state {
        tailf:info "Allow ENTITY-STATE-MIB traps";
      }
      enum envmon {
        tailf:info "Allow environmental monitor traps";
      }
      enum ethernet-cfm {
        tailf:info "Allow SNMP Ethernet CFM traps";
      }
      enum evc {
        tailf:info "Allow SNMP EVC traps";
      }
      enum event-manager {
        tailf:info "Allow SNMP Embedded Event Manager traps";
      }
      enum firewall {
        tailf:info "Allow SNMP Firewall traps";
      }
      enum flash {
        tailf:info "Allow SNMP FLASH traps";
      }
      enum flowmon {
        tailf:info "Allow SNMP flow monitor notifications";
      }
      enum frame-relay {
        tailf:info "Allow SNMP frame-relay traps";
      }
      enum fru-ctrl {
        tailf:info "Allow entity FRU control traps";
      }
      enum gdoi {
        tailf:info "Allows gdoi traps";
      }
      enum hsrp {
        tailf:info "Allow SNMP HSRP traps";
      }
      enum iplocalpool {
        tailf:info "Allow SNMP IP Local Pool traps";
      }
      enum ipmulticast {
        tailf:info "Allow SNMP ipmulticast traps";
      }
      enum ipsec {
        tailf:info "Allow SNMP IPsec traps";
      }
      enum ipsla {
        tailf:info "Allow SNMP Host IP SLA traps";
      }
      enum isakmp {
        tailf:info "Allow SNMP ISAKMP traps";
      }
      enum isg-mib {
        tailf:info "Allow SNMP isgmib traps";
      }
      enum isis {
        tailf:info "Allow IS-IS traps";
      }
      enum l2tun-pseudowire-status {
        tailf:info "Allow SNMP L2 pseudowire status traps";
      }
      enum l2tun-session {
        tailf:info "Allow SNMP L2 session traps";
      }
      enum license {
        tailf:info "Allow license traps";
      }
      enum mac-notification {
        tailf:info "Allow SNMP MAC Notification Traps";
      }
      enum memory {
        tailf:info "Allow SNMP Mempool traps";
      }
      enum mpls-fast-reroute {
        tailf:info "Allow SNMP MPLS traffic engineering fast reroute traps";
      }
      enum mpls-ldp {
        tailf:info "Allow SNMP MPLS label distribution protocol traps";
      }
      enum mpls-traffic-eng {
        tailf:info "Allow SNMP MPLS traffic engineering traps";
      }
      enum mpls-vpn {
        tailf:info "Allow SNMP MPLS Virtual Private Network traps";
      }
      enum msdp {
        tailf:info "Allow SNMP MSDP traps";
      }
      enum mvpn {
        tailf:info "Allow Multicast Virtual Private Network traps";
      }
      enum nhrp {
        tailf:info "Allow SNMP NHRP traps";
      }
      enum ospf {
        tailf:info "Allow OSPF traps";
      }
      enum ospfv3 {
        tailf:info "Allow OSPFv3 traps";
      }
      enum pfr {
        tailf:info "Allow SNMP PfR traps";
      }
      enum pim {
        tailf:info "Allow SNMP PIM traps";
      }
      enum pw-vc {
        tailf:info "Allow SNMP Pseudowire VC traps";
      }
      enum resource-policy {
        tailf:info "Enable CISCO-ERM-MIB notifications";
      }
      enum rf {
        tailf:info "Allow all SNMP traps defined in CISCO-RF-MIB";
      }
      enum rsrb {
        tailf:info "Allow rsrb event traps";
      }
      enum rsvp {
        tailf:info "Allow RSVP flow change traps";
      }
      enum sdlc {
        tailf:info "Allow sdlc event traps";
      }
      enum sdllc {
        tailf:info "Allow sdllc event traps";
      }
      enum snmp {
        tailf:info "Allow SNMP-type notifications";
      }
      enum sonet {
        tailf:info "Allow SNMP SONET traps";
      }
      enum srp {
        tailf:info "Allow SRP protocol traps";
      }
      enum stun {
        tailf:info "Allow stun event traps";
      }
      enum syslog {
        tailf:info "Allow SNMP syslog traps";
      }
      enum trustsec-sxp {
        tailf:info "Allow SNMP CISCO-TRUSTSEC-SXP-MIB traps";
      }
      enum tty {
        tailf:info "Allow TCP connection traps";
      }
      enum voice {
        tailf:info "Allow SNMP Voice traps";
      }
      enum vrfmib {
        tailf:info "Allow SNMP vrfmib traps";
      }
      enum vrrp {
        tailf:info "Allow SNMP vrrp traps";
      }
      enum x25 {
        tailf:info "Allow x25 event traps";
      }
      enum bridge {
      }
      enum rtr {
      }
      enum port-security {
      }
      enum vlan-membership {
      }
      enum vtp {
      }
      enum vlancreate {
      }
      enum vlandelete {
      }
      enum MAC-Notification {
      }
      enum cluster {
      }
    }
  }

  typedef mpls-label-mode-type {
    type enumeration {
      enum per-ce {
        tailf:info "Per CE label";
      }
      enum per-prefix {
        tailf:info "Per prefix label (default)";
      }
      enum per-vrf {
        tailf:info "Per VRF label for entire VRF";
      }
      enum vrf-conn-aggr {
        tailf:info "Per VRF label for connected and BGP aggregates in VRF";
      }
    }
  }

  typedef pm-class-type-control-event-type {
    type enumeration {
      enum access-reject {
        tailf:info "Radius authentication failed";
      }
      enum account-logoff {
        tailf:info "Upon an account logoff";
      }
      enum account-logon {
        tailf:info "Upon an account logon";
      }
      enum acct-notification {
        tailf:info "Upon an Accounting Notification event";
      }
      enum credit-exhausted {
        tailf:info "Upon the billing server returning qt=0 qv=0 it>0";
      }
      enum dummy-event {
        tailf:info "Dummy event to test suspendable actions";
      }
      enum flow-timeout {
        tailf:info "Upon flow timeout of a service";
      }
      enum quota-depleted {
        tailf:info "Upon the depletion of allocated quota";
      }
      enum radius-timeout {
        tailf:info "RADIUS server timed out during authentication";
      }
      enum service-failed {
        tailf:info "Upon failure of a service";
      }
      enum service-start {
        tailf:info "Upon a request to start a service";
      }
      enum service-stop {
        tailf:info "Upon a request to stop a service";
      }
      enum session-default-service {
        tailf:info "Upon providing default service";
      }
      enum session-restart {
        tailf:info "Upon a session being restarted";
      }
      enum session-service-found {
        tailf:info "Upon network plumbing service determined";
      }
      enum session-start {
        tailf:info "Upon a session being created";
      }
      enum timed-policy-expiry {
        tailf:info "Upon a timed policy expiry";
      }
    }
  }

  // netconf-yang cisco-ia logging
  typedef netconf-yang-cia-log-level {
    type enumeration {
      enum none {
        tailf:info "Specifies Logging level";
      }
      enum error {
        tailf:info "Specifies Logging level";
      }
      enum warning {
        tailf:info "Specifies Logging level";
      }
      enum information {
        tailf:info "Specifies Logging level";
      }
      enum debug {
        tailf:info "Specifies Logging level";
      }
    }
  }

// NOTE: This is to be able to run yang with/without ypp
//#if (1 == 0)
  typedef NEDCOM_SECRET_TYPE {
    type string;
  }
//#endif


  // =========================================================================
  // GROUPING
  // =========================================================================


  // description-grouping
  grouping description-grouping {
    leaf description {
      tailf:info "Description text";
      tailf:cli-multi-value;
      tailf:cli-preformatted;
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;Description";
      }
    }
  }

  grouping description-quote-grouping {
    leaf description {
      tailf:info "Description text";
      tailf:cli-no-value-on-delete;
      tailf:cli-full-command;
      //ios:string-quote-input "description <STRING>";
      type string {
        tailf:info "LINE;;Description";
      }
    }
  }

  // password-grouping
  grouping password-grouping {
    leaf type {
      tailf:cli-drop-node-name;
      tailf:cli-optional-in-sequence;
      tailf:cli-incomplete-command;
      type enumeration {
        enum "0" {
          tailf:info "Specifies an UNENCRYPTED password/key will follow";
        }
        enum "5" {
          tailf:info "Specifies a HIDDEN key will follow";
        }
        enum "6" {
          tailf:info "Specifies ENCRYPTED key will follow";
        }
        enum "7" {
          tailf:info "Specifies a HIDDEN password/key will follow";
        }
      }
    }
    leaf secret {
      tailf:cli-drop-node-name;
      tailf:cli-reset-container;
      tailf:cli-disallow-value "0|5|6|7|key-chain";
      type NEDCOM_SECRET_TYPE {
        tailf:info "LINE;;The UNENCRYPTED (cleartext) password/key";
      }
    }
  }

  // crypto-key-grouping
  grouping crypto-key-grouping {
    leaf encryption {
      tailf:cli-drop-node-name;
      tailf:cli-optional-in-sequence;
      tailf:cli-incomplete-command;
      type enumeration {
        enum "0" {
          tailf:info "Specifies an UNENCRYPTED password will follow";
        }
        enum "6" {
          tailf:info "Specifies an ENCRYPTED password will follow";
        }
        enum "7" {
          tailf:info "Specifies an HIDDEN password will follow";
        }
      }
    }
    leaf secret {
      tailf:cli-drop-node-name;
      tailf:cli-reset-container;
      tailf:cli-disallow-value "0|6|7";
      type NEDCOM_SECRET_TYPE {
        tailf:info "LINE;;The UNENCRYPTED (cleartext) user password";
      }
    }
  }


  // interface-name-grouping - all interface lists collected
  grouping interface-name-grouping {
    choice interface-choice {

      leaf Null {
        tailf:info "Null interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Null/name";
        }
        type uint8 {
          tailf:info "<0-0>;;Null interface number";
          range "0";
        }
      }

      leaf Loopback {
        tailf:info "Loopback interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Loopback/name";
        }
        type string {
          tailf:info "<0-2147483647>;;Loopback interface number";
          pattern '([0-9\.])+';
        }
      }

      leaf VirtualPortGroup {
        tailf:info "Virtual Port Group";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/VirtualPortGroup/name";
        }
        type uint8 {
          tailf:info "<0-31>;;VirtualPortGroup interface number";
        }
      }

      leaf Embedded-Service-Engine {
        tailf:info "cisco embedded service engine module";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Embedded-Service-Engine/name";
        }
        type string {
          tailf:info "<0-2>/<0-0>;;Embedded-Service-Engine interface number";
          pattern '[0-9]+.*';
        }
      }

      leaf Service-Engine {
        tailf:info "Cisco service engine module";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Service-Engine/name";
        }
        type string {
          tailf:info "<0-2>/<0-0>;;Service-Engine interface number";
          pattern '[0-9]+.*';
        }
      }

      leaf Tunnel {
        tailf:info "Tunnel interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Tunnel/name";
        }
        type uint32 {
          tailf:info "<0-2147483647>;;Tunnel interface number";
        }
      }

      leaf Port-channel {
        tailf:info "Ethernet Channel of interfaces";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Port-channel/name";
        }
        type uint32 {
          tailf:info "<1-512>;;Port-channel interface number";
          range "1..512";
        }
      }

      container Port-channel-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf Port-channel {
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          tailf:non-strict-leafref {
            path "/ios:interface/Port-channel-subinterface/Port-channel/name";
          }
          type string {
            pattern '[0-9]+\.[0-9]+';
          }
        }
      }

      leaf Multilink {
        tailf:info "Multilink-group interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Multilink/name";
        }
        type uint32 {
          tailf:info "<1-2147483647>;;Multilink interface number";
          range "1..2147483647";
        }
      }

      leaf nve {
        tailf:info "Network virtualization endpoint interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/nve/name";
        }
        type uint16 {
          tailf:info "<1-4096>;;nve interface number";
          range "1..4096";
        }
      }

      leaf MFR {
        tailf:info "Multilink Frame Relay bundle interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/MFR/name";
        }
        type uint32 {
          tailf:info "<0-2147483647>;;MFR interface number";
        }
      }

      container MFR-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf MFR {
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          tailf:non-strict-leafref {
            path "/ios:interface/MFR-subinterface/MFR/name";
          }
          type string {
            pattern '[0-9]+\.[0-9]+';
          }
        }
      }

      leaf BRI {
        tailf:info "ISDN Basic Rate Interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/BRI/name";
        }
        type string {
          tailf:info "<slot>/<port>;;BRI interface number";
          pattern '[0-9]+.*';
        }
      }

      leaf Ethernet-Internal {
        tailf:info "Ethernet-Internal";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Ethernet-Internal/name";
        }
        type string {
          tailf:info "<slot>/<port>;;Ethernet-Internal interface number";
          pattern '[0-9]+.*';
        }
      }

      leaf Ethernet {
        tailf:info "Ethernet";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Ethernet/name";
        }
        type string {
          tailf:info "<slot>/<port>;;Ethernet interface number";
          pattern '[0-9]+.*';
        }
      }

      leaf FastEthernet {
        tailf:info "FastEthernet IEEE 802.3";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/FastEthernet/name";
        }
        type string {
          tailf:info "<0-66>/<0-128>;;FastEthernet interface number";
          pattern '[0-9]+.*';
        }
      }

      leaf GigabitEthernet {
        tailf:info "GigabitEthernet IEEE 802.3z";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/GigabitEthernet/name";
        }
        type string {
          tailf:info "<0-66>/<0-128>;;GigabitEthernet interface number";
          pattern '[0-9]+.*';
        }
      }

      leaf TwoGigabitEthernet {
        tailf:info "Two Gigabit Ethernet";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/TwoGigabitEthernet/name";
        }
        type string {
          tailf:info "<0-66>/<0-128>;;TwoGigabitEthernet interface number";
          pattern '[0-9]+.*';
        }
      }

      leaf TenGigabitEthernet {
        tailf:info "Ten Gigabit Ethernet";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/TenGigabitEthernet/name";
        }
        type string {
          tailf:info "<0-66>/<0-128>;;TenGigabitEthernet interface number";
          pattern '[0-9]+.*';
        }
      }

      leaf TwentyFiveGigE {
        tailf:info "Twenty Five Gigabit Ethernet";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/TwentyFiveGigE/name";
        }
        type string {
          tailf:info "<0-66>/<0-128>;;TwentyFiveGigE interface number";
          pattern '[0-9]+.*';
        }
      }

      leaf FortyGigabitEthernet {
        tailf:info "Forty Gigabit Ethernet";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/FortyGigabitEthernet/name";
        }
        type string {
          tailf:info "X/Y/Z;;FortyGigabitEthernet interface id";
          pattern '[0-9]+.*';
        }
      }

      leaf HundredGigE {
        tailf:info "Hundred Gigabit Ethernet";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/HundredGigE/name";
        }
        type string {
          tailf:info "<0-66>/<0-128>;;HundredGigE interface number";
          pattern '[0-9]+.*';
        }
      }

      leaf mgmt {
        tailf:info "Management Ethernet interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/mgmt/name";
        }
        type uint8 {
          tailf:info "<0-0>;;mgmt interface number";
          range "0";
        }
      }

      leaf Wlan-GigabitEthernet {
        tailf:info "Wlan-GigabitEthernet interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Wlan-GigabitEthernet/name";
        }
        type string {
          tailf:info "<0-0>;;Wlan-GigabitEthernet interface number";
          pattern '[0-9]+.*';
        }
      }

      leaf wlan-ap {
        tailf:info "Service module interface to embedded AP";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/wlan-ap/name";
        }
        type string {
          tailf:info "<0-0>;;wlan-ap interface number";
          pattern '[0-9]+.*';
        }
      }

      leaf ISM {
        tailf:info "WORD;;ISM interface number";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/ISM/name";
        }
        type string {
          tailf:info "WORD;;ISM interface number";
          pattern '[0-9]+.*';
        }
      }

      leaf Analysis-Module {
        tailf:info "cisco network analysis service module";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Analysis-Module/name";
        }
        type string {
          tailf:info "WORD;;Analysis-Module interface number";
          pattern '[0-9]+.*';
        }
      }

      leaf Integrated-Service-Engine {
        tailf:info "cisco integrated service engine module";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Integrated-Service-Engine/name";
        }
        type string {
          tailf:info "WORD;;Integrated-Service-Engine interface number";
          pattern '[0-9]+.*';
        }
      }

      leaf ATM {
        tailf:info "ATM interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/ATM/name";
        }
        type string {
          pattern '[0-9]+.*';
        }
      }

      leaf CEM {
        tailf:info "Circuit Emulation interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/CEM/name";
        }
        type string {
          pattern '[0-9]+.*';
        }
      }

      leaf CEM-ACR {
        tailf:info "Circuit Emulation interface with ACR";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/CEM-ACR/name";
        }
        type string {
          pattern '[0-9]+.*';
        }
      }

      leaf BDI {
        tailf:info "Bridge-Domain interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/BDI/name";
        }
        type uint16 {
          tailf:info "<1-8191>;;BDI interface number";
          range "1..8191";
        }
      }

      leaf BVI {
        tailf:info "Bridge-Group Virtual Interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/BVI/name";
        }
        type string {
          tailf:info "<1-255>;;BVI interface number";
          pattern '[0-9]+.*';
        }
      }

      leaf Cable {
        tailf:info "CMTS interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Cable/name";
        }
        type string {
          pattern '[0-9]+.*';
        }
      }

      leaf CMON-Tunnel {
        tailf:info "Cable Monitor interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/CMON-Tunnel/name";
        }
        type string {
          pattern '[0-9]+.*';
        }
      }

      leaf Video {
        tailf:info "video service interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Video/name";
        }
        type string {
          pattern '[0-9]+.*';
        }
      }

      leaf Integrated-Cable {
        tailf:info "Integrated Cable interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Integrated-Cable/name";
        }
        type string {
          pattern '[0-9]+.*';
        }
      }

      leaf Modular-Cable {
        tailf:info "Modular Cable interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Modular-Cable/name";
        }
        type string {
          pattern '[0-9]+.*';
        }
      }

      leaf Wideband-Cable {
        tailf:info "Wideband CMTS interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Wideband-Cable/name";
        }
        type string {
          pattern '[0-9]+.*';
        }
      }

      leaf Dialer {
        tailf:info "Dialer interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Dialer/name";
        }
        type string {
          tailf:info "<0-255>;;Dialer interface number";
          pattern '[0-9]+.*';
        }
      }

      leaf Bundle {
        tailf:info "Virtual Bundle";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Bundle/name";
        }
        type uint8 {
          tailf:info "<1-255>;;Bundle interface number";
          range "1..255";
        }
      }

      container Bundle-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf Bundle {
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          tailf:non-strict-leafref {
            path "/ios:interface/Bundle-subinterface/Bundle/name";
          }
          type string {
            pattern '[0-9]+\.[0-9]+';
          }
        }
      }

      leaf Cellular {
        tailf:info "Cellular";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Cellular/name";
        }
        type string {
          pattern '[0-9]+.*';
        }
      }

      leaf Qam-red {
        tailf:info "QAM red interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Qam-red/name";
        }
        type string {
          pattern '[0-9]+.*';
        }
      }

      leaf Asi {
        tailf:info "ASI interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Asi/name";
        }
        type string {
          pattern '[0-9]+.*';
        }
      }

      leaf Vlan {
        tailf:info "Catalyst Vlans";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Vlan/name";
        }
        type uint16 {
          tailf:info "<1-4094>;;Vlan interface number";
          range "1..4094";
        }
      }

      leaf Async {
        tailf:info "Async interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Async/name";
        }
        type string {
          pattern '[0-9]+.*';
        }
      }

      leaf Group-Async {
        tailf:info "Async Group interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Group-Async/name";
        }
        type uint16;
      }

      leaf POS {
        tailf:info "POS interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/POS/name";
        }
        type string {
          pattern '[0-9]+.*';
        }
      }

      leaf SM {
        tailf:info "Services Module (SM) with Services Ready Engine (SRE)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/SM/name";
        }
        type string {
          pattern '[0-9]+/[0-9]+';
        }
      }

      leaf Serial {
        tailf:info "Serial interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Serial/name";
        }
        type string {
          pattern '[0-9]+(/[\.0-9]+)*(:[0-9]+)?';
        }
      }

      container Serial-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf Serial {
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          tailf:non-strict-leafref {
            path "/ios:interface/Serial-subinterface/Serial/name";
          }
          type string {
            pattern '[0-9]+(/[\.0-9]+)*(:[0-9]+)?\.[0-9]+';
          }
        }
      }

      leaf Virtual-Template {
        tailf:info "Virtual Template interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Virtual-Template/name";
        }
        type uint16 {
          tailf:info "<1-4095>;;Virtual-Template interface number";
          range "1..4095";
        }
      }

      leaf Virtual-PPP {
        tailf:info "Virtual PPP interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Virtual-PPP/name";
        }
        type uint32 {
          tailf:info "<1-2147483647>;;Virtual-PPP interface number";
          range "1..2147483647";
        }
      }

      leaf pseudowire {
        tailf:info "Pseudowire Interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/pseudowire/name";
        }
        type uint32 {
          tailf:info "<1-231072>;;pseudowire interface number";
          range "1..231072";
        }
      }

      leaf LISP {
        tailf:info "Locator/ID Separation Protocol Virtual Interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/LISP/name";
        }
        type uint16 {
          tailf:info "<0-1999>;;LISP interface number";
          range "0..1999";
        }
      }

      container LISP-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf LISP {
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          tailf:non-strict-leafref {
            path "/ios:interface/LISP-subinterface/LISP/name";
          }
          type string {
            pattern '[0-9]+\.[0-9]+';
          }
        }
      }

      // network-clock input-source * interface ToP0/12
      leaf ToP {
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          pattern "[0-9]+/[0-9]+";
        }
      }

      leaf Dot11Radio {
        tailf:info "IEEE 802.11 WLAN";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Dot11Radio/name";
        }
        type string {
          pattern '[0-9]+.*';
        }
      }

      leaf vasileft {
        tailf:info "VasiLeft interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/vasileft/name";
        }
        type uint16 {
          tailf:info "<1-1000>;;vasileft interface number";
          range "1..1000";
        }
      }

      leaf vasiright {
        tailf:info "VasiRight interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/vasiright/name";
        }
        type uint16 {
          tailf:info "<1-1000>;;vasiright interface number";
          range "1..1000";
        }
      }

      leaf AppNav-Compress {
        tailf:info "Service-Context Virtual Interface Compress";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/AppNav-Compress/name";
        }
        type uint16 {
          tailf:info "<1-1000>;;AppNav-Compress interface number";
          range "1..1000";
        }
      }

      leaf AppNav-UnCompress {
        tailf:info "Service-Context Virtual interface UnCompress";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/AppNav-UnCompress/name";
        }
        type uint16 {
          tailf:info "<1-1000>;;AppNav-UnCompress interface number";
          range "1..1000";
        }
      }

      leaf ucse {
        tailf:info "Cisco ucse server";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/ucse/name";
        }
        type string {
          pattern '[0-9]+.*';
        }
      }

      leaf GMPLS {
        tailf:info "MPLS interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/GMPLS/name";
        }
        type uint16 {
          tailf:info "<0-1000>;;GMPLS interface number";
          range "0..1000";
        }
      }
      container GMPLS-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf GMPLS {
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          tailf:non-strict-leafref {
            path "/ios:interface/GMPLS-subinterface/GMPLS/name";
          }
          type string {
            pattern '[0-9]+\.[0-9]+';
          }
        }
      }
    }
  } // interface-name-grouping


  grouping interface-nodiff-name-grouping {
    choice interface-choice {

      leaf Null {
        tailf:info "Null interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint8 {
          tailf:info "<0-0>;;Null interface number";
          range "0";
        }
      }

      leaf Loopback {
        tailf:info "Loopback interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          tailf:info "<0-2147483647>;;Loopback interface number";
          pattern '([0-9\.])+';
        }
      }

      leaf VirtualPortGroup {
        tailf:info "Virtual Port Group";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint8 {
          tailf:info "<0-31>;;VirtualPortGroup interface number";
        }
      }

      leaf Embedded-Service-Engine {
        tailf:info "cisco embedded service engine module";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          tailf:info "<0-2>/<0-0>;;Embedded-Service-Engine interface number";
          pattern '[0-9]+.*';
        }
      }

      leaf Service-Engine {
        tailf:info "Cisco service engine module";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          tailf:info "<0-2>/<0-0>;;Service-Engine interface number";
          pattern '[0-9]+.*';
        }
      }

      leaf Tunnel {
        tailf:info "Tunnel interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint32 {
          tailf:info "<0-2147483647>;;Tunnel interface number";
        }
      }

      leaf Port-channel {
        tailf:info "Ethernet Channel of interfaces";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint32 {
          tailf:info "<1-512>;;Port-channel interface number";
          range "1..512";
        }
      }

      container Port-channel-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf Port-channel {
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          type string {
            pattern '[0-9]+\.[0-9]+';
          }
        }
      }

      leaf Multilink {
        tailf:info "Multilink-group interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint32 {
          tailf:info "<1-2147483647>;;Multilink interface number";
          range "1..2147483647";
        }
      }

      leaf nve {
        tailf:info "Network virtualization endpoint interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint16 {
          tailf:info "<1-4096>;;nve interface number";
          range "1..4096";
        }
      }

      leaf MFR {
        tailf:info "Multilink Frame Relay bundle interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint32 {
          tailf:info "<0-2147483647>;;MFR interface number";
        }
      }

      container MFR-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf MFR {
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          type string {
            pattern '[0-9]+\.[0-9]+';
          }
        }
      }

      leaf BRI {
        tailf:info "ISDN Basic Rate Interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          tailf:info "<slot>/<port>;;BRI interface number";
          pattern '[0-9]+.*';
        }
      }

      leaf Ethernet-Internal {
        tailf:info "Ethernet-Internal";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          tailf:info "<slot>/<port>;;Ethernet-Internal interface number";
          pattern '[0-9]+.*';
        }
      }

      leaf Ethernet {
        tailf:info "Ethernet";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          tailf:info "<slot>/<port>;;Ethernet interface number";
          pattern '[0-9]+.*';
        }
      }

      leaf FastEthernet {
        tailf:info "FastEthernet IEEE 802.3";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          tailf:info "<0-66>/<0-128>;;FastEthernet interface number";
          pattern '[0-9]+.*';
        }
      }

      leaf GigabitEthernet {
        tailf:info "GigabitEthernet IEEE 802.3z";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          tailf:info "<0-66>/<0-128>;;GigabitEthernet interface number";
          pattern '[0-9]+.*';
        }
      }

      leaf TwoGigabitEthernet {
        tailf:info "Two Gigabit Ethernet";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          tailf:info "<0-66>/<0-128>;;TwoGigabitEthernet interface number";
          pattern '[0-9]+.*';
        }
      }

      leaf TenGigabitEthernet {
        tailf:info "Ten Gigabit Ethernet";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          tailf:info "<0-66>/<0-128>;;TenGigabitEthernet interface number";
          pattern '[0-9]+.*';
        }
      }

      leaf TwentyFiveGigE {
        tailf:info "Twenty Five Gigabit Ethernet";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          tailf:info "<0-66>/<0-128>;;TwentyFiveGigE interface number";
          pattern '[0-9]+.*';
        }
      }

      leaf FortyGigabitEthernet {
        tailf:info "Forty Gigabit Ethernet";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          tailf:info "X/Y/Z;;FortyGigabitEthernet interface id";
          pattern '[0-9]+.*';
        }
      }

      leaf HundredGigE {
        tailf:info "Hundred Gigabit Ethernet";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          tailf:info "<0-66>/<0-128>;;HundredGigE interface number";
          pattern '[0-9]+.*';
        }
      }

      leaf mgmt {
        tailf:info "Management Ethernet interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint8 {
          tailf:info "<0-0>;;mgmt interface number";
          range "0";
        }
      }

      leaf Wlan-GigabitEthernet {
        tailf:info "Wlan-GigabitEthernet interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          tailf:info "<0-0>;;Wlan-GigabitEthernet interface number";
          pattern '[0-9]+.*';
        }
      }

      leaf wlan-ap {
        tailf:info "Service module interface to embedded AP";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          tailf:info "<0-0>;;wlan-ap interface number";
          pattern '[0-9]+.*';
        }
      }

      leaf ISM {
        tailf:info "WORD;;ISM interface number";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          tailf:info "WORD;;ISM interface number";
          pattern '[0-9]+.*';
        }
      }

      leaf Analysis-Module {
        tailf:info "cisco network analysis service module";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          tailf:info "WORD;;Analysis-Module interface number";
          pattern '[0-9]+.*';
        }
      }

      leaf Integrated-Service-Engine {
        tailf:info "cisco integrated service engine module";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          tailf:info "WORD;;Integrated-Service-Engine interface number";
          pattern '[0-9]+.*';
        }
      }

      leaf ATM {
        tailf:info "ATM interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          pattern '[0-9]+.*';
        }
      }

      leaf CEM {
        tailf:info "Circuit Emulation interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          pattern '[0-9]+.*';
        }
      }

      leaf CEM-ACR {
        tailf:info "Circuit Emulation interface with ACR";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          pattern '[0-9]+.*';
        }
      }

      leaf BDI {
        tailf:info "Bridge-Domain interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint16 {
          tailf:info "<1-8191>;;BDI interface number";
          range "1..8191";
        }
      }

      leaf BVI {
        tailf:info "Bridge-Group Virtual Interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          tailf:info "<1-255>;;BVI interface number";
          pattern '[0-9]+.*';
        }
      }

      leaf Cable {
        tailf:info "CMTS interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          pattern '[0-9]+.*';
        }
      }

      leaf CMON-Tunnel {
        tailf:info "Cable Monitor interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          pattern '[0-9]+.*';
        }
      }

      leaf Video {
        tailf:info "video service interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          pattern '[0-9]+.*';
        }
      }

      leaf Integrated-Cable {
        tailf:info "Integrated Cable interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          pattern '[0-9]+.*';
        }
      }

      leaf Modular-Cable {
        tailf:info "Modular Cable interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          pattern '[0-9]+.*';
        }
      }

      leaf Wideband-Cable {
        tailf:info "Wideband CMTS interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          pattern '[0-9]+.*';
        }
      }

      leaf Dialer {
        tailf:info "Dialer interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          tailf:info "<0-255>;;Dialer interface number";
          pattern '[0-9]+.*';
        }
      }

      leaf Bundle {
        tailf:info "Virtual Bundle";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint8 {
          tailf:info "<1-255>;;Bundle interface number";
          range "1..255";
        }
      }

      container Bundle-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf Bundle {
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          type string {
            pattern '[0-9]+\.[0-9]+';
          }
        }
      }

      leaf Cellular {
        tailf:info "Cellular";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          pattern '[0-9]+.*';
        }
      }

      leaf Qam-red {
        tailf:info "QAM red interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          pattern '[0-9]+.*';
        }
      }

      leaf Asi {
        tailf:info "ASI interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          pattern '[0-9]+.*';
        }
      }

      leaf Vlan {
        tailf:info "Catalyst Vlans";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint16 {
          tailf:info "<1-4094>;;Vlan interface number";
          range "1..4094";
        }
      }

      leaf Async {
        tailf:info "Async interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          pattern '[0-9]+.*';
        }
      }

      leaf Group-Async {
        tailf:info "Async Group interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint16;
      }

      leaf POS {
        tailf:info "POS interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          pattern '[0-9]+.*';
        }
      }

      leaf SM {
        tailf:info "Services Module (SM) with Services Ready Engine (SRE)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          pattern '[0-9]+/[0-9]+';
        }
      }

      leaf Serial {
        tailf:info "Serial interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          pattern '[0-9]+(/[\.0-9]+)*(:[0-9]+)?';
        }
      }

      container Serial-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf Serial {
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          type string {
            pattern '[0-9]+(/[\.0-9]+)*(:[0-9]+)?\.[0-9]+';
          }
        }
      }

      leaf Virtual-Template {
        tailf:info "Virtual Template interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint16 {
          tailf:info "<1-4095>;;Virtual-Template interface number";
          range "1..4095";
        }
      }

      leaf Virtual-PPP {
        tailf:info "Virtual PPP interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint32 {
          tailf:info "<1-2147483647>;;Virtual-PPP interface number";
          range "1..2147483647";
        }
      }

      leaf pseudowire {
        tailf:info "Pseudowire Interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint32 {
          tailf:info "<1-231072>;;pseudowire interface number";
          range "1..231072";
        }
      }

      leaf LISP {
        tailf:info "Locator/ID Separation Protocol Virtual Interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint16 {
          tailf:info "<0-1999>;;LISP interface number";
          range "0..1999";
        }
      }

      container LISP-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf LISP {
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          type string {
            pattern '[0-9]+\.[0-9]+';
          }
        }
      }

      // network-clock input-source * interface ToP0/12
      leaf ToP {
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          pattern "[0-9]+/[0-9]+";
        }
      }

      leaf Dot11Radio {
        tailf:info "IEEE 802.11 WLAN";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          pattern '[0-9]+.*';
        }
      }

      leaf vasileft {
        tailf:info "VasiLeft interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint16 {
          tailf:info "<1-1000>;;vasileft interface number";
          range "1..1000";
        }
      }

      leaf vasiright {
        tailf:info "VasiRight interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint16 {
          tailf:info "<1-1000>;;vasiright interface number";
          range "1..1000";
        }
      }

      leaf AppNav-Compress {
        tailf:info "Service-Context Virtual Interface Compress";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint16 {
          tailf:info "<1-1000>;;AppNav-Compress interface number";
          range "1..1000";
        }
      }

      leaf AppNav-UnCompress {
        tailf:info "Service-Context Virtual interface UnCompress";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint16 {
          tailf:info "<1-1000>;;AppNav-UnCompress interface number";
          range "1..1000";
        }
      }

      leaf ucse {
        tailf:info "Cisco ucse server";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          pattern '[0-9]+.*';
        }
      }

      leaf GMPLS {
        tailf:info "MPLS interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint16 {
          tailf:info "<0-1000>;;GMPLS interface number";
          range "0..1000";
        }
      }
      container GMPLS-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf GMPLS {
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          type string {
            pattern '[0-9]+\.[0-9]+';
          }
        }
      }
    }
  } // interface-nodiff-name-grouping


  // service-group * / service-policy
  // control-plane service-policy
  // interface * / service-policy
  // interface pseudowire * / service-policy
  // interface * / service-policy type performance-monitor
  // wireless profile policy * / service-policy
  // interface * / vlan-range * / service-policy
  // map-class frame-relay * / service-policy
  // vlan configuration * / service policy
  // interface ATM* / pvc * / service-policy
  grouping service-policy-grouping {
    leaf output {
      tailf:info "Assign output policy-map";
      tailf:cli-remove-before-change;
      tailf:non-strict-leafref {
        path "/ios:policy-map/name";
      }
      type string {
        tailf:info "WORD;;output Policy-map name";
      }
    }
    leaf input {
      tailf:info "Assign input policy-map";
      tailf:cli-remove-before-change;
      tailf:non-strict-leafref {
        path "/ios:policy-map/name";
      }
      type string {
        tailf:info "WORD;;input Policy-map name";
      }
    }
  }

  // police {conform|exceed|violate}-action groupings
  grouping police-action-transmit-grouping {
    leaf transmit {
      tailf:info "transmit packet";
      type empty;
    }
  }
  grouping police-action-drop-grouping {
    leaf drop {
      tailf:info "drop packet";
      type empty;
    }
  }


  // Police conform action grouping
  grouping police-conform-action-grouping {
    container conform-action {
      tailf:info "action when rate is less than conform burst";
      tailf:cli-flatten-container;
      choice conform-action-choice {
        leaf set-clp-transmit {
          tailf:info "set atm clp and send it";
          type empty;
        }
        leaf set-cos-transmit {
          tailf:info "rewrite packet cos and send it";
          type cos_value-type;
        }
        leaf set-discard-class-transmit {
          tailf:info "set discard-class and send it";
          type uint8 {
            tailf:info "<0-63>;;new discard-class";
            range "0..63";
          }
        }
        leaf set-dscp-transmit {
          tailf:info "set dscp and send it";
          type dscp-type;
        }
        leaf set-frde-transmit {
          tailf:info "set FR DE and send it";
          type empty;
        }
        leaf set-mpls-exp-imposition-transmit {
          tailf:info "set exp at tag imposition and send it";
          type exp_value-type;
        }
        leaf set-mpls-exp-topmost-transmit {
          tailf:info "set exp on topmost label and send it";
          type exp_value-type;
        }
        leaf set-prec-transmit {
          tailf:info "rewrite packet precedence and send it";
          type prec_value-type;
        }
        leaf set-qos-transmit {
          tailf:info "set qos-group and send it";
          type qos_value-type;
        }
        leaf transmit {
          tailf:info "transmit packet";
          type empty;
        }
        leaf drop {
          tailf:info "drop packet";
          type empty;
        }
      }
    }

    leaf table {
      tailf:info "Specify conform-action table-map";
      tailf:cli-optional-in-sequence;
      tailf:non-strict-leafref {
        path "/ios:table-map/name";
      }
      type string {
        tailf:info "WORD;;table-map name";
      }
    }
  }

  // Police exceed action grouping
  grouping police-exceed-action-grouping {
    container exceed-action {
      tailf:info "action when rate is within conform and conform + exceed burst";
      tailf:cli-flatten-container;
      choice exceed-action-choice {
        leaf dscp {
          type dscp-type;
        }
        leaf set-clp-transmit {
          tailf:info "set atm clp and send it";
          type empty;
        }
        leaf set-cos-transmit {
          tailf:info "rewrite packet cos and send it";
          type cos_value-type;
        }
        leaf set-discard-class-transmit {
          tailf:info "set discard-class and send it";
          type uint8 {
            tailf:info "<0-63>;;new discard-class";
            range "0..63";
          }
        }
        leaf set-dscp-transmit {
          tailf:info "set dscp and send it";
          type dscp-type;
        }
        leaf set-frde-transmit {
          tailf:info "set FR DE and send it";
          type empty;
        }
        leaf set-mpls-exp-imposition-transmit {
          tailf:info "set exp at tag imposition and send it";
          type exp_value-type;
        }
        leaf set-mpls-exp-topmost-transmit {
          tailf:info "set exp on topmost label and send it";
          type exp_value-type;
        }
        leaf set-prec-transmit {
          tailf:info "rewrite packet precedence and send it";
          type prec_value-type;
        }
        leaf set-qos-transmit {
          tailf:info "set qos-group and send it";
          type qos_value-type;
        }
        leaf transmit {
          tailf:info "transmit packet";
          type empty;
        }
        leaf drop {
          tailf:info "drop packet";
          type empty;
        }
        leaf policed-dscp-transmit {
          tailf:info "change dscp per policed-dscp map and send it";
          type empty;
        }
      }
    }
  }

  // Police violate action grouping
  grouping police-violate-action-grouping {
    container violate-action {
      tailf:info "action when rate is greater than conform exceed burst";
      tailf:cli-flatten-container;
      choice violate-action-choice {
        leaf set-clp-transmit {
          tailf:info "set atm clp and send it";
          type empty;
        }
        leaf set-cos-transmit {
          tailf:info "rewrite packet cos and send it";
          type cos_value-type;
        }
        leaf set-discard-class-transmit {
          tailf:info "set discard-class and send it";
          type uint8 {
            tailf:info "<0-63>;;new discard-class";
            range "0..63";
          }
        }
        leaf set-dscp-transmit {
          tailf:info "set dscp and send it";
          type dscp-type;
        }
        leaf set-frde-transmit {
          tailf:info "set FR DE and send it";
          type empty;
        }
        leaf set-mpls-exp-imposition-transmit {
          tailf:info "set exp at tag imposition and send it";
          type exp_value-type;
        }
        leaf set-mpls-exp-topmost-transmit {
          tailf:info "set exp on topmost label and send it";
          type exp_value-type;
        }
        leaf set-prec-transmit {
          tailf:info "rewrite packet precedence and send it";
          type prec_value-type;
        }
        leaf set-qos-transmit {
          tailf:info "set qos-group and send it";
          type qos_value-type;
        }
        leaf transmit {
          tailf:info "transmit packet";
          type empty;
        }
        leaf drop {
          tailf:info "drop packet";
          type empty;
        }
      }
    }
  }


  // Police multiple conform action grouping
  grouping police-multiple-conform-action-grouping {
    container conform-set-clp-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container conform-action {
        tailf:info "action when rate is less than conform burst";
        tailf:cli-flatten-container;
        leaf set-clp-transmit {
          tailf:info "set atm clp and send it";
          type empty;
        }
      }
    }
    choice conform-set-cos-transmit-choice {
      container conform-set-cos-transmit {
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        container conform-action {
          tailf:info "action when rate is less than conform burst";
          tailf:cli-flatten-container;
          leaf set-cos-transmit {
            tailf:info "rewrite packet cos and send it";
            type cos_value-type;
          }
        }
      }
      container conform-set-cos-transmit-table {
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        container conform-action {
          tailf:info "action when rate is less than conform burst";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf set-cos-transmit {
            tailf:info "rewrite packet cos and send it";
            tailf:cli-incomplete-command;
            type cos_value-type;
          }
          leaf table {
            tailf:info "Specify table-map";
            tailf:non-strict-leafref {
              path "/ios:table-map/name";
            }
            type string {
              tailf:info "WORD;;table-map name";
            }
          }
        }
      }
    }
    container conform-set-discard-class-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container conform-action {
        tailf:info "action when rate is less than conform burst";
        tailf:cli-flatten-container;
        leaf set-discard-class-transmit {
          tailf:info "set discard-class and send it";
          type uint8 {
            tailf:info "<0-63>;;new discard-class";
            range "0..63";
          }
        }
      }
    }
    choice conform-set-dscp-transmit-choice {
      container conform-set-dscp-transmit {
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        container conform-action {
          tailf:info "action when rate is less than conform burst";
          tailf:cli-flatten-container;
          leaf set-dscp-transmit {
            tailf:info "set dscp and send it";
            type dscp-type;
          }
        }
      }
      container conform-set-dscp-transmit-table {
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        container conform-action {
          tailf:info "action when rate is less than conform burst";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf set-dscp-transmit {
            tailf:info "set dscp and send it";
            tailf:cli-incomplete-command;
            type dscp-type;
          }
          leaf table {
            tailf:info "Specify table-map";
            tailf:non-strict-leafref {
              path "/ios:table-map/name";
            }
            type string {
              tailf:info "WORD;;table-map name";
            }
          }
        }
      }
    }
    container conform-set-frde-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container conform-action {
        tailf:info "action when rate is less than conform burst";
        tailf:cli-flatten-container;
        leaf set-frde-transmit {
          tailf:info "set FR DE and send it";
          type empty;
        }
      }
    }
    choice conform-set-mpls-exp-imposition-transmit-choice {
      container conform-set-mpls-exp-imposition-transmit {
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        container conform-action {
          tailf:info "action when rate is less than conform burst";
          tailf:cli-flatten-container;
          leaf set-mpls-exp-imposition-transmit {
            tailf:info "set exp at tag imposition and send it";
            type exp_value-type;
          }
        }
      }
      container conform-set-mpls-exp-imposition-transmit-table {
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        container conform-action {
          tailf:info "action when rate is less than conform burst";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf set-mpls-exp-imposition-transmit {
            tailf:info "set exp at tag imposition and send it";
            tailf:cli-incomplete-command;
            type exp_value-type;
          }
          leaf table {
            tailf:info "Specify table-map";
            tailf:non-strict-leafref {
              path "/ios:table-map/name";
            }
            type string {
              tailf:info "WORD;;table-map name";
            }
          }
        }
      }
    }
    choice conform-set-mpls-exp-topmost-transmit-choice {
      container conform-set-mpls-exp-topmost-transmit {
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        container conform-action {
          tailf:info "action when rate is less than conform burst";
          tailf:cli-flatten-container;
          leaf set-mpls-exp-topmost-transmit {
            tailf:info "set exp on topmost label and send it";
            type exp_value-type;
          }
        }
      }
      container conform-set-mpls-exp-topmost-transmit-table {
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        container conform-action {
          tailf:info "action when rate is less than conform burst";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf set-mpls-exp-topmost-transmit {
            tailf:info "set exp on topmost label and send it";
            tailf:cli-incomplete-command;
            type exp_value-type;
          }
          leaf table {
            tailf:info "Specify table-map";
            tailf:non-strict-leafref {
              path "/ios:table-map/name";
            }
            type string {
              tailf:info "WORD;;table-map name";
            }
          }
        }
      }
    }
    choice conform-set-prec-transmit-choice {
      container conform-set-prec-transmit {
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        container conform-action {
          tailf:info "action when rate is less than conform burst";
          tailf:cli-flatten-container;
          leaf set-prec-transmit {
            tailf:info "rewrite packet precedence and send it";
            type prec_value-type;
          }
        }
      }
      container conform-set-prec-transmit-table {
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        container conform-action {
          tailf:info "action when rate is less than conform burst";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf set-prec-transmit {
            tailf:info "rewrite packet precedence and send it";
            tailf:cli-incomplete-command;
            type prec_value-type;
          }
          leaf table {
            tailf:info "Specify table-map";
            tailf:non-strict-leafref {
              path "/ios:table-map/name";
            }
            type string {
              tailf:info "WORD;;table-map name";
            }
          }
        }
      }
    }
    choice conform-set-qos-transmit-choice {
      container conform-set-qos-transmit {
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        container conform-action {
          tailf:info "action when rate is less than conform burst";
          tailf:cli-flatten-container;
          leaf set-qos-transmit {
            tailf:info "set qos-group and send it";
            type qos_value-type;
          }
        }
      }
      container conform-set-qos-transmit-table {
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        container conform-action {
          tailf:info "action when rate is less than conform burst";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf set-qos-transmit {
            tailf:info "set qos-group and send it";
            tailf:cli-incomplete-command;
            type qos_value-type;
          }
          leaf table {
            tailf:info "Specify table-map";
            tailf:non-strict-leafref {
              path "/ios:table-map/name";
            }
            type string {
              tailf:info "WORD;;table-map name";
            }
          }
        }
      }
    }
    container conform-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container conform-action {
        tailf:info "action when rate is less than conform burst";
        tailf:cli-flatten-container;
        uses police-action-transmit-grouping;
      }
    }
    container conform-drop {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container conform-action {
        tailf:info "action when rate is less than conform burst";
        tailf:cli-flatten-container;
        uses police-action-drop-grouping;
      }
    }
  }

  // Police multiple exceed action grouping
  grouping police-multiple-exceed-action-grouping {

    container exceed-dscp {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container exceed-action {
        tailf:info "action when rate is within conform and conform + exceed burst";
        tailf:cli-flatten-container;
        leaf dscp {
          //tailf:info
          type dscp-type;
        }
      }
    }

    container exceed-set-clp-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container exceed-action {
        tailf:info "action when rate is within conform and conform + exceed burst";
        tailf:cli-flatten-container;
        leaf set-clp-transmit {
          tailf:info "set atm clp and send it";
          type empty;
        }
      }
    }

    choice exceed-set-cos-transmit-choice {
      container exceed-set-cos-transmit {
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        container exceed-action {
          tailf:info "action when rate is within conform and conform + exceed burst";
          tailf:cli-flatten-container;
          leaf set-cos-transmit {
            tailf:info "rewrite packet cos and send it";
            type cos_value-type;
          }
        }
      }
      container exceed-set-cos-transmit-table {
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        container exceed-action {
          tailf:info "action when rate is within conform and conform + exceed burst";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf set-cos-transmit {
            tailf:info "rewrite packet cos and send it";
            tailf:cli-incomplete-command;
            type cos_value-type;
          }
          leaf table {
            tailf:info "Specify table-map";
            tailf:non-strict-leafref {
              path "/ios:table-map/name";
            }
            type string {
              tailf:info "WORD;;table-map name";
            }
          }
        }
      }
    }

    container exceed-set-discard-class-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container exceed-action {
        tailf:info "action when rate is within conform and conform + exceed burst";
        tailf:cli-flatten-container;
        leaf set-discard-class-transmit {
          tailf:info "set discard-class and send it";
          type uint8 {
            tailf:info "<0-63>;;new discard-class";
            range "0..63";
          }
        }
      }
    }

    choice exceed-set-dscp-transmit-choice {
      container exceed-set-dscp-transmit {
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        container exceed-action {
          tailf:info "action when rate is within conform and conform + exceed burst";
          tailf:cli-flatten-container;
          leaf set-dscp-transmit {
            tailf:info "set dscp and send it";
            type dscp-type;
          }
        }
      }
      container exceed-set-dscp-transmit-table {
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        container exceed-action {
          tailf:info "action when rate is within conform and conform + exceed burst";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf set-dscp-transmit {
            tailf:info "set dscp and send it";
            tailf:cli-incomplete-command;
            type dscp-type;
          }
          leaf table {
            tailf:info "Specify table-map";
            tailf:non-strict-leafref {
              path "/ios:table-map/name";
            }
            type string {
              tailf:info "WORD;;table-map name";
            }
          }
        }
      }
    }

    container exceed-set-frde-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container exceed-action {
        tailf:info "action when rate is within conform and conform + exceed burst";
        tailf:cli-flatten-container;
        leaf set-frde-transmit {
          tailf:info "set FR DE and send it";
          type empty;
        }
      }
    }

    container exceed-set-mpls-exp-imposition-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container exceed-action {
        tailf:info "action when rate is within conform and conform + exceed burst";
        tailf:cli-flatten-container;
        leaf set-mpls-exp-imposition-transmit {
          tailf:info "set exp at tag imposition and send it";
          type exp_value-type;
        }
      }
    }

    container exceed-set-mpls-exp-topmost-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container exceed-action {
        tailf:info "action when rate is within conform and conform + exceed burst";
        tailf:cli-flatten-container;
        leaf set-mpls-exp-topmost-transmit {
          tailf:info "set exp on topmost label and send it";
          type exp_value-type;
        }
      }
    }

    container exceed-set-prec-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container exceed-action {
        tailf:info "action when rate is within conform and conform + exceed burst";
        tailf:cli-flatten-container;
        leaf set-prec-transmit {
          tailf:info "rewrite packet precedence and send it";
          type prec_value-type;
        }
      }
    }

    choice exceed-set-qos-transmit-choice {
      container exceed-set-qos-transmit {
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        container exceed-action {
          tailf:info "action when rate is within conform and conform + exceed burst";
          tailf:cli-flatten-container;
          leaf set-qos-transmit {
            tailf:info "set qos-group and send it";
            type qos_value-type;
          }
        }
      }
      container exceed-set-qos-transmit-table {
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        container exceed-action {
          tailf:info "action when rate is within conform and conform + exceed burst";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf set-qos-transmit {
            tailf:info "set qos-group and send it";
            tailf:cli-incomplete-command;
            type cos_value-type;
          }
          leaf table {
            tailf:info "Specify table-map";
            tailf:non-strict-leafref {
              path "/ios:table-map/name";
            }
            type string {
              tailf:info "WORD;;table-map name";
            }
          }
        }
      }
    }

    container exceed-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container exceed-action {
        tailf:info "action when rate is within conform and conform + exceed burst";
        tailf:cli-flatten-container;
        uses police-action-transmit-grouping;
      }
    }

    container exceed-drop {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container exceed-action {
        tailf:info "action when rate is within conform and conform + exceed burst";
        tailf:cli-flatten-container;
        uses police-action-drop-grouping;
      }
    }
  }

  // Police multiple violate action grouping
  grouping police-multiple-violate-action-grouping {

    container violate-set-clp-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container violate-action {
        tailf:info "action when rate is greater than conform exceed burst";
        tailf:cli-flatten-container;
        leaf set-clp-transmit {
          tailf:info "set atm clp and send it";
          type empty;
        }
      }
    }

    container violate-set-cos-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container violate-action {
        tailf:info "action when rate is greater than conform + exceed burst";
        tailf:cli-flatten-container;
        leaf set-cos-transmit {
          tailf:info "rewrite packet cos and send it";
          type cos_value-type;
        }
      }
    }

    container violate-set-discard-class-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container violate-action {
        tailf:info "action when rate is greater than conform + exceed burst";
        tailf:cli-flatten-container;
        leaf set-discard-class-transmit {
          tailf:info "set discard-class and send it";
          type uint8 {
            tailf:info "<0-63>;;new discard-class";
            range "0..63";
          }
        }
      }
    }

    container violate-set-dscp-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container violate-action {
        tailf:info "action when rate is greater than conform + exceed burst";
        tailf:cli-flatten-container;
        leaf set-dscp-transmit {
          tailf:info "set dscp and send it";
          type dscp-type;
        }
      }
    }

    container violate-set-frde-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container violate-action {
        tailf:info "action when rate is greater than conform + exceed burst";
        tailf:cli-flatten-container;
        leaf set-frde-transmit {
          tailf:info "set FR DE and send it";
          type empty;
        }
      }
    }

    container violate-set-mpls-exp-imposition-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container violate-action {
        tailf:info "action when rate is greater than conform + exceed burst";
        tailf:cli-flatten-container;
        leaf set-mpls-exp-imposition-transmit {
          tailf:info "set exp at tag imposition and send it";
          type exp_value-type;
        }
      }
    }

    container violate-set-mpls-exp-topmost-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container violate-action {
        tailf:info "action when rate is greater than conform + exceed burst";
        tailf:cli-flatten-container;
        leaf set-mpls-exp-topmost-transmit {
          tailf:info "set exp on topmost label and send it";
          type exp_value-type;
        }
      }
    }

    container violate-set-prec-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container violate-action {
        tailf:info "action when rate is greater than conform + exceed burst";
        tailf:cli-flatten-container;
        leaf set-prec-transmit {
          tailf:info "rewrite packet precedence and send it";
          type prec_value-type;
        }
      }
    }

    container violate-set-qos-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container violate-action {
        tailf:info "action when rate is greater than conform + exceed burst";
        tailf:cli-flatten-container;
        leaf set-qos-transmit {
          tailf:info "set qos-group and send it";
          type qos_value-type;
        }
      }
    }

    container violate-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container violate-action {
        tailf:info "action when rate is greater than conform + exceed burst";
        tailf:cli-flatten-container;
        uses police-action-transmit-grouping;
      }
    }

    container violate-drop {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container violate-action {
        tailf:info "action when rate is greater than conform exceed burst";
        tailf:cli-flatten-container;
        uses police-action-drop-grouping;
      }
    }
  }


  // police-action-grouping
  grouping police-action-grouping {
    container actions {
      tailf:cli-break-sequence-commands;
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      // policy-map * / class * / police ? / conform-action
      uses police-multiple-conform-action-grouping;
      // policy-map * / class * / police ? / exceed-action
      uses police-multiple-exceed-action-grouping;
      // policy-map * / class * / police ? / violate-action
      uses police-multiple-violate-action-grouping;
    }
  }


  // policy-map * / class * /
  grouping policy-map-class-grouping {

    // policy-map * / class * / fragment
    leaf fragment {
      tailf:info "configure qos fragment class";
      tailf:cli-hide-in-submode;
      tailf:cli-diff-dependency "/ios:policy-map/class/service-fragment";
      type string {
        tailf:info "WORD;;class-map fragment name";
      }
    }

    // policy-map * / class * / service-fragment
    leaf service-fragment {
      tailf:info "configure qos service-fragment class";
      tailf:cli-hide-in-submode;
      type string {
        tailf:info "WORD;;class-map service-fragment name";
      }
    }

    // policy-map * / class * / flow monitor
    container flow {
      tailf:info "Flow subcommands";
      leaf monitor {
        tailf:info "Apply a Flow Monitor";
        tailf:non-strict-leafref {
          path "/ios:flow/monitor/name";
        }
        type string {
          tailf:info "WORD;;Flow Monitor name";
        }
      }
    }

    // policy-map * / class * / monitor metric
    container monitor {
      tailf:info "Monitor related parameters";
      container metric {
        tailf:info "Monitor metric";

        // policy-map * / class * / monitor metric rtp
        container rtp {
          tailf:info "RTP metrics parameters";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-pmap-c-mrtp";

          // policy-map * / class * / monitor metric rtp / clock-rate *
          list clock-rate {
            tailf:info "RTP timestamp field's sampling frequency";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key id;
            leaf id {
              type uint8 {
                tailf:info "<0-127>;;payload type number";
                range "0..127";
              }
            }
            leaf rate {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<1000-192000>;;frequency in Hz";
                range "1000..192000";
              }
            }
          }
        }
      }
    }

    // policy-map * / class * / react *
    list react {
      tailf:info "Configure threshold crossing actions";
      tailf:cli-mode-name "config-pmap-c-react";
      tailf:cli-incomplete-command;
      key id;
      leaf id {
        type uint16 {
          tailf:info "<1-65535>;;React instance id";
          range "1..65535";
        }
      }
      leaf type {
        tailf:cli-drop-node-name;
        tailf:cli-hide-in-submode;
        type enumeration {
          enum media-stop {
            tailf:info "Media stream stopped";
          }
          enum mrv {
            tailf:info "Variation in packet rate from configured expected rate";
          }
          enum network-delay {
            tailf:info "Network delay";
          }
          enum one-way-delay {
            tailf:info "One way delay for RTP stream";
          }
          enum rtp-jitter-average {
            tailf:info "Mean jitter for the RTP stream";
          }
          enum rtp-jitter-inter-arrival-mean {
            tailf:info "Mean inter-arrival jitter for the RTP stream";
          }
          enum transport-bytes-lost-rate {
            tailf:info "Ratio of lost bytes to total received bytes";
          }
          enum transport-packets-lost-rate {
            tailf:info "Ratio of lost packets to total reaceived packets";
          }
        }
      }

      // policy-map * / class * / monitor metric rtp / react * / threshold value
      container threshold {
        tailf:info "Config react threshold";
        container value {
          tailf:info "Range of percentage loss that would trigger the alarm";
          leaf ge {
            tailf:info "greater and equal to";
            type string {
              tailf:info "WORD;;rtp lost fraction threshold 0.05 - 100 (% in precision of 0.01)";
            }
          }
        }
      }

      // policy-map * / class * / monitor metric rtp / react * / action
      container action {
        tailf:info "Config react action";
        leaf syslog {
          tailf:info "The threshold-crossing event is logged to syslog";
          type empty;
        }
        leaf snmp {
          tailf:info "SNMP is notified of the event";
          type empty;
        }
      }
    }

    // policy-map * / class * / pass-through
    leaf pass-through {
      tailf:info "pass-through action";
      tailf:cli-full-command;
      type empty;
    }

    // policy-map * / class * / drop|inspect|pass
    container policy {
      tailf:cli-drop-node-name;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }

      // policy-map * / class * / drop
      // policy-map * / class * / pass
      // policy-map * / class * / inspect
      leaf action {
        tailf:cli-drop-node-name;
        tailf:cli-remove-before-change;
        type enumeration {
          enum drop {
            tailf:info "Drop the packet";
          }
          enum inspect {
            tailf:info "Context-based Access Control Engine";
          }
          enum pass {
            tailf:info "Pass the packet";
          }
        }
      }

      // policy-map * / class * / drop log
      // policy-map * / class * / pass log
      leaf log {
        when "(../action = 'drop') or (../action = 'pass')" {
          tailf:dependency "../action";
        }
        tailf:info "Send logging message for drop|pass";
        tailf:cli-optional-in-sequence;
        type empty;
      }

      // policy-map * / class * / inspect
      leaf parameter-map {
        tailf:cli-drop-node-name;
        when "../action = 'inspect'" {
          tailf:dependency "../action";
        }
        tailf:non-strict-leafref {
          path "/ios:parameter-map/type/inspect/name";
        }
        type string {
          tailf:info "WORD;;Parameter-map (inspect) name";
        }
      }
    }

    // policy-map * / class * / inspect-police
    container inspect-police {
      when "../policy/action = 'inspect'" {
        tailf:dependency "../policy/action";
      }
      tailf:cli-drop-node-name;
      container police {
        tailf:info "Police";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf rate {
          tailf:info "Specify police rate";
          type uint32 {
            tailf:info "<8000-2000000000>;;Rate value in bps";
            range "8000..2000000000";
          }
        }
        leaf burst {
          tailf:info "Specify 'burst' parameter";
          type uint32 {
            tailf:info "<1000-512000000>;;Burst value in bytes";
            range "1000..512000000";
          }
        }
      }
    }

    // policy-map * / class * / bandwidth
    container bandwidth {
      tailf:info "Bandwidth";

      // policy-map * / class * / bandwidth <bits>
      leaf bits {
        tailf:cli-drop-node-name;
        ios:ned-diff-minimize-value "/../..";
        type uint32 {
          tailf:info "<8-10000000>;;Kilo Bits per second";
          range "8..10000000";
        }
      }

      // policy-map * / class * / bandwidth percent
      leaf percent {
        tailf:info "% of total Bandwidth";
        ios:ned-diff-minimize-value "/../..";
        type percentage-type;
      }

      // policy-map * / class * / bandwidth remaining
      container remaining {
        tailf:info "% of the remaining bandwidth";

        // policy-map * / class * / bandwidth remaining percent
        container percent {
          tailf:info "% of the remaining bandwidth";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf percent {
            // dep: before this is created, change ratio
            tailf:cli-diff-dependency "../../ratio/ratio" {
              tailf:cli-trigger-on-set;
            }
            tailf:cli-drop-node-name;
            type percentage-type;
          }
          uses bandwidth-remaining-account-grouping;
        }

        // policy-map * / class * / bandwidth remaining ratio
        container ratio {
          tailf:info "ratio for sharing excess bandwidth";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf ratio {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-65536>;;Ratio";
              range "1..65536";
            }
          }
          uses bandwidth-remaining-account-grouping;
        }
      }
    }

    // policy-map * / class * / compress header ip
    container compress {
      tailf:info "Activate Compression";
      container header {
        tailf:info "configure header compression";
        container ip {
          tailf:info "configure ip header compression";
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          presence true;
          leaf protocol {
            tailf:cli-drop-node-name;
            type enumeration {
              enum rtp {
                tailf:info "configure rtp header compression";
              }
              enum tcp {
                tailf:info "configure tcp header compression";
              }
            }
          }
        }
      }
    }

    // policy-map * / class * / dbl
    leaf dbl {
      tailf:info "enable dynamic buffer limiting";
      tailf:cli-full-command;
      type empty;
    }

    // policy-map * / class * / estimate bandwidth
    container estimate {
      tailf:info "estimate resources required for this class";
      container bandwidth {
        tailf:info "bandwidth required to service this class";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        presence true;
        container delay-one-in {
          tailf:info "specify QoS target delay";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf doi {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint32 {
              range "50..1000000";
              tailf:info "<50-1000000>;;delay one packet of N";
            }
          }

          leaf milliseconds {
            type uint32 {
              range "8..1000" {
                tailf:info "<8-1000>;;worst-case milliseconds of delay";
              }
            }
          }
        }
        leaf drop-one-in {
          tailf:info "specify QoS target loss rate";
          type uint32 {
            tailf:info "<50-1000000>;;drop one packet of N";
          }
        }
      }
    }

    // policy-map * / class * / account
    leaf account {
      tailf:info "Account statistic";
      type empty;
    }

    // policy-map * / class * / fair-queue
    container fair-queue {
      tailf:info "Enable Flow-based Fair Queuing in this Class";
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      tailf:cli-display-separated;
      presence true;


      // policy-map * / class * / fair-queue ?
      leaf dynamic-queues {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        type uint32 {
          tailf:info "<16-4096>;;Number Dynamic Conversation Queues";
          range "16|32|64|128|256|512|1024|2048|4096";
        }
      }

      // policy-map * / class * / fair-queue queue-limit
      leaf queue-limit {
        tailf:info "per flow queue limit";
        tailf:cli-full-command;
        type uint32 {
          tailf:info "<1-2048000>;;packets";
          range "1..2048000";
        }
      }
    }

    // policy-map * / class * / netflow-sampler
    leaf netflow-sampler {
      tailf:info "NetFlow action";
      tailf:cli-full-command;
      type string {
        tailf:info "WORD;;Name of the flow sampler";
      }
    }

    // policy-map * / class * / police aggregate
    container police-aggregate {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      container police {
        tailf:info "Police";
        leaf aggregate {
          tailf:info "Choose aggregate policer for current class";
          tailf:cli-diff-dependency "/ios:qos/aggregate-policer";
          tailf:cli-diff-dependency "/ios:mls/qos/aggregate-policer";
          tailf:cli-diff-dependency "/ios:policer/aggregate";
          tailf:cli-diff-dependency "../../../police-policy-map/police/cir" {
            tailf:cli-trigger-on-set;
          }
          type string {
            tailf:info "WORD;;enter aggregate-policer name";
          }
        }
      }
    }

    // policy-map * / class * / police ?
    choice police-choice {

      // police "cirmode" - (policy map)
      // police cir <bps> [[bc <burst-normal>] [be <burst-max>]]
      //        [pir <bps> [be <burst-bytes>]] ACTIONS
      // NOTE: cir, bc & be keywords are mandatory in this model.
      //       Java code will add missing cir,bc and be in show().
      case police-cirmode-case {
        container police-policy-map {  //NEW: police-cirmode
          tailf:cli-no-keyword;
          tailf:cli-drop-node-name;
          container police {
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-pmap-c-police";
            tailf:cli-flatten-container;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            when "contains(/ios:tailfned/police, 'cirmode')";
            // cir <bps>
            leaf cir {
              tailf:info "Committed information rate";
              tailf:cli-hide-in-submode;
              tailf:cli-diff-set-after "../../../police-aggregate/police/aggregate";
              tailf:cli-diff-set-after "/ios:policy-map/class-default/class/shape";
              ios:ned-diff-minimize-value "/../../..";
              type police-bps-type;
            }
            // [bc <burst-normal>]
            leaf bc {
              tailf:info "Conform burst";
              tailf:cli-optional-in-sequence;
              tailf:cli-hide-in-submode;
              type police-burst-type;
            }
            // [be <burst-max>]
            leaf be {
              when "../bc" {
                tailf:dependency "../bc";
              }
              tailf:info "Excess burst";
              tailf:cli-optional-in-sequence;
              tailf:cli-hide-in-submode;
              type police-burst-type;
            }
            // [pir <bps> [be <burst-bytes>]]
            leaf pir {
              tailf:info "Peak Information Rate";
              tailf:cli-optional-in-sequence;
              tailf:cli-hide-in-submode;
              type police-bps-type;
            }
            container pir-be {
              when "../pir" {
                tailf:dependency "../pir";
              }
              tailf:cli-drop-node-name;
              tailf:cli-optional-in-sequence;
              tailf:cli-flatten-container;
              tailf:cli-hide-in-submode;
              leaf be {
                tailf:info "Excess burst";
                type police-burst-type;
              }
            }

            // account user-defined
            container account {
              tailf:info "Overhead Accounting";
              tailf:cli-optional-in-sequence;
              tailf:cli-flatten-container;
              tailf:cli-hide-in-submode;
              leaf user-defined {
                tailf:info "Offset Size";
                type int8 {
                  tailf:info "<-63 - 63>;;User Defined size";
                  range "-63..63";
                }
              }
            }

            // conform-action | exceed-action | violate-action
            uses police-action-grouping;

            // policy-map * / class * / police / conform-color
            container conform-color {
              tailf:info "conform color aware";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf class-map-name {
                tailf:cli-drop-node-name;
                tailf:non-strict-leafref {
                  path "/ios:class-map/name";
                }
                type string {
                  tailf:info "WORD;;class-map name for conform color aware";
                }
              }
              leaf exceed-color {
                tailf:info "exceed color aware";
                tailf:non-strict-leafref {
                  path "/ios:class-map/name";
                }
                type string {
                  tailf:info "WORD;;lass-map name for exceed color aware";
                }
              }
            }
          }
        }
      }

      // police cir percent (combo of percent & policy-map versions)
      // police cir percent <percentage>
      //    [bc] <burst> ms] [be [<burst> ms]
      //    [pir percent <percentage> [be <burst> ms]] / ACTIONS
      case police-cir-percent-case {
        container police-cir-percent {
          tailf:cli-no-keyword;
          tailf:cli-drop-node-name;
          container police {
            container cir {
              tailf:info "Committed information rate";
              container percent {
                tailf:info "% of interface bandwidth for Committed information rate";
                tailf:cli-add-mode;
                tailf:cli-mode-name "config-pmap-c-police";
                tailf:cli-incomplete-command;
                tailf:cli-flatten-container;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                when "not(contains(/ios:tailfned/police, 'cirflat'))";
                // percent <percentage>
                leaf percentage {
                  tailf:cli-drop-node-name;
                  tailf:cli-hide-in-submode;
                  type percentage-type;
                }
                // [bc <burst> ms]
                leaf bc {
                  tailf:info "Conform burst";
                  tailf:cli-optional-in-sequence;
                  tailf:cli-hide-in-submode;
                  type uint16 {
                    tailf:info "<1-2000>;;Burst ms";
                  }
                }
                container bc-ms {
                  when "../bc" {
                    tailf:dependency "../bc";
                  }
                  tailf:cli-drop-node-name;
                  tailf:cli-optional-in-sequence;
                  tailf:cli-hide-in-submode;
                  tailf:cli-flatten-container;
                  tailf:cli-compact-syntax;
                  leaf ms {
                    tailf:info "Milli seconds";
                    tailf:cli-no-keyword;
                    type empty;
                  }
                }
                // [be [<burst> ms]
                leaf be {
                  when "../bc-ms/ms" {
                    tailf:dependency "../bc-ms/ms";
                  }
                  tailf:info "Excess burst";
                  tailf:cli-optional-in-sequence;
                  tailf:cli-hide-in-submode;
                  type uint16 {
                    tailf:info "<1-2000>;;Burst ms";
                  }
                }
                container be-ms {
                  when "../be" {
                    tailf:dependency "../be";
                  }
                  tailf:cli-drop-node-name;
                  tailf:cli-hide-in-submode;
                  tailf:cli-flatten-container;
                  tailf:cli-compact-syntax;
                  leaf ms {
                    tailf:info "Milli seconds";
                    tailf:cli-no-keyword;
                    type empty;
                  }
                }
                // [pir percent <percentage> [be <burst> ms]]
                container pir {
                  tailf:info "Peak Information Rate";
                  tailf:cli-flatten-container;
                  tailf:cli-compact-syntax;
                  tailf:cli-hide-in-submode;
                  tailf:cli-optional-in-sequence;
                  leaf percent {
                    tailf:info "% of interface bandwidth for Peak Information Rate";
                    type percentage-type;
                  }
                }
                container pir-be {
                  when "../pir" {
                    tailf:dependency "../pir";
                  }
                  tailf:cli-drop-node-name;
                  tailf:cli-optional-in-sequence;
                  tailf:cli-flatten-container;
                  tailf:cli-hide-in-submode;
                  leaf be {
                    tailf:info "Excess burst";
                    type uint16 {
                      tailf:info "<1-2000>;;Burst ms";
                    }
                  }
                }
                container pir-be-ms {
                  when "../pir-be/be" {
                    tailf:dependency "../pir-be/be";
                  }
                  tailf:cli-drop-node-name;
                  tailf:cli-optional-in-sequence;
                  tailf:cli-hide-in-submode;
                  tailf:cli-flatten-container;
                  leaf ms {
                    tailf:info "Milli seconds";
                    tailf:cli-no-keyword;
                    type empty;
                  }
                }
                // conform-action | exceed-action | violate-action
                uses police-action-grouping;
              }
            }
          }
        }
      }

      // police cir percent <percentage> [options] ACTIONS
      case police-cirflat-percent-case {
        container police-cirflat-percent {
          tailf:cli-no-keyword;
          tailf:cli-drop-node-name;
          container police {
            container cir {
              tailf:info "Committed information rate";
              container percent {
                tailf:info "% of interface bandwidth for Committed information rate";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                tailf:cli-incomplete-command;
                when "contains(/ios:tailfned/police, 'cirflat')";
                // percent <percentage>
                leaf percentage {
                  tailf:cli-drop-node-name;
                  type percentage-type;
                }
                // [bc <burst> ms]
                leaf bc {
                  tailf:info "Conform burst";
                  tailf:cli-optional-in-sequence;
                  type uint16 {
                    tailf:info "<1-2000>;;Burst ms";
                  }
                }
                container bc-ms {
                  when "../bc" {
                    tailf:dependency "../bc";
                  }
                  tailf:cli-drop-node-name;
                  tailf:cli-optional-in-sequence;
                  tailf:cli-flatten-container;
                  tailf:cli-compact-syntax;
                  leaf ms {
                    tailf:info "Milli seconds";
                    tailf:cli-no-keyword;
                    type empty;
                  }
                }
                // [be [<burst> ms]
                leaf be {
                  when "../bc-ms/ms" {
                    tailf:dependency "../bc-ms/ms";
                  }
                  tailf:info "Excess burst";
                  tailf:cli-optional-in-sequence;
                  type uint16 {
                    tailf:info "<1-2000>;;Burst ms";
                  }
                }
                container be-ms {
                  when "../be" {
                    tailf:dependency "../be";
                  }
                  tailf:cli-drop-node-name;
                  tailf:cli-flatten-container;
                  tailf:cli-compact-syntax;
                  leaf ms {
                    tailf:info "Milli seconds";
                    tailf:cli-no-keyword;
                    type empty;
                  }
                }
                // [pir percent <percentage> [be <burst> ms]]
                container pir {
                  tailf:info "Peak Information Rate";
                  tailf:cli-flatten-container;
                  tailf:cli-compact-syntax;
                  tailf:cli-optional-in-sequence;
                  leaf percent {
                    tailf:info "% of interface bandwidth for Peak Information Rate";
                    type percentage-type;
                  }
                }
                container pir-be {
                  when "../pir" {
                    tailf:dependency "../pir";
                  }
                  tailf:cli-drop-node-name;
                  tailf:cli-optional-in-sequence;
                  tailf:cli-flatten-container;
                  leaf be {
                    tailf:info "Excess burst";
                    type uint16 {
                      tailf:info "<1-2000>;;Burst ms";
                    }
                  }
                }
                container pir-be-ms {
                  when "../pir-be/be" {
                    tailf:dependency "../pir-be/be";
                  }
                  tailf:cli-drop-node-name;
                  tailf:cli-optional-in-sequence;
                  tailf:cli-flatten-container;
                  leaf ms {
                    tailf:info "Milli seconds";
                    tailf:cli-no-keyword;
                    type empty;
                  }
                }
                // conform-action | exceed-action | violate-action
                uses police-action-grouping;
              }
            }
          }
        }
      }

      // police rate (control-plane)
      // police rate <units> <pps|bps> [burst <burst-in-x> [<packets|bytes>]]
      //   [peak-rate <peak-rate-in-xps> [<pps|bps>]]
      //   [peak-burst <peak-burst-in-x> [<packets|bytes>]]
      //   [conform-action <action>]
      case police-rate-unit-case {
        container police-rate-unit {
          tailf:cli-no-keyword;
          tailf:cli-drop-node-name;
          container police {
            container rate {
              tailf:info "Specify police rate";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-pmap-c-police";
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }

              // <units>
              leaf units {
                tailf:cli-drop-node-name;
                tailf:cli-hide-in-submode;
                type uint64 {
                  tailf:info "WORD;;Rate value in the range 7-10,000,000,000";
                }
              }
              // <pps|bps>
              leaf xps {
                tailf:cli-no-keyword;
                tailf:cli-drop-node-name;
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                type police-pps-bps-type;
              }

              leaf child-conform-aware {
                tailf:info "specify child-conform-aware";
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                type empty;
              }

              // [burst <burst-in-x> <packets|bytes>]
              leaf burst {
                tailf:info "Specify 'burst' parameter";
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                type uint32 {
                  tailf:info "<1-512000000>;;Burst value in packets/bytes";
                }
              }
              leaf burst-type {
                when "../burst" {
                  tailf:dependency "../burst";
                }
                tailf:cli-no-keyword;
                tailf:cli-drop-node-name;
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                type police-packets-bytes-type;
              }

              // [peak-rate <peak-rate-in-xps> <pps|bps>]
              leaf peak-rate {
                tailf:info "Specify peak rate";
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                type uint32 {
                  tailf:info "<1-512000000>;;Peak-rate value in packets or bytes per second";
                  range "1..512000000";
                }
              }
              leaf peak-rate-type {
                when "../peak-rate" {
                  tailf:dependency "../peak-rate";
                }
                tailf:cli-no-keyword;
                tailf:cli-drop-node-name;
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                type police-pps-bps-type;
              }

              // [peak-burst <peak-burst-in-x> <packets|bytes>]
              leaf peak-burst {
                tailf:info "Specify 'peak-burst' parameter for peak-rate";
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                type uint32 {
                  tailf:info "<1-512000000>;;Burst value in packets/bytes";
                }
              }
              leaf peak-burst-type {
                when "../peak-burst" {
                  tailf:dependency "../peak-burst";
                }
                tailf:cli-no-keyword;
                tailf:cli-drop-node-name;
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                type police-packets-bytes-type;
              }

              // conform-action | exceed-action | violate-action
              uses police-action-grouping;
            }
          }
        }
      }

      // police rate percent (control-plane)
      // police rate percent <percentage> [burst <ms> ms]
      //    [peak-rate percent <percentage>] [peak-burst <ms> ms]
      case police-rate-percent-case {
        container police-rate-percent {
          tailf:cli-no-keyword;
          tailf:cli-drop-node-name;
          container police {
            container rate {
              tailf:info "Specify police rate";
              container percent {
                tailf:info "% of interface bandwidth for rate";
                tailf:cli-add-mode;
                tailf:cli-mode-name "config-pmap-c-police";
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                // <percentage>
                leaf percentage {
                  tailf:cli-drop-node-name;
                  tailf:cli-hide-in-submode;
                  type percentage-type;
                }
                // [burst <ms> ms]
                leaf burst {
                  tailf:info "Specify 'burst' parameter";
                  tailf:cli-optional-in-sequence;
                  tailf:cli-hide-in-submode;
                  type uint16 {
                    tailf:info "<1-2000>;;Burst value in milliseconds";
                  }
                }
                leaf ms {
                  when "../burst" {
                    tailf:dependency "../burst";
                  }
                  tailf:info "Treat 'burst' value in milliseconds";
                  tailf:cli-hide-in-submode;
                  type empty;
                }
                // [peak-rate percent <percentage>]
                container peak-rate {
                  tailf:info "Specify peak rate";
                  tailf:cli-hide-in-submode;
                  tailf:cli-optional-in-sequence;
                  tailf:cli-flatten-container;
                  leaf percent {
                    tailf:info "% of interface bandwidth for peak-rate";
                    type percentage-type;
                  }
                }
                // [peak-burst <ms> ms]
                leaf peak-burst {
                  tailf:info "Specify 'peak-burst' parameter for 'peak-rate'";
                  tailf:cli-hide-in-submode;
                  tailf:cli-optional-in-sequence;
                  type uint16 {
                    tailf:info "<1-2000>;;Peak burst value in milliseconds";
                  }
                }
                container peak-burst-ms {
                  when "../peak-burst" {
                    tailf:dependency "../peak-burst";
                  }
                  tailf:cli-drop-node-name;
                  tailf:cli-optional-in-sequence;
                  tailf:cli-hide-in-submode;
                  tailf:cli-flatten-container;
                  leaf ms {
                    tailf:info "Milli seconds";
                    tailf:cli-no-keyword;
                    type empty;
                  }
                }
                // conform-action | exceed-action | violate-action
                uses police-action-grouping;
              }
            }
          }
        }
      }

      // police rate pdp
      // police rate pdp [burst <bytes>]
      //    [peak-rate pdp [peak-burst <bytes>]] ACTIONS
      case police-rate-pdp-case {
        container police-rate-pdp {
          tailf:cli-no-keyword;
          tailf:cli-drop-node-name;
          container police {
            container rate {
              tailf:info "Specify police rate";
              container pdp {
                tailf:info "% of interface bandwidth for rate";
                tailf:cli-add-mode;
                tailf:cli-mode-name "config-pmap-c-police";
                tailf:cli-flatten-container;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                // [burst <bytes>]
                leaf burst {
                  tailf:info "Conform burst";
                  tailf:cli-hide-in-submode;
                  tailf:cli-optional-in-sequence;
                  type police-burst-type;
                }
                // [peak-rate pdp [peak-burst <bytes>]]
                leaf peak-rate {
                  tailf:info "Specify peak rate";
                  tailf:cli-hide-in-submode;
                  tailf:cli-optional-in-sequence;
                  type enumeration {
                    enum "pdp" {
                    }
                  }
                }
                leaf peak-burst {
                  when "../peak-rate" {
                    tailf:dependency "../peak-rate";
                  }
                  tailf:info "Specify 'peak-burst' parameter for 'peak-rate'";
                  tailf:cli-hide-in-submode;
                  tailf:cli-optional-in-sequence;
                  type police-burst-type;
                }
                // conform-action | exceed-action | violate-action
                uses police-action-grouping;
              }
            }
          }
        }
      }

      // policy-map * / class * / police flow
      // police flow [mask {dest-only | full-flow | src-only}]
      //    <bps> [<burst-normal>] ACTIONS
      case police-flow-case {
        container police-flow {
          tailf:cli-no-keyword;
          tailf:cli-drop-node-name;
          container police {
            container flow {
              tailf:info "police each flow";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-pmap-c-police";
              tailf:cli-flatten-container;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              // [mask {dest-only | full-flow | src-only}]
              leaf mask {
                tailf:info "flow mask to be used for policing";
                tailf:cli-hide-in-submode;
                tailf:cli-optional-in-sequence;
                type enumeration {
                  enum dest-only {
                    tailf:info "destination-address only flow mask";
                  }
                  enum full-flow {
                    tailf:info "full flow mask";
                  }
                  enum src-only {
                    tailf:info "source-address only flow mask";
                  }
                }
              }
              // <bps>
              leaf bps {
                tailf:cli-drop-node-name;
                tailf:cli-hide-in-submode;
                type police-bps-type;
              }
              // [<burst-normal>]
              leaf burst-normal {
                when "../bps" {
                  tailf:dependency "../bps";
                }
                tailf:cli-drop-node-name;
                tailf:cli-hide-in-submode;
                tailf:cli-optional-in-sequence;
                type police-burst-type;
              }
              // conform-action | exceed-action | violate-action
              uses police-action-grouping;
            }
          }
        }
      }

      // police "bpsflat" - (Catalyst 4500)
      // police <bps> bps <byte> byte ACTIONS
      case police-bpsflat-case {
        container police-catalyst { // NEW: police-bpsflat
          tailf:cli-no-keyword;
          tailf:cli-drop-node-name;
          container police {
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-pmap-c-police";
            tailf:cli-flatten-container;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            when "contains(/ios:tailfned/police, 'bpsflat')";
            // <bps> bps
            leaf bps-value {
              tailf:cli-no-keyword;
              tailf:cli-drop-node-name;
              tailf:cli-hide-in-submode;
              tailf:cli-incomplete-command;
              type string {
                tailf:info "<32000-32000000000>;;Rate in bits per second (postfix k, m, g optional; decimal point allowed)";
              }
            }
            choice bps-type-choice {
              leaf bps {
                tailf:cli-hide-in-submode;
                tailf:cli-optional-in-sequence;
                tailf:cli-incomplete-command;
                type empty;
              }
              leaf kbps {
                tailf:cli-hide-in-submode;
                tailf:cli-optional-in-sequence;
                tailf:cli-incomplete-command;
                type empty;
              }
              leaf mbps {
                tailf:cli-hide-in-submode;
                tailf:cli-optional-in-sequence;
                tailf:cli-incomplete-command;
                type empty;
              }
              leaf gbps {
                tailf:cli-hide-in-submode;
                tailf:cli-incomplete-command;
                type empty;
              }
            }
            // <byte> byte
            leaf byte-value {
              tailf:cli-no-keyword;
              tailf:cli-drop-node-name;
              tailf:cli-hide-in-submode;
              tailf:cli-incomplete-command;
              type string {
                tailf:info "<32000-32000000000>;;(postfix k, m, g optional; decimal point allowed)";
              }
            }
            choice byte-type-choice {
              leaf byte {
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                type empty;
              }
              leaf kbyte {
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                type empty;
              }
              leaf mbyte {
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                type empty;
              }
              leaf gbyte {
                tailf:cli-hide-in-submode;
                type empty;
              }
            }
            // conform-action | exceed-action | violate-action
            container actions {
              tailf:cli-break-sequence-commands;
              tailf:cli-no-keyword;
              tailf:cli-drop-node-name;
              tailf:cli-flatten-container;
              tailf:cli-hide-in-submode;
              // policy-map * / class * / police ? / conform-action
              uses police-multiple-conform-action-grouping;
              // policy-map * / class * / police ? / exceed-action
              uses police-multiple-exceed-action-grouping;
              // policy-map * / class * / police ? / violate-action
              uses police-multiple-violate-action-grouping;
            }
          }
        }
      }

      // police switch "numflat" - (Catalyst c3550)
      // police <bps> <burst> exceed-action {drop | policed-dscp-transmit}]
      case police-switch-case {
        container police-switch {
          tailf:cli-no-keyword;
          tailf:cli-drop-node-name;
          container police {
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            when "contains(/ios:tailfned/police, 'numflat')";
            // <bps = cir>
            leaf cir {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              tailf:cli-diff-dependency "../../../police-aggregate/police/aggregate" {
                tailf:cli-trigger-on-set;
              }
              type uint32 {
                tailf:info "<8000-1000000000>;;Bits per second";
                range "8000..1000000000";
              }
            }
            // <burst = bc>
            leaf bc {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<8000-2000000>;;Normal burst bytes";
                range "8000..2000000";
              }
            }
            // exceed-action
            leaf exceed-action {
              tailf:info "action when rate is exceeded";
              type enumeration {
                enum drop {
                  tailf:info "drop packet";
                }
                enum policed-dscp-transmit {
                  tailf:info "change dscp per policed-dscp map and send it";
                }
              }
            }
          }
        }
      }

      // police "numflat"
      // police <bps> [burst-normal] [burst-max] ACTIONS
      case police-numflat-case {
        container police-numflat {
          tailf:cli-no-keyword;
          tailf:cli-drop-node-name;
          container police {
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            when "contains(/ios:tailfned/police, 'numflat')";
            // <bps> (cir)
            leaf cir {
              tailf:cli-drop-node-name;
              tailf:cli-diff-dependency "../../../police-aggregate/police/aggregate" {
                tailf:cli-trigger-on-set;
              }
              type police-bps-type;
            }
            // <bc> (burst-normal)
            leaf bc {
              tailf:cli-drop-node-name;
              tailf:cli-optional-in-sequence;
              type police-burst-type;
            }
            // <be> (burst-max)
            leaf be {
              tailf:cli-drop-node-name;
              tailf:cli-optional-in-sequence;
              type police-burst-type;
            }
            // conform-action | exceed-action | violate-action
            container actions {
              tailf:cli-break-sequence-commands;
              tailf:cli-no-keyword;
              tailf:cli-drop-node-name;
              tailf:cli-flatten-container;
              // policy-map * / class * / police ? / conform-action
              uses police-multiple-conform-action-grouping;
              // policy-map * / class * / police ? / exceed-action
              uses police-multiple-exceed-action-grouping;
              // policy-map * / class * / police ? / violate-action
              uses police-multiple-violate-action-grouping;
            }
          }
        }
      }

      // police "cirflat" - (Catalyst C3750, C6504)
      // police cir <bps> bc <burst-normal> [pir <bps>] [be <burst-max] ACTIONS
      case police-cirflat-case {
        container police-cirflat {
          tailf:cli-no-keyword;
          tailf:cli-drop-node-name;
          container police {
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            when "contains(/ios:tailfned/police, 'cirflat')";
            // cir <bps>
            leaf cir {
              tailf:info "Committed information rate";
              tailf:cli-diff-dependency "../../../police-aggregate/police/aggregate" {
                tailf:cli-trigger-on-set;
              }
              type police-bps-type;
            }
            // bc <burst-normal>
            leaf bc {
              tailf:info "Conform burst";
              tailf:cli-optional-in-sequence;
              type police-burst-type;
            }
            // [pir <bps>]
            leaf pir {
              tailf:info "Peak Information Rate";
              tailf:cli-optional-in-sequence;
              type police-bps-type;
            }
            // [be> <burst-max>]
            leaf be {
              tailf:info "Excess burst";
              tailf:cli-optional-in-sequence;
              type police-burst-type;
            }
            // conform-action | exceed-action | violate-action
            container actions {
              tailf:cli-break-sequence-commands;
              tailf:cli-drop-node-name;
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              uses police-conform-action-grouping;
              uses police-exceed-action-grouping;
              uses police-violate-action-grouping;
            }
          }
        }
      }
    }

    // policy-map * / class * / priority
    container priority {
      tailf:info "Strict Scheduling Priority for this Class";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-delete-when-empty;
      ios:remove-before-populate "priority :: 2";
      presence true;
      leaf level {
        tailf:info "Multi-Level Priority Queue";
        tailf:cli-optional-in-sequence;
        type uint8 {
          tailf:info "<1-2>;;Multi-Level Priority Queue";
          range "1..2";
        }
      }
      choice priority-type {
        leaf kilo-bits {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<8-10000000>;;Kilo Bits per second";
            range "8..10000000";
          }
        }
        // policy-map * / class * / priority percent
        leaf percent {
          tailf:info "% of total bandwidth";
          ios:ned-diff-minimize-value "/../..";
          type uint16 {
            tailf:info "<1-100>;;percentage";
            range "1..100";
          }
        }
      }
      leaf burst {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<32-64000000>;;Burst in bytes";
          range "32..64000000";
        }
      }
    }

    // policy-map * / class * / shape
    container shape {
      tailf:info "Traffic Shaping";

      // policy-map * / class * / shape adaptive
      leaf adaptive {
        tailf:info "Enable Traffic Shaping adaptation to BECN";
        tailf:cli-full-command;
        type uint32 {
          tailf:info "<8000-154400000>;;Lower Bound Target Bit Rate (bits per second)";
          range "8000..154400000";
        }
      }

      // policy-map * / class * / shape average
      choice shape-average-peak {
        container average {
          tailf:info "configure token bucket: CIR (bps) [Bc (bits) [Be (bits)]], send out Bc only per interval";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          choice average-choice {
            case a {
              leaf bit-rate {
                tailf:cli-drop-node-name;
                cli:ned-diff-move-first {
                  cli:arguments "when-higher|parents=2";
                }
                cli:ned-diff-move-last {
                  cli:arguments "when-lower|parents=2";
                }
                type uint64 {
                  tailf:info "<8000-max>;;Target Bit Rate (bits per second), the value needs to be a multiple of 8000";
                }
              }
              leaf bits-per-interval-sustained {
                tailf:cli-drop-node-name;
                tailf:cli-optional-in-sequence;
                type uint32 {
                  tailf:info "<4-15440000>;;bits per interval, sustained. Recommend not to configure it, the algorithm will find out the best value";
                  range "4..154400000";
                }
              }
              leaf bits-per-interval-excess {
                tailf:cli-drop-node-name;
                tailf:cli-optional-in-sequence;
                type uint32 {
                  tailf:info "<0-154400000>;;bits per interval, excess. Bc will be used if you don't configure it";
                  range "0..154400000";
                }
              }
              leaf account {
                tailf:info "Overhead Accounting";
                tailf:cli-incomplete-command;
                type empty;
              }
              leaf user-defined {
                tailf:info "Offset Size";
                type int8 {
                  tailf:info "<-63 - 63>;;User Defined size";
                  range "-63..63";
                }
              }
              leaf atm {
                tailf:info "ATM cell tax";
                type empty;
              }
            }

            // policy-map * / class * / shape average percent
            case b {
              leaf percent {
                tailf:info "% of interface bandwidth for Committed information rate";
                type percentage-type;
              }
              leaf burst-size-sustained {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type uint16 {
                  tailf:info "<10-2000>;;Sustained burst size in msec";
                  range "10..2000";
                }
              }
              leaf ms {
                tailf:info "milliseconds";
                type empty;
              }
              container bse {
                tailf:cli-drop-node-name;
                tailf:cli-flatten-container;
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands;
                leaf burst-size-excess {
                  tailf:cli-incomplete-command;
                  type uint16 {
                    tailf:info "<10-2000>;;Excess burst size in msec";
                    range "10..2000";
                  }
                }
                leaf ms {
                  tailf:info "milliseconds";
                  type empty;
                }
              }
            }
          }
        }

        // policy-map * / class * / shape peak
        container peak {
          tailf:info "configure token bucket: CIR (bps) [Bc (bits) [Be (bits)]], send out Bc+Be per interval";
          choice peak-choice {
            case a {
              leaf bit-rate {
                tailf:cli-drop-node-name;
                cli:ned-diff-move-first {
                  cli:arguments "when-higher|parents=2";
                }
                cli:ned-diff-move-last {
                  cli:arguments "when-lower|when-delete|parents=2";
                }
                type uint64 {
                  tailf:info "<8000-40000000000>;;Target Bit Rate (bits/sec). (postfix k, m, g optional; decimal point allowed)";
                }
              }
            }
            leaf percent {
              tailf:info "% of interface bandwidth for Committed information rate";
              type uint8 {
                tailf:info "<1-100>;;percentage";
                range "1..100";
              }
            }
          }
        }
      }

      // policy-map * / class * / shape fecn-adapt
      leaf fecn-adapt {
        tailf:info "Enable Traffic Shaping reflection of FECN as BECN";
        tailf:cli-full-command;
        type empty;
      }

      // policy-map * / class * / shape fr-voice-adapt
      container fr-voice-adapt {
        tailf:info "Enable rate adjustment depending on voice presence";
        presence true;
        leaf deactivation {
          type uint16 {
            range "1..10000";
            tailf:info "<1-10000>;;de-activation delay in seconds";
          }
        }
      }

      // policy-map * / class * / shape max-buffers
      leaf max-buffers {
        tailf:cli-full-command;
        tailf:info "Set Maximum Buffer Limit";
        type uint16 {
          tailf:info "<1-4096>;;Maximum Buffer Limit";
          range "1..4096";
        }
      }
    }

    // policy-map * / class * / queue-buffers ratio
    container queue-buffers {
      tailf:info "queue buffer";
      tailf:cli-diff-dependency "../bandwidth";
      tailf:cli-diff-dependency "../priority";
      tailf:cli-diff-dependency "../shape";
      leaf ratio {
        tailf:info "Relative buffer size for queue";
        type uint16 {
          tailf:info "<0-100>;;Queue-buffers ratio limit";
          range "0..100";
        }
      }
    }

    // policy-map * / class * / random-detect
    container random-detect {
      tailf:info "Enable Random Early Detection as drop policy";
      tailf:cli-diff-dependency "../bandwidth";
      tailf:cli-diff-dependency "../shape";

      // policy-map * / class * / random-detect precedence-based  <= hidden!
      // policy-map * / class * / random-detect cos-based
      // policy-map * / class * / random-detect dscp-based
      // policy-map * / class * / random-detect discard-class-based
      // policy-map * / class * / random-detect * aggregate
      container base {
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf type {
          tailf:cli-drop-node-name;
          tailf:cli-remove-before-change;
          tailf:cli-diff-dependency "../../../bandwidth/percent";
          type enumeration {
            enum cos-based {
              tailf:info "Enable cos-class-based WRED as drop policy";
            }
            enum precedence-based {
              tailf:info "Enable precedence-based WRED as drop policy";
            }
            enum discard-class-based {
              tailf:info "Enable discard-class-based WRED as drop policy";
            }
            enum dscp-based {
              tailf:info "Enable dscp-based WRED as drop policy";
            }
          }
        }
        leaf aggregate {
          tailf:info "aggregate subclasses";
          type empty;
        }
        leaf minimum-thresh {
          tailf:info "minimum threshold for red aggregate";
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<0-1000000>;;minimum threshold (number of packets)";
            range "0..1000000";
          }
        }
        leaf maximum-thresh {
          tailf:info "maximum threshold for red aggregate";
          type uint32 {
            tailf:info "<0-1000000>;;maximum threshold (number of packets)";
            range "0..1000000";
          }
        }
        leaf mark-probability {
          tailf:alt-name mark-prob;
          tailf:info "mark-probability for red aggregate";
          type empty;
        }
        leaf denominator {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<0-65535>;;mark probability denominator";
            range "0..65535";
          }
        }
      }

      // policy-map * / class * / random-detect exponential-weighting-constant
      leaf exponential-weighting-constant {
        tailf:info "weight for mean queue depth calculation";
        tailf:cli-full-command;
        tailf:cli-diff-dependency "../base/type";
        type uint16 {
          tailf:info "<1-16>;;integer in 1..16 used in weighted average to mean 2^number";
          range "1..16";
        }
      }

      // policy-map * / class * / random-detect ecn
      leaf ecn {
        tailf:info "explicit congestion notification";
        tailf:cli-full-command;
        type empty;
      }

      // policy-map * / class * / random-detect cos *
      list cos {
        when "../base/type = 'cos-based'" {
          tailf:dependency "../base/type";
        }
        tailf:info "parameters for each cos value";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        tailf:cli-diff-dependency "../base/type";
        key cos;
        leaf cos {
          type uint8 {
            tailf:info "<0-7>;;cos value";
            range "0..7";
          }
        }
        uses random-detect-grouping;
      }

      // policy-map * / class * / random-detect precedence *
      list precedence {
        when "../base/type = 'precedence-based'" {
          tailf:dependency "../base/type";
        }
        tailf:info "parameters for each precedence value";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        tailf:cli-diff-dependency "../base/type";
        key prec;
        leaf prec {
          type union {
            type uint8 {
              tailf:info "<0-7>;;IP precedence";
              range "0..7";
            }
            type enumeration {
              enum rsvp {
                tailf:info "rsvp traffic";
              }
            }
          }
        }
        uses random-detect-grouping;
      }

      // policy-map * / class * / random-detect precedence values *
      container precedence-values {
        tailf:cli-drop-node-name;
        list precedence {
          tailf:info "parameters for each precedence value";
          when "../../base/type = 'precedence-based'" {
            tailf:dependency "../../base/type";
          }
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-incomplete-command;
          tailf:cli-diff-dependency "../../base/type";
          key values;
          leaf values {
            tailf:info "multiple precedence subclasses";
            tailf:cli-expose-key-name;
            type uint8 {
              tailf:info "<0-7>;;SUBCLASS id";
              range "0..7";
            }
          }
          uses random-detect-values-grouping;
        }
      }

      // policy-map * / class * / random-detect discard-class *
      list discard-class {
        when "../base/type = 'discard-class-based'" {
          tailf:dependency "../base/type";
        }
        tailf:info "parameters for each discard-class value";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        tailf:cli-diff-dependency "../base/type";
        key dclass;
        leaf dclass {
          type uint16 {
            tailf:info "<0-7>;;discard-class value";
            range "0..7";
          }
        }
        uses random-detect-grouping;
      }

      // policy-map * / class * / random-detect dscp *
      list dscp {
        when "../base/type = 'dscp-based'" {
          tailf:dependency "../base/type";
        }
        tailf:info "parameters for each dscp value";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        tailf:cli-diff-dependency "../base/type";
        key dscpvalue;
        leaf dscpvalue {
          type dscp-type;
        }
        uses random-detect-grouping;
      }

      // policy-map * / class * / random-detect dscp values *
      container dscp-values {
        tailf:cli-drop-node-name;
        list dscp {
          tailf:info "parameters for each dscp value";
          when "../../base/type = 'dscp-based'" {
            tailf:dependency "../../base/type";
          }
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-incomplete-command;
          tailf:cli-diff-dependency "../../base/type";
          key values;
          leaf values {
            tailf:info "multiple dscp subclasses";
            tailf:cli-expose-key-name;
            type dscp-type;
          }
          uses random-detect-values-grouping;
        }
      }
    }

    // policy-map * / class * / queue-limit
    container queue-limit {
      tailf:info "Queue Max Threshold for Tail Drop";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-diff-dependency "../shape";
      tailf:cli-diff-dependency "../bandwidth";

      // policy-map * / class * / queue-limit percent
      container percent {
        tailf:info "% of threshold";
        tailf:cli-optional-in-sequence;
        leaf value {
          tailf:cli-drop-node-name;
          type percentage-type;
        }
      }

      // policy-map * / class * / queue-limit ?
      leaf queue-limit-value {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        tailf:cli-diff-delete-before "../percent";
        cli:ned-diff-move-before ">random-detect " {
          cli:arguments "when-higher :: default=64000000";
        }
        type uint32 {
          tailf:info "<1-64000000>;;in bytes, <1-3400> in ms, <1-8192000> in packets by default";
          range "1..64000000";
        }
      }
      leaf queue-limit-type {
        when "../queue-limit-value";
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        tailf:cli-full-command;
        tailf:cli-diff-delete-before "../percent";
        type enumeration {
          enum bytes {
            tailf:info "in bytes";
          }
          enum ms {
            tailf:info "in milliseconds";
          }
          enum us {
            tailf:info "in microseconds";
          }
          enum packets {
            tailf:info "in packets";
          }
        }
      }

      // policy-map * / class * / queue-limit dscp *
      list dscp {
        tailf:info "parameters for each dscp value";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key dscp;
        leaf dscp {
          type dscp-type;
        }
        leaf percent {
          tailf:info "% of threshold";
          type percentage-type;
        }
        container absolute {
          tailf:cli-drop-node-name;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf value {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            tailf:cli-diff-delete-before "../../percent";
            type uint32 {
              tailf:info "<1-64000000>;;in bytes, <1-3400> in ms, <1-8192000> in packets by default";
              range "1..64000000";
            }
          }
          leaf type {
            tailf:cli-drop-node-name;
            type enumeration {
              enum bytes {
                tailf:info "in bytes";
              }
              enum ms {
                tailf:info "in milliseconds";
              }
              enum us {
                tailf:info "in microseconds";
              }
              enum packets {
                tailf:info "in packets";
              }
            }
          }
        }
      }
    }

    // policy-map * / class * / set
    container set {
      tailf:info "Set QoS values";

      // policy-map * / class * / set atm-clp
      leaf atm-clp {
        tailf:info "Set ATM CLP bit to 1";
        tailf:cli-full-command;
        type empty;
      }

      // policy-map * / class * / set cos
      container cos {
        tailf:info "Set IEEE 802.1Q/ISL class of service/user priority";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        choice cos-type {
          case a {
            leaf val {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<0-7>;;cos value";
                range "0..7";
              }
            }
          }
          case b {
            leaf pack {
              tailf:cli-drop-node-name;
              type enumeration {
                enum dscp {
                  tailf:info "Set value from packet dscp";
                  tailf:code-name "pack_dscp";
                }
                enum precedence {
                  tailf:info "Set value from packet precedence.";
                  tailf:code-name "pack_precedence";
                }
                enum cos {
                  tailf:info "Set value from class of service/user priority";
                }
                enum qos-group {
                  tailf:info "Set value from QoS Group.";
                }
              }
            }
            leaf table {
              tailf:info "Set codepoint value based on tablemap.";
              tailf:non-strict-leafref {
                path "/ios:table-map/name";
              }
              type string {
                tailf:info "WORD;;table-map name";
              }
            }
          }
        }
      }

      // policy-map * / class * / set cos-inner
      container cos-inner {
        tailf:info "Set Inner CoS";
        leaf val {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-7>;;cos value";
            range "0..7";
          }
        }
      }

      // policy-map * / class * / set discard-class
      leaf discard-class {
        tailf:info "Discard behavior identifier";
        tailf:cli-full-command;
        type uint16 {
          range "0..7";
          tailf:info "<0-7>;;Discard Class value";
        }
      }

      // policy-map * / class * / set dscp
      container dscp {
        tailf:info "Set DSCP in IP(v4) and IPv6 packets";

        // policy-map * / class * / set dscp tunnel
        leaf tunnel {
          tailf:info "set tunnel packet dscp";
          tailf:cli-full-command;
          type dscp-type;
        }

        // policy-map * / class * / set dscp
        choice dscp-choice {
          leaf value {
            tailf:cli-drop-node-name;
            tailf:cli-full-command;
            type dscp-type;
          }
          // policy-map * / class * / set dscp dscp table
          container dscp {
            tailf:info "Set packet dscp from dscp";
            tailf:cli-incomplete-command;
            tailf:cli-incomplete-no;
            leaf table {
              tailf:info "Set packet dscp from dscp based on table map.";
              tailf:non-strict-leafref {
                path "/ios:table-map/name";
              }
              type string {
                tailf:info "WORD;;table-map name";
              }
            }
          }
        }
      }

      // policy-map * / class * / set fr-de
      leaf fr-de {
        tailf:info "Set FR DE bit to 1";
        tailf:cli-full-command;
        type empty;
      }

      // policy-map * / class * / set ip
      container ip {
        tailf:info "Set IP specific values";
        choice ip-choice {
          leaf dscp {
            tailf:info "Set IP DSCP (DiffServ CodePointint)";
            type dscp-type;
          }
          container precedence {
            tailf:info "Set IP precedence";
            presence "Set IP precedence";
            leaf precedence-val {
              tailf:cli-drop-node-name;
              type precedence-type;
            }
          }
        }
      }

      // policy-map * / class * / set mpls experimental
      container mpls {
        tailf:info "Set MPLS specific values";
        container experimental {
          tailf:info "Set Experimental value";

          // policy-map * / class * / set mpls experimental
          leaf exp-value {
            tailf:cli-drop-node-name;
            tailf:cli-full-command;
            type uint8 {
              tailf:info "<0-7>;;Experimental value";
              range "0..7";
            }
          }

          // policy-map * / class * / set mpls experimental imposition
          container imposition {
            tailf:info "Set Experimental value at tag imposition";
            leaf exp-value {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<0-7>;;Experimental value";
                range "0..7";
              }
            }
          }

          // policy-map * / class * / set mpls experimental topmost
          container topmost {
            tailf:info "Set Experimental value on topmost label";
            choice topmost-choice {
              leaf exp-value {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<0-7>;;Experimental value";
                  range "0..7";
                }
              }
              // policy-map * / class * / set mpls experimental topmost qos-group
              container qos-group {
                tailf:info "Set packet mpls exp topmost from QoS Group.";
                tailf:cli-reset-container;
                tailf:cli-delete-when-empty;
                presence true;
                leaf table {
                  tailf:info "Set packet mpls exp topmost from QoS Group based on table map.";
                  tailf:non-strict-leafref {
                    path "/ios:table-map/name";
                  }
                  type string {
                    tailf:info "WORD;;table-map name";
                  }
                }
              }
            }
          }
        }
      }

      // policy-map * / class * / set qos-group
      container qos-group {
        tailf:info "Set QoS Group";
        leaf qos-group-value {
          tailf:cli-drop-node-name;
          tailf:cli-full-command;
          type uint8 {
            range "0..99";
          }
        }
      }

      // policy-map * / class * / set precedence
      container precedence {
        tailf:info "Set precedence in IP(v4) and IPv6 packets";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        choice precedence-choice {
          case precedence-value {
            leaf precedence-value {
              tailf:cli-drop-node-name;
              tailf:cli-no-keyword;
              type precedence-type;
            }
          }
          case precedence-from-field {
            leaf from-field {
              tailf:cli-drop-node-name;
              tailf:cli-no-keyword;
              type enumeration {
                enum cos {
                  tailf:info "Set packet precedence from L2 COS";
                }
                enum qos-group {
                  tailf:info "Set packet precedence from QoS Group.";
                }
              }
            }
            leaf table {
              tailf:info "Set packet precedence based on table map.";
              tailf:non-strict-leafref {
                path "/ios:table-map/name";
              }
              type string {
                tailf:info "WORD;;table-map name";
              }
            }
          }
        }
      }
    }

    // policy-map * / class * / service-policy
    leaf service-policy {
      tailf:info "Configure QoS Service Policy";
      tailf:cli-remove-before-change;
      tailf:cli-full-command;
      tailf:cli-diff-dependency "../bandwidth/percent";
      // NOTE: using ../bandwith diff-dep here caused dependencies to break
      tailf:non-strict-leafref {
        path "/ios:policy-map/name";
      }
      type string {
        tailf:info "WORD;;policy-map name";
      }
    }

    // policy-map * / class * / trust
    leaf trust {
      tailf:info "Set trust value for the class";
      type enumeration {
        enum cos {
          tailf:info "trust value for the class";
        }
        enum dscp {
          tailf:info "trust value for the class";
        }
        enum ip-precedence {
          tailf:info "trust value for the class";
        }
      }
    }

    // policy-map * / class * / distribute service-node-group *
    container distribute {
      tailf:info "Distribute action";
      list service-node-group {
        tailf:info "Distribute to service-node-group";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        max-elements 2;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;service-node-group name";
          }
        }
      }
    }

    // policy-map * / class * / monitor-load
    leaf monitor-load {
      tailf:info "Monitor AO";
      tailf:cli-full-command;
      type enumeration {
        enum MS-port-mapper {
          tailf:info "Monitor Microsoft Endpoint Port Mapper load";
        }
        enum cifs {
          tailf:info "Monitor CIFS Accelerator load";
        }
        enum http {
          tailf:info "Monitor HTTP Accelerator load";
        }
        enum ica {
          tailf:info "Monitor ICA Accelerator load";
        }
        enum mapi {
          tailf:info "Monitor MAPI Accelerator load";
        }
        enum nfs {
          tailf:info "Monitor NFS Accelerator load";
        }
        enum ssl {
          tailf:info "Monitor SSL accelerator load";
        }
        enum video {
          tailf:info "Monitor Video Accelerator load";
        }
        enum ice {
        }
      }
    }
  }

  grouping policy-map-type-control-class-grouping {

    // policy-map type control * / class type control * event / *
    list action {
      tailf:cli-break-sequence-commands;
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key id;
      leaf id {
        type uint8 {
          tailf:info "<1-254>;;action number, 1 for 1st action to perform, 2 for 2nd...";
          range "1..254";
        }
      }

      // policy-map type control * / class type control * event / * service
      container service {
        tailf:info "Specify a service to apply to the user";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf action {
          tailf:cli-drop-node-name;
          type enumeration {
            enum deny {
              tailf:info "Deny access if connected. Disconnect session if not";
            }
            enum disconnect {
              tailf:info "Disconnect the session";
            }
            enum local {
              tailf:info "Locally terminate the session";
            }
            enum permit {
              tailf:info "Permit access if connected. Local termination if not";
            }
          }
        }
        leaf delay {
          type uint32;
        }
      }

      // policy-map type control * / class type control * event / * service-policy
      container service-policy {
        tailf:info "apply and unapply";

        // policy-map type control * / class type control * event / * service-policy type service
        container type {
          tailf:info "refer either control and service policies";
          container service {
            tailf:info "Specify a service to download";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf unapply {
              tailf:info "Specify a service profile to unapply";
              tailf:cli-optional-in-sequence;
              type empty;
            }
            leaf name {
              tailf:info "Specify a named service to apply";
              tailf:cli-disallow-value "unapply";
              tailf:cli-optional-in-sequence;
              tailf:cli-full-command;
              tailf:non-strict-leafref {
                path "/ios:policy-map-service/policy-map/name";
              }
              type string {
                tailf:info "WORD;;Name of a service profile";
              }
            }
            leaf identifier {
              tailf:info "Specify an identifier type";
              tailf:cli-full-command;
              type enumeration {
                enum authenticated-domain {
                  tailf:info "Authenticated domain name";
                }
                enum authenticated-username {
                  tailf:info "Authenticated username";
                }
                enum dnis {
                  tailf:info "Dial Number Information Service (called party number)";
                }
                enum nas-port {
                  tailf:info "NAS Port Identifier";
                }
                enum service-name {
                  tailf:info "Service name currently associated with user";
                }
                enum tunnel-name {
                  tailf:info "VPDN Tunnel-Name";
                }
                enum unauthenticated-domain {
                  tailf:info "Unauthenticated domain name";
                }
                enum unauthenticated-username {
                  tailf:info "Unauthenticated username";
                }
              }
            }
          }
        }
      }

      // policy-map type control * / class type control * event / * authorize
      container authorize {
        tailf:info "Authorize the user";

        // policy-map type control * / class type control * event / * authorize aaa
        container aaa {
          tailf:info "Specify AAA parameters";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf list {
            tailf:info "Specify an AAA method list that authorization should be made with";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          leaf name {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            tailf:cli-disallow-value "list|password";
            type string {
              tailf:info "WORD;;Named Method List";
            }
          }
          leaf password {
            tailf:info "Specify a password to be used for AAA request";
            tailf:cli-optional-in-sequence;
            ios:password-dequote-output "password (\\S+)";
            type NEDCOM_SECRET_TYPE {
              tailf:info "WORD;;password";
            }
          }
          leaf identifier {
            tailf:info "Specify an identifier type";
            type enumeration {
              enum authenticated-domain {
                tailf:info "Authenticated domain name";
              }
              enum authenticated-username {
                tailf:info "Authenticated username";
              }
              enum auto-detect {
                tailf:info "auto-detect remote-id/circuit-id combination for authorization";
              }
              enum circuit-id {
                tailf:info "Circuit ID";
              }
              enum ctag-cos {
                tailf:info "ctag cos";
              }
              enum ctag-vlan-id {
                tailf:info "ctag vlan id";
              }
              enum dnis {
                tailf:info "Dial Number Information Service (called party number)";
              }
              enum generic-service-name {
                tailf:info "Generic service key applied to all users";
              }
              enum hostname {
                tailf:info "hostname";
              }
              enum mac-address {
                tailf:info "MAC address";
              }
              enum nas-port {
                tailf:info "nasport";
              }
              enum payload-etype {
                tailf:info "payload etype";
              }
              enum peer-ip-address {
                tailf:info "Peer IP Address";
              }
              enum remote-id {
                tailf:info "Remote ID";
              }
              enum source-ip-address {
                tailf:info "Source IP address";
              }
              enum stag-cos {
                tailf:info "stag cos";
              }
              enum stag-type {
                tailf:info "stag type";
              }
              enum stag-vlan-id {
                tailf:info "stag vlan id";
              }
              enum tunnel-name {
                tailf:info "VPDN Tunnel-Name";
              }
              enum unauthenticated-domain {
                tailf:info "Unauthenticated domain name";
              }
              enum unauthenticated-username {
                tailf:info "Unauthenticated username";
              }
              enum vc-id {
                tailf:info "VC ID";
              }
              enum vendor-class-id {
                tailf:info "Vendor Class ID";
              }
            }
          }
          leaf plus {
            tailf:info "Use additional identifiers";
            type enumeration {
              enum circuit-id {
                tailf:info "Circuit ID";
              }
              enum ctag-cos {
                tailf:info "ctag cos";
              }
              enum ctag-vlan-id {
                tailf:info "ctag vlan id";
              }
              enum hostname {
                tailf:info "hostname";
              }
              enum nas-port {
                tailf:info "nasport";
              }
              enum payload-etype {
                tailf:info "payload etype";
              }
              enum peer-ip-address {
                tailf:info "Peer IP Address";
              }
              enum remote-id {
                tailf:info "Remote ID";
              }
              enum stag-cos {
                tailf:info "stag cos";
              }
              enum stag-type {
                tailf:info "stag type";
              }
              enum stag-vlan-id {
                tailf:info "stag vlan id";
              }
              enum vc-id {
                tailf:info "VC ID";
              }
              enum vendor-class-id {
                tailf:info "Vendor Class ID";
              }
            }
          }
        }
      }

      // policy-map type control * / class type control * event / * authenticate aaa list
      container authenticate {
        tailf:info "Authenticate the user";
        container aaa {
          tailf:info "Specify AAA parameters";
          leaf list {
            tailf:info "Specify an AAA method list that key collection should be made with";
            tailf:cli-diff-dependency "/ios:aaa/authentication";
            type union {
              type enumeration {
                enum default {
                  tailf:info "Use a default Authentication method list";
                }
              }
              type string {
                tailf:info "WORD;;Named Method List";
              }
            }
          }
        }
      }

      // policy-map type control * / class type control * event / * set-timer
      container set-timer {
        tailf:info "Set a timer to execute a rule on its expiry";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf name {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type string {
            tailf:info "WORD;;Name of the timer";
          }
        }
        leaf value {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-10100>;;Timer value in minutes";
            range "1..10100";
          }
        }
      }
    }
  }


  grouping distribute-list-content-grouping {

    // distribute-list <access-list-name> in|out
    leaf access-list-name {
      tailf:cli-drop-node-name;
      tailf:cli-prefix-key;
      tailf:cli-optional-in-sequence;
      tailf:cli-disallow-value "prefix-list|route-map|prefix|gateway|in|out";
      //tailf:cli-incomplete-command;
      type exp-ip-acl-type;
    }

    // distribute-list prefix-list
    leaf prefix-list {
      tailf:info "Filter connections based on an IPv6 prefix-list";
      tailf:cli-prefix-key;
      tailf:cli-optional-in-sequence;
      tailf:cli-diff-dependency "/ios:ipv6/prefix-list/prefixes";
      type string {
        tailf:info "WORD;;Prefix-list name";
      }
    }

    // distribute-list prefix <pfx-list-name> gateway <pfx-list-name> in|out
    leaf prefix {
      tailf:info "Filter prefixes in routing updates";
      tailf:cli-prefix-key;
      tailf:cli-optional-in-sequence;
      tailf:cli-diff-dependency "/ios:ip/prefix-list/prefixes";
      type string {
        tailf:info "WORD;;Name of an IP prefix-list";
      }
    }
    leaf gateway {
      tailf:info "Filtering incoming updates based on gateway";
      tailf:cli-prefix-key;
      tailf:cli-optional-in-sequence;
      tailf:cli-diff-dependency "/ios:ip/prefix-list/prefixes";
      type string {
        tailf:info "WORD;;Name of an IP prefix-list";
      }
    }

    // distribute-list prefix routemap <route-map-name> in|out
    leaf route-map {
      tailf:info "Filter prefixes based on the route-map";
      tailf:cli-prefix-key;
      tailf:cli-optional-in-sequence;
      type string {
        tailf:info "WORD;;route-map name";
      }
    }
  }

  grouping redistribute-ospf-match-grouping {

    leaf match {
      tailf:info "Redistribution of OSPF routes";
      tailf:cli-incomplete-command;
      type empty;
    }

    leaf internal {
      when "../match" {
        tailf:dependency "../match";
      }
      tailf:info "Redistribute OSPF internal routes";
      type empty;
    }

    container external-1 {
      when "../match" {
        tailf:dependency "../match";
      }
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      leaf external {
        tailf:info "Redistribute OSPF external routes";
        type enumeration {
          enum "1" {
            tailf:info "Redistribute external type 1 routes";
          }
        }
      }
    }

    container external-2 {
      when "../match" {
        tailf:dependency "../match";
      }
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      leaf external {
        tailf:info "Redistribute OSPF external routes";
        type enumeration {
          enum "2" {
            tailf:info "Redistribute external type 2 routes";
          }
        }
      }
    }

    container nssa-external-1 {
      when "../match" {
        tailf:dependency "../match";
      }
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      leaf nssa-external {
        tailf:info "Redistribute OSPF NSSA external routes";
        type enumeration {
          enum "1" {
            tailf:info "Redistribute NSSA external type 1 routes";
          }
        }
      }
    }

    container nssa-external-2 {
      when "../match" {
        tailf:dependency "../match";
      }
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      leaf nssa-external {
        tailf:info "Redistribute OSPF NSSA external routes";
        type enumeration {
          enum "2" {
            tailf:info "Redistribute NSSA external type 2 routes";
          }
        }
      }
    }
  }

  // router rip
  // router ospf *
  // router bgp *
  // router eigrp * / address-family * / topology base /
  // router isis
  grouping router-distribute-list-grouping {

    list distribute-list {
      tailf:info "Filter networks in routing updates";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-remove-before-change;
      key direction;
      leaf direction {
        tailf:cli-diff-dependency "../../distribute-list-interface/distribute-list" {
          tailf:cli-trigger-on-set;
        }
        tailf:cli-full-command;
        type enumeration {
          enum "in" {
            tailf:info "Filter incoming routing updates";
          }
          enum "out" {
            tailf:info "Filter outgoing routing updates";
          }
        }
      }
      uses distribute-list-content-grouping;
    }

    container distribute-list-interface {
      tailf:cli-drop-node-name;
      list distribute-list {
        tailf:info "Filter networks in routing updates";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-remove-before-change;
        key "direction interface";
        leaf direction {
          type enumeration {
            enum "in" {
              tailf:info "Filter incoming routing updates";
            }
            enum "out" {
              tailf:info "Filter outgoing routing updates";
            }
          }
        }
        leaf interface {
          tailf:cli-diff-dependency "/ios:interface";
          type string {
            tailf:info "WORD;;Interface name";
          }
        }
        uses distribute-list-content-grouping;
      }
    }
  }

  // router rip /
  // router eigrp * /
  grouping router-offset-list-grouping {

    list offset-list {
      tailf:info "Add or subtract offset from metrics";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-incomplete-command;
      key direction;
      leaf id {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        type union {
          type uint32 {
            tailf:info "<0-99>;;Access list of networks to apply offset (0 selects all networks)";
            range "0..99";
          }
          type uint32 {
            tailf:info "<1300-1999>;;Access list of networks to apply offset (expanded range)";
            range "1300..1999";
          }
          type string {
            tailf:info "WORD;;Access-list name";
          }
        }
      }
      leaf direction {
        type enumeration {
          enum in {
            tailf:info "Perform offset on incoming updates";
          }
          enum out {
            tailf:info "Perform offset on outgoing updates";
          }
        }
      }
      leaf offset {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<0-2147483647>;;Offset";
        }
      }
    }

    container offset-list-interface {
      tailf:cli-drop-node-name;
      list offset-list {
        tailf:info "Add or subtract offset from metrics";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        key "direction interface";
        leaf id {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type union {
            type uint32 {
              tailf:info "<0-99>;;Access list of networks to apply offset (0 selects all networks)";
              range "0..99";
            }
            type uint32 {
              tailf:info "<1300-1999>;;Access list of networks to apply offset (expanded range)";
              range "1300..1999";
            }
            type string {
              tailf:info "WORD;;Access-list name";
            }
          }
        }
        leaf direction {
          type enumeration {
            enum in {
              tailf:info "Perform offset on incoming updates";
            }
            enum out {
              tailf:info "Perform offset on outgoing updates";
            }
          }
        }
        leaf offset {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key {
            tailf:cli-before-key 2;
          }
          type uint32 {
            tailf:info "<0-2147483647>;;Offset";
          }
        }
        leaf interface {
          tailf:cli-diff-dependency "/ios:interface";
          type string {
            tailf:info "WORD;;Interface name";
          }
        }
      }
    }
  }

  // router rip *
  // router ospf *
  // router isis
  // router isis *
  // router eigrp *
  // ipv6 router eigrp *
  grouping passive-interface-grouping {

    // router * / passsive-interface
    container passive-interface {
      tailf:info "Suppress routing updates on an interface";

      // router * / passsive-interface default
      leaf default {
        tailf:info "Suppress routing updates on all interfaces";
        tailf:cli-diff-set-after "../interface" {
          tailf:cli-when-target-delete;
        }
        tailf:cli-diff-delete-after "../../disable/passive-interface" {
          tailf:cli-when-target-delete;
        }
        type empty;
      }

      // router * / passsive-interface *
      list interface {
        when "not(../default)" {
          tailf:dependency "../default";
        }
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          tailf:cli-disallow-value "default";
          tailf:cli-diff-delete-before "/ios:interface" {
            tailf:cli-when-target-delete;
          }
          tailf:cli-diff-delete-before "../../default" {
            tailf:cli-when-target-create;
          }
          type string {
            tailf:info "WORD;;Interface name";
          }
        }
      }
    }

    // Fix to handle showing "no passive-interface <ifname>"
    // Replace 'disable passive-interface <ifname> with
    // "no passive-interface <ifname>"
    container disable {
      tailf:info "Use 'disable passive-interface' for 'no passive-interface' config";
      when "../passive-interface/default" {
        tailf:dependency "../passive-interface/default";
      }
      list passive-interface {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key interface;
        leaf interface {
          tailf:cli-diff-delete-before "/ios:interface" {
            tailf:cli-when-target-delete;
          }
          tailf:cli-diff-delete-before "../../../passive-interface/default" {
            tailf:cli-when-target-delete;
          }
          type string {
            tailf:info "WORD;;Interface name";
          }
        }
      }
    }
  }


  // ip-community-list-grouping
  grouping ip-community-list-grouping {
    list entry {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-show-long-obu-diffs;
      ordered-by user;
      key expr;
      leaf expr {
        ios:string-multi-transform "ip community-list.+ (?:permit|deny) <STRING>";
        tailf:cli-multi-word-key {
          tailf:cli-max-words 11;
        }
        type string {
          tailf:info "<RULE>;;deny <options> | permit <options>";
          pattern "(permit.*)|(deny.*)";
        }
      }
    }
  }

  // ip-extcommunity-list-grouping
  grouping ip-extcommunity-list-grouping {

    list entry {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-show-long-obu-diffs;
      ordered-by user;
      key expr;
      leaf expr {
        tailf:cli-multi-word-key;
        type string {
          tailf:info "<RULE>;;deny <LINE> | permit <LINE>";
          pattern "(permit.*)|(deny.*)";
        }
      }
    }

  }


  // ip-route-options-grouping
  grouping ip-route-options-grouping {
    leaf dhcp {
      tailf:info "Default Gateway obtained from DHCP";
      tailf:cli-optional-in-sequence;
      tailf:cli-case-insensitive;
      type empty;
    }
    leaf global {
      tailf:info "Next hop address is global";
      tailf:cli-break-sequence-commands;
      type empty;
    }
    leaf metric {
      tailf:cli-drop-node-name;
      type uint8 {
        tailf:info "<1-255>;;Distance metric for this route";
        range "1..255";
      }
    }
    leaf name {
      tailf:info "Specify name of the next hop";
      type string {
        tailf:info "WORD;;Name of the next hop";
      }
    }
    leaf permanent {
      tailf:info "permanent route";
      type empty;
    }
    leaf multicast {
      tailf:info "multicast route";
      type empty;
    }
    leaf tag {
      tailf:info "Set tag for this route";
      type uint32 {
        tailf:info "<1-4294967295>;;Tag value";
        range "1..4294967295";
      }
    }
    leaf track {
      tailf:info "Install route depending on tracked item";
      type uint16 {
        tailf:info "<1-1000>;;tracked object number";
        range "1..1000";
      }
    }
  }

  // ip-route-grouping
  grouping ip-route-grouping {

    list ip-route-interface-forwarding-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-reset-container;
      key "prefix mask interface forwarding-address";
      leaf prefix {
        tailf:cli-disallow-value "vrf";
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Destination prefix";
        }
      }
      leaf mask {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Destination prefix mask";
        }
      }
      leaf interface {
        type string {
          tailf:info "WORD;;Interface name";
        }
      }
      leaf forwarding-address {
        type union {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Forwarding router's address";
          }
          type enumeration {
            enum multicast {
              tailf:info "multicast route";
            }
          }
        }
      }
      uses ip-route-options-grouping;
    }

    list ip-route-forwarding-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-reset-container;
      key "prefix mask forwarding-address";
      leaf prefix {
        tailf:cli-disallow-value "vrf";
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Destination prefix";
        }
      }
      leaf mask {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Destination prefix mask";
        }
      }
      leaf forwarding-address {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Forwarding router's address";
        }
      }
      uses ip-route-options-grouping;
    }

    list ip-route-interface-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-reset-container;
      key "prefix mask interface";
      leaf prefix {
        tailf:cli-disallow-value "vrf";
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Destination prefix";
        }
      }
      leaf mask {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Destination prefix mask";
        }
      }
      leaf interface {
        tailf:cli-disallow-value "metric|global|name|permanent|multicast|tag|track";
        type union {
          type string {
            tailf:info "WORD;;Interface name";
          }
          type enumeration {
            enum dhcp {
              tailf:info "Default Gateway obtained from DHCP";
            }
          }
        }
      }
      uses ip-route-options-grouping;
    }
  }

  // ipv6-route-options-grouping
  grouping ipv6-route-options-grouping {
    leaf distance {
      tailf:cli-drop-node-name;
      tailf:cli-break-sequence-commands;
      type uint8 {
        tailf:info "<1-254>;;Administrative distance";
        range "1..254";
      }
    }
    choice type-choice {
      leaf multicast {
        tailf:info "Route only usable by multicast";
        tailf:cli-full-command;
        type empty;
      }
      leaf unicast {
        tailf:info "Route only usable by unicast";
        type empty;
      }
    }
    leaf tag {
      tailf:info "Tag value";
      type uint32 {
        tailf:info "<0-4294967295>;;Tag value";
      }
    }
    leaf track {
      tailf:info "Track";
      type uint32 {
        tailf:info "<0-4294967295>;;Tracked object";
      }
    }
    leaf name {
      tailf:info "Name of static route";
      tailf:cli-full-command;
      type string {
        tailf:info "WORD;;Name";
      }
    }
  }

  // ipv6-route-grouping
  grouping ipv6-route-grouping {
    list ipv6-route-interface-destination-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-reset-container;
      key "prefix interface destination";
      leaf prefix {
        tailf:cli-disallow-value "vrf";
        type ipv6-prefix {
          tailf:info "X:X:X:X::X/<0-128>;;IPv6 prefix x:x::y/<z>";
        }
      }
      leaf interface {
        type string {
          tailf:info "WORD;;Interface name";
        }
      }
      leaf destination {
        type inet:ipv6-address {
          tailf:info "X:X:X:X::X;;IPv6 address of next-hop";
        }
      }
      uses ipv6-route-options-grouping;
    }
    list ipv6-route-destination-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-reset-container;
      key "prefix destination";
      leaf prefix {
        tailf:cli-disallow-value "vrf";
        type ipv6-prefix {
          tailf:info "X:X:X:X::X/<0-128>;;IPv6 prefix x:x::y/<z>";
        }
      }
      leaf destination {
        type inet:ipv6-address {
          tailf:info "X:X:X:X::X;;IPv6 address of next-hop";
        }
      }
      uses ipv6-route-options-grouping;

    }
    list ipv6-route-interface-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-reset-container;
      key "prefix interface";
      leaf prefix {
        tailf:cli-disallow-value "vrf";
        type ipv6-prefix {
          tailf:info "X:X:X:X::X/<0-128>;;IPv6 prefix x:x::y/<z>";
        }
      }
      leaf interface {
        type string {
          tailf:info "WORD;;Interface name";
        }
      }
      uses ipv6-route-options-grouping;
    }
  }

  // ip mroute *
  // ip mroute vrf *
  grouping ip-mroute-grouping {
    list address-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-reset-container;
      key "source-address mask";
      leaf source-address {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Source address";
        }
      }
      leaf mask {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Network mask";
        }
      }
      choice mroute-choice {
        container fallback-lookup {
          tailf:info "Alternate routing table for RPF lookup";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-optional-in-sequence;
          choice fallback-choice {
            leaf global {
              tailf:info "Global routing table for RPF lookup";
              type empty;
            }
            leaf vrf {
              tailf:info "Select VPN Routing/Forwarding instance";
              type string {
                tailf:info "WORD;;VPN Routing/Forwarding instance name";
              }
            }
          }
        }
        leaf rpf-address {
          tailf:cli-drop-node-name;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;RPF neighbor address or route";
          }
        }
        container interface {
          tailf:cli-drop-node-name;
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          uses interface-name-grouping;
        }
      }
      leaf distance {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-255>;;Administrative distance for mroute";
        }
        default 1;
      }
    }
  }

  // random-detect-grouping
  grouping random-detect-grouping {
    choice threshold-choice {
      container percent {
        tailf:info "% of minimum threshold";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf min {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<1-100>;;Minimum threshold percentage";
            range "1..100";
          }
        }
        leaf max {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<1-100>;;Maximum threshold percentage";
            range "1..100";
          }
        }
      }
      case numeric {
        leaf min-threshold {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<1-512000000>;;minimum threshold (in packet by default)";
          }
        }
        leaf min-threshold-unit {
          tailf:cli-drop-node-name;
          tailf:cli-optional-in-sequence;
          type enumeration {
            enum bytes {
                        tailf:info "number of bytes";
            }
            enum ms {
                     tailf:info "milliseconds";
            }
            enum us {
                     tailf:info "microseconds";
            }
            enum packets {
                          tailf:info "packets";
            }
          }
        }
        leaf max-threshold {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-512000000>;;maximum threshold (number of packets)";
          }
        }
        leaf max-threshold-unit {
          tailf:cli-drop-node-name;
          tailf:cli-optional-in-sequence;
          type enumeration {
            enum bytes {
                        tailf:info "number of bytes";
            }
            enum ms {
                     tailf:info "milliseconds";
            }
            enum us {
                     tailf:info "microseconds";
            }
            enum packets {
                          tailf:info "packets";
            }
          }
        }
        leaf denominator {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-65535>;;mark probability denominator";
          }
        }
      }
    }
  }

  // random-detect-values-grouping
  grouping random-detect-values-grouping {
    leaf minimum-thresh {
      tailf:info "minimum threshold for red aggregate";
      tailf:cli-incomplete-command;
      type uint32 {
        tailf:info "<1-512000000>;;minimum threshold (number of packets)";
      }
    }
    leaf maximum-thresh {
      tailf:info "maximum threshold for red aggregate";
      type uint32 {
        tailf:info "<1-512000000>;;maximum threshold (number of packets)";
      }
    }
    leaf mark-prob {
      tailf:info "mark-probability for red aggregate";
      type uint32 {
        tailf:info "<0-65535>;;mark probability denominator";
        range "0..65535";
      }
    }
  }

  // class-map-match-grouping
  grouping class-map-match-grouping {

    // class-map * / match application *
    list application {
      tailf:info "Application to match";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        tailf:cli-multi-word-key;
        type string {
          tailf:info "WORD;;Application name";
        }
      }
    }

    // class-map * / match access-group *
    // class-map * / match access-group name *
    container access-group {
      tailf:info "Access group";
      tailf:cli-diff-dependency "/ios:ip/access-list";
      leaf-list index {
        tailf:cli-drop-node-name;
        tailf:cli-list-syntax;
        type uint32 {
          tailf:info "<1-2799>;;Access list index";
          range "1..2799";
        }
      }
      leaf-list name {
        tailf:info "Named Access List";
        tailf:cli-list-syntax;
        type string {
          tailf:info "WORD;;Access List name";
        }
      }
    }

    // class-map * / match any
    leaf any {
      tailf:info "Any packets";
      type empty;
    }

    // class-map * / match class-map *
    leaf-list class-map {
      tailf:info "Class map";
      tailf:cli-list-syntax;
      tailf:non-strict-leafref {
        path "/ios:class-map/name";
      }
      type string {
        tailf:info "WORD;;Match class-map name";
      }
    }

    // class-map * / match cos *
    leaf-list cos {
      tailf:info "IEEE 802.1Q/ISL class of service/user priority values";
      tailf:cli-flat-list-syntax;
      tailf:cli-disallow-value "inner";
      max-elements 8;
      type uint16 {
        tailf:info "<0-7>;;Enter up to 8 class-of-service values separated by white-spaces";
        range "0..7";
      }
    }

    // class-map * / match cos inner *
    // Note: old IOS CLI, will not handle all modifications
    container cos-inner {
      tailf:cli-drop-node-name;
      container cos {
        tailf:info "IEEE 802.1Q/ISL class of service/user priority values";
        leaf-list inner {
          tailf:info "ATM VC configured as Access VC class of service/user priority values";
          tailf:cli-flat-list-syntax;
          ios:max-values-output "3 :: 4"; // values start after 3 words, max 4 per line
          max-elements 8;
          type uint16 {
            tailf:info "<0-7>;;Enter up to 8 class-of-service values separated by white-spaces";
            range "0..7";
          }
        }
      }
    }

    // class-map * / match destination-address mac *
    container destination-address {
      tailf:info "Destination address";
      leaf-list mac {
        tailf:info "MAC address";
        tailf:cli-list-syntax;
        type string {
          tailf:info "H.H.H;;MAC address";
        }
      }
    }

    // class-map * / match discard-class *
    leaf-list discard-class {
      tailf:info "Discard behavior identifier";
      tailf:cli-list-syntax;
      type uint8 {
        tailf:info "<0-7>;;Discard Class value";
        range "0..7";
      }
    }

    // class-map * / match dscp *
    leaf-list dscp {
      tailf:info "Match DSCP in IP(v4) and IPv6 packets";
      tailf:cli-flat-list-syntax;
      tailf:cli-full-command;
      ios:max-values-output "2 :: 8"; // values start after 2 words, max 8 per line
      ios:prune-leaf-list-duplicates;
      type dscp-type;
    }

    // class-map * / match fr-de
    leaf fr-de {
      tailf:info "Match on Frame-relay DE bit";
      type empty;
    }

    // class-map * / match fr-dlci *
    leaf-list fr-dlci {
      tailf:info "Match on fr-dlci";
      tailf:cli-list-syntax;
      type uint16 {
        tailf:info "<16-1007>;;frame-relay dlci number";
        range "16..1007";
      }
    }

    // class-map * / match non-client-nrt
    leaf non-client-nrt {
      tailf:info "Match non-client NRT";
      type empty;
    }

    // class-map * / match input vlan *
    container input {
      tailf:info "input attachment circuits";
      leaf-list vlan {
        tailf:info "layer2 input VLANs to match";
        tailf:cli-list-syntax;
        type union {
          type uint16 {
            tailf:info "<1-4094>;;VLAN id";
            range "1..4094";
          }
          type string {
            tailf:info "WORD;;VLAN id range. Use , or - to separate entries";
            pattern '[0-9,-]+';
          }
        }
      }
    }

    // class-map * / match input-interface *
    list input-interface {
      tailf:info "Select an input interface to match";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        tailf:cli-multi-word-key;
        tailf:cli-diff-dependency "/ios:interface";
        type string {
          tailf:info "WORD;;Interface name or range";
        }
      }
    }

    // class-map * / match ip
    container ip {
      tailf:info "IP specific values";

      // class-map * / match ip dscp *
      leaf-list dscp {
        tailf:info "Match IP DSCP (DiffServ CodePoints)";
        tailf:cli-flat-list-syntax;
        type dscp-type;
      }

      // class-map * / match ip precedence *
      leaf-list precedence {
        tailf:info "Match IP precedence";
        tailf:cli-flat-list-syntax;
        tailf:cli-remove-before-change;
        ios:max-values-output "3 :: 4"; // values start after 3 words, max 4 per line
        type precedence-type;
      }

      // class-map * / match ip rtp *
      list rtp {
        tailf:info "Match RTP port nos";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "port1 port2";
        leaf port1 {
          type uint16 {
            tailf:info "<2000-65535>;;Lower bound of UDP destination port";
            range "2000..65535";
          }
        }
        leaf port2 {
          type uint16 {
            tailf:info "<0-16383>;;Range of UDP ports";
            range "0..16383";
          }
        }
      }
    }

    // class-map * / match mpls experimental topmost *
    container mpls {
      tailf:info "Multi Protocol Label Switching specific values";
      container experimental {
        tailf:info "Match MPLS experimental";
        leaf-list topmost {
          tailf:info "Match MPLS experimental value on topmost label";
          tailf:cli-flat-list-syntax;
          type uint16 {
            tailf:info "<0-7>;;Enter up to 8 experimental values separated by white-spaces";
            range "0..7";
          }
        }
      }
    }

    // class-map * / match precedence *
    leaf-list precedence {
      tailf:info "Match Precedence in IP(v4) and IPv6 packets";
      tailf:cli-flat-list-syntax;
      tailf:cli-remove-before-change;
      ios:max-values-output "2 :: 4"; // values start after 2 words, max 4 per line
      type precedence-type;
    }

    // class-map * / match protocol
    container protocol {
      tailf:info "Protocol";

      // class-map * / match protocol attribute
      container attribute {
        tailf:info "Attribute based protocol match";

        // class-map * / match protocol attribute category *
        list category {
          tailf:info "Category attribute";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key category-type;
          leaf category-type {
            type enumeration {
              enum "voice-and-video" {
                tailf:info "Filter incoming connections";
              }
              enum "database" {
                tailf:info "Filter outgoing connections";
              }
              enum "email" {
                tailf:info "Email related applications";
              }
              enum "browsing" {
                tailf:info "Browsing related applications";
              }
              enum "trojan" {
                tailf:info "Trojan related applications";
              }
              enum "gaming" {
                tailf:info "Gaming related applications";
              }
              enum "anonymizers" {
                tailf:info "Anonymizers applications";
              }
              enum "backup-and-storage" {
                tailf:info "Backup and storage related applications";
              }
              enum "business-and-productivity-tools" {
                tailf:info "Business-and-productivity-tools related applications";
              }
              enum "epayement" {
                tailf:info "Epayement related applications";
              }
              enum "file-sharing" {
                tailf:info "File-sharing related applications";
              }
              enum "industrial-protocols" {
                tailf:info "Industrial-protocols related applications";
              }
              enum "instant-messaging" {
                tailf:info "Instant-messaging related applications";
              }
              enum "inter-process-rpc" {
                tailf:info "Inter-process-rpc related applications";
              }
              enum "internet-security" {
                tailf:info "Internet security related applications";
              }
              enum "layer3-over-ip" {
                tailf:info "Layer3-over-IP related applications";
              }
              enum "location-based-services" {
                tailf:info "Location-based-services related applications";
              }
              enum "net-admin" {
                tailf:info "Net-admin related applications";
              }
              enum "newsgroup" {
                tailf:info "Newsgroup related applications";
              }
              enum "other" {
                tailf:info "Other related applications";
              }
              enum "social-networking" {
                tailf:info "Social-networking related applications";
              }
              enum "software-updates" {
                tailf:info "Software updates and downloads related applications";
              }
            }
          }
        }

        // class-map * / match protocol attribute traffic-class *
        list traffic-class {
          tailf:info "traffic-class attribute";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key traffic-class-type;
          leaf traffic-class-type {
            type enumeration {
              enum "broadcast-video" {
                tailf:info "Broadcast TV, live events, video surveillance";
              }
              enum "bulk-data" {
                tailf:info "Non-interactive data applications";
              }
              enum "multimedia-conferencing" {
                tailf:info "Desktop software multimedia collaboration applications";
              }
              enum "multimedia-streaming" {
                tailf:info "Video-on-Demand (VoD) streaming video";
              }
              enum "network-control" {
                tailf:info "Network control plane traffic";
              }
              enum "ops-admin-mgmt" {
                tailf:info "Network operations, administration, and management";
              }
              enum "real-time-interactive" {
                tailf:info "High-definition interactive video applications";
              }
              enum "signaling" {
                tailf:info "Signaling traffic that supports IP voice and video telephony";
              }
              enum "transactional-data" {
                tailf:info "Interactive data applications";
              }
              enum "voip-telephony" {
                tailf:info "VoIP telephony (bearer-only) traffic";
              }
            }
          }
        }

        // class-map * / match protocol attribute business-relevance *
        list business-relevance {
          tailf:info "business-relevance attribute";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key business-relevance-type;
          leaf business-relevance-type {
            type enumeration {
              enum "business-irrelevant" {
                tailf:info "Undesirable business traffic";
              }
              enum "business-relevant" {
                tailf:info "Business critical applications";
              }
              enum "default" {
                tailf:info "Related business applications";
              }
            }
          }
        }
      }

      // class-map * / match protocol *
      list protocol-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          tailf:cli-disallow-value "attribute";
          type string {
            tailf:info "WORD;;protocol";
          }
        }
        list values {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-show-long-obu-diffs;
          ordered-by user;
          key value;
          leaf value {
            tailf:cli-multi-word-key;
            type string;
          }
        }
      }
    }

    // class-map * / match packet length min *
    // class-map * / match packet length max *
    // class-map * / match packet length min * max *
    container packet {
      tailf:info "Layer 3 Packet length";
      list length {
        tailf:info "Layer 3 Packet length";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-show-long-obu-diffs;
        ordered-by user;
        key line;
        leaf line {
          tailf:cli-multi-word-key;
          type string {
            tailf:info "LINE;;min X | max X | min X max Y";
            pattern '(min \d+)|(max \d+)|(min \d+ max \d+)';
          }
        }
      }
    }

    // class-map * / match qos-group *
    leaf-list qos-group {
      tailf:info "Qos-group";
      tailf:cli-list-syntax;
      type uint16 {
        tailf:info "<0-99>;;Qos Group value";
        range "0..99";
      }
    }

    // class-map * / match source-address *
    container source-address {
      tailf:info "Source address";
      leaf-list mac {
        tailf:info "MAC address";
        tailf:cli-list-syntax;
        type string {
          tailf:info "H.H.H;;MAC address";
        }
      }
    }

    // class-map * / match vlan inner *
    container vlan-inner {
      tailf:cli-drop-node-name;
      container vlan {
        tailf:info "VLANs to match";
        leaf-list inner {
          tailf:info "Inner tag to match";
          tailf:cli-list-syntax;
          type union {
            type uint16 {
              tailf:info "<1-4094>;;VLAN id";
              range "1..4094";
            }
            type string {
              tailf:info "WORD;;VLAN id range. Use , or - to separate entries";
              pattern '[0-9,-]+';
            }
          }
        }
      }
    }

    // class-map * / match vlan *
    leaf-list vlan {
      tailf:info "VLANs to match";
      tailf:cli-list-syntax;
      type union {
        type uint16 {
          tailf:info "<1-4094>;;VLAN id";
          range "1..4094";
        }
        type string {
          tailf:info "WORD;;VLAN id range. Use , or - to separate entries";
          pattern '[0-9,-]+';
        }
      }
    }

    // class-map * / match service instance ethernet *
    container service {
      tailf:info "Service Instance to match";
      container instance {
        tailf:info "Service Instance to match";
        leaf-list ethernet {
          tailf:info "Service Instance to match";
          tailf:cli-list-syntax;
          type string {
            tailf:info "<1-4294967295>;;Service Instance Identifier. Ranges accepted";
          }
        }
      }
    }

    // class-map * / match security-group
    container security-group {
      tailf:info "Security group";

      // class-map * / match security-group source tag *
      list source {
        tailf:info "Source security group";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key tag;
        leaf tag {
          tailf:info "Security group tag";
          tailf:cli-expose-key-name;
          type uint16 {
            tailf:info "<1-65533>;;Security group tag id";
            range "1..65533";
          }
        }
      }

      // class-map * / match security-group destination tag *
      list destination {
        tailf:info "Destination security group";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key tag;
        leaf tag {
          tailf:info "Security group tag";
          tailf:cli-expose-key-name;
          type uint16 {
            tailf:info "<1-65533>;;Security group tag id";
            range "1..65533";
          }
        }
      }
    }

    // class-map * / match flow record *
    container flow {
      tailf:info "Flow based QoS parameters";
      list record {
        tailf:info "FNF flow record ";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          tailf:non-strict-leafref {
            path "/ios:flow/record/name";
          }
          type string {
            tailf:info "WORD;;flow record name";
          }
        }
      }
    }
  }

  // ip-name-server-grouping
  grouping ip-name-server-grouping {
    list name-server-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-show-long-obu-diffs;
      ordered-by user;
      max-elements 6;
      key address;
      leaf address {
        type union {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Domain server IP address (maximum of 6)";
          }
          type inet:ipv6-address {
            tailf:info "X:X:X:X::X;;Domain server IPv6 address (maximum of 6)";
          }
        }
      }
    }
  }

  // ip-host-grouping
  grouping ip-host-grouping {
    list host-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-incomplete-command;
      key hostname;
      leaf hostname {
        tailf:cli-disallow-value "vrf";
        type string {
          tailf:info "WORD;;Name of host";
        }
      }
      leaf tcp-port-number {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        tailf:cli-incomplete-command;
        type uint16 {
          tailf:info "<0-65535>;;Default telnet port number";
        }
      }
      leaf-list ip-address1 {
        tailf:cli-drop-node-name;
        tailf:cli-flat-list-syntax;
        tailf:cli-replace-all;
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Host IP address";
        }
      }
    }
  }

  // ip-dhcp-excluded-address-grouping
  grouping ip-dhcp-excluded-address-grouping {
    list low-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key low;
      leaf low {
        tailf:cli-disallow-value "vrf";
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Low IP address";
        }
      }
    }
    list low-high-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key "low high";
      leaf low {
        tailf:cli-disallow-value "vrf";
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Low IP address";
        }
      }
      leaf high {
        tailf:cli-disallow-value "vrf";
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;High IP address";
        }
      }
    }
  }

  // ntp-peer-grouping
  grouping ntp-peer-grouping {
    list peer-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      key name;
      leaf name {
        tailf:cli-disallow-value "vrf";
        type inet:host {
          tailf:info "Hostname, A.B.C.D or X:X:X:X::X;;Address of peer";
        }
      }
      leaf burst {
        tailf:info "Send a burst when peer is reachable (Default)";
        type empty;
      }
      leaf iburst {
        tailf:info "Send a burst when peer is unreachable (Default)";
        type empty;
      }
      leaf key {
        tailf:info "Configure peer authentication key";
        type uint32 {
          tailf:info "<1-4294967295>;;Peer key number";
        }
      }
      leaf maxpoll {
        tailf:info "Maximum poll interval";
        type uint8 {
          tailf:info "<4-17>;;Poll value in Log2";
          range "4..17";
        }
      }
      leaf minpoll {
        tailf:info "Minimum poll interval";
        type uint8 {
          tailf:info "<4-17>;;Poll value in Log2";
          range "4..17";
        }
      }
      leaf normal-sync {
        tailf:info "Disable rapid sync at startup";
        type empty;
      }
      leaf prefer {
        tailf:info "Prefer this peer when possible";
        //tailf:cli-no-name-on-delete; // for 3845 12.4(15)T7
        type empty;
      }
      container source {
        tailf:info "Interface for source address";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        uses interface-name-grouping;
      }
      leaf version {
        tailf:info "Configure NTP version";
        type uint8 {
          tailf:info "<1-4>;;NTP version number";
        }
      }
    }
  }

  // sntp-server-grouping
  grouping sntp-server-grouping {
    list server-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      key name;
      leaf name {
        tailf:cli-disallow-value "vrf";
        type inet:host {
          tailf:info "Hostname, A.B.C.D or X:X:X:X::X;;Address of peer";
        }
      }
      leaf key {
        tailf:info "Configure server authentication key";
        type uint32 {
          tailf:info "<1-4294967295>;;Server key number";
          range "1..4294967295";
        }
      }
      leaf version {
        tailf:info "Configure NTP version";
        type uint8 {
          tailf:info "<1-4>;;NTP version number";
        }
      }
    }
  }

  // line-grouping
  grouping line-grouping {

    // line * / location
    leaf location {
      tailf:info "Enter terminal location description";
      tailf:cli-multi-value;
      tailf:cli-preformatted;
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;One text line describing the terminal's location";
      }
    }

    // line * / absolute-timeout
    leaf absolute-timeout {
      tailf:info "Set absolute timeout for line disconnection";
      tailf:cli-full-command;
      type uint32 {
        tailf:info "<0-10000>;;Absolute timeout interval in minutes. Default 0";
        range "0..10000";
      }
      default 0;
    }

    // line * / access-class
    container access-class {
      tailf:info "Filter connections based on an IP access list";
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      list access-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-diff-dependency "/ios:ip/access-list";
        key direction;
        leaf direction {
          type enumeration {
            enum "in" {
              tailf:info "Filter incoming connections";
            }
            enum "out" {
              tailf:info "Filter outgoing connections";
            }
          }
        }
        leaf access-list {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type exp-ip-acl-type;
        }
        leaf vrfname {
          tailf:info "Access list is applied for given VRFs";
          tailf:cli-optional-in-sequence;
          tailf:cli-diff-dependency "/ios:ip/vrf";
          tailf:cli-diff-dependency "/ios:vrf/definition";
          type string {
            tailf:info "WORD;;Vrfname";
          }
        }
        leaf vrf-also {
          tailf:info "Same access list is applied for all VRFs";
          type empty;
        }
      }
    }

    // line * / no flush-at-activation
    leaf flush-at-activation {
      tailf:info "Clear input stream at activation";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
      default true;
    }

    // line * / special-character-bits
    leaf special-character-bits {
      tailf:info "Size of the escape (and other special) characters";
      type uint8 {
        tailf:info "<7-8>;;Bits per character";
        range "7..8";
      }
    }

    // line * / activation-character
    container activation-character-choice {
      tailf:cli-drop-node-name;
      ios:replace-output " activation-character" {
        cli:arguments " activation-character 13";
      }
      choice activation-character-choice {

        // line * / no activation-character
        leaf activation-character {
          tailf:info "Define the activation character";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          tailf:cli-full-no;
          type boolean;
          default true;
        }

        // line * / activation-character X
        container activation-character-conf {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          leaf activation-character {
            tailf:info "Define the activation character";
            ios:delete-syntax " activation-character 13";
            type union {
              type string {
                tailf:info "CHAR;;Activation character";
              }
              type uint8 {
                tailf:info "<0-127>;;Decimal equivalent. Default 13";
              }
            }
            default 13;
          }
        }
      }
    }

    // line * / escape-character
    leaf escape-character {
      tailf:info "Change the current line's escape character";
      type union {
        type uint8 {
          tailf:info "ASCII decimal equivalent";
        }
        type enumeration {
          enum BREAK {
            tailf:info "Cause escape on BREAK";
          }
          enum DEFAULT {
            tailf:info "Use default escape character";
          }
          enum NONE {
            tailf:info "Disable escape entirely";
          }
        }
      }
      default DEFAULT;
    }

    // line * / disconnect-character
    leaf disconnect-character {
      tailf:info "Define the disconnect character";
      type uint8 {
        tailf:info "<0-255>;;Disconnect character in decimal equivalent";
      }
    }

    // line * / script
    container script {
      tailf:info "specify event related chat scripts to run on the line";
      leaf dialer {
        tailf:info "chat script to run whenever dialer makes an outgoing call";
        tailf:non-strict-leafref {
          path "/ios:chat-script/name";
        }
        type string {
          tailf:info "WORD;;chat script name";
        }
      }
    }

    // line * / modem
    container modem {
      tailf:info "Configure the Modem Control Lines";

      // line * / modem enable
      leaf enable {
        tailf:info "Console port is used for connecting modem";
        tailf:cli-boolean-no;
        type boolean;
      }

      // line * / modem Dialin
      leaf Dialin {
        tailf:info "Configure line for a modern dial-in modem";
        type empty;
      }

      // line * / modem InOut
      container InOut {
        tailf:info "Configure line for incoming AND outgoing use of modem";
        presence true;
        leaf hangup {
          type empty;
        }
      }

      // line * / modem DTR-active
      leaf DTR-active {
        tailf:info "Leave DTR low unless line has an active incoming connection or EXEC";
        type empty;
      }

      // line * / modem Host
      leaf Host {
        tailf:info "Devices that expect an incoming modem call";
        type empty;
      }

      // line * / modem autoconfigure
      container autoconfigure {
        tailf:info "Automatically configure modem on line";

        // line * / modem autoconfigure discovery
        leaf discovery {
          tailf:info "Attempt to determine modem type automatically";
          type empty;
        }

        // line * / modem autoconfigure type
        leaf type {
          tailf:info "Specify modem type";
          type string {
            tailf:info "WORD;;Modem type";
          }
        }
      }
    }

    // line * / terminal-type
    leaf terminal-type {
      tailf:info "Set the terminal type";
      type string {
        tailf:info "WORD;;Terminal type";
      }
    }

    // line * / exec
    container exec-choice {
      tailf:cli-drop-node-name;
      choice exec-choice {
        // line * / no exec
        default exec;
        leaf exec {
          tailf:info "Configure EXEC";
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }
        // line * / exec prompt
        container exec-conf {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          container exec {
            tailf:cli-incomplete-command;
            tailf:cli-incomplete-no;
            container prompt {
              tailf:info "EXEC prompt";
              leaf timestamp {
                tailf:info "Print timestamps for show commands";
                type empty;
              }
            }
          }
        }
      }
    }

    // line * / exec-timeout
    container exec-timeout {
      tailf:info "Set the EXEC timeout";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf minutes {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<0-35791>;;Timeout in minutes";
        }
        tailf:ned-default-handling report-all;
        default 10;
      }
      leaf seconds {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<0-2147483>;;Timeout in seconds";
        }
        tailf:ned-default-handling report-all;
        default 0;
      }
    }

    // line * / no exec-banner
    leaf exec-banner {
      tailf:info "Enable the display of the EXEC banner";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
      default true;
    }

    // line * / no motd-banner
    leaf motd-banner {
      tailf:info "Enable the display of the MOTD banner";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
      default true;
    }

    // line * / refuse-message
    leaf refuse-message {
      tailf:info "Define a refuse banner";
      tailf:cli-no-value-on-delete;
      type string {
        tailf:info "LINE;;Quoted string. Use \\r\\n for newline. delimeter ^ is added automatically.";
      }
    }

    // line * / vacant-message
    leaf vacant-message {
      tailf:info "Define a vacant banner";
      tailf:cli-no-value-on-delete;
      type string {
        tailf:info "LINE;;Quoted string. Use \\r\\n for newline. delimeter ^ is added automatically.";
      }
    }

    // line * / international
    leaf international {
      tailf:info "Enable international 8-bit character support";
      type empty;
    }

    // line * / timeout login response
    container timeout {
      tailf:info "Timeouts for the line";
      container login {
        tailf:info "Timeouts related to the login sequence";
        leaf response {
          tailf:info "Timeout for any user input during login sequences";
          type uint16 {
            tailf:info "<1-300>;;Timeout in seconds. Default 30";
            range "1..300";
          }
          default 30;
        }
      }
    }

    // line * / session-limit
    leaf session-limit {
      tailf:info "Set maximum number of sessions";
      type uint32 {
        tailf:info "<0-4294967295>;;Maximum number of sessions";
      }
    }

    // line * / session-disconnect-warning
    container session-disconnect-warning {
      tailf:info "Set warning countdown for session-timeout";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf seconds {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<0-4294967295>;;Session timeout warning in seconds";
        }
      }
      leaf message {
        tailf:info "Optional warning message";
        tailf:cli-multi-value;
        type string {
          tailf:info "LINE;;One text line optional warning message";
        }
      }
    }

    // line * / logging
    container logging {
      tailf:info "Modify message logging facilities";
      // line * / logging synchronous
      container synchronous {
        tailf:info "Synchronized message output";
        tailf:cli-delete-when-empty;
        presence true;
        // line * / logging synchronous level
        leaf level {
          tailf:info "Severity level to output asynchronously";
          type union {
            type uint8 {
              tailf:info "<0-7>;;Severity level; lower number for higher severity";
              range "0..7";
            }
            type enumeration {
              enum all {
                tailf:info "Turn off all severity level for asynchronous output";
              }
            }
          }
        }
      }
    }

    // line * / rotary
    leaf rotary {
      tailf:info "Add line to a rotary group";
      type uint8 {
        tailf:info "<0-100>;;Rotary group to add line to";
        range "0..100";
      }
    }

    // line * / login
    container login {
      tailf:info "Enable password checking";
      tailf:cli-delete-when-empty;
      tailf:cli-diff-dependency "../password";
      presence true;

      // line * / login local
      leaf local {
        tailf:info "Local password checking";
        tailf:cli-diff-set-after "/ios:aaa/new-model" {
          tailf:cli-when-target-delete;
        }
        tailf:cli-diff-delete-before "/ios:aaa/new-model" {
          tailf:cli-when-target-set;
        }
        type empty;
      }
    }

    // line * / login authentication
    // line * / login tacacs
    container local-authentication {
      tailf:cli-drop-node-name;
      container login {
        tailf:info "Enable password checking";
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;

        leaf tacacs {
          type empty;
        }

        leaf authentication {
          tailf:info "Authentication parameters.";
          tailf:cli-diff-dependency "/ios:aaa/new-model";
          type union {
            type string {
              tailf:info "WORD;;Use an authentication list with this name.";
            }
            type enumeration {
              enum "default" {
                tailf:info "Use the default authentication list.";
              }
            }
          }
          default "default";
        }
      }
    }

    // line * / autohangup
    leaf autohangup {
      tailf:info "Automatically hangup when last connection closes";
      type empty;
    }

    // line * / autoselect
    container autoselect {
      tailf:info "Set line to autoselect";

      // line * / autoselect durin-login
      leaf during-login {
        tailf:info "Do autoselect at the Username/Password prompt";
        type empty;
      }

      // line * / autoselect ppp
      leaf ppp {
        tailf:info "Set line to allow PPP autoselection";
        type empty;
      }
    }

    // line * / autocommand
    container autocommand {
      tailf:info "Automatically execute an EXEC command";
      leaf command {
        tailf:cli-drop-node-name;
        tailf:cli-multi-value;
        type string {
          tailf:info "LINE;;Appropriate EXEC command";
        }
      }
    }

    // line * / accounting
    container accounting {
      tailf:info "Accounting parameters";

      // line * / accounting exec
      leaf exec {
        tailf:info "For starting an exec (shell)";
        type union {
          type string {
            tailf:info "WORD;;Use an accounting list with this name";
          }
          type enumeration {
            enum "default" {
              tailf:info "Use the default accounting list.";
            }
          }
        }
        default "default";
      }

      // line * / accounting commands *
      list commands {
        tailf:info "For exec (shell) commands.";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key level;
        leaf level {
          type uint8 {
            tailf:info "<0-15>;;Enable level";
            range "0..15";
          }
        }
        leaf name {
          tailf:cli-drop-node-name;
          type union {
            type string {
              tailf:info "WORD;;Use an accounting list with this name";
            }
            type enumeration {
              enum "default" {
                tailf:info "Use the default accounting list";
              }
            }
          }
          default "default";
        }
      }
    }

    // line * / logout-warning
    leaf logout-warning {
      tailf:info "Set Warning countdown for absolute timeout of line";
      tailf:cli-full-command;
      type uint32 {
        tailf:info "<0-4294967295>;;Warning time in seconds. Default 20";
      }
      default 20;
    }

    // line * / ip
    container ip {
      tailf:info "IP options";

      // line * / ip netmask-format
      leaf netmask-format {
        tailf:info "Change display of netmasks";
        type enumeration {
          enum bit-count {
            tailf:info "Display netmask as number of significant bits";
          }
          enum decimal {
            tailf:info "Display netmask in dotted decimal";
          }
          enum hexadecimal {
            tailf:info "Display netmask in hexadecimal";
          }
        }
        default bit-count;
      }
    }

    // line * / ipv6 access-class *
    container ipv6 {
      tailf:info "IPv6 options";
      list access-class {
        tailf:info "Filter connections based on an IPv6 access list";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-diff-dependency "/ios:ipv6/access-list";
        key direction;
        leaf direction {
          type enumeration {
            enum "in" {
              tailf:info "Filter incoming connections";
            }
            enum "out" {
              tailf:info "Filter outgoing connections";
            }
          }
        }
        leaf access-list {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type exp-ip-acl-type;
        }
      }

      // line * / ipv6 access-class * vrfname *
      container access-class-vrf {
        tailf:cli-drop-node-name;
        list access-class {
          tailf:info "Filter connections based on an IPv6 access list";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-diff-dependency "/ios:ipv6/access-list";
          key "direction vrfname";
          leaf access-list {
            tailf:cli-drop-node-name;
            tailf:cli-prefix-key;
            type exp-ip-acl-type;
          }
          leaf direction {
            type enumeration {
              enum "in" {
                tailf:info "Filter incoming connections";
              }
              enum "out" {
                tailf:info "Filter outgoing connections";
              }
            }
          }
          leaf vrfname {
            tailf:info "Access list is applied for given VRFs";
            tailf:cli-expose-key-name;
            tailf:non-strict-leafref {
              path "/ios:vrf/definition/name";
            }
            type string {
              tailf:info "WORD;;Vrfname";
            }
          }
        }
      }
    }

    // line * / authorization exec
    container authorization {
      tailf:info "Authorization parameters";

      // line * / authorization exec
      leaf exec {
        tailf:info "For starting an exec (shell)";
        tailf:cli-diff-dependency "/ios:aaa/new-model";
        type union {
          type enumeration {
            enum "default" {
              tailf:info "Use the default authorization list";
            }
          }
          type string {
            tailf:info "WORD;;Use an authorization list with this name";
          }
        }
        default "default";
      }

      // line * / authorization commands *
      list commands {
        tailf:info "For exec (shell) commands.";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        tailf:cli-diff-dependency "/ios:aaa/new-model";
        key level;
        leaf level {
          type uint8 {
            tailf:info "<0-15>;;Enable level";
            range "0..15";
          }
        }
        leaf name {
          tailf:cli-drop-node-name;
          type union {
            type string {
              tailf:info "WORD;;Use an authorization list with this name";
            }
            type enumeration {
              enum "default" {
                tailf:info "Use the default authorization list";
              }
            }
          }
          default "default";
        }
      }
    }

    // line * / history size
    container history {
      tailf:info "Enable and control the command history function";
      leaf size {
        tailf:info "Set history buffer size";
        type uint16 {
          tailf:info "<0-256>;;Size of history buffer. Default 10";
          range "0..256";
        }
        default 10;
      }
    }

    // line * / full-help
    leaf full-help {
      tailf:info "Provide help to unprivileged user";
      type empty;
    }

    // line * / password
    container password {
      tailf:info "Set a password";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      uses password-grouping {
        refine "secret" {
          cli:secret " password <SECRET>";
        }
      }
    }

    // line * / privilege level
    container privilege {
      tailf:info "Change privilege level for line";
      leaf level {
        tailf:info "Assign default privilege level for line";
        type uint8 {
          tailf:info "<0-15>;;Default privilege level for line. Default 1";
          range "0..15";
        }
        default 1;
      }
    }

    // line * / session-timeout
    container session-timeout {
      tailf:info "Set interval for closing connection when there is no input traffic";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf session-timeout-value {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<0-35791>;;Session timeout interval in minutes";
          range "0..35791";
        }
      }
      leaf output {
        tailf:info "Include output traffic as well as input traffic";
        type empty;
      }
    }

    // line * / stopbits
    leaf stopbits {
      tailf:info "Set async line stop bits";
      type enumeration {
        enum "1" {
          tailf:info "One stop bit";
        }
        enum "1.5" {
          tailf:info "One and one-half stop bits";
        }
        enum "2" {
          tailf:info "Two stop bits";
        }
      }
    }

    // line * / telnet
    container telnet {
      tailf:info "Telnet protocol-specific configuration";

      // line * / telnet break-on-ip
      leaf break-on-ip {
        tailf:info "Send break signal when interrupt is received";
        type empty;
      }

      // line * / telnet transparent
      leaf transparent {
        tailf:info "Send a CR as a CR followed by a NULL instead of a CR followed by a LF";
        type empty;
      }
    }

    // line * / transport
    container transport {
      tailf:info "Define transport protocols for line";
      tailf:cli-incomplete-no;

      // line * / transport input *
      leaf-list input {
        tailf:info "Define which protocols to use when connecting to the terminal server";
        tailf:cli-flat-list-syntax;
        tailf:cli-replace-all;
        //tailf:cli-no-value-on-delete;
        ios:delete-syntax " default transport input";
        type enumeration {
          enum all {
            tailf:info "All protocols";
          }
          enum none {
            tailf:info "No protocols";
          }
          enum ssh {
            tailf:info "TCP/IP SSH protocol";
          }
          enum telnet {
            tailf:info "TCP/IP Telnet protocol";
          }
          enum lat {
            tailf:info "DEC LAT protocol";
          }
          enum pad {
            tailf:info "X.3 PAD";
          }
          enum udptn {
            tailf:info "UDPTN async via UDP protocol";
          }
          enum rlogin {
            tailf:info "Unix rlogin protocol";
          }
          enum lapb-ta {
            tailf:info "LAPB Terminal Adapter";
          }
          enum mop {
            tailf:info "DEC MOP Remote Console Protocol  ";
          }
          enum v120 {
            tailf:info "Async over ISDN";
          }
          enum acercon {}
          enum nasi {}
        }
      }

      // line * / transport output *
      leaf-list output {
        tailf:info "Define which protocols to use for outgoing connections";
        tailf:cli-flat-list-syntax;
        tailf:cli-replace-all;
        //tailf:cli-no-value-on-delete;
        ios:delete-syntax " default transport output";
        type enumeration {
          enum all {
            tailf:info "All protocols";
          }
          enum none {
            tailf:info "No protocols";
          }
          enum ssh {
            tailf:info "TCP/IP SSH protocol";
          }
          enum telnet {
            tailf:info "TCP/IP Telnet protocol";
          }
          enum lat {
            tailf:info "DEC LAT protocol";
          }
          enum pad {
            tailf:info "X.3 PAD";
          }
          enum udptn {
            tailf:info "UDPTN async via UDP protocol";
          }
          enum rlogin {
            tailf:info "Unix rlogin protocol";
          }
          enum lapb-ta {
            tailf:info "LAPB Terminal Adapter";
          }
          enum mop {
            tailf:info "DEC MOP Remote Console Protocol  ";
          }
          enum v120 {
            tailf:info "Async over ISDN";
          }
          enum acercon {}
          enum nasi {}
        }
      }

      // line * / transport preferred *
      leaf preferred {
        tailf:info "Specify the preferred protocol to use";
        //tailf:cli-no-value-on-delete;
        ios:delete-syntax " default transport preferred";
        type enumeration {
          enum none {
            tailf:info "No protocols";
          }
          enum ssh {
            tailf:info "TCP/IP SSH protocol";
          }
          enum telnet {
            tailf:info "TCP/IP Telnet protocol";
          }
        }
      }
    }

    // line * / speed
    leaf speed {
      tailf:info "Set the transmit and receive speeds";
      tailf:cli-full-command;
      type uint32 {
        tailf:info "<0-4294967295>;;Transmit and receive speeds. Default 9600";
      }
      default 9600;
    }

    // line * / rxspeed
    leaf rxspeed {
      tailf:info "Set the receive speed";
      type uint32 {
        tailf:info "<0-4294967295>;;Receive speed";
      }
    }

    // line * / txspeed
    leaf txspeed {
      tailf:info "Set the transmit speed";
      type uint32 {
        tailf:info "<0-4294967295>;;Transmit speed";
      }
    }

    // line * / flowcontrol
    container flowcontrol {
      tailf:info "Set the flow control";
      choice flowcontrol-choice {

        // line * / flowcontrol hardware
        container hardware {
          tailf:info "Set hardware flow control";
          presence true;
          leaf out {
            type empty;
          }
        }

        // line * / flowcontrol software
        container software {
          tailf:info "Set software flow control";
          presence true;
        }

        // line * / flowcontrol NONE
        container none {
          tailf:cli-drop-node-name;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf mode {
            tailf:cli-drop-node-name;
            type enumeration {
              enum NONE {
                tailf:info "Set no flow control";
              }
            }
            default NONE;
          }
          leaf lock {
            tailf:info "Ignore network host requests to change flow control";
            ios:delete-syntax " no flowcontrol NONE";
            type empty;
          }
        }
      }
    }

    // line * / length
    leaf length {
      tailf:info "Set number of lines on a screen";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<0-512>;;Number of lines on screen (0 for no pausing). Default 24";
        range "0..512";
      }
      default 24;
    }

    // line * / width
    leaf width {
      tailf:info "Set width of the display terminal";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "Number of characters on a screen line. Default 80";
        range "0..512";
      }
      default 80;
    }

    // line * / media-type rj45
    container media-type {
      tailf:info "Console connection media type";
      leaf rj45 {
        tailf:info "Console connection set to RJ45";
        type empty;
      }
    }
  }

  // queue-size-grouping
  grouping queue-size-grouping {
    leaf queue-size-1 {
      tailf:cli-drop-node-name;
      type uint8 {
        tailf:info "<1-100>;;enter percent of queue size between 1 and 100";
        range "1..100";
      }
    }
    leaf queue-size-2 {
      tailf:cli-drop-node-name;
      type uint8 {
        tailf:info "<1-100>;;enter percent of queue size between 1 and 100";
        range "1..100";
      }
    }
    leaf queue-size-3 {
      tailf:cli-drop-node-name;
      type uint8 {
        tailf:info "<1-100>;;enter percent of queue size between 1 and 100";
        range "1..100";
      }
    }
    leaf queue-size-4 {
      tailf:cli-drop-node-name;
      type uint8 {
        tailf:info "<1-100>;;enter percent of queue size between 1 and 100";
        range "1..100";
      }
    }
    leaf queue-size-5 {
      tailf:cli-drop-node-name;
      type uint8 {
        tailf:info "<1-100>;;enter percent of queue size between 1 and 100";
        range "1..100";
      }
    }
    leaf queue-size-6 {
      tailf:cli-drop-node-name;
      type uint8 {
        tailf:info "<1-100>;;enter percent of queue size between 1 and 100";
        range "1..100";
      }
    }
    leaf queue-size-7 {
      tailf:cli-drop-node-name;
      type uint8 {
        tailf:info "<1-100>;;enter percent of queue size between 1 and 100";
        range "1..100";
      }
    }
    leaf queue-size-8 {
      tailf:cli-drop-node-name;
      type uint8 {
        tailf:info "<1-100>;;enter percent of queue size between 1 and 100";
        range "1..100";
      }
    }
  }

  // grouping interface-common-pre-grouping
  grouping interface-common-pre-grouping {

    // interface * / mac-address
    leaf mac-address {
      tailf:info "Manually set interface MAC address";
      type string {
        tailf:info "H.H.H;;MAC address";
      }
    }

    // interface * / description
    leaf description {
      tailf:info "Interface specific description";
      tailf:cli-multi-value;
      tailf:cli-preformatted;
      tailf:cli-no-value-on-delete;
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;Up to 240 characters describing this interface";
        length "0..240";
      }
    }

    // interface * / backup
    container backup {
      tailf:info "Modify backup parameters";

      // interface * / backup delay
      container delay {
        tailf:info "Delays before backup line up or down transitions";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf enable-delay-period  {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type union {
            type uint32 {
              tailf:info "<0-4294967294>;;Seconds";
            }
            type enumeration {
              enum never {
                tailf:info "Never activate the backup line";
              }
            }
          }
        }
        leaf disable-delay-period {
          tailf:cli-drop-node-name;
          type union {
            type uint32 {
              tailf:info "<0-4294967294>;;Seconds";
            }
            type enumeration {
              enum never {
                tailf:info "Never deactivate the backup line";
              }
            }
          }
        }
      }

      // interface * / backup interface
      container interface {
        tailf:info "Configure an interface as a backup";
        uses interface-name-grouping;
      }
    }

    // interface * / glbp *
    list glbp {
      tailf:info "Gateway Load Balancing Protocol interface commands";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key group-number;
      leaf group-number {
        type uint16 {
          tailf:info "<0-1023>;;Group number";
          range "0..1023";
        }
      }

      // interface * / glbp * ip
      leaf ip {
        tailf:info "Enable group and set virtual IP address";
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Virtual IP address";
        }
      }

      // interface * / glbp * ip * secondary
      container ip-secondary-list {
        tailf:cli-drop-node-name;
        list ip {
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          key address;
          leaf address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Virtual IP address";
            }
          }
          leaf secondary {
            tailf:info "Make this IP address a secondary address";
            type empty;
          }
        }
      }

      // interface * / glbp * timers
      container timers {
        tailf:info "Adjust GLBP timers";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        container hellotime {
          tailf:cli-drop-node-name;
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          choice hellotime-choice {
            leaf seconds {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint8 {
                tailf:info "<1-60>;;Hello interval in seconds";
                range "1..60";
              }
            }
            leaf msec {
              tailf:info "Specify hello interval in milliseconds";
              tailf:cli-incomplete-command;
              type uint32 {
                tailf:info "<50-60000>;;Hello interval in milliseconds";
                range "50..60000";
              }
            }
          }
        }
        container holdtime {
          tailf:cli-drop-node-name;
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          choice holdtime-choice {
            leaf seconds {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<1-180>;;Hold time in seconds";
                range "1..180";
              }
            }
            leaf msec {
              tailf:info "Specify hold time in milliseconds";
              type uint32 {
                tailf:info "<70-180000>;;Hello interval in milliseconds";
                range "70..180000";
              }
            }
          }
        }
      }

      // interface * / glbp * priority
      leaf priority {
        tailf:info "Priority level";
        type uint8 {
          tailf:info "<1-255>;;Priority value";
          range "1..255";
        }
      }

      // interface * / glbp * preempt
      container preempt {
        tailf:info "Overthrow lower priority designated routers";
        tailf:cli-delete-when-empty;
        presence true;
        container delay {
          tailf:info "Wait before preempting";
          leaf minimum {
            tailf:info "Delay at least this long";
            type uint32 {
              tailf:info "<0-3600>;;Number of seconds for minimum delay";
              range "0..3600";
            }
          }
        }
      }

      // interface * / glbp * load-balancing
      leaf load-balancing {
        tailf:info "Load balancing method";
        type enumeration {
          enum host-dependent {
            tailf:info "Load balance equally, source MAC determines forwarder choice";
          }
          enum round-robin {
            tailf:info "Load balance equally using each forwarder in turn";
          }
          enum weighted {
            tailf:info "Load balance in proportion to forwarder weighting";
          }
        }
        default round-robin;
      }

      // interface * / glbp * authentication
      container authentication {
        tailf:info "Authentication method";
        //md5   MD5 authentication
        leaf text {
          tailf:info "Plain text authentication";
          type string {
            tailf:info "WORD;;Text authentication string";
          }
        }
      }

      // interface * / glbp * weighting track *
      container weighting {
        tailf:info "Gateway weighting and tracking";
        list track {
          tailf:info "Interface tracking";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key id;
          leaf id {
            type uint16 {
              tailf:info "<1-1000>;;Tracked object";
            }
          }
          leaf decrement {
            tailf:info "Weighting decrement";
            type uint8 {
              tailf:info "<1-255>;;Decrement value";
              range "1..255";
            }
          }
        }
      }
    }
  }

  // interface * / ospfv3
  // interface * / ospfv3 * ipv4
  // interface * / ospfv3 * ipv6
  grouping interface-ospfv3-grouping {

    // interface * / ospfv3 area
    container area {
      tailf:info "Set the OSPF area ID";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf id {
        tailf:cli-drop-node-name;
        tailf:cli-reset-container;
        type union {
          type uint32 {
            tailf:info "<0-4294967295>;;OSPF area ID as a decimal value";
          }
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;OSPF area ID in IP address format";
          }
        }
      }
      leaf instance {
        tailf:info "Set the OSPF instance";
        type uint8 {
          tailf:info "<0-31>;;Instance ID";
          range "0..31";
        }
      }
    }

    // interface * / ospfv3 priority
    leaf priority {
      tailf:info "Router priority";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<0-255>;;Priority";
      }
    }

    // interface * / ospfv3 cost
    leaf cost {
      tailf:info "Route cost of this interface";
      type uint16 {
        tailf:info "<1-65535>;;Route cost of this interface";
        range "1..65535";
      }
    }

    // interface * / ospfv3 authentication
    container authentication {
      tailf:info "Enable authentication";
      choice authentication-choice {
        leaf key-chain {
          tailf:info "Use a key-chain for cryptographic authentication keys";
          tailf:non-strict-leafref {
            path "/ios:key/chain/name";
          }
          type string {
            tailf:info "WORD;;Key-chain name";
          }
        }
        leaf null {
          tailf:info "Use no authentication";
          type empty;
        }
      }
    }

    // interface * / ospfv3 flood-reduction
    container flood-reduction {
      tailf:info "OSPF Flood Reduction";
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      presence true;
      leaf disable {
        tailf:info "Disable Flood Reduction on this interface";
        type empty;
      }
    }

    // interface * / ospfv3 bfd
    container bfd {
      tailf:info "Enable BFD on this interface";
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      presence true;
      choice bfd-choice {
        leaf disable {
          tailf:info "Disable BFD on this interface";
          type empty;
        }
        leaf strict-mode {
          tailf:info "Enable BFD in strict mode";
          type empty;
        }
      }
    }

    // interface * / ospfv3 network
    container network {
      tailf:info "Network type";
      choice network-choice {
        container point-to-multipoint {
          tailf:info "Specify OSPF point-to-multipoint network";
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          presence true;
          leaf non-broadcast {
            tailf:info "Specify OSPF NBMA network";
            type empty;
          }
        }
        leaf point-to-point {
          tailf:info "Specify OSPF point-to-point network";
          type empty;
        }
        leaf broadcast {
          tailf:info "Specify OSPF broadcast multi-access network";
          type empty;
        }
        leaf non-broadcast {
          tailf:info "Specify OSPF NBMA network";
          type empty;
        }
        leaf manet {
          tailf:info "Specify MANET OSPF interface type";
          type empty;
        }
      }
    }

    // interface * / ospfv3 hello-interval
    leaf hello-interval {
      tailf:info "Time between HELLO packets";
      type uint16 {
        tailf:info "<1-65535>;;Seconds";
        range "1..65535";
      }
    }

    // interface * / ospfv3 dead-interval
    leaf dead-interval {
      tailf:info "Interval after which a neighbor is declared dead";
      type uint16 {
        tailf:info "<1-65535>;;Seconds";
        range "1..65535";
      }
    }
  }

  // interface * / storm-control broadcast
  // interface * / storm-control multicast
  // interface * / storm-control unicast
  grouping interface-storm-control-grouping {

    // interface * / storm-control broadcast level bps
    // interface * / storm-control broadcast level pps
    container level-bps-pps {
      tailf:cli-drop-node-name;
      container level {
        tailf:info "Set storm suppression level on this interface";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        choice level-choice {
          case bps {
            leaf bps {
              tailf:info "Enter suppression level in bits per second";
              type string {
                tailf:info "<0.0 - 10000000000.0>[k|m|g];;Enter rising threshold";
              }
            }
            leaf bps-falling {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "<0.0 - 10000000000.0>[k|m|g];;Enter falling threshold";
              }
            }
          }
          case pps {
            leaf pps {
              tailf:info "Enter suppression level in packets per second";
              type string {
                tailf:info "<0.0 - 10000000000.0>[k|m|g];;Enter rising threshold";
              }
            }
            leaf pps-falling {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "<0.0 - 100000000000.0>[k|m|g];;Enter falling threshold";
              }
            }
          }
        }
      }
    }

    // interface * / storm-control broadcast level <rising-threshold> <falling-threshold>
    container level-threshold {
      tailf:cli-drop-node-name;
      container level {
        tailf:info "Set storm suppression level on this interface";
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        leaf rising {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type decimal64 {
            tailf:info "<0.00 - 100.00>;;Enter rising threshold";
            fraction-digits 2;
            range "0..100";
          }
        }
        leaf falling {
          tailf:cli-drop-node-name;
          type decimal64 {
            tailf:info "<0.00 - 100.00>;;Enter falling threshold";
            fraction-digits 2;
            range "0..100";
          }
        }
      }
    }
  }


  // interface * / wrr-queue
  // interface * / rcv-queue
  grouping interface-queue-grouping {

    // interface * / wrr-queue bandwidth
    // interface * / rcv-queue bandwidth
    container bandwidth {
      tailf:info "Configure minimum bandwidth with weights or percentages";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      choice bandwidth-choice {
        case a {
          leaf weight-1 {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<0-255>;;enter bandwidth weight";
              range "0..255";
            }
          }
          leaf weight-2 {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<0-255>;;enter bandwidth weight";
              range "0..255";
            }
          }
          leaf weight-3 {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<0-255>;;enter bandwidth weight";
              range "0..255";
            }
          }
          leaf weight-4 {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<0-255>;;enter bandwidth weight";
              range "0..255";
            }
          }
          leaf weight-5 {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<0-255>;;enter bandwidth weight";
              range "0..255";
            }
          }
          leaf weight-6 {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<0-255>;;enter bandwidth weight";
              range "0..255";
            }
          }
          leaf weight-7 {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<0-255>;;enter bandwidth weight";
              range "0..255";
            }
          }
        }
        case b {
          container percent {
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf percent-1 {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<0-100>;;enter bandwidth percent";
                range "0..100";
              }
            }
            leaf percent-2 {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<0-100>;;enter bandwidth percent";
                range "0..100";
              }
            }
            leaf percent-3 {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<0-100>;;enter bandwidth percent";
                range "0..100";
              }
            }
            leaf percent-4 {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<0-100>;;enter bandwidth percent";
                range "0..100";
              }
            }
            leaf percent-5 {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<0-100>;;enter bandwidth percent";
                range "0..100";
              }
            }
            leaf percent-6 {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<0-100>;;enter bandwidth percent";
                range "0..100";
              }
            }
            leaf percent-7 {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<0-100>;;enter bandwidth percent";
                range "0..100";
              }
            }
          }
        }
      }
    }

    // interface * / wrr-queue dscp-map *
    // interface * / rcv-queue dscp-map *
    list dscp-map {
      tailf:info "Configure dscp-map for a queue threshold";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key "queue threshold";
      leaf queue {
        type uint8 {
          tailf:info "<1-7>;;enter dscp-map queue id";
        }
      }
      leaf threshold {
        type uint8 {
          tailf:info "<1-4>;;enter dscp-map threshold id";
        }
      }
      list values {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-show-long-obu-diffs;
        ordered-by user;
        key value;
        leaf value {
          tailf:cli-multi-word-key;
          type string;
        }
      }
    }

    // interface * / wrr-queue cos-map *
    // interface * / rcv-queue cos-map *
    list cos-map {
      tailf:info "Configure cos-map for a queue threshold";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      key "queue-id threshold-id";
      leaf queue-id {
        type uint8 {
          tailf:info "<1-7>;;enter cos-map queue id";
          range "1..7";
        }
      }
      leaf threshold-id {
        type uint8 {
          tailf:info "<1-8>;;enter cos-map threshhold id";
          range "0..8";
        }
      }
      leaf-list cos-values {
        tailf:cli-drop-node-name;
        tailf:cli-flat-list-syntax;
        ios:max-values-output "4 :: 1"; // values start after 4 words, max 1 per line
        //FIXME: rcv-queue
        ios:ned-defaults "if-wrr-queue-cos-map";
        max-elements 8;
        type uint8 {
          tailf:info "<0-7>;;cos values separated by spaces (up to 8 values total)";
          range "0..7";
        }
      }
    }

    // interface * / wrr-queue queue-limit
    // interface * / rcv-queue queue-limit
    container queue-limit {
      tailf:info "Configure queue-limit";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf weight-a {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<0-100>;;enter queue size weight";
          range "0..100";
        }
      }
      leaf weight-b {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<0-100>;;enter queue size weight";
          range "0..100";
        }
      }
      leaf weight-c {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<0-100>;;enter queue size weight";
          range "0..100";
        }
      }
      leaf weight-d {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<0-100>;;enter queue size weight";
          range "0..100";
        }
      }
      leaf weight-e {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<0-100>;;enter queue size weight";
          range "0..100";
        }
      }
      leaf weight-f {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<0-100>;;enter queue size weight";
          range "0..100";
        }
      }
      leaf weight-g {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<0-100>;;enter queue size weight";
          range "0..100";
        }
      }
    }

    // interface * / wrr-queue random-detect
    // interface * / rcv-queue random-detect
    container random-detect {
      tailf:info "Configure random-detect";

      // interface * / wrr-queue random-detect max-threshold *
      list max-threshold {
        tailf:info "Max threshold";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key id;
        leaf id {
          type uint8 {
            tailf:info "<1-3>;;enter queue id";
            range "1..3";
          }
        }
        uses queue-size-grouping;
      }

      // interface * / wrr-queue random-detect min-threshold *
      list min-threshold {
        tailf:info "Min threshold";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key id;
        leaf id {
          type uint8 {
            tailf:info "<1-3>;;enter queue id";
            range "1..3";
          }
        }
        uses queue-size-grouping;
      }
    }

    // interface * / wrr-queue threshold *
    // interface * / rcv-queue threshold *
    list threshold {
      tailf:info "Configure queue tail-drop thresholds";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      key id;
      leaf id {
        type uint8 {
          tailf:info "<1-7>;;enter queue id";
          range "1..7";
        }
      }
      uses queue-size-grouping;
    }

    // interface * / wrr-queue min-reserve *
    // interface * / rcv-queue min-reserve *
    list min-reserve {
      tailf:info "Configure min-reserve level";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      key id;
      leaf id {
        type uint8 {
          tailf:info "<1-4>;;queue id";
          range "1..4";
        }
      }
      leaf level {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-8>;;min-reserve level";
          range "1..8";
        }
      }
    }
  }


  // grouping interface-common-grouping
  grouping interface-common-grouping {

    // interface * / arp
    container arp {
      tailf:info "Set arp type (arpa, probe, snap), timeout, log options or packet priority";

      // interface * / arp timeout
      leaf timeout {
        tailf:info "Set ARP cache timeout";
        tailf:cli-full-command;
        type uint32 {
          tailf:info "<0-2147483>;;Seconds. Default 14400";
          range "0..2147483";
        }
        default 14400;
      }

      // interface * / arp frame-relay
      leaf frame-relay {
        tailf:info "Enable ARP for a frame relay interface";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
      }

      // interface * / arp authorized
      leaf authorized {
        tailf:info "Only allow internal authorized ARP entry";
        type empty;
      }
    }

    // interface * / access-session
    container access-session {
      tailf:info "Access Session specific Interface Configuration Commands";

      // interface * / access-session host-mode
      leaf host-mode {
        tailf:info "Set the Host mode for authentication on this interface";
        type enumeration {
          enum multi-auth {
            tailf:info "MULTIPLE AUTHENTICATION Mode";
          }
          enum multi-domain {
            tailf:info "Multiple Domain Mode";
          }
          enum multi-host {
            tailf:info "Multiple Host Mode";
          }
          enum single-host {
            tailf:info "Single Host Mode";
          }
        }
        default multi-auth;
      }

      // interface * / access-session control-direction
      leaf control-direction {
        tailf:info "Set the control-direction on the interface";
        type enumeration {
          enum both {
            tailf:info "Control traffic in BOTH directions";
          }
          enum in {
            tailf:info "Control inbound traffic only";
          }
        }
        default both;
      }

      // interface * / access-session closed
      leaf closed {
        tailf:info "Enable closed access on port (disabled by default, i.e. open access)";
        type empty;
      }

      // interface * / access-session port-control
      leaf port-control {
        tailf:info "Set the port-control value";
        type enumeration {
          enum auto {
            tailf:info "PortState set to automatic";
          }
          enum force-authorized {
            tailf:info "PortState set to AUTHORIZED";
          }
          enum force-unauthorized {
            tailf:info "PortState set to UnAuthorized";
          }
        }
        default force-authorized;
      }
    }

    // interface * / mab
    container mab {
      tailf:info "MAC Authentication Bypass Interface Config Commands";
      presence true;
      leaf eap {
        tailf:info "Use EAP authentication for MAC Auth Bypass";
        type empty;
      }
    }

    // interface * / medium
    leaf medium {
      tailf:info "Configures the interface as point-to-point";
      type enumeration {
        enum "p2p";
      }
    }

    // interface * / fair-queue
    container fair-queue {
      tailf:info "Enable Fair Queuing on an Interface";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      presence true;
      leaf congestive-discard-threshold {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<1-4096>;;Congestive Discard Threshold";
        }
      }
      leaf dynamic-queues {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<16-4096>;;Number Dynamic Conversation Queues";
        }
      }
      leaf reservable-queues {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<0-1000>;;Number Reservable Conversation Queues";
        }
      }
    }

    // interface * / flowcontrol
    container flowcontrol {
      tailf:info "Configure flow operation.";

      // interface * / no flowcontrol bidirectional
      leaf bidirectional {
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // interface * / flowcontrol receive
      leaf receive {
        tailf:info "Configure receiving flow operation";
        type enumeration {
          enum desired {
            tailf:info "Allow but do not require flow-control packets on port";
          }
          enum off {
            tailf:info "Disable flow-control packets on port";
          }
          enum on {
            tailf:info "Enable flow-control packets on port";
          }
        }
      }

      // interface * / flowcontrol send
      leaf send {
        tailf:info "Configure sending flow operation";
        type enumeration {
          enum desired {
            tailf:info "Allow but do not require flow-control packets on port";
          }
          enum off {
            tailf:info "Disable flow-control packets on port";
          }
          enum on {
            tailf:info "Enable flow-control packets on port";
          }
        }
      }
    }

    // interface * / traffic-shape
    container traffic-shape {
      tailf:info "Enable Traffic Shaping on an Interface or Sub-Interface";

      // interface * / traffic-shape rate
      container rate {
        tailf:info "configure token bucket: CIR (bps) [Bc (bits) [Be (bits)]]";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf bit-rate {
          tailf:cli-drop-node-name;
          tailf:cli-diff-dependency "../../group/access-list" {
            tailf:cli-trigger-on-set;
          }
          type uint32 {
            tailf:info "<8000-100000000>;;Target Bit Rate (bits per second)";
          }
        }
        leaf burst-size {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<0-100000000>;;bits per interval, sustained";
            range "0..100000000";
          }
        }
        leaf excess-burst-size {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<0-100000000>;;bits per interval, excess in first interval";
            range "0..100000000";
          }
        }
        leaf max-buffers {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-4096>;;Set buffer limit";
            range "1..4096";
          }
        }
      }

      // interface * / traffic-shape group *
      list group {
        tailf:info "configure token bucket: group <access-list> CIR (bps) [Bc (bits) [Be (bits)]] ";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        key access-list;
        leaf access-list {
          tailf:cli-diff-dependency "../../rate/bit-rate" {
            tailf:cli-trigger-on-set;
          }
          type uint16 {
            tailf:info "<1-2799>;;selecting Access list";
            range "1..2799";
          }
        }
        leaf bit-rate {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<8000-100000000>;;Target Bit Rate (bits per second)";
          }
        }
        leaf burst-size {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<0-100000000>;;bits per interval, sustained";
            range "0..100000000";
          }
        }
        leaf excess-burst-size {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<0-100000000>;;bits per interval, excess in first interval";
            range "0..100000000";
          }
        }
        leaf max-buffers {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-4096>;;Set buffer limit";
            range "1..4096";
          }
        }
      }
    }

    // interface * / keepalive
    choice keepalive-choice {
      // interface * / no keepalive
      leaf keepalive {
        tailf:info "Enable keepalive";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }
      // interface * / keepalive <period>
      container keepalive-period {
        tailf:cli-drop-node-name;
        leaf keepalive {
          tailf:info "Enable keepalive";
          type uint16 {
            tailf:info "<0-32767>;;Keepalive period (default 10 seconds)";
            range "0..32767";
          }
          default 10;
        }
      }
      // interface * / keepalive <period> [retries]
      container keepalive-period-retries {
        tailf:cli-drop-node-name;
        container keepalive {
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf period {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<0-32767>;;Keepalive period (default 10 seconds)";
              range "0..32767";
            }
          }
          leaf retries {
            tailf:cli-drop-node-name;
            type uint8 {
              range "1..255";
            }
          }
        }
      }
    }

    // interface * / snmp
    container snmp {
      tailf:info "Modify SNMP interface parameters";

      // interface * / snmp ifindex persist
      container ifindex {
        tailf:info "Persist ifindex for the interface";
        leaf persist {
          tailf:info "Enable/Disable ifIndex persistence ";
          type empty;
        }
      }

      // interface * / snmp trap
      container trap {
        tailf:info "Allow a specific SNMP trap";

        // interface * / no snmp trap link-status
        leaf link-status {
          tailf:info "Allow SNMP LINKUP and LINKDOWN traps";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          ios:trim-when-list "create";
          type boolean;
          default true;
        }

        // interface * / snmp trap link-status permit duplicates
        container link-status-capas {
          tailf:cli-drop-node-name;
          container link-status {
            tailf:info "Allow SNMP LINKUP and LINKDOWN traps";
            container permit {
              tailf:info "Permit the following capability";
              leaf duplicates {
                tailf:info "Permit duplicate SNMP LINKUP and LINKDOWN traps";
                type empty;
              }
            }
          }
        }

        // interface * / snmp trap mac-notification change
        container mac-notification {
          tailf:info "MAC Address notification for the interface";
          container change {
            tailf:info "Enable Mac Address notification feature for this port";
            // interface * / snmp trap mac-notification change added
            leaf added {
              tailf:info "Enable Mac Address added notification for this port";
              type empty;
            }
            // interface * / snmp trap mac-notification change removed
            leaf removed {
              tailf:info "Enable Mac Address removed notification for this port";
              type empty;
            }
          }
        }
      }
    }

    // interface * / flow-sampler
    container flow-sampler {
      tailf:info "Attach flow sampler to the interface";
      leaf name {
        tailf:cli-drop-node-name;
        tailf:non-strict-leafref {
          path "/ios:flow-sampler-map/name";
        }
        type string {
          tailf:info "WORD;;Name of the flow sampler";
        }
      }
      container egress {
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf name {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          tailf:non-strict-leafref {
            path "/ios:flow-sampler-map/name";
          }
          type string {
            tailf:info "WORD;;Name of the flow sampler";
          }
        }
        leaf egress {
          tailf:info "Egress flow sampler";
          type empty;
        }
      }
    }

    // interface * / lldp
    container lldp {
      tailf:info "LLDP interface subcommands";

      // interface * / no lldp transmit
      leaf transmit {
        tailf:info "Enable LLDP transmission on interface";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // interface * / no lldp receive
      leaf receive {
        tailf:info "Enable LLDP reception on interface";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }
    }

    // interface * / bfd
    container bfd {
      tailf:info "BFD interface configuration commands";

      // interface * / bfd interval
      container interval {
        tailf:info "Transmit interval between BFD packets";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf msecs {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<15-9000>;;Milliseconds";
          }
        }
        leaf min_rx {
          tailf:info "Minimum receive interval capability";
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<15-9000>;;Milliseconds";
          }
        }
        leaf multiplier {
          tailf:info "Multiplier value used to compute holddown";
          type uint8 {
            tailf:info "<3-50>;;value used to multiply the interval";
            range "3..50";
          }
        }
      }

      // interface * / no bfd echo
      leaf echo {
        tailf:info "Use echo adjunct as bfd detection mechanism";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // interface * / bfd template
      leaf template {
        tailf:info "BFD template";
        tailf:cli-full-command;
        tailf:cli-diff-dependency "/ios:bfd/fast-timers-on-slow-interface";
        type string {
          tailf:info "WORD;;bfd template name";
        }
      }
    }

    // interface * / bandwidth
    container bandwidth {
      tailf:info "Set bandwidth informational parameter";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf inherit {
        tailf:cli-optional-in-sequence;
        tailf:info "Specify how bandwidth is inherited";
        type empty;
      }
      leaf kilobits {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<1-200000000>;;Bandwidth in kilobits";
        }
      }
    }

    // interface * / cdp
    container cdp {
      tailf:info "CDP interface subcommands";

      // interface * / no cdp enable
      //  Note: Some devices show 'cdp enable', use cdp-read-inject  ned-setting
      leaf enable {
        tailf:info "Enable CDP on interface";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // interface * / cdp tlv
      container tlv {
        tailf:info "Enable exchange of specific tlv information";
        container app {
          tailf:info "Enable/Configure Application TLV";
          tailf:cli-display-separated;
          tailf:cli-compact-syntax;
          tailf:cli-reset-container;
          tailf:cli-sequence-commands;
          presence true;
          leaf tlvtype {
            tailf:info "Configure APP TLV";
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "Configure App TLV Type information";
              range "1001..65535";
            }
          }
          leaf value {
            tailf:info "Configure App TLV Value information";
            type string {
              tailf:info "WORD;;Configure App TLV value information";
            }
          }
        }
        leaf server-location {
          tailf:info "Enable CDP location server on interface";
          tailf:cli-full-command;
          type empty;
        }
        leaf location {
          tailf:info "Exchange location information";
          tailf:cli-full-command;
          type empty;
        }
        // log
      }

      // interface * / cdp filter-tlv-list
      leaf filter-tlv-list {
        tailf:info "Apply tlv list filter on interface";
        tailf:cli-remove-before-change;
        tailf:non-strict-leafref {
          path "/ios:cdp/tlv-list/name";
        }
        type string {
          tailf:info "WORD;;Filter tlv-list";
        }
      }
    }

    // interface * / no vtp
    leaf vtp {
      tailf:info "Enable VTP on this interface";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
      default true;
    }

    // interface * / mop
    container mop {
      tailf:info "DEC MOP server commands";

      // interface * / no mop enabled
      leaf xenabled {
        tailf:alt-name enabled;
        tailf:info "Enable MOP for interface";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // interface * / no mop sysid
      leaf sysid {
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }
    }

    // interface * / dampening
    container dampening {
      tailf:info "Enable event dampening";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      presence true;
      leaf dampening-time {
        tailf:cli-drop-node-name;
        tailf:cli-delete-container-on-delete;
        type uint16 {
          tailf:info "<1-30>;;Half-life time for penalty";
          range 1..30;
        }
      }
      leaf reuse-threshold {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<1-20000>;;Value to start reusing an interface";
          range "1..20000";
        }
      }
      leaf suppress-threshold {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<1-20000>;;Value to start suppressing an interface";
          range "1..20000";
        }
      }
      leaf max-suppress {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-255>;;Maximum duration to suppress an interface";
          range "1..255";
        }
      }
      leaf restart {
        tailf:info "Enable restart penalty";
        type uint16 {
          tailf:info "<1-20000>;;Penalty applied at restart";
          range "1..20000";
        }
      }
    }

    // interface * / vlan-range *
    list vlan-range {
      tailf:cli-mode-name "config-if-vlan-range";
      tailf:cli-diff-create-after "../service-policy" {
        tailf:cli-when-target-delete;
      }
      tailf:cli-diff-modify-after "../service-policy" {
        tailf:cli-when-target-delete;
      }
      key id;
      leaf id {
        tailf:cli-suppress-range;
        type uint16 {
          tailf:info "WORD;;VLAN IDs 1-4094";
          range "1..4094";
        }
      }

      // interface * / vlan-range * / service-policy input
      // interface * / vlan-range * / service-policy output
      container service-policy {
        tailf:info "Configure Service Policy";

        uses service-policy-grouping {
          refine output {
            tailf:cli-diff-set-after "../../../service-policy" {
              tailf:cli-when-target-delete;
            }
          }
          refine input {
            tailf:cli-diff-set-after "../../../service-policy" {
              tailf:cli-when-target-delete;
            }
          }
        }
      }
    }

    // interface * / mace
    container mace {
      tailf:info "Measurement Aggregation and Correlation Engine";
      leaf enable {
        tailf:info "Enable MACE";
        type empty;
      }
    }

    // interface * / private-vlan mapping
    container private-vlan {
      tailf:info "Configure private VLAN SVI interface settings";
      container mapping {
        tailf:info "Set the private VLAN SVI interface mapping";
        leaf vlans {
          tailf:cli-drop-node-name;
          tailf:cli-remove-before-change;
          tailf:cli-diff-dependency "/ios:vlan/vlan-list/private-vlan";
          type string {
            tailf:info "WORD;;Secondary VLAN IDs of the private VLAN SVI interface mapping";
          }
        }
      }
    }

    // interface * / hold-queue *
    list hold-queue {
      tailf:info "Set hold queue depth";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      key direction;
      leaf direction {
        type enumeration {
          enum in {
            tailf:info "Input queue";
          }
          enum out {
            tailf:info "Output queue";
          }
        }
      }
      leaf queue-length {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        type uint32 {
          tailf:info "<0-240000>;;Queue length";
          range "0..240000";
        }
      }
    }

    // interface * / mpls
    container mpls {
      tailf:info "Configure MPLS interface parameters";

      // interface * / mpls accounting experimental
      container accounting {
        tailf:info "Enable MPLS accounting on this interface";
        container experimental {
          tailf:info "Count packets by MPLS experimental value on this interface";
          leaf input {
            tailf:info "received packets";
            type empty;
          }
          leaf output {
            tailf:info "transmitted packets";
            type empty;
          }
        }
      }

      // interface * / mpls bgp forwarding
      container bgp {
        tailf:info "MPLS BGP";
        leaf forwarding {
          tailf:info "Configure MPLS forwarding for directly connected BGP peers";
          type empty;
        }
      }

      // interface * / mpls label protocol
      container label {
        tailf:info "Label properties";
        leaf protocol {
          tailf:info "Configure label/tag distribution protocol (LDP/TDP)";
          type enumeration {
            enum both {
              tailf:info "Use LDP or TDP (Adapt to peer on multiaccess interface)";
            }
            enum ldp {
              tailf:info "Use LDP (default)";
            }
            enum tdp {
              tailf:info "Use TDP";
            }
          }
        }
      }

      // interface * / mpls ldp
      container ldp {
        tailf:info "Configure Label Distribution Protocol (LDP) parameters";
        tailf:cli-incomplete-no;

        // interface * / mpls ldp igp
        container igp {
          tailf:info "Configure IGP-related parameters";

          // interface * / no mpls ldp igp autoconfig
          leaf autoconfig {
            tailf:info "Allow automatic configuration of LDP when the IGP is configured";
            tailf:cli-boolean-no;
            tailf:cli-full-command;
            type boolean;
            default true;
          }

          choice sync-choice {
            // interface * / no mpls ldp igp sync
            leaf sync {
              tailf:info "Allow LDP-IGP Synchronization on this interface";
              tailf:cli-boolean-no;
              tailf:cli-full-command;
              type boolean;
              default true;
            }
            // interface * / mpls ldp igp sync delay
            container sync-delay {
              tailf:cli-drop-node-name;
              container sync {
                tailf:info "Allow LDP-IGP Synchronization on this interface";
                tailf:cli-incomplete-command;
                tailf:cli-incomplete-no;
                leaf delay {
                  tailf:info "Configure LDP to IGP sync achieved notification delay time";
                  type uint8 {
                    tailf:info "<5-60>;;Delay time (seconds)";
                    range "5..60";
                  }
                }
              }
            }
          }
        }

        // interface * / mpls ldp discovery
        container discovery {
          tailf:info "Configure interface LDP Discovery parameters";
          // interface * / mpls ldp discovery transport-address
          leaf transport-address {
            tailf:info "Specify interface LDP transport address";
            type ldp-discovery-address-type;
          }
        }
      }

      // interface * / mpls mtu
      leaf mtu {
        tailf:info "Set MPLS Maximum Transmission Unit";
        tailf:cli-full-command;
        cli:ned-diff-move-last {
          cli:arguments "when-higher";
        }
        type union {
          type uint16 {
            tailf:info "<1501-1524>;;MTU (baby giants bytes)";
            range "1501..1524";
          }
          type uint16 {
            tailf:info "<64-1500>;;MTU (bytes)";
            range "64..1500";
          }
          type uint16 {
            tailf:info "<64-9216>;;MTU size in bytes";
            range "64..9216";
          }
        }
        default 1500;
      }

      // interface * / mpls traffic-eng
      container traffic-eng {
        tailf:info "Configure Traffic Engineering parameters";
        tailf:cli-diff-dependency "/ios:mpls/traffic-eng";

        // interface * / mpls traffic-eng administrative-weight
        leaf administrative-weight {
          tailf:info "Set the administrative weight for the interface";
          tailf:cli-full-command;
          type uint32 {
            tailf:info "<0-4294967295>;;Weight";
            range "0..4294967295";
          }
        }

        // interface * / mpls traffic-eng tunnels
        leaf tunnels {
          tailf:info "enable MPLS Traffic Engineering tunnels";
          tailf:cli-full-command;
          type empty;
        }

        // interface * / mpls traffic-eng backup-path
        leaf backup-path {
          tailf:info "Configure an MPLS TE backup for this interface";
          tailf:cli-diff-dependency "/ios:interface";
          type string {
            tailf:info "Tunnel;;Tunnel interface";
          }
        }

        // interface * / mpls traffic-eng attribute-flags
        leaf attribute-flags {
          tailf:info "Set user-defined interface attibute flags";
          tailf:cli-full-command;
          type string {
            tailf:info "<0x0-0xFFFFFFFF>;;Attribute flags";
          }
        }

        // interface * / mpls traffic-eng flooding thresholds
        container flooding {
          tailf:info "Set flooding parameters";
          container thresholds {
            tailf:info "Set flooding thresholds";

            // interface * / mpls traffic-eng flooding thresholds down *
            leaf-list down {
              tailf:info "Set the thresholds for decreased resource availability";
              tailf:cli-flat-list-syntax;
              type uint8 {
                tailf:info "<0-100>;;decreased bandwidth usage (percent)";
                range "0..100";
              }
            }

            // interface * / mpls traffic-eng flooding thresholds up *
            leaf-list up {
              tailf:info "Set the thresholds for increased resource availability";
              tailf:cli-flat-list-syntax;
              type uint8 {
                tailf:info "<0-100>;;increased bandwidth usage (percent)";
                range "0..100";
              }
            }
          }
        }
      }

      // interface * / mpls ip
      leaf ip {
        tailf:info "Configure dynamic MPLS forwarding for IP";
        type empty;
      }

      // interface * / mpls nhrp
      leaf nhrp {
        tailf:info "MPLS NHRP commands";
        tailf:cli-diff-dependency "../../ip/nhrp";
        type empty;
      }

      // interface * / mpls propagate-cos
      leaf propagate-cos {
        type empty;
      }
    }

    // interface * / isis
    container isis {
      tailf:info "IS-IS commands";

      // interface * / isis bfd
      container bfd {
        tailf:info "Bidirectional Forwarding Protocol";
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;

        // interface * / isis bfd disable
        leaf disable {
          tailf:info "disable bfd";
          type empty;
        }
      }

      // interface * / isis tag
      leaf tag {
        tailf:info "Assign an admin tag to an ISIS interface IP route";
        type uint32 {
          tailf:info "<1-4294967295>;;Admin tag number";
        }
      }

      // interface * / isis circuit-type
      leaf circuit-type {
        tailf:info "Configure circuit type for interface";
        type enumeration {
          enum level-1 {
            tailf:info "Level-1 only adjacencies are formed";
          }
          enum level-1-2 {
            tailf:info "Level-1-2 adjacencies are formed";
          }
          enum level-2-only {
            tailf:info "Level-2 only adjacencies are formed";
          }
        }
        default level-1-2;
      }

      // interface * / isis network point-to-point
      leaf network {
        tailf:info "Network type";
        tailf:cli-full-command;
        type enumeration {
          enum point-to-point {
            tailf:info "Specify ISIS point-to-point network";
          }
        }
      }

      // interface * / isis metric
      choice metric-choice {
        case default-case {
          leaf metric {
            tailf:info "Configure the metric for interface";
            type union {
              type uint32 {
                tailf:info "<0-16777214>;;Default metric";
                range "0..16777214";
              }
              type enumeration {
                enum maximum {
                  tailf:info "Maximum metric. will exclude this link from their SPF";
                }
              }
            }
          }
        }
        case level-case {
          container metric-level {
            tailf:cli-drop-node-name;
            list metric {
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              key level;
              leaf level {
                type enumeration {
                  enum level-1 {
                    tailf:info "Apply metric to level-1 links";
                  }
                  enum level-2 {
                    tailf:info "Apply metric to level-2 links";
                  }
                }
              }
              leaf default {
                tailf:cli-drop-node-name;
                tailf:cli-prefix-key;
                type uint32 {
                  tailf:info "<0-16777214>;;Default metric";
                  range "0..16777214";
                }
              }
            }
          }
        }
      }

      // interface * / isis lsp-interval
      leaf lsp-interval {
        tailf:info "Set LSP transmission interval";
        type uint32 {
          tailf:info "<1-4294967295>;;LSP transmission interval (milliseconds)";
          range "1..4294967295";
        }
      }

      // interface * / isis authentication
      uses router-isis-interface-grouping;

      // interface * / isis ipv6
      container ipv6 {
        tailf:info "IPv6 interface configuration";
        tailf:cli-diff-set-after "../../ipv6/enable";
        tailf:cli-diff-delete-before "../../ipv6/enable";

        // interface * / isis ipv6 metric
        choice metric-choice {

          // interface * / isis ipv6 metric
          leaf metric {
            tailf:info "Configure the metric for interface";
            type union {
              type uint32 {
                tailf:info "<0-16777214>;;Default metric";
                range "0..16777214";
              }
              type enumeration {
                enum maximum {
                  tailf:info "Maximum metric. All routers will exclude this link from their SPF";
                }
              }
            }
          }

          // interface * / isis ipv6 metric ? level-1|level-2
          container metric-level {
            tailf:cli-drop-node-name;
            list metric {
              tailf:info "Configure the metric for interface";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              key level;
              leaf level {
                type enumeration {
                  enum level-1 {
                    tailf:info "Apply metric to level-1 links";
                  }
                  enum level-2 {
                    tailf:info "Apply metric to level-2 links";
                  }
                }
              }
              leaf value {
                tailf:cli-drop-node-name;
                tailf:cli-prefix-key;
                type union {
                  type uint32 {
                    tailf:info "<0-16777214>;;Default metric";
                    range "0..16777214";
                  }
                  type enumeration {
                    enum maximum {
                      tailf:info "Maximum metric. All routers will exclude this link from their SPF";
                    }
                  }
                }
              }
            }
          }
        }

        // interface * / isis ipv6 tag
        leaf tag {
          tailf:info "Assign an admin tag to an ISIS interface IPv6 route";
          type uint32 {
            tailf:info "<1-4294967295>;;Admin tag number";
            range "1..4294967295";
          }
        }
      }

      // interface * / isis three-way-handshake
      leaf three-way-handshake {
        tailf:info "Select Cisco or IETF three-way handshake";
        tailf:cli-diff-dependency "../../ipv6/router/isis" {
          tailf:cli-trigger-on-set;
        }
        type enumeration {
          enum cisco {
            tailf:info "Cisco implementation of three-way handshake (default)";
          }
          enum ietf {
            tailf:info "IETF implementation of three-way handshake";
          }
        }
        default cisco;
      }

      // interface * / isis priority
      choice priority-choice {
        leaf priority {
          tailf:info "Set priority for Designated Router election";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<0-127>;;Priority value";
            range "0..127";
          }
        }
        // interface * / isis priority ? level-1
        // interface * / isis priority ? level-2
        container priority-level-1-2 {
          tailf:cli-drop-node-name;
          list priority {
            tailf:info "Set priority for Designated Router election";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            key level;
            leaf level {
              type enumeration {
                enum level-1 {
                  tailf:info "Specify priority for level-1 routing";
                }
                enum level-2 {
                  tailf:info "Specify priority for level-2 routing";
                }
              }
            }
            leaf priority {
              tailf:cli-drop-node-name;
              tailf:cli-prefix-key;
              type uint8 {
                tailf:info "<0-127>;;Priority value";
                range "0..127";
              }
            }
          }
        }
      }

      // interface * / isis hello padding
      container hello {
        tailf:info "Add padding to IS-IS hello packets";

        // interface * / no isis hello padding
        // interface * / no isis hello padding always
        choice padding-choice {
          container padding-always {
            tailf:cli-drop-node-name;
            container padding {
              tailf:cli-incomplete-command;
              tailf:cli-incomplete-no;
              leaf always {
                tailf:cli-boolean-no;
                type boolean;
                default true;
              }
            }
          }
          leaf padding {
            tailf:info "Pad hello packets";
            tailf:cli-boolean-no;
            tailf:cli-full-command;
            tailf:cli-full-no;
            type boolean;
            default true;
          }
          default padding;
        }
      }

      // interface * / isis hello-multiplier
      container hello-multiplier {
        tailf:info "Set Hello multiplier";
        leaf seconds {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-65535>;;Hello multiplier value";
            range "1..65535";
          }
        }
      }

      // interface * / isis hello-interval
      container hello-interval {
        tailf:info "Set Hello interval in seconds";
        choice hello-interval-choice {
          leaf seconds {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<1-65535>;;Hello interval value";
              range "1..65535";
            }
          }
          leaf minimal {
            tailf:info "Holdtime 1 second, interval depends on multiplier";
            type empty;
          }
        }
      }

      // interface * / isis csnp-interval
      choice csnp-interval-choice {
        leaf csnp-interval {
          tailf:info "Set CSNP interval in seconds";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<0-65535>;;CSNP interval value";
          }
        }
        // interface * / isis csnp-interval ? level-1
        // interface * / isis csnp-interval ? level-2
        container csnp-interval-level {
          tailf:cli-drop-node-name;
          list csnp-interval {
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            key level;
            leaf level {
              type enumeration {
                enum level-1 {
                  tailf:info "Specify interval for level-1 CSNPs";
                }
                enum level-2 {
                  tailf:info "Specify interval for level-2 CSNPs";
                }
              }
            }
            leaf seconds {
              tailf:cli-drop-node-name;
              tailf:cli-prefix-key;
              type uint16 {
                tailf:info "<0-65535>;;CSNP interval value";
              }
            }
          }
        }
      }

      // interface * / isis password
      choice password-choice {
        leaf password {
          tailf:info "Configure the authentication password for interface";
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;Password";
          }
        }
        // interface * / isis password ? level-1
        // interface * / isis password ? level-2
        container password-level-1-2 {
          tailf:cli-drop-node-name;
          list password {
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            key level;
            leaf password {
              tailf:cli-prefix-key;
              tailf:cli-drop-node-name;
              ios:password-dequote-output "password (\\S+)";
              type NEDCOM_SECRET_TYPE {
                tailf:info "WORD;;Password";
              }
            }
            leaf level {
              type enumeration {
                enum level-1 {
                  tailf:info "Specify password for level-1 PDUs";
                }
                enum level-2 {
                  tailf:info "Specify password for level-2 PDUs";
                }
              }
            }
          }
        }
      }

      // interface * / isis affinity flex-algo
      container affinity {
        tailf:info "Affinity configuration on interface";
        container flex-algo {
          tailf:info "Affinity flex-algo config on interface";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-intf-affinity";

          // interface * / isis affinity flex-algo / name *
          list name {
            tailf:info "Affinity color name";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;Affinity color name";
              }
            }
          }
        }
      }

      // interface * / isis delay normalize
      container delay {
        tailf:info "Delay normalization interval";
        container normalize {
          tailf:info "Delay normalization interval";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf interval {
            tailf:info "Delay normalization interval";
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<1-16777215>;;interval value";
              range "1..16777215";
            }
          }
          leaf offset {
            tailf:info "Delay normalization offset";
            type uint32 {
              tailf:info "<1-16777215>;;offset value";
              range "1..16777215";
            }
          }
        }
      }

      // interface * / isis fast-reroute
      container fast-reroute {
        tailf:info "Fast-Reroute Interface Configuration";

        // interface * / isis fast-reroute protection
        container protection {
          tailf:info "enable fast-reroute protection on interface";

          // interface * / isis fast-reroute protection level-1
          leaf level-1 {
            tailf:info "apply to level-1";
            type empty;
          }

          // interface * / isis fast-reroute protection level-2
          leaf level-2 {
            tailf:info "apply to level-2";
            type empty;
          }
        }

        // interface * / isis fast-reroute candidate
        container candidate {
          tailf:info "interface can be used for fast-reroute path";

          // interface * / isis fast-reroute candidate level-1
          leaf level-1 {
            tailf:info "apply to level-1";
            type empty;
          }

          // interface * / isis fast-reroute candidate level-2
          leaf level-2 {
            tailf:info "apply to level-2";
            type empty;
          }
        }

        // interface * / isis fast-reroute ti-lfa protection
        container ti-lfa {
          tailf:info "TI-LFA interface configuration";
          container protection {
            tailf:info "TI-LFA protection";

            // interface * / isis fast-reroute ti-lfa protection level-1
            leaf level-1 {
              tailf:info "apply to level-1";
              type empty;
            }

            // interface * / isis fast-reroute ti-lfa protection level-2
            leaf level-2 {
              tailf:info "apply to level-2";
              type empty;
            }
          }
        }
      }
    }

    // interface * / vrf forwarding
    // interface * / ip vrf forwarding
    choice vrf-choice {
      container ip-vrf {
        tailf:cli-drop-node-name;
        container ip {
          container vrf {
            leaf forwarding {
              tailf:info "Configure forwarding table";
              tailf:non-strict-leafref {
                path "/ios:ip/vrf/name";
              }
              tailf:cli-diff-delete-after "/ios:router/ospf/disable/passive-interface/interface" {
                tailf:cli-when-target-delete;
              }
              ios:if-vrf-restore;
              type string {
                tailf:info "WORD;;VRF name";
              }
            }
          }
        }
      }

      // interface * / vrf forwarding
      container vrf {
        tailf:info "VPN Routing/Forwarding parameters on the interface";
        leaf forwarding {
          tailf:info "Configure forwarding table";
          tailf:cli-diff-dependency "/ios:vrf/definition";
          ios:if-vrf-restore;
          type string {
            tailf:info "WORD;;VRF name";
          }
        }
      }
    }

    // interface * / mtu
    leaf mtu {
      tailf:info "Set the interface Maximum Transmission Unit (MTU)";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<64-18000>;;MTU size in bytes";
        range "64..18000";
      }
    }

    // interface * / pm-path
    container pm-path {
      tailf:info "Global pm-path configuration";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-diff-dependency "/ios:pm-agent";
      leaf name {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type string {
          tailf:info "WORD;;Path name";
        }
      }
      leaf interface-id {
        tailf:info "Specify the interface-id";
        type uint32 {
          tailf:info "<1-4294967295>;;Specify the interface-id value";
          range "1..4294967295";
        }
      }
    }

    // interface * / ip
    container ip {
      tailf:info "Interface Internet Protocol config commands";

      // interface * / ip access-group *
      // interface * / ip access-group common *
      list access-group {
        tailf:info "Specify access control for packets";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        cli:ned-diff-move-before ">no switchport mode " {
          cli:arguments "when-delete|prio=+1";
        }
        key direction;
        leaf direction {
          type enumeration {
            enum in {
              tailf:code-name "access_group_direction_in";
              tailf:info "inbound packets";
            }
            enum out {
              tailf:code-name "access_group_direction_out";
              tailf:info "outbound packets";
            }
          }
        }
        leaf common {
          tailf:info "specify ipv4 common ACL for packet filtering";
          tailf:cli-prefix-key;
          tailf:cli-optional-in-sequence;
          type empty;
        }
        leaf access-list {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          tailf:cli-diff-dependency "/ios:ip/access-list";
          tailf:cli-disallow-value "common";
          type exp-ip-acl-type;
        }
        leaf regular-access-list {
          when "../common" {
            tailf:dependency "../common";
          }
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          tailf:cli-optional-in-sequence;
          tailf:cli-diff-dependency "/ios:ip/access-list";
          tailf:cli-disallow-value "common|in|out";
          type exp-ip-acl-type;
        }
      }

      // interface * / ip authentication
      container authentication {
        tailf:info "authentication subcommands";

        // interface * / ip authentication mode eigrp *
        container mode {
          tailf:info "mode";
          list eigrp {
            tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key as-no;
            leaf as-no {
              type uint16 {
                tailf:info "<1-65535>;;Autonomous system number";
                range "1..65535";
              }
            }
            leaf md5 {
              tailf:info "Keyed message digest";
              type empty;
            }
          }
        }

        // interface * / ip authentication key-chain eigrp *
        container key-chain {
          tailf:info "key-chain";
          list eigrp {
            tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key as-no;
            leaf as-no {
              type uint16 {
                tailf:info "<1-65535>;;Autonomous system number";
                range "1..65535";
              }
            }
            leaf key-chain {
              tailf:cli-drop-node-name;
              tailf:non-strict-leafref {
                path "/ios:key/chain/name";
              }
              type string {
                tailf:info "WORD;;name of key-chain";
              }
            }
          }
        }
      }

      // interface * / ip accounting
      container accounting {
        tailf:info "Enable IP accounting on this interface";
        tailf:cli-delete-when-empty;
        presence true;

        // interface * / ip accounting output-packets
        leaf output-packets {
          tailf:info "Account for IP packets output on this interface";
          tailf:cli-full-command;
          type empty;
        }

        // interface * / ip accounting precedence
        container precedence {
          tailf:info "Count packets by IP precedence on this interface";
          leaf input {
            tailf:info "received packets";
            type empty;
          }
          leaf output {
            tailf:info "transmitted packets";
            type empty;
          }
        }

        // interface * / ip accounting access-violations
        leaf access-violations {
          tailf:info "Account for IP packets violating access lists on this interface";
          tailf:cli-full-command;
          type empty;
        }
      }

      // interface * / ip vrf
      container vrf {
        tailf:info "VPN Routing/Forwarding parameters on the interface";
        leaf receive {
          tailf:info "Add Interface Address into VRF Table";
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;Table name";
          }
        }
        leaf sitemap {
          tailf:info "Configure route-map for routes received from this site";
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;Name of the route-map";
          }
          // Note: no dependency to route-map
        }
      }

      // interface * / ip arp inspection
      container arp {
        tailf:info "Configure ARP features";
        container inspection {
          tailf:info "Arp Inspection configuration";

          // interface * / ip arp inspection trust
          leaf trust {
            tailf:info "Configure Trust state";
            type empty;
          }

          // interface * / ip arp inspection limit
          container limit {
            tailf:info "Configure Rate limit of incoming ARP packets";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            choice limit-choice {
              leaf none {
                tailf:info "No limit";
                type empty;
              }
              leaf rate {
                tailf:info "Rate Limit";
                type uint16 {
                  tailf:info "<0-10000>;;Packets per second";
                  range "0..10000";
                }
              }
            }
            container burst {
              tailf:info "Configure Burst parameters for ARP packets";
              tailf:cli-flatten-container;
              leaf interval {
                tailf:info "Number of seconds to check the rate";
                type uint8 {
                  tailf:info "<1-15>;;Burst interval in seconds";
                  range "1..15";
                }
              }
            }
          }
        }
      }

      // interface * / ip address
      choice address-choice {

        // interface * / no ip address
        // interface * / ip unnumbered
        case no-address {
          container no-address {
            tailf:cli-drop-node-name;
            leaf address {
              tailf:cli-boolean-no;
              tailf:cli-full-command;
              tailf:cli-full-no;
              // dep: before this created, must change below:
              tailf:cli-diff-dependency "/ios:virtual-service" {
                tailf:cli-trigger-on-set;
              }
              ios:if-addr-move;
              type boolean;
              default true;
            }
          }
          container unnumbered {
            tailf:info "Enable IP processing without an explicit address";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            uses interface-name-grouping;
            leaf poll {
              tailf:info "Enable IP connected host polling";
              type empty;
            }
            leaf point-to-point {
              tailf:info "Enable point-to-point connection";
              type empty;
            }
          }
        }

        // interface * / ip address
        container address {
          tailf:info "Set the IP address of an interface";
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          choice address-choice {
            case fixed-case {
              // interface * / ip address a.b.c.d m.a.s.k
              container primary {
                tailf:cli-drop-node-name;
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands;
                tailf:cli-incomplete-command;
                tailf:cli-incomplete-no;
                // dep: before this created, must change:
                tailf:cli-diff-dependency "/ios:l2vpn-xconnect/l2vpn/xconnect/context" {
                  tailf:cli-trigger-on-set;
                }
                leaf address {
                  tailf:cli-drop-node-name;
                  tailf:cli-incomplete-command;
                  tailf:cli-incomplete-no;
                  ios:if-addr-move;
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;IP address";
                  }
                }
                leaf mask {
                  tailf:cli-drop-node-name;
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;IP subnet mask";
                  }
                }
              }

              // interface * / ip address a.b.c.d m.a.s.k secondary
              list secondary {
                tailf:cli-drop-node-name;
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                tailf:cli-compact-syntax;
                tailf:cli-incomplete-command;
                tailf:cli-incomplete-no;
                tailf:cli-diff-dependency "../primary/address";
                key "address mask";
                leaf address {
                  tailf:cli-incomplete-no;
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;IP address";
                  }
                }
                leaf mask {
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;IP subnet mask";
                  }
                }
                leaf secondary {
                  tailf:info "Make this IP address a secondary address";
                  type empty;
                }
              }
            }

            // interface * / ip address dhcp
            case dhcp-case {
              container dhcp {
                tailf:info "IP Address negotiated via DHCP";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands;
                presence true;
                container client-id {
                  tailf:info "Specify client-id to use";
                  tailf:cli-optional-in-sequence;
                  tailf:cli-flatten-container;
                  tailf:cli-compact-syntax;
                  uses interface-name-grouping;
                }
                leaf hostname {
                  tailf:info "Specify value for hostname option";
                  type string {
                    tailf:info "WORD;;hostname string";
                  }
                }
              }
            }

            // interface * / ip address negotiated
            case negotiated-case {
              container negotiated {
                tailf:info "IP Address negotiated over PPP";
                tailf:cli-reset-container;
                tailf:cli-delete-when-empty;
                presence true;
                leaf previous {
                  tailf:info "IPCP attempts to negotiate previous address assigned";
                  type empty;
                }
              }
            }
          }
        }
      }

      // interface * / ip directed-broadcast
      container directed-broadcast {
        tailf:info "Enable forwarding of directed broadcasts";
        tailf:cli-delete-when-empty;
        presence true;
        leaf access-list {
          tailf:cli-drop-node-name;
          type union {
            type uint16 {
              tailf:info "<1-199>;;A standard IP access list number";
              range "1..199";
            }
            type uint16 {
              tailf:info "<1300-2699>;;A standard IP expanded access list number";
              range "1300..2699";
            }
          }
        }
      }

      // interface * / ip broadcast-address
      leaf broadcast-address {
        tailf:info "Set the broadcast address of an interface";
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;IP broadcast address";
        }
      }

      // interface * / ip sticky-arp
      container sticky-arp {
        tailf:info "Allow the creation of sticky ARP entries";
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        leaf ignore {
          tailf:info "Disallow the creation of sticky ARP entries";
          type empty;
        }
      }

      // interface * / ip split-horizon eigrp no-list *
      // interface * / no ip split-horizon eigrp *
      container split-horizon-eigrp {
        tailf:cli-drop-node-name;
        container split-horizon {
          tailf:info "Perform split horizon";
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          container eigrp {
            tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
            list no-list {
              tailf:info "'no ip split-horizon eigrp' entry";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key as-no;
              leaf as-no {
                type uint16 {
                  tailf:info "<1-65535>;;Autonomous System";
                  range "1..65535";
                }
              }
            }
          }
        }
      }

      // interface * / no ip split-horizon
      leaf split-horizon {
        tailf:info "Perform split horizon";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // interface * / ip router
      container router {
        tailf:info "IP router interface commands";

        // interface * / ip router isis
        container isis {
          tailf:info "IS-IS Routing for IP";
          tailf:cli-delete-when-empty;
          presence true;
          leaf tag {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;Routing process tag";
            }
          }
        }
      }

      // interface * / ip flow
      container flow {
        tailf:info "NetFlow related commands";

        // interface * / ip flow ingress
        leaf ingress {
          tailf:info "Enable inbound NetFlow";
          type empty;
        }

        // interface * / ip flow egress
        leaf egress {
          tailf:info "Enable outbound NetFlow";
          type empty;
        }

        // interface * / ip flow monitor * input
        // interface * / ip flow monitor * output
        list monitor {
          tailf:info "Apply a Flow Monitor";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-diff-delete-before "/ios:flow/monitor/record" {
            tailf:cli-when-target-delete;
          }
          cli:ned-diff-move-after ">flow monitor " {
            cli:arguments "parent|when-set";
          }
          cli:ned-diff-move-before ">flow monitor " {
            cli:arguments "parent|when-delete";
          }
          key "name direction";
          leaf name {
            ios:config-lock " ip flow monitor (\\S+)(?: sampler \\S+)? (?:input|output) :: flow monitor $1";
            tailf:non-strict-leafref {
              path "/ios:flow/monitor/name";
            }
            type string {
              tailf:info "WORD;;Flow Monitor name";
            }
          }
          leaf sampler {
            tailf:info "Optional Sampler to apply to this Flow Monitor";
            tailf:cli-prefix-key {
              tailf:cli-before-key 2;
            }
            tailf:cli-optional-in-sequence;
            tailf:non-strict-leafref {
              path "/ios:sampler/name";
            }
            type string {
              tailf:info "WORD;;Sampler name";
            }
          }
          leaf direction {
            type enumeration {
              enum "input" {
                tailf:info "Apply Flow Monitor on input traffic";
              }
              enum "output" {
                tailf:info "Apply Flow Monitor on output traffic";
              }
            }
          }
        }
      }

      // interface * / ip helper-address
      container helper-address {
        tailf:info "Specify a destination address for UDP broadcasts";
        tailf:cli-diff-dependency "../../ip-vrf/ip/vrf/forwarding";

        // interface * / ip helper-address *
        list helper-address-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-show-long-obu-diffs;
          ordered-by user;
          key address;
          leaf address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP destination address";
            }
          }
        }

        // interface * / ip helper-address global *
        list global {
          tailf:info "Helper-address is global";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-show-long-obu-diffs;
          ordered-by user;
          key address;
          leaf address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP destination address";
            }
          }
        }

        // interface * / ip helper-address vrf *
        list vrf {
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-show-long-obu-diffs;
          ordered-by user;
          key "vrf address";
          leaf vrf {
            tailf:cli-diff-dependency "/ios:ip/vrf";
            tailf:cli-diff-dependency "/ios:vrf/definition";
            type string {
              tailf:info "VRF name for helper-address";
            }
          }
          leaf address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP destination address";
            }
          }
        }
      }

      // interface * / ip summary-address eigrp *
      container summary-address {
        tailf:info "Perform address summarization";
        list eigrp {
          tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
          tailf:cli-delete-when-empty;
          tailf:cli-suppress-mode;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          key "as-no ip-address wildcard-mask";
          leaf as-no {
            type uint16 {
              tailf:info "<1-65535>;;Autonomous system number";
              range "1..65535";
            }
          }
          leaf ip-address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP summary address";
            }
          }
          leaf wildcard-mask {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Summary mask";
            }
          }
          leaf distance {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            type uint8 {
              tailf:info "<1-255>;;Administrative distance";
              range "1..255";
            }
          }
          leaf leak-map {
            tailf:info "Allow dynamic prefixes based on the leak-map";
            type string {
              tailf:info "WORD;;leak-map name";
            }
          }
        }
      }

      // interface * / ip ospf
      container ospf {
        tailf:info "OSPF interface commands";

        // interface * / ip ospf *
        list process-id {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-incomplete-command;
          key id;
          leaf id {
            tailf:cli-suppress-range;
            type uint16 {
              tailf:info "<1-65535>;;Process ID";
              range "1..65535";
            }
          }
          leaf area {
            tailf:info "Set the OSPF area ID";
            type union {
              type uint32 {
                tailf:info "<0-4294967295>;;OSPF area ID as a decimal value";
              }
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;OSPF area ID in IP address format";
              }
            }
          }
          leaf secondaries {
            tailf:info "Include or exclude secondary IP addresses";
            type empty;
          }
          leaf none {
            tailf:info "Do not include secondary IP addresses";
            type empty;
          }
        }

        // interface * / ip ospf authentication
        container authentication {
          tailf:info "Enable authentication";
          tailf:cli-delete-when-empty;
          presence true;
          choice authentication-choice {
            // interface * / ip ospf authentication message-digest
            leaf message-digest {
              tailf:info "Use message-digest authentication";
              type empty;
            }
            // interface * / ip ospf authentication null
            leaf null {
              tailf:info "Use no authentication";
              type empty;
            }
            // interface * / ip ospf authentication key-chain
            leaf key-chain {
              tailf:info "Use a key-chain for cryptographic authentication keys";
              type string {
                tailf:info "WORD;;Key-chain name";
              }
            }
          }
        }

        // interface * / ip ospf authentication-key
        container authentication-key {
          tailf:info "Authentication password (key)";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          uses password-grouping {
            refine "secret" {
              cli:secret " ip ospf authentication-key <SECRET>";
            }
          }
        }

        // interface * / ip ospf message-digest-key *
        list message-digest-key {
          tailf:info "Message digest authentication password (key)";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-remove-before-change;
          key id;
          leaf id {
            type uint8 {
              tailf:info "<1-255>;;Key ID";
              range "1..255";
            }
          }
          container md5 {
            tailf:info "Use MD5 algorithm";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            uses password-grouping {
              refine "secret" {
                cli:secret " md5 <SECRET>";
              }
            }
          }
        }

        // interface * / ip ospf network *
        leaf-list network {
          tailf:info "Network type";
          tailf:cli-flat-list-syntax {
            tailf:cli-replace-all;
          }
          tailf:cli-full-command;
          max-elements 2;
          type enumeration {
            enum point-to-multipoint {
              tailf:info "Specify OSPF point-to-multipoint network";
            }
            enum point-to-point {
              tailf:info "Specify OSPF point-to-point network";
            }
            enum broadcast {
              tailf:info "Specify OSPF broadcast multi-access network";
            }
            enum non-broadcast {
              tailf:info "Specify OSPF NBMA network";
            }
          }
        }

        // interface * / ip ospf prefix-suppression
        leaf prefix-suppression {
          tailf:info "OSPF prefix suppression";
          type empty;
        }

        // interface * / ip ospf dead-interval
        container dead-interval {
          tailf:info "Interval after which a neighbor is declared dead";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          choice dead-interva-choice {
            leaf seconds {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<1-65535>;;Seconds";
                range "1..65535";
              }
            }
            case minimal {
              leaf minimal {
                tailf:info "Set to 1 second";
                type empty;
              }
              leaf hello-multiplier {
                tailf:info "Set multiplier for Hellos";
                type uint8 {
                  tailf:info "<3-20>;;Number of Hellos sent within 1 second";
                  range "3..20";
                }
              }
            }
          }
        }

        // interface * / ip ospf hello-interval
        leaf hello-interval {
          tailf:info "Time between HELLO packets";
          type uint16 {
            tailf:info "<1-65535>;;Seconds";
            range "1..65535";
          }
        }

        // interface * / ip ospf retransmit-interval
        leaf retransmit-interval {
          tailf:info "Time between retransmitting lost link state advertisements";
          type uint16 {
            tailf:info "<1-65535>;;Seconds";
            range "1..65535";
          }
        }

        // interface * / ip ospf transmit-delay
        leaf transmit-delay {
          tailf:info "Link state transmit delay";
          type uint16 {
            tailf:info "<1-65535>;;Seconds";
            range "1..65535";
          }
        }

        // interface * / ip ospf flood-reduction
        leaf flood-reduction {
          tailf:info "OSPF Flood Reduction";
          type empty;
        }

        // interface * / ip ospf demand-circuit
        container demand-circuit {
          tailf:info "OSPF Demand Circuit";
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          presence true;
          leaf ignore {
            tailf:info "Ignore demand circuit auto-negotiation requests";
            type empty;
          }
        }

        // interface * / ip ospf resync-timeout
        leaf resync-timeout {
          tailf:info "Interval after which adjacency is reset if oob-resync is not started";
          type uint16 {
            tailf:info "<1-65535>;;Seconds";
            range "1..65535";
          }
        }

        // interface * / ip ospf bfd
        container bfd {
          tailf:info "BFD interface configuration commands";
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          presence true;
          leaf enable {
            tailf:cli-full-command;
            tailf:cli-drop-node-name;
            type enumeration {
              enum disable {
                            tailf:info "Disable BFD for this interface";
              }
              enum strict-mode {
                tailf:info "Enable BFD in strict mode";
              }
            }
          }
        }

        // interface * / ip ospf mtu-ignore
        leaf mtu-ignore {
          tailf:info "Ignores the MTU in DBD packets";
          tailf:cli-full-command;
          type empty;
        }

        // interface * / ip ospf cost
        leaf cost {
          tailf:info "Interface cost";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<1-65535>;;Cost";
            range "1..65535";
          }
        }

        // interface * / ip ospf ttl-security
        container ttl-security {
          tailf:info "TTL security check";
          tailf:cli-delete-when-empty;
          presence true;
          leaf hops {
            tailf:info "IP hops";
            type uint8 {
              tailf:info "<1-254>;;maximum number of hops allowed";
              range "1..254";
            }
          }
        }

        // interface * / ip ospf priority
        leaf priority {
          tailf:info "Router priority";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<0-255>;;Priority";
          }
        }

        // interface * / ip ospf lls
        container lls {
          tailf:info "Link-local Signaling (LLS) support";
          tailf:cli-delete-when-empty;
          presence true;
          // interface * / ip ospf lls disable
          leaf disable {
            tailf:info "disable LLS";
            type empty;
          }
        }

        // interface * / ip ospf database-filter all out
        container database-filter {
          tailf:info "Filter OSPF LSA during synchronization and flooding";
          container all {
            tailf:info "Filter all LSA";
            leaf out {
              tailf:info "Outgoing LSA";
              type empty;
            }
          }
        }

        // interface * / ip ospf shutdown
        leaf shutdown {
          tailf:info "Set OSPF protocol's state to disable under current interface";
          type empty;
        }
      }

      // interface * / ip irdp
      container irdp-enable {
        tailf:cli-drop-node-name;
        leaf irdp {
          tailf:info "ICMP Router Discovery Protocol";
          tailf:cli-full-no;
          tailf:cli-full-command;
          tailf:cli-diff-delete-after "../../irdp";
          type empty;
        }
      }

      // interface * / ip irdp X
      container irdp {
        when "../irdp-enable/irdp" {
          tailf:dependency "../irdp-enable/irdp";
        }
        tailf:info "ICMP Router Discovery Protocol";
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;

        // interface * / ip irdp multicast
        leaf multicast {
          tailf:info "advertisements are sent with multicasts";
          type empty;
        }

        // interface * / ip irdp maxadvertinterval
        leaf maxadvertinterval {
          tailf:info "maximum time between advertisements";
          type uint16 {
            tailf:info "<0,4-1800>;;maximum time between advertisements (default 600 seconds)";
            range "0|4..1800";
          }
          default 600;
        }

        // interface * / ip irdp minadvertinterval
        leaf minadvertinterval {
          tailf:info "minimum time between advertisements";
          type uint16 {
            tailf:info "<3-1800>;;minimum time between advertisements (default 450 seconds)";
            range "3..1800";
          }
          default 450;
        }

        // interface * / ip irdp holdtime
        leaf holdtime {
          tailf:info "how long a receiver should believe the information";
          type uint16 {
            tailf:info "<4-9000>;;holdtime (default 1800 seconds)";
            range "4..9000";
          }
          default 1800;
        }

        // interface * / ip irdp preference
        leaf preference {
          tailf:info "preference level for this interface";
          type int32 {
            tailf:info "<-2147483648 - 2147483647>;;preference for this address (higher values preferred";
          }
        }
      }

      // interface * / ip pim
      container pim {
        tailf:info "PIM interface commands";
        tailf:cli-diff-set-after "../../vrf/forwarding";

        // interface * / ip pim redundancy *
        list redundancy {
          tailf:info "Enable PIM redundancy operation";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-remove-before-change;
          tailf:cli-incomplete-command;
          cli:ned-diff-move-before ">ip pim redundancy" {
            cli:arguments "when-delete";
          }
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Standby group name";
            }
          }
          leaf protocol {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            tailf:cli-incomplete-command;
            type enumeration {
              enum hsrp {
                tailf:info "HSRP (default, if neither 'hsrp' nor 'vrrp' is specified)";
              }
              enum vrrp {
                tailf:info "VRRP";
              }
            }
          }
          leaf dr-priority {
            tailf:info "Redundancy DR priority for active router";
            type uint32 {
              tailf:info "<0-4294967294>;;Redundancy DR priority. Preference given to larger value";
            }
          }
        }

        // interface * / ip pim query-interval
        leaf query-interval {
          tailf:info "PIM router query interval";
          type uint16 {
            tailf:info "<1-65535>;;Query interval in seconds or milliseconds. Default 30";
            range "1..65535";
          }
          default 30;
        }

        // interface * / ip pim bsr-border
        leaf bsr-border {
          tailf:info "Border of PIM domain";
          type empty;
        }

        // interface * / ip pim nbma-mode
        leaf nbma-mode {
          tailf:info "Use Non-Broadcast Multi-Access (NBMA) mode on interface";
          type empty;
        }

        // interface * / ip pim sparse-mode
        // interface * / ip pim sparse-dense-mode
        // interface * / ip pim dense-mode
        choice ip-pim-dense-mode-choice {
          leaf mode {
            tailf:cli-drop-node-name;
            tailf:cli-diff-dependency "/ios:ip/multicast-routing";
            type enumeration {
              enum sparse-mode {
                tailf:info "Enable PIM sparse-mode operation";
              }
              enum sparse-dense-mode {
                tailf:info "Enable PIM sparse-dense-mode operation";
              }
              enum dense-mode {
                tailf:info "Enable PIM dense-mode operation";
              }
            }
          }

          // interface * / ip pim dense-mode
          container dense-mode {
            tailf:info "Enable PIM dense-mode operation";
            tailf:cli-incomplete-no;
            tailf:cli-diff-dependency "/ios:ip/multicast-routing";

            // interface * / ip pim dense-mode proxy-register
            container proxy-register  {
              tailf:info "Send proxy registers";
              tailf:cli-no-name-on-delete;

              // interface * / ip pim dense-mode proxy-register list
              leaf list {
                tailf:info "Access list";
                tailf:cli-no-name-on-delete;
                tailf:cli-no-value-on-delete;
                type ext-acl-type;
              }
            }
          }
        }

        // interface * / ip pim dr-priority
        leaf dr-priority {
          tailf:info "PIM router DR priority";
          type uint32 {
            tailf:info "<0-4294967294>;;DR priority, preference given to larger value. Default 1";
          }
          default 1;
        }

        // interface * / ip pim snooping
        leaf snooping {
          tailf:info "PIM Snooping enable for Catalyst Vlan";
          type empty;
        }

        // interface * / ip pim passive
        leaf passive {
          tailf:info "Enable PIM passive interface operation";
          tailf:cli-full-command;
          type empty;
        }

        // interface * / ip pim neighbor-filter
        leaf neighbor-filter {
          tailf:info "PIM peering filter";
          type base-acl-type;
        }
      }

      // interface * / ip multicast
      container multicast {
        tailf:info "IP multicast interface commands";

        // interface * / ip multicast boundary
        container boundary {
          tailf:info "Boundary for administratively scoped multicast addresses";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf access-list {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;ACL name or number";
            }
          }
          leaf filter-autorp {
            tailf:info "Filter AutoRP packet contents.";
            type empty;
          }
        }

        // interface * / ip multicast limit
        container limit {
          tailf:info "Limit multicast mroute state";

          // interface * / ip multicast limit *
          list access-lists {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key access-list;
            leaf access-list {
              tailf:cli-suppress-range;
              type ip-acl-type;
            }
            leaf allowed-state {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<0-2147483647>;;Max Allowed State on this interface";
                range "0..2147483647";
              }
            }
          }

          // interface * / ip multicast limit / connected *
          list connected {
            tailf:info "Limit connected incoming state";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key access-list;
            leaf access-list {
              tailf:cli-suppress-range;
              type ip-acl-type;
            }
            leaf allowed-state {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<0-2147483647>;;Max Allowed State on this interface";
                range "0..2147483647";
              }
            }
          }

          // interface * / ip multicast limit / out *
          list out {
            tailf:info "Limit outgoing state";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key access-list;
            leaf access-list {
              tailf:cli-suppress-range;
              type ip-acl-type;
            }
            leaf allowed-state {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<0-2147483647>;;Max Allowed State on this interface";
                range "0..2147483647";
              }
            }
          }

          // interface * / ip multicast limit / rpf *
          list rpf {
            tailf:info "Limit incoming state";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key access-list;
            leaf access-list {
              tailf:cli-suppress-range;
              type ip-acl-type;
            }
            leaf allowed-state {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<0-2147483647>;;Max Allowed State on this interface";
                range "0..2147483647";
              }
            }
          }
        }

        // interface * / ip multicast rate-limit in
        container rate-limit {
          tailf:info "Rate limit multicast data packets";
          container in {
            tailf:info "Rate limit incoming packets";
            leaf value {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<0-4294967>;;Rate in kilobits per second";
                range "0..4294967";
              }
            }
          }
        }
      }

      // interface * / ip cgmp
      container cgmp {
        tailf:info "Enable/disable CGMP";
        tailf:cli-diff-dependency "../pim";
        presence true;
      }

      // interface * / ip policy route-map
      container policy {
        tailf:info "Enable policy routing";
        leaf route-map {
          tailf:info "Policy route-map";
          type string {
            tailf:info "WORD;;Route map name";
          }
        }
      }

      // interface * / no ip unreachables
      leaf unreachables {
        tailf:info "Enable sending ICMP Unreachable messages";
        tailf:cli-boolean-no;
        type boolean;
        default true;
      }

      // interface * / ip local-proxy-arp
      leaf local-proxy-arp {
        tailf:info "Enable local-proxy ARP";
        type empty;
      }

      // interface * / no ip proxy-arp
      leaf proxy-arp {
        tailf:info "Enable proxy ARP";
        tailf:cli-boolean-no;
        type boolean;
        default true;
      }

      // interface * / no ip route-cache
      container route-cache-conf {
        tailf:cli-drop-node-name;
        leaf route-cache {
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }
      }

      // interface * / ip route-cache
      container route-cache {
        tailf:info "Enable fast-switching cache for outgoing packets";
        tailf:cli-incomplete-no;
        tailf:cli-incomplete-command;

        // interface * / no ip route-cache cef
        leaf cef {
          tailf:info "Enable Cisco Express Forwarding";
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }

        // interface * / ip route-cache flow
        leaf flow {
          tailf:info "Enable Flow fast-switching cache";
          tailf:cli-boolean-no;
          type boolean;
          default false;
        }

        // interface * / ip route-cache policy
        leaf policy {
          tailf:info "Enable fast-switching policy cache for outgoing packets";
          tailf:cli-boolean-no;
          type boolean;
          default false;
        }

        // interface * / ip route-cache same-interface
        leaf same-interface {
          tailf:info "Enable fast-switching on the same interface";
          tailf:cli-boolean-no;
          type boolean;
          default false;
        }
      }

      // interface * / ip mroute-cache
      // interface * / no ip mroute-cache
      leaf mroute-cache {
        tailf:info "Enable switching cache for incoming multicast packets";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // interface * / ip igmp
      container igmp {
        tailf:info "IGMP interface commands";

        // interface * / ip igmp max-groups
        container max-groups {
          tailf:info "set maximum number of IGMP groups that can be joined";
          leaf number {
            tailf:cli-drop-node-name;
            tailf:cli-no-value-on-delete;
            tailf:cli-full-command;
            type uint32 {
              tailf:info "<0-4294967294>;;maximum # of groups";
            }
          }
          // interface * / ip igmp max-groups action
          leaf action {
            tailf:info "action taken on exceeding the limit";
            tailf:cli-no-value-on-delete;
            tailf:cli-full-command;
            type enumeration {
              enum deny {
                tailf:info "do not allow any more groups";
              }
              enum replace {
                tailf:info "replace existing group with new";
              }
            }
            default deny;
          }
        }

        // interface * / ip igmp filter
        leaf filter {
          tailf:info "set IGMP filter profile number";
          type uint32 {
            tailf:info "<1-4294967295>;;IGMP profile number";
            range "1..4294967295";
          }
        }

        // interface * / ip igmp join-group *
        list join-group {
          tailf:info "IGMP join multicast group";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key address;
          leaf address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP group address";
            }
          }
          leaf source {
            tailf:info "Include SSM source";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP source address";
            }
          }
        }

        // interface * / ip igmp static-group
        container static-group {
          tailf:info "IGMP static multicast group";

          // interface * / ip igmp static-group *
          list groups {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key name;
            leaf name {
              tailf:cli-suppress-range;
              type union {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IP group address";
                }
                type enumeration {
                  enum "*" {
                    tailf:info "Populated for all groups";
                  }
                }
              }
            }
          }

          // interface * / ip igmp static-group * source *
          list groups-source {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-diff-dependency "../groups";
            key "name source";
            leaf name {
              tailf:cli-suppress-range;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IP group address";
              }
            }
            leaf source {
              tailf:info "SSM source address";
              tailf:cli-expose-key-name;
              type union {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IP source address";
                }
                type enumeration {
                  enum ssm-map {
                    tailf:info "Get source via SSM mapping";
                  }
                }
              }
            }
          }

          // interface * / ip igmp static-group class-map *
          list class-map {
            tailf:info "Class map of type multicast-flows";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key id;
            leaf id {
              tailf:non-strict-leafref {
                path "/ios:class-map/name";
              }
              type string {
                tailf:info "WORD;;Name of class-map of type multicast-flows";
              }
            }
          }
        }

        // interface * / ip igmp last-member-query-interval
        leaf last-member-query-interval {
          tailf:info "IGMP last member query interval";
          type uint16 {
            tailf:info "<100-25500>;;Last member query interval in milliseconds";
            range "100..25500";
          }
          default 1000;
        }

        // interface * / ip igmp last-member-query-count
        leaf last-member-query-count {
          tailf:info "IGMP last member query count";
          type uint8 {
            tailf:info "<1-7>;;Last member query count";
            range "1..7";
          }
          default 2;
        }

        // interface * / ip igmp version
        leaf version {
          tailf:info "IGMP version";
          type uint8 {
            tailf:info "<1-3>;;version number. Default 2";
            range "1..3";
          }
          default 2;
        }

        // interface * / ip igmp v3lite
        leaf v3lite {
          tailf:info "Enable/disable IGMPv3 Lite";
          type empty;
        }

        // interface * / ip igmp helper-address
        container helper-address {
          tailf:info "IGMP helper address";
          leaf address {
            tailf:cli-drop-node-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IGMP helper address";
            }
          }
        }

        // interface * / ip igmp explicit-tracking
        leaf explicit-tracking {
          tailf:info "Enable/Disable IGMP explicit-tracking";
          type empty;
        }

        // interface * / ip igmp query-interval
        leaf query-interval {
          tailf:info "IGMP host query interval";
          type uint16 {
            tailf:info "<1-18000>;;Query interval in seconds";
            range "1..18000";
          }
          default 60;
        }

        // interface * / ip igmp access-group
        leaf access-group {
          tailf:info "IGMP group access group";
          type exp-ip-acl-type;
        }

        // interface * / ip igmp snooping
        container snooping {
          tailf:info "IGMP Snooping enable for Catalyst Vlan";
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;

          // interface * / no ip igmp snooping report-suppression
          leaf report-suppression {
            tailf:info "Force a report suppression";
            tailf:cli-boolean-no;
            type boolean;
            default true;
          }

          // interface * / no ip igmp snooping tcn flood
          container tcn {
            tailf:info "STP Topology Change Notification behavior";
            leaf flood {
              tailf:info "flood when a TCN is seen";
              tailf:cli-boolean-no;
              type boolean;
              default true;
            }
          }

          // interface * / ip igmp snooping fast-leave
          leaf fast-leave {
            tailf:info "Enable IGMP fast leave processing";
            type empty;
          }

          // interface * / ip igmp snooping querier
          leaf querier {
            tailf:info "Enable IGMP querier processing";
            type empty;
          }

          // interface * / ip igmp snooping mrouter
          container mrouter {
            tailf:info "Configure an L2 port as a multicast router port";

            // interface * / ip igmp snooping mrouter interface
            container interface {
              tailf:info "next-hop interface to mrouter";
              uses interface-name-grouping;
            }
          }
        }

        // interface * / no ip igmp snooping
        container snooping-enable {
          tailf:cli-drop-node-name;
          leaf snooping {
            tailf:cli-boolean-no;
            type boolean;
            default true;
          }
        }

        // interface * / ip igmp limit
        container limit {
          tailf:info "IGMP limit";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf value {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<1-64000>;;Max Allowed State on this interface";
              range "1..64000";
            }
          }
          leaf except {
            tailf:info "Groups not to be counted";
            type ip-acl-type;
          }
        }
      }

      // interface * / no ip redirects
      leaf redirects {
        tailf:info "Enable sending ICMP Redirect messages";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // interface * / ip hello-interval eigrp *
      container hello-interval {
        tailf:info "Configures EIGRP-IPv4 hello interval";
        list eigrp {
          tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          key as-number;
          leaf as-number {
            type uint16 {
              tailf:info "<1-65535>;;AS number";
            }
          }
          leaf seconds {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<1-65535>;;Seconds between hello transmissions";
              range "1..65535";
            }
          }
        }
      }

      // interface * / ip hold-time eigrp *
      container hold-time {
        tailf:info "Configures EIGRP-IPv4 hold time";
        list eigrp {
          tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          key as-number;
          leaf as-number {
            type uint16 {
              tailf:info "<1-65535>;;AS number";
            }
          }
          leaf seconds {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<1-65535>;;Seconds before neighbor is considered down";
              range "1..65535";
            }
          }
        }
      }

      // interface * / ip nbar
      container nbar {
        tailf:info "Network-Based Application Recognition";

        // interface * / ip nbar protocol-discovery
        leaf protocol-discovery {
          tailf:info "Enable protocol discovery for both ipv4 and ipv6";
          type empty;
        }
      }

      // interface * / ip nhrp
      container nhrp {
        tailf:info "NHRP interface subcommands";

        // interface * / ip nhrp authentication
        leaf authentication {
          tailf:info "Authentication string";
          type string {
            tailf:info "WORD;;authentication string";
          }
        }

        // interface * / ip nhrp group
        leaf group {
          tailf:info "NHRP group name";
          type string {
            tailf:info "WORD;;group name string";
          }
        }

        // interface * / ip nhrp map
        container map {
          tailf:info "Map dest IP addresses to NBMA addresses";

          // interface * / ip nhrp map *
          list map-list {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key ip-address;
            leaf ip-address {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IP address of destination";
              }
            }
            leaf nbma-address {
              tailf:cli-drop-node-name;
              type union {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IP NBMA address";
                }
                type inet:ipv6-address {
                  tailf:info "X:X:X:X::X;;IPv6 NBMA address";
                }
              }
            }
          }

          // interface * / ip nhrp map multicast
          container multicast {
            tailf:info "Use this NBMA mapping for broadcasts/multicasts";

            // interface * / no ip nhrp map multicast dynamic
            leaf dynamic {
              tailf:info "Dynamically learn destinations from client registrations on hub";
              tailf:cli-boolean-no;
              tailf:cli-full-command;
              type boolean;
              default true;
            }

            // interface * / ip nhrp map multicast *
            list multicast-list {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key nbma-address;
              leaf nbma-address {
                type union {
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;IP NBMA address";
                  }
                  type inet:ipv6-address {
                    tailf:info "X:X:X:X::X;;IPv6 NBMA address";
                  }
                }
              }
            }
          }

          // interface * / ip nhrp map group *
          list group {
            tailf:info "NHRP group mapping";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;NHRP group name";
              }
            }

            // interface * / ip nhrp map group * service-policy output
            container service-policy {
              tailf:info "QoS service-policy";
              leaf output {
                tailf:info "apply QoS service policy in the output direction";
                tailf:non-strict-leafref {
                  path "/ios:policy-map/name";
                }
                type string {
                  tailf:info "WORD;;QoS policy-map name";
                }
              }
            }
          }
        }

        // interface * / ip nhrp network-id
        leaf network-id {
          tailf:info "NBMA network identifier";
          type union {
            type uint32 {
              tailf:info "<1-4294967295>;;Network identifier";
            }
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP address";
            }
          }
        }

        // interface * / ip nhrp holdtime
        leaf holdtime {
          tailf:info "Advertised holdtime";
          type uint16 {
            tailf:info "<1-65535>;;Number of seconds. Default 600";
            range "1..65535";
          }
          default 600;
        }

        // interface * / ip nhrp nhs
        container nhs {
          tailf:info "Specify a next hop server";

          // interface * / ip nhrp nhs *
          list nhs-list {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            key nhs-address;
            leaf nhs-address {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Protocol IP address of NHS";
              }
            }
            // interface * / ip nhrp nhs * nbma
            leaf nbma {
              tailf:info "NBMA of NHS";
              type union {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IPv4 address";
                }
                type inet:ipv6-address {
                  tailf:info "X:X:X:X::X;;IPv6 address";
                }
                type string {
                  tailf:info "WORD;;NHS FQDN string";
                }
              }
            }
            // interface * / ip nhrp nhs * multicast
            leaf multicast {
              when "../nbma" {
                tailf:dependency "../nbma";
              }
              tailf:info "Use this NBMA mapping for broadcasts/multicasts";
              type empty;
            }
          }
        }

        // interface * / ip nhrp server-only
        container server-only {
          tailf:info "Disable NHRP requests";
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          presence true;
          leaf non-caching {
            tailf:info "Do not create NHRP cache entries";
            type empty;
          }
        }

        // interface * / ip nhrp registration
        container registration {
          tailf:info "Settings for registration packets.";

          // interface * / no ip nhrp registration no-unique
          leaf no-unique {
            tailf:info "Do not set the 'Unique' flag in registration requests.";
            tailf:cli-boolean-no;
            tailf:cli-full-command;
            type boolean;
            default true;
          }

          // interface * / ip nhrp registration timeout
          leaf timeout {
            tailf:info "Time between periodic Registration messages";
            type uint16 {
              tailf:info "<1-65535>;;Number of seconds";
              range "1..65535";
            }
          }
        }

        // interface * / ip nhrp shortcut
        container shortcut {
          tailf:info "Enable shortcut switching";
          tailf:cli-delete-when-empty;
          presence true;
          leaf virtual-template {
            tailf:info "Virtual template interface number";
            type uint16 {
              tailf:info "<1-4095>;;Virtual template number";
              range "1..4095";
            }
          }
        }

        // interface * / ip nhrp redirect
        container redirect {
          tailf:info "Enable NHRP redirect traffic indication";
          tailf:cli-delete-when-empty;
          presence true;
          leaf timeout {
            tailf:info "Specify interval over which to throttle";
            type uint8 {
              tailf:info "<2-30>;;Interval in seconds";
              range "2..30";
            }
          }
        }
      }

      // interface * / ip tcp
      container tcp {
        tailf:info "TCP header compression and other parameters";

        // interface * / ip tcp adjust-mss
        leaf adjust-mss {
          tailf:info "Adjust the mss of transit packets";
          type uint16 {
            tailf:info "<500-1460>;;Maximum segment size in bytes";
            range "500..1460";
          }
        }

        // interface * / ip tcp header-compression
        container header-compression {
          tailf:info "Enable TCP header compression";
          tailf:cli-delete-when-empty;
          presence true;
          leaf type {
            tailf:cli-drop-node-name;
            type enumeration {
              enum ietf-format {
                tailf:info "Compressing using IETF format";
              }
              enum iphc-format {
                tailf:info "Using PPP  IPHC compression for TCP/UDP/RTP";
              }
              enum passive {
                tailf:info "Compress only for destinations which send compressed headers";
              }
            }
          }
        }

        // interface * / ip tcp compression-connections
        leaf compression-connections {
          tailf:info "Maximum number of compressed connections";
          type uint16 {
            tailf:info "<1-256>;;Number of connections";
            range "1..256";
          }
        }
      }

      // interface * / ip rtp
      container rtp {
        tailf:info "RTP parameters";
        container header-compression {
          tailf:info "Enable RTP header compression";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf type {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            type enumeration {
              enum ietf-format {
                tailf:info "Compressing using IETF format";
              }
              enum iphc-format {
                tailf:info "Compress using IPHC format";
              }
              enum passive {
                tailf:info "Compress only for destinations which send compressed headers";
              }
            }
          }
          leaf periodic-refresh {
            tailf:info "Periodic context refresh";
            type empty;
          }
        }
        leaf compression-connections {
          tailf:info "Maximum number of compressed connections";
          type uint16 {
            tailf:info "<1-1000>;;Number of connections";
            range "1..1000";
          }
        }
      }

      // interface * / ip header-compression
      container header-compression {
        tailf:info "IPHC options";
        leaf max-header {
          tailf:info "Maximim compressible header";
          type uint8 {
            tailf:info "<20-168>;;Maximim compressible header";
            range "20..168";
          }
        }
      }

      // interface * / ip mobile
      container mobile {
        tailf:info "Mobile IP support";

        // interface * / ip mobile router-service
        container router-service {
          tailf:info "Mobile router support";

          // interface * / ip mobile router-service roam
          container roam {
            tailf:info "Roaming interface";
            tailf:cli-diff-dependency "/ios:router/mobile";
            presence true;
            leaf priority {
              tailf:info "Priority level";
              type uint8 {
                tailf:info "<0-255>;;Priority level";
              }
            }
          }

          // interface * / ip mobile router-service description
          leaf description {
            tailf:info "roaming interface description";
            tailf:cli-multi-value;
            tailf:cli-preformatted;
            tailf:cli-full-command;
            type string {
              tailf:info "LINE;;roaming interface description";
            }
          }

          // interface * / ip mobile router-service link-type
          leaf link-type {
            tailf:info "Link type of the roaming interface";
            type string {
              tailf:info "WORD;;Link type";
            }
          }

          // interface * / ip mobile router-service tunnel
          container tunnel {
            tailf:info "Tunnel parameters";
            leaf mode {
              tailf:info "Tunnel encapsulation mode";
              type enumeration {
                enum gre {
                  tailf:info "Generic Routing Encapsulation";
                }
                enum ipip {
                  tailf:info "IP-in-IP Encapsulation";
                }
              }
            }
          }

          // interface * / ip mobile router-service collocated
          container collocated {
            tailf:info "Collocated care-of address options";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf gateway {
              tailf:info "Default gateway for static collocated care-of address";
              tailf:cli-optional-in-sequence;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IP address to use as the default gateway";
              }
            }
            leaf ccoa-only {
              tailf:info "Only register a collocated CoA";
              tailf:cli-optional-in-sequence;
              type empty;
            }

            // interface * / ip mobile router-service collocated registration
            container registration {
              tailf:info "Registration options";
              tailf:cli-break-sequence-commands;
              leaf retry {
                tailf:info "Retry interval in seconds (1-65535)";
                type uint16 {
                  tailf:info "<1-65535>;;Seconds (default 60; 65535 = never)";
                  range "1..65535";
                }
                default 60;
              }
              container nat {
                tailf:info "NAT traversal settings";
                container traversal {
                  tailf:info "Enable NAT traversal support";
                  tailf:cli-compact-syntax;
                  presence true;
                  leaf keepalive {
                    tailf:info "Keepalive message frequency (sec)";
                    type uint16 {
                      tailf:info "<0-65535>;;keepalive value";
                    }
                  }
                  leaf force {
                    tailf:info "Force home agent to use UDP encapsulation for the tunnel";
                    type empty;
                  }
                }
              }
            }
            leaf encapsulation {
              type enumeration {
                enum slip {}
                enum ppp {}
              }
            }
          }
        }
      }

      // interface * / ip inspect * in
      // interface * / ip inspect * out
      list inspect {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key direction;
        leaf direction {
          type enumeration {
            enum in {
              tailf:info "Inbound inspection";
            }
            enum out {
              tailf:info "Outbound inspection";
            }
          }
        }
        leaf name {
          tailf:cli-prefix-key;
          tailf:cli-drop-node-name;
          tailf:non-strict-leafref {
            path "/ios:ip/inspect/name/name";
          }
          type string {
            tailf:info "WORD;;Name of inspection defined";
          }
        }
      }

      // interface * / ip virtual-reassembly
      container virtual-reassembly {
        tailf:info "Enable Virtual Fragment Reassembly";
        tailf:cli-delete-when-empty;
        presence true;

        // interface * / ip virtual-reassembly in
        leaf in {
          tailf:info "Enable VFR on Ingress";
          tailf:cli-full-command;
          type empty;
        }

        // interface * / ip virtual-reassembly out
        leaf out {
          tailf:info "Enable VFR on Egress";
          tailf:cli-full-command;
          type empty;
        }

        container conf {
          tailf:cli-drop-node-name;
          tailf:cli-compact-syntax;

          // interface * / ip virtual-reassembly drop-fragments
          leaf drop-fragments {
            tailf:info "Drop all the incoming fragments";
            type empty;
          }

          // interface * / ip virtual-reassembly max-fragments
          leaf max-fragments {
            tailf:info "Specify max number of fragments per reassembly (datagram)";
            type uint8 {
              tailf:info "<1-64>;;Number of fragments per datagram";
              range "1..64";
            }
          }

          // interface * / ip virtual-reassembly max-reassemblies
          leaf max-reassemblies {
            tailf:info "Specify max number of concurrent reassemblies";
            type uint16 {
              tailf:info "<1-1024>;;Number of datagrams that can be reassembled at a time";
              range "1..1024";
            }
          }

          // interface * / ip virtual-reassembly timeout
          leaf timeout {
            tailf:info "Specify timeout value of the datagram being reassembled";
            type uint8 {
              tailf:info "<1-60>;;Timeout value of the datagram being reassembled";
            }
          }

          // interface * / ip virtual-reassembly percentage
          leaf percentage {
            tailf:info "Reserved Reassembly capacity for high priority packets";
            type uint8 {
              tailf:info "<1-100>;;Reserved Reassembly capacity percentage";
              range "1..100";
            }
          }

          // interface * / ip virtual-reassembly dscp
          leaf-list dscp {
            tailf:info "DSCP value";
            tailf:cli-flat-list-syntax;
            tailf:cli-full-command;
            type dscp-type;
          }

          // interface * / ip virtual-reassembly precedence
          leaf-list precedence {
            tailf:info "IP precedence";
            tailf:cli-flat-list-syntax;
            tailf:cli-full-command;
            type precedence-type;
          }
        }
      }

      // interface * / ip dns view-group
      container dns {
        tailf:info "Configure DNS server";
        leaf view-group {
          tailf:info "Configure a DNS view-list for use on this interface";
          tailf:non-strict-leafref {
            path "/ios:ip/dns/view-list/name";
          }
          type string {
            tailf:info "WORD;;View-list name";
          }
        }
      }

      // interface * / ip ddns
      container ddns {
    	tailf:info "Configure dynamic DNS";

    	// interface * / ip ddns update
    	container update {
    	  tailf:info "Configure dynamic DNS update";

    	  // interface * / ip ddns update hostname
    	  leaf hostname {
    		tailf:info "Dynamic DNS update hostname";
    		type string {
    		  tailf:info "WORD;;Host name";
    		}
    	  }

          // interface * / ip ddns update *
    	  list list {
    		tailf:cli-drop-node-name;
    		tailf:cli-suppress-mode;
    		tailf:cli-delete-when-empty;
    		key name;
    		leaf name {
    		  tailf:non-strict-leafref {
    		    path "/ios:ip/ddns/update/method/name";
    		  }
              tailf:cli-disallow-value "hostname";
    		  type string {
    			tailf:info "WORD;;Method name";
    		  }
    	    }

    		// interface * / ip ddns update * host-group
      	    leaf host-group {
      	  	  tailf:info "Dynamic DNS update destination host list";
      		  tailf:non-strict-leafref {
      		    path "/ios:ip/host-list/name";
      		  }
      		  type string {
      		    tailf:info "WORD;;Host list name";
      		  }
      	    }
    	  }
    	}
      }

      // interface * / ip dhcp
      container dhcp {
        tailf:info "Configure DHCP parameters for this interface";

        // interface * / ip dhcp client
        container client {
          tailf:info "DHCP client configuration";

          // interface * / ip dhcp client update
          container update {
        	tailf:info "Dynamically update information";

        	// interface * / ip dhcp client update dns
        	container dns {
        	  tailf:info "Dynamic DNS update configuration";
        	  presence true;
        	  tailf:cli-delete-when-empty;
      		  tailf:cli-reset-container;

        	  // interface * / ip dhcp client update dns server
        	  leaf server {
        		tailf:info "Dynamic DNS updates requested of server";
        		type enumeration {
        		  enum both {
        			tailf:info "Server updates both (A and PTR) records";
        		  }
        		  enum none {
        			tailf:info "Ask server to perform no updates";
        		  }
        		}
        	  }
        	}
          }

          // interface * / ip dhcp client request
          container request {
            tailf:info "Specify options (not) to request";

            // interface * / no ip dhcp client request domain-name
            leaf domain-name {
              tailf:info "Domain name (15)";
              tailf:cli-boolean-no;
              type boolean;
              default true;
            }
          }

          // interface * / ip dhcp client client-id
          container client-id {
            tailf:info "Specify Client-ID to use";
            choice client-id-choice {
              leaf ascii {
                tailf:info "Ascii Client-ID string";
                type string {
                  tailf:info "WORD;;Client-ID string";
                }
              }
              case interface {
                uses interface-name-grouping;
              }
            }
          }

          // interface * / ip dhcp client hostname
          leaf hostname {
            tailf:info "Specify hostname to use";
            type string {
              tailf:info "WORD;;Hostname string";
            }
          }

          // interface * / ip dhcp client lease
          container lease {
            tailf:info "Requested address lease time";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf days {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<0-365>;;Days";
                range "0..365";
              }
            }
            leaf hours {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<0-23>;;Hours";
              }
            }
            leaf minutes {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<0-59>;;Minutes";
                range "0..59";
              }
            }
          }
        }

        // interface * / ip dhcp relay information
        container relay {
          tailf:info "DHCP relay configuration parameters";

          // interface * / ip dhcp relay information
          container information {
            tailf:info "DHCP relay information option";

            // interface * / ip dhcp relay information trusted
            leaf trusted {
              tailf:info "Received DHCP packet may contain relay info option with zero giaddr";
              type empty;
            }

            // interface * / ip dhcp relay information option
            container option {
              tailf:info "DHCP relay information option";
              leaf subscriber-id {
                tailf:info "Subscriber identifier sub option";
                type string {
                  tailf:info "WORD;;Subscriber identifier string";
                }
              }
            }

            // interface * / ip dhcp relay information option-insert
            container option-insert {
              tailf:info "Insert relay information in BOOTREQUEST";
              tailf:cli-reset-container;
              tailf:cli-delete-when-empty;
              presence true;
              leaf none {
                tailf:info "Set to none";
                type empty;
              }
            }

            // interface * / ip dhcp relay information check-reply
            container check-reply {
              tailf:info "Validate relay information in BOOTREPLY";
              tailf:cli-reset-container;
              tailf:cli-delete-when-empty;
              presence true;
              leaf none {
                tailf:info "Set to none";
                type empty;
              }
            }

            // interface * / ip dhcp relay information policy-action
            leaf policy-action {
              tailf:info "Define reforwarding policy";
              type enumeration {
                enum drop {
                           tailf:info "Do not forward BOOTREQUEST message";
                }
                enum encapsulate {
                                  tailf:info "Encapsulate existing information";
                }
                enum keep {
                           tailf:info "Leave existing information alone";
                }
                enum replace {
                              tailf:info "Replace existing information";
                }
              }
            }
          }

          // interface * / ip dhcp relay source-interface
          container source-interface {
            tailf:info "Set source interface for relayed messages";
            uses interface-name-grouping;
          }
        }

        // interface * / ip dhcp snooping
        container snooping {
          tailf:info "DHCP Snooping";

          // interface * / ip dhcp snooping limit
          container limit {
            tailf:info "DHCP Snooping limit";
            leaf rate {
              tailf:info "DHCP Snooping limit";
              type uint16 {
                tailf:info "<1-2048>;;DHCP snooping rate limit";
                range "1..2048";
              }
            }
          }

          // interface * / ip dhcp snooping trust
          leaf trust {
            tailf:info "DHCP Snooping trust config";
            type empty;
          }

          // interface * / ip dhcp snooping vlan * information option format-type circuit-id
          list vlan {
            tailf:info "DHCP Snooping vlan";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-incomplete-command;
            key id;
            leaf id {
              type uint16 {
                tailf:info "<1-4094>;;DHCP Snooping vlan";
                range "1..4094";
              }
            }
            container information {
              tailf:info "DHCP Snooping information";
              container option {
                tailf:info "DHCP Snooping information option";
                container format-type {
                  tailf:info "Option 82 information format";
                  container circuit-id {
                    tailf:info "Circuit id option 82 format";
                    tailf:cli-compact-syntax;
                    leaf override {
                      tailf:info "Override all contents of circuit-id";
                      tailf:cli-incomplete-command;
                      type empty;
                    }
                    leaf string {
                      tailf:info "User defined string for circuit id";
                      type string {
                        tailf:info "WORD;;Use string for circuit id (3-63 chars)";
                        length "3..63";
                      }
                    }
                  }
                }
              }
            }
          }

          // interface * / ip dhcp snooping bridge-domain *
          list bridge-domain {
            tailf:info "DHCP Snooping bridge-domain";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            key id;
            leaf id {
              type uint16 {
                tailf:info "<1-4094>;;DHCP Snooping bridge-domain number";
                range "1..4094";
              }
            }
            container information {
              tailf:info "DHCP Snooping information";
              tailf:cli-flatten-container;
              container option {
                tailf:info "DHCP Snooping information option";
                container format-type {
                  tailf:info "Option 82 information format";
                  container circuit-id {
                    tailf:info "Circuit id option 82 format";
                    leaf string {
                      tailf:info "User defined string for circuit id";
                      type string {
                        tailf:info "WORD;;Use string for circuit id";
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }

      // interface * / ip mtu
      leaf mtu {
        tailf:info "Set IP Maximum Transmission Unit";
        tailf:cli-diff-dependency "../../mtu";
        type uint16 {
          tailf:info "<68-9216>;;MTU (bytes)";
          range "68..9216";
        }
      }

      // interface * / ip nat
      container nat {
        tailf:info "NAT interface commands";
        leaf allow-static-host {
          tailf:info "Allow static-ip clients";
          type empty;
        }
        leaf enable {
          tailf:info "Enable Address Translation (NVI)";
          type empty;
        }
        choice nat-choice {
          leaf inside {
            tailf:info "Inside interface for address translation";
            type empty;
          }
          leaf outside {
            tailf:info "Outside interface for address translation";
            type empty;
          }
        }
      }

      // interface * / ip rsvp
      container rsvp {
        tailf:info "RSVP Interface Commands";

        // interface * / ip rsvp bandwidth
        container bandwidth {
          tailf:info "RSVP Reservable Bandwidth (kbps)";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-delete-when-empty;
          presence true;
          leaf interface-bandwidth {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-2147483647>;;Reservable Bandwidth (kbps)";
              range "1..2147483647";
            }
          }
          leaf single-flow-bandwidth {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-2147483647>;;Largest Reservable Flow (kbps)";
              range "1..2147483647";
            }
          }
        }

        // interface * / ip rsvp bandwidth percent
        container bandwidth-percent {
          tailf:cli-drop-node-name;
          container bandwidth {
            tailf:info "RSVP Reservable Bandwidth (kbps)";
            tailf:cli-incomplete-command;
            tailf:cli-incomplete-no;
            container percent {
              tailf:info "Specify a percentage of interface bandwidth";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf rsvp-bandwidth {
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<1-1000>;;Percentage of bandwidth. Values higher than 100 represent overbooking";
                  range "1..1000";
                }
              }
              choice bandwidth-choice {
                leaf max-flow-bw {
                  tailf:cli-drop-node-name;
                  type uint32 {
                    tailf:info "<1-2147483647>;;Largest Reservable Flow (kbps)";
                    range "1..2147483647";
                  }
                }
                leaf percent {
                  tailf:info "Specify a percentage of interface bandwidth";
                  type uint16 {
                    tailf:info "<1-1000>;;Percentage of flow bandwidth. Values higher than 100 represent overbooking";
                    range "1..1000";
                  }
                }
              }
            }
          }
        }

        // interface * / ip rsvp signalling
        container signalling {
          tailf:info "RSVP signalling";

          // interface * / ip rsvp signalling hello
          container hello-rr {
            tailf:cli-drop-node-name;
            leaf hello {
              tailf:info "Enable neighbor-down detection";
              // dep: before this created, must change:
              tailf:cli-diff-dependency "../../hello-bfd/hello/bfd" {
                tailf:cli-trigger-on-set;
              }
              tailf:cli-diff-dependency "../../hello/graceful-restart" {
                tailf:cli-trigger-on-set;
              }
              tailf:cli-diff-dependency "../../hello-gr-nbr/hello/graceful-restart" {
                tailf:cli-trigger-on-set;
              }
              type empty;
            }
          }

          // interface * / ip rsvp signalling hello bfd
          container hello-bfd {
            tailf:cli-drop-node-name;
            container hello {
              tailf:info "Enable neighbor-down detection";
              tailf:cli-incomplete-command;
              tailf:cli-incomplete-no;
              leaf bfd {
                tailf:info "Configure BFD trigger for MPLS/TE FRR";
                tailf:cli-diff-dependency "../../../hello/graceful-restart" {
                  tailf:cli-trigger-on-set;
                }
                type empty;
              }
            }
          }

          // interface * / ip rsvp signalling hello graceful-restart
          container hello {
            tailf:info "Enable neighbor-down detection";
            tailf:cli-incomplete-command;
            tailf:cli-incomplete-no;
            container graceful-restart {
              tailf:info "Configure RSVP Graceful Restart";
              tailf:cli-full-command;
              tailf:cli-full-no;
              presence true;
            }
          }

          // interface * / ip rsvp signalling hello graceful-restart neighbor *
          container hello-gr-nbr {
            tailf:cli-drop-node-name;
            container hello {
              tailf:info "Enable neighbor-down detection";
              tailf:cli-incomplete-command;
              tailf:cli-incomplete-no;
              container graceful-restart {
                tailf:info "Configure RSVP Graceful Restart";
                tailf:cli-incomplete-command;
                tailf:cli-incomplete-no;
                list neighbor {
                  tailf:info "Specify a neighbor router";
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  key address;
                  leaf address {
                    type union {
                      type inet:ipv4-address {
                        tailf:info "A.B.C.D;;Neighbor address";
                      }
                      type inet:ipv6-address {
                        tailf:info "X:X:X:X::X;;Neighbor IPv6 address";
                      }
                    }
                  }
                }
              }
            }
          }
        }

        // interface * / ip rsvp resource-provider
        container resource-provider {
          tailf:info "RSVP resource provider";
          choice resource-provider-choice {
            leaf none {
              tailf:info "Associates NO resources with reservations";
              type empty;
            }
            leaf wfq {
              tailf:info "Associates WFQ resources with reservations";
              type enumeration {
                enum interface {
                                tailf:info "Associates WFQ queues and bandwidth at the interface level with reservations";
                }
                enum pvc {
                          tailf:info "Associates WFQ queues and bandwidth at the PVC level with reservations";
                }
              }
            }
          }
        }

        // interface * / ip rsvp tunnel overhead-percent
        container tunnel {
          tailf:info "Tunnel Interface Mode";
          leaf overhead-percent {
            tailf:info "Overhead percent to be reserved";
            tailf:cli-no-value-on-delete;
            tailf:cli-diff-delete-before "../../bandwidth";
            type uint8 {
              tailf:info "<0-100>;;Percentage Over-head on Tunnel";
            }
          }
        }
      }

      // interface * / ip verify
      container verify {
        tailf:info "Enable per packet validation";

        // interface * / ip verify
        container unicast {
          tailf:info "Enable per packet validation for unicast";

          // interface * / ip verify unicast reverse-path
          container reverse-path {
            tailf:info "Reverse path validation of source address (old command format)";
            tailf:cli-compact-syntax;
            tailf:cli-delete-when-empty;
            tailf:cli-reset-container;
            presence true;

            // interface * / ip verify unicast reverse-path allow-self-ping
            leaf allow-self-ping {
              tailf:info "Allow router to ping itself (opens vulnerability in verification)";
              type empty;
            }

            leaf access-list {
              tailf:cli-drop-node-name;
              tailf:cli-disallow-value "allow-self-ping";
              type exp-ip-acl-type;
            }
          }

          // interface * / ip verify unicast source
          container source {
            tailf:info "Validation of source address";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-all-siblings;
            }
            leaf reachable-via {
              tailf:info "Specify reachability check to apply to the source address";
              type enumeration {
                enum any {
                          tailf:info "Source is reachable via any interface";
                }
                enum rx {
                         tailf:info "Source is reachable via interface on which packet was received";
                }
              }
            }
            leaf allow-self-ping {
              tailf:cli-break-sequence-commands;
              tailf:info "Allow router to ping itself (opens vulnerability in verification)";
              type empty;
            }
            leaf allow-default {
              tailf:info "Allow default route to match when checking source address";
              type empty;
            }
            leaf access-list {
              tailf:cli-drop-node-name;
              tailf:cli-disallow-value "allow-self-ping|allow-default";
              type exp-ip-acl-type;
            }
          }
        }

        // interface * / ip verify source
        container source {
          tailf:info "source address";
          tailf:cli-delete-when-empty;
          presence true;

          // interface * / ip verify source vlan dhcp-snooping
          container vlan {
            tailf:info "vlan specification";
            container dhcp-snooping {
              tailf:info "snooping enable vlan";
              tailf:cli-reset-container;
              tailf:cli-delete-when-empty;
              presence true;
              leaf port-security {
                tailf:info "port security";
                type empty;
              }
            }
          }
        }
      }

      // interface * / ip rip
      container rip {
        tailf:info "Router Information Protocol";

        // interface * / ip rip send version
        container send {
          tailf:info "advertisement transmission";
          leaf version {
            tailf:info "version control";
            type enumeration {
              enum "1" {
                tailf:info "RIP version 1";
              }
              enum "2" {
                tailf:info "RIP version 2";
              }
            }
          }
        }

        // interface * / ip rip receive version
        container receive {
          tailf:info "advertisement reception";
          leaf version {
            tailf:info "version control";
            type enumeration {
              enum "1" {
                tailf:info "RIP version 1";
              }
              enum "2" {
                tailf:info "RIP version 2";
              }
            }
          }
        }

        // interface * / ip rip authentication
        container authentication {
          tailf:info "Authentication control";

          // interface * / ip rip authentication mode
          leaf mode {
            tailf:info "Authentication mode";
            type enumeration {
              enum md5 {
                        tailf:info "Keyed message digest";
              }
              enum text {
                         tailf:info "Clear text authentication";
              }
            }
          }

          // interface * / ip rip authentication key-chain
          leaf key-chain {
            tailf:info "Authentication key-chain";
            tailf:non-strict-leafref {
              path "/ios:key/chain/name";
            }
            type string {
              tailf:info "LINE;;name of key-chain";
            }
          }
        }
      }

      // interface * / ip mask-reply
      leaf mask-reply {
        tailf:info "Enable sending ICMP Mask Reply messages";
        tailf:cli-full-command;
        type empty;
      }

      // interface * / ip bandwidth-percent *
      container bandwidth-percent {
        tailf:info "Set EIGRP bandwidth limit";
        list eigrp {
          tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          key as-number;
          leaf as-number {
            type uint16 {
              tailf:info "<1-65535>;;AS number";
            }
          }
          leaf percent {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-999999>;;Maximum bandwidth percentage that EIGRP may use";
              range "1..999999";
            }
          }
        }
      }

      // interface * / no ip next-hop-self eigrp *
      // interface * / ip next-hop-self eigrp no-list *
      container next-hop-self {
        tailf:info "Configures EIGRP-IPv4 next-hop-self";
        container eigrp {
          tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
          list no-list {
            tailf:info "'no ip next-hop-self eigrp' entry";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key as-number;
            leaf as-number {
              type uint16 {
                tailf:info "<1-65535>;;AS number";
                range "1..65535";
              }
            }
          }
        }
      }

      // interface * / ip lisp source-locator
      container lisp {
        tailf:info "Locator/ID Separation Protocol";
        container source-locator {
          tailf:info "Choose IP source address for LISP packets egressing this interface";
          uses interface-name-grouping;
        }
      }

      // interface * / ip wccp
      container wccp {
        tailf:info "WCCP IPv4 interface commands";
        tailf:cli-diff-dependency "/ios:ip/wccp";
        uses interface-ip-wccp-grouping;

        // interface * / ip wccp vrf *
        list vrf {
          tailf:info "Configure WCCP for a VRF";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-incomplete-command;
          key name;
          leaf name {
            tailf:cli-diff-dependency "/ios:vrf/definition";
            type string {
              tailf:info "WORD;;VRF name";
            }
          }
          uses interface-ip-wccp-grouping;
        }
      }

      // interface * / ip device tracking
      container device {
        tailf:info "IP Device tracking";
        container tracking {
          tailf:info "IP device tracking";

          // interface * / ip device tracking probe
          container probe {
            tailf:info "IP device tracking Probe";
            leaf count {
              tailf:info "IP device tracking Probe count";
              type uint16 {
                tailf:info "<1-255>;;Probe count";
                range "1..255";
              }
            }
            leaf interval {
              tailf:info "IP device tracking Probe interval";
              type uint32 {
                tailf:info "<30-1814400>;;Probe interval";
                range "30..1814400";
              }
            }
          }

          // interface * / ip device tracking maximum
          leaf maximum {
            tailf:info "IP device tracking maximum";
            type uint16 {
              tailf:info "<0-65535>;;Maximum devices (0 means disabled)";
            }
          }
        }
      }

      // interface * / ip mfib
      container mfib {
        tailf:info "Interface Specific MFIB Control";

        // interface * / no ip mfib forwarding input
        // interface * / no ip mfib forwarding output
        container forwarding {
          tailf:info "Multicast forwarding to/from interface";
          leaf input {
            tailf:info "Multicast forwarding from interface";
            tailf:cli-boolean-no;
            tailf:cli-full-command;
            type boolean;
            default true;
          }
          leaf output {
            tailf:info "Multicast forwarding to interface";
            tailf:cli-boolean-no;
            tailf:cli-full-command;
            type boolean;
            default true;
          }
        }

        // interface * / ip mfib cef
        container cef {
          tailf:info "Multicast CEF to/from interface";

          // interface * / no ip mfib cef input
          leaf input {
            tailf:info "Multicast CEF from interface";
            tailf:cli-boolean-no;
            tailf:cli-full-command;
            type boolean;
            default true;
          }

          // interface * / no ip mfib cef output
          leaf output {
            tailf:info "Multicast CEF to interface";
            tailf:cli-boolean-no;
            tailf:cli-full-command;
            type boolean;
            default true;
          }
        }
      }

      // interface * / ip subscriber
      container subscriber {
        tailf:info "IP session configuration options";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-subscriber";
        presence true;
        leaf type {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          tailf:cli-remove-before-change;
          type enumeration {
            enum interface {
              tailf:info "Interface IP session";
            }
            enum l2-connected {
              tailf:info "Layer 2 connected IP sessions";
            }
            enum routed {
              tailf:info "Routed IP sessions";
            }
          }
        }

        // interface * / ip subscriber / initiator
        container initiator {
          tailf:info "IP session initiation configuration options";

          // interface * / ip subscriber / initiator dhcp
          leaf dhcp {
            tailf:info "IP session initiated by DHCP";
            type empty;
          }
        }
      }

      // interface * / ip load-sharing
      leaf load-sharing {
        tailf:info "Style of load sharing";
        type enumeration {
          enum per-destination {
            tailf:info "Deterministic distribution";
          }
          enum per-packet {
            tailf:info "Random distribution";
          }
          enum per-longest-match-prefix {
          }
        }
        default per-destination;
      }
    }

    // interface * / ipv6
    container ipv6 {
      tailf:info "IPv6 interface subcommands";
      tailf:cli-diff-dependency "/ios:ipv6/unicast-routing";

      // interface * / ipv6 address
      container address {
        tailf:info "Configure IPv6 address on interface";
        choice address-choice {

          // interface * / ipv6 address autoconfig
          case autoconfig-case {
            container autoconfig {
              tailf:info "Obtain address using autoconfiguration";
              presence true;
              leaf default {
                tailf:info "Insert default route";
                type empty;
              }
            }
          }

          // interface * / ipv6 address dhcp
          case dhcp-case {
            container dhcp {
              tailf:info "Obtain a ipv6 address using dhcp";
              tailf:cli-reset-container;
              tailf:cli-delete-when-empty;
              presence true;
              leaf rapid-commit {
                tailf:info "Enable Rapid-Commit";
                type empty;
              }
            }
          }

          // interface * / ipv6 address *
          case manual-case {
            list prefix-list {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              ios:if-addr-move;
              key prefix;
              leaf prefix {
                type union {
                  type inet:ipv6-address {
                    tailf:info "X:X:X:X::X;;IPv6 link-local address";
                  }
                  type ios:ipv6-prefix {
                    tailf:info "X:X:X:X::X/<0-128>;;IPv6 prefix";
                  }
                }
              }
              leaf link-local {
                tailf:info "Use link-local address";
                tailf:cli-full-command;
                type empty;
              }
              leaf anycast {
                tailf:info "Configure as an anycast";
                tailf:cli-full-command;
                type empty;
              }
              leaf eui-64 {
                tailf:info "Use eui-64 interface identifier";
                tailf:cli-full-command;
                type empty;
              }
            }
          }

          // interface * / ipv6 address * *
          case general-prefix-case {
            list general-prefix-list {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key "name prefix";
              leaf name {
                tailf:non-strict-leafref {
                  path "/ios:ipv6/general-prefix/name";
                }
                type string {
                  tailf:info "WORD;;General prefix name";
                }
              }
              leaf prefix {
                type ios:ipv6-prefix {
                  tailf:info "X:X:X:X::X/<0-128>;;IPv6 prefix";
                }
              }
              leaf anycast {
                tailf:info "Configure as an anycast";
                tailf:cli-full-command;
                type empty;
              }
              leaf eui-64 {
                tailf:info "Use eui-64 interface identifier";
                tailf:cli-full-command;
                type empty;
              }
            }
          }
        }
      }

      // interface * / ipv6 enable
      leaf enable {
        tailf:info "Enable IPv6 on interface";
        tailf:cli-diff-dependency "/ios:vrf/definition/address-family/ipv6";
        type empty;
      }

      // interface * / ipv6 mode host unicast
      container mode {
        tailf:info "Interface mode";
        container host {
          tailf:info "Inhibit forwarding on interface";
          leaf unicast {
            tailf:info "Unicast traffic";
            type empty;
          }
        }
      }

      // interface * / ipv6 unnumbered
      container unnumbered {
        tailf:info "Preferred interface for source address selection";
        uses interface-name-grouping;
      }

      // interface * / ipv6 traffic-filter *
      // interface * / ipv6 traffic-filter common *
      list traffic-filter {
        tailf:info "Access control list for packets";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        key direction;
        leaf direction {
          type enumeration {
            enum "in" {
              tailf:info "inbound packets";
            }
            enum "out" {
              tailf:info "outbound packets";
            }
          }
        }
        leaf common {
          tailf:info "Common access control list";
          tailf:cli-prefix-key;
          tailf:cli-optional-in-sequence;
          type empty;
        }
        leaf access-list {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          tailf:non-strict-leafref {
            path "/ios:ipv6/access-list/named-acl/name";
          }
          tailf:cli-disallow-value "common";
          type string {
            tailf:info "WORD;;Access-list name";
          }
        }
        leaf regular-access-list {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          tailf:cli-optional-in-sequence;
          tailf:non-strict-leafref {
            path "/ios:ipv6/access-list/named-acl/name";
          }
          tailf:cli-disallow-value "common|in|out";
          type string {
            tailf:info "WORD;;Access-list name";
          }
        }
      }

      // interface * / ipv6 nd
      container nd {
        tailf:info "IPv6 interface Neighbor Discovery subcommands";

        // interface * / ipv6 nd dad
        container dad {
          tailf:info "Duplicate Address Detection";

          // interface * / ipv6 nd dad attempts
          leaf attempts {
            tailf:info "Set IPv6 Duplicate Address Detection Transmits";
            type uint16 {
              tailf:info "<0-600>;;Number of attempts. Default 1";
              range "0..600";
            }
            default 1;
          }

          // interface * / ipv6 nd dad time
          leaf time {
            tailf:info "Set IPv6 Duplicate Address Detection Time";
            type uint16 {
              tailf:info "<1-6000>;;time (milliseconds)";
              range "1..6000";
            }
          }
        }

        // interface * / ipv6 nd reachable-time
        leaf reachable-time {
          tailf:info "Set advertised reachability time";
          type uint32 {
            tailf:info "<0-3600000>;;Reachability time in milliseconds. Default 0";
            range "0..3600000";
          }
          default 0;
        }

        // interface * / ipv6 nd cache
        container cache {
          tailf:info "Cache entry";

          // interface * / ipv6 nd cache interface-limit
          container interface-limit {
            tailf:info "Limit on number of entries per interface";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf size {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<1-4294967295>;;Number of entries";
                range "1..4294967295";
              }
            }
            leaf log {
              tailf:info "Logging rate";
              type uint16 {
                tailf:info "<1-3600>;;Rate in seconds";
                range "1..3600";
              }
            }
          }

          // interface * / ipv6 nd cache expire
          container expire {
            tailf:info "Expiry time for ND entries";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf seconds {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<1-65536>;;Expiry time (seconds)";
                range "1..65536";
              }
            }
            leaf refresh {
              tailf:info "Automatically refresh entry";
              type empty;
            }
          }
        }

        // interface * / ipv6 nd prefix
        container prefix {
          tailf:info "Configure IPv6 Routing Prefix Advertisement";

          // interface * / ipv6 nd prefix *
          list prefix-list {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-all-siblings;
            }
            tailf:cli-incomplete-command;
            key ipv6-prefix;
            leaf ipv6-prefix {
              type union {
                type ipv6-prefix {
                  tailf:info "X:X:X:X::X/<0-128>;;IPv6 prefix x:x::y/<z>";
                }
                type enumeration {
                  enum "default" {
                    tailf:info "Specify prefix default parameters";
                  }
                }
              }
            }
            // interface * / ipv6 nd prefix * no-advertise
            choice advertise-choice {
              case no-advertise {
                leaf no-advertise {
                  tailf:info "Do not advertise prefix";
                  tailf:cli-full-command;
                  type empty;
                }
              }
              case advertise {
                // interface * / ipv6 nd prefix * <valid-lifetime>
                leaf valid-lifetime {
                  tailf:cli-drop-node-name;
                  tailf:cli-incomplete-command;
                  type union {
                    type enumeration {
                      enum "infinite" {
                        tailf:info "Infinite Valid Lifetime";
                      }
                    }
                    type uint32 {
                      tailf:info "<0-4294967295>;;Valid Lifetime (secs)";
                    }
                  }
                }
                // interface * / ipv6 nd prefix * <preferred-lifetime>
                leaf preferred-lifetime {
                  tailf:cli-drop-node-name;
                  type union {
                    type enumeration {
                      enum "infinite" {
                        tailf:info "Infinite Preferred Lifetime";
                      }
                    }
                    type uint32 {
                      tailf:info "<0-4294967295>;;Preferred Lifetime (secs)";
                    }
                  }
                }
                // interface * / ipv6 nd prefix * off-link
                leaf off-link {
                  tailf:cli-break-sequence-commands;
                  tailf:info "Prefix is offlink";
                  type empty;
                }
                // interface * / ipv6 nd prefix * no-autoconfig
                leaf no-autoconfig {
                  tailf:info "Do not use prefix for autoconfiguration";
                  type empty;
                }
                // interface * / ipv6 nd prefix * no-rtr-address
                leaf no-rtr-address {
                  tailf:info "Do not send full router address in prefix advert";
                  type empty;
                }
                // interface * / ipv6 nd prefix * no-onlink
                leaf no-onlink {
                  tailf:info "Do not use prefix for onlink determination";
                  type empty;
                }
              }
            }
          }
        }

        // interface * / ipv6 nd managed-config-flag
        leaf managed-config-flag {
          tailf:info "Hosts should use DHCP for address config";
          type empty;
        }

        // interface * / ipv6 nd other-config-flag
        leaf other-config-flag {
          tailf:info "Hosts should use DHCP for non-address config";
          type empty;
        }

        // interface * / ipv6 nd ra
        container ra {
          tailf:info "Router Advertisement control";

          // interface * / ipv6 nd ra suppress
          container suppress {
            tailf:info "Suppress IPv6 Router Advertisements";
            tailf:cli-delete-when-empty;
            presence true;
            leaf all {
              tailf:info "Suppress all ipv6 Router advertisements";
              type empty;
            }
          }

          // interface * / ipv6 nd ra interval
          container interval {
            choice interval-choice {
              leaf seconds {
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<4-1800>;;RA Interval (sec). Default 200";
                  range "4..1800";
                }
                default 200;
              }
              leaf msec {
                tailf:info "Interval in milliseconds";
                type uint32 {
                  tailf:info "<70-1800000>;;RA Interval (msec)";
                  range "70..1800000";
                }
              }
            }
          }

          // interface * / ipv6 nd ra lifetime
          leaf lifetime {
            tailf:info "Set IPv6 Router Advertisement Lifetime";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<0-9000>;;RA Lifetime (seconds). Default 1800";
              range "0..9000";
            }
            default 1800;
          }
        }

        // interface * / ipv6 nd raguard
        container raguard {
          tailf:info "apply the router advertisements (RA) guard feature";
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          presence true;

          // interface * / ipv6 nd raguard attach-policy
          leaf attach-policy {
            tailf:info "Apply a policy for feature RA guard";
            tailf:non-strict-leafref {
              path "/ios:ipv6/nd/raguard/policy/name";
            }
            type string {
              tailf:info "WORD;;policy name for feature RA guard";
            }
          }
        }

        // interface * / ipv6 nd autoconfig
        container autoconfig {
          tailf:info "Automatic Configuration";

          // interface * / ipv6 nd autoconfig prefix
          leaf prefix {
            tailf:info "Prefix";
            tailf:cli-full-command;
            type empty;
          }

          // interface * / ipv6 nd autoconfig default-route
          leaf default-route {
            tailf:info "Default Route";
            tailf:cli-full-command;
            type empty;
          }
        }

        // interface * / ipv6 nd router-preference
        leaf router-preference {
          tailf:info "Set default router preference value";
          type enumeration {
            enum Low {
              tailf:info "Low default router preference";
            }
            enum Medium {
              tailf:info "Medium default router preference";
            }
            enum High {
              tailf:info "High default router preference";
            }
          }
        }

        // interface * / ipv6 nd inspection
        container inspection {
          tailf:info "Configure NDP inspection on the interface";
          presence true;

          // interface * / ipv6 nd inspection vlan *
          container vlan {
            tailf:info "Configure the vlan list for which this policy applies (default: all)";
            choice vlan-choice {
              default which;
              leaf which {
                tailf:cli-drop-node-name;
                type enumeration {
                  enum all {
                    tailf:info "all VLANs";
                  }
                  enum none {
                    tailf:info "no VLANs";
                  }
                }
                default all;
              }
              leaf-list vlans {
                tailf:cli-drop-node-name;
                tailf:cli-range-list-syntax;
                tailf:cli-replace-all;
                ios:leaf-list-modify-replace "default ipv6 nd inspection vlan none";
                type uint16 {
                  tailf:info "WORD;;VLAN IDs of the VLANs for which this policy applies";
                  range "1..4094";
                }
              }
            }
          }
        }
      }

      // interface * / ipv6 mld
      container mld {
        tailf:info "interface commands";

        // interface * / ipv6 mld query-timeout
        leaf query-timeout {
          tailf:info "previous querier timeout";
          type uint16 {
            tailf:info "<1-18016>;;timeout value in seconds. Default 255";
            range "1..18016";
          }
          default 255;
        }

        // interface * / ipv6 mld query-interval
        leaf query-interval {
          tailf:info "host query interval";
          type uint16 {
            tailf:info "<1-3600>;;Query interval in seconds. Default 125";
            range "1..3600";
          }
          default 125;
        }

        // interface * / ipv6 mld access-group
        leaf access-group {
          tailf:info "source, group membership access";
          type string {
            tailf:info "WORD;;Named access list specifying access group range";
          }
        }

        // interface * / no ipv6 mld router
        leaf router {
          tailf:info "Disable membership tracking";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }

        // interface * / no ipv6 mld snooping
        container snooping-enable {
          tailf:cli-drop-node-name;
          leaf snooping {
            tailf:cli-boolean-no;
            type boolean;
            default true;
          }
        }
      }

      // interface * / ipv6 pim
      container pim {
        tailf:info "PIM interface commands";

        // interface * / ipv6 pim hello-interval
        leaf hello-interval {
          tailf:info "PIM neighbor Hello announcement interval";
          type uint16 {
            tailf:info "<1-3600>;;Hello interval in seconds";
            range "1..3600";
          }
        }
      }

      // interface * / no ipv6 redirects
      leaf redirects {
        tailf:info "Enable sending of ICMP Redirect messages";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // interface * / no ipv6 unreachables
      leaf unreachables {
        tailf:info "Enable sending of ICMP Unreachable messages";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // interface * / ipv6 tcp adjust-mss
      container tcp {
        tailf:info "TCP interface commands";
        leaf adjust-mss {
          tailf:info "Adjust the mss of IPV6 transit packets";
          type uint16 {
            tailf:info "<40-1454>;;Maximum segment size in bytes";
            range "40..1454";
          }
        }
      }

      // interface * / ipv6 router isis
      container router {
        tailf:info "IPv6 Router interface commands";
        container isis {
          tailf:info "isis  IS-IS Routing for IPv6";
          tailf:cli-delete-when-empty;
          presence true;
          leaf tag {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;Routing process tag";
            }
          }
        }
      }

      // interface * / ipv6 ospf
      container ospf {
        tailf:info "OSPF interface commands";
        // does not work due to ipv6 address re-inject with vrf (must be solved in java)
        // tailf:cli-diff-dependency "../address/prefix-list";

        // interface * / ipv6 ospf network
        leaf network {
          tailf:info "Network type";
          tailf:cli-full-command;
          type enumeration {
            enum broadcast {
              tailf:info "Specify OSPF broadcast multi-access network";
            }
            enum non-broadcast {
              tailf:info "Specify OSPF NBMA network";
            }
            enum point-to-multipoint {
              tailf:info "Specify OSPF point-to-multipoint network";
            }
            enum point-to-point {
              tailf:info "Specify OSPF point-to-point network";
            }
          }
        }

        // interface * / ipv6 ospf *
        list process {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          key id;
          leaf id {
            type uint16 {
              tailf:info "<1-65535>;;Process ID";
              range "1..65535";
            }
          }
          leaf area {
            tailf:info "Set the OSPF area ID";
            type union {
              type uint32 {
                tailf:info "<0-4294967295>;;OSPF area ID as a decimal value";
                range "0..4294967295";
              }
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;OSPF area ID in IP address format";
              }
            }
          }
          leaf instance {
            tailf:info "Set the OSPF instance";
            type union {
              type uint8 {
                tailf:info "<0-31>;;Instance ID";
                range "0..31";
              }
              type uint8 {
                tailf:info "<32-255>;;Instance ID (DEPRECATED!)";
                range "32..255";
              }
            }
          }
        }

        // interface * / ipv6 ospf bfd
        container bfd {
          tailf:info "Enable BFD on this interface";
          presence true;
          leaf disable {
            tailf:info "Disable BFD on this interface";
            type empty;
          }
        }

        // interface * / ipv6 ospf cost
        leaf cost {
          tailf:info "Route cost of this interface";
          type uint16 {
            tailf:info "<1-65535>;;Route cost of this interface";
            range "1..65535";
          }
        }

        // interface * / ipv6 ospf database-filter
        container database-filter {
          tailf:info "Filter OSPF LSA during synchronization and flooding";
          choice database {
            leaf all {
              tailf:info "Filter all LSA";
              type enumeration {
                enum out {
                  tailf:info "Outgoing LSA";
                }
              }
            }
            leaf disable {
              tailf:info "Disable LSA Filter on this interface";
              type empty;
            }
          }
        }

        // interface * / ipv6 ospf dead-interval
        leaf dead-interval {
          tailf:info "Interval after which a neighbor is declared dead";
          type uint16 {
            tailf:info "<1-65535>;;Seconds";
            range "1..65535";
          }
        }

        // interface * / ipv6 ospf demand-circuit
        container demand-circuit {
          tailf:info "OSPF demand circuit";
          presence true;
          leaf disable {
            tailf:info "Disable demand circuit on this interface";
            type empty;
          }
        }

        // interface * / ipv6 ospf flood-reduction
        container flood-reduction {
          tailf:info "OSPF Flood Reduction";
          presence true;
          leaf disable {
            tailf:info "Disable Flood Reduction on this interface";
            type empty;
          }
        }

        // interface * / ipv6 ospf hello-interval
        leaf hello-interval {
          tailf:info "Time between HELLO packets";
          type uint16 {
            tailf:info "<1-65535>;;Seconds";
            range "1..65535";
          }
        }

        // interface * / ipv6 ospf mtu-ignore
        container mtu-ignore {
          tailf:info "Ignores the MTU in DBD packets";
          presence true;
          leaf disable {
            tailf:info "Disable Ingore MTU on this interface";
            type empty;
          }
        }

        // interface * / ipv6 ospf priority
        leaf priority {
          tailf:info "Router priority";
          type uint16 {
            tailf:info "<0-255>;;Priority";
            range "0..255";
          }
        }

        // interface * / ipv6 ospf retransmit-interval
        leaf retransmit-interval {
          tailf:info "Time between retransmitting lost link state advertisements";
          type uint16 {
            tailf:info "<1-65535>;;Seconds";
            range "1..65535";
          }
        }

        // interface * / ipv6 ospf retransmit-interval
        leaf transmit-delay {
          tailf:info "Link state transmit delay";
          type uint16 {
            tailf:info "<1-65535>;;Seconds";
            range "1..65535";
          }
        }
      }

      // interface * / ipv6 eigrp *
      leaf-list eigrp {
        tailf:cli-list-syntax;
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<1-65535>;;AS number";
          range "1..65535";
        }
      }

      // interface * / ipv6 mtu
      leaf mtu {
        tailf:info "Set IPv6 Maximum Transmission Unit";
        type uint16 {
          tailf:info "<1280-18000>;;MTU (bytes)";
          range "1280..18000";
        }
      }

      // interface * / ipv6 crypto map
      container crypto {
        tailf:info "Encryption/Decryption commands";
        container map {
          tailf:info "Assign a Crypto Map";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf map-name {
            tailf:cli-drop-node-name;
            tailf:cli-diff-dependency "/ios:crypto/map";
            type string {
              tailf:info "WORD;;Crypto Map tag";
            }
          }
          leaf redundancy {
            tailf:info "enable redundancy";
            type string {
              tailf:info "WORD;;Name of IP Redundancy Group";
            }
          }
          leaf stateful {
            tailf:info "enable stateful failover";
            type empty;
          }
        }
      }

      // interface * / ipv6 hold-time eigrp *
      container hold-time {
        tailf:info "Configures EIGRP-IPv6 hold time";
        list eigrp {
          tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key as-no;
          leaf as-no {
            type uint16 {
              tailf:info "<1-65535>;;AS number";
              range "1..65535";
            }
          }
          leaf seconds {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<1-65535>;;Seconds before neighbor is considered down";
              range "1..65535";
            }
          }
        }
      }

      // interface * / ipv6 hello-interval eigrp *
      container hello-interval {
        tailf:info "Configures EIGRP-IPv6 hello interval";
        list eigrp {
          tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key as-no;
          leaf as-no {
            type uint16 {
              tailf:info "<1-65535>;;AS number";
              range "1..65535";
            }
          }
          leaf seconds {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<1-65535>;;Seconds between hello transmission";
              range "1..65535";
            }
          }
        }
      }

      // interface * / ipv6 verify
      container verify {
        tailf:info "Enable per packet validation";
        container unicast {
          tailf:info "Enable per packet validation for unicast";

          // interface * / ipv6 verify unicast source reachable-via
          container source {
            tailf:info "Validation of source address";
            leaf reachable-via {
              tailf:info "Specify reachability check to apply to the source address";
              type enumeration {
                enum any {
                  tailf:info "Source is reachable via any interface";
                }
                enum rx {
                  tailf:info "Source is reachable via interface on which packet was received";
                }
              }
            }
          }

          // interface * / ipv6 verify unicast reverse-path
          container reverse-path {
            tailf:info "Reverse path validation of source address (old command format)";
            tailf:cli-delete-when-empty;
            presence true;
            leaf access-list {
              tailf:cli-drop-node-name;
              tailf:non-strict-leafref {
                path "/ios:ipv6/access-list/named-acl/name";
              }
              type string {
                tailf:info "WORD;;Access-list name";
              }
            }
          }
        }
      }

      // interface * / ipv6 dhcp
      container dhcp {
        tailf:info "IPv6 DHCP interface subcommands";

        // interface * / ipv6 dhcp relay
        container relay {
          tailf:info "Act as an IPv6 DHCP relay agent";

          // interface * / ipv6 dhcp relay destination *
          list destination {
            tailf:info "Configure relay destination";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            key ipv6-address;
            leaf ipv6-address {
              type inet:ipv6-address {
                tailf:info "X:X:X:X::X;;IPv6 address";
              }
            }
            leaf source-address {
              tailf:info "Configure source address to use for relay-forward";
              tailf:cli-optional-in-sequence;
              type inet:ipv6-address {
                tailf:info "X:X:X:X::X;;IPv6 src address";
              }
            }
            leaf link-address {
              tailf:info "Configure link-address to use for relay-forward";
              type inet:ipv6-address {
                tailf:info "X:X:X:X::X;;IPv6 link address";
              }
            }
          }

          // interface * / ipv6 dhcp relay source-interface
          container source-interface {
            tailf:info "Set source interface for relayed messages";
            uses interface-name-grouping;
          }
        }

        // interface * / ipv6 dhcp client
        container client {
          tailf:info "Act as an IPv6 DHCP client";

          // interface * / ipv6 dhcp client information refresh minimum
          container information {
            tailf:info "Configure information refresh option";
            container refresh {
              tailf:info "Configure information refresh parameters";
              leaf minimum {
                tailf:info "Minimum information refresh time";
                type uint16 {
                  tailf:info "<60-3600>;;Seconds";
                  range "60..3600";
                }
              }
            }
          }
        }

        // interface * / ipv6 dhcp server
        choice server-choice {
          // interface * / ipv6 dhcp server
          leaf server {
            tailf:info "Act as an IPv6 DHCP server";
            tailf:cli-full-command;
            tailf:cli-full-no;
            type empty;
          }
          // interface * / ipv6 dhcp server ?
          container server-name {
            tailf:cli-drop-node-name;
            container server {
              tailf:info "Act as an IPv6 DHCP server";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-all-siblings;
              }
              tailf:cli-incomplete-command;
              tailf:cli-incomplete-no;
              leaf poolname {
                tailf:cli-drop-node-name;
                type string {
                  tailf:info "WORD;;Name of IPv6 DHCP pool";
                }
              }
              leaf rapid-commit {
                tailf:info "Enable Rapid-Commit";
                tailf:cli-break-sequence-commands;
                type empty;
              }
              leaf preference {
                tailf:info "Preference";
                type uint8 {
                  tailf:info "<0-255>;;Preference value";
                }
              }
              leaf allow-hint {
                tailf:info "Allow hint from client";
                type empty;
              }
            }
          }
        }

        // interface * / ipv6 dhcp guard
        container guard {
          tailf:info "Configure IPv6 DHCP guard on the interface";
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          presence true;

          // interface * / ipv6 dhcp guard attach-policy
          leaf attach-policy {
            tailf:info "Apply a policy for feature DHCP Guard";
            tailf:non-strict-leafref {
              path "/ios:ipv6/dhcp/guard/policy/name";
            }
            type string {
              tailf:info "WORD;;policy name for feature DHCP Guard";
            }
          }
        }
      }

      // interface * / ipv6 nhrp
      container nhrp {
        tailf:info "NHRP interface subcommands";

        // interface * / ipv6 nhrp map
        container map {
          tailf:info "Map dest IPv6 address to NBMA address";

          // interface * / ipv6 nhrp map *
          list map-list {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key ipv6-address;
            leaf ipv6-address {
              tailf:cli-drop-node-name;
              type ipv6-prefix {
                tailf:info "X:X:X:X::X/<0-128>;;IPv6 address/mask of destination";
              }
            }
            leaf nbma-address {
              tailf:cli-drop-node-name;
              type union {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IP NBMA address";
                }
                type inet:ipv6-address {
                  tailf:info "X:X:X:X::X;;IPv6 NBMA address";
                }
              }
            }
          }

          // interface * / ipv6 nhrp map multicast
          container multicast {
            tailf:info "Use this NBMA mapping for broadcasts/multicasts";

            // interface * / ipv6 nhrp map multicast dynamic
            leaf dynamic {
              tailf:info "Dynamically learn destinations from client registrations on hub";
              type empty;
            }

            // interface * / ipv6 nhrp map multicast *
            list multicast-list {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key nbma-address;
              leaf nbma-address {
                type union {
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;IP NBMA address";
                  }
                  type inet:ipv6-address {
                    tailf:info "X:X:X:X::X;;IPv6 NBMA address";
                  }
                }
              }
            }
          }
        }

        // interface * / ipv6 nhrp network-id
        leaf network-id {
          tailf:info "NBMA network identifier";
          type uint32 {
            tailf:info "<1-4294967295>;;Network identifier";
            range "1..4294967295";
          }
        }

        // interface * / ipv6 nhrp holdtime
        leaf holdtime {
          tailf:info "Advertised holdtime";
          type uint16 {
            tailf:info "<1-65535>;;Number of seconds";
            range "1..65535";
          }
        }

        // interface * / ipv6 nhrp nhs
        container nhs {
          tailf:info "Specify a next hop server";

          // interface * / ipv6 nhrp nhs *
          list nhs-list {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            key nhs-address;
            leaf nhs-address {
              type inet:ipv6-address {
                tailf:info "X:X:X:X::X;;Protocol IPv6 address of NHS";
              }
            }
            // interface * / ipv6 nhrp nhs * nbma
            leaf nbma {
              tailf:info "NBMA of NHS";
              type union {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IPv4 address";
                }
                type inet:ipv6-address {
                  tailf:info "X:X:X:X::X;;IPv6 address";
                }
                type string {
                  tailf:info "WORD;;NHS FQDN string";
                }
              }
            }
            // interface * / ip nhrp nhs * multicast
            leaf multicast {
              when "../nbma" {
                tailf:dependency "../nbma";
              }
              tailf:info "Use this NBMA mapping for broadcasts/multicasts";
              type empty;
            }
          }
        }

        // interface * / ipv6 nhrp server-only
        container server-only {
          tailf:info "Disable NHRP requests";
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          presence true;
          leaf non-caching {
            tailf:info "Do not create NHRP cache entries";
            type empty;
          }
        }

        // interface * / ipv6 nhrp registration
        container registration {
          tailf:info "Settings for registration packets.";

          // interface * / ipv6 nhrp registration no-unique
          leaf no-unique {
            tailf:info "Do not set the 'Unique' flag in registration requests.";
            type empty;
          }

          // interface * / ipv6 nhrp registration timeout
          leaf timeout {
            tailf:info "Time between periodic Registration messages";
            type uint16 {
              tailf:info "<1-65535>;;Number of seconds";
              range "1..65535";
            }
          }
        }

        // interface * / ipv6 nhrp shortcut
        container shortcut {
          tailf:info "Enable shortcut switching";
          presence true;
        }

        // interface * / ipv6 nhrp redirect
        container redirect {
          tailf:info "Enable NHRP redirect traffic indication";
          tailf:cli-delete-when-empty;
          presence true;
          leaf timeout {
            tailf:info "Specify interval over which to throttle";
            type uint8 {
              tailf:info "<2-30>;;Interval in seconds";
              range "2..30";
            }
          }
        }
      }

      // interface * / ipv6 summary-address eigrp *
      container summary-address {
        tailf:info "Perform address summarization";
        tailf:cli-diff-dependency "/ios:ipv6/unicast-routing";
        list eigrp {
          tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
          tailf:cli-delete-when-empty;
          tailf:cli-suppress-mode;
          key "as-no ipv6-address";
          leaf as-no {
            type uint16 {
              tailf:info "<1-65535>;;Autonomous system number";
              range "1..65535";
            }
          }
          leaf ipv6-address {
            type ios:ipv6-prefix {
              tailf:info "X:X:X:X::X/<0-128>;;IPv6 prefix";
            }
          }
          leaf distance {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<0-255>;;Administrative distance";
              range "0..255";
            }
          }
        }
      }

      // interface * / ipv6 rip *
      list rip {
        tailf:info "Configure RIP routing protocol";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;User selected string identifying this RIP process";
          }
        }

        // interface * / ipv6 rip * enable
        leaf enable {
          tailf:info "Enable/disable RIP routing";
          type empty;
        }

        // interface * / ipv6 rip * default-information
        container default-information {
          tailf:info "Configure handling of default route";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf default-route {
            tailf:cli-drop-node-name;
            tailf:cli-reset-container;
            type enumeration {
              enum only {
                tailf:info "Advertise only the default route";
              }
              enum originate {
                tailf:info "Originate the default route";
              }
            }
          }
          leaf metric {
            tailf:info "Default route metric";
            type uint8 {
              tailf:info "<1-15>;;Metric value";
              range "1..15";
            }
          }
        }
      }

      // interface * / ipv6 wccp
      container wccp {
        tailf:info "WCCP IPv4 interface commands";
        tailf:cli-diff-dependency "/ios:ipv6/wccp";
        uses interface-ip-wccp-grouping;

        // interface * / ipv6 wccp vrf *
        list vrf {
          tailf:info "Configure WCCP for a VRF";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-incomplete-command;
          key name;
          leaf name {
            tailf:cli-diff-dependency "/ios:vrf/definition";
            type string {
              tailf:info "WORD;;VRF name";
            }
          }
          uses interface-ip-wccp-grouping;
        }
      }

      // interface * / ipv6 policy route-map
      container policy {
        tailf:info "Enable IPv6 policy routing";
        leaf route-map {
          tailf:info "IPv6 policy-based-routing routemap";
          type string {
            tailf:info "WORD;;Route-map name";
          }
        }
      }

      // interface * / ipv6 flow monitor * input
      // interface * / ipv6 flow monitor * output
      container flow {
        tailf:info "Flow related commands";
        list monitor {
          tailf:info "Apply a Flow Monitor";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-diff-delete-before "/ios:flow/monitor/record-netflow/record/netflow" {
            tailf:cli-when-target-delete;
          }
          cli:ned-diff-move-after ">flow monitor " {
            cli:arguments "parent|when-set";
          }
          cli:ned-diff-move-before ">flow monitor " {
            cli:arguments "parent|when-delete";
          }
          key "name direction";
          leaf name {
            ios:config-lock " ipv6 flow monitor (\\S+)(?: sampler \\S+)? (?:input|output) :: flow monitor $1";
            tailf:non-strict-leafref {
              path "/ios:flow/monitor/name";
            }
            type string {
              tailf:info "WORD;;Flow Monitor name";
            }
          }
          leaf sampler {
            tailf:info "Optional Sampler to apply to this Flow Monitor";
            tailf:cli-prefix-key {
              tailf:cli-before-key 2;
            }
            tailf:cli-optional-in-sequence;
            tailf:non-strict-leafref {
              path "/ios:sampler/name";
            }
            type string {
              tailf:info "WORD;;Sampler name";
            }
          }
          leaf direction {
            type enumeration {
              enum "input" {
                tailf:info "Apply Flow Monitor on input traffic";
              }
              enum "output" {
                tailf:info "Apply Flow Monitor on output traffic";
              }
            }
          }
        }
      }
    }

    // interface * / ospfv3
    container ospfv3 {
      tailf:info "OSPFv3 interface commands";
      tailf:cli-diff-dependency "/ios:ipv6/unicast-routing";
      tailf:cli-diff-dependency "/ios:router/ospfv3";
      uses interface-ospfv3-grouping;
      list ospfv3-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          tailf:cli-suppress-range;
          type uint16 {
            tailf:info "<1-65535>;;Process ID";
            range "1..65535";
          }
        }
        uses interface-ospfv3-grouping;
        container ipv4 {
          tailf:info "Specify parameters for IPv4";
          uses interface-ospfv3-grouping;
        }
        container ipv6 {
          tailf:info "Specify parameters for IPv6";
          uses interface-ospfv3-grouping;
        }
      }
    }

    // interface * / nat64 enable
    container nat64 {
      tailf:info "NAT64 interface commands";
      leaf enable {
        tailf:info "Enable NAT64";
        type empty;
      }
    }

    // interface * / lisp
    container lisp {
      tailf:info "Locator/ID Separation Protocol";

      // interface * / lisp mobility
      container mobility {
        tailf:info "Configures to allow EID mobility on interface";

        // interface * / lisp mobility liveness
        container liveness {
          tailf:info "Configure mobility liveness settings";

          // interface * / no lisp mobility liveness test
          leaf test {
            tailf:info "Perform liveness test on dynamic-EID discovered on this interface";
            tailf:cli-boolean-no;
            tailf:cli-full-command;
            type boolean;
            default true;
          }
        }

        // interface * / lisp mobility *
        list name-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-full-command;
          key name;
          leaf name {
            tailf:cli-disallow-value "discover|liveness";
            type string {
              tailf:info "WORD;;Name of the dynamic-EID to use";
            }
          }
        }
      }
    }

    // interface * / nhrp
    container nhrp {
      tailf:info "NHRP Interface commands";

      // interface * / nhrp group
      leaf group {
        tailf:info "NHRP group name";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;group name string";
        }
      }

      // interface * / no nhrp route-watch
      leaf route-watch {
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        tailf:cli-diff-dependency "../../ip/nhrp";
        type boolean;
        default true;
      }
    }

    // interface * / if-state nhrp
    container if-state {
      tailf:info "Allow applications to control interface state";
      leaf nhrp {
        tailf:info "Allow NHRP to control interface state";
        type empty;
      }
    }

    // interface * / umbrella
    container umbrella {
      tailf:info "Umbrella interface commands";
      tailf:cli-diff-dependency "/ios:parameter-map/type/umbrella/global";
      leaf out {
        tailf:info "Umbrella Out direction";
        tailf:cli-diff-dependency "../in" {
          tailf:cli-trigger-on-set;
        }
        type empty;
      }
      leaf in {
        tailf:info "Umbrella In direction";
        tailf:cli-diff-dependency "../out" {
          tailf:cli-trigger-on-set;
        }
        type string {
          tailf:info "WORD;;Umbrella interface tag";
        }
      }
    }

    // interface * / utd enable
    container utd {
      tailf:info "UTD support on this interface";
      leaf enable {
        tailf:info "Enable threat defense on this interface";
        tailf:cli-diff-dependency "/ios:utd/all-interfaces" {
          tailf:cli-trigger-on-set;
        }
        type empty;
      }
    }

    // interface * / delay
    leaf delay {
      tailf:info "Specify interface throughput delay";
      type uint32 {
        tailf:info "<1-16777215>;;Throughput delay (tens of microseconds)";
      }
    }

    // interface * / load-interval
    leaf load-interval {
      tailf:info "Specify interval for load calculation for an interface";
      type uint16 {
        tailf:info "<30-600>;;Load interval delay in seconds. Default 300";
        range "0..600";
      }
      default 300;
    }

    // interface * / loopback mac
    container loopback {
      tailf:info "Configure internal loopback on an interface";
      leaf mac {
        tailf:info "Loopback towards system at the MAC controller level";
        type empty;
      }
    }

    // interface * / logging
    container logging {
      tailf:info "Configure logging for interface";

      // interface * / logging event
      container event {
        tailf:info "Interface events";

        // interface * / no logging event link-status
        leaf link-status {
          tailf:info "UPDOWN and CHANGE messages";
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }

        // interface * / logging event trunk-status
        leaf trunk-status {
          tailf:info "TRUNK status messages";
          tailf:cli-full-command;
          type empty;
        }

        // interface * / logging event bundle-status
        leaf bundle-status {
          tailf:info "BUNDLE/UNBUNDLE messages";
          tailf:cli-full-command;
          type empty;
        }

        // interface * / logging event subif-link-status
        leaf subif-link-status {
          tailf:info "Sub-interface UPDOWN and CHANGE messages";
          tailf:cli-full-command;
          type empty;
        }

        // interface * / logging event spanning-tree
        container spanning-tree {
          tailf:info "Spanning-tree Interface events";
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          presence true;
          leaf status {
            tailf:info "Spanning-tree state change messages";
            type empty;
          }
        }

        // interface * / logging event nfas-status
        leaf nfas-status {
          tailf:info "NFAS D-channel status messages";
          tailf:cli-full-command;
          type empty;
        }

        // interface * / no logging event power-inline-status
        leaf power-inline-status {
          tailf:info "Inline power messages";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }
      }

      // interface * / logging ip access-list cache
      container ip {
        tailf:info "IP configuration";
        container access-list {
          tailf:info "Access-list";
          container cache {
            tailf:info "Optimized logging";
            leaf in {
              tailf:info "inbound packet logs";
              type empty;
            }
            leaf out {
              tailf:info "outbound packet logs";
              type empty;
            }
          }
        }
      }
    }

    // interface * / max-reserved-bandwidth
    leaf max-reserved-bandwidth {
      tailf:info "Maximum Reservable Bandwidth on an Interface";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<1-100>;;Max. reservable bandwidth as percent of interface bandwidth";
        range "1..100";
      }
    }

    // interface * / history
    container history {
      tailf:info "Interface history histograms - 60 second, 60 minute and 72 hour";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf xps {
        tailf:cli-drop-node-name;
        tailf:cli-remove-before-change;
        type enumeration {
          enum BPS {
            tailf:info "Maintain history in bits/second";
          }
          enum PPS {
            tailf:info "Maintain history in packets/second";
          }
        }
      }
      leaf-list filter {
        tailf:cli-drop-node-name;
        tailf:cli-flat-list-syntax;
        tailf:cli-remove-before-change;
        type string {
          tailf:info "WORD;;Optional Interface counter(s) | all";
        }
      }
    }

    // interface * / unidirectional
    leaf unidirectional {
      tailf:info "Configure unidirectional mode.";
      type enumeration {
        enum receive-only {
          tailf:info "Configure unidirectional receive only";
        }
        enum send-only {
          tailf:info "Configure unidirectional send only";
        }
      }
    }

    // interface * / mls
    container mls {
      tailf:info "mls sub/interface commands";

      // interface * / mls ip
      container ip {
        tailf:info "ip keyword";

        // interface * / mls ip directed-broadcast
        leaf directed-broadcast {
          tailf:info "Enable HW forwarding of directed broadcasts";
          type enumeration {
            enum drop {
              tailf:info "drop directed-broadcast pkts from recipient list";
            }
            enum exclude-router {
              tailf:info "exclude router from recipient list for directed broadcast";
            }
            enum include-router {
              tailf:info "include router in recipient list for directed broadcast";
            }
          }
        }
      }

      // interface * / mls netflow sampling
      container netflow {
        tailf:info "netflow command keyword";
        leaf sampling {
          tailf:info "sampling keyword";
          type empty;
        }
      }

      // interface * / mls qos
      container qos {
        tailf:info "qos command keyword";

        // interface * / mls qos cos
        container cos {
          tailf:info "Configure interface COS parameters";
          leaf cos-value {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<0-7>;;Class of service value between 0 and 7";
              range "0..7";
            }
          }
          leaf override {
            tailf:info "Force default COS on all packets";
            type empty;
          }
        }

        // interface * / no mls qos channel-consistency
        leaf channel-consistency {
          tailf:info "enable or disable qos consistency checks";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }

        // interface * / mls qos trust
        container trust {
          tailf:info "Configure trust state of interface";

          // interface * / mls qos trust device cisco-phone
          container device {
            tailf:info "trusted device class";
            leaf cisco-phone {
              tailf:info "Cisco IP Phone";
              type empty;
            }
          }

          choice trust-choice {

            // interface * / mls qos trust cos
            container cos {
              tailf:info "Classify by packet COS";
              tailf:cli-reset-container;
              tailf:cli-delete-when-empty;
              // dep: before this created, must change mls qos vlan-based
              tailf:cli-diff-dependency "../../vlan-based" {
                tailf:cli-trigger-on-set;
              }
              presence true;

              // interface * / mls qos trust cos pass-through dscp
              container pass-through {
                tailf:info "cos pass-through mode";
                leaf dscp {
                  tailf:info "transmit without dscp modification";
                  type empty;
                }
              }
            }

            // interface * / mls qos trust dscp
            container dscp {
              tailf:info "Classify by packet DSCP";
              // dep: before this created, must change mls qos vlan-based
              tailf:cli-diff-dependency "../../vlan-based" {
                tailf:cli-trigger-on-set;
              }
              presence true;

              // interface * / mls qos trust dscp pass-through cos
              container pass-through {
                tailf:info "dscp pass-through mode";
                leaf cos {
                  tailf:info "transmit without cos modification";
                  type empty;
                }
              }
            }

            // interface * / mls qos trust ip-precedence
            container ip-precedence {
              tailf:info "Classify by packet IP precedence";
              // dep: before this created, must change mls qos vlan-based
              tailf:cli-diff-dependency "../../vlan-based" {
                tailf:cli-trigger-on-set;
              }
              presence true;
            }
          }
        }

        // interface * / mls qos monitor
        container monitor {
          tailf:info "Collect QoS statistics";

          // interface * / mls qos monitor dscp
          leaf-list dscp {
            tailf:info "Collect DSCP statistics";
            tailf:cli-flat-list-syntax;
            ios:max-values-output "4 :: 8"; // values start after 4 words, max 8 per line
            max-elements 15;
            type uint8 {
              tailf:info "<0-63>;;dscp (up to 15 values total)";
              range "0..63";
            }
          }
        }

        // interface * / mls qos vlan-based
        leaf vlan-based {
          tailf:info "vlan-based keyword";
          tailf:cli-full-command;
          // dep: before this created, must change service-policy
          tailf:cli-diff-dependency "../../../service-policy/input" {
            tailf:cli-trigger-on-set;
          }
          tailf:cli-diff-dependency "../../../service-policy/output" {
            tailf:cli-trigger-on-set;
          }
          type empty;
        }

        // interface * / mls qos bridged
        leaf bridged {
          tailf:info "bridged keyword";
          tailf:cli-full-command;
          type empty;
        }

        // interface * / mls qos dscp-mutation
        leaf dscp-mutation {
          tailf:info "mutation keyword";
          tailf:cli-remove-before-change;
          tailf:non-strict-leafref {
            path "/ios:mls/qos/map/dscp-mutation/name";
          }
          type string {
            tailf:info "WORD;;dscp-mutation map name";
          }
        }
      }

      // interface * / mls l2tpv3 reserve
      container l2tpv3 {
        tailf:info "L2TPv3 feature";
        container reserve {
          tailf:info "reserve slot for L2TPv3 feature support";

          // interface * / mls l2tpv3 reserve slot
          leaf slot {
            tailf:info "slot for L2TPv3 feature support on SIP-400 card";
            type uint8 {
              tailf:info "<1-6>;;slot number";
            }
          }

          // interface * / mls l2tpv3 reserve interface *
          leaf-list interface {
            tailf:info "interface of the ES40";
            tailf:cli-flat-list-syntax;
            tailf:cli-replace-all;
            ordered-by user;
            type string {
              tailf:info "WORD;;Interface name";
            }
          }
        }
      }

      // interface * / mls rp
      container rp {
        tailf:info "rp";

        // interface * / mls rp vtp-domain
        leaf vtp-domain {
          tailf:info "vlan domain name on interface";
          type string {
            tailf:info "WORD;;vlan domain name";
          }
        }

        // interface * / mls rp ip
        leaf ip {
          tailf:info "enable multilayer switching for ip";
          type empty;
        }
      }
    }

    // interface * / trust device
    container trust {
      tailf:info "Set trust value for the interface";
      leaf device {
        tailf:info "trusted device class";
        type enumeration {
          enum cisco-phone {
            tailf:info "Cisco IP Phone";
          }
          enum cts {
            tailf:info "CTS";
          }
          enum ip-camera {
            tailf:info "IPVSC";
          }
          enum media-player {
            tailf:info "DMP";
          }
        }
      }
    }

    // interface * / auto qos
    container auto {
      tailf:info "Configure Automation";
      container qos {
        tailf:info "Configure AutoQoS";

        // interface * / auto qos voip
        container voip {
          tailf:info "Configure AutoQoS for VoIP";

          // interface * / auto qos voip cisco-phone
          leaf cisco-phone {
            tailf:info "Trust the QoS marking of Cisco IP Phone";
            type empty;
          }

          // interface * / auto qos voip trust
          leaf trust {
            tailf:info "Trust the COS marking";
            type empty;
          }
        }

        // interface * / auto qos trust
        container trust {
          tailf:info "Trust the DSCP/CoS marking";
          tailf:cli-diff-delete-before "../voip";
          presence true;
        }
      }
    }

    // interface * / ntp
    container ntp {
      tailf:info "Configure NTP";

      // interface * / ntp broadcast
      container broadcast {
        tailf:info "Configure NTP broadcast service";
        //tailf:cli-delete-when-empty;
        presence true;
        container client {
          tailf:info "Listen to NTP broadcasts";
          tailf:cli-full-command;
          presence true;
        }

        // interface * / ntp broadcast destination [version] [key] *
        list destination {
          tailf:info "Configure broadcast destination address";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-reset-container;
          key address;
          leaf version {
            tailf:info "Configure NTP version";
            type uint8 {
              tailf:info "<1-4>;;NTP version number";
              range "1..4";
            }
          }
          leaf key {
            tailf:info "Configure broadcast authentication key";
            type uint32 {
              tailf:info "<0-4294967295>;;Broadcast key number";
            }
          }
          leaf address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Destination broadcast IP address";
            }
          }
        }
        container version-key {
          tailf:cli-drop-node-name;
          tailf:cli-compact-syntax;
          tailf:cli-reset-container;
          leaf version {
            tailf:info "Configure NTP version";
            type uint8 {
              tailf:info "<1-4>;;NTP version number";
              range "1..4";
            }
          }
          leaf key {
            tailf:info "Configure broadcast authentication key";
            type uint32 {
              tailf:info "<0-4294967295>;;Broadcast key number";
            }
          }
        }
      }

      // interface * / ntp disable
      leaf disable {
        tailf:info "Disable NTP traffic (both IP and IPv6)";
        type empty;
      }

      // interface * / ntp multicast
      container multicast {
        tailf:info "Configure NTP multicast service";
        tailf:cli-display-separated;
        tailf:cli-compact-syntax;
        presence true;

        // interface * / ntp multicast *
        list address-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key group-address;
          leaf group-address {
            type union {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Multicast group IP address";
              }
              type inet:ipv6-address {
                tailf:info "X:X:X:X::X;;Multicast group IPv6 address";
              }
            }
          }
          leaf version {
            tailf:info "Configure NTP version";
            type uint8 {
              tailf:info "<1-4>;;NTP version number";
              range "1..4";
            }
          }
          leaf key {
            tailf:info "Configure multicast authentication key";
            type uint32 {
              tailf:info "<0-4294967295>;;Multicast key number";
            }
          }
          leaf ttl {
            tailf:info "TTL of the multicast packet";
            type uint8 {
              tailf:info "<1-255>;;TTL";
              range "1..255";
            }
          }
        }

        // interface * / ntp multicast version
        leaf version {
          tailf:info "Configure NTP version";
          type uint8 {
            tailf:info "<1-4>;;NTP version number";
            range "1..4";
          }
        }

        // interface * / ntp multicast key
        leaf key {
          tailf:info "Configure multicast authentication key";
          type uint32 {
            tailf:info "<0-4294967295>;;Multicast key number";
          }
        }

        // interface * / ntp multicast ttl
        leaf ttl {
          tailf:info "TTL of the multicast packet";
          type uint8 {
            tailf:info "<1-255>;;TTL";
            range "1..255";
          }
        }

        // interface * / ntp multicast client *
        container client-list {
          tailf:cli-drop-node-name;
          leaf-list client {
            tailf:info "Listen to NTP multicasts";
            tailf:cli-list-syntax;
            tailf:cli-suppress-list-no;
            tailf:cli-incomplete-no;
            type union {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Multicast client IP address";
              }
              type inet:ipv6-address {
                tailf:info "X:X:X:X::X;;Multicast client IPv6 address";
              }
            }
          }
        }

        // interface * / ntp multicast client
        leaf client {
          tailf:info "Listen to NTP multicasts";
          tailf:cli-full-command;
          type empty;
        }
      }
    }

    // interface * / power
    container power {
      tailf:info "Power configuration";

      // interface * / power inline
      container inline {
        tailf:info "Inline power configuration";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        // interface * / power inline consumption
        leaf consumption {
          tailf:info "Configure the inline device consumption";
          tailf:cli-optional-in-sequence;
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<4000-15400>;;milli-watts";
            range "4000..15400";
          }
        }
        // interface * / power inline auto
        // interface * / power inline never
        // interface * / power inline static
        leaf mode {
          tailf:cli-drop-node-name;
          type enumeration {
            enum auto {
              tailf:info "Automatically detect and power inline devices";
            }
            enum never {
              tailf:info "Never apply inline power";
            }
            enum static {
              tailf:info "High priority inline power interface";
            }
          }
          default auto;
        }
        leaf max {
          tailf:info "Maximum power allowed on this interface";
          when "../mode != 'never'" {
            tailf:dependency "../mode";
          }
          type uint16 {
            tailf:info "<4000-15400>;;milli-watts";
            range "4000..15400";
          }
        }
      }

      // interface * / power client local
      container client {
        tailf:info "Client radio requested maximum transmitter power level";
        leaf local {
          tailf:info "Set power to Access Point local power";
          type empty;
        }
      }
    }

    // interface * / rate-limit input *
    // interface * / rate-limit output *
    list rate-limit {
      tailf:info "Rate Limit";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key line;
      leaf line {
        tailf:cli-multi-word-key;
        type string {
          tailf:info "WORD;;rate-limit parameters, e.g 'input dscp 1 8000 9000 10000 conform-action transmit exceed-action transmit'";
          pattern '(input|output) ([0-9]+|access-group|dscp|qos-group) .* conform-action .* exceed-action .*';
        }
      }
    }

    // interface * / service-policy
    container service-policy {
      tailf:info "Configure QoS Service Policy";

      // interface * / service-policy history
      leaf history {
        tailf:cli-full-command;
        tailf:info "Keep history of QoS metrics";
        type empty;
      }

      // interface * / service-policy input
      // interface * / service-policy output
      uses service-policy-grouping {
        refine output {
          ios:if-sp-move "output";
          ios:config-lock  " service-policy output (\\S+) :: policy-map $1";
          ios:config-lock2 " service-policy output (\\S+) :: platform qos (marker-statistics|match-statistics per-<S>)\n"; // \n for regex trigger check
          tailf:cli-diff-delete-before "/ios:platform/qos/marker-statistics";
          tailf:cli-diff-delete-before "/ios:platform/qos/match-statistics";
        }
        refine input {
          ios:if-sp-move "input";
          ios:config-lock  " service-policy input (\\S+) :: policy-map $1";
          ios:config-lock2 " service-policy input (\\S+) :: platform qos (marker-statistics|match-statistics per-<S>)\n"; // \n for regex trigger check
          tailf:cli-diff-delete-before "/ios:platform/qos/marker-statistics";
          tailf:cli-diff-delete-before "/ios:platform/qos/match-statistics";
        }
      }

      // interface * / service-policy type
      container type {
        tailf:info "Configure CPL Service Policy";

        // interface * / service-policy type control
        container control {
          tailf:info "Apply a control policy to the interface";

          choice control-choice {
            // interface * / service-policy type control subscriber
            leaf subscriber {
              tailf:info "Apply a subscriber control policy to the interfac";
              tailf:non-strict-leafref {
                path "/ios:policy-map-event-control/policy-map/name";
              }
              type string {
                tailf:info "WORD;;policy-map name";
              }
            }

            // interface * / service-policy type control
            leaf name {
              tailf:cli-drop-node-name;
              tailf:cli-disallow-value "subscriber";
              tailf:non-strict-leafref {
                path "/ios:policy-map-control/policy-map/name";
              }
              type string {
                tailf:info "WORD;;Name of control service-policy";
              }
            }
          }
        }

        // interface * / service-policy type performance-monitor
        container performance-monitor {
          tailf:info "Configure media monitor service-policy type";
          uses service-policy-grouping;
        }
      }
    }

    // interface * / service-insertion waas
    container service-insertion {
      tailf:info "Service-insertion AppNav Controller";
      leaf waas {
        tailf:info "Enable Service-insertion";
        type empty;
      }
    }

    // interface * / service-module
    container service-module {
      tailf:info "Configure service module";

      // interface * / service-module fail-open
      container fail-open {
        presence true; // untested
      }

      // interface * / service-module ip
      container ip {
        tailf:info "Service module ip configuration";

        // interface * / service-module ip address
        container address {
          tailf:info "Set the IP address of Service module";

          // interface * / service-module ip address
          container primary {
            tailf:cli-drop-node-name;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf address {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IP address";
              }
            }
            leaf mask {
              tailf:cli-drop-node-name;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IP subnet mask";
              }
            }
          }
        }

        // interface * / service-module ip default-gateway
        leaf default-gateway {
          tailf:info "Service module default gateway configuration";
          tailf:cli-full-command;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP address of default gateway";
          }
        }
      }

      // interface * / service-module t1 timeslots
      container t1 {
        tailf:info "Configure Serial T1 parameters";

        // interface * / service-module t1 clock source
        container clock {
          tailf:info "Service module clock source";
          leaf source {
            tailf:info "Module clock source";
            type enumeration {
              enum line {
                tailf:info "Recover clock from line";
              }
              enum internal {
                tailf:info "Use adapter internal clock";
              }
            }
            default line;
          }
        }

        // interface * / service-module t1 framing
        leaf framing {
          tailf:info "Framing format";
          type enumeration {
            enum esf {
              tailf:info "ESF format";
            }
            enum sf {
              tailf:info "SF format";
            }
          }
          default esf;
        }

        // interface * / service-module t1 timeslots
        container timeslots {
          tailf:info "List of timeslots in the T1 group";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf-list list {
            tailf:cli-drop-node-name;
            tailf:cli-range-list-syntax;
            type uint8 {
              tailf:info "<1-24>;List of timeslots";
              range "1..24";
            }
          }
          leaf speed {
            tailf:info "Fraction timeslots speed";
            type enumeration {
              enum 56 {
                tailf:info "56K";
              }
              enum 64 {
                tailf:info "64K";
              }
            }
          }
        }
      }
    }

    // interface * / group
    leaf group {
      tailf:info "Add this subinterface to a group";
      tailf:cli-full-command;
      tailf:cli-diff-dependency "/ios:service-group";
      type uint16 {
        tailf:info "<1-65532>;;Group number";
        range "1..65532";
      }
    }

    // interface * / shutdown
    leaf shutdown {
      // Note: default to "no shutdown" in order to be able to bring if up.
      tailf:info "Shutdown the selected interface";
      ios:trim-when-list "delete";
      tailf:cli-show-no;
      tailf:cli-full-command;
      type empty;
    }

    // interface * / tcam priority
    container tcam {
      tailf:info "Set tcam priority";
      leaf priority {
        tailf:info "priority keyword";
        type enumeration {
          enum low {
           tailf:info "low priority";
          }
          enum high {
           tailf:info "high priority";
          }
        }
      }
    }

    // interface * / standby
    container standby {
      tailf:info "HSRP interface configuration commands";

      // interface * / no standby redirect
      container redirect-enable {
        tailf:cli-drop-node-name;
        leaf redirect {
          tailf:info "Configure sending of ICMP Redirect messages with an HSRP virtual IP address as the gateway IP address";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }
      }

      // interface * / standby redirect
      container redirect {
        tailf:info "Configure sending of ICMP Redirect messages with an HSRP virtual IP address as the gateway IP address";
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;

        // interface * / no standby redirect unknown
        leaf unknown {
          tailf:info "Redirect to non-HSRP routers";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }

        // interface * / standby redirect timers
        container timers {
          tailf:info "Adjust redirect timers";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf advertisement {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<10-180>;;Passive router advertisement interval in seconds";
              range "10..180";
            }
          }
          leaf holddown {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<30-3600>;;Passive router holddown interval in seconds";
              range "30..3600";
            }
          }
        }

        // interface * / standby redirect authentication md5
        container advertisement {
          tailf:info "Redirect advertisement messages";
          container authentication {
            tailf:info "Authentication";
            container md5 {
              tailf:info "Use MD5 authentication";

              // interface * / standby redirect authentication md5 key-chain
              leaf key-chain {
                tailf:info "Set key chain";
                type string {
                  tailf:info "WORD;;Name of key-chain";
                }
              }

              // interface * / standby redirect advertisement authentication md5 key-string
              container key-string {
                tailf:info "Set key string";
                tailf:cli-flatten-container;
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands;
                uses password-grouping {
                  refine "secret" {
                    cli:secret " md5 key-string <SECRET>";
                  }
                }
                leaf timeout {
                  tailf:info "Set timeout";
                  type uint16 {
                    tailf:info "<0-32767>;;Timeout until only accepting new key (seconds)";
                    range "0..32767";
                  }
                }
              }
            }
          }
        }
      }

      // interface * / standby version
      leaf version {
        tailf:info "HSRP version";
        tailf:cli-full-command;
        type enumeration {
          tailf:info "<1-2>;;Version number";
          enum "1";
          enum "2";
        }
      }

      // interface * / no standby bfd
      leaf bfd {
        tailf:info "Enable HSRP BFD";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // interface * / standby delay
      container delay {
        tailf:info "HSRP initialisation delay";
        tailf:cli-compact-syntax;
        leaf minimum {
          tailf:info "Minimum delay";
          type uint16 {
            tailf:info "<0-10000>;;Delay in seconds";
            range "0..10000";
          }
        }
        leaf reload {
          tailf:info "Delay after reload";
          type uint16 {
            tailf:info "<0-10000>;;Delay in seconds";
            range "0..10000";
          }
        }
      }

      // interface * / standby mac-refresh
      leaf mac-refresh {
        tailf:info "Refresh MAC cache on switch by periodically sending packet from virtual mac address";
        type uint8 {
          tailf:info "<0-255>;;Interval to refresh MAC cache";
          range "0..255";
        }
      }

      // interface * / standby use-bia
      container use-bia {
        tailf:info "HSRP uses interface's burned in address";
        presence true;
        container scope {
          tailf:info "Specify the scope of use-bia";
          leaf interface {
            tailf:info "Use-bia applies to all groups on this interface or sub-interface";
            type empty;
          }
        }
      }

      // interface * / standby *
      list standby-list {
        tailf:callpoint delete-when-empty-patch { tailf:transaction-hook subtree; }
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        tailf:cli-diff-dependency "../version";
        ios:trim-empty-create " standby \\d+";
        key group-number;
        leaf group-number {
          tailf:key-default 0;
          tailf:cli-suppress-range;
          type uint16 {
            tailf:info "<0-4095>;;group number";
          }
        }

        // interface * / standby * authentication
        container authentication {
          tailf:info "Authentication";
          choice auth-choice {

            // interface * / standby * authentication
            leaf word {
              tailf:cli-drop-node-name;
              tailf:cli-disallow-value "md5|text";
              type string {
                tailf:info "WORD;;Plain text authentication string (8 chars max)";
              }
            }

            // interface * / standby * authentication md5
            container md5 {
              tailf:info "Use MD5 authentication";

              // interface * / standby * authentication md5 key-chain
              leaf key-chain {
                tailf:info "Set key chain";
                type string {
                  tailf:info "WORD;;Name of key-chain";
                }
              }

              // interface * / standby * authentication md5 key-string
              container key-string {
                tailf:info "Set key string";
                tailf:cli-flatten-container;
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands;
                uses password-grouping {
                  refine "secret" {
                    cli:secret " md5 key-string <SECRET>(?: timeout \\d+)?";
                  }
                }
                leaf timeout {
                  tailf:info "Set timeout";
                  type uint16 {
                    tailf:info "<0-32767>;;Timeout until only accepting new key (seconds)";
                    range "0..32767";
                  }
                }
              }
            }

            // interface * / standby * authentication text
            leaf text {
              tailf:info "Plain text authentication";
              cli:secret;
              type NEDCOM_SECRET_TYPE {
                tailf:info "WORD;;Plain text authentication string (8 chars max)";
              }
            }
          }
        }

        // interface * / standby * follow
        leaf follow {
          tailf:info "Name of HSRP group to follow";
          type string {
            tailf:info "WORD;;name string (25 chars. max)";
          }
        }

        // interface * / standby * ip
        container ip {
          tailf:info "Enable HSRP and set the virtual IP address";
          tailf:cli-delete-when-empty;
          presence true;
          leaf address {
            tailf:cli-drop-node-name;
            tailf:cli-full-command;
            // dep: before this created, must change below:
            tailf:cli-diff-dependency "../../../../vrf/forwarding" {
              tailf:cli-trigger-on-set;
            }
            tailf:cli-diff-dependency "../../../../ip-vrf/ip/vrf/forwarding" {
              tailf:cli-trigger-on-set;
            }
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Virtual IP address";
            }
          }

          // interface * / standby * ip * secondary
          list secondary {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-incomplete-command;
            tailf:cli-incomplete-no;
            tailf:cli-diff-dependency "../address";
            key address;
            leaf address {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Virtual IP address";
              }
            }
            leaf secondary {
              tailf:info "Make this IP address a secondary virtual IP address";
              type empty;
            }
          }
        }

        // interface * / standby * ipv6
        leaf ipv6 {
          tailf:info "Enable HSRP IPv6";
          type union {
            type inet:ipv6-address {
              tailf:info "X:X:X:X::X;;IPv6 link-local address";
            }
            type ios:ipv6-prefix;
            type enumeration {
              enum autoconfig {
                tailf:info "Obtain address using autoconfiguration";
              }
            }
          }
        }

        // interface * / standby * mac-address
        leaf mac-address {
          tailf:info "Virtual MAC address";
          type string {
            tailf:info "H.H.H;;MAC address";
          }
        }

        // interface * / standby * name
        leaf name {
          tailf:info "Redundancy name string";
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;name string";
          }
        }

        // interface * / standby * timers
        container timers {
          tailf:info "Hello and hold timers";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          container hello-interval {
            tailf:cli-drop-node-name;
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            choice hello-interval-choice {
              leaf seconds {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type uint8 {
                  tailf:info "<1-254>;;Hello interval in seconds";
                  range "1..254";
                }
              }
              leaf msec {
                tailf:info "Specify hello interval in milliseconds";
                tailf:cli-incomplete-command;
                type uint16 {
                  tailf:info "<15-999>;;Hello interval in milliseconds";
                  range "15..999";
                }
              }
            }
          }
          container hold-time {
            tailf:cli-drop-node-name;
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            choice hold-time-choice {
              leaf seconds {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<1-255>;;Hold time in seconds";
                  range "1..255";
                }
              }
              leaf msec {
                tailf:info "Specify hold time in milliseconds";
                type uint16 {
                  tailf:info "<50-3000>;;Hello interval in milliseconds";
                  range "50..3000";
                }
              }
            }
          }
        }

        // interface * / standby * priority
        leaf priority {
          tailf:info "Priority level";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<0-255>;;Priority value (default 100)";
          }
          default 100;
        }

        // interface * / standby * preempt
        container preempt {
          tailf:info "Overthrow lower priority Active routers";
          tailf:cli-compact-syntax;
          //tailf:cli-keep-when-empty;
          ios:trim-delete-when-empty "( preempt)";
          presence true;
          container delay {
            tailf:info "Wait before preempting";
            tailf:cli-compact-syntax;
            leaf minimum {
              tailf:info "Delay at least this long";
              type uint16 {
                tailf:info "<0-3600>;;Number of seconds for minimum delay";
                range "0..3600";
              }
            }
            leaf reload {
              tailf:info "Delay after reload";
              type uint16 {
                tailf:info "<0-3600>;;Number of seconds for reload delay";
                range "0..3600";
              }
            }
            leaf sync {
              tailf:info "Wait for IP redundancy client";
              type uint16 {
                tailf:info "<0-3600>;;Number of seconds for sync delay";
                range "0..3600";
              }
            }
          }
        }

        // interface * / standby * track *
        list track {
          tailf:info "Priority tracking";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key name;
          leaf name {
            tailf:cli-suppress-range;
            type union {
              type uint16 {
                tailf:info "<0-1000>;;Tracked object number";
              }
              type string {
                tailf:info "WORD;;Interface name";
              }
            }
          }
          choice options {
            case interface {
              leaf priority-decrement {
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<1-255>;;Decrement value";
                }
              }
            }
            case group-number {
              leaf decrement {
                tailf:info "Priority decrement";
                tailf:cli-full-command;
                type uint16 {
                  tailf:info "<1-255>;;Decrement value";
                }
              }
              leaf shutdown {
                tailf:info "Shutdown group";
                tailf:cli-full-command;
                type empty;
              }
            }
          }
        }
      }
    }

    // interface * / storm-control
    container storm-control {
      tailf:info "storm configuration";

      // interface * / storm-control action
      container action {
        tailf:info "Action to take for storm-control";
        leaf shutdown {
          tailf:info "Shutdown this interface if a storm occurs";
          tailf:cli-full-command;
          type empty;
        }
        leaf trap {
          tailf:info "Send SNMP trap if a storm occurs";
          tailf:cli-full-command;
          type empty;
        }
        leaf level {
          tailf:info "Set storm suppression level on this interface";
          type decimal64 {
            tailf:info "<0-100>;;Enter Integer part of level as percentage of bandwidth";
            fraction-digits 2;
            range "0..100";
          }
        }
      }

      // interface * / storm-control broadcast
      container broadcast {
        tailf:info "Broadcast address storm control";

        // interface * / storm-control broadcast level
        leaf level {
          tailf:info "Set storm suppression level on this interface";
          tailf:cli-full-command;
          type decimal64 {
            tailf:info "<0-100>;;Enter Integer part of level as percentage of bandwidth";
            fraction-digits 2;
            range "0..100";
          }
        }

        // interface * / storm-control broadcast level bps|pps
        // interface * / storm-control broadcast level <rising> <falling>
        uses interface-storm-control-grouping;

        // interface * / storm-control broadcast include multicast
        container include {
          tailf:info "include other traffic types";
          leaf multicast {
            tailf:info "Suppress broadcast and multicast traffic";
            type empty;
          }
        }
      }

      // interface * / storm-control multicast
      container multicast {
        tailf:info "Multicast address storm control";

        // interface * / storm-control multicast level
        leaf level {
          tailf:info "Set storm suppression level on this interface";
          tailf:cli-full-command;
          type decimal64 {
            tailf:info "<0-100>;;Enter Integer part of level as percentage of bandwidth";
            fraction-digits 2;
            range "0..100";
          }
        }

        // interface * / storm-control multicast level bps|pps
        // interface * / storm-control multicast level <rising> <falling>
        uses interface-storm-control-grouping;
      }

      // interface * / storm-control unicast
      container unicast {
        tailf:info "Unicast address storm control";

        // interface * / storm-control unicast level
        leaf level {
          tailf:info "Set storm suppression level on this interface";
          tailf:cli-full-command;
          type decimal64 {
            tailf:info "<0-100>;;Enter Integer part of level as percentage of bandwidth";
            fraction-digits 2;
            range "0..100";
          }
        }

        // interface * / storm-control unicast level bps|pps
        // interface * / storm-control unicast level <rising> <falling>
        uses interface-storm-control-grouping;
      }
    }

    // interface * / pagp
    container pagp {
      tailf:info "PAgP interface subcommands";

      // interface * / pagp rate
      leaf rate {
        tailf:info "Rate at which the PAgP packets are sent to peer";
        type enumeration {
          enum normal {
            tailf:info "PAgP packets are transmitted at the slow rate once the link is established";
          }
          enum fast {
            tailf:info "PAgP packets are transmitted at the fast rate";
          }
        }
        default normal;
      }
    }

    // interface * / wrr-queue
    container wrr-queue {
      tailf:info "Configure weighted round-robin xmt queues";
      uses interface-queue-grouping;
    }

    // interface * / no wrr-queue random-detect *
    // interface * / no rcv-queue random-detect *
    container no-list {
      tailf:info "no wrr-queue random-detect entry";
      container wrr-queue {
        tailf:info "Configure weighted round-robin xmt queues";
        list random-detect {
          tailf:info "Configure random-detect";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key id;
          leaf id {
            type uint32 {
            }
          }
        }
      }
      container rcv-queue {
        tailf:info "Configure weighted round-robin xmt queues";
        list random-detect {
          tailf:info "Configure random-detect";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key id;
          leaf id {
            type uint32 {
            }
          }
        }
      }
    }

    // interface * / priority-queue
    container priority-queue {
      tailf:info "Configure priority scheduling";

      // interface * / priority-queue queue-limit
      leaf queue-limit {
        tailf:info "configure priority queue limit";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<0-100>;;enter queue size weight";
          range "0..100";
        }
      }

      // interface * / priority-queue dscp-map *
      list dscp-map {
        tailf:info "Configure dscp-map for a queue threshold";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          type uint8 {
            tailf:info "<1-1>;;enter priority queue id";
            range "1";
          }
        }
        list values {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-show-long-obu-diffs;
          ordered-by user;
          key value;
          leaf value {
            tailf:cli-multi-word-key;
            type string;
          }
        }
      }

      // interface * / priority-queue cos-map *
      container cos-map {
        tailf:info "Configure cos-map for a queue";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf id {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<1-1>;;enter cos-map queue id";
            range "1";
          }
        }
        leaf-list cos-values {
          tailf:cli-drop-node-name;
          tailf:cli-flat-list-syntax;
          ios:ned-defaults "if-priority-queue-cos-map";
          max-elements 8;
          type uint8 {
            tailf:info "<0-7>;;cos values separated by spaces (up to 8 values total)";
            range "0..7";
          }
        }
      }

      // interface * / priority-queue out
      leaf out {
        tailf:info "egress priority queue";
        tailf:cli-full-command;
        type empty;
      }
    }

    // interface * / rep
    container rep {
      tailf:info "Resilient Ethernet Protocol characteristics";

      // interface * / rep block
      container block {
        tailf:info "Block port & VLANs for VLAN Load-balancing";
        container port {
          tailf:info "Specify port for VLAN Load-balancing";
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-compact-syntax;
          choice port-choice {
            leaf neighbor-offset {
              tailf:cli-drop-node-name;
              type int16 {
                tailf:info "<-256 - 256>;;Neighbor offset";
                range "-256..256";
              }
            }
            leaf id {
              tailf:info "REP port ID";
              type string {
                tailf:info "WORD;;REP port ID (16 digit hexadecimal number)";
              }
            }
            leaf preferred {
              tailf:info "Preferred flag";
              type empty;
            }
          }
          leaf vlan {
            tailf:info "VLANs to block";
            type union {
              type string {
                tailf:info "WORD;;VLAN list (1-4094) ex: 1-65,72,300-320";
              }
              type enumeration {
                enum all {
                  tailf:info "All VLANs";
                }
              }
            }
          }
        }
      }

      // interface * / rep preempt
      container preempt {
        tailf:info "Preemption options";
        leaf delay {
          tailf:info "Delay timer in seconds";
          type uint16 {
            tailf:info "<15-300>;;number of seconds before automatic preemption takes place";
            range "15..300";
          }
        }
      }

      // interface * / rep segment
      container segment {
        tailf:info "REP segment ID";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf id {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-1024>;;Between 1 and 1024";
            range "1..1024";
          }
        }
        leaf edge {
          tailf:info "Edge Port";
          tailf:cli-optional-in-sequence;
          type empty;
        }
        leaf no-neighbor {
          tailf:info "No-Neighbor Edge Port";
          tailf:cli-optional-in-sequence;
          type empty;
        }
        leaf primary {
          tailf:info "Primary Edge Port";
          tailf:cli-optional-in-sequence;
          when "../edge" {
            tailf:dependency "../edge";
          }
          type empty;
        }
        leaf preferred {
          tailf:info "Preferred Alternate Port";
          type empty;
        }
      }

      // interface * / rep lsl-retries
      leaf lsl-retries {
        tailf:info "Configure LSL no. of retries";
        type uint8 {
          tailf:info "<3-10>;;No. of retries";
          range "3..10";
        }
      }

      // interface * / rep lsl-age-timer
      leaf lsl-age-timer {
        tailf:info "Configure LSL age-out timer";
        type uint16 {
          tailf:info "<120-10000>;;LSL ageout timer value, in multiples of 40ms";
          range "120..10000";
        }
      }

      // interface * / rep stcn
      container stcn {
        tailf:info "Segment Topology Change Notification";

        // interface * / rep stcn segment
        leaf segment {
          tailf:info "for REP segment";
          type string {
            tailf:info "WORD;;segment ID list (1-1024) ex: 1-3,6-9";
          }
        }

        // interface * / rep stcn stp
        leaf stp {
          tailf:info "for STP network";
          type empty;
        }
      }
    }

    // interface * / rcv-queue
    container rcv-queue {
      tailf:info "Configure receive queue(s)";
      uses interface-queue-grouping;
    }

    // interface * / udld
    container udld {
      tailf:info "Configure UDLD enabled or disabled and ignore global UDLD setting";
      container port {
        tailf:info "Enable UDLD protocol on this interface despite global UDLD setting";
        tailf:cli-delete-when-empty;
        presence true;
        choice port-choice {
          leaf aggressive {
            tailf:info "Enable UDLD protocol in aggressive mode on this interface despite global UDLD setting";
            type empty;
          }
          leaf disable {
            tailf:info "Disable UDLD protocol on this interface despite global UDLD setting";
            type empty;
          }
        }
      }
    }

    // interface * / peer
    container peer {
      tailf:info "Peer parameters for point to point interfaces";

      // interface * / no peer neighbor-route
      leaf neighbor-route {
        tailf:info "Create neighbor route to peer if needed";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // interface * / peer ip address forced
      container ip {
        tailf:info "Configure peer ip options";
        container address {
          tailf:info "Configure peer ip address options";
          leaf forced {
            tailf:info "Force ip address selected from pool";
            type empty;
          }
        }
      }

      // interface * / peer default ip address
      container default {
        tailf:info "Specify default parameters";
        container ip {
          tailf:info "Specify default IP parameters";
          choice address-choice {
            // interface * / no peer default ip address
            case no-address {
              container no-address {
                tailf:cli-drop-node-name;
                leaf address {
                  tailf:cli-boolean-no;
                  tailf:cli-full-command;
                  tailf:cli-full-no;
                  type boolean;
                  default true;
                }
              }
            }

            // interface * / peer default ip address
            container address {
              tailf:info "Specify default IP address";
              tailf:cli-incomplete-command;
              tailf:cli-incomplete-no;
              choice address-choice {
                leaf dhcp {
                  tailf:info "Use DHCP proxy client mechanism to allocate a peer IP address";
                  type empty;
                }
                container dhcp-pool {
                  tailf:info "Use local DHCP pools to allocate a peer IP address";
                  presence true;
                  leaf pools {
                    tailf:cli-drop-node-name;
                    tailf:cli-multi-value;
                    type string {
                      tailf:info "LINE;;List of one or more DHCP address pools";
                    }
                  }
                }
                container pool {
                  tailf:info "Use IP pool mechanism to allocate a peer IP address";
                  presence true;
                  leaf pools {
                    tailf:cli-drop-node-name;
                    tailf:cli-multi-value;
                    type string {
                      tailf:info "LINE;;List of one or more DHCP address pools";
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // interface * / random-detect
    leaf random-detect {
      tailf:info "Enable Weighted Random Early Detection (WRED) on an Interface";
      type empty;
    }

    // interface * / clns
    container clns {
      tailf:info "CLNS interface subcommands";

      // interface * / clns enable
      leaf enable {
        tailf:info "Enable CLNS and ES-IS routing on interface";
        type empty;
      }

      // interface * / clns mtu
      leaf mtu {
        tailf:info "Set MTU packet size for interface";
        type uint32 {
          tailf:info "<512-4294967295>;;CLNS MTU packet size for interface";
        }
      }

      // interface * / clns router
      container router {
        tailf:info "Enable CLNS routing protocol on interface";

        // interface * / clns router isis
        container isis {
          tailf:info "ISO IS-IS routing protocol";
          tailf:cli-delete-when-empty;
          presence true;
          leaf tag {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;Routing process tag";
            }
          }
        }
      }

      // interface * / no clns route-cache
      leaf route-cache {
        tailf:info "Enable fast switching through the cache";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }
    }

    // interface * / dsu
    container dsu {

      // interface * / dsu bandwidth
      leaf bandwidth {
        tailf:cli-full-command;
        type uint32;
      }

      // interface * / dsu mode
      leaf mode {
        tailf:cli-full-command;
        type enumeration {
          enum 1 {
            tailf:info "DSU mode 1";
          }
          enum 2 {
            tailf:info "DSU mode 2";
          }
        }
      }
    }

    // interface * / framing
    leaf framing {
      tailf:info "Framing interface subcommands";
      tailf:cli-full-command;
      type enumeration {
        enum bypass {
        }
        enum g751 {
          tailf:info "G.751 framing";
        }
        enum c-bit {
        }
        enum m13 {
        }
      }
    }

    // interface * / cablelength
    leaf cablelength {
      tailf:cli-full-command;
      type union {
        type uint32;
        type enumeration {
          enum short {
          }
          enum long {
          }
        }
      }
    }

    // interface * / isdn
    container isdn {
      tailf:info "ISDN Interface configuration commands";

      // interface * / isdn switch-type
      leaf switch-type {
        tailf:info "Select the Interface ISDN switch type";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;Switch type";
        }
      }

      // interface * / isdn protocol-emulate
      leaf protocol-emulate {
        tailf:info "Protocol (L2/L3) emulation network/user side";
        tailf:cli-full-command;
        type enumeration {
          enum network {
            tailf:info "ISDN protocol emulation network side";
          }
          enum user {
            tailf:info "ISDN protocol emulation user side (default)";
          }
        }
      }

      // interface * / isdn incoming-voice
      container incoming-voice {
        tailf:info "Specify options for incoming calls.";
        choice incoming-voice-choice {
          leaf voice {
            tailf:info "Incoming voice calls will be handled as voice.";
            type empty;
          }
          container data {
            tailf:info "Incoming voice calls will be handled as data.";
            tailf:cli-delete-when-empty;
            presence true;
            leaf kbps {
              tailf:cli-drop-node-name;
              type enumeration {
                enum "56" {
                  tailf:info "B Channel Bandwidth of 56Kb/s";
                }
                enum "64" {
                  tailf:info "B Channel Bandwidth of 64Kb/s";
                }
              }
            }
          }
          container modem {
            tailf:info "Incoming voice calls will be handled as modems.";
            tailf:cli-delete-when-empty;
            presence true;
            leaf kbps {
              tailf:cli-drop-node-name;
              type enumeration {
                enum "56" {
                  tailf:info "56  B Channel Bandwidth of 56Kb/s  ";
                }
                enum "64" {
                  tailf:info "64  B Channel Bandwidth of 64Kb/s";
                }
              }
            }
          }
        }
      }

      // interface * / isdn supp-service
      container supp-service {
        tailf:info "Specify the subscribed supplementary service";
        container name {
          tailf:info "Specify the subscribed name service";
          container calling {
            tailf:info "calling name service";
            tailf:cli-delete-when-empty;
            presence true;
          }
        }
      }

      // interface * / isdn termination multidrop
      container termination {
        tailf:info "To connect the TR pair and to in turn enable internal termination";
        leaf multidrop {
          tailf:info "Enable multidrop Internal termination";
          type empty;
        }
      }

      // interface * / isdn termination point-to-point-setup
      leaf point-to-point-setup {
        tailf:info "Bri send point-to-point SETUP";
        tailf:cli-full-command;
        type empty;
      }

      // interface * / isdn map address
      container map {
        tailf:info "Specify E.164 address to numbering plan/type mapping";
        container address {
          tailf:info "Map an ISDN address";

          // interface * / isdn map address *
          list address-list {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            tailf:cli-incomplete-command;
            key address;
            leaf address {
              type string {
                tailf:info "WORD;;ISDN address to map";
              }
            }
            leaf plan {
              tailf:info "Set address numbering plan";
              tailf:cli-incomplete-command;
              type string {
                tailf:info "WORD;;plan name";
              }
            }
            leaf type {
              tailf:info "Set address number type";
              type string {
                tailf:info "WORD;;plan type";
              }
            }
          }

          // interface * / isdn map address transparent
          leaf transparent {
            tailf:info "Priority is given to end-to-end transparency for plan/type";
            type empty;
          }
        }
      }

      // interface * / isdn bind-l3
      container bind-l3 {
        tailf:info "Bind Layer 3 protocol to signaling interface";

        // interface * / isdn bind-l3 ccm-manager
        leaf ccm-manager {
          tailf:info "Select call manager backhaul";
          type empty;
        }
      }

      // interface * / isdn outgoing
      container outgoing {
        tailf:info "Options for outgoing IEs and messages";

        // interface * / isdn outgoing display-ie
        leaf display-ie {
          tailf:info "DISPLAY IE in outgoing ISDN messages is allowed";
          type empty;
        }

        // interface * / isdn outgoing ie
        container ie {
          tailf:info "Information Elements";
          container facility {
            tailf:info "FACILITY ie in outgoing ISDN messages is allowed";
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            presence true;
            uses interface-isdn-outgoing-ie-grouping;
          }
          container extended-facility {
            tailf:info "EXTENDED FACILITY IE in outgoing ISDN messages is allowed";
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            presence true;
            uses interface-isdn-outgoing-ie-grouping;
          }
          container progress-indicator {
            tailf:info "PROGRESS IND IE in outgoing ISDN messages is allowed";
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            presence true;
            uses interface-isdn-outgoing-ie-grouping;
          }
          container network-facility {
            tailf:info "NETWORK FACILITY IE in outgoing ISDN messages is allowed";
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            presence true;
            uses interface-isdn-outgoing-ie-grouping;
          }
          container notify-indicator {
            tailf:info "NOTIFY INDICATION IE in outgoing ISDN messages is allowed";
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            presence true;
            uses interface-isdn-outgoing-ie-grouping;
          }
          container connected-number {
            tailf:info "CONNECTED NUMBER IE in outgoing ISDN messages is allowed";
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            presence true;
            uses interface-isdn-outgoing-ie-grouping;
          }
          container connected-subaddr {
            tailf:info "CONNECTED SUBADDR IE in outgoing ISDN messages is allowed";
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            presence true;
            uses interface-isdn-outgoing-ie-grouping;
          }
          container caller-number {
            tailf:info "CALLER NUMBER IE in outgoing ISDN messages is allowed";
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            presence true;
            uses interface-isdn-outgoing-ie-grouping;
          }
          container caller-subaddr {
            tailf:info "CALLER SUBADDR IE in outgoing ISDN messages is allowed";
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            presence true;
            uses interface-isdn-outgoing-ie-grouping;
          }
          container called-number {
            tailf:info "CALLED NUMBER IE in outgoing ISDN messages is allowed";
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            presence true;
            uses interface-isdn-outgoing-ie-grouping;
          }
          container called-subaddr {
            tailf:info "CALLED SUBADDR IE in outgoing ISDN messages is allowed";
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            presence true;
            uses interface-isdn-outgoing-ie-grouping;
          }
          //display             DISPLAY IE in outgoing ISDN messages is allowed
          container redirecting-number {
            tailf:info "REDIRECTING NUMBER IE in outgoing ISDN messages is allowed";
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            presence true;
            uses interface-isdn-outgoing-ie-grouping;
          }
          container user-user {
            tailf:info "USER USER IE in outgoing ISDN messages is allowed";
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            presence true;
            uses interface-isdn-outgoing-ie-grouping;
          }
          container high-layer-compat {
            tailf:info "HIGH LAYER COMPAT IE in outgoing ISDN messages is allowed";
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            presence true;
            uses interface-isdn-outgoing-ie-grouping;
          }
          container low-layer-compat {
            tailf:info "LOW LAYER COMPAT IE in outgoing ISDN messages is allowed";
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            presence true;
            uses interface-isdn-outgoing-ie-grouping;
          }
        }
      }

      // interface * / isdn bchan-number-order
      leaf bchan-number-order {
        tailf:info "Specify bchannel starting number order";
        type enumeration {
          enum ascending {
            tailf:info "B-chan selection starting from B1";
          }
          enum descending {
            tailf:info "B-chan selection starting from B23/32";
          }
        }
        default descending;
      }
    }

    // interface * / scramble
    leaf scramble {
      tailf:cli-full-command;
      type empty;
    }

    // interface * / clock source
    container clock {
      tailf:info "Configure interface clock source";
      leaf source {
        type enumeration {
          enum internal {
            tailf:info "Internal clock source";
          }
          enum external {
            tailf:info "External clock source";
          }
          enum line {
            tailf:info "Line clock source";
          }
        }
      }

      // interface * / clock rate
      leaf rate {
        tailf:info "Clock rate";
        type uint32 {
          tailf:info "NUM;;Clock rate, round of to the nearest supported "+
            "value by device. Please set exact to avoid diff.";
        }
      }
    }

    // interface * / down-when-looped
    leaf down-when-looped {
      tailf:info "Force looped serial interface down";
      tailf:cli-full-command;
      type empty;
    }

    // interface * / crc
    leaf crc {
      tailf:info "CRC interface subcommands";
      tailf:cli-full-command;
      type enumeration {
        enum 16 {
          tailf:info "Setting CRC-16";
        }
        enum 32 {
          tailf:info "Setting CRC-32";
        }
      }
    }

    // interface * / carrier-delay
    container carrier-delay {
      tailf:info "Specify delay for interface transitions";
      tailf:cli-diff-delete-after "/ios:track/track-object/carrier-delay";
      uses carrier-delay-grouping {
        refine "delay-choice/seconds/seconds" {
          default 2;
        }
      }

      // interface * / carrier-delay up
      container up {
        tailf:info "Carrier Up Transitions";
        uses carrier-delay-grouping;
      }

      // interface * / carrier-delay down
      container down {
        tailf:info "Carrier Down Transitions";
        uses carrier-delay-grouping;
      }
    }

    // interface * / trunk-group
    leaf trunk-group {
      tailf:info "Configure interface to be in a trunk group";
      tailf:non-strict-leafref {
        path "/ios:trunk/group/name";
      }
      type string {
        tailf:info "WORD;;Trunk group label";
      }
    }

    // interface * / eapol
    container eapol {
      tailf:info "eapol";

      // interface * / eapol eth-type
      leaf eth-type {
        tailf:info "Configure Ethernet Type for EAPOL Frame";
        type enumeration {
          enum "876F" {
            tailf:info "Alternate Eth Value (presently only one eth-type supported)";
          }
        }
      }

      // interface * / eapol destination-address
      leaf destination-address {
        tailf:info "Configure destination MAC address";
        type union {
          type string {
            tailf:info "H.H.H;;MAC address";
          }
          type enumeration {
            enum bridge-group-address {
              tailf:info "Configure bridge group address";
            }
            enum broadcast-address {
              tailf:info "Configure broadcast MAC address";
            }
            enum lldp-multicast-address {
              tailf:info "Configure lldp multicast address";
            }
          }
        }
      }
    }

    // interface * / mka
    container mka {
      tailf:info "MACsec Key Agreement (MKA) interface configuration";

      // interface * / mka policy
      leaf policy {
        tailf:info "Apply MKA Policy";
        tailf:cli-remove-before-change;
        tailf:non-strict-leafref {
          path "/ios:mka/policy/name";
        }
        type string {
          tailf:info "WORD;;MKA Policy NAME";
        }
      }

      // interface * / mka pre-shared-key key-chain
      container pre-shared-key {
        tailf:info "Configure MKA Pre-Shared-Key";
        leaf key-chain {
          tailf:info "Configure the key-chain name";
          tailf:non-strict-leafref {
            path "/ios:key/macsec/chain/name";
          }
          type string {
            tailf:info "WORD;;Name of key-chain to be used to get keys";
          }
        }
      }
    }

    // interface * / macsec
    container macsec-enable {
      tailf:cli-drop-node-name;
      leaf macsec {
        tailf:info "MACsec enable commands";
        tailf:cli-diff-dependency "../../ip/mtu";
        type empty;
      }
    }

    // interface * / macsec X
    container macsec {
      tailf:info "MACsec enable commands";
      tailf:cli-incomplete-command;
      tailf:cli-incomplete-no;

      // interface * / macsec replay-protection window-size
      container replay-protection {
        tailf:info "Set replay-protection";
        leaf window-size {
          tailf:info "Set replay window-size";
          type uint32 {
            tailf:info "<0-4294967295>;;Window size 0 - 4294967295";
          }
        }
      }

      // interface * / macsec network-link
      leaf network-link {
        tailf:info "Enable macsec on switch connected interface";
        type empty;
      }

      // interface * / macsec dot1q-in-clear
      leaf dot1q-in-clear {
        tailf:info "Dot1q in Clear option";
        type enumeration {
          enum "1" {
            tailf:info "Dot1q in Clear (presently only one tag supported)";
          }
        }
      }

      // interface * / macsec access-control
      leaf access-control {
        tailf:info "Access Control Policy";
        type enumeration {
          enum must-secure {
            tailf:info "access-control must-secure";
          }
          enum should-secure {
            tailf:info "access-control should-secure";
          }
        }
        default must-secure;
      }
    }

    // interface * / crypto
    container crypto {
      tailf:info "Encryption/Decryption commands";

      // interface * / crypto engine
      container engine {
        tailf:info "";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf slot {
          tailf:info "WORD;;<integer>/<integer>";
          type string;
        }
        leaf location {
          tailf:info "";
          tailf:cli-drop-node-name;
          type enumeration {
            enum "inside";
            enum "outside";
          }
        }
      }

      // interface * / crypto map
      container map {
        tailf:info "Assign a Crypto Map";

        // interface * / crypto map ipv4
        container ipv4 {
          tailf:cli-drop-node-name;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf map-name {
            tailf:cli-drop-node-name;
            tailf:cli-disallow-value "ipv6";
            tailf:cli-diff-dependency "/ios:crypto/map";
            type string {
              tailf:info "WORD;;Crypto Map tag";
            }
          }
          leaf redundancy {
            tailf:info "enable redundancy";
            type string {
              tailf:info "WORD;;Name of IP Redundancy Group";
            }
          }
          leaf stateful {
            tailf:info "enable stateful failover";
            type empty;
          }
        }

        // interface * / crypto map ipv6
        container ipv6 {
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf map-name {
            tailf:cli-drop-node-name;
            tailf:cli-diff-dependency "/ios:crypto/map";
            type string {
              tailf:info "WORD;;Crypto Map tag";
            }
          }
          leaf redundancy {
            tailf:info "enable redundancy";
            type string {
              tailf:info "WORD;;Name of IP Redundancy Group";
            }
          }
          leaf stateful {
            tailf:info "enable stateful failover";
            type empty;
          }
        }
      }

      // interface * / crypto ipsec
      container ipsec {
        tailf:info "Set IPSec parameters";

        // interface * / crypto ipsec df-bit
        leaf df-bit {
          tailf:info "Handling of encapsulated DF bit.";
          type enumeration {
            enum clear {
              tailf:info "Clear DF bit for encapsulated packets.";
            }
            enum copy {
              tailf:info "Copy DF bit from inner for encapsulated packets.";
            }
            enum set {
              tailf:info "Set DF bit for encapsulated packets.";
            }
          }
        }
      }
    }

    // interface * / no routing dynamic
    container routing {
      tailf:info "Per-interface routing configuration";
      leaf dynamic {
        tailf:info "participates in routing protocols";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }
    }

    // interface * / autonomic connect
    container autonomic {
      tailf:info "Autonomic Networking";
      leaf connect {
        tailf:info "Connect to External Device";
        type empty;
      }
    }

    // interface * / performance monitor context
    container performance {
      tailf:info "Global performance monitor configuration";
      container monitor {
        tailf:info "monitor";
        leaf context {
          tailf:info "Select ezPM context";
          tailf:cli-diff-dependency "/ios:performance/monitor/context[name=current()]/exporter/destination";
          tailf:non-strict-leafref {
            path "/ios:performance/monitor/context/name";
          }
          type string {
            tailf:info "WORD;;User defined ezPM context";
          }
        }
      }
    }

    // interface * / no qos
    // interface * / qos X
    choice qos-choice {
      container qos-enable {
        tailf:cli-drop-node-name;
        leaf qos {
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          tailf:cli-full-no;
          type boolean;
          default true;
        }
      }
      container qos {
        tailf:info "QoS configuration";
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;

        // interface * / qos trust
        container trust {
          tailf:info "Trust state of the interface";
          tailf:cli-compact-syntax;
          choice trust-choice {
            leaf dscp {
              tailf:info "Trust DSCP";
              type empty;
            }
            leaf cos {
              tailf:info "Trust CoS";
              type empty;
            }
            leaf device {
              tailf:info "trusted device class";
              type enumeration {
                enum cisco-phone {
                  tailf:info "Cisco IP Phone";
                }
                enum cts {
                  tailf:info "Cisco-telepresence";
                }
                enum ip-camera {
                  tailf:info "Cisco video surveillance camera";
                }
                enum media-player {
                  tailf:info "Cisco Digital Media Player";
                }
              }
            }

            // interface * / qos trust extend
            container extend {
              tailf:info "Extend trust through a connected device";
              tailf:cli-delete-when-empty;
              tailf:cli-reset-container;
              presence true;
              leaf cos {
                tailf:info "CoS value to use for packets from the device";
                type uint8 {
                  tailf:info "<0-7>;;CoS value";
                  range "0..7";
                }
              }
            }
          }
        }

        // interface * / qos pre-classify
        leaf pre-classify {
          tailf:info "Enable QOS classification before packets are tunnel encapsulated";
          type empty;
        }

        // interface * / qos vlan-based
        container vlan-based {
          tailf:info "Vlan-based QoS";
          presence true;
        }

        // interface * / qos dscp
        leaf dscp {
          tailf:info "Default DSCP";
          type uint8 {
            tailf:info "<0-63>;;DSCP value";
            range "0..63";
          }
        }
      }
    }

    // interface * / qos-config scheduling-mode min-bw-guarantee
    // interface * / no qos-config scheduling-mode min-bw-guarantee
    container qos-config {
      tailf:info "Configuring qos scheduling mode";
      container scheduling-mode {
        tailf:info "Scheduling mode";
        leaf min-bw-guarantee {
          tailf:info "Assure minimum bandwidth guarantee only";
          tailf:cli-boolean-no;
          type boolean;
        }
      }
    }

    // interface * / tx-queue *
    list tx-queue {
      tailf:info "Configure interface transmit queue";
      tailf:cli-mode-name "config-if-tx-queue";
      key id;
      leaf id {
        type uint8 {
          tailf:info "<1-4>;;Transmit queue number";
          range "1..4";
        }
      }

      // interface * / tx-queue * / bandwidth
      container bandwidth {
        tailf:info "Bandwidth for this queue";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        choice bandwidth-choice {
          // interface * / tx-queue * / bandwidth
          case numeric {
            leaf value {
              tailf:cli-drop-node-name;
              tailf:cli-disallow-value "percent";
              type string {
                tailf:info "<16000-1000000000>;;Bandwidth (Sharing rate) (postfix k, m, g optional; decimal point allowed)";
              }
            }
            leaf unit {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "UNIT;;kbps | mbps | gbps";
              }
            }
          }
          // interface * / tx-queue * / bandwidth percent
          leaf percent {
            tailf:info "% of the link bandwidth";
            type uint8 {
              tailf:info "<1-100>;;percent";
              range "1..100";
            }
          }
        }
      }

      // interface * / tx-queue * / shape
      container shape {
        tailf:info "Traffic shaping configuration";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        choice shape-choice {
          // interface * / tx-queue * / shape
          case numeric {
            leaf value {
              tailf:cli-drop-node-name;
              tailf:cli-disallow-value "percent";
              type string {
                tailf:info "<16000-1000000000>;;Shaping rate (postfix k, m, g optional; decimal point allowed)";
              }
            }
            leaf unit {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "UNIT;;kbps | mbps | gbps";
              }
            }
          }
          // interface * / tx-queue * / shape percent
          leaf percent {
            tailf:info "% of the link bandwidth";
            type uint8 {
              tailf:info "<1-100>;;percent";
              range "1..100";
            }
          }
        }
      }

      // interface * / tx-queue * / priority high
      leaf priority {
        tailf:info "Priority of this queue";
        type enumeration {
          enum high {
            tailf:info "High priority queue";
          }
        }
      }
    }

    // interface * / link state group
    container link {
      tailf:info "Configure Link";
      container state {
        tailf:info "Configure link state";
        container group {
          tailf:info "Configure link state group";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf number {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<1-10>;;Link state group number";
              range "1..10";
            }
          }
          leaf direction {
            tailf:cli-drop-node-name;
            type enumeration {
              enum downstream {
                tailf:info "Downstream interface";
              }
              enum upstream {
                tailf:info "Upstream interface";
              }
            }
          }
        }
      }
    }

    // interface * / source template
    container source {
      tailf:info "Get config from another source";
      leaf template {
        tailf:info "Get config from a template";
        tailf:non-strict-leafref {
          path "/ios:template/name";
        }
        type string {
          tailf:info "WORD;;Template name";
        }
      }
    }

    // interface * / l2protocol *
    container l2protocol {
      tailf:info "Configure l2 control protocol processing";
      choice l2protocol-choice {
        leaf drop {
          tailf:info "Drop the l2 control packets";
          tailf:cli-full-command;
          type empty;
        }
        leaf peer {
          tailf:info "peer L2 control protocol packets as data";
          tailf:cli-full-command;
          type empty;
        }
        list protocols {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          key protocol;
          leaf protocol {
            type enumeration {
              enum cdp {
                tailf:info "Cisco Discovery Protocol";
              }
              enum dtp {
                tailf:info "Dynamic Trunking Protocol";
              }
              enum lacp {
                tailf:info "LACP Protocol";
              }
              enum stp {
                tailf:info "Spanning Tree Protocol";
              }
              enum vtp {
                tailf:info "Vlan Trunking Protocol";
              }
            }
          }
          leaf option {
            tailf:cli-drop-node-name;
            tailf:cli-prefix-key;
            type enumeration {
              enum drop {
                tailf:info "Drop the l2 control packets";
              }
              enum peer {
                tailf:info "peer L2 control protocol packets as data";
              }
            }
          }
        }
      }
    }

    // interface * / zone-member security
    container zone-member {
      tailf:info "Apply zone name";
      leaf security {
        tailf:info "Security zone";
        tailf:cli-diff-dependency "../../vrf/forwarding";
        tailf:non-strict-leafref {
          path "/ios:zone/security/id";
        }
        type string {
          tailf:info "WORD;;Zone";
        }
      }
    }

    // interface * / et-analytics enable
    container et-analytics {
      tailf:info "et-analytics support on this interface";
      tailf:cli-diff-dependency "/ios:et-analytics";
      leaf enable {
        tailf:info "Enable et-analytics on this interface";
        type empty;
      }
    }

    // interface * / srlg gid *
    container srlg {
      tailf:info "Interface Shared Risk Link Group config commands";
      list gid {
        tailf:info "SRLG Group ID";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key id;
        leaf id {
          type uint16 {
            tailf:info "<1-8192>;;SRLG ID";
            range "1..8192";
          }
        }
      }
    }

    // interface * / stackwise-virtual link
    container stackwise-virtual {
      tailf:info "Configure Stackwise Virtual link values";
      tailf:cli-diff-dependency "/ios:stackwise-virtual";

      // interface * / stackwise-virtual link
      leaf link {
        tailf:info "Configure Stackwise Virtual link number";
        type uint8 {
          tailf:info "<1-255>;;Stackwise Virtual link number";
        }
      }

      // interface * / stackwise-virtual dual-active-detection
      leaf dual-active-detection {
        tailf:info "Configure this link for dual active detection";
        type empty;
      }
    }

    // interface * / location
    container location {
      tailf:info "Interface location information";

      // interface * / location civic-location-id
      leaf civic-location-id {
        tailf:info "Civic location information";
        type union {
          type string {
            tailf:info "WORD;;civic location identifier string";
          }
          type enumeration {
            enum host {
              tailf:info "Globally defined host location identifer";
            }
            enum none {
              tailf:info "No globally defined location identifer";
            }
          }
        }
      }
    }


    // interface * / bridge-group *
    leaf bridge-group {
      tailf:info "Transparent bridging interface parameters";
      tailf:cli-remove-before-change;
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<1-255>;;Assign an interface to a Bridge Group.";
        range "1..255";
      }
    }

    // interface * / bridge-group * / ?
    container bridge-group-conf {
      tailf:cli-drop-node-name;
      when "../bridge-group" {
        tailf:dependency "../bridge-group";
      }
      list bridge-group {
        tailf:info "Transparent bridging interface parameters";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        max-elements 1;
        key id;
        leaf id {
          type uint8 {
            tailf:info "<1-255>;;Assign an interface to a Bridge Group.";
            range "1..255";
          }
        }

        // interface * / bridge-group * / subscriber-loop-control
        leaf subscriber-loop-control {
          tailf:info "Configure subscriber loop control";
          tailf:cli-full-command;
          type empty;
        }

        // interface * / bridge-group * / block-unknown-source
        leaf block-unknown-source {
          tailf:info "block traffic which come from unknown source MAC address";
          tailf:cli-full-command;
          type empty;
        }

        // interface * / bridge-group * / no source-learning
        leaf source-learning {
          tailf:info "learn source MAC address";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }

        // interface * / bridge-group * / no unicast-flooding
        leaf unicast-flooding {
          tailf:info "flood packets with unknown unicast destination MAC addresses";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }

        // interface * / bridge-group * / spanning-disabled
        leaf spanning-disabled {
          tailf:info "Disable spanning tree on a bridge group";
          tailf:cli-full-command;
          type empty;
        }
      }
    }

    // interface * / tx-ring-limit
    leaf tx-ring-limit {
      tailf:info "Configure transmit ring limit";
      type uint16 {
        tailf:info "uint16;;Number (ring limit)";
      }
    }

    // interface * / tx-queue-limit
    leaf tx-queue-limit {
      type uint16;
    }

    // interface * / l2proto-forward tagged
    container l2proto-forward {
      container tagged {
        presence true;
      }
    }

    // interface * / tag-switching
    container tag-switching {
      tailf:info "Tag Switching interface configuration commands";

      // interface * / tag-switching mtu
      container mtu {
        tailf:info "Set MPLS Maximum Transmission Unit";
        choice mtu-choice {
          leaf override {
            tailf:info "Override mpls mtu maximum of interface mtu";
            type uint16 {
              tailf:info "<1515-1580>;;MTU (bytes)";
            }
          }
          leaf value {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<64-1514>;;MTU (bytes)";
            }
          }
        }
      }

      // interface * / tag-switching ip
      leaf ip {
        tailf:info "Configure IP dynamic Tag Switching";
        type empty;
      }
    }

  } // grouping interface-common-grouping


  // grouping interface-common-ptp-grouping
  grouping interface-common-ptp-grouping {
    uses interface-common-grouping {
      refine "service-policy/input" {
        tailf:cli-diff-dependency "../../encapsulation-pointtopoint/encapsulation";
        tailf:cli-diff-dependency "../../ppp";
      }
      refine "service-policy/output" {
        tailf:cli-diff-dependency "../../encapsulation-pointtopoint/encapsulation";
        tailf:cli-diff-dependency "../../ppp";
      }
      refine "peer/neighbor-route" {
        tailf:cli-diff-dependency "../../encapsulation-pointtopoint/encapsulation" {
          tailf:cli-trigger-on-set;
        }
      }
    }
  }


  // interface-tunnel-grouping
  grouping interface-tunnel-grouping {

    // interface * / tunnel
    container tunnel {
      tailf:info "protocol-over-protocol tunneling";
      tailf:cli-diff-dependency "/ios:crypto/ikev2/profile";
      tailf:cli-diff-dependency "/ios:crypto/ipsec/profile";

      // interface * / tunnel source
      leaf source {
        tailf:info "source of tunnel packets";
        type string {
          tailf:info "WORD;;Interface name or address";
        }
      }

      // interface * / tunnel destination
      leaf destination {
        tailf:info "destination of tunnel";
        type inet:host {
          tailf:info "Hostname, A.B.C.D or X:X:X:X::X;;Destination address";
        }
      }

      // interface * / tunnel mode
      container mode {
        tailf:info "tunnel encapsulation method";
        tailf:cli-diff-set-before "../../ip/subscriber";

        choice mode-choice {

          // interface * / tunnel mode ethernet gre
          container ethernet {
            tailf:info "Ethernet over gre";
            container gre {
              tailf:info "Ethernet over gre";
              choice af-choice {
                container ipv4 {
                  tailf:info "over IPv4";
                  tailf:cli-delete-when-empty;
                  presence true;
                }
                container ipv6 {
                  tailf:info "over IPv6";
                  tailf:cli-delete-when-empty;
                  presence true;
                }
              }
            }
          }

          // interface * / tunnel mode ipsec
          container ipsec {
            tailf:info "IPSec tunnel encapsulation";
            choice af-choice {
              container ipv4 {
                tailf:info "over IPv4";
                tailf:cli-delete-when-empty;
                presence true;
              }
              container ipv6 {
                tailf:info "over IPv6";
                tailf:cli-delete-when-empty;
                presence true;
              }
            }
          }

          // interface * / tunnel mode mpls traffic-eng
          container mpls {
            tailf:info "MPLS encapsulations";
            container traffic-eng {
              tailf:info "Traffic engineering tunnels";
              tailf:cli-delete-when-empty;
              presence true;
              leaf gre-ip {
                type empty;
              }
              leaf point-to-multipoint {
                tailf:info "point-to-multipoint tunnel mode";
                tailf:cli-full-command;
                type empty;
              }
            }
          }

          // interface * / tunnel mode gre
          container gre {
            tailf:info "generic route encapsulation protocol";
            choice gre-choice {
              container multipoint {
                tailf:info "over IPv4 (multipoint)";
                presence true;
                leaf ipv6 {
                  tailf:info "over IPv6";
                  type empty;
                }
              }
              leaf ip {
                tailf:info "over IP";
                type empty;
              }
              leaf ipv6 {
                tailf:info "over IPv6";
                type empty;
              }
              default ip;
            }
          }

          // interface * / tunnel mode eon
          leaf eon {
            tailf:info "EON compatible CLNS tunnel";
            type empty;
          }

          // interface * / tunnel mode ipv6
          leaf ipv6 {
            tailf:info "Generic packet tunneling in IPv6";
            type empty;
          }

          // interface * / tunnel mode ipip
          container ipip {
            tailf:info "IP over IP encapsulation";
            presence true;
          }
        }
      }

      // interface * / tunnel key
      leaf key {
        tailf:info "security or selector key";
        type uint32 {
          tailf:info "<0-4294967295>;;key";
          range "0..4294967295";
        }
      }

      // interface * / tunnel vrf
      leaf vrf {
        tailf:info "set tunnel vrf membership";
        tailf:cli-diff-dependency "../../../../ip/vrf";
        tailf:cli-diff-dependency "../../../../vrf/definition";
        type string {
          tailf:info "WORD;;vrf table name";
        }
      }

      // interface * / tunnel path-mtu-discovery
      container path-mtu-discovery {
        tailf:info "Enable Path MTU Discovery on tunnel";
        presence true;
      }

      // interface * / tunnel bandwidth
      container bandwidth {
        tailf:info "Set bandwidth informational parameter";

        // interface * / tunnel bandwidth receive
        leaf receive {
          tailf:info "Receive bandwidth";
          type uint32 {
            tailf:info "<1-10000000>;;Bandwidth in kilobits";
            range "1..10000000";
          }
        }

        // interface * / tunnel bandwidth transmit
        leaf transmit {
          tailf:info "Transmit bandwidth";
          type uint32 {
            tailf:info "<1-10000000>;;Bandwidth in kilobits";
            range "1..10000000";
          }
        }
      }

      // interface * / tunnel protection
      container protection {
        tailf:info "Enable tunnel protection";

        // interface * / tunnel protection ipsec X
        container ipsec-conf {
          tailf:cli-drop-node-name;
          tailf:cli-diff-dependency "../../mode/ipsec";
          container ipsec {
            tailf:info "Use ipsec to protect this tunnel interface";
            tailf:cli-incomplete-command;
            tailf:cli-incomplete-no;

            // interface * / tunnel protection ipsec policy ipv4
            container policy {
              tailf:info "ACL config";
              leaf ipv4 {
                tailf:info "IPv4 ACL";
                ios:config-lock " tunnel protection ipsec policy ipv4 (\\S+) :: ip access-list extended $1";
                tailf:cli-diff-dependency "/ios:ip/access-list";
                type ext-acl-type;
              }
            }
          }
        }

        // interface * / tunnel protection ipsec profile
        container ipsec {
          tailf:info "Use ipsec to protect this tunnel interface";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          tailf:cli-diff-dependency "../../mode/ipsec";
          leaf profile {
            tailf:info "Determine the ipsec policy profile to use.";
            tailf:non-strict-leafref {
              path "../../../../../../crypto/ipsec/profile/name";
            }
            type string {
              tailf:info "WORD;;IPSec policy profile";
            }
          }
          choice profile-choice {
            // interface * / tunnel protection ipsec profile ? isakmp-profile
            leaf isakmp-profile {
              tailf:info "Specify isakmp profile for the crypto connection.";
              tailf:non-strict-leafref {
                path "../../../../../../crypto/isakmp/profile/name";
              }
              type string {
                tailf:info "WORD;;Profile name.";
              }
            }
            // interface * / tunnel protection ipsec profile ? ikev2-profile
            leaf ikev2-profile {
              tailf:info "Specify ikev2 profile for the crypto connection.";
              tailf:non-strict-leafref {
                path "../../../../../../crypto/ikev2/profile/name";
              }
              type string {
                tailf:info "WORD;;Profile name.";
              }
            }
            // interface * / tunnel protection ipsec profile ? shared
            leaf shared {
              tailf:info "Use a shared socket for the crypto connection.";
              type empty;
            }
          }
        }
      }

      // interface * / tunnel mpls
      container mpls {
        tailf:info "MPLS tunnel commands";

        // interface * / tunnel mpls traffic-eng
        container traffic-eng {
          tailf:info "Configure traffic engineering tunnel parameters";
          tailf:cli-diff-dependency "../../mode/mpls/traffic-eng";

          // interface * / tunnel mpls traffic-eng forwarding-adjacency
          container forwarding-adjacency {
            tailf:info "Treat this tunnel as a Forwarding Adjacency";
            tailf:cli-delete-when-empty;
            tailf:cli-reset-container;
            presence true;
            leaf holdtime {
              tailf:info "How long in msecs to wait upon flooding a down Forwarding Adjacency";
              type uint32 {
                tailf:info "<0-4294967295>;;Holdtime on MPLS TE Down.";
              }
            }
          }

          // interface * / tunnel mpls traffic-eng load-share
          leaf load-share {
            tailf:info "Specify tunnel load-sharing metric";
            tailf:cli-full-command;
            type uint32 {
              tailf:info "<0-1000000>;;Loadshare value";
              range "0..1000000";
            }
          }

          // interface * / tunnel mpls traffic-eng name
          leaf name {
            tailf:info "specify a name describing the TE tunnel";
            tailf:cli-full-command;
            type string {
              tailf:info "WORD;;Name of tunnel (max of 63 characters)";
            }
          }

          // interface * / tunnel mpls traffic-eng affinity
          container affinity {
            tailf:info "desired link attributes for links comprising tunnel";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf attributes {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "<0x0-0xFFFFFFFF>;;affinity value";
              }
            }
            leaf mask {
              tailf:info "mask on desired link attributes";
              type string {
                tailf:info "<0x0-0xFFFFFFFF>;;affinity mask value";
              }
            }
          }

          // interface * / tunnel mpls traffic-eng autoroute
          container autoroute {
            tailf:info "parameters for routing over tunnel";

            // interface * / tunnel mpls traffic-eng autoroute announce
            leaf announce {
              tailf:info "announce tunnel to IGP";
              type empty;
            }

            // interface * / tunnel mpls traffic-eng autoroute destination
            leaf destination {
              tailf:info "announce tunnel destination to IP static route";
              type empty;
            }

            // interface * / tunnel mpls traffic-eng autoroute metric
            container metric {
              tailf:info "Specify mpls tunnel metric";
              choice metric-choice {
                leaf value {
                  tailf:cli-drop-node-name;
                  type uint32 {
                    tailf:info "<1-4294967295>;;Set tunnel metric for autoroutes";
                    range "1..4294967295";
                  }
                }
                leaf absolute {
                  tailf:info "Set metric for all autoroutes over tunnel";
                  type uint32 {
                    tailf:info "<1-4294967295>;;Absolute metric value";
                    range "1..4294967295";
                  }
                }
                leaf relative {
                  tailf:info "Adjust tunnel metric for autoroutes relative to IGP";
                  type int8 {
                    tailf:info "<-10 - 10>;;Relative metric value";
                    range "-10..10";
                  }
                }
              }
            }
          }

          // interface * / tunnel mpls traffic-eng backup-bw
          container backup-bw {
            tailf:info "Represents bw for Fast Reroute backup";
            leaf bandwidth {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<1-4294967295>;;Amount of allocatable backup bw, any lsp may use";
                range "1..4294967295";
              }
            }
          }

          // interface * / tunnel mpls traffic-eng priority
          container priority {
            tailf:info "tunnel priority";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf setup-priority {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<0-7>;;setup priority";
                range "0..7";
              }
            }
            leaf hold-priority {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<0-7>;;hold priority";
                range "0..7";
              }
            }
          }

          // interface * / tunnel mpls traffic-eng bandwidth
          container bandwidth {
            tailf:info "tunnel bandwidth requirement";
            leaf requirement {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<0-4294967295>;;bandwidth requirement in kbps";
              }
            }
          }

          // interface * / tunnel mpls traffic-eng path-option *
          list path-option {
            tailf:info "a primary or fallback path setup option";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-all-siblings;
            }
            tailf:cli-incomplete-command;
            key id;
            leaf id {
              tailf:cli-suppress-range;
              type uint16 {
                tailf:info "<1-1000>;;preference for this path option";
              }
            }
            choice path-option-choice {
              // interface * / tunnel mpls traffic-eng path-option * dynamic
              leaf dynamic {
                tailf:info "setup based on dynamically calculcated path";
                tailf:cli-optional-in-sequence;
                type empty;
              }
              // interface * / tunnel mpls traffic-eng path-option * explicit
              container explicit {
                tailf:info "setup based on preconfigured path";
                tailf:cli-flatten-container;
                tailf:cli-compact-syntax;
                tailf:cli-optional-in-sequence;
                choice explicit-choice {
                  leaf name {
                    tailf:info "Specify an IP explicit path by name";
                    type string {
                      tailf:info "WORD;;Name of ip explicit path";
                    }
                  }
                  leaf identifier {
                    tailf:info "Specify an IP explicit path by number";
                    type uint16 {
                      tailf:info "<1-65535>;;Number of ip explicit path";
                    }
                  }
                }
              }
            }
            uses if-tunnel-mpls-traffic-eng-path-option-grouping;
          }

          // interface * / tunnel mpls traffic-eng path-option protect *
          container path-option-protect {
            tailf:cli-drop-node-name;
            container path-option {
              tailf:info "a primary or fallback path setup option";
              list protect {
                tailf:info "a path protection setup option";
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                tailf:cli-incomplete-command;
                key id;
                leaf id {
                  tailf:cli-suppress-range;
                  type uint16 {
                    tailf:info "<1-1000>;;preference for this path option";
                  }
                }
                choice path-option-choice {
                  leaf diverse {
                    tailf:info "setup based on dynamically calculcated diverse path";
                    tailf:cli-optional-in-sequence;
                    type empty;
                  }
                  container explicit {
                    tailf:info "setup based on preconfigured path";
                    tailf:cli-optional-in-sequence;
                    tailf:cli-flatten-container;
                    tailf:cli-compact-syntax;
                    choice explicit-choice {
                      leaf name {
                        tailf:info "Specify an IP explicit path by name";
                        type string {
                          tailf:info "WORD;;Name of ip explicit path";
                        }
                      }
                      leaf identifier {
                        tailf:info "Specify an IP explicit path by number";
                        type uint16 {
                          tailf:info "<1-65535>;;Number of ip explicit path";
                        }
                      }
                    }
                  }
                }
                uses if-tunnel-mpls-traffic-eng-path-option-grouping;
              }
            }
          }

          // interface * / tunnel mpls traffic-eng bidirectional association
          container bidirectional {
            tailf:info "Configure bidirectional LSPs";
            container association {
              tailf:info "Specify association parameters";

              // interface * / tunnel mpls traffic-eng bidirectional association id
              container id {
                tailf:info "Unique association ID";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                leaf value {
                  tailf:cli-drop-node-name;
                  tailf:cli-incomplete-command;
                  type uint16 {
                    tailf:info "<0-65535>;;Association ID";
                  }
                }
                leaf source-address {
                  tailf:info "Source IP address";
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;IP address";
                  }
                }
                leaf global-id {
                  tailf:info "Global ID for association global source";
                  type uint32 {
                    tailf:info "<1-4294967295>;;Global ID";
                    range "1..4294967295";
                  }
                }
              }

              // interface * / tunnel mpls traffic-eng bidirectional association type co-routed
              container type {
                tailf:info "Association type";
                container co-routed {
                  tailf:info "Co-routed LSPs (with bidirectional CSPF)";
                  tailf:cli-compact-syntax;
                  tailf:cli-sequence-commands {
                    tailf:cli-reset-siblings;
                  }
                  tailf:cli-delete-when-empty;
                  presence true;
                  leaf fault-oam {
                    tailf:info "Enable fault OAM";
                    type empty;
                  }
                  leaf wrap-protection {
                    tailf:info "Enable wrap-protection";
                    type empty;
                  }
                }
              }
            }
          }

          // interface * / tunnel mpls traffic-eng path-selection
          container path-selection {
            tailf:info "Path Selection Configuration";

            // interface * / tunnel mpls traffic-eng path-selection metric
            leaf metric {
              tailf:info "Metric type for path calculation";
              type enumeration {
                enum igp {
                  tailf:info "Use IGP Metric";
                }
                enum te {
                  tailf:info "Use TE Metric";
                }
              }
            }

            // interface * / tunnel mpls traffic-eng path-selection segment-routing adjacency
            container segment-routing {
              tailf:info "Segment-routing path-selection options";
              leaf adjacency {
                tailf:info "Segment-routing adjacency path-selection type";
                type enumeration {
                  enum protected {
                    tailf:info "Use only protected adjacencies";
                  }
                  enum unprotected {
                    tailf:info "Use only unprotected adjacencies";
                  }
                }
              }
            }
          }

          // interface * / tunnel mpls traffic-eng auto-bw
          container auto-bw {
            tailf:info "Specify mpls tunnel should automatically change bw";
            tailf:cli-compact-syntax;
            tailf:cli-delete-when-empty;
            presence true;
            leaf frequency {
              tailf:info "Frequency to change tunnel BW";
              type uint32 {
                tailf:info "<300-604800>;;seconds between applying auto-bw";
                range "300..604800";
              }
            }
            leaf adjustment-threshold {
              tailf:info "Set the bandwidth change threshold to trigger adjustment";
              type uint8 {
                tailf:info "<1-99>;;Percent bandwidth change to trigger adjustment";
                range "1..99";
              }
            }
            leaf max-bw {
              tailf:info "Set the Maximum Bandwidth for auto-bw on this tunnel";
              type uint32 {
                tailf:info "<0-4294967295>;;Maximum kb/s that tunnel can be auto set to";
              }
            }
            leaf min-bw {
              tailf:info "Set the Minimum Bandwidth for auto-bw on this tunnel";
              type uint32 {
                tailf:info "<0-4294967294>;;Min kb/s that tunnel can be auto set to";
              }
            }
            leaf collect-bw {
              tailf:info "Just collect Bandwidth info on this tunnel";
              type empty;
            }
          }

          // interface * / tunnel mpls traffic-eng record-route
          leaf record-route {
            tailf:info "record the route used by the tunnel";
            type empty;
          }

          // interface * / tunnel mpls traffic-eng fast-reroute
          container fast-reroute {
            tailf:info "Specify mpls tunnel can be fast-rerouted";
            presence true;
          }

          // interface * / tunnel mpls traffic-eng bfd
          container bfd {
            tailf:info "Bidirectional Forwarding Detection (BFD) configuration";

            // interface * / tunnel mpls traffic-eng bfd encap-mode gal
            container encap-mode {
              tailf:info "Encapsulation mode used by BFD";
              leaf gal {
                tailf:info "Generic Associated Label (GAL) encapsulation for BFD";
                tailf:cli-diff-dependency "/ios:bfd-template/single-hop";
                type string {
                  tailf:info "WORD;;name of the bfd-template";
                }
              }
            }
          }
        }
      }

      // interface * / tunnel vlan *
      leaf-list vlan {
        tailf:info "Set vlan-id for ethernet over gre mode";
        tailf:cli-range-list-syntax;
        tailf:cli-replace-all;
        tailf:cli-diff-dependency "../mode/ethernet/gre";
        type uint16 {
          tailf:info "<1-4094>;;vlan-id";
          range "1..4094";
        }
      }

      // interface * / tunnel checksum
      leaf checksum {
        tailf:info "enable end to end checksumming of packets";
        type empty;
      }

      // interface * / tunnel route-via
      container route-via {
        tailf:info "Select subset of routes for tunnel transport";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        uses interface-name-grouping;

        leaf mandatory-preferred {
          tailf:cli-drop-node-name;
          type enumeration {
            enum "mandatory" {
              tailf:info "If route is not available, drop traffic";
            }
            enum "preferred" {
              tailf:info "If route is not available, use any routec";
            }
          }
        }
      }
    }

    // interface * / domain
    container domain {
      tailf:info "Specify a domain";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      tailf:cli-diff-dependency "../tunnel";
      leaf domain-name {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        tailf:non-strict-leafref {
          path "/ios:domain/name";
        }
        tailf:cli-disallow-value "path|saf|dynamic-path|dci-path";
        type string {
          tailf:info "WORD;;Domain name"; // default: default
        }
      }

      choice path-choice {
        leaf dynamic-path {
          tailf:info "Designate this interface as PfR WAN interface on Branch border";
          tailf:cli-full-command;
          type empty;
        }
        leaf dci-path {
          tailf:info "Specify a DCI service provider for this interface";
          type string {
            tailf:info "WORD;;Specify the color of service providerWORD  Specify the color of service provider";
          }
        }
        leaf path {
          tailf:info "Specify a service provider for this interface";
          type string {
            tailf:info "WORD;;Specify the color of service provider";
          }
        }
        container saf {
          tailf:info "Specify SAF paramenters";
          tailf:cli-flatten-container;
          leaf neighboring {
            tailf:info "Enable SAF neighboring";
            tailf:cli-full-command;
            type empty;
          }
        }
      }

      leaf path-id {
        tailf:cli-break-sequence-commands;
        tailf:info "Specify Path ID";
        type uint8 {
          tailf:info "<1-62>;;Path ID";
          range "1..62";
        }
      }
      leaf internet-bound {
        tailf:info "Specify Internet-bound interface";
        tailf:cli-full-command;
        type empty;
      }
      leaf zero-sla {
        tailf:info "Specify if you want this interface to be a 0-sla interface";
        tailf:cli-full-command;
        type empty;
      }
      leaf path-last-resort {
        tailf:info "Specify if you want this interface to be a path of last resort";
        tailf:cli-full-command;
        type empty;
      }
    }

    // interface * / domain smart-probe
    container domain-smart-probe {
      tailf:cli-drop-node-name;
      tailf:cli-diff-dependency "../domain";
      container domain {
        tailf:info "Specify a domain";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf domain-name {
          tailf:cli-drop-node-name;
          tailf:cli-optional-in-sequence;
          tailf:cli-incomplete-command;
          tailf:non-strict-leafref {
            path "/ios:domain/name";
          }
          tailf:cli-disallow-value "path|saf|dynamic-path|dci-path";
          type string {
            tailf:info "WORD;;Domain name"; // default: default
          }
        }
        container smart-probe {
          tailf:info "smart-probe related configuration";
          tailf:cli-flatten-container;
          leaf profile {
            tailf:info "apply smart-probe profile to this interface";
            type uint8 {
              tailf:info "<0-2>;;smart-probe profile ID number. Default 0";
              range "0..2";
            }
            default 0;
          }
        }
      }
    }
  }


  // interface-ethernet-pre-grouping
  grouping interface-ethernet-pre-grouping {

    // interface * / port-type
    leaf port-type {
      tailf:info "Set port type";
      tailf:ned-ignore-compare-config;
      type enumeration {
        enum eni {
          tailf:info "Set port-type to ENI";
        }
        enum nni {
          tailf:info "Set port-type to NNI";
        }
        enum uni {
          tailf:info "Set port-type to UNI";
        }
      }
    }

    // interface * / platform ring
    container platform {
      tailf:info "Configure platform";

      // interface * / platform qos
      container qos {
        tailf:info "qos command keyword";

        // interface * / platform qos vlan-based
        leaf vlan-based {
          tailf:info "vlan-based keyword";
          type empty;
        }

        // interface * / platform qos queue-mode mode-dscp
        container queue-mode {
          tailf:info "queueing mode";
          leaf mode-dscp {
            tailf:info "queueing mode dscp";
            type empty;
          }
        }
      }

      // interface * / platform ring
      container ring {
        tailf:info "Configure ring entries commands";
        leaf rx {
          tailf:info "Configure receiver ring entries";
          type uint16 {
            tailf:info "<1-4096>;;Number of ring entries for the Rx ring";
            range "1..4096";
          }
        }
        leaf tx {
          tailf:info "Configure transmit ring entries";
          type uint16 {
            tailf:info "<1-4096>;;Number of ring entries for the Tx ring";
            range "1..4096";
          }
        }
      }
    }

    // interface * / encapsulation
    container encapsulation {
      tailf:info "Set encapsulation type for an interface";
      tailf:cli-diff-set-before "../ip";
      tailf:cli-diff-delete-after "../ip"; // NSO: works on 4.5.6, fails on 4.5.2

      // interface * / encapsulation dot1Q
      container dot1Q {
        tailf:info "IEEE 802.1Q Virtual LAN";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf vlan-id {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-4094>;;IEEE 802.1Q VLAN ID required";
            range "1..4094";
          }
        }
        leaf second-dot1q {
          tailf:info "Configure this subinterface as a 1Q-in-1Q subinterface";
          tailf:cli-optional-in-sequence;
          tailf:cli-full-command;
          type union {
            type enumeration {
              enum any {
                tailf:info "All Inner VLAN IDs not configured on another subinterface";
              }
            }
            type string {
              tailf:info "Second (inner) VLAN IDs e.g. 100,200-300,400,500-600";
            }
          }
        }
        leaf native {
          tailf:info "Make this as native vlan";
          type empty;
        }
      }
    }
  }

  // interface-ethernet-grouping
  grouping interface-ethernet-grouping {

    // interface * / authentication
    container authentication {
      tailf:info "set the port-control value";

      // interface * / authentication control-direction
      leaf control-direction {
        tailf:info "Set the control-direction on the interface";
        type enumeration {
          enum both {
            tailf:info "Control traffic in BOTH directions";
          }
          enum in {
            tailf:info "Control inbound traffic only";
          }
        }
        default both;
      }

      // interface * / authentication event
      container event {
        tailf:info "Set action for authentication events";

        // interface * / authentication event fail
        container fail {
          tailf:info "Configure failed authentication actions/parameters";
          tailf:cli-compact-syntax;
          tailf:cli-reset-container;

          // interface * / authentication event fail retry
          leaf retry {
            tailf:info "Number of times to retry failed authentications";
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-5>;;Enter the retry count";
              range "0..5";
            }
          }

          container action {
            tailf:info "Required action for authentication event";
            tailf:cli-flatten-container;

            // interface * / authentication event fail action authorize vlan
            choice authentication-event-fail-action-choice {
              container authorize {
                tailf:info "Authorize the port";
                tailf:cli-flatten-container;
                tailf:cli-compact-syntax;
                leaf vlan {
                  tailf:info "VLAN ID";
                  type uint16 {
                    tailf:info "<1-65535>;;VLAN ID";
                    range "1..65535";
                  }
                }
              }

              // interface * / authentication event fail action next-method
              leaf next-method {
                tailf:info "Move to next authentication method";
                type empty;
              }
            }
          }
        }

          // interface * / authentication event server
        container server {
          tailf:info "Configure actions for AAA server events";

          // interface * / authentication event server dead
          container dead {
            tailf:info "Configure AAA server dead actions";
            container action {
              tailf:info "Required action for authentication event";

              // interface * / authentication event server dead action reinitialize vlan
              container reinitialize {
                tailf:info "Reinitialize all client on the port";
                leaf vlan {
                  tailf:info "Configure Critical Authorization VLAN";
                  type uint16 {
                    tailf:info "<1-4094>;;Enter a VlanId";
                    range "1..4094";
                  }
                }
              }

              // interface * / authentication event server dead action authorize
              container authorize-enable {
                tailf:cli-drop-node-name;
                leaf authorize {
                  tailf:info "Authorize the port";
                  type empty;
                }
              }

              // interface * / authentication event server dead action authorize X
              container authorize {
                tailf:info "Authorize the port";
                tailf:cli-incomplete-command;
                tailf:cli-incomplete-no;

                // interface * / authentication event server dead action authorize vlan *
                leaf-list vlan {
                  tailf:info "Configure Critical Authorization VLAN";
                  tailf:cli-list-syntax;
                  type uint16 {
                    tailf:info "<1-4094>;;Enter a VlanId";
                    range "1..4094";
                  }
                }

                // interface * / authentication event server dead action authorize voice
                leaf voice {
                  tailf:info "Configure Critical Authorization VLAN";
                  type empty;
                }
              }
            }
          }

          // interface * / authentication event server avlive action reinitialize
          container alive {
            tailf:info "Configure AAA server alive actions";
            container action {
              tailf:info "Required action for authentication event";
              leaf reinitialize {
                tailf:info "Reinitialize all authorized clients";
                type empty;
              }
            }
          }
        }

        // interface * / authentication event no-response action authorize vlan
        container no-response {
          tailf:info "Configure non-responsive host actions";
          container action {
            tailf:info "Required action for authentication event";
            container authorize {
              tailf:info "Authorize the port";
              leaf vlan {
                tailf:info "Configure Guest vlan";
                type uint16 {
                  tailf:info "<1-4094>;;Enter a VlanId";
                  range "1..4094";
                }
              }
            }
          }
        }
      }

      // interface * / authentication host-mode
      leaf host-mode {
        tailf:info "Set the Host mode for authentication on this interface";
        type enumeration {
          enum multi-auth {
            tailf:info "Multiple Authentication Mode";
          }
          enum multi-domain {
            tailf:info "Multiple Domain Mode";
          }
          enum multi-host {
            tailf:info "Multiple Host Mode";
          }
          enum single-host {
            tailf:info "SINGLE HOST Mode";
          }
        }
        default single-host;
      }

      // interface * / authentication open
      leaf open {
        tailf:info "Enable or Disable open access on this port";
        type empty;
      }

      // interface * / authentication order *
      leaf-list order {
        tailf:info "Add an authentication method to the order list";
        tailf:cli-flat-list-syntax;
        tailf:cli-replace-all;
        ordered-by user;
        type enumeration {
          enum dot1x {
            tailf:info "Authentication method 'dot1x' allowed";
          }
          enum mab {
            tailf:info "Authentication method 'mab' allowed";
          }
          enum webauth {
            tailf:info "Authentication method 'webauth' allowed";
          }
        }
      }

      // interface * / authentication priority *
      leaf-list priority {
        tailf:info "Add an authentication method to the priority list";
        tailf:cli-flat-list-syntax;
        tailf:cli-replace-all;
        ordered-by user;
        type enumeration {
          enum dot1x {
            tailf:info "Authentication method 'dot1x' allowed";
          }
          enum mab {
            tailf:info "Authentication method 'mab' allowed";
          }
          enum webauth {
            tailf:info "Authentication method 'webauth' allowed";
          }
        }
      }

      // interface * / authentication port-control
      leaf port-control {
        tailf:info "Set the port-control value";
        type enumeration {
          enum auto {
            tailf:info "PortState will be set to AUTO";
          }
          enum force-authorized {
            tailf:info "PortState set to Authorized";
          }
          enum force-unauthorized {
            tailf:info "PortState will be set to UnAuthorized";
          }
        }
        default force-authorized;
      }

      // interface * / authentication periodic
      leaf periodic {
        tailf:info "Enable or Disable Reauthentication for this port";
        type empty;
      }

      // interface * / authentication timer
      container timer {
        tailf:info "Set authentication timer values";

        // interface * / authentication timer reauthenticate
        leaf reauthenticate {
          tailf:info "Time in seconds after which an automatic "+
            "re-authentication should be initiated (default 1 hour)";
          type union {
            type uint16 {
              tailf:info "<1-65535>;;Enter a value between 1 and 65535";
              range "1..65535";
            }
            type enumeration {
              enum server {
                tailf:info "Obtain re-authentication timeout value from the server";
              }
            }
          }
        }

        // interface * / authentication timer inactivity
        container inactivity {
          tailf:info "Interval in seconds after which if there is no activity"
            +" from the client then it will be unauthorized (default OFF)";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf value {
            tailf:cli-drop-node-name;
            type union {
              type uint16 {
                tailf:info "<1-65535>;;Enter a value between 1 and 65535";
                range "1..65535";
              }
              type enumeration {
                enum server {
                  tailf:info "Obtain inactivity timeout value from the server";
                }
              }
            }
          }
          leaf dynamic {
            tailf:info "Initiate a dynamic probe on inactivity timeout";
            type empty;
          }
        }
      }

      // interface * / authentication violation
      leaf violation {
        tailf:info "Configure action to take on security violations";
        type enumeration {
          enum protect {
            tailf:info "Protect the port";
          }
          enum replace {
            tailf:info "Replace the existing session";
          }
          enum restrict {
            tailf:info "Restrict the port";
          }
          enum shutdown {
            tailf:info "SHUTDOWN the port";
          }
        }
        default shutdown;
      }
    }

    // interface * / mac access-group * in
    // interface * / mac access-group * out
    container mac {
      tailf:info "MAC interface commands";
      list access-group {
        tailf:info "MAC access-group configuration commands";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        key direction;
        leaf direction {
          type enumeration {
            enum in {
              tailf:info "Apply to Ingress";
            }
            enum out {
              tailf:info "Apply to Egress";
            }
          }
        }
        leaf access-list {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          tailf:non-strict-leafref {
            path "/ios:mac/access-list/extended/id";
          }
          type string {
            tailf:info "WORD;;ACL name";
          }
        }
      }
    }

    // interface * / rmon
    container rmon {
      tailf:info "Configure Remote Monitoring on an interface";

      // interface * / rmon promiscuous
      leaf promiscuous {
        tailf:info "Monitor the interface in promiscuous mode";
        type empty;
      }

      // interface * / rmon collection
      container collection {
        tailf:info "Configure Remote Monitoring Collection on an interface";

        // interface * / rmon collection stats * owner
        list stats {
          tailf:info "Configure statistics";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key id;
          leaf id {
            type uint16 {
              tailf:info "<1-65535>;;Set RMON collection control index";
            }
          }
          leaf owner {
            tailf:info "Configure the owner of this RMON collection";
            type string {
              tailf:info "WORD;;RMON collection owner";
            }
          }
        }
      }
    }

    // interface * / spanning-tree
    container spanning-tree-enable {
      tailf:cli-drop-node-name;
      leaf spanning-tree {
        tailf:info "Spanning Tree Subsystem";
        tailf:cli-diff-delete-before "../../port-type";
        ios:if-redeploy "*/spanning-tree/bpduguard/enable :: spanning-tree bpduguard enable :: delete"
          +" ;; /spanning-tree/guard :: spanning-tree guard :: delete";
        type empty;
      }
    }

    // interface * / spanning-tree XX
    container spanning-tree {
      tailf:info "Spanning Tree Subsystem";
      tailf:cli-diff-delete-before "../port-type";
      tailf:cli-diff-delete-before "../spanning-tree-enable/spanning-tree";
      tailf:cli-incomplete-command;
      tailf:cli-incomplete-no;

      // interface * / spanning-tree bpdufilter
      leaf bpdufilter {
        tailf:info "Don't send or receive BPDUs on this interface";
        type enumeration {
          enum disable {
            tailf:info "Disable BPDU filtering for this interface";
          }
          enum enable {
            tailf:info "Enable BPDU filtering for this interface";
          }
        }
      }

      // interface * / spanning-tree bpduguard
      container bpduguard {
        tailf:info "Don't accept BPDUs on this interface";
        choice bpduguard-choice {
          leaf disable {
            tailf:info "Disable BPDU guard for this interface";
            type empty;
          }
          leaf enable {
            tailf:info "Enable BPDU guard for this interface";
            tailf:cli-diff-dependency "../../../ethernet/dot1ad/nni";
            type empty;
          }
        }
      }

      // interface * / spanning-tree cost
      leaf cost {
        tailf:info "To set the path cost of the interface";
        tailf:cli-full-command;
        type uint32 {
          tailf:info "<1-200000000>;;port path cost";
          range "1..200000000";
        }
      }

      // interface * / spanning-tree guard
      leaf guard {
        tailf:info "Change an interface's spanning tree guard mode";
        tailf:cli-full-command;
        type enumeration {
          enum loop {
            tailf:info "Set guard mode to loop guard on interface";
          }
          enum none {
            tailf:info "Set guard mode to none";
          }
          enum root {
            tailf:info "Set guard mode to root guard on interface";
          }
        }
      }

      // interface * / spanning-tree link-type
      leaf link-type {
        tailf:info "Specify a link type for spanning tree tree protocol use";
        tailf:cli-full-command;
        type enumeration {
          enum auto {
            tailf:code-name link_type_auto;
            tailf:info "Determine link type based on media duplex of this interface";
          }
          enum none {
            tailf:info "Consider the interface as point-to-point";
          }
          enum point-to-point {
            tailf:info "Consider the interface as point-to-point";
          }
          enum root {
            tailf:info "Consider the interface as shared";
          }
          enum shared {
            tailf:info "Consider the interface as shared";
          }
        }
      }

      // interface * / spanning-tree mst
      container mst {
        tailf:info "Multiple spanning tree";
        choice mst-choice {
          list instance-range {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-range-list-syntax;
            key id;
            leaf id {
              type uint16 {
                tailf:info "MST instance list, example 0,2-4,6,8-12";
              }
            }
            leaf cost {
              tailf:info "Change the interface spanning tree path cost for an instance";
              type uint32 {
                tailf:info "<1-200000000>;;Change the interface spanning tree path cost for an instance";
                range "1..200000000";
              }
            }
            leaf port-priority {
              tailf:info "Change the spanning tree port priority for an instance";
              type uint16 {
                tailf:info "<0-240>;;port priority in increments of 16";
                range "0..240" {
                  tailf:step 16;
                }
              }
            }
          }
          leaf pre-standard {
            tailf:info "Force pre-standard MST BPDU transmission on port";
            type empty;
          }
        }
      }

      // interface * / spanning-tree portfast
      container portfast {
        tailf:info "Spanning tree portfast options";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence true;
        choice portfast-choice {
          leaf disable {
            tailf:info "Disable portfast for this interface";
            type empty;
          }
          leaf network {
            tailf:info "Enable portfast network on the interface";
            type empty;
          }
          case trunk-mode {
            leaf edge {
              tailf:info "Enable portfast edge on the interface";
              type empty;
            }
            leaf trunk {
              tailf:info "Enable portfast edge on the interface even in trunk mode";
              type empty;
            }
          }
        }
      }

      // interface * / spanning-tree loopguard default
      container loopguard {
        tailf:info "Spanning tree loopguard options";
        leaf default {
          tailf:info "Enable loopguard by default on all ports";
          type empty;
        }
      }

      // interface * / spanning-tree port-priority
      leaf port-priority {
        tailf:info "Change an interface's spanning tree port priority";
        type uint8 {
          tailf:info "<0-240>;;port priority in increments of 16";
          range "0..240" {
            tailf:step 16;
          }
        }
      }

      // interface * / spanning-tree vlan * port-priority
      // interface * / spanning-tree vlan * cost
      list vlan {
        tailf:info "VLAN Switch Spanning Tree";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-range-list-syntax;
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          type uint16 {
            tailf:info "WORD;;vlan range, example: 1,3-5,7,9-11";
            range "1..4096";
          }
        }
        leaf port-priority {
          tailf:info "Change an interface's spanning tree port priority";
          type uint8 {
            tailf:info "<0-240>;;port priority in increments of 16";
            range "0..240" {
              tailf:step 16;
            }
          }
        }
        leaf cost {
          tailf:info "Change an interface's per VLAN spanning tree path cost";
          type uint32 {
            tailf:info "<1-200000000>;;Change an interface's per VLAN spanning tree path cost";
            range "1..200000000";
          }
        }
      }
    }

    // interface * / srr-queue bandwidth
    container srr-queue {
      tailf:info "Configure shaped round-robin transmit queues";
      container bandwidth {
        tailf:info "Configure shared bandwidth";

        // interface * / srr-queue bandwidth limit
        leaf limit {
          tailf:info "Configure bandwidth-limit for this interface";
          type uint8 {
            tailf:info "<10-90>;;enter bandwidth limit for interface as percentage";
            range "10..90";
          }
        }

        // interface * / srr-queue bandwidth shape
        container shape {
          tailf:info "Configure shaping on transmit queues";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-reset-container;
          leaf weight1 {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<0-65535>;;enter bandwidth weight for queue id 1";
            }
          }
          leaf weight2 {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<0-65535>;;enter bandwidth weight for queue id 2";
            }
          }
          leaf weight3 {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<0-65535>;;enter bandwidth weight for queue id 3";
            }
          }
          leaf weight4 {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<0-65535>;;enter bandwidth weight for queue id 4";
            }
          }
        }

        // interface * / srr-queue bandwidth share
        container share {
          tailf:info "Configure shared bandwidth";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-reset-container;
          leaf weight1 {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<1-255>;;enter bandwidth weight for queue id 1";
              range "1..255";
            }
          }
          leaf weight2 {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<1-255>;;enter bandwidth weight for queue id 2";
              range "1..255";
            }
          }
          leaf weight3 {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<1-255>;;enter bandwidth weight for queue id 3";
              range "1..255";
            }
          }
          leaf weight4 {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-255>;;enter bandwidth weight for queue id 4";
              range "1..255";
            }
          }
        }
      }
    }

    // interface * / queue-set
    leaf queue-set {
      tailf:info "Choose a queue set for this queue";
      type uint8 {
        tailf:info "<1-2>;;the qset to which this port is mapped";
      }
    }

    // interface * / dot1x
    container dot1x {
      tailf:info "Interface Config Commands for IEEE 802.1X";

      // interface * / dot1x pae authenticator
      container pae {
        tailf:info "Set 802.1x interface pae type";
        leaf authenticator {
          tailf:info "Set pae type as Authenticator";
          type empty;
        }
      }

      // interface * / dot1x timeout
      container timeout {
        tailf:info "Various Timeouts";
        tailf:cli-diff-dependency "../pae/authenticator";

        // interface * / dot1x timeout quiet-period
        leaf quiet-period {
          tailf:info "QuietPeriod in Seconds";
          type uint16 {
            tailf:info "<1-65535>;;Enter a value between 1 and 65535";
            range "1..65535";
          }
        }

        // interface * / dot1x timeout tx-period
        leaf tx-period {
          tailf:info "Timeout for supplicant retries";
          type uint16 {
            tailf:info "<1-65535>;;Enter a value between 1 and 65535";
            range "1..65535";
          }
        }

        // interface * / dot1x timeout supp-timeout
        leaf supp-timeout {
          tailf:info "Timeout for supplicant reply";
          type uint16 {
            tailf:info "<1-65535>;;Enter a value between 1 and 65535";
            range "1..65535";
          }
        }

        // interface * / dot1x timeout supp-period
        leaf supp-period {
          tailf:info "Timeout for supplicant reply";
          type uint16 {
            tailf:info "<1-65535>;;Enter a value between 1 and 65535";
            range "1..65535";
          }
        }

        // interface * / dot1x timeout ratelimit-period
        leaf ratelimit-period {
          tailf:info "Ratelimit Period in seconds";
          type uint16 {
            tailf:info "<1-65535>;;Enter a value between 1 and 65535";
            range "1..65535";
          }
        }

        // interface * / dot1x timeout held-period
        leaf held-period {
          tailf:info "Timeout for authentication retries";
          type uint16 {
            tailf:info "<1-65535>;;Enter a value between 1 and 65535";
            range "1..65535";
          }
        }
      }

      // interface * / dot1x max-reauth-req
      leaf max-reauth-req {
        tailf:info "Max No. of Reauthentication Attempts";
        type uint8 {
          tailf:info "<1-10>;;Enter a value between 1 and 10";
          range "1..10";
        }
      }
    }

    // interface * / macro
    container macro {
      tailf:info "Command macro";

      // interface * / macro description
      uses description-grouping;

      // interface * / no macro auto processing
      container auto {
        tailf:info "Smartport interface macro configurations";
        leaf processing {
          tailf:info "Enable smartport macro auto execution on this interface";
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }
      }
    }

    // interface * / media-type
    leaf media-type {
      tailf:info "Media type";
      tailf:cli-full-command;
      ios:if-redeploy "/speed :: speed :: create :: auto ;; /duplex :: duplex :: create :: auto";
      type enumeration {
        enum rj45 {
          tailf:info "Copper";
        }
        enum sfp {
          tailf:info "Fiber";
        }
        enum auto-select {
          tailf:info "Auto Select";
        }
        enum gbic {
        }
      }
      default auto-select;
    }

    // interface * / no mdix auto
    // DEP: media-type rj45, [no] mdix auto
    // DEP: [no] mdix auto, media-type sfp
    container mdix {
      tailf:info "Set Media Dependent Interface with Crossover";
      leaf auto {
        tailf:info "Enable automatic MDI crossover detection on this interface";
        tailf:cli-boolean-no;
        type boolean;
        default true;
      }
    }

    // interface * / channel-protocol
    leaf channel-protocol {
      tailf:info "Select the channel protocol (LACP, PAgP)";
      type enumeration {
        enum lacp {
          tailf:info "Prepare interface for LACP protocol";
        }
        enum pagp {
          tailf:info "Prepare interface for PAgP protocol";
        }
      }
    }

    // interface * / lacp
    container lacp {
      tailf:info "LACP interface subcommands";

      // interface * / lacp rate
      leaf rate {
        tailf:info "Rate at which the LACP packets are requested to be ingressed to this interface";
        type enumeration {
          enum fast {
            tailf:info "Request LACP packets to be ingressed at the 1 second rate for this interface";
          }
          enum normal {
            tailf:info "Request LACP packets to be ingressed at the 30 second rate once the link is established";
          }
        }
        default normal;
      }

      // interface* / lacp fast-switchover
      leaf fast-switchover {
        tailf:info "Enable LACP fast switchover on this port channel";
        type empty;
      }

      // interface * / lacp min-bundle
      leaf min-bundle {
        tailf:info "LACP minimum number of ports to bundle in this port channel";
        type uint8 {
          tailf:info "<1-8>;;Minimum number of ports to bundle in this Port Channel";
          range "1..8";
        }
      }

      // interface * / lacp max-bundle
      leaf max-bundle {
        tailf:info "LACP maximum number of ports to bundle in this port channel";
        type uint8 {
          tailf:info "<1-8>;;Max number of ports to bundle in this Port Channel";
          range "1..8";
        }
      }

      // interface * / lacp port-priority
      leaf port-priority {
        tailf:info "LACP priority on this interface";
        type uint16 {
          tailf:info "<0-65535>;;Priority value";
        }
      }
    }

    // interface * / plim
    container plim {
      tailf:info "Configure features on the PLIM";

      // interface * / plim ethernet vlan filter disable
      container ethernet {
        tailf:info "Configure features on the ethernet interface";
        container vlan {
          tailf:info "vlan specific features";
          container filter {
            tailf:info "Configure VLAN filtering";
            leaf disable {
              tailf:info "Configure the interface to accept all VLAN traffic";
              type empty;
            }
          }
        }
      }
    }

    // interface * / ethernet
    container ethernet {
      tailf:info "Ethernet interface parameters";

      // interface * / ethernet oam XXX
      container oam-conf {
        tailf:cli-drop-node-name;
        container oam {
          tailf:info "To enable Ethernet Link OAM";

          // interface * / ethernet oam max-rate
          leaf max-rate {
            tailf:info "Maximum transmission rate(number of OAMPDUs per second)";
            type uint8 {
              tailf:info "<1-10>;;Set the rate in number of packets per second. Default 10";
              range "1..10";
            }
            default 10;
          }

          // interface * / ethernet oam min-rate
          leaf min-rate {
            tailf:info "Minimum transmission rate(one OAMPDU per number of seconds)";
            type uint8 {
              tailf:info "<1-10>;;Set the rate in number of seconds. Default 1";
              range "1..10";
            }
            default 1;
          }

          // interface * / ethernet oam mode
          leaf mode {
            tailf:info "Ethernet OAM client mode";
            type enumeration {
              enum "active" {
                tailf:info "Active mode";
              }
              enum "passive" {
                tailf:info "Passive mode";
              }
            }
          }

          // interface * / ethernet oam remote-loopback
          container remote-loopback {
            tailf:info "Ethernet OAM Remote Loopback";

            // interface * / ethernet oam remote-loopback supported
            leaf supported {
              tailf:info "Support remote loopback functionality";
              type empty;
            }
          }

          // interface * / ethernet oam timeout
          leaf timeout {
            tailf:info "Ethernet OAM client link timeout setting";
            type uint8 {
              tailf:info "<2-30>;;Set timeout value in number of seconds. Default 5";
              range "2..30";
            }
            default 5;
          }

          // interface * / ethernet oam link-monitor
          container link-monitor {
            tailf:info "Ethernet OAM Link Monitor";

            // interface * / no ethernet oam link-monitor supported
            leaf supported {
              tailf:info "Support link monitoring on the interface";
              tailf:cli-boolean-no;
              tailf:cli-full-command;
              type boolean;
              default true;
            }

            // interface * / no ethernet oam link-monitor on
            leaf on {
              tailf:info "Enable link monitoring on the interface";
              tailf:cli-boolean-no;
              tailf:cli-full-command;
              type boolean;
              default true;
            }

            // interface * / ethernet oam link-monitor receive-crc
            container receive-crc {
              tailf:info "Received frames with CRC errors in a period";

              // interface * / ethernet oam link-monitor receive-crc window
              leaf window {
                tailf:info "Window size of a polling period";
                type uint16 {
                  tailf:info "<10-1800>;;Set window size in multiple of 100 milliseconds (will be rounded off to second)";
                  range "10..1800";
                }
              }
            }
          }
        }
      }

      // interface * / ethernet oam
      leaf oam {
        tailf:info "Operations, Administration and Maintenance";
        type empty;
      }

      // interface * / ethernet dot1ad
      container dot1ad {
        tailf:info "dot1ad port";
        choice dot1ad-choice {

          // interface * / ethernet dot1ad nni
          leaf nni {
            tailf:info "dot1ad nni port";
            type empty;
          }

          // interface * / ethernet dot1ad uni
          container uni {
            tailf:info "dot1ad uni";
            choice uni-choice {
              container c-port {
                tailf:info "dot1ad uni customer bridge port";
                tailf:cli-delete-when-empty;
                presence true;
                leaf isolate {
                  tailf:info "split horizon";
                  type empty;
                }
              }
              container s-port {
                tailf:info "dot1ad uni s bridge port";
                tailf:cli-delete-when-empty;
                presence true;
                leaf isolate {
                  tailf:info "split horizon";
                  type empty;
                }
              }
            }
          }
        }
      }

      // interface * / ethernet cfm
      container cfm {
        tailf:info "Ethernet CFM interface commands";

        // interface * / ethernet cfm mip level *
        container mip {
          tailf:info "Maintenance Intermediate Point";
          list level {
            tailf:info "Maintenance Level";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key level;
            leaf level {
              type uint8 {
                tailf:info "<0-7>;;maintenance level number";
                range "0..7";
              }
            }
            leaf-list vlan {
              tailf:info "Specify vlan (range 1-4094)";
              tailf:cli-range-list-syntax;
              type uint16 {
                tailf:info "<1-4094>;;VLAN id";
                range "1..4094";
              }
            }
          }
        }

        // interface * / ethernet cfm mep
        container mep {
          tailf:info "Maintenance End Point";

          // interface * / ethernet cfm mep domain * mpid ? port
          list mep-list {
            tailf:cli-drop-node-name;
            tailf:cli-mode-name "config-if-ecfm-mep";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            tailf:cli-remove-before-change;
            key domain;
            leaf domain {
              tailf:info "maintenance domain";
              tailf:cli-expose-key-name;
              tailf:non-strict-leafref {
                path "/ios:ethernet/cfm/domain/name";
              }
              type string {
                tailf:info "WORD;;maintenance domain name";
              }
            }
            leaf mpid {
              tailf:info "Maintenance End Point Identifier";
              tailf:cli-hide-in-submode;
              tailf:cli-incomplete-command;
              type uint16 {
                tailf:info "<1-8191>;;Maintenance End Point Identifier";
                range "1..8191";
              }
            }
            leaf port {
              tailf:info "DOWN service direction with no vlan association";
              tailf:cli-hide-in-submode;
              type empty;
            }
          }

          // interface * / ethernet cfm mep domain * mpid ? vlan *
          list mep-list-vlan {
            tailf:cli-drop-node-name;
            tailf:cli-mode-name "config-if-ecfm-mep";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            tailf:cli-remove-before-change;
            key "domain vlan";
            leaf domain {
              tailf:info "maintenance domain";
              tailf:cli-expose-key-name;
              tailf:non-strict-leafref {
                path "/ios:ethernet/cfm/domain/name";
              }
              type string {
                tailf:info "WORD;;maintenance domain name";
              }
            }
            leaf mpid {
              tailf:info "Maintenance End Point Identifier";
              tailf:cli-prefix-key {
                tailf:cli-before-key 2;
              }
              type uint16 {
                tailf:info "<1-8191>;;Maintenance End Point Identifier";
                range "1..8191";
              }
            }
            leaf vlan {
              tailf:info "Specify vlan (range 1-4094)";
              tailf:cli-expose-key-name;
              tailf:non-strict-leafref {
                path "/ios:ethernet/cfm/domain/service/vlan";
              }
              type uint16 {
                tailf:info "<1-4094>;;VLAN id";
                range "1..4094";
              }
            }
          }

          // interface * / ethernet cfm mep domain * mpid ? service *
          list mep-list-service {
            tailf:cli-drop-node-name;
            tailf:cli-mode-name "config-if-ecfm-mep";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            tailf:cli-remove-before-change;
            key "domain service";
            leaf domain {
              tailf:info "maintenance domain";
              tailf:cli-expose-key-name;
              tailf:non-strict-leafref {
                path "/ios:ethernet/cfm/domain/name";
              }
              type string {
                tailf:info "WORD;;maintenance domain name";
              }
            }
            leaf mpid {
              tailf:info "Maintenance End Point Identifier";
              tailf:cli-prefix-key {
                tailf:cli-before-key 2;
              }
              type uint16 {
                tailf:info "<1-8191>;;Maintenance End Point Identifier";
                range "1..8191";
              }
            }
            leaf service {
              tailf:info "Maintenance Association within Domain";
              tailf:cli-expose-key-name;
              tailf:non-strict-leafref {
                path "/ios:ethernet/cfm/domain/service/csi-id";
              }
              type string {
                tailf:info "WORD;;service instance id - short MA name";
              }
            }
          }
        }

        // interface * / no ethernet cfm enable
        leaf enable {
          tailf:info "CFM interface enabling";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }

        // interface * / ethernet cfm interface
        // interface * / no ethernet cfm interface
        leaf interface {
          tailf:info "CFM interface enable";
          tailf:cli-boolean-no;
          type boolean;
        }
      }

      // interface * / ethernet uni
      container uni {
        tailf:info "Configure Ether UNI";

        // interface * / ethernet uni id
        leaf id {
          tailf:info "Configure Ether UNI ID";
          type string {
            tailf:info "WORD;;UNI ID of length <1-64>";
            length "0..64";
          }
        }

        // interface * / ethernet uni bundle
        container bundle {
          tailf:info "bundling service without multiplexing";
          tailf:cli-delete-when-empty;
          presence true;
          leaf all-to-one {
            tailf:info "all-to-one bundling service";
            type empty;
          }
        }
      }

      // interface * / ethernet lmi
      container lmi {
        tailf:info "Ethernet LMI interface commands";

        // interface * / ethernet lmi interface
        // interface * / no ethernet lmi interface
        // note: visibility depends on global "ethernet lmi global"
        leaf interface {
          tailf:info "Enable Ethernet LMI on this interface";
          tailf:cli-boolean-no;
          type boolean;
        }
      }

      // interface * / ethernet backup interface
      container backup {
        tailf:info "Set backup for the interface";
        leaf interface {
          tailf:info "Specify an interface as backup";
          tailf:cli-remove-before-change;
          type string {
            tailf:info "WORD;;Interface name";
          }
        }
      }

      // interface * / ethernet loopback
      container loopback {
        tailf:info "Configure a loopback on this interface";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        tailf:cli-delete-when-empty;
        presence true;
        leaf type {
          tailf:cli-drop-node-name;
          tailf:cli-remove-before-change;
          type enumeration {
            enum facility {
              tailf:info "Facility loopback";
            }
            enum terminal {
              tailf:info "Terminal loopback";
            }
          }
        }
        leaf vlan {
          tailf:info "Vlan";
          tailf:cli-break-sequence-commands;
          tailf:cli-remove-before-change;
          when "../type = 'facility'";
          type string {
            tailf:info "WORD;;Vlans to loopback";
          }
        }
        leaf mac-address {
          tailf:info "Configure mac address swap or copy";
          tailf:cli-break-sequence-commands;
          tailf:cli-incomplete-command;
          type enumeration {
            enum copy {
              tailf:info "Copy MAC DA and SA";
            }
            enum swap {
              tailf:info "Swap MAC DA and SA";
            }
          }
        }
        leaf timeout {
          tailf:info "Configure a timeout";
          type union {
            type enumeration {
              enum none {
                tailf:info "No timeout";
              }
            }
            type uint16 {
              tailf:info "<5-300>;;Timeout in seconds";
            }
          }
        }
        leaf supported {
          tailf:info "Loopback is supported";
          type empty;
        }
      }
    }

    // interface * / negotiation auto
    // interface * / no negotiation auto
    container negotiation {
      tailf:info "Select autonegotiation mode";
      leaf auto {
        tailf:info "Enable link autonegotiation";
        tailf:cli-boolean-no;
        type boolean;
      }
    }

    // interface * / synchronous
    container synchronous {
      tailf:info "Synchronous";
      leaf mode {
        tailf:info "Mode";
        type empty;
      }
    }

    // interface * / network-clock
    container network-clock {
      tailf:info "Network clock configuration commands";

      // interface * / network-clock wait-to-restore
      leaf wait-to-restore {
        tailf:info "Wait-to-Restore timer";
        type uint32 {
          tailf:info "<0-86400>;;sec (default 300 seconds)";
          range "0..86400";
        }
      }
    }

    // interface * / esmc mode
    container esmc {
      tailf:info "Ethernet Synchronization Messaging Channe";
      container mode {
        tailf:info "ESMC mode";

        // interface * / esmc mode rx
        // interface * / esmc mode tx
        leaf direction {
          tailf:cli-drop-node-name;
          tailf:cli-full-command;
          type enumeration {
            enum rx {
              tailf:info "ESMC receive-only mode";
            }
            enum tx {
              tailf:info "ESMC transmit-only mode";
            }
          }
        }

        // interface * / esmc mode ql-disabled
        leaf ql-disabled {
          tailf:info "QL disabled";
          type empty;
        }
      }
    }

    // interface * / enable
    // interface * / no enable
    leaf enable {
      tailf:info "enable qsfp traffic";
      tailf:cli-boolean-no;
      type boolean;
    }

    // interface * / speed
    leaf speed {
      tailf:info "Configure speed operation.";
      tailf:cli-no-value-on-delete;
      tailf:cli-full-command;
      tailf:cli-full-no;
      tailf:cli-diff-dependency "../media-type" {
        tailf:cli-trigger-on-set;
      }
      tailf:cli-diff-set-after "../speed-auto/speed/auto" {
        tailf:cli-when-target-delete;
      }
      ios:if-patch-speed;
      type enumeration {
        enum "10" {
          tailf:info "Force 10 Mbps operation";
        }
        enum "100" {
          tailf:info "Force 100 Mbps operation";
        }
        enum "1000" {
          tailf:info "Force 1000 Mbps operation";
        }
        enum "10000" {
          tailf:info "Force 10000 Mbps operation";
        }
        enum "auto" {
          tailf:info "Enable AUTO speed configuration";
        }
        enum "nonegotiate" {
          tailf:info "Do not negotiate speed";
        }
      }
      default auto;
    }

    // interface * / speed auto *
    container speed-auto {
      tailf:cli-drop-node-name;
      tailf:cli-diff-dependency "../media-type" {
        tailf:cli-trigger-on-set;
      }
      container speed {
        tailf:info "Configure speed operation.";
        leaf-list auto {
          tailf:info "Enable AUTO speed configuration";
          tailf:cli-replace-all;
          tailf:cli-flat-list-syntax;
          tailf:cli-incomplete-no;
          tailf:cli-diff-set-after "../../../speed" {
            tailf:cli-when-target-delete;
          }
          type enumeration {
            enum "10" {
              tailf:info "Include 10 Mbps in auto-negotiation advertisement";
            }
            enum "100" {
              tailf:info "Include 100 Mbps in auto-negotiation advertisement";
            }
            enum "1000" {
              tailf:info "Include 1000 Mbps in auto-negotiation advertisement";
            }
          }
        }
      }
    }

    // interface * / duplex
    leaf duplex {
      tailf:info "Configure duplex operation.";
      tailf:cli-no-value-on-delete;
      tailf:cli-full-command;
      tailf:cli-diff-dependency "../negotiation";
      tailf:cli-diff-dependency "../speed";
      cli:ned-diff-stay-after ">no shutdown";
      type enumeration {
        enum auto {
          tailf:code-name "duplex_auto";
          tailf:info "Enable AUTO duplex configuration";
        }
        enum full {
          tailf:code-name "duplex_full";
          tailf:info "Force full duplex operation";
        }
        enum half {
          tailf:code-name "duplex_half";
          tailf:info "Force half-duplex operation";
        }
      }
      default auto;
    }

    // interface * / half-duplex
    leaf half-duplex {
      type empty;
    }

    // interface * / full-duplex
    leaf full-duplex {
      type empty;
    }

    // interface * / xconnect
    uses xconnect-if-grouping;

    // interface * / member
    container member {
      tailf:info "Configure the Layer2 VPN member";

      // interface * / member vfi
      leaf vfi {
        tailf:info "Configure the Virtual Forwarding Instance (VFI) member";
        tailf:cli-remove-before-change;
        tailf:non-strict-leafref {
          path "/ios:l2vpn-vfi/l2vpn/vfi/context/name";
        }
        type string {
          tailf:info "WORD;;Enter VFI name (Max Size 31)";
        }
      }
    }

    // interface * / pppoe
    container pppoe {
      tailf:info "pppoe interface subcommands";

      // interface * / pppoe enable
      container enable {
        tailf:info "Enable pppoe";
        presence true;
        leaf group {
          tailf:info "attach a BBA group";
          type union {
            type string {
              tailf:info "WORD;;BBA Group name";
            }
            type enumeration {
              enum global {
                tailf:info "Attach global PPPoE group";
              }
            }
          }
        }
      }

      // interface * / pppoe max-sessions
      leaf max-sessions {
        tailf:info "Maximum PPPOE sessions";
        type uint16 {
          tailf:info "<1-4085>;;Maximum PPPOE sessions";
          range "1..4085";
        }
      }

      // interface * / pppoe intermediate-agent X
      container intermediate-agent {
        tailf:info "Intermediate Agent";
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;

        // interface * / pppoe intermediate-agent trust
        leaf trust {
          tailf:info "Trust Setting";
          type empty;
        }
      }

      // interface * / pppoe intermediate-agent
      container intermediate-agent-enable {
        tailf:cli-drop-node-name;
        leaf intermediate-agent {
          tailf:info "Intermediate Agent";
          type empty;
        }
      }
    }

    // interface * / pppoe-client
    uses pppoe-client-grouping;

    // interface * / vlan-id dot1q *
    container vlan-id {
      tailf:info "Process VLAN-encapsulated packets with a specific VLAN ID";
      list dot1q {
        tailf:info "802.1Q VLAN";
        tailf:cli-mode-name "config-if-vlan-id";
        tailf:cli-exit-command "exit-vlan-config" {
          tailf:info "Exit from VLAN configuration mode";
        }
        key id;
        leaf id {
          type uint16 {
            tailf:info "<1-4094>;;VLAN ID";
            range "1..4094";
          }
        }
      }
    }

    // interface * / secondary-admin-state
    leaf secondary-admin-state {
      type enumeration {
        enum auto-in-service;
        enum maintenance;
        enum normal;
        enum in-service;
      }
    }

    // interface * / attach profile
    container attach {
      tailf:info "Attach a profile to a port";
      leaf profile {
        tailf:info "Alarm profile name";
        tailf:non-strict-leafref {
          path "/ios:alarm-profile/entry-list/name";
        }
        type string {
          tailf:info "WORD;;Alarm profile name";
        }
      }
    }

    // interface * / service instance *
    container service {
      tailf:info "Configure Ether Service";
      tailf:cli-diff-after "../snmp";
      list instance {
        tailf:info "Configure Ether Service Instance";
        tailf:cli-mode-name "config-if-srv";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        ios:if-service-evc-deleted;
        key id;
        leaf id {
          // dep: before this created, must change below:
          tailf:cli-diff-dependency "../../../service-policy/output" {
            tailf:cli-trigger-on-set;
          }
          tailf:cli-diff-dependency "../../../service-policy/input" {
            tailf:cli-trigger-on-set;
          }
          tailf:cli-diff-dependency "../../../cdp/enable" {
            tailf:cli-trigger-on-set;
          }
          tailf:cli-diff-dependency "../../../ip/no-address/address" {
            tailf:cli-trigger-on-set;
          }
          tailf:cli-diff-delete-after "/ios:ethernet/ring/g8032/g8032-list/instance/inclusion-list" {
            tailf:cli-when-target-delete;
          }
          tailf:cli-diff-delete-after "/ios:ethernet/ring/g8032/g8032-list/exclusion-list" {
            tailf:cli-when-target-delete;
          }
          tailf:cli-diff-delete-after "/ios:l2vpn-xconnect/l2vpn/xconnect/context/member/member-list[service-instance=current()/../id]" {
            tailf:cli-when-target-delete; // WARNING: NSO bug with 5.2.5, fail to trigger [CISCOIOS-2201]
          }
          tailf:cli-diff-set-before "/ios:l2vpn-xconnect/l2vpn/xconnect/context/member/member-list[service-instance=current()/../id]";
          type uint32 {
            tailf:info "<1-4294967295>;;Service Instance Identifier";
            range "1..4294967295";
          }
        }
        leaf trunk {
          tailf:cli-optional-in-sequence;
          tailf:cli-prefix-key;
          type empty;
        }
        leaf ethernet {
          tailf:info "Configure an Ethernet Instance";
          tailf:cli-hide-in-submode;
          type empty;
        }
        leaf ethernet-evc-name {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          tailf:non-strict-leafref {
            path "/ios:ethernet/evc/name";
          }
          type string {
            tailf:info "WORD;;Attach an EVC to the service instance";
          }
        }

        // interface * / service instance * / description
        leaf description {
          tailf:cli-break-sequence-commands;
          tailf:info "Service instance specific description";
          tailf:cli-multi-value;
          tailf:cli-preformatted;
          tailf:cli-full-command;
          type string {
            tailf:info "LINE;;Up to 240 characters describing this service instance";
            length "0..240";
          }
        }

        // interface * / service instance * / encapsulation
        container encapsulation {
          tailf:info "Configure ethernet frame match criteria";
          choice encapsulation-choice {

            // interface * / service instance * / encapsulation dot1q
            container dot1q {
              tailf:info "IEEE 802.1Q Virtual LAN or S-VLAN";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              // dep: before this created, must change below:
              tailf:cli-diff-dependency "../untagged" {
                tailf:cli-trigger-on-set;
              }
              uses if-srv-encapsulation-dot1q-grouping;
            }

            // interface * / service instance * / encapsulation dot1ad
            container dot1ad {
              tailf:info "IEEE 802.1ad VLAN-tagged packets";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf-list id {
                tailf:cli-drop-node-name;
                tailf:cli-replace-all;
                tailf:cli-range-list-syntax;
                type uint16 {
                  tailf:info "<1-4094>;;VLAN id";
                  range "1..4094";
                }
              }

              leaf-list dot1q {
                tailf:info "IEEE 802.1Q VLAN-tagged packets";
                tailf:cli-range-list-syntax;
                tailf:cli-replace-all;
                type uint16 {
                  tailf:info "<1-4094>;;Single VLAN id";
                  range "1..4094";
                }
              }
            }

            // interface * / service instance * / encapsulation untagged
            container untagged {
              tailf:info "Untagged encapsulation";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              tailf:cli-delete-when-empty;
              // dep: before this created, must change below:
              tailf:cli-diff-dependency "../dot1q" {
                tailf:cli-trigger-on-set;
              }
              presence true;
              leaf comma {
                tailf:info "comma";
                tailf:alt-name ",";
                type empty;
              }
              container dot1q {
                tailf:info "IEEE 802.1Q Virtual LAN or S-VLAN";
                tailf:cli-flatten-container;
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                uses if-srv-encapsulation-dot1q-grouping;
              }
            }

            // interface * / service instance * / encapsulation default
            container default {
              tailf:info "catch-all unconfigured encapsulation";
              presence true;
            }
          }
        }

        // interface * / service instance * / rewrite ingress tag
        container rewrite {
          tailf:info "Configure ethernet rewrite criteria";
          container ingress {
            tailf:info "Ingress Rewrite";
            container tag {
              tailf:info "Configure Rewrite Tag";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              tailf:cli-diff-dependency "../../../encapsulation";
              tailf:cli-diff-delete-before "../../../encapsulation" {
                tailf:cli-when-target-modify;
              }
              choice tag-choice {

                // interface * / service instance * / rewrite ingress tag pop
                leaf pop {
                  tailf:info "Pop the tag";
                  type enumeration {
                    enum "1" {
                      tailf:info "Pop the outermost tag";
                    }
                    enum "2" {
                      tailf:info "Pop two outermost tags";
                    }
                  }
                }

                // interface * / service instance * / rewrite ingress tag push
                case push {
                  leaf push {
                    tailf:info "Rewrite Operation of push";
                    type enumeration {
                      enum dot1ad {
                                   tailf:info "Push dot1ad tag";
                      }
                      enum dot1q {
                                  tailf:info "Push dot1q tag";
                      }
                    }
                  }
                  leaf vlan-id {
                    tailf:cli-drop-node-name;
                    type uint16 {
                      tailf:info "<1-4094>;;VLAN id";
                      range "1..4094";
                    }
                  }
                }

                // interface * / service instance * / rewrite ingress tag translate
                case translate {
                  leaf translate {
                    tailf:info "Translate Tag";
                    tailf:cli-incomplete-command;
                    type enumeration {
                      enum "1-to-1" {
                        tailf:info "Translate 1-to-1";
                      }
                      enum "1-to-2" {
                        tailf:info "Translate 1-to-2";
                      }
                      enum "2-to-1" {
                        tailf:info "Translate 2-to-1";
                      }
                      enum "2-to-2" {
                        tailf:info "Translate 2-to-2";
                      }
                    }
                  }
                  leaf dot1ad {
                    tailf:info "Ethertype dot1ad of the translation";
                    tailf:cli-optional-in-sequence;
                    type uint16 {
                      tailf:info "<1-4094>;;VLAN id";
                      range "1..4094";
                    }
                  }
                  leaf dot1q {
                    tailf:info "Ethertype dot1q of the translation";
                    type uint16 {
                      tailf:info "<1-4094>;;VLAN id";
                      range "1..4094";
                    }
                  }
                  leaf second-dot1q {
                    tailf:info "Second dot1q tag";
                    tailf:cli-optional-in-sequence;
                    type uint16 {
                      tailf:info "<1-4094>;;VLAN id";
                      range "1..4094";
                    }
                  }
                  leaf vlan-type {
                    tailf:info "Vlan protocol type";
                    tailf:cli-optional-in-sequence;
                    type enumeration {
                      enum "0x88A8" {
                        tailf:info "vlan protocol type 0x88A8";
                      }
                      enum "0x9100" {
                        tailf:info "vlan protocol type 0x9100";
                      }
                      enum "0x9200" {
                        tailf:info "vlan protocol type 0x9200";
                      }
                    }
                  }
                }
              }
              leaf mode {
                tailf:cli-drop-node-name;
                type enumeration {
                  enum symmetric {
                                  tailf:info "Tag egress packets as specified in encapsulation";
                  }
                }
              }
            }
          }
        }

        // interface * / service instance * / storm-control
        container storm-control {
          tailf:info "storm configuration";

          // interface * / service instance * / storm-control unicast cir
          container unicast {
            tailf:info "Unknown unicast address storm control";
            leaf cir {
              tailf:info "Committed Information Rate";
              type string {
                tailf:info "<8000-1000000000>;;Target Bit Rate (biTs per second)";
              }
            }
          }

          // interface * / service instance * / storm-control broadcast cir
          container broadcast {
            tailf:info "Broadcast address storm control";
            leaf cir {
              tailf:info "Committed Information Rate";
              type string {
                tailf:info "<8000-1000000000>;;Target Bit Rate (biTs per second)";
              }
            }
          }

          // interface * / service instance * / storm-control multicast cir
          container multicast {
            tailf:info "Multicast address storm control";
            leaf cir {
              tailf:info "Committed Information Rate";
              type string {
                tailf:info "<8000-1000000000>;;Target Bit Rate (biTs per second)";
              }
            }
          }
        }

        // interface * / service instance * / ip
        container ip {
          tailf:info "Interface Internet Protocol config commands";

          // interface * / service instance * / ip access-group ? in
          // interface * / service instance * / ip access-group ? out
          list access-group {
            tailf:info "Specify access control for packets";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            key direction;
            leaf direction {
              type enumeration {
                enum in {
                  tailf:code-name "access_group_direction_in";
                  tailf:info "inbound packets";
                }
                enum out {
                  tailf:code-name "access_group_direction_out";
                  tailf:info "outbound packets";
                }
              }
            }
            leaf access-list {
              tailf:cli-drop-node-name;
              tailf:cli-prefix-key;
              tailf:cli-diff-dependency "/ios:ip/access-list";
              type exp-ip-acl-type;
            }
          }
        }

        // interface * / service instance * / group
        leaf group {
          tailf:info "Join a service group";
          tailf:cli-full-command;
          tailf:cli-diff-dependency "/ios:service-group";
          type uint16 {
            tailf:info "<1-65532>;;Service group ID number";
            range "1..65532";
          }
        }

        // interface * / service instance * / errdisable
        container errdisable {
          tailf:info "Configure error disable";
          container recovery {
            tailf:info "enable auto recovery";
            container cause {
              tailf:info "error disable cause";
              leaf mac-security {
                tailf:info "mac-security violation";
                type uint32 {
                  tailf:info "<30-86400>;;timer interval(sec)";
                  range "30..86400";
                }
              }
            }
          }
        }

        // interface * / service instance * / snmp
        container snmp {
          tailf:info "Modify SNMP service instance parameters";
          container trap {
            tailf:info "Allow a specific SNMP trap";
            leaf link-status {
              tailf:info "Allow SNMP LINKUP and LINKDOWN traps";
              type empty;
            }
          }
          container ifindex {
            tailf:info "Persist ifindex for the service instance";
            leaf persist {
              tailf:info "Enable/Disable ifIndex persistence";
              type empty;
            }
          }
        }

        // interface * / service instance * / shutdown
        leaf shutdown {
          tailf:info "Take the Service Instance out of Service";
          type empty;
        }

        // interface * / service instance * / mac
        container mac {
          tailf:info "Commands for MAC Address-based features";

          // interface * / service instance * / mac security
          container security {
            tailf:info "MAC Security commands";
            tailf:cli-display-separated;
            tailf:cli-delete-when-empty;
            tailf:cli-diff-dependency "../../bridge-domain";
            presence true;

            // interface * / service instance * / mac security address *
            list address {
              tailf:info "MAC Address";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key "operation mac-address";
              leaf operation {
                type enumeration {
                  enum deny {
                    tailf:info "Specify an address that must not be learnt";
                  }
                  enum permit {
                    tailf:info "Specify an address to statically configure in the MAC table";
                  }
                }
              }
              leaf mac-address {
                type string {
                  tailf:info "H.H.H;;Specify the 48-bit MAC Address to deny/permit";
                }
              }
            }

            // interface * / service instance * / mac security maximum
            container maximum {
              tailf:info "Configure an upper bound";
              leaf addresses {
                tailf:info "Maximum addresses that can be learnt on this service instance";
                type uint16 {
                  tailf:info "<1-1000>;;Address count";
                  range "1..1000";
                }
              }
            }

            // interface * / service instance * / mac security aging
            container aging {
              tailf:info "Specify aging controls for secured MAC addresses";

              // interface * / service instance * / mac security aging time
              container time {
                tailf:info "Configure aging time";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                leaf value {
                  tailf:cli-drop-node-name;
                  type uint16 {
                    tailf:info "<0-1440>;;Duration (in minutes) after which secured MAC addresses will be aged out";
                    range "0..1440";
                  }
                }
                leaf inactivity {
                  tailf:info "Calculate address age from time of last frame (not first frame)";
                  type empty;
                }
              }

              // interface * / service instance * / mac security aging static
              leaf static {
                tailf:info "Apply aging controls to statically configured addresses also";
                type empty;
              }

              // interface * / service instance * / mac security aging sticky
              leaf sticky {
                tailf:info "Apply aging controls to persistent (\"sticky\") addresses also";
                type empty;
              }
            }

            // interface * / service instance * / mac security violation
            leaf violation {
              tailf:info "Configure the response when a MAC security policy is violated";
              tailf:cli-full-command;
              type enumeration {
                enum protect {
                  tailf:info "Protect mode - don't report violations, drop violating frames";
                }
                enum restrict {
                  tailf:info "Restrict mode - report violations, drop violating frames";
                }
              }
            }

            // interface * / service instance * / mac security sticky
            container sticky {
              tailf:info "Make dynamically learnt MAC addresses persistent";
              tailf:cli-display-separated;
              presence true;

              // interface * / service instance * / mac security sticky address *
              list address {
                tailf:info "(This command is not intended to be explicitly configured)";
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                max-elements 1;
                key mac-addr;
                leaf mac-addr {
                  type string {
                    tailf:info "H.H.H;;(This command is not intended to be explicitly configured)";
                  }
                }
              }
            }
          }

          // interface * / service instance * / mac static
          container static {
            tailf:info "static MAC address";
            // interface * / service instance * / mac static address *
            list address {
              tailf:info "MAC Address";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key mac-addr;
              leaf mac-addr {
                type string {
                  tailf:info "H.H.H;;Specify the 48-bit Static MAC Address";
                }
              }
            }
          }

          // interface * / service instance * / mac access-group *
          list access-group {
            tailf:info "Specify access control for packets";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            key direction;
            leaf direction {
              type enumeration {
                enum in {
                  tailf:info "Apply to Ingress";
                }
                enum out {
                  tailf:info "Apply to Egress";
                }
              }
            }
            leaf access-list {
              tailf:cli-drop-node-name;
              tailf:cli-prefix-key;
              type string {
                tailf:info "WORD;;ACL name";
              }
            }
          }
        }

        // interface * / service instance * / l2protocol *
        container l2protocol {
          tailf:info "Configure l2 control protocol processing";
          choice l2protocol-choice {
            leaf discard {
              tailf:info "discard L2 control protocol packets as data";
              tailf:cli-full-command;
              type empty;
            }
            leaf peer {
              tailf:info "peer L2 control protocol packets as data";
              tailf:cli-full-command;
              type empty;
            }
            leaf forward {
              tailf:info "forward L2 control protocol packets as data";
              tailf:cli-full-command;
              type empty;
            }
            leaf tunnel {
              tailf:info "tunnel L2 control protocol packets as data";
              tailf:cli-full-command;
              type empty;
            }
            list protocols {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              key protocol;
              leaf protocol {
                type l2protocol-type;
              }
              leaf option {
                tailf:cli-drop-node-name;
                tailf:cli-prefix-key;
                type enumeration {
                  enum discard {
                                tailf:info "discard L2 control protocol packets as data";
                  }
                  enum peer {
                             tailf:info "peer L2 control protocol packets as data";
                  }
                  enum forward {
                                tailf:info "forward L2 control protocol packets as data";
                  }
                  enum tunnel {
                               tailf:info "tunnel L2 control protocol packets as data";
                  }
                }
              }
            }
          }
        }

        // interface * / service instance * / bridge-domain
        container bridge-domain {
          tailf:info "Bridge-domain";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-diff-dependency "../encapsulation";
          leaf from-encapsulation {
            tailf:info "Derive bridge domains from encapsulation vlan list,";
            tailf:cli-optional-in-sequence;
            tailf:cli-full-command;
            type empty;
          }
          leaf bridge-id {
            tailf:cli-drop-node-name;
            tailf:cli-diff-dependency "/ios:vlan/vlan-list";
            tailf:cli-diff-dependency "/ios:bridge-domain/bridge-domain-list";
            type uint16 {
              tailf:info "<1-16384>;;Bridge-domain number";
              range "1..16384";
            }
          }
          leaf split-horizon {
            tailf:info "Configure this port as a member of a split horizon group";
            type empty;
          }
          leaf group {
            tailf:info "Split-horizon group";
            type uint8 {
              tailf:info "<0-2>;;Split-horizon group number. Default 0";
              range "0..2";
            }
            default 0;
          }
        }

        // interface * / service instance * / service-policy
        container service-policy {
          tailf:info "Attach a policy-map to an EFP";
          tailf:cli-diff-dependency "/ios:policy-map";
          list input {
            tailf:info "service policy input";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            max-elements 1;
            key name;
            leaf name {
              tailf:non-strict-leafref {
                path "/ios:policy-map/name";
              }
              type string {
                tailf:info "WORD;;input Policy-map name";
              }
            }
          }
          list output {
            tailf:info "service policy output";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            max-elements 1;
            key name;
            leaf name {
              tailf:non-strict-leafref {
                path "/ios:policy-map/name";
              }
              type string {
                tailf:info "WORD;;output Policy-map name";
              }
            }
          }
        }

        // interface * / service instance * / xconnect
        container xconnect {
          tailf:cli-add-mode;
          tailf:cli-mode-name "cfg-if-ether-vc-xconn";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          tailf:cli-diff-dependency "../encapsulation";
          tailf:cli-diff-delete-before "../bridge-domain";
          tailf:cli-diff-delete-before "/ios:l2/vfi/neighbor-vfi/neighbor";
          presence true;
          leaf address {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            tailf:cli-hide-in-submode;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP address of peer";
            }
          }
          leaf vcid {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            tailf:cli-hide-in-submode;
            type uint32 {
              tailf:info "<1-4294967295>;;Enter VC ID value";
              range "1..4294967295";
            }
          }
          leaf encapsulation {
            tailf:info "Data encapsulation method";
            tailf:cli-hide-in-submode;
            tailf:cli-optional-in-sequence;
            tailf:cli-remove-before-change;
            type enumeration {
              enum mpls {
                tailf:info "Use MPLS encapsulation";
              }
              enum l2tpv3 {
                tailf:info "Use L2TPv3 encapsulation";
              }
            }
          }
          leaf manual {
            tailf:info "Manually configure session parameters";
            tailf:cli-optional-in-sequence;
            tailf:cli-hide-in-submode;
            type empty;
          }
          leaf pw-class {
            tailf:info "Optional pseudowire-class to use for advanced configuration";
            tailf:cli-optional-in-sequence;
            tailf:cli-hide-in-submode;
            tailf:non-strict-leafref {
              path "/ios:pseudowire-class/name";
            }
            type string {
              tailf:info "WORD;;Pseudowire-class name";
            }
          }
          leaf sequencing {
            when "../encapsulation = 'l2tpv3'" {
              tailf:dependency "../encapsulation";
            }
            tailf:info "Configure sequencing options for xconnect";
            tailf:cli-full-command;
            tailf:cli-hide-in-submode;
            type enumeration {
              enum both {
                tailf:info "Transmit and receive sequence numbers";
              }
              enum receive {
                tailf:info "Receive sequence numbers";
              }
              enum transmit {
                tailf:info "Transmit sequence numbers";
              }
            }
          }
          leaf circuit-type {
            tailf:info "Configure the circuit type";
            tailf:cli-optional-in-sequence;
            tailf:cli-hide-in-submode;
            type enumeration {
              enum ethernet {
                tailf:info "Ethernet";
              }
            }
          }

          // interface * / service instance * / xconnect / backup
          container backup {
            tailf:cli-break-sequence-commands;
            tailf:info "Xconnect backup configuration commands";

            // interface * / service instance * / xconnect / backup peer
            container peer {
              tailf:info "Backup pseudowire";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf peer-router-ip-addr {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                tailf:cli-diff-delete-before "../../../address";
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IP address of peer";
                }
              }
              leaf vcid {
                tailf:cli-drop-node-name;
                tailf:cli-remove-before-change;
                type uint32 {
                  tailf:info "<1-4294967295>;;Enter VC ID value";
                  range "1..4294967295";
                }
              }
              leaf pw-class {
                tailf:cli-optional-in-sequence;
                tailf:non-strict-leafref {
                  path "/ios:pseudowire-class/name";
                }
                type string {
                  tailf:info "Optional Pseudowire-class to use for backup pseudowire";
                }
              }
              leaf priority {
                tailf:info "Optional priority to use for backup pseudowire.";
                type uint8 {
                  tailf:info "Peer priority";
                  range "1..10";
                }
              }
            }

            // interface * / service instance * / xconnect / backup delay
            container delay {
              tailf:info "Backup delay";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              leaf enable-delay {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type uint8 {
                  tailf:info "<0-180>;;Enable delay";
                  range "0..180";
                }
                default 0;
              }
              leaf disable-delay {
                tailf:cli-drop-node-name;
                type union {
                  type uint8 {
                    tailf:info "<0-180>;;Disable delay";
                    range "0..180";
                  }
                  type enumeration {
                    enum never {
                      tailf:info "Disallow disable";
                    }
                  }
                }
                default 0;
              }
            }
          }

          // interface * / service instance * / xconnect / mpls
          container mpls {
            tailf:info "MPLS manual configuration commands";

            // interface * / service instance * / xconnect / mpls label
            container label {
              tailf:info "MPLS local and remote pseudowire labels";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              leaf local {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type uint32 {
                  tailf:info "NUM;;Local pseudowire label";
                }
              }
              leaf remote {
                tailf:cli-drop-node-name;
                type uint32 {
                  tailf:info "NUM;;Remote pseudowire label";
                }
              }
            }

            // interface * / service instance * / xconnect / mpls control-word
            leaf control-word {
              tailf:info "Include control-word in pseudowire packets";
              tailf:cli-show-no;
              type empty;
            }
          }

          // interface * / service instance * / xconnect / mtu
          leaf mtu {
            tailf:info "set XCONNECT Maximum Transfer Unit";
            tailf:cli-full-command;
            tailf:cli-diff-set-after "../../../../mtu";
            tailf:cli-diff-dependency "../../../../mtu";
            type uint16 {
              tailf:info "<64-9216>;;per Xconnect MTU size in bytes";
              range "64..9216";
            }
          }

          // interface * / service instance * / xconnect / no remote link failure notification
          container remote {
            tailf:info "Xconnect remote peer configuration commands";
            container link {
              tailf:info "Link information";
              container failure {
                tailf:info "Failure information";
                leaf notification {
                  tailf:info "Notify in case of remote link failure";
                  tailf:cli-boolean-no;
                  type boolean;
                  default true;
                }
              }
            }
          }
        }

        // interface * / service instance * / cfm
        container cfm {
          tailf:info "Ethernet CFM EFP subcommands";

          // interface * / service instance * / cfm mip level
          container mip {
            tailf:info "Maintenance Intermediate Point";
            leaf level {
              tailf:info "Maintenance Level";
              type uint8 {
                tailf:info "<0-7>;;maintenance level number";
                range "0..7";
              }
            }
          }

          // interface * / service instance * / cfm mep
          container mep {
            tailf:info "Maintenance End Point";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-if-srv-ecfm-mep";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            presence true;
            leaf domain {
              tailf:info "Configure a domain for this mep";
              tailf:cli-hide-in-submode;
              tailf:cli-incomplete-command;
              tailf:non-strict-leafref {
                path "/ios:ethernet/cfm/domain/name";
              }
              tailf:cli-diff-dependency "/ios:ethernet/cfm/domain/service";
              ios:config-lock "  cfm mep domain (\\S+) mpid \\d+ :: \nethernet cfm domain $1 level <S>\n no service <S> evc =EVC\n" {
                cli:arguments "=EVC :: service instance .+ ethernet (\\S+)";
              }
              type string {
                tailf:info "WORD;;maintenance domain name";
              }
            }
            leaf mpid {
              tailf:info "Maintenance End Point Identifier";
              tailf:cli-hide-in-submode;
              type uint16 {
                tailf:info "<1-8191>;;Maintenance End Point Identifier";
                range "1..8191";
              }
            }

            // interface * / service instance * / cfm mep / continuity-check
            container continuity-check {
              tailf:info "Enable Continuity Check for this local MEP";
              tailf:cli-break-sequence-commands;

              // interface * / service instance * / cfm mep / continuity-check static rmep
              container static {
                tailf:info "Verify MEP in received CCM is valid";
                leaf rmep {
                  tailf:info "MEP defined using rmep mpid";
                  type empty;
                }
              }
            }

            // interface * / service instance * / cfm mep / rmep mpid
            container rmep {
              tailf:info "Static Remote MEP associated with this DOWN MEP";
              leaf mpid {
                tailf:info "Maintenance End Point Identifier";
                type uint16 {
                  tailf:info "<1-8191>;;Identifier value";
                  range "1..8191";
                }
              }
            }

            // interface * / service instance * / cfm mep / cos
            leaf cos {
              tailf:info "Specify Class of Service sent in CFM mssages for EFP MEP";
              type uint8 {
                tailf:info "<0-7>;;CoS value";
                range "0..7";
              }
            }

            // interface * / service instance * / cfm mep / alarm
            container alarm {
              tailf:info "Controls Alarms for MEP, overrides global";

              // interface * / service instance * / cfm mep / alarm notification
              leaf notification {
                tailf:info "Ethernet CFM alarm notification";
                type enumeration {
                  enum none {
                             tailf:info "No defects to be reported";
                  }
                  enum xcon {
                             tailf:info "Report only: DefXcon";
                  }
                  enum error-xcon {
                    tailf:info "Report only: DefError and DefXcon";
                  }
                  enum remote-error-xcon {
                    tailf:info "Report only: DefRemote, DefError and DefXcon";
                  }
                  enum mac-remote-error-xcon {
                    tailf:info "Report only: DefMACStatus, DefRemote, DefError and DefXcon (default)";
                  }
                  enum all {
                            tailf:info "Report all defects: DefRDI, DefMACStatus, DefRemote, DefError, DefXcon";
                  }
                }
                default mac-remote-error-xcon;
              }
            }
          }
        }

        // interface * / service instance * / ethernet
        container ethernet-if-srv {
          tailf:cli-drop-node-name;
          container ethernet {
            tailf:info "ethernet";

            // interface * / service instance * / ethernet lmi
            container lmi {
              tailf:info "Configure ether lmi parameters";
              container ce-vlan {
                tailf:info "Configure ether lmi customer vlans";
                leaf-list map {
                  tailf:info "Configure ether lmi ce-vlan/evc map";
                  tailf:cli-replace-all;
                  tailf:cli-range-list-syntax;
                  type union {
                    type uint16 {
                      tailf:info "<1-4094>;;VLAN id";
                      range "1..4094";
                    }
                    type enumeration {
                      enum "default" {
                        tailf:info "Default EFP";
                      }
                      enum untagged {
                                     tailf:info "Untagged frames";
                      }
                    }
                  }
                }
              }
            }

            // interface * / service instance * / ethernet loopback
            container loopback {
              tailf:info "Ethernet Dataplane Loopback";
              container permit {
                tailf:info "Allow data plane loopback to be activated";
                leaf external {
                  tailf:info "Allow to loopback the traffic from the wire";
                  type empty;
                }
                leaf internal {
                  tailf:info "Allow to loopback the traffic from the relay";
                  type empty;
                }
              }
            }
          }
        }
      }
    }

    // interface * / cts
    container cts {
      tailf:info "Configure Cisco Trusted Security";

      // interface * / cts manual
      container manual {
        tailf:info "Supply local configuration for CTS parameters";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-if-cts-manual";
        presence true;

        // interface * / cts manual / policy static sgt
        container policy {
          tailf:info "CTS policy for manual mode";
          container static {
            tailf:info "Configure policy to be applied on the link";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf sgt {
              tailf:info "Source Security Group Tag to apply to untagged or non-trusted incoming traffic";
              type uint16 {
                tailf:info "<2-65519>;;Source Group Tag (SGT)";
                range "2..65519";
              }
            }
            leaf trusted {
              tailf:info "Trust the Source Group Tags (SGT) that the peer uses for sending";
              type empty;
            }
          }
        }

        // interface * / cts manual / no propagate sgt
        container propagate {
          tailf:info "CTS SGT Propagation configuration for manual mode";
          leaf sgt {
            tailf:info "CTS SGT Propagation configuration";
            tailf:cli-boolean-no;
            type boolean;
            default true;
          }
        }
      }
    }

    // interface * / channel-group
    container channel-group {
      tailf:info "Add this interface to an Etherchannel group";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf number {
        tailf:cli-drop-node-name;
        // dep: must delete channel-group before this:
        tailf:cli-diff-delete-before "/ios:interface/Port-channel[not(contains(current()/../../name, '.')) and  name=current()/../number]";
        tailf:cli-diff-dependency "/ios:interface/Port-channel[name=current()/../number]";
        tailf:cli-diff-dependency "/ios:interface/Port-channel[name=current()/../number]/service/instance";
        //tailf:cli-diff-dependency "../../mls/qos/trust";
        //tailf:cli-diff-dependency "../../port-type";
        cli:ned-diff-move-first {
          cli:arguments "when-delete";
        }
        cli:ned-diff-move-last {
          cli:arguments "when-set";
        }
        /* dep: before this created, must show changes to below:
        tailf:cli-diff-dependency "../../mls" {
          tailf:cli-trigger-on-set;
        }
        tailf:cli-diff-dependency "../../ip" {
          tailf:cli-trigger-on-set;
        }
        tailf:cli-diff-dependency "../../ipv6" {
          tailf:cli-trigger-on-set;
        }
        tailf:cli-diff-dependency "../../service-policy" {
          tailf:cli-trigger-on-set;
        }
        tailf:cli-diff-dependency "../../mtu" {
          tailf:cli-trigger-on-set;
        }
        tailf:cli-diff-dependency "../../storm-control" {
          tailf:cli-trigger-on-set;
        }
        */
        type uint16 {
          tailf:info "<1-512>;;Channel group number";
          range "1..512";
        }
      }
      leaf mode {
        tailf:info "Etherchannel Mode of the interface";
        type enumeration {
          enum active {
             tailf:info "Enable LACP unconditionally";
          }
          enum auto {
             tailf:info "Enable PAgP only if a PAgP device is detected";
          }
          enum desirable {
             tailf:info "Enable PAgP unconditionally";
          }
          enum on {
             tailf:info "Enable Etherchannel only";
          }
          enum passive {
             tailf:info "Enable LACP only if a LACP device is detected";
          }
        }
      }
      leaf non-silent {
        tailf:info "Start negotiation only after data packets received";
        type empty;
      }
    }

    // interface * / soak link notification
    container soak {
      tailf:info "Soak hardware link notification";
      container link {
        tailf:info "link";
        leaf notification {
          tailf:info "notification";
          type uint16 {
            tailf:info "<0-300>;;duration";
            range "0..300";
          }
        }
      }
    }

    // interface * / mvr
    container mvr {
      tailf:info "MVR per port configuration";

      // interface * / mvr type
      leaf type {
        tailf:info "The type of this port";
        type enumeration {
          enum receiver {
                         tailf:info "An MVR receiver port";
          }
          enum source {
                       tailf:info "An MVR source port";
          }
        }
      }

      // interface * / mvr vlan *
      list vlan {
        tailf:info "One of the VLANs of the port";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-diff-dependency "../type";
        key id;
        leaf id {
          tailf:cli-suppress-range;
          type uint16 {
            tailf:info "<1-1001,1006-4094>;;MVR Multicast VLAN id";
            range "1..1001|1006..4094";
          }
        }

        // interface * / mvr vlan * receiver vlan *
        container receiver {
          tailf:info "Set MVR receiver property";
          list vlan {
            tailf:info "Set MVR receiver VLAN for trunk";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key id;
            leaf id {
              tailf:cli-suppress-range;
              type uint16 {
                tailf:info "<1-1001,1006-4094>;;MVR receiver|Multicast VLAN id";
                range "1..1001|1006..4094";
              }
            }
          }
        }

        // interface * / mvr vlan * group *
        list group {
          tailf:info "Set as static member of multicast group";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key address;
          leaf address {
            tailf:cli-suppress-range;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP address of multicast group";
            }
          }
          container receiver {
            tailf:info "Set MVR receiver property";
            list vlan {
              tailf:info "Set MVR receiver VLAN for trunk";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key id;
              leaf id {
                tailf:cli-suppress-range;
                type uint16 {
                  tailf:info "<1-1001,1006-4094>;;MVR receiver|Multicast VLAN id";
                  range "1..1001|1006..4094";
                }
              }
            }
          }
        }
      }
    }

    // interface * / mac-addr-filter
    container mac-addr-filter {
      presence true;
    }

  } // interface-ethernet-grouping


  grouping interface-ethernet-switch-grouping {
    uses interface-ethernet-grouping {
      refine "service/instance" {
        tailf:cli-diff-set-after "/ios:interface/GigabitEthernet/service/instance" {
          tailf:cli-when-target-delete;
        }
        tailf:cli-diff-set-after "/ios:interface/TenGigabitEthernet/service/instance" {
          tailf:cli-when-target-delete;
        }
        tailf:cli-diff-set-after "/ios:interface/Port-channel/service/instance" {
          tailf:cli-when-target-delete;
        }
      }
    }
  }

  // grouping interface-common-macsec-grouping
  grouping interface-common-macsec-grouping {
    uses interface-common-grouping {
      refine "mka" {
        cli:shutdown-before-edit "../channel-group/number,../channel-group/mode";
      }
      refine "macsec" {
        cli:shutdown-before-edit "../channel-group/number,../channel-group/mode";
      }
    }
  }

  // interface-ethernet-post-grouping
  grouping interface-ethernet-post-grouping {

    // interface * / fhrp delay
    container fhrp {
      tailf:info "Configure FHRP";
      container delay {
        tailf:info "Configure FHRP delay";

        // interface * / fhrp delay minimum
        leaf minimum {
          tailf:info "Minimum delay";
          type uint16 {
            tailf:info "<0-3600>;;Delay in seconds";
            range "0..3600";
          }
        }

        // interface * / fhrp delay reload
        leaf reload {
          tailf:info "Reload delay";
          type uint16 {
            tailf:info "<0-3600>;;Delay in seconds";
            range "0..3600";
          }
        }
      }
    }

    // interface * / vrrp delay
    container vrrp-conf {
      tailf:cli-drop-node-name;
      container vrrp {
        tailf:info "VRRP Interface configuration commands";
        tailf:cli-incomplete-no;
        container delay {
          tailf:info "VRRP initialisation delay";
          tailf:cli-compact-syntax;
          leaf minimum {
            tailf:info "Minimum delay";
            type uint16 {
              tailf:info "<0-10000>;;Seconds to delay after interface up";
              range "0..10000";
            }
          }
          leaf reload {
            tailf:info "Reload delay";
            type uint16 {
              tailf:info "<0-10000>;;Seconds to delay after reload";
              range "0..10000";
            }
          }
        }
      }
    }

    // interface * / vrrp *
    list vrrp {
      tailf:info "VRRP Interface configuration commands";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key id;
      leaf id {
        type uint8 {
          tailf:info "<1-255>;;Group number";
          range "1..255";
        }
      }

      // interface * / vrrp * authentication
      container authentication {
        tailf:info "Authentication";
        choice auth {
          leaf word {
            tailf:cli-drop-node-name;
            tailf:cli-disallow-value "md5|text";
            type string {
              tailf:info "WORD;;Plain text authentication string";
            }
          }
          container md5 {
            tailf:info "Use MD5 authentication";
            leaf key-chain {
              tailf:info "Set key chain";
              type string {
                tailf:info "WORD;;Name of key-chain";
              }
            }

            // interface * / vrrp * authentication md5 key-string
            container key-string {
              tailf:info "Set key string";
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              uses password-grouping {
                refine "secret" {
                  cli:secret " md5 key-string <SECRET>";
                }
              }
              leaf timeout {
                tailf:info "Set timeout";
                type uint16 {
                  tailf:info "<0-32767>;;Timeout until only accepting new key (seconds)";
                  range "0..32767";
                }
              }
            }
          }
          leaf text {
            tailf:info "Plain text authentication";
            type string {
              tailf:info "WORD;;Plain text authentication string (8 chars max)";
            }
          }
        }
      }

      uses interface-vrrp-grouping;

      // interface * / vrrp * ip
      container ip {
        tailf:info "Enable Virtual Router Redundancy Protocol (VRRP) for IP";
        leaf address {
          tailf:cli-drop-node-name;
          tailf:cli-full-command;
          tailf:cli-diff-delete-after "../secondary-address";
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;VRRP group IP address";
          }
        }
        list secondary-address {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          key address;
          leaf address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;VRRP group IP address";
            }
          }
          leaf secondary {
            tailf:info "Specify an additional VRRP address for this group";
            type empty;
          }
        }
      }
    }

    // interface * / vrrp * address-family ipv4
    // interface * / vrrp * address-family ipv6
    container vrrv3p-v3 {
      tailf:cli-diff-dependency "/ios:fhrp/version/vrrp";
      when "/ios:fhrp/version/vrrp = 'v3'";
      tailf:cli-drop-node-name;
      list vrrp {
        tailf:cli-mode-name "config-if-vrrp";
        tailf:cli-full-command;
        tailf:cli-exit-command "exit-vrrp" {
          tailf:info "Exit from VRRP group configuration mode";
        }
        key "id address-family";
        leaf id {
          type uint8 {
            tailf:info "<1-255>;;Group number";
            range "1..255";
          }
        }
        leaf address-family {
          tailf:cli-expose-key-name;
          tailf:info "Address family of the group";
          type enumeration {
            enum ipv4 {
              tailf:info "ipv4 Address family";
            }
            enum ipv6 {
              tailf:info "ipv6 Address family";
            }
          }
        }

        uses interface-vrrp-grouping;

        // interface * / vrrp * address-family / address
        container address {
          tailf:info "IPv4 address config";

          // interface * / vrrp * address-family / address ? primary
          list primary-list {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            max-elements 1;
            key address;
            leaf address {
              type union {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IP address";
                }
                type inet:ipv6-address {
                  tailf:info "X:X:X:X::X;;IPv6 address";
                }
              }
            }
            leaf primary {
              tailf:info "Primary Address";
              type empty;
            }
          }

          // interface * / vrrp * address-family / address * secondary
          list secondary-list {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key address;
            leaf address {
              type union {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IP address";
                }
                type ios:ipv6-prefix {
                  tailf:info "X:X:X:X::X/<0-128>;;IPv6 address and prefix";
                }
              }
            }
            leaf secondary {
              tailf:info "Secondary Address";
              type empty;
            }
          }
        }
      }
    }

    // interface * / vrrs
    container vrrs {
      tailf:info "VRRS Interface configuration commands";

      // interface * / vrrs pathway *
      list pathway {
        tailf:info "Configure a VRRS pathway";
        tailf:cli-mode-name "config-if-vrrs-pw";
        tailf:cli-exit-command "exit-vrrs-pw" {
        }
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of the VRRS tag to associate with pathway";
          }
        }

        // interface * / vrrs pathway * / description
        uses description-grouping;

        // interface * / vrrs pathway * / address *
        list address {
          tailf:info "IPv4/IPv6 Address configuration";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key address;
          leaf address {
            type union {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IP address";
              }
              type inet:ipv6-address {
                tailf:info "X:X:X:X::X;;IPv6 link-local address";
              }
              type ios:ipv6-prefix {
                tailf:info "X:X:X:X::X/<0-128>;;IPv6 address and prefix";
              }
            }
          }
        }
      }
    }
  } // interface-ethernet-post-grouping


  // interface-pointtopoint-grouping
  grouping interface-pointtopoint-grouping {

    // interface * / encapsulation
    container encapsulation-pointtopoint {
      tailf:cli-drop-node-name;
      container encapsulation {
        tailf:info "Set encapsulation type for an interface";
        choice encapsulation-choice {

          // interface * / encapsulation isl
          container isl {
            tailf:info "Inter Switch Link - Virtual LAN encapsulation";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf vlan-id {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<1-4095>;;Virtual LAN Identifier.";
                range "1..4095";
              }
            }
          }

          // interface * / encapsulation ppp
          container ppp {
            tailf:info "Point-to-Point protocol";
            presence true;
          }

          // interface * / encapsulation slip
          container slip {
            tailf:info "Serial Line IP";
            presence true;
          }

          // interface * / encapsulation frame-relay
          container frame-relay {
            tailf:info "Frame Relay networks";
            tailf:cli-delete-when-empty;
            presence true;
            leaf IETF {
              tailf:info "Use RFC1490/RFC2427 encapsulation";
              tailf:cli-full-command;
              type empty;
            }
            leaf MFR {
              tailf:info "Multilink Frame Relay bundle interface";
              tailf:cli-allow-join-with-value {
                tailf:cli-display-joined;
              }
              tailf:cli-full-command;
              tailf:non-strict-leafref {
                path "/ios:interface/MFR/name";
              }
              type uint32 {
                tailf:info "<0-2147483647>;;MFR interface number";
              }
            }
          }

          // interface * / encapsulation hdlc
          container hdlc {
            tailf:info "Serial HDLC synchronous";
            tailf:cli-delete-when-empty;
            presence true;
          }
        }
      }
    }

    // interface * / frame-relay
    container frame-relay {
      tailf:info "Set frame relay parameters";
      tailf:cli-diff-dependency "../encapsulation-pointtopoint/encapsulation/frame-relay";

      // interface * / frame-relay multilink
      container multilink {
        tailf:info "Set Multilink FR parameters";

        // interface * / frame-relay multilink output-threshold
        leaf output-threshold {
          tailf:info "Set output-threshold as xmt credit on one bundle link";
          type uint32 {
            tailf:info "<20-2147483647>;;number of bytes";
            range "20..2147483647";
          }
        }

        // interface * / frame-relay multilink bid
        container bid {
          tailf:info "Bundle id for this bundle interface";
          tailf:cli-reset-container;
          leaf bid {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "LINE;;String to identify this bundle to the peer";
            }
          }
        }
      }

      // interface * / frame-relay class
      leaf class {
        tailf:info "Define a map class on the interface";
        tailf:cli-full-command;
        tailf:non-strict-leafref {
          path "/ios:map-class/frame-relay/name";
        }
        type string {
          tailf:info "WORD;;map class name";
        }
      }

      // interface * / frame-relay interface-dlci
      container interface-dlci {
        tailf:info "Define a DLCI on an interface/subinterface";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-fr-dlci";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-delete-when-empty;
        presence true;
        leaf dlci {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type uint16 {
            tailf:info "<16-1007>;;Define a switched or locally terminated DLCI";
          }
        }
        leaf encapsulation {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum cisco {
              tailf:info "Use CISCO Encapsulation";
            }
            enum IETF {
              tailf:info "Use RFC1490/RFC2427 Encapsulation";
            }
            enum ppp {
              tailf:info "Use RFC1973 Encapsulation to support PPP over FR";
            }
            enum switched {
              tailf:info "Define a switched DLCI";
            }
          }
        }

        // interface * / frame-relay interface-dlci / class
        leaf class {
          tailf:info "Assign a mapclass to a dlci";
          tailf:non-strict-leafref {
            path "/ios:map-class/frame-relay/name";
          }
          type string {
            tailf:info "WORD;;map class name";
          }
        }
      }

      // interface * / frame-relay limi-type
      leaf lmi-type {
        tailf:info "Use CISCO-ANSI-CCITT type LMI";
        tailf:cli-full-command;
        type enumeration {
          enum ansi {
          }
          enum cisco {
          }
          enum q933a {
          }
        }
      }

      // interface * / frame-relay intf-type
      leaf intf-type {
        tailf:info "Configure a FR DTE/DCE/NNI interface";
        tailf:cli-full-command;
        type enumeration {
          enum dce {
            tailf:info "Configure a FR DCE";
          }
          enum dte {
            tailf:info "Configure a FR DTE";
          }
          enum nni {
            tailf:info "Configure a FR NNI";
          }
        }
      }

      // interface * / frame-relay container route *
      list route {
        tailf:info "frame relay route for pvc switching";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key in-dlci;
        leaf in-dlci {
          type uint16 {
            tailf:info "<16-1007>;;input dlci to be switche";
            range "16..1007";
          }
        }
        leaf interface {
          tailf:info "outgoing interface for pvc switching";
          type string {
            tailf:info "WORD;;Interface Name";
          }
        }
        leaf out-dlci {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<16-1007>;;output dlci to use when switching";
            range "16..1007";
          }
        }
      }
    }

    // interface * / dialer
    container dialer {
      tailf:info "Dial-on-demand routing (DDR) commands";

      // interface * / dialer in-band
      container in-band {
        tailf:info "Set v.25bis dialing for interface";
        tailf:cli-delete-when-empty;
        presence true;
        leaf parity {
          tailf:cli-drop-node-name;
          type enumeration {
            enum no-parity {
              tailf:info "No parity";
            }
            enum odd-parity {
              tailf:info "Odd parity";
            }
          }
        }
      }

      // interface * / dialer remote-name
      leaf remote-name {
        tailf:info "Configure a remote name";
        type string {
          tailf:info "WORD;;Remote Name";
        }
      }

      // interface * / dialer idle-timeout
      container idle-timeout {
        tailf:info "Specify idle timeout before disconnecting line";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf seconds {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<0-2147483>;;Idle timeout before disconnecting a call";
          }
        }
        leaf direction {
          tailf:cli-drop-node-name;
          type enumeration {
            enum either {
              tailf:info "Reset idle timer based on both inbound and outbound traffic";
            }
            enum inbound {
              tailf:info "Reset idle timer based on inbound traffic only";
            }
          }
        }
      }

      // interface * / dialer enable-timeout
      leaf enable-timeout {
        tailf:info "Set length of time an interface stays down before it is available for dialing";
        type uint32 {
          tailf:info "<1-2147483>;;Enable timeout in seconds";
          range "1..2147483";
        }
      }

      // interface * / dialer string
      leaf string {
        tailf:info "Specify telephone number to be passed to DCE device";
        type string {
          tailf:info "WORD;;Dialer string (quote strings containing #)";
        }
      }

      // interface * / dialer hold-queue
      leaf hold-queue {
        tailf:info "Configure output hold queue";
        type uint8 {
          tailf:info "<0-100>;;Specify size of output hold queue";
          range "0..100";
        }
      }

      // interface * / dialer persistent
      container persistent {
        tailf:info "Configure dialing without interesting traffic";
        tailf:cli-diff-delete-before "../pool";
        presence true;
      }

      // interface * / dialer pool
      leaf pool {
        tailf:info "Specify dialer pool to be used";
        type uint8 {
          tailf:info "<1-255>;;Dialer pool number";
          range "1..255";
        }
      }

      // interface * / dialer pool-member *
      list pool-member {
        tailf:info "Specify dialer pool membership";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key id;
        leaf id {
          type uint8 {
            tailf:info "<1-255>;;Dialer pool number";
          }
        }
        leaf priority {
          tailf:info "Priority of interface in pool";
          tailf:cli-optional-in-sequence;
          type uint8 {
            tailf:info "<1-255>;;Priority";
            range "1..255";
          }
        }
        leaf min-link {
          tailf:info "Minimum number of B channels for pool";
          tailf:cli-optional-in-sequence;
          type uint8 {
            tailf:info "<1-255>;;Number of B channels";
            range "1..255";
          }
        }
        leaf max-link {
          tailf:info "Maximum number of B channels for pool";
          type uint8 {
            tailf:info "<1-255>;;Number of B channels";
            range "1..255";
          }
        }
      }

      // interface * / dialer map
      container map {
        tailf:info "Define multiple dial-on-demand numbers";

        // interface * / dialer map ip *
        list ip {
          tailf:info "IP";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key address;
          leaf address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Protocol specific address";
            }
          }

          // interface * / dialer map ip * name
          leaf name {
            tailf:info "Map to a host";
            type string {
              tailf:info "WORD;;Hostname to map";
            }
          }

          // interface * / dialer map ip * class
          leaf class {
            tailf:info "dialer map class";
            type string {
              tailf:info "WORD;;name of dialer map class";
            }
          }
        }
      }

      // interface * / dialer watch-group
      leaf watch-group {
        tailf:info "Assign interface to dialer-watch-list";
        type uint16 {
          tailf:info "<1-255>;;Dialer watch group number";
          range "1..255";
        }
        tailf:non-strict-leafref {
          path "/ios:dialer/watch-list/id";
        }
      }

      // interface * / dialer load-threshold
      container load-threshold {
        tailf:info "Specify threshold for placing additional calls";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf load {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<1-255>;;Load threshold to place another call";
            range "1..255";
          }
        }
        leaf direction {
          tailf:cli-drop-node-name;
          type enumeration {
            enum inbound {
              tailf:info "Threshold decision based on inbound traffic only";
            }
            enum outbound {
              tailf:info "Threshold decision based on outbound traffic only";
            }
            enum either {
              tailf:info "Threshold decision based on max of inbound and outbound traffic";
            }
          }
        }
      }
    }

    // interface * / dialer-group
    leaf dialer-group {
      tailf:info "Assign interface to dialer-list";
      type uint8 {
        tailf:info "<1-128>;;Dialer list number";
        range "1..128";
      }
    }

    // interface * / ppp
    container ppp {
      tailf:info "Point-to-Point Protocol";
      tailf:cli-diff-dependency "../encapsulation-pointtopoint/encapsulation";

      // interface * / ppp mtu adaptive
      container mtu {
        tailf:info "PPP MTU configuration";
        leaf adaptive {
          tailf:info "Adapt MTU to peer's MRU";
          tailf:cli-diff-dependency "../../../dialer";
          type empty;
        }
      }

      // interface * / ppp pcf local
      container pfc {
        tailf:info "Options for Protocol Field Compression";
        leaf local {
          tailf:info "Specify use of PFC option in outbound Config-Requests";
          type enumeration {
            enum forbid {
              tailf:info "Do not include PFC option in our Config-Requests, ever";
            }
            enum request {
              tailf:info "Include PFC option in our Config-Requests";
            }
          }
        }
      }

      // interface * / ppp acfc
      container acfc {
        tailf:info "Options for HDLC Address & Control Field Compression";

        // interface * / ppp acfc local
        leaf local {
          tailf:info "Specify use of ACFC option in outbound Config-Requests";
          type enumeration {
            enum forbid {
              tailf:info "Do not include ACFC option in our Config-Requests, ever";
            }
            enum request {
              tailf:info "Include ACFC option in our Config-Requests";
            }
          }
        }

        // interface * / ppp acfc remote
        leaf remote {
          tailf:info "Specify handling of ACFC option in inbound Config-Requests";
          type enumeration {
            enum apply {
              tailf:info "Do ACFC if peer indicates it can receive such frames";
            }
            enum ignore {
              tailf:info "Accept ACFC option, but do not apply ACFC on outbound frames";
            }
            enum reject {
              tailf:info "Explicitly reject the ACFC option and disallow ACFC";
            }
          }
        }
      }

      // interface * / ppp accounting
      leaf accounting {
        tailf:info "Set PPP network accounting method";
        type union {
          type string {
            tailf:info "WORD;;Named accounting list.";
          }
          type enumeration {
            enum "default" {
              tailf:info "The default accounting list.";
            }
          }
        }
      }

      // interface * / ppp encrypt mppe
      container encrypt {
        tailf:info "Enable PPP encryption";
        container mppe {
          tailf:info "Microsoft Point-to-Point Encryption";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf bits {
            tailf:cli-drop-node-name;
            type enumeration {
              enum auto {
                tailf:info "Will offer 40 and 128 bit if available";
              }
              enum 40 {
                tailf:info "40 Bit Encryption only";
              }
              enum 128 {
                tailf:info "128 Bit Encryption only";
              }
            }
          }
          leaf mode {
            tailf:cli-drop-node-name;
            type enumeration {
              enum passive {
                tailf:info "Will accept encryption negotiation but not offer";
              }
              enum required {
                tailf:info "Encryption MUST be negotiated";
              }
              enum stateful {
                tailf:info "Negotiate stateful mode only";
              }
            }
          }
        }
      }

      // interface * / ppp authentication
      container authentication {
        tailf:info "Set PPP link authentication method";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        leaf method {
          tailf:cli-drop-node-name;
          type ppp-auth-method;
        }
        leaf method2 {
          tailf:cli-drop-node-name;
          tailf:cli-optional-in-sequence;
          type ppp-auth-method;
        }
        leaf method3 {
          tailf:cli-drop-node-name;
          tailf:cli-optional-in-sequence;
          type ppp-auth-method;
        }
        leaf callin {
          tailf:cli-break-sequence-commands;
          tailf:info "Authenticate remote on incoming call only";
          type empty;
        }
        leaf callout {
          tailf:info "Authenticate remote on outgoing call only";
          type empty;
        }
        leaf callback {
          tailf:info "Authenticate remote on callback only";
          type empty;
        }
        leaf optional {
          tailf:info "Allow peer to refuse to authenticate";
          type empty;
        }
        leaf list-name {
          tailf:cli-drop-node-name;
          tailf:cli-disallow-value "callin|callout|callback|optional|one-time";
          tailf:cli-diff-dependency "/ios:aaa/authentication/ppp";
          type union {
            type string {
              tailf:info "WORD;;Use an authentication list with this name";
            }
            type enumeration {
              enum default {
                tailf:info "Use the default authentication list";
              }
            }
          }
        }
        leaf one-time {
          tailf:info "Allow use of username*OTP for one-time passwords";
          type empty;
        }
      }

      // interface * / ppp authorization
      leaf authorization {
        tailf:info "Set PPP network authorization method";
        type union {
          type string {
            tailf:info "WORD;;Named authorization list.";
          }
          type enumeration {
            enum "default" {
              tailf:info "The default authorization list.";
            }
          }
        }
      }

      // interface * / ppp pap
      container pap {
        tailf:info "Set PAP authentication parameters";

        // interface * / ppp pap sent-username
        container sent-username {
          tailf:info "Set outbound PAP username";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf username {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type string {
              tailf:info "WORD;;Outbound PAP username";
            }
          }
          container password {
            tailf:info "Set outbound PAP password";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            uses password-grouping {
              refine "secret" {
                cli:secret " password <SECRET>";
              }
            }
          }
        }
      }

      // interface * / ppp chap
      container chap {
        tailf:info "Set CHAP authentication parameters";

        // interface * / ppp chap hostname
        leaf hostname {
          tailf:info "Set alternate CHAP hostname";
          type string {
            tailf:info "WORD;;Alternate CHAP hostname";
          }
        }

        // interface * / ppp chap password
        container password {
          tailf:info "Set default CHAP password";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          uses password-grouping {
            refine "secret" {
              cli:secret " chap password <SECRET>";
            }
          }
        }
      }

      // interface * / ppp ipcp
      container ipcp {
        tailf:info "Set IPCP negotiation options";

        // interface * / ppp ipcp address
        container address {
          tailf:info "Additional ipcp address options";
          tailf:cli-compact-syntax;

          // interface * / ppp ipcp address accept
          leaf accept {
            tailf:info "Accept any non zero IP address from our peer";
            tailf:cli-full-command;
            type empty;
          }

          // interface * / ppp ipcp address proxy
          leaf proxy {
            tailf:info "Peer proxy IP address (XCONNECT)";
            tailf:cli-full-command;
            type inet:ipv4-address;
          }

          // interface * / ppp ipcp address request
          leaf request {
            tailf:info "Request any address from our peer";
            tailf:cli-full-command;
            type enumeration {
              enum "ignore" {
                tailf:info "Ignore negotiated address";
              }
            }
          }

          // interface * / ppp ipcp address required
          leaf required {
            tailf:info "Disconnect peers with no IP address negotiated";
            tailf:cli-full-command;
            type empty;
          }

          // interface * / ppp ipcp address unique
          leaf unique {
            tailf:info "Disconnect if peer IP address already in use";
            tailf:cli-full-command;
            type empty;
          }
        }

        // interface * / ppp ipcp dns
        container dns {
          tailf:info "Specify DNS negotiation options";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          choice dns-choice {
            case dns-address {
              leaf primary {
                tailf:cli-drop-node-name;
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Primary DNS IP address";
                }
              }
              leaf secondary {
                tailf:cli-drop-node-name;
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Secondary DNS IP address";
                }
              }
            }
            // interface * / ppp ipcp dns request
            container request {
              tailf:info "Request server addresses from peer";
              tailf:cli-delete-when-empty;
              presence true;
              leaf accept {
                tailf:info "Accept any non zero DNS address";
                type empty;
              }
            }
          }
        }
      }

      // interface * / ppp multilink
      container multilink {
        tailf:info "Make interface multilink capable";
        tailf:cli-display-separated;
        cli:ned-diff-move-before ">encapsulation " {
          cli:arguments "when-delete";
        }
        presence true;

        // interface * / ppp multilink interleave
        leaf interleave {
          tailf:info "Allow interleaving of small packets with fragments";
          type empty;
        }

        // interface * / ppp multilink links
        container links {
          tailf:info "Specify the limits on the number of links in a bundle";

          // interface * / ppp multilink links maximum
          container maximum {
            tailf:info "Maximum number of links desired in the bundle";
            leaf maximum-value {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<1-255>;;Specify maximum desired number of links in a bundle";
              }
            }
          }

          // interface * / ppp multilink links minimum
          container minimum {
            tailf:info "Minimum number of links desired in the bundle";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf minimum-value {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<1-255>;;Specify minimum desired number of links in a bundle";
              }
            }
            leaf mandatory {
              tailf:info "Disable network layer until minimum number of links is reach";
              type empty;
            }
          }
        }

        // interface * / ppp multilink group
        leaf group {
          tailf:info "Put interface in a multilink bundle";
          // NOTE: using a tailf:non-strict-leafref here caused other dependencies to fail
          tailf:non-strict-leafref {
            path "/ios:interface/Multilink/name";
          }
          type uint32 {
            tailf:info "<1-2147483647>;;Multilink group number";
            range "1..2147483647";
          }
        }

        // interface * / ppp multilink fragment-delay
        leaf fragment-delay {
          tailf:info "Specify the maximum delay for each fragment";
          type uint16 {
            tailf:info "<1-1000>;;Maximum delay in milliseconds";
            range "1..1000";
          }
        }

        // interface * / ppp multilink fragment
        container fragment {
          tailf:info "Specify fragmentation parameters";

          // interface * / ppp multilink fragment disable
          leaf disable {
            tailf:info "Suppress multilink fragmentation when possible";
            tailf:cli-full-command;
            type empty;
          }

          // interface * / ppp multilink fragment size
          leaf size {
            tailf:info "Specify the maximum size of a multilink fragment";
            type uint16 {
              tailf:info "<42-65535>;;Maximum fragment size in bytes";
              range "42..65535";
            }
          }

          // interface * / ppp multilink fragment delay
          container delay {
            tailf:info "Specify the maximum delay for each fragment";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf delay-value {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<0-1000>;;Delay in milliseconds";
                range "0..1000";
              }
            }
            leaf additional-delay-value {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<1-999>;;Additional delay in microseconds";
                range "1..999";
              }
            }
          }
        }

        // interface * / no ppp multilink fragmentation
        leaf fragmentation {
          tailf:info "Enable/Disable multilink fragmentation";
          tailf:cli-full-command;
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }

        // interface * / ppp multilink queue depth
        container queue {
          tailf:info "Specify link queuing parameters";
          container depth {
            tailf:info "Specify maximum depth for link transmit queues";
            leaf fifo {
              tailf:info "Set max depth for link queues when bundle has FIFO queuing";
              type uint8 {
                tailf:info "<2-255>;;Max queue depth for link";
                range "2..255";
              }
            }
            leaf qos {
              tailf:info "Set max depth for link queues when bundle has non-FIFO queuing";
              type uint8 {
                tailf:info "<2-255>;;Max queue depth for link";
                range "2..255";
              }
            }
          }
        }

        // interface * / ppp multilink min-links
        container min-links {
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf links {
            tailf:cli-drop-node-name;
            type uint8;
          }
          leaf mandatory {
            type empty;
          }
        }
      }

      // interface * / ppp timeout
      container timeout {
        tailf:info "Set PPP timeout parameters";

        // interface * / ppp timeout ncp
        leaf ncp {
          tailf:info "Maximum time to wait for network layer to negotiate";
          type uint16 {
            tailf:info "<1-65535>;;seconds";
            range "1..65535";
          }
        }
      }
    }

    // interface * / pseudowire
    container pseudowire {
      tailf:info "Pseudowire commands";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-if-xconn";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      presence true;
      leaf address {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        tailf:cli-hide-in-submode;
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;IP address of peer";
        }
      }
      leaf vcid {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        tailf:cli-hide-in-submode;
        type uint32 {
          tailf:info "<1-4294967295>;;Enter VC ID value";
        }
      }
      leaf encapsulation {
        tailf:info "Data encapsulation method";
        tailf:cli-hide-in-submode;
        tailf:cli-optional-in-sequence;
        tailf:cli-remove-before-change;
        tailf:cli-delete-container-on-delete;
        type enumeration {
          enum mpls {
            tailf:info "Use MPLS encapsulation";
          }
          enum l2tpv2 {
            tailf:info "Use L2TPv2 encapsulation";
          }
          enum l2tpv3 {
            tailf:info "Use L2TPv3 encapsulation";
          }
        }
      }
      leaf pw-class {
        tailf:info "Optional pseudowire-class to use for advanced configuration";
        tailf:cli-hide-in-submode;
        tailf:non-strict-leafref {
          path "/ios:pseudowire-class/name";
        }
        type string {
          tailf:info "WORD;;Pseudowire-class name";
        }
      }
    }

    // interface * / multilink
    container multilink {
      tailf:info "Configure multilink parameters";

      // interface * / multilink max-links
      leaf max-links {
        tailf:info "Specify upper limit of the number of links in a bundle";
        type uint8 {
          tailf:info "<1-255>;;Number of links";
          range "1..255";
        }
      }

      // interface * / multilink min-links
      container min-links {
        tailf:info "Specify lower limit of the number of links in a bundle";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf links {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<0-255>;;Number of links";
          }
        }
        leaf mandatory {
          tailf:info "Disable network layer until minimum number of links is reached";
          type empty;
        }
      }

      // interface * / multilink max-fragments
      leaf max-fragments {
        tailf:info "Specify the maximum number of fragments per transmitted packet";
        type uint8 {
          tailf:info "<2-16>;;Maximum fragments per packet";
          range "2..16";
        }
      }
    }

    // interface * / multilink-group
    leaf multilink-group {
      tailf:info "Put interface in a multilink bundle";
      type uint32 {
        tailf:info "<1-2147483647>;;Multilink group number";
        range "1..2147483647";
      }
    }

    // interface * / physical-layer
    leaf physical-layer {
      tailf:info "Configure sync or async physical layer on serial interface";
      type enumeration {
        enum async {
          tailf:info "Configure asynchronous physical layer on serial interface";
        }
        enum sync {
          tailf:info "Configure synchronous physical layer on serial interface";
        }
      }
    }

    // interface * / async
    container async {
      tailf:info "Async interface parameters";
      container mode {
        tailf:info "Specify line mode (interactive or dedicated interface use)";
        leaf dedicated {
          tailf:info "Line is dedicated as an async interface";
          type empty;
        }
        leaf interactive {
          tailf:info "Line may be switched between interactive use and async interface";
          type empty;
        }
      }
    }

    // interface * / pulse-time
    container pulse-time {
      tailf:info "Force DTR low during resets";
      choice pulse-time-choice {
        leaf seconds {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<0-60>;;DTR low time in seconds";
            range "0..60";
          }
        }
        leaf msec {
          tailf:info "millisecond (resolution)";
          type uint16 {
            tailf:info "<1-59999>;;DTR low time in milliseconds";
            range "1..59999";
          }
        }
      }
    }

    // interface * / serial restart-delay
    container serial {
      tailf:info "serial interface commands";
      container restart-delay {
        tailf:info "Configure serial interface restart-delay";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf seconds {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-900>;;Restart delay (seconds)";
            range "0..900";
          }
        }
        leaf milliseconds {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-999>;;Restart delay (milliseconds)";
            range "0..999";
          }
        }
      }
    }

    // interface * / dce-terminal-timing-enable
    // interface * / no dce-terminal-timing-enable
    leaf dce-terminal-timing-enable {
      tailf:info "Enable DCE terminal timing";
      tailf:cli-full-command;
      tailf:cli-boolean-no;
      type boolean;
    }
  }


  // interface-switch-grouping
  grouping interface-switch-grouping {

    // interface * / switchport
    container switchport {
      tailf:info "Set switching mode characteristics";
      tailf:cli-display-separated;
      tailf:cli-recursive-delete;
      tailf:cli-show-no;
      presence true;
      tailf:callpoint interface-switchport-hook { tailf:set-hook node; }

      tailf:cli-diff-after "../service/instance" {
        tailf:cli-when-target-delete;
      }
      tailf:cli-diff-set-after "/ios:router/ospf/disable/passive-interface/interface" {
        tailf:cli-when-target-delete;
      }
      //cli:ned-diff-move-after ">no interface $1" {
      //        cli:arguments "parent|when-set :: regex=interface (\\S+)";
      //}

      ios:if-redeploy "/service-policy/input :: service-policy input :: any"
        +" ;; /service-policy/output :: service-policy output :: any"
        +" ;; /lacp/rate :: lacp rate :: any :: normal"
        +" ;; /source/template :: source template :: any"
        +" ;; /ip/arp/inspection/limit/rate :: ip arp inspection limit rate :: any";

      ios:if-switchport-sp-patch; // patch for me3600, inject delete of service-policy

      // interface * / switchport mode
      container mode {
        tailf:info "Set trunking mode of the interface";
        tailf:cli-diff-delete-after "../../authentication";
        tailf:cli-diff-delete-after "../../dot1x";
        tailf:cli-diff-delete-after "../../mab";
        choice mode-choice {

          // interface * / switchport mode access
          container access {
            tailf:info "Set trunking mode to ACCESS unconditionally";
            presence true;
          }

          // interface * / switchport mode dot1q-tunnel
          container dot1q-tunnel {
            tailf:info "set trunking mode to TUNNEL unconditionally";
            presence true;
          }

          // interface * / switchport mode dynamic
          leaf dynamic {
            tailf:info "Set trunking mode to dynamically negotiate access or trunk mode";
            tailf:cli-diff-set-after "../../port-security";
            tailf:cli-diff-set-after "../../port-security-enable/port-security";
            tailf:cli-diff-set-after "../../nonegotiate" {
              tailf:cli-when-target-delete;
            }
            tailf:cli-diff-set-before "../../trunk/encapsulation" {
              tailf:cli-when-target-delete;
            }
            type enumeration {
              enum auto {
                tailf:info "Set trunking mode dynamic negotiation parameter to AUTO";
              }
              enum desirable {
                tailf:info "Set trunking mode dynamic negotiation parameter to DESIRABLE";
              }
            }
          }

          // interface * / switchport mode trunk
          container trunk {
            tailf:info "Set trunking mode to TRUNK unconditionally";
            tailf:cli-diff-set-after "../../trunk";
            tailf:cli-diff-delete-after "../../../mka";
            tailf:cli-diff-delete-after "../../../macsec";
            presence true;
          }

          // interface * / switchport mode private-vlan
          container private-vlan {
            tailf:info "Set private-vlan mode";
            choice private-vlan-choice {
              leaf host {
                tailf:info "Set the mode to private-vlan host";
                type empty;
              }
              leaf promiscuous {
                tailf:info "Set the mode to private-vlan promiscuous";
                type empty;
              }
              container trunk {
                tailf:info "Set the mode to private-vlan trunk";
                tailf:cli-diff-delete-after "../../../port-security";
                tailf:cli-diff-delete-after "../../../port-security-enable/port-security";
                presence true;
              }
            }
          }
        }
      }

      // interface * / switchport trunk
      container trunk {
        tailf:info "Set trunking characteristics of the interface";

        // interface * / switchport trunk encapsulation
        leaf encapsulation {
          tailf:info "Set encapsulation format on trunk port";
          tailf:cli-diff-delete-after "../../mode/access" {
            tailf:cli-when-target-set;
          }
          type enumeration {
            enum "dot1q" {
              tailf:info "Interface uses only 802.1q trunking encapsulation when trunking";
            }
            enum "isl" {
              tailf:info "Interface uses only ISL trunking encapsulation when trunking";
            }
            enum "negotiate" {
              tailf:info "Device will negotiate trunking encapsulation with peer on interface";
            }
          }
          default negotiate;
        }

        // interface * / switchport trunk native
        container native {
          tailf:info "Set trunking native characteristics when interface is in trunking mode";
          leaf vlan {
            tailf:info "Set native VLAN when interface is in trunking mode";
            type union {
              type enumeration {
                enum tag {
                  tailf:info "Set native VLAN tagging state";
                }
              }
              type uint16 {
                tailf:info "<1-4094>;;VLAN ID of the native VLAN when this port is in trunking mode. Default 1";
                range "1..4094";
              }
            }
            default 1;
          }
        }

        // interface * / switchport trunk allowed
        container allowed {
          tailf:info "Set allowed VLAN characteristics when interface is in trunking mode";

          // interface * / switchport trunk allowed vlan
          container vlan {
            tailf:info "Set allowed VLANs when interface is in trunking mode";
            choice vlan-choice {
              leaf-list vlans {
                tailf:cli-drop-node-name;
                tailf:cli-range-list-syntax;
                //tailf:cli-diff-dependency "../../../../mode";
                ios:leaf-list-modify "( switchport trunk allowed vlan)(.+)";
                type uint16 {
                  tailf:info "WORD;;VLAN IDs of the allowed VLANs when this port is in trunking mode";
                  range "1..4094";
                }
              }
              leaf none {
                tailf:info "no VLANs";
                type empty;
              }
            }
          }
        }

        // interface * / switchport trunk pruning vlan
        container pruning {
          tailf:info "Set pruning VLAN characteristics when interface is in trunking mode";
          container vlan {
            tailf:info "Set VLANs enabled for pruning when interface is in trunking mode";
            choice vlan-choice {
              leaf-list vlans {
                tailf:cli-drop-node-name;
                tailf:cli-range-list-syntax;
                tailf:cli-replace-all;
                type uint16 {
                  tailf:info "WORD;;VLAN IDs of the allowed VLANs when this port is in trunking mode";
                  range "1..4094";
                }
              }
              leaf none {
                tailf:info "no VLANs";
                type empty;
              }
            }
          }
        }
      }

      // interface * / switchport autostate
      container autostate {
        tailf:info "Include or exclude this port from vlan link up calculation";
        leaf exclude {
          tailf:info "Exclude this port from vlan link up calculation";
          type empty;
        }
      }

      // interface * / switchport capture
      container capture-enable {
        tailf:cli-drop-node-name;
        leaf capture {
          tailf:info "Set capture mode characteristics of this interface";
          type empty;
        }
      }

      // interface * / switchport capture allowed vlan *
      container capture {
        tailf:info "Set capture mode characteristics of this interface";
        container allowed {
          tailf:info "Set allowed VLAN characteristics when interface is in capture mode";
          container vlan {
            tailf:info "Set allowed VLANs when interface is in private-vlan trunking mode";
            leaf-list vlans {
              tailf:cli-replace-all;
              tailf:cli-range-list-syntax;
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "VLAN IDs of the allowed VLANs when this port is in capture mode";
                range "1..4094";
              }
            }
          }
        }
      }

      // interface * / switchport private-vlan
      container private-vlan {
        tailf:info "Set the private VLAN configuration";

        // interface * / switchport private-vlan trunk
        container trunk {
          tailf:info "Set the private vlan trunking configuration";

          // interface * / switchport private-vlan trunk native vlan
          container native {
            tailf:info "Set the private vlan trunking native configuration";
            leaf vlan {
              tailf:info "Set native VLAN configuration";
              type union {
                type enumeration {
                  enum "tag" {
                    tailf:info "Set native VLAN tagging state";
                  }
                }
                type uint16 {
                  tailf:info "<1-4094>;;VLAN ID of the native VLAN when this port is in trunking mode";
                  range "1..4094";
                }
              }
            }
          }

          // interface * / switchport private-vlan trunk allowed vlan *
          // Note: Java code makes a single entry of all 'add' entries.
          container allowed {
            tailf:info "Set allowed VLAN characteristics when interface is in private-vlan trunking mode";
            container vlan {
              tailf:info "Set allowed VLANs when interface is in private-vlan trunking mode";
              choice vlan-choice {
                leaf-list vlans {
                  tailf:cli-replace-all;
                  tailf:cli-range-list-syntax;
                  tailf:cli-drop-node-name;
                  type uint16 {
                    tailf:info "WORD;;VLAN IDs of the allowed VLANs when interface is in private-vlan trunking mode";
                    range "1..4094";
                  }
                }
                leaf none {
                  tailf:info "no VLANs";
                  type empty;
                }
              }
            }
          }
        }

        // interface * / switchport private-vlan association
        container association {
          tailf:info "Set the private VLAN association";

          // interface * / switchport private-vlan association trunk *
          list trunk {
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key primary-vlan-id;
            leaf primary-vlan-id {
              type uint16 {
                tailf:info "<2-4094>;;Primary VLAN ID of the private VLAN trunk association";
                range "2..4094";
              }
            }
            leaf secondary-vlan-id {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<2-4094>;;Secondary VLAN ID of the private VLAN port/trunk association";
                range "2..4094";
              }
            }
          }
        }

        // interface * / switchport private-vlan host-association
        container host-association {
          tailf:info "Set the private VLAN host association";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf primary-vlan-id {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<2-1001,1006-4094>;;Primary VLAN ID of the private VLAN port association";
              range "2..1001|1006..4094";
            }
          }
          leaf secondary-vlan-id {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<2-1001,1006-4094>;;Secondary VLAN ID of the private VLAN port association";
              range "2..1001|1006..4094";
            }
          }
        }

        // interface * / switchport private-vlan mapping *
        container mapping {
          tailf:info "Set the private VLAN promiscuous mapping";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf primary-vlan-id {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<2-1001,1006-4094>;;Primary VLAN ID of the private VLAN promiscuous port mapping";
              range "2..1001|1006..4094";
            }
          }
          leaf secondary-vlan-id {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "<2-1001,1006-4094>;;Secondary VLAN ID of the private VLAN promiscuous port mapping";
            }
          }
        }
      }

      // interface * / switchport vlan mapping
      container vlan {
        tailf:info "Set a VLAN mapping on this interface";

        // interface * / switchport vlan mapping enable
        container mapping-enable {
          tailf:cli-drop-node-name;
          container mapping {
            tailf:info "Set a VLAN mapping on this interface";
            leaf enable {
              tailf:info "Enable VLAN mapping on this interface";
              type empty;
            }
          }
        }

        // interface * / switchport vlan mapping *
        list mapping {
          tailf:info "Set a VLAN mapping on this interface";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-remove-before-change;
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          tailf:cli-diff-dependency "../../mode/trunk";
          key id;
          leaf id {
            tailf:cli-diff-dependency "/ios:vlan/vlan-list/private-vlan";
            type union {
              type uint16 {
                tailf:info "WORD;;original VLAN ID(s) on wire";
              }
              type enumeration {
                enum default {
                  tailf:info "default for any vlan";
                }
              }
            }
          }
          choice translated-choice {
            leaf dot1q-tunnel {
              tailf:info "Set a VLAN tunnel (add outer tag)";
              type uint16 {
                tailf:info "<1-4094>;;VLAN ID of outer tag added";
                range "1..4094";
              }
            }
            leaf drop {
              tailf:info "Drop by default";
              type empty;
            }
            leaf translated-id {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<1-4094>;;VLAN ID to be translated";
                range "1..4094";
              }
            }
          }
        }

        // interface * / switchport vlan mapping X
        container mapping-conf {
          tailf:cli-drop-node-name;
          container mapping {

            // interface * / switchport vlan mapping dot1q-tunnel *
            list dot1q-tunnel {
              tailf:info "Set dot1q tunnel vlan mapping on this interface";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key "outer inner";
              leaf outer {
                type uint16 {
                  tailf:info "<1-4094>;;Outer VLAN ID of original packets";
                  range "1..4094";
                }
              }
              leaf inner {
                type union {
                  type uint16 {
                    tailf:info "<1-4094>;;Inner VLAN ID of original packets";
                    range "1..4094";
                  }
                  type enumeration {
                    enum drop {
                      tailf:info "Drop all VLAN traffic except for those VLANs that are explicitly translated";
                    }
                  }
                }
              }
              leaf translated {
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<1-4094>;;VLAN ID to be translated";
                  range "1..4094";
                }
              }
            }

            // interface * / switchport vlan mapping default drop

          }
        }
      }

      // interface * / switchport access vlan
      container access {
        tailf:info "Set access mode characteristics of the interface";
        leaf vlan {
          tailf:info "Set VLAN when interface is in access mode";
          type union {
            type uint16 {
              tailf:info "<1-4094>;;VLAN ID of the VLAN when this port is in access mode. Default 1";
              range "1..4094";
            }
            type enumeration {
              enum dynamic {
                tailf:info "When in access mode, this interfaces VLAN is controlled by VMPS";
              }
            }
          }
          default 1;
        }
      }

      // interface * / switchport backup interface *
      container backup {
        tailf:info "Set backup for the interface";
        list interface {
          tailf:info "Specify an interface as backup";
          tailf:cli-suppress-mode;
          //tailf:cli-keep-when-empty;
          ios:trim-delete-when-empty "( interface \\S+)";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Interface Name";
            }
          }

          // interface * / switchport backup interface * preemption
          container preemption {
            tailf:info "preemption parameters";

            // interface * / switchport backup interface * preemption mode
            leaf mode {
              tailf:info "set the preemption mode";
              cli:ned-diff-stay-after ">interface $1" {
                cli:arguments "parent|when-set :: regex=interface (\\S+) ";
              }
              type enumeration {
                enum bandwidth {
                  tailf:info "higher bandwidth interface preferred";
                }
                enum forced {
                  tailf:info "active interface preferred";
                }
                enum off {
                  tailf:info "turn off preemption";
                }
              }
            }

            // interface * / switchport backup interface * preemption delay
            leaf delay {
              tailf:info "preemption parameters";
              type uint16 {
                tailf:info "<1-300>;;preemption delay in seconds";
                range "1..300";
              }
            }
          }
        }
      }

      // interface * / switchport nonegotiate
      leaf nonegotiate {
        tailf:info "Device will not engage in negotiation protocol on this interface";
        tailf:cli-diff-delete-before "../trunk";
        tailf:cli-diff-delete-before "../mode/trunk";
        tailf:cli-diff-delete-before "../mode/access";
        tailf:cli-diff-delete-before "../mode/dot1q-tunnel";
        type empty;
      }

      // interface * / switchport block
      container block {
        tailf:info "Disable forwarding of unknown uni/multi cast addresses";
        leaf multicast {
          tailf:info "Block unknown multicast addresses";
          tailf:cli-full-command;
          type empty;
        }
        leaf unicast {
          tailf:cli-full-command;
          tailf:info "Block unknown unicast addresses";
          type empty;
        }
      }

      // interface * / switchport port-security
      container port-security-enable {
        tailf:cli-drop-node-name;
        leaf port-security {
          tailf:info "Security related command";
          tailf:cli-diff-delete-before "../../mode/access";
          tailf:cli-diff-delete-before "../../mode/trunk";
          tailf:cli-diff-delete-before "../../mode/dot1q-tunnel";
          type empty;
        }
      }

      // interface * / switchport port-security X
      container port-security {
        tailf:info "Security related command";
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        tailf:cli-diff-delete-before "../mode/access";
        tailf:cli-diff-delete-before "../mode/trunk";

        // interface * / switchport port-security aging
        container aging {
          tailf:info "Port-security aging commands";
          leaf time {
            tailf:info "Port-security aging time";
            type uint16 {
              tailf:info "<1-1440>;;Aging time in minutes. Enter a value between 1 and 1440";
              range "1..1440";
            }
          }
          leaf type {
            tailf:info "Port-security aging type";
            type enumeration {
              enum absolute {
                tailf:info "Absolute aging (default)";
              }
              enum inactivity {
                tailf:info "Aging based on inactivity time period";
              }
            }
          }
        }

        // interface * / switchport port-security mac-address sticky
        container mac-address-sticky {
          tailf:cli-drop-node-name;
          container mac-address {
            tailf:info "Secure mac address";
            leaf sticky {
              tailf:info "Configure dynamic secure addresses as sticky";
              type empty;
            }
          }
        }

        // interface * / switchport port-security mac-address [sticky] *
        list mac-address {
          tailf:info "Secure mac address";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          key hw-address;
          leaf sticky {
            tailf:info "Configure dynamic secure addresses as sticky";
            tailf:cli-optional-in-sequence;
            tailf:cli-prefix-key;
            tailf:cli-diff-dependency "../../mac-address-sticky/mac-address/sticky";
            type empty;
          }
          leaf hw-address {
            type mac-address-type;
          }
          leaf vlan {
            tailf:info "set VLAN ID of the VLAN on which this address can be learned";
            type union {
              type uint16 {
                tailf:info "<1-4094>;;VLAN ID on which this address can be learned";
                range "1..4094";
              }
              type enumeration {
                enum access;
              }
            }
          }
        }

        // interface * / switchport port-security maximum
        leaf maximum {
          tailf:info "Max secure addresses";
          tailf:cli-no-value-on-delete;
          tailf:cli-full-command;
          tailf:cli-diff-delete-after "../maximum-vlan/maximum";
          type uint16 {
            tailf:info "<1-8192>;;Maximum addresses";
            range "1..8192";
          }
        }

        // interface * / switchport port-security maximum ? vlan
        container maximum-vlan {
          tailf:cli-drop-node-name;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf maximum {
            tailf:cli-no-value-on-delete;
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<1-8192>;;Maximum addresses";
              range "1..8192";
            }
          }
          leaf vlan {
            tailf:info "Max secure addresses per vlan";
            type empty;
          }
        }

        // interface * / switchport port-security maximum * vlan *
        container maximum-vlan-list {
          tailf:cli-drop-node-name;
          list maximum {
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            key "max-addresses vlan";
            leaf max-addresses {
              type uint16 {
                tailf:info "<1-8192>;;Maximum addresses";
                range "1..8192";
              }
            }
            leaf vlan {
              tailf:info "Max secure addresses per vlan";
              tailf:cli-expose-key-name;
              type string {
                tailf:info "WORD;;VLAN IDs to which this maximum applies";
              }
            }
          }
        }

        // interface * / switchport port-security violation
        leaf violation {
          tailf:info "Security violation mode";
          type enumeration {
            enum protect {
              tailf:info "Security violation protect mode";
            }
            enum restrict {
              tailf:info "Security violation restrict mode";
            }
            enum shutdown {
              tailf:info "Security violation shutdown mode";
            }
          }
        }
      }

      // interface * / switchport priority
      container priority {
        tailf:info "Set appliance 802.1p priority";
        tailf:cli-incomplete-command;

        container extend {
          tailf:info "Set appliance 802.1p priority";
          tailf:cli-incomplete-command;
          choice trust-choice {
            leaf trust {
              tailf:cli-full-command;
              tailf:info "Trust 802.1p priorities of devices on appliance";
              type empty;
            }
            leaf cos {
              tailf:info "Override 802.1p priority of devices on appliance";
              tailf:cli-full-command;
              type uint8 {
                tailf:info "<0-7>;;Priority for devices on appliance";
                range "0..7";
              }
            }
          }
        }
      }

      // interface * / switchport protected
      leaf protected {
        tailf:info "Configure an interface to be a protected port";
        type empty;
      }

      // interface * / switchport voice
      container voice {
        tailf:info "Voice appliance attributes";
        leaf vlan {
          tailf:info "Vlan for voice traffic";
          type union {
            type enumeration {
              enum dot1p {
                tailf:info "Priority tagged on PVID";
              }
              enum none {
                tailf:info "Don't tell telephone about voice vlan";
              }
              enum untagged {
                tailf:info "Untagged on PVID";
              }
            }
            type uint16 {
              tailf:info "<1-4094>;;Vlan for voice traffic";
              range "1..4094";
            }
          }
        }
        container detect {
          tailf:info "detection enhancement keyword";
          tailf:cli-incomplete-command;
          container cisco-phone {
            tailf:info "Cisco IP phone";
            presence true;
            leaf full-duplex {
              tailf:info "full duplex keyword";
              type empty;
            }
          }
        }
      }

      // interface * / switchport host
      leaf host {
        tailf:info "Set port host";
        type empty;
      }
    }

    // interface * / switch virtual link
    container switch {
      tailf:info "Configure switch link";
      container virtual {
        tailf:info "Configure virtual switch values";
        leaf link {
          tailf:info "Configure virtual switch number";
          type uint8 {
            tailf:info "<1-2>;;switch number";
            range "1..2";
          }
        }
      }
    }

    // interface * / l2protocol-tunnel
    container l2protocol-tunnel {
      tailf:info "Tunnel Layer2 protocols";
      tailf:cli-delete-when-empty;
      presence true;

      // interface * / l2protocol-tunnel cdp
      leaf cdp {
        tailf:info "Cisco Discovery Protocol";
        type empty;
      }

      // interface * / l2protocol-tunnel drop-threshold
      container drop-threshold {
        tailf:info "Set drop threshold for protocol packets";
        leaf packet-rate {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-4096>;;Packets/sec rate beyond which protocol packets will be dropped";
            range "1..4096";
          }
        }
        leaf cdp {
          tailf:info "Cisco Discovery Protocol";
          type uint16 {
            tailf:info "<1-4096>;;Packets/sec rate beyond which protocol packets will be dropped";
            range "1..4096";
          }
        }
        leaf stp {
          tailf:info "Spanning Tree Protocol";
          type uint16 {
            tailf:info "<1-4096>;;Packets/sec rate beyond which protocol packets will be dropped";
            range "1..4096";
          }
        }
        leaf vtp {
          tailf:info "Vlan Trunking Protocol";
          type uint16 {
            tailf:info "<1-4096>;;Packets/sec rate beyond which protocol packets will be dropped";
            range "1..4096";
          }
        }
      }

      // interface * / l2protocol-tunnel shutdown-threshold
      container shutdown-threshold {
        tailf:info "Set shutdown threshold for protocol packets";
        leaf packet-rate {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-4096>;;Packets/sec rate beyond which interface is put to err-disable";
            range "1..4096";
          }
        }
        leaf cdp {
          tailf:info "Cisco Discovery Protocol";
          type uint16 {
            tailf:info "<1-4096>;;Packets/sec rate beyond which interface is put to err-disable";
            range "1..4096";
          }
        }
        leaf lldp {
          tailf:info "Link Layer Discovery Protocol";
          type uint16 {
            tailf:info "<1-4096>;;Packets/sec rate beyond which interface is put to err-disable";
            range "1..4096";
          }
        }
        leaf stp {
          tailf:info "Spanning Tree Protocol";
          type uint16 {
            tailf:info "<1-4096>;;Packets/sec rate beyond which interface is put to err-disable";
            range "1..4096";
          }
        }
        leaf vtp {
          tailf:info "Vlan Trunking Protocol";
          type uint16 {
            tailf:info "<1-4096>;;Packets/sec rate beyond which interface is put to err-disable";
            range "1..4096";
          }
        }

        // interface * / l2protocol-tunnel shutdown-threshold point-to-point
        container point-to-point {
          tailf:info "point-to-point L2 Protocol";
          leaf pagp {
            tailf:info "Port Aggregation Protocol";
            type uint16 {
              tailf:info "<1-4096>;;Packets/sec rate beyond which interface is put to err-disable";
              range "1..4096";
            }
          }
          leaf lacp {
            tailf:info "Link Aggregation Control Protocol";
            type uint16 {
              tailf:info "<1-4096>;;Packets/sec rate beyond which interface is put to err-disable";
              range "1..4096";
            }
          }
          leaf udld {
            tailf:info "Unidirectional Link Detection";
            type uint16 {
              tailf:info "<1-4096>;;Packets/sec rate beyond which interface is put to err-disable";
              range "1..4096";
            }
          }
        }
      }

      // interface * / l2protocol-tunnel stp
      leaf stp {
        tailf:info "Spanning Tree Protocol";
        type empty;
      }

      // interface * / l2protocol-tunnel vtp
      leaf vtp {
        tailf:info "Vlan Trunking Protocol";
        type empty;
      }

      // interface * / l2protocol-tunnel lldp
      leaf lldp {
        tailf:info "Link Layer Discovery Protocol";
        type empty;
      }

      // interface * / l2protocol-tunnel point-to-point
      container point-to-point {
        tailf:info "point-to-point L2 Protocol";
        leaf lacp {
          tailf:info "Link Aggregation Control Protocol";
          type empty;
        }
        leaf pagp {
          tailf:info "Port Aggregation Protocol";
          type empty;
        }
        leaf udld {
          tailf:info "Unidirectional Link Detection";
          type empty;
        }
      }
    }

    // interface * / device-tracking
    container device-tracking {
      tailf:info "Configure device-tracking on the interface";

      // interface * / device-tracking attach-policy
      leaf attach-policy {
        tailf:info "Apply a policy for feature device-tracking";
        tailf:non-strict-leafref {
          path "/ios:device-tracking/policy/name";
        }
        type string {
          tailf:info "WORD;;policy name for device tracking";
        }
      }
    }
  } // interface-switch-grouping


  // crypto pki token grouping
  grouping crypto-pki-token-grouping {

    // crypto pki token * removal timeout
    container removal {
      tailf:info "actions to take after token removal";
      leaf timeout {
        tailf:info "seconds after token removal at which keys from the token are cleared";
        type uint16 {
          tailf:info "<0-480>;;Token key timeout in seconds. Default 0";
          range "0..480";
        }
        default 0;
      }
    }

    // crypto pki token * max-retries
    leaf max-retries {
      tailf:info "maximum number of consecutive login failures permitted";
      type uint8 {
        tailf:info "<1-15>;;Token key maximum unsuccessful login retries before token is locked. Default 15";
        range "1..15";
      }
      default 15;
    }
  }


  // router bgp * /
  grouping router-bgp-max-path-grouping {

    // router bgp * / maximum-paths
    container paths {
      tailf:cli-drop-node-name;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf number-of-paths {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<1-16>;;Number of paths. Default 1";
          range "1..16";
        }
        default "1";
      }
      leaf import {
        tailf:info "Maximum import paths";
        type uint16 {
          tailf:info "<1-16>;;Number of import paths";
          range "1..16";
        }
      }
    }
  }


  grouping router-bgp-redistribute-isis-grouping {
    choice osi-ip-choice {
      leaf ip {
        tailf:info "Redistribution of IP dynamic routes";
        tailf:cli-no-name-on-delete;
        tailf:cli-no-value-on-delete;
        tailf:cli-remove-before-change;
        type empty;
      }
      leaf clns {
        tailf:info "Redistribution of OSI dynamic routes";
        tailf:cli-no-name-on-delete;
        tailf:cli-no-value-on-delete;
        tailf:cli-remove-before-change;
        type empty;
      }
    }
    leaf level {
      tailf:cli-drop-node-name;
      tailf:cli-no-name-on-delete;
      tailf:cli-no-value-on-delete;
      type enumeration {
        enum level-1 {
          tailf:info "IS-IS level-1 routes only";
        }
        enum level-2 {
          tailf:info "IS-IS level-2 routes only";
        }
        enum level-1-2 {
          tailf:info "IS-IS level-1 and level-2 routes";
        }
      }
    }
  }


  // router-bgp-redistribute-grouping
  grouping router-bgp-redistribute-grouping {
    leaf metric {
      tailf:info "Metric for redistributed routes";
      tailf:cli-no-name-on-delete;
      tailf:cli-no-value-on-delete;
      tailf:cli-remove-before-change;
      type uint32 {
        tailf:info "<0-4294967295>;;Default metric";
        range "0..4294967295";
      }
    }
    leaf subnets {
      tailf:info "Consider subnets for redistribution into BGP";
      tailf:cli-no-name-on-delete;
      tailf:cli-no-value-on-delete;
      type empty;
    }
    leaf route-map {
      tailf:info "Route map reference";
      tailf:cli-no-name-on-delete;
      tailf:cli-no-value-on-delete;
      type string {
        tailf:info "WORD;;Pointer to route-map entries";
      }
    }
    leaf include-connected {
      tailf:info "Include connected";
      tailf:cli-no-name-on-delete;
      tailf:cli-no-value-on-delete;
      type empty;
    }
  }


  grouping router-bgp-redistribute-ospf-grouping {

    leaf metric {
      tailf:info "Metric for redistributed routes";
      tailf:cli-no-name-on-delete;
      tailf:cli-no-value-on-delete;
      tailf:cli-remove-before-change;
      type uint32 {
        tailf:info "<0-4294967295>;;Default metric";
        range "0..4294967295";
      }
    }

    leaf subnets {
      tailf:info "Consider subnets for redistribution into BGP";
      tailf:cli-no-name-on-delete;
      tailf:cli-no-value-on-delete;
      type empty;
    }

    leaf route-map {
      tailf:info "Route map reference";
      tailf:cli-no-name-on-delete;
      tailf:cli-no-value-on-delete;
      type string {
        tailf:info "WORD;;Pointer to route-map entries";
      }
    }

    leaf include-connected {
      tailf:info "Include connected";
      tailf:cli-no-name-on-delete;
      tailf:cli-no-value-on-delete;
      type empty;
    }

    leaf match {
      tailf:info "Redistribution of OSPF routes";
      tailf:cli-no-name-on-delete;
      tailf:cli-no-value-on-delete;
      tailf:cli-incomplete-command;
      type empty;
    }

    leaf internal {
      when "../match" {
        tailf:dependency "../match";
      }
      tailf:info "Redistribute OSPF internal routes";
      tailf:cli-no-name-on-delete;
      tailf:cli-no-value-on-delete;
      type empty;
    }

    container external-1 {
      when "../match" {
        tailf:dependency "../match";
      }
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      leaf external {
        tailf:info "Redistribute OSPF external routes";
        tailf:cli-no-name-on-delete;
        tailf:cli-no-value-on-delete;
        type enumeration {
          enum "1" {
            tailf:info "Redistribute external type 1 routes";
          }
        }
      }
    }

    container external-2 {
      when "../match" {
        tailf:dependency "../match";
      }
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      leaf external {
        tailf:info "Redistribute OSPF external routes";
        tailf:cli-no-name-on-delete;
        tailf:cli-no-value-on-delete;
        type enumeration {
          enum "2" {
            tailf:info "Redistribute external type 2 routes";
          }
        }
      }
    }

    container nssa-external-1 {
      when "../match" {
        tailf:dependency "../match";
      }
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      leaf nssa-external {
        tailf:info "Redistribute OSPF NSSA external routes";
        tailf:cli-no-name-on-delete;
        tailf:cli-no-value-on-delete;
        type enumeration {
          enum "1" {
            tailf:info "Redistribute NSSA external type 1 routes";
          }
        }
      }
    }

    container nssa-external-2 {
      when "../match" {
        tailf:dependency "../match";
      }
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      leaf nssa-external {
        tailf:info "Redistribute OSPF NSSA external routes";
        tailf:cli-no-name-on-delete;
        tailf:cli-no-value-on-delete;
        type enumeration {
          enum "2" {
            tailf:info "Redistribute NSSA external type 2 routes";
          }
        }
      }
    }
  }


  // route-map-metric-grouping
  grouping route-map-metric-grouping {
    leaf route-map {
      tailf:info "Route map reference";
      type string {
        tailf:info "WORD;;Pointer to route-map entries";
      }
    }
    leaf metric {
      tailf:info "Metric for redistributed routes";
      type uint32 {
        tailf:info "<0-4294967295>;;Default metric";
        range "0..4294967295";
      }
    }
  }


  // router bgp * / neighbor * distribute-list *
  grouping router-bgp-neighbor-distribute-list-grouping {

    list distribute-list {
      tailf:info "Filter networks in routing updates";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-remove-before-change;
      key direction;
      leaf direction {
        type enumeration {
          enum "in" {
            tailf:info "Filter incoming routing updates";
          }
          enum "out" {
            tailf:info "Filter outgoing routing updates";
          }
        }
      }
      uses distribute-list-content-grouping;
    }

    container distribute-list-interface {
      tailf:cli-drop-node-name;
      list distribute-list {
        tailf:info "Filter networks in routing updates";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-remove-before-change;
        key "direction interface";
        leaf direction {
          type enumeration {
            enum "in" {
              tailf:info "Filter incoming routing updates";
            }
            enum "out" {
              tailf:info "Filter outgoing routing updates";
            }
          }
        }
        leaf interface {
          type string {
            tailf:info "WORD;;Interface name";
          }
        }
        uses distribute-list-content-grouping;
      }
    }
  }


  // router bgp * / neighbor *
  // router bgp * / peer-policy * /
  grouping router-bgp-peer-policy-grouping {

    // router bgp * / neighbor * additional-paths
    container additional-paths {
      tailf:info "Negotiate additional paths capabilities with this neighbor";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf send {
        tailf:info "Send additional paths to this neighbor";
        tailf:cli-optional-in-sequence;
        type empty;
      }
      leaf receive {
        tailf:info "Receive additional paths from neighbors";
        type empty;
      }
    }

    // router bgp * / neighbor * advertise additional-paths best
    container advertise {
      tailf:info "Advertise to this neighbor";
      container additional-paths {
        tailf:info "Advertise additional paths";
        tailf:cli-compact-syntax;
        leaf all {
          tailf:info "Select all available paths";
          type empty;
        }
        leaf group-best {
          tailf:info "Select group-best paths";
          type empty;
        }
        leaf best {
          tailf:info "Select best N paths";
          type uint8 {
            tailf:info "<2-3>;;Number of best paths in additional paths to be selected";
            range "2..3";
          }
        }
      }
    }

    // router bgp * / neighbor * advertisement-interval
    leaf advertisement-interval {
      tailf:info "Minimum interval between sending BGP routing updates";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<0-600>;;time in seconds";
        range "0..600";
      }
    }

    // router bgp * / neighbor * next-hop-self
    container next-hop-self {
      tailf:info "Disable the next hop calculation for this neighbor";
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      presence true;
      leaf all {
        tailf:info "Enable next-hop-self for both eBGP and iBGP received paths";
        type empty;
      }
    }

    // router bgp * / neighbor * aigp
    container aigp {
      tailf:cli-delete-when-empty;
      presence true;
    }

    // router bgp * / neighbor * send-community
    container send-community {
      tailf:info "Send Community attribute to this neighbor";
      tailf:cli-delete-when-empty;
      presence true;
      leaf send-community-where {
        tailf:cli-drop-node-name;
        type enumeration {
          enum both {
            tailf:info "Send Standard and Extended Community attributes";
          }
          enum extended {
            tailf:info "Send Extended Community attribute";
          }
          enum standard {
            tailf:code-name "send_standard";
            tailf:info "Send Standard Community attribute";
          }
        }
      }
    }

    // router bgp * / neighbor * send-label
    container send-label {
      tailf:info "Send NLRI + MPLS Label to this peer";
      tailf:cli-delete-when-empty;
      presence true;
      leaf explicit-null {
        tailf:info "Advertise Explicit Null label in place of Implicit Null";
        type empty;
      }
    }

    // router bgp * / neighbor * maximum-prefix
    container maximum-prefix {
      tailf:info "Maximum number of prefixes accepted from this peer";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      leaf max-prefix-no {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<1-2147483647>;;maximum no. of prefix limit";
          range "1..2147483647";
        }
      }
      leaf threshold {
        tailf:cli-drop-node-name;
        tailf:cli-break-sequence-commands;
        type uint8 {
          tailf:info "<1-100>;;Threshold value (%) at which to generate a warning msg";
          range "1..100";
        }
      }
      leaf restart {
        tailf:info "Restart bgp connection after limit is exceeded";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<1-65535>;;Restart interval in minutes";
          range "1..65535";
        }
      }
      leaf warning-only {
        tailf:info "Only give warning message when limit is exceeded";
        tailf:cli-full-command;
        type empty;
      }
    }

    // router bgp * / neighbor * allowas-in
    container allowas-in {
      tailf:info "Accept as-path with my AS present in it";
      tailf:cli-delete-when-empty;
      presence true;
      leaf as-no {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-10>;;Number of occurances of AS number";
          range "1..10";
        }
      }
    }

    // router bgp * / neighbor * as-override  [peergroup only]
    container as-override {
      tailf:info "Override matching AS-number while sending update";
      tailf:cli-delete-when-empty;
      presence true;
      leaf disable {
        type empty;
      }
    }

    // router bgp * / neighbor * default-originate
    container default-originate {
      tailf:info "Originate default route to this neighbour";
      tailf:cli-delete-when-empty;
      presence true;
      leaf route-map {
        tailf:info "Route-map to specify criteria to originate default";
        type string {
          tailf:info "WORD;;route-map name";
        }
      }
    }

    // router bgp * / neighbor * prefix-list *
    list prefix-list {
      tailf:info "Filter updates to/from this neighbor";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      key direction;
      leaf direction {
        type enumeration {
          enum in {
            tailf:info "Filter incoming updates";
          }
          enum out {
            tailf:info "Filter outgoing updates";
          }
        }
      }
      leaf prefix-list-name {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        tailf:non-strict-leafref {
          path "/ios:ip/prefix-list/prefixes/name";
        }
        type string {
          tailf:info "WORD;;Name of a prefix list";
        }
      }
    }

    // router bgp * / neighbor * route-reflector-client
    leaf route-reflector-client {
      tailf:info "Configure a neighbor as Route Reflector client";
      tailf:cli-full-command;
      type empty;
    }

    // router bgp * / neighbor * slow-peer
    container slow-peer {
      tailf:info "Configure slow-peer";

      // router bgp * / neighbor * slow-peer split-update-group
      container split-update-group {
        tailf:info "Configure slow-peer split-update-group";
        leaf static {
          tailf:info "Static slow-peer";
          type empty;
        }
        leaf dynamic {
          tailf:info "Dynamically split the slow peer to slow-update group";
          type empty;
        }
      }
    }

    // router bgp * / neighbor * soft-reconfiguration
    leaf soft-reconfiguration {
      tailf:info "Per neighbor soft reconfiguration";
      tailf:cli-full-command;
      type enumeration {
        enum inbound {
          tailf:info "Allow inbound soft reconfiguration for this neighbor";
        }
      }
    }

    // router bgp * / neighbor * remove-private-as
    container remove-private-as {
      tailf:info "Remove private AS number from outbound updates";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      presence true;
      leaf all {
        tailf:info "Remove all private AS numbers";
        type empty;
      }
      leaf replace-as {
        tailf:info "Replace all private AS numbers with local AS";
        type empty;
      }
    }

    // router bgp * / neighbor * route-map *
    list route-map {
      tailf:info "Apply route map to neighbor";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key direction;
      leaf direction {
        type enumeration {
          enum in {
            tailf:info "Apply map to incoming routes";
          }
          enum out {
            tailf:info "Apply map to outbound routes";
          }
        }
      }
      leaf route-map-name {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        type string {
          tailf:info "WORD;;Name of route map";
        }
      }
    }

    // router bgp * / neighbor * advertise-map * exist-map *
    list advertise-map {
      tailf:info "Apply advertise map to neighbor";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Name of route map";
        }
      }
      list exist-map {
        tailf:info "advertise prefix only if prefix is in the condition exists";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;condition route-map name";
          }
        }
      }
    }

    // router bgp * / neighbor * advertise-map * internal-vpn-client
    leaf internal-vpn-client {
      tailf:info "Stack iBGP-CE Neighbor Path in ATTR_SET for vpn update";
      type empty;
    }
  }

  // router bgp * / neighbor *
  // router bgp * / peer-session * /
  grouping router-bgp-peer-session-grouping {

    // router bgp * / neighbor * local-as
    container local-as {
      tailf:info "Specify a local-as number";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-delete-when-empty;
      presence true;
      leaf as-no {
        tailf:cli-drop-node-name;
        type bgp-as-no-type;
      }
      leaf no-prepend {
        tailf:info "Do not prepend local-as to updates from ebgp peers";
        type empty;
      }
      leaf replace-as {
        tailf:info "Replace real AS with local AS in the EBGP updates";
        type empty;
      }
      leaf dual-as {
        tailf:info "Accept either real AS or local AS from the ebgp peer";
        type empty;
      }
    }

    // router bgp * / neighbor * password
    container password {
      tailf:info "Set a password";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf enctype {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        tailf:cli-incomplete-command;
        type uint8 {
          tailf:info "<0-7>;;Encryption type (0 to disable encryption, 7 for proprietary)";
          range "0..7";
        }
        default 0;
      }
      leaf text {
        tailf:cli-drop-node-name;
        tailf:cli-multi-value;
        tailf:cli-full-command;
        tailf:cli-disallow-value "0|1|2|3|4|5|6|7";
        cli:secret " password <SECRET>";
        type NEDCOM_SECRET_TYPE {
          tailf:info "LINE;;The password";
        }
      }
    }

    // router bgp * / neighbor * allow-policy
    leaf allow-policy {
      tailf:info "Enable the policy support for this IBGP Neighbor";
      type empty;
    }

    // router bgp * / neighbor * ttl-security hops
    container ttl-security {
      tailf:info "BGP ttl security check";
      leaf hops {
        tailf:info "IP hops";
        type uint8 {
          tailf:info "<1-254>;;maximum number of hops";
          range "1..254";
        }
      }
    }

    // router bgp * / neighbor * timers
    container timers {
      tailf:info "BGP per neighbor timers";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf keepalive-interval {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint16 {
          range "0..65535";
          tailf:info "<0-65535>;;Keepalive interval";
        }
      }
      leaf holdtime {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<0-65535>;;Holdtime";
          range "0..65535";
        }
      }
      leaf minimum-neighbor-hold {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<0-65535>;;Minimum hold time from neighbor";
          range "0..65535";
        }
      }
    }

    // router bgp * / neighbor * fall-over
    // router bgp * / neighbor * fall-over route-map
    container fall-over {
      tailf:info "session fall on peer route lost";
      tailf:cli-delete-when-empty;
      presence true;
      leaf route-map {
        tailf:info "Route map for peer route";
        type string {
          tailf:info "WORD;;Name of the route map";
        }
      }
    }

    // router bgp * / neighbor * fall-over bfd
    container fall-over-bfd {
      tailf:cli-drop-node-name;
      container fall-over {
        tailf:info "session fall on peer route lost";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        tailf:cli-diff-delete-before "../../fall-over";
        leaf bfd {
          tailf:info "Use BFD to detect failure";
          type empty;
        }
        choice hop-choice {
          leaf multi-hop {
            tailf:info "Force BFD multi-hop to detect failure";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          leaf single-hop {
            tailf:info "Force BFD single-hop to detect failure";
            tailf:cli-optional-in-sequence;
            type empty;
          }
        }
        leaf check-control-plane-failure {
          tailf:info "Retreive control plane dependent failure (c-bit) information from BFD for BGP GR/NSF operation";
          tailf:cli-optional-in-sequence;
          type empty;
        }
        leaf strict-mode {
          tailf:info "Enable BFD strict-mode";
          type empty;
        }
      }
    }

    // router bgp * / neighbor * ebgp-multihop
    container ebgp-multihop {
      tailf:info "Allow EBGP neighbors not on directly connected networks";
      tailf:cli-delete-when-empty;
      presence true;
      leaf max-hop {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-255>;;maximum hop count";
          range "1..255";
        }
      }
    }

    // router bgp * / neighbor * ao
    container ao {
      tailf:info "TCP-AO authentication";
      leaf keychain-name {
        tailf:cli-drop-node-name;
        tailf:non-strict-leafref {
          path "/ios:key/tcp/chain/name";
        }
        type string {
          tailf:info "WORD;;Keychain name";
        }
      }
    }

    // router bgp * / neighbor * bmp-activate
    container bmp-activate {
      tailf:info "Activate the BMP monitoring for a BGP peer";
      leaf all {
        tailf:info "Activate BMP monitoring for all servers";
        tailf:cli-full-command;
        tailf:cli-diff-delete-before "../server" {
          tailf:cli-when-target-set;
        }
        type empty;
      }
      leaf server {
        tailf:info "Activate BMP for server";
        tailf:cli-remove-before-change;
        tailf:cli-full-command;
        tailf:cli-diff-delete-before "../all" {
          tailf:cli-when-target-set;
        }
        type uint8 {
          tailf:info "<1-4>;;BMP Server Number";
          range "1..4";
        }
      }
    }

    // router bgp * / bgp cluster-id
    leaf cluster-id {
      tailf:cli-full-command;
      type union {
        type uint32 {
          tailf:info "<1-4294967295>;;Route-Reflector Cluster-id as 32 bit quantity";
          range "1..4294967295";
        }
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Route-Reflector Cluster-id in IP address format";
        }
      }
    }

    // router bgp * / neighbor * update-source
    container update-source {
      tailf:info "Source of routing updates";
      uses interface-nodiff-name-grouping;
    }

    // router bgp * / neighbor * path-attribute
    container path-attribute {
      tailf:info "BGP optional attribute filtering";

      // router bgp * / neighbor * path-attribute discard * in
      list discard {
        tailf:info "Discard matching path-attribute for this neighbor";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          type uint8 {
            tailf:info "<1-255>;;path attribute type";
            range "1..255";
          }
        }
        leaf in {
          tailf:info "Perform inbound path-attribute filtering";
          type empty;
        }
      }
    }

    // router bgp * / neighbor * version
    leaf version {
      tailf:info "Set the BGP version to match a neighbor";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<4-4>;;Neighbor's BGP version";
        range "4";
      }
    }

    // router bgp * / neighbor * transport
    container transport {
      tailf:info "Transport options";

      // router bgp * / neighbor * transport connection-mode
      leaf connection-mode {
        tailf:info "Specify passive or active connection";
        type enumeration {
          enum active {
            tailf:info "Actively establish the TCP session";
          }
          enum passive {
            tailf:info "Passively establish the TCP session";
          }
        }
      }

      // router bgp * / neighbor * transport path-mtu-discovery
      container path-mtu-discovery {
        tailf:info "Use transport path MTU discovery";
        tailf:cli-delete-when-empty;
        presence true;
        leaf disable {
          tailf:info "disable";
          type empty;
        }
      }
    }

    // router bgp * / neighbor * disable-connected-check
    leaf disable-connected-check {
      tailf:info "One-hop away EBGP peer using loopback address";
      tailf:cli-full-command;
      type empty;
    }
  }

  // ORDER:
  // router bgp * / neighbor * peer-group <name>
  // router bgp * / neighbor * remote-as <as>
  // router bgp * / neighbor * inherit peer-session
  // router bgp * / neighbor * activate

  // router bgp * / address-family * / neighbor * activate
  // router bgp * / address-family * / neighbor * inherit peer-policy

  // router bgp * / neighbor *
  grouping router-bgp-neighbor-grouping {

    // router bgp * / neighbor * remote-as
    leaf remote-as {
      tailf:info "Specify a BGP neighbor";
      tailf:cli-delete-container-on-delete;
      tailf:cli-full-command;
      type string {
        tailf:info "AS of remote neighbor";
      }
    }

    // router bgp * / neighbor * activate
    leaf activate {
      tailf:info "Enable the Address Family for this Neighbor";
      tailf:cli-delete-container-on-delete;
      tailf:cli-full-command;
      tailf:cli-diff-set-after "../inherit/peer-session";
      tailf:cli-diff-dependency "/ios:router/bgp/template/peer-session/remote-as";
      type empty;
    }

    // router bgp * / neighbor * inherit
    container inherit {
      tailf:info "Inherit a template";

      // router bgp * / neighbor * inherit peer-session
      leaf peer-session {
        tailf:info "Inherit a peer-session template";
        tailf:cli-remove-before-change;
        tailf:cli-full-command;
        tailf:non-strict-leafref {
          path "/ios:router/bgp/template/peer-session/name";
        }
        type string {
          tailf:info "WORD;;Template name";
        }
      }

      // router bgp * / neighbor * inherit peer-policy
      leaf peer-policy {
        tailf:info "Inherit a peer-policy template";
        tailf:cli-remove-before-change;
        tailf:cli-full-command;
        tailf:cli-diff-dependency "/ios:router/bgp/template/peer-session/inherit/peer-session";
        tailf:cli-diff-dependency "/ios:router/bgp/template/peer-session/remote-as";
        tailf:non-strict-leafref {
          path "/ios:router/bgp/template/peer-policy/name";
        }
        type string {
          tailf:info "WORD;;Template name";
        }
      }
    }

    // router bgp * / neighbor * local-as
    // router bgp * / neighbor * password
    // router bgp * / neighbor * ttl-security hops
    // router bgp * / neighbor * timers
    // router bgp * / neighbor * fall-over
    // router bgp * / neighbor * ebgp-multihop
    // router bgp * / neighbor * update-source
    // router bgp * / neighbor * version
    // router bgp * / neighbor * transport
    // router bgp * / neighbor * disable-connected-check
    uses router-bgp-peer-session-grouping;

    // router bgp * / neighbor * advertisement-interval
    // router bgp * / neighbor * maximum-prefix
    // router bgp * / neighbor * next-hop-self
    // router bgp * / neighbor * send-community
    // router bgp * / neighbor * allowas-in
    // router bgp * / neighbor * as-override
    // router bgp * / neighbor * default-originate
    // router bgp * / neighbor * prefix-list *
    // router bgp * / neighbor * route-reflector-client
    // router bgp * / neighbor * soft-reconfiguration
    // router bgp * / neighbor * remove-private-as
    // router bgp * / neighbor * route-map *
    // router bgp * / neighbor * internal-vpn-client
    uses router-bgp-peer-policy-grouping;

    // router bgp * / neighbor * soo
    leaf soo {
      tailf:info "Site-of-Origin extended community";
      tailf:cli-full-command;
      type string {
        tailf:info "ASN:nn or IP-address:nn;;VPN extended community";
      }
    }

    // router bgp * / neighbor * capability orf prefix-list
    container capability {
      tailf:info "Advertise capability to the peer";
      container orf {
        tailf:info "Advertise ORF capability to the peer";
        leaf-list prefix-list {
          tailf:info "Advertise prefixlist ORF capability to this neighbor";
          tailf:cli-flat-list-syntax;
          max-elements 1;
          type enumeration {
            enum both {
              tailf:info "Capability to SEND and RECEIVE the ORF to/from this neighbor";
            }
            enum receive {
              tailf:info "Capability to RECEIVE the ORF from this neighbor";
            }
            enum send {
              tailf:info "Capability to SEND the ORF to this neighbor";
            }
          }
        }
      }
    }

    // router bgp * / neighbor * description
    leaf description {
      tailf:info "Neighbor specific description";
      tailf:cli-multi-value;
      tailf:cli-preformatted;
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;Up to 80 characters describing this neighbor";
      }
    }

    // router bgp * / neighbor * distribute-list *
    uses router-bgp-neighbor-distribute-list-grouping;

    // router bgp * / neighbor * dmzlink-bw
    leaf dmzlink-bw {
      tailf:info "Propagate the DMZ link bandwidth";
      tailf:cli-full-command;
      type empty;
    }

    // router bgp * / neighbor * filter-list *
    list filter-list {
      tailf:info "Establish BGP filters";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      key direction;
      leaf direction {
        type enumeration {
          enum in {
            tailf:info "Filter incoming routes";
          }
          enum out {
            tailf:info "Filter outgoing routes";
          }
        }
      }
      leaf as-path-list {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        type string {
          tailf:info "WORD;;Access-list number or name";
        }
      }
    }

    // router bgp * / neighbor * next-hop-self ?
    container next-hop-self-arg {
      tailf:cli-drop-node-name;
      leaf next-hop-self {
        type string;
      }
    }

    // router bgp * / neighbor * next-hop-unchanged
    leaf next-hop-unchanged {
      tailf:info "Propagate the iBGP paths's next hop unchanged for this neighbor";
      tailf:cli-full-command;
      type empty;
    }

    // router bgp * / neighbor * shutdown
    container shutdown {
      tailf:info "Administratively shut down this neighbor";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      presence true;
      // router bgp * / neighbor * shutdown graceful
      leaf graceful {
        tailf:info "Gracefully shut down this neighbor";

        type uint16 {
          tailf:info "<30-65535>;;time in seconds";
          range "30..65535";
        }
      }
      leaf local-preference {
        tailf:info "Set Local Preference for Gshut routes";
        type uint32 {
          tailf:info "<1-4294967295>;;Local Preference";
          range "1..4294967295";
        }
      }
    }

    // router bgp * / neighbor * translate-update
    container translate-update {
      tailf:info "Translate Update to MBGP format";
      container multicast {
        tailf:info "Address Family modifier";
        tailf:cli-delete-when-empty;
        tailf:cli-reset-container;
        presence true;
        leaf unicast {
          tailf:info "Address Family modifier";
          type empty;
        }
      }
    }

    // router bgp * / neighbor * unsuppress-map
    leaf unsuppress-map {
      tailf:info "Route-map to selectively unsuppress suppressed routes";
      tailf:cli-full-command;
      type string {
        tailf:info "WORD;;Name of route map";
      }
    }

    // router bgp * / neighbor * weight
    leaf weight {
      tailf:info "Set default weight for routes from this neighbor";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<0-65535>;;default weight";
        range "0..65535";
      }
    }

    // router bgp * / neighbor * ha-mode
    container ha-mode {
      tailf:info "high availability mode";
      container graceful-restart {
        tailf:info "graceful-restart for this peer";
        presence true;
        leaf disable {
          tailf:info "disable graceful-restart";
          type empty;
        }
      }
      container sso {
        tailf:info "stateful-switchover support for this peer";
        presence true;
        leaf disable {
          tailf:info "disable stateful-switchover";
          type empty;
        }
      }
    }

    // router bgp * / neighbor * suppress-signaling-protocol
    container suppress-signaling-protocol {
      tailf:info "suppress VPLS signaling protocol";
      leaf ldp {
        tailf:info "suppress ldp signaling, enable bgp signaling";
        tailf:cli-full-command;
        type empty;
      }
    }

    // router bgp * / neighbor * prefix-length-size
    leaf prefix-length-size {
      tailf:info "Packet Level storage size for Prefixes";
      type uint8 {
        tailf:info "<1-2>;;Storage size in bytes";
        range "1..2";
      }
    }
  }

  // router bgp * / address-family * / aggregate-address *
  grouping router-bgp-aggregate-address-content-grouping {

    // router bgp * / address-family * / aggregate-address * as-set
    leaf as-set {
      tailf:info "Generate AS set path information";
      type empty;
    }

    // router bgp * / address-family * / aggregate-address * summary-only
    leaf summary-only {
      tailf:info "Filter more specific routes from updates";
      type empty;
    }

    // router bgp * / address-family * / aggregate-address * attribute-map
    leaf attribute-map {
      tailf:info "Set attributes of aggregate";
      type string {
        tailf:info "WORD;;Route map for parameter control";
      }
    }

    // router bgp * / address-family * / aggregate-address * advertise-map
    leaf advertise-map {
      tailf:info "Set condition to advertise attribute";
      type string {
        tailf:info "WORD;;Route map to control attribute advertisement";
      }
    }

    // router bgp * / address-family * / aggregate-address * suppress-map
    leaf suppress-map {
      tailf:info "Conditionally filter more specific routes from updates";
      type string {
        tailf:info "WORD;;Route map for suppression";
      }
    }

    // router bgp * / address-family * / aggregate-address * as-override
    leaf as-override {
      tailf:info "Override matching AS-number while sending update";
      type empty;
    }

    // router bgp * / address-family * / aggregate-address * route-map
    leaf route-map {
      tailf:info "Set parameters of aggregate";
      type string {
        tailf:info "WORD;;Route map for parameter control";
      }
    }
  }

  // router bgp * /
  // router bgp * / address-family *
  grouping router-bgp-af-grouping {

    // router bgp * / address-family * / synchronization
    leaf synchronization {
      tailf:info "Perform IGP synchronization";
      tailf:cli-full-command;
      type empty;
    }

    // router bgp * / address-family * / table-map
    choice table-map-choice {
      leaf table-map {
        tailf:info "Map external entry attributes into routing table";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;route-map name";
        }
      }
      container table-map-filter {
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf table-map {
          tailf:info "Map external entry attributes into routing table";
          tailf:cli-incomplete-command;
          type string {
            tailf:info "WORD;;route-map name";
          }
        }
        leaf filter {
          tailf:info "Selective route download";
          type empty;
        }
      }
    }

    // router bgp * / address-family * / bgp
    container bgp-af {
      tailf:cli-drop-node-name;
      container bgp {
        tailf:info "BGP specific commands";

        // router bgp * / address-family * / bgp redistribute-internal
        leaf redistribute-internal {
          tailf:info "Allow redistribution of iBGP into IGPs (dangerous)";
          tailf:cli-full-command;
          type empty;
        }

        // router bgp * / address-family * / bgp dampening
        container dampening {
          tailf:info "Enable route-flap dampening";
          presence true;
          choice dampening-choice {
            leaf route-map {
              tailf:info "Route-map to specify criteria for dampening";
              type string {
                tailf:info "WORD;;route-map name";
              }
            }
            container dampen {
              tailf:cli-drop-node-name;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              leaf half-life-time {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<1-45>;;Half-life time for the penalty";
                  range "1..45";
                }
              }
              leaf reuse-time {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type uint16 {
                  tailf:info "<1-20000>;;Value to start reusing a route";
                  range "1..20000";
                }
              }
              leaf suppress-time {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type uint16 {
                  tailf:info "<1-20000>;;Value to start suppressing a route";
                  range "1..20000";
                }
              }
              leaf max-suppress-time {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<1-255>;;Maximum duration to suppress a stable route";
                  range "1..255";
                }
              }
            }
          }
        }

        // router bgp * / address-family * / bgp additional-paths
        container additional-paths {
          tailf:info "Additional paths in the BGP table";

          // router bgp * / address-family * / bgp additional-paths select
          container select {
            tailf:info "Selection criteria to pick the paths";
            tailf:cli-compact-syntax;

            // router bgp * / address-family * / bgp additional-paths select all
            leaf all {
              tailf:info "Select all available paths";
              type empty;
            }

            // router bgp * / address-family * / bgp additional-paths select group-best
            leaf group-best {
              tailf:info "Select group-best path";
              type empty;
            }

            // router bgp * / address-family * / bgp additional-paths select best
            leaf best {
              tailf:info "Select best N paths";
              type uint8 {
                tailf:info "<2-3>;;Number of best paths in additional paths to be selected";
                range "2..3";
              }
            }

            // router bgp * / address-family * / bgp additional-paths select backup
            container backup {
              tailf:info "Select backup path";
              tailf:cli-reset-container;
              tailf:cli-delete-when-empty;
              presence true;
              leaf best-external {
                tailf:info "Select best-external path";
                type empty;
              }
            }
          }

          // router bgp * / address-family * / bgp additional-paths receive
          // router bgp * / address-family * / bgp additional-paths send
          choice send-receive-choice {
            leaf receive {
              tailf:info "Receive additional paths from neighbors";
              tailf:cli-full-command;
              type empty;
            }
            container send {
              tailf:info "Send additional paths to neighbors";
              tailf:cli-delete-when-empty;
              presence true;
              leaf receive {
                tailf:info "Receive additional paths from neighbors";
                type empty;
              }
            }
          }

          // router bgp * / address-family * / bgp additional-paths install
          leaf install {
            tailf:info "Additional paths to install into RIB";
            tailf:cli-full-command;
            type empty;
          }
        }

        // router bgp * / address-family * / bgp bestpath igp-metric ignore
        container bestpath {
          tailf:info "Change the default bestpath selection";
          container igp-metric {
            tailf:info "igp metric";
            leaf ignore {
              tailf:info "Ignore igp metric in bestpath selection";
              type empty;
            }
          }
        }

        // router bgp * / address-family * / bgp suppress-inactive
        leaf suppress-inactive {
          tailf:info "Suppress routes that are not in the routing table";
          tailf:cli-full-command;
          type empty;
        }

        // router bgp * / address-family * / bgp dmzlink-bw
        leaf dmzlink-bw {
          tailf:info "Use DMZ Link Bandwidth as weight for BGP multipaths";
          tailf:cli-full-command;
          type empty;
        }

        // router bgp * / address-family * / bgp slow-peer detection
        container slow-peer {
          tailf:info "Configure slow-peer";
          container detection {
            tailf:info "Slow-peer detection";
            presence true;
          }
        }

        // router bgp * / address-family * / bgp soft-reconfig-backup
        leaf soft-reconfig-backup {
          tailf:info "Use soft-reconfiguration inbound only when route-refresh is not negotiated";
          tailf:cli-full-command;
          type empty;
        }

        // router bgp * / address-family * / bgp nexthop
        container nexthop {
          tailf:info "Nexthop tracking commands";

          // router bgp * / address-family * / bgp nexthop route-map
          leaf route-map {
            tailf:info "Route map for valid nexthops";
            tailf:cli-full-command;
            type string {
              tailf:info "WORD;;route-map name";
            }
          }

          // router bgp * / address-family * / bgp nexthop trigger
          container trigger {
            tailf:info "Nexthop triggering";

            // router bgp * / address-family * / bgp nexthop trigger delay
            leaf delay {
              tailf:cli-full-command;
              tailf:info "Set the delay to tigger nexthop tracking";
              type uint8 {
                tailf:info "<0-100>;;Delay value (seconds)";
                range "0..100";
              }
            }

            // router bgp * / address-family * / no bgp nexthop trigger enable
            leaf enable {
              tailf:info "Enable nexthop tracking";
              tailf:cli-full-command;
              tailf:cli-boolean-no;
              type boolean;
              default true;
            }
          }
        }

        // router bgp * / address-family * / bgp scan-time
        leaf scan-time {
          tailf:cli-full-command;
          tailf:info "Configure background scanner interval";
          type uint8 {
            tailf:info "<5-60>;;Scanner interval (seconds)";
            range "5..60";
          }
        }

        // router bgp * / address-family * / bgp inject-map *
        list inject-map {
          tailf:info "Routemap which specifies prefixes to inject";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-incomplete-command;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;route-map name";
            }
          }
          leaf exist-map {
            tailf:info "Routemap which specifies exist condition";
            type string {
              tailf:info "WORD;;route-map name";
            }
          }
          leaf copy-attributes {
            tailf:info "Copy attributes from aggregate";
            type empty;
          }
        }

        // router bgp * / address-family * / bgp recursion host
        container recursion {
          tailf:info "recursion rule for the nexthops";
          leaf host {
            tailf:info "recursion via host for the nexthops";
            type empty;
          }
        }

        // router bgp * / address-family * / bgp bgp mpls-local-label
        leaf mpls-local-label {
          tailf:info "Installs local label for ALL /32 prefixes";
          type empty;
        }
      }
    }

    // router bgp * / address-family * / network * *
    list network {
      tailf:info "Specify a network to announce via BGP";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      key "number mask";
      leaf number {
        type union {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Network number";
          }
          type ios:ipv6-prefix {
            tailf:info "X:X:X:X::X/<0-128>;;IPv6 prefix";
          }
        }
      }
      leaf mask {
        tailf:info "Network mask";
        tailf:cli-expose-key-name;
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Network mask";
        }
      }
      choice option-choice {
        leaf backdoor {
          tailf:info "Specify a BGP backdoor route";
          type empty;
        }
        leaf route-map {
          tailf:info "Route-map to modify the attributes";
          type string {
            tailf:info "WORD;;Name of the route map";
          }
        }
      }
    }
    // router bgp * / address-family * / network * *
    container network-address {
      tailf:cli-drop-node-name;
      list network {
        tailf:info "Specify a network to announce via BGP";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        key number;
        leaf number {
          type union {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Network number";
            }
            type ios:ipv6-prefix {
              tailf:info "X:X:X:X::X/<0-128>;;IPv6 prefix";
            }
          }
        }
        choice option-choice {
          leaf backdoor {
            tailf:info "Specify a BGP backdoor route";
            type empty;
          }
          leaf route-map {
            tailf:info "Route-map to modify the attributes";
            type string {
              tailf:info "WORD;;Name of the route map";
            }
          }
        }
      }
    }

    // router bgp * / address-family * / aggregate-address *
    list aggregate-address {
      tailf:info "Configure BGP aggregate entries";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      key "address mask";
      leaf address {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Aggregate address";
        }
      }
      leaf mask {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Aggregate mask";
        }
      }
      uses router-bgp-aggregate-address-content-grouping;
    }

    // router bgp * / address-family * / aggregate-address *
    container aggregate-addres-ipv6 {
      tailf:cli-drop-node-name;
      list aggregate-address {
        tailf:info "Configure BGP aggregate entries";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        key address;
        leaf address {
          type ipv6-prefix {
            tailf:info "X:X:X:X::X/<0-128>;;IPv6 Network number";
          }
        }
        uses router-bgp-aggregate-address-content-grouping;
      }
    }

    // router bgp * / address-family * / redistribute
    container redistribute {
      tailf:info "Redistribute information from another routing protocol";

      // router bgp * / address-family * / redistribute bgp
      container bgp {
        tailf:info "Border Gateway Protocol (BGP)";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-delete-when-empty;
        leaf as-no {
          tailf:cli-drop-node-name;
          tailf:cli-remove-before-change;
          type bgp-as-no-type;
        }
        uses router-bgp-redistribute-grouping {
          refine "metric" {
            tailf:cli-break-sequence-commands;
          }
        }
      }

      // router bgp * / address-family * / redistribute connected
      container connected {
        tailf:info "Connected";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-bgp-redistribute-grouping;
      }

      // router bgp * / address-family * / redistribute static
      container static {
        tailf:info "Static routes";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-bgp-redistribute-grouping;
      }

      // router bgp * / address-family * / redistribute dvmrp
      container dvmrp {
        tailf:info "Redistribution of DVMRP into BGP IPv4 Multicast";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-delete-when-empty;
        presence true;
        uses route-map-metric-grouping;
      }

      // router bgp * / address-family * / redistribute eigrp *
      list eigrp {
        tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-remove-before-change;
        key as-no;
        leaf as-no {
          type eigrp-as-no-type;
        }
        uses router-bgp-redistribute-grouping;
      }

      // router bgp * / address-family * / redistribute isis
      container isis {
        tailf:info "ISO IS-IS";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-bgp-redistribute-isis-grouping;
        uses router-bgp-redistribute-grouping;

        // router bgp * / address-family * / redistribute isis *
        list isis-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-remove-before-change;
          key name;
          leaf name {
            tailf:cli-disallow-value "level-1|level-2|level-1-2|metric|clns|ip"+
              "|route-map|subnets|include-connected";
            type string {
              tailf:info "WORD;;ISO routing area tag";
            }
          }
          uses router-bgp-redistribute-isis-grouping;
          uses router-bgp-redistribute-grouping;
        }
      }

      // router bgp * / address-family * / redistribute iso-igrp
      container iso-igrp {
        tailf:info "IGRP for OSI networks";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        uses route-map-metric-grouping;
        list iso-igrp-area {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-remove-before-change;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Pointer to route-map entries";
              // match any but route-map
              pattern '^([^r].*)|(r^[o].*)|(ro[^u].*)|'
                +'(rou[^t].*)|(rout[^e].*)|(route[^\-].*)|'
                +'(route-[^m].*)|(route-m[^a].*)|'
                +'(route-ma[^p])|(route-map..*)';
            }
          }
          uses route-map-metric-grouping;
        }
      }

      // router bgp * / address-family * / redistribute mobile
      container mobile {
        tailf:info "Mobile routes";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-bgp-redistribute-grouping;
      }

      // router bgp * / address-family * / redistribute odr
      container odr {
        tailf:info "On Demand stub Routes";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-bgp-redistribute-grouping;
      }

      // router bgp * / address-family * / redistribute ospf *
      list ospf {
        tailf:info "Open Shortest Path First (OSPF)";
        tailf:cli-suppress-mode;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        tailf:cli-remove-before-change;
        key id;
        leaf id {
          type uint16 {
            tailf:info "<1-65535>;;Process ID";
            range "1..65535";
          }
        }
        leaf vrf {
          // Note: only one vrf per entry, since must match af vrf
          tailf:info "VPN Routing/Forwarding Instance";
          tailf:cli-diff-dependency "/ios:ip/vrf";
          tailf:cli-diff-dependency "/ios:vrf/definition";
          type string {
            tailf:info "WORD;;VPN Routing/Forwarding Instance (VRF) name";
          }
        }
        uses router-bgp-redistribute-ospf-grouping;
      }

      // router bgp * / address-family * / redistribute rip
      container rip {
        tailf:info "Routing Information Protocol (RIP)";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-bgp-redistribute-grouping;

        // router bgp * / address-family * / redistribute rip *
        list rip-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          key id;
          leaf id {
            tailf:cli-suppress-range;
            tailf:cli-disallow-value "metric|subnets|route-map|include-connected";
            type string {
              tailf:info "WORD;;User selected string identifying this process";
            }
          }
          uses router-bgp-redistribute-grouping;
        }
      }

      // router bgp * / address-family * / redistribute lisp
      container lisp {
        tailf:info "Locator ID Separation Protocol (LISP)";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-bgp-redistribute-grouping;
      }
    }

    // router bgp * / address-family * / snmp context
    container snmp {
      tailf:info "Modify snmp parameters";
      list context {
        tailf:info "Configure a SNMP context";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        max-elements 1;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Context Name";
          }
        }
      }
    }

    // router bgp * / neighbor *
    // router bgp * / address-family * / neighbor *
    container neighbor-tag {
      tailf:cli-drop-node-name;
      list neighbor {
        tailf:info "Specify a neighbor router";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          //cli:parse-disallow-type all-address;
          cli:parse-disallow-type inet:ip-address;
          cli:parse-disallow-type ios:ios-ipv6-address;
          type string {
            tailf:info "WORD;;Neighbor tag";
          }
        }
        // router bgp * / address-family * / neighbor * peer-group
        leaf peer-group {
          tailf:info "Configure peer-group";
          tailf:cli-delete-container-on-delete;
          tailf:cli-full-command;
          type empty;
        }
        uses router-bgp-neighbor-grouping;
      }
    }

    // router bgp * / neighbor *
    // router bgp * / address-family * / neighbor *
    list neighbor {
      tailf:info "Specify a neighbor router";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      key id;
      leaf id {
        tailf:cli-diff-dependency "../../neighbor-tag/neighbor";
        type union {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Neighbor address";
          }
          type inet:ipv6-address {
            tailf:info "X:X:X:X::X;;Neighbor IPv6 address";
          }
          type ios-ipv6-address;
        }
      }
      // router bgp * / address-family * / neighbor * peer-group
      leaf peer-group {
        tailf:info "Member of the peer-group";
        tailf:cli-delete-container-on-delete;
        tailf:cli-full-command;
        tailf:cli-diff-set-after "../remote-as";
        tailf:cli-suppress-leafref-in-diff;
        tailf:non-strict-leafref {
          path "/ios:router/bgp/neighbor-tag/neighbor/id";
        }
        type string {
          tailf:info "WORD;;peer-group name";
        }
      }
      uses router-bgp-neighbor-grouping;
    }

    // router bgp * / address-family * / maximum-paths
    container maximum-paths {
      tailf:info "Forward packets over multiple paths";

      // router bgp * / address-family * / maximum-paths
      uses router-bgp-max-path-grouping;

      // router bgp * / address-family * / maximum-paths eibgp
      container eibgp {
        tailf:info "Both eBGP and iBGP paths as multipath";
        uses router-bgp-max-path-grouping;
      }

      // router bgp * / address-family * / maximum-paths ibgp
      container ibgp {
        tailf:info "iBGP-multipath";
        choice ibgp-choice {
          default b;
          case a {
            container unequal-cost {
              tailf:info "Perform Un-Equal cost multipath selection";
              uses router-bgp-max-path-grouping;
            }
          }
          case b {
            uses router-bgp-max-path-grouping;
          }
        }
      }

      // router bgp * / address-family * / maximum-paths import
      leaf import {
        tailf:info "Maximum import paths";
        type uint16 {
          tailf:info "<1-16>;;Number of import paths";
          range "1..16";
        }
      }
    }

    // router bgp * / address-family * / maximum-secondary-paths
    container maximum-secondary-paths {
      tailf:info "Maximum secondary paths";
      leaf paths {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        tailf:cli-diff-set-after "../eibgp" {
          tailf:cli-when-target-delete;
        }
        type uint8 {
          tailf:info "<0-32>;;Number of secondary paths";
          range "0..32";
        }
      }
      leaf eibgp {
        tailf:info "Both eBGP and iBGP paths as secondary multipath";
        type uint8 {
          tailf:info "<0-32>;;Number of secondary paths";
          range "0..32";
        }
      }
      leaf ibgp {
        tailf:info "iBGP-secondary-multipath";
        type uint8 {
          tailf:info "<0-32>;;Number of secondary paths";
          range "0..32";
        }
      }
    }

    // router bgp * / import path
    container import {
      tailf:info "Configure path import";
      container path {
        tailf:info "Path selection and path limit";

        // router bgp * / import path selection
        container selection {
          tailf:info "Path selection policy";
          choice selection-choice {
            leaf all {
              tailf:info "Import all available paths";
              type empty;
            }
            container bestpath {
              tailf:info "Import the best available path.";
              tailf:cli-delete-when-empty;
              presence true;
              leaf strict {
                tailf:info "Do not fallback to best available path";
                type empty;
              }
            }
            container multipaths {
              tailf:info "Import all multipaths.";
              tailf:cli-delete-when-empty;
              presence true;
              leaf strict {
                tailf:info "Do not fallback to best available path";
                type empty;
              }
            }
          }
        }

        // router bgp * / import path limit
        leaf limit {
          tailf:info "Per net imported path limit";
          type uint8 {
            tailf:info "<2-255>;;Maximum number of paths that can be imported into a net";
            range "2..255";
          }
        }
      }
    }

    // router bgp * / address-family * / default-information originate
    container default-information {
      tailf:info "Control distribution of default information";
      leaf originate {
        tailf:info "Distribute a default route";
        type empty;
      }
    }

    // router bgp * / address-family * / default-metric
    leaf default-metric {
      tailf:info "Set metric of redistributed routes";
      tailf:cli-full-command;
      type uint32 {
        tailf:info "<1-4294967295>;;Default metric";
        range "1..4294967295";
      }
    }

    // router bgp * / address-family * / distribute-list *
    uses router-distribute-list-grouping;

    // router bgp * / address-family * / distance
    container distance {
      tailf:info "Define an administrative distance";

      // router bgp * / address-family * / distance bgp
      container bgp {
        tailf:info "BGP distance";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf extern-as {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<1-255>;;Distance for routes external to the AS";
            range "1..255";
          }
        }
        leaf internal-as {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<1-255>;;Distance for routes internal to the AS";
            range "1..255";
          }
        }
        leaf local {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-255>;;Distance for local routes";
            range "1..255";
          }
        }
      }

      // router bgp * / address-family * / distance *
      list adm-distance {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "srcip wildbits";
        leaf distance {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type uint16 {
            tailf:info "<1-255>;;Administrative distance";
            range "1..255";
          }
        }
        leaf srcip {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP Source address";
          }
        }
        leaf wildbits {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Wildcard bits";
          }
        }
        leaf access-list {
          tailf:cli-drop-node-name;
          type std-ip-acl-type;
        }
      }
    }

    // router bgp * / address-family * / auto-summary
    // router bgp * / address-family * / no auto-summary
    leaf auto-summary {
      // Cisco doc node: Disabled by default
      tailf:info "Enable automatic network number summarization";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
    }
  }

  // router bgp * / address-family *
  grouping router-bgp-af2-grouping {

    // router bgp * / address-family * / segment-routing mpls
    container segment-routing {
      tailf:info "BGP Segment Routing Config";
      leaf mpls {
        tailf:info "BGP Segment Routing MPLS Config";
        tailf:cli-diff-dependency "/ios:segment-routing/mpls";
        type empty;
      }
    }
  }

  // router bgp * / bgp
  grouping router-bgp-bgp-grouping {

    // router bgp * / bgp
    container bgp {

      // router bgp * / bgp router-id
      choice router-id-choice {
        leaf router-id {
          tailf:info "Override configured router identifier (peers will reset)";
          tailf:cli-full-command;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Manually configured router identifier";
          }
        }
        // router bgp * / bgp router-id interface
        container router-id-interface {
          tailf:cli-drop-node-name;
          container router-id {
            tailf:info "Override configured router identifier (peers will reset)";
            tailf:cli-incomplete-command;
            tailf:cli-incomplete-no;
            container interface {
              tailf:info "Interface name";
              uses interface-name-grouping;
            }
          }
        }
        // router bgp * / bgp router-id vrf auto-assign
        container router-id-vrf {
          tailf:cli-drop-node-name;
          container router-id {
            tailf:info "Override configured router identifier (peers will reset)";
            tailf:cli-incomplete-command;
            tailf:cli-incomplete-no;
            container vrf {
              tailf:info "vrf-specific router id configuration";
              leaf auto-assign {
                tailf:info "Automatically assign per-vrf bgp router id";
                type empty;
              }
            }
          }
        }
        // router bgp * / bgp router-id auto-assign
        container router-id-conf {
          tailf:cli-drop-node-name;
          container router-id {
            tailf:info "Override configured router identifier (peers will reset)";
            tailf:cli-incomplete-command;
            tailf:cli-incomplete-no;
            leaf auto-assign {
              tailf:info "Automatically assign bgp router id";
              type empty;
            }
          }
        }
      }

      // router bgp * / bgp advertise-best-external
      leaf advertise-best-external {
        tailf:info "Advertise best external path to internal peers";
        type empty;
      }

      // router bgp * / bgp asnotation dot
      container asnotation {
        tailf:info "Change the default asplain notation";
        leaf dot {
          tailf:info "asdot notation";
          type empty;
        }
      }

      // router bgp * / bgp consistency-checker
      container consistency-checker {
        tailf:info "Consistency-checker";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf type {
          tailf:cli-drop-node-name;
          type enumeration {
            enum auto-repair {
              tailf:info "Auto-Repair";
            }
            enum "error-message" {
              tailf:info "Log Error-Msg";
            }
          }
        }
        leaf interval {
          tailf:info "Set the bgp consistency checker";
          type uint16 {
            tailf:info "<5-1440>;;Interval (minutes). Default 1440";
            range "5..1440";
          }
          default 1440;
        }
      }

      // router bgp * / no bgp fast-external-fallover
      leaf fast-external-fallover {
        tailf:info "Immediately reset session if a link to a directly connected external peer goes down";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // router bgp * / bgp always-compare-med
      leaf always-compare-med {
        tailf:info "Allow comparing MED from different neighbors";
        tailf:cli-full-command;
        type empty;
      }

      // router bgp * / bgp cluster-id
      leaf cluster-id {
        tailf:cli-full-command;
        type union {
          type uint32 {
            tailf:info "<1-4294967295>;;Route-Reflector Cluster-id as 32 bit quantity";
            range "1..4294967295";
          }
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Route-Reflector Cluster-id in IP address format";
          }
        }
      }

      // router bgp * / no bgp transport path-mtu-discovery
      container transport {
        tailf:info "global enable/disable transport session parameters";
        leaf path-mtu-discovery {
          tailf:info "transport path MTU discovery";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }
      }

      // router bgp * / no bgp enforce-first-as
      leaf enforce-first-as {
        tailf:info "Enforce the first AS for EBGP routes(default)";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // router bgp * / bgp client-to-client
      container client-to-client {
        tailf:info "Configure client to client route reflection";

        // router bgp * / no bgp client-to-client reflection
        leaf reflection {
          tailf:info "reflection of routes allowed";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }
      }

      // router bgp * / bgp log-neighbor-changes
      // router bgp * / no bgp log-neighbor-changes
      leaf log-neighbor-changes {
        tailf:info "Log neighbor up/down and reset reason";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
      }

      // router bgp * / bgp ha-mode sso
      container ha-mode {
        tailf:info "Select BGP High Availability mode";
        container sso {
          tailf:info "BGP High Availability NSR sso mode";
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          presence true;
          leaf prefer {
            tailf:info "Perfer BGP High Availability NSR sso mode";
            type empty;
          }
        }
      }

      // router bgp * / bgp confederation
      container confederation {
        tailf:info "AS confederation parameters";

        // router bgp * / bgp confederation identifier
        leaf identifier {
          tailf:info "as number";
          type bgp-as-no-type;
        }

        // router bgp * / bgp confederation peers
        container peers {
          tailf:info "Peer ASs in BGP confederation";
          leaf-list as-no {
            tailf:cli-drop-node-name;
            tailf:cli-flat-list-syntax;
            type bgp-as-no-type;
          }
        }
      }

      // router bgp * / bgp deterministic-med
      leaf deterministic-med {
        tailf:info "Pick the best-MED path among paths advertised from the neighboring AS";
        tailf:cli-full-command;
        type empty;
      }

      // router bgp * / bgp listen
      container listen {
        tailf:info "Neighbor subnet range listener";

        // router bgp * / bgp listen range * peer-group *
        list range {
          tailf:info "Subnet network range";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key "network-length peer-group";
          leaf network-length {
            type ios:ipv4-prefix {
              tailf:info "A.B.C.D/nn;;Subnet range <network>/<length>, e.g., 10.0.0.0/24";
            }
          }
          leaf peer-group {
            tailf:info "Member of the peer-group";
            tailf:cli-expose-key-name;
            type string {
              tailf:info "WORD;;peer-group name";
            }
          }
        }

        // router bgp * / bgp listen limit
        leaf limit {
          tailf:info "Set the max limit for the dynamic subnet range neighbors";
          type uint32 {
            tailf:info "<1-5000>;;max number. Default 100";
            range "1..5000";
          }
          default 100;
        }
      }

      // router bgp * / bgp update-delay
      leaf update-delay {
        tailf:info "Set the max initial delay for sending update";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<1-3600>;;Delay value (seconds). Default 120";
          range "1..3600";
        }
        default 120;
      }

      // router bgp * / bgp graceful-restart
      container graceful-restart-conf {
        tailf:cli-drop-node-name;
        container graceful-restart {
          tailf:info "Graceful restart capability parameters";
          tailf:cli-incomplete-no;
          tailf:cli-incomplete-command;

          // router bgp * / bgp graceful-restart restart-time
          leaf restart-time {
            tailf:info "Set the max time needed to restart and come back up";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<1-3600>;;Delay value (seconds). Default 120";
              range "1..3600";
            }
            default 120;
          }

          // router bgp * / bgp graceful-restart stalepath-time
          leaf stalepath-time {
            tailf:info "Set the max time to hold onto restarting peer's stale paths";
            type uint16 {
              tailf:info "<1-3600>;;Delay value (seconds). Default 360";
              range "1..3600";
            }
            default 360;
          }
        }
      }
      // router bgp * / bgp graceful-restart
      leaf graceful-restart {
        tailf:info "Graceful restart capability parameters";
        tailf:cli-full-command;
        type empty;
      }

      // router bgp * / no bgp regexp deterministic
      container regexp {
        tailf:info "Select regular expression engine";
        leaf deterministic {
          tailf:info "Enable bounded-execution-time regular expression engine";
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }
      }

      // router bgp * / bgp bestpath
      container bestpath {
        tailf:info "Change the default bestpath selection";

        // router bgp * / bgp bestpath compare-routerid
        leaf compare-routerid {
          tailf:info "Compare router-id for identical EBGP paths";
          tailf:cli-full-command;
          type empty;
        }

        // router bgp * / bgp bestpath cost-community ignore
        container cost-community {
          tailf:info "cost community";
          leaf ignore {
            tailf:info "Ignore cost communities in bestpath selection";
            type empty;
          }
        }

        // router bgp * / bgp bestpath med
        container med {
          tailf:info "MED attribute";
          tailf:cli-compact-syntax;
          leaf confed {
            tailf:info "Compare MED among confederation paths";
            type empty;
          }
          leaf missing-as-worst {
            tailf:info "Treat missing MED as the least preferred one";
            type empty;
          }
        }

        // router bgp * / bgp bestpath as-path multipath-relax
        container as-path {
          leaf multipath-relax {
            type empty;
          }
        }
      }

      // router bgp * / bgp maxas-limit
      leaf maxas-limit {
        tailf:info "Allow AS-PATH attribute from any neighbor imposing a limit on number of ASes";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<1-2000>;;Number of ASes in the AS-PATH attribute";
          range "1..2000";
        }
      }

      // router bgp * / bgp default
      container default {
        tailf:info "Configure BGP defaults";

        // router bgp * / no bgp default ipv4-unicast
        leaf ipv4-unicast {
          tailf:info "Activate ipv4-unicast for a peer by default";
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }

        // router bgp * / no bgp default ipv4-activate
        leaf ipv4-activate {
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }

        // router bgp * / no bgp default ipv6-nexthop
        leaf ipv6-nexthop {
          tailf:info "Default IPv6 nexthop format";
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }

        // router bgp * / bgp default local-preference
        leaf local-preference {
          tailf:info "local preference (higher=more preferred)";
          type uint32 {
            tailf:info "<0-4294967295>;;Configure default local preference value. Default 100";
            range "1..4294967295";
          }
          default 100;
        }

        // no bgp default route-target filter
        container route-target {
          tailf:info "Control behavior based on Route-Target attributes";
          leaf filter {
            tailf:info "Control automatic VPN Route-Target filtering";
            tailf:cli-boolean-no;
            type boolean;
            default true;
          }
        }
      }

      // router bgp * / bgp mpls-local-label
      leaf mpls-local-label {
        tailf:info "Installs local label for ALL /32 prefixes";
        type empty;
      }

      // router bgp * / bgp rpki server tcp * * refresh
      container rpki {
        tailf:info "RPKI parameters";
        container server {
          tailf:info "RPKI cache server parameters";
          list tcp {
            tailf:info "use the TCP protocol to connect to RPKI cache server";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key "address port";
            leaf address {
              type union {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IP address of RPKI Cache server";
                }
                type inet:ipv6-address {
                  tailf:info "X:X:X:X::X;;IPv6 address of RPKI cache server";
                }
              }
            }
            leaf port {
              tailf:cli-expose-key-name;
              tailf:info "Port number of RPKI Cache";
              type uint16 {
                tailf:info "<1-65535>;;Port number";
              }
            }
            leaf refresh {
              tailf:info "Refresh time";
              tailf:cli-remove-before-change;
              type uint16 {
                tailf:info "<1-65535>;;Refresh time in seconds";
                range "1..65535";
              }
            }
          }
        }
      }
    }

    // router bgp * / timers bgp
    container timers {
      tailf:info "Adjust routing timers";
      container bgp {
        tailf:info "BGP timers";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf keepalive {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<0-65535>;;Keepalive interval";
            range "0..65535";
          }
        }
        leaf holdtime {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-65535>;;Holdtime";
            range "0..65535";
          }
        }
        leaf min-holdtime {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-65535>;;Minimum hold time from neighbor";
            range "0..65535";
          }
        }
      }
    }
  }

  // router ospfv3 * / address-family ipv4 XX
  grouping router-ospf-af-grouping {
  }

  // router ospfv3 * / address-family ipv4 unicast
  // router ospfv3 * / address-family ipv6 unicast
  grouping router-ospfv3-af-grouping {

    // router ospfv3 * / address-family * / capability
    container capability {
      tailf:info "Enable a specific feature";
      leaf vrf-lite {
        tailf:info "Do not perform PE specific checks";
        type empty;
      }
    }

    // router ospfv3 * / address-family * / discard-route
    container discard-route {
      tailf:info "Enable or disable discard-route installation";

      // router ospfv3 * / address-family * / no discard-route external
      leaf external {
        tailf:info "Discard route for summarised redistributed routes";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // router ospfv3 * / address-family * / no discard-route internal
      leaf internal {
        tailf:info "Discard route for summarised inter-area routes";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }
    }
  }


  // router ospf * /
  // router ospf * vrf * /
  // router ospfv3 * / address-family ipv4 unicast /
  // router ospfv3 * / address-family ipv6 /
  // router ospfv3 * / address-family ipv4 unicast vrf * /
  grouping router-ospf-common-af-grouping {

    // router ospf * / default-information
    container default-information {
      tailf:info "Control distribution of default information";
      container originate {
        tailf:info "Distribute a default route";
        tailf:cli-compact-syntax;
        //tailf:cli-keep-when-empty;
        ios:trim-delete-when-empty "( originate)";
        presence true;
        leaf always {
          tailf:info "Always advertise default route";
          type empty;
        }
        leaf metric {
          tailf:info "OSPF default metric";
          type uint32 {
            tailf:info "<0-16777214>;;OSPF metric";
            range "0..16777214";
          }
        }
        leaf metric-type {
          tailf:info "OSPF metric type for default routes";
          type ospf-metric-type;
          default 2;
        }
        leaf route-map {
          tailf:info "Route map reference";
          type string {
            tailf:info "WORD;;Route map name";
          }
        }
      }
    }

    // router ospf * / default-metric
    leaf default-metric {
      tailf:info "Set metric of redistributed routes";
      tailf:cli-full-command;
      type uint32 {
        tailf:info "<1-16777214>;;OSPF default metric";
        range "1..16777214";
      }
    }

    // router ospf * / distance
    container distance {
      tailf:info "Define an administrative distance";
      leaf weight {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-255>;;Administrative distance. Default 110";
          range "1..255";
        }
        default 110;
      }
      // router ospf * / distance *
      list distance-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key "ip-address wildcard-mask";
        leaf ip-address {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP source address";
          }
        }
        leaf wildcard-mask {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Wildcard bits";
          }
        }
        leaf weight {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type uint8 {
            tailf:info "<1-255>;;Administrative distance";
            range "1..255";
          }
        }
        leaf access-list {
          tailf:cli-drop-node-name;
          type std-ip-acl-type;
        }
      }

      // router ospf * / distance ospf
      container ospf {
        tailf:info "OSPF routes Administrative distance";
        tailf:cli-compact-syntax;
        leaf intra-area {
          tailf:info "Intra-area routes";
          type uint32 {
            tailf:info "<1-255>;;Distance for intra-area routes";
            range "1..255";
          }
        }
        leaf inter-area {
          tailf:info "Inter-area routes";
          type uint32 {
            tailf:info "<1-255>;;Distance for inter-area routes";
            range "1..255";
          }
        }
        leaf external {
          tailf:info "External routes";
          type uint32 {
            tailf:info "<1-255>;;Distance for external routes";
            range "1..255";
          }
        }
      }
    }

    // router ospf * / maximum-paths
    leaf maximum-paths {
      tailf:info "Forward packets over multiple paths";
      tailf:cli-full-command;
      type uint32 {
        tailf:info "<1-32>;;Number of paths. Default 4";
        range "1..32";
      }
      default 4;
    }

    // router ospf * / nsr
    leaf nsr {
      tailf:info "Enable non-stop routing";
      type empty;
    }

    // router ospf * / redistribute
    container redistribute {
      tailf:info "Redistribute information from another routing protocol";

      // router ospf * / redistribute connected
      container connected {
        tailf:info "Connected";
        tailf:cli-compact-syntax;
        //tailf:cli-keep-when-empty;
        ios:trim-delete-when-empty "( connected)";
        presence true;
        uses router-ospf-redistribute-grouping;
        uses router-ospf-route-map-grouping;
      }

      // router ospf * / redistribute static
      container static {
        tailf:info "Static routes";
        tailf:cli-compact-syntax;
        //tailf:cli-keep-when-empty;
        ios:trim-delete-when-empty "( static)";
        presence true;
        uses router-ospf-redistribute-grouping;
        uses router-ospf-route-map-grouping;
      }

      // router ospf * / redistribute odr
      container odr {
        tailf:info "On Demand stub Routes";
        tailf:cli-compact-syntax;
        //tailf:cli-keep-when-empty;
        ios:trim-delete-when-empty "( odr)";
        presence true;
        uses router-ospf-redistribute-grouping;
        uses router-ospf-route-map-grouping;
      }

      // router ospf * / redistribute bgp
      container bgp {
        tailf:info "Border Gateway Protocol (BGP)";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf as-no {
          tailf:cli-drop-node-name;
          tailf:cli-remove-before-change;
          tailf:cli-delete-container-on-delete;
          tailf:cli-diff-dependency "/ios:router/bgp";
          tailf:cli-diff-delete-before "/ios:router/bgp" {
            tailf:cli-when-target-set;
          }
          ios:trim-delete-when-empty "( redistribute bgp \\d+)";
          type bgp-as-no-type;
        }
        uses router-ospf-redistribute-grouping {
          refine metric {
            tailf:cli-break-sequence-commands;
          }
        }
        uses router-ospf-route-map-grouping;
      }

      // router ospf * / redistribute ospf *
      list ospf {
        tailf:info "Open Shortest Path First (OSPF)";
        tailf:cli-suppress-mode;
        //tailf:cli-keep-when-empty;
        tailf:cli-compact-syntax;
        ios:trim-delete-when-empty "( redistribute ospf \\d+)";
        key id;
        leaf id {
          tailf:cli-suppress-range;
          type uint16 {
            tailf:info "<1-65535>;;Process ID";
            range "1..65535";
          }
        }
        uses router-ospf-redistribute-grouping;
        uses redistribute-ospf-match-grouping;
        uses router-ospf-route-map-grouping;
      }

      // router ospf * / redistribute isis
      container isis {
        tailf:info "ISO IS-IS";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty; // NOTE: differs from the other protocols
        presence true;
        uses router-isis-level-grouping;
        uses router-ospf-redistribute-grouping;
        uses router-ospf-route-map-grouping;
      }

      // router ospf * / redistribute isis *
      container isis-area {
        tailf:cli-drop-node-name;
        list isis {
          tailf:info "ISO IS-IS";
          tailf:cli-suppress-mode;
          tailf:cli-compact-syntax;
          //tailf:cli-keep-when-empty;
          ios:trim-delete-when-empty "( redistribute isis \\S+)";
          key name;
          leaf name {
            tailf:cli-disallow-value "level-1|level-2|level-1-2|metric|metric-type|route-map|nssa-only|subnets|tag";
            type string {
              tailf:info "WORD;;ISO routing area tag";
            }
          }
          uses router-isis-level-grouping;
          uses router-ospf-redistribute-grouping;
          uses router-ospf-route-map-grouping;
        }
      }

      // router ospf * / redistribute eigrp *
      list eigrp {
        tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty; // NOTE: differs from the keep-when-empty above
        tailf:cli-compact-syntax;
        key as-no;
        leaf as-no {
          type eigrp-as-no-type;
        }
        uses router-ospf-redistribute-grouping;
        uses router-ospf-route-map-grouping;
      }

      // router ospf * / redistribute iso-igrp
      container iso-igrp {
        tailf:info "IGRP for OSI networks";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        presence true;
        leaf area-tag {
          tailf:cli-drop-node-name;
          tailf:cli-disallow-value "route-map";
          tailf:cli-optional-in-sequence;
          type string {
            tailf:info "WORD;;ISO routing area tag";
          }
        }
        uses router-ospf-route-map-grouping;
        uses router-ospf-redistribute-grouping;
      }

      // router ospf * / redistribute maximum-prefix
      container maximum-prefix {
        tailf:info "Maximum number of prefixes redistributed to protocol";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf number {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-4294967295>;;Maximum number of IP prefixes redistributed";
            range "1..4294967295";
          }
        }
        container threshold-warning-only-container {
          tailf:cli-drop-node-name;
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          leaf threshold {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-100>;;Threshold value (%) at which to generate a warning message";
              range "1..100";
            }
          }
          leaf warning-only {
            tailf:info "Only give warning message when limit is exceeded";
            tailf:cli-full-command;
            type empty;
          }
        }
      }

      // router ospf * / redistribute mobile
      container mobile {
        tailf:info "Mobile routes";
        tailf:cli-compact-syntax;
        presence true;
        uses router-ospf-redistribute-grouping;
        uses router-ospf-route-map-grouping;
      }

      // router ospf * / redistribute rip
      container rip {
        tailf:info "Routing Information Protocol (RIP)";
        tailf:cli-compact-syntax;
        //tailf:cli-keep-when-empty;
        ios:trim-delete-when-empty "( rip)";
        presence true;
        uses router-ospf-redistribute-grouping;
        uses router-ospf-route-map-grouping;

        // router ospf * / redistribute rip *
        list redistribute-list-rip {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;User selected string identifying this process";
            }
          }
          uses router-ospf-redistribute-grouping;
          uses router-ospf-route-map-grouping;
        }
      }

      // router ospf * / redistribute lisp subnets
      container lisp {
        tailf:info "Locator ID Separation Protocol (LISP)";
        container subnets {
          tailf:info "Consider subnets for redistribution into OSPF";
          tailf:cli-compact-syntax;
          tailf:cli-delete-when-empty;
          presence true;
        }
      }
    }
  }

  // router ospf * /
  // router ospfv3 * /
  // router ospf * vrf * /
  // router ospfv3 * / address-family ipv4 unicast
  // router ospfv3 * / address-family ipv6 unicast
  grouping router-ospf-common-grouping {

    // router ospf * / area
    list area {
      tailf:info "OSPF area parameters";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      ios:trim-empty-create "area \\S+" {
        cli:arguments "trimmed";
      }
      key id;
      leaf id {
        tailf:cli-suppress-range;
        type ospf-area-type;
      }

      // router ospf * / area * authentication
      container authentication {
        tailf:info "Enable authentication";
        tailf:cli-delete-when-empty;
        tailf:cli-reset-container;
        presence true;

        // router ospf * / area * authentication message-digest
        leaf message-digest {
          tailf:info "Use message-digest authentication";
          type empty;
        }

        // router ospf * / area * authentication null
        choice authentication-choice {
          leaf null {
            tailf:info "Use no authentication";
            tailf:cli-full-command;
            type empty;
          }
          // router ospf * / area * authentication key-chain
          leaf key-chain {
            tailf:info "Use a key-chain for cryptographic authentication keys";
            tailf:cli-full-command;
            type string {
              tailf:info "LINE;;name of key-chain";
            }
          }
        }
      }

      // router ospf * / area * nssa
      container nssa {
        tailf:info "Specify a NSSA area";
        tailf:cli-compact-syntax;
        //tailf:cli-keep-when-empty;
        ios:trim-delete-when-empty "( nssa)";
        tailf:cli-diff-dependency "../stub" {
          tailf:cli-trigger-on-set;
        }
        presence true;

        // router ospf * / area * nssa no-redistribution
        leaf no-redistribution {
          tailf:info "No redistribution into this NSSA area";
          type empty;
        }

        // router ospf * / area * nssa default-information-originate
        leaf default-information-originate {
          tailf:info "Originate Type 7 default into NSSA area";
          type empty;
        }

        // router ospf * / area * nssa metric
        leaf metric {
          tailf:info "OSPF default metric";
          when "../default-information-originate" {
            tailf:dependency "../default-information-originate";
          }
          type uint32 {
            tailf:info "<0-16777214>;;OSPF metric";
            range "0..16777214";
          }
        }

        // router ospf * / area * nssa metric-type
        leaf metric-type {
          tailf:info "OSPF metric type for default routes";
          type ospf-metric-type;
          default 2;
        }

        // router ospf * / area * nssa nssa-only
        leaf nssa-only {
          tailf:info "Limit default advertisement to this NSSA area";
          type empty;
        }

        // router ospf * / area * nssa no-ext-capability
        leaf no-ext-capability {
          tailf:info "Do not send domain specific capabilities into NSSA";
          type empty;
        }

        // router ospf * / area * nssa no-summary
        leaf no-summary {
          tailf:info "Do not send summary LSA into NSSA";
          type empty;
        }

        // router ospf * / area * nssa translate
        container translate {
          tailf:info "Translate LSA";
          container type7 {
            tailf:info "From Type 7 to Type 5";
            tailf:cli-compact-syntax;
            leaf always {
              tailf:info "Always translate LSAs on this ABR";
              type empty;
            }
            leaf suppress-fa {
              tailf:info "Suppress forwarding address in translated LSAs";
              type empty;
            }
          }
        }
      }

      // router ospf * / area * default-cost
      leaf default-cost {
        tailf:info "Set the summary default-cost of a NSSA/stub area";
        tailf:cli-full-command;
        tailf:cli-diff-delete-before "../nssa";
        type uint32 {
          tailf:info "<0-16777215;;Stub's advertised external route metric";
          range "0..16777215";
        }
      }

      // router ospf * / area * filter-list
      list filter-list {
        tailf:info "Filter networks between OSPF areas";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        key direction;
        leaf direction {
          type enumeration {
            enum in {
              tailf:info "Filter networks sent to this area";
            }
            enum out {
              tailf:info "Filter networks sent from this area";
            }
          }
        }
        leaf prefix {
          tailf:cli-prefix-key;
          tailf:info "Filter prefixes between OSPF areas";
          type string {
            tailf:info "WORD;;Name of an IP prefix-list";
          }
        }
      }

      // router ospf * / area * range *
      list range {
        tailf:info "Summarize routes matching address/mask (border routers only)";
        tailf:cli-suppress-mode;
        //tailf:cli-keep-when-empty;
        tailf:cli-compact-syntax;
        ios:trim-delete-when-empty "( range \\S+ \\S+)";
        key "ip mask";
        leaf ip {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP address to match";
          }
        }
        leaf mask {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP mask for address";
          }
        }
        leaf advertise {
          tailf:cli-drop-node-name;
          type enumeration {
            enum advertise {
              tailf:info "Advertise this range (default)";
            }
            enum not-advertise {
              tailf:info "DoNotAdvertise this range";
            }
          }
          default advertise;
        }
        leaf cost {
          tailf:info "User specified metric for this range";
          type uint32 {
            tailf:info "<0-16777215>;;Advertised metric for this range";
            range "0..16777215";
          }
        }
      }

      // router ospf * / address-family ipv6 unicast / area * range
      container range-ipv6 {
        tailf:cli-drop-node-name;
        list range {
          tailf:info "Summarize routes matching address/mask (border routers only)";
          tailf:cli-compact-syntax;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          ios:trim-delete-when-empty "( range \\S+)";
          key prefix;
          leaf prefix {
            type ipv6-prefix {
              tailf:info "X:X:X:X::X/<0-128>;;IPv6 prefix to match";
            }
          }
          leaf advertise {
            tailf:cli-drop-node-name;
            type enumeration {
              enum advertise {
                tailf:info "Advertise this range (default)";
              }
              enum not-advertise {
                tailf:info "DoNotAdvertise this range";
              }
            }
            default advertise;
          }
          leaf cost {
            tailf:info "User specified metric for this range";
            type uint32 {
              tailf:info "<0-16777215>;;Advertised metric for this range";
              range "0..16777215";
            }
          }
        }
      }

      // router ospf * / area * sham-link *
      list sham-link {
        tailf:info "Define a sham link and its parameters";
        tailf:cli-suppress-mode;
        //tailf:cli-keep-when-empty;
        tailf:cli-compact-syntax;
        ios:trim-delete-when-empty "( sham-link \\S+ \\S+)";
        key "source dest";
        leaf source {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP addr associated with sham-link source";
          }
        }
        leaf dest {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP addr associated with sham-link destination";
          }
        }
        leaf cost {
          tailf:info "Associate a cost with the sham-link";
          type uint16 {
            tailf:info "<1-65535>;;Cost of the sham-link";
            range "0..65535";
          }
        }
        container ttl-security {
          tailf:info "TTL security check";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          leaf hops {
            tailf:info "IP hops";
            type uint8 {
              tailf:info "<1-254>;;maximum number of hops allowed";
              range "1..254";
            }
          }
        }
      }

      // router ospf * / area * stub
      container stub {
        tailf:info "Specify a stub area";
        tailf:cli-compact-syntax;
        //tailf:cli-keep-when-empty;
        ios:trim-delete-when-empty "( stub)";
        tailf:cli-diff-dependency "../nssa" {
          tailf:cli-trigger-on-set;
        }
        presence true;
        leaf no-summary {
          tailf:info "Do not send summary LSA into stub area";
          type empty;
        }
        leaf no-ext-capability {
          tailf:info "Do not send domain specific capabilities into stub area";
          type empty;
        }
      }

      // router ospf * / area * virtual-link *
      list virtual-link {
        tailf:info "Define a virtual link and its parameters";
        tailf:cli-suppress-mode;
        //tailf:cli-keep-when-empty;
        tailf:cli-compact-syntax;
        ios:trim-delete-when-empty "( virtual-link \\S+)";
        key id;
        leaf id {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;ID (IP addr) associated with virtual link neighbor";
          }
        }

        // router ospf * / area * virtual-link retransmit-interval
        leaf retransmit-interval {
          tailf:info "LSA retransmit interval";
          type uint16 {
            tailf:info "<1-8192>;;Seconds";
            range "1..8192";
          }
        }

        // router ospf * / area * virtual-link transmit-delay
        leaf transmit-delay {
          tailf:info "LSA transmission delay";
          type uint16 {
            tailf:info "<1-8192>;;Seconds";
            range "1..8192";
          }
          default 1;
        }

        // router ospf * / area * virtual-link hello-interval
        leaf hello-interval {
          tailf:info "Hello packet interval";
          type int32 {
            tailf:info "<1-8192;;Seconds>";
            range "1..8192";
          }
        }

        // router ospf * / area * virtual-link dead-interval
        leaf dead-interval {
          tailf:info "Dead router detection time";
          type uint16 {
            tailf:info "<1-8192;;Seconds>";
            range "1..8192";
          }
        }

        // router ospf * / area * virtual-link authentication
        leaf authentication {
          tailf:info "Set authentication type";
          type empty;
        }

        // router ospf * / area * virtual-link authentication-key
        container authentication-key {
          tailf:info "Set authentication key";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          uses password-grouping {
            refine "secret" {
              cli:secret " authentication-key <SECRET>";
            }
          }
        }

        // router ospf * / area * virtual-link message-digest-key *
        list message-digest-key {
          tailf:info "Set message digest key";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-incomplete-command;
          key id;
          leaf id {
            tailf:cli-suppress-range;
            type uint8 {
              tailf:info "<1-255>;;Key ID";
              range "1..255";
            }
          }
          // router ospf * / area * virtual-link message-digest-key * md5
          container md5 {
            tailf:info "Use MD5 algorithm";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf auth-type {
              tailf:cli-drop-node-name;
              tailf:cli-optional-in-sequence;
              tailf:cli-incomplete-command;
              type uint8 {
                tailf:info "<0-7>;;Encryption type (0 for not yet encrypted, 7 for proprietary)";
                range "0..7";
              }
              default 0;
            }
            leaf auth-key {
              tailf:cli-drop-node-name;
              tailf:cli-full-command;
              type string {
                tailf:info "WORD;;Authentication key (16 chars)";
                length "1..16";
              }
            }
          }
        }

      }
    }

    // router ospf * / auto-cost reference-bandwidth
    container auto-cost {
      tailf:info "Calculate OSPF interface cost according to bandwidth";
      leaf reference-bandwidth {
        tailf:info "Use reference bandwidth method to assign OSPF cost";
        type uint32 {
          tailf:info "<1-4294967>;;The reference bandwidth in terms of Mbits per second. Default 100";
          range "1..4294967";
        }
        default 100;
      }
    }

    // router ospf * / bfd all-interfaces
    container bfd {
      tailf:info "BFD configuration commands";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf all-interfaces {
        tailf:info "Enable BFD on all interfaces";
        type empty;
      }
      leaf strict-mode {
        tailf:info "Enable BFD in strict mode";
        type empty;
      }
    }

    // router ospf * / interface-id
    container interface-id {
      tailf:info "Source of the interface ID";
      leaf snmp-if-index {
        tailf:info "SNMP MIB ifIndex";
        type empty;
      }
    }

    // router ospf * / no log-adjacency-changes
    // router ospf * / log-adjacency-changes detail
    // router ospf * / log-adjacency-changes (cat6500 & me3750)
    container log-adjacency-changes {
      tailf:info "Log changes in adjacency state";
      tailf:cli-show-no;
      presence true;
      leaf detail {
        tailf:info "Log all state changes";
        type empty;
      }
    }

    // router ospf * / max-lsa
    container max-lsa {
      tailf:info "maximum number of LSAs OSPF process will receive";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      leaf maximum-number {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<1-4294967294>;;Maximum number of non self-generated LSAs this process can receive";
          range "1..4294967294";
        }
      }
      leaf threshold-percentage {
        tailf:cli-break-sequence-commands;
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-100>;;Threshold value (%) at which to generate a warning msg";
          range "1..100";
        }
      }
      leaf warning-only {
        tailf:info "Only give warning message when limit is exceeded";
        tailf:cli-full-command;
        type empty;
      }
      leaf ignore-time {
        tailf:info "time during which all adjacencies are suppressed";
        type uint32 {
          tailf:info "<1-17895>;;number of minutes during which all adjacencies are suppressed";
          range "1..17895";
        }
      }
      leaf reset-time {
        tailf:info "time after which ignore-count is reset to zero";
        type uint32 {
          tailf:info "<2-35791>;;number of minutes after which ignore-count is reset to zero";
          range "2..35791";
        }
        default 60;
      }
      leaf ignore-count {
        tailf:info "maximum number of times adjacencies can be suppressed";
        type uint32 {
          tailf:info "<1-65534>;;count on how many times adjacencies can be suppressed";
          range "1..65534";
        }
      }
    }

    // router ospf * / passive-interface
    uses passive-interface-grouping;

    // router ospf * / queue-depth
    container queue-depth {
      tailf:info "OSPF Hello/Router process queue depth";

      // router ospf * / queue-depth hello
      leaf hello {
        tailf:info "OSPF Hello process queue depth";
        type union {
          type uint32 {
            tailf:info "<1-2147483647>;;maximum numer of packets in the queue";
            range "1..2147483647";
          }
          type enumeration {
            enum "unlimited" {
              tailf:info "Unlimited queue depth";
            }
          }
        }
        default "unlimited";
      }

      // router ospf * / queue-depth update
      leaf update {
        tailf:info "OSPF Router process queue depth";
        type union {
          type uint32 {
            tailf:info "<1-2147483647>;;maximum numer of packets in the queue. Default 200";
            range "1..2147483647";
          }
          type enumeration {
            enum "unlimited" {
              tailf:info "Unlimited queue depth";
            }
          }
        }
        default 200;
      }
    }

    // router ospf * / timers
    container timers {
      tailf:info "Adjust routing timers";

      // router ospf * / timers lsa arrival
      container lsa {
        tailf:info "OSPF LSA timers";
        leaf arrival {
          tailf:info "OSPF LSA arrival timer";
          type uint32 {
            tailf:info "<0-600000>;;The minimum interval in milliseconds between accepting the same LSA.";
            range "0..600000";
          }
        }
      }

      // router ospf * / timers pacing
      container pacing {
        tailf:info "OSPF pacing timers";

        // router ospf * / timers pacing flood
        leaf flood {
          tailf:info "OSPF flood pacing timer";
          tailf:cli-full-command;
          type uint32 {
            tailf:info "<5-100>;;The minimum interval in msec to pace limit flooding on interface. Default 33";
            range "5..100";
          }
          default 33;
        }

        // router ospf * / timers pacing lsa-group
        leaf lsa-group {
          tailf:info "OSPF LSA group pacing timer";
          tailf:cli-full-command;
          type uint32 {
            tailf:info "<10-1800>;;Interval in sec between group of LSA being refreshed or maxaged. Default 240";
            range "10..1800";
          }
          default 240;
        }

        // router ospf * / timers pacing retransmission
        leaf retransmission {
          tailf:info "OSPF retransmission pacing timer";
          tailf:cli-full-command;
          type uint32 {
            tailf:info "<5-200>;;The minimum interval in msec between neighbor retransmissions. Default 66";
            range "5..200";
          }
          default 66;
        }
      }

      // router ospf * / timers spf
      container spf {
        tailf:info "OSPF SPF timers";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf spf-start {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<1-600000>;;Delay between receiving a change to SPF calculation";
            range "0..600000";
          }
        }
        leaf spf-hold {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-600000>;;Hold time between consecutive SPF calculations";
          }
        }
      }

      // router ospf * / timers throttle
      container throttle {
        tailf:info "OSPF throttle timers";

        // router ospf * / timers throttle lsa
        container lsa {
          tailf:info "OSPF LSA throttle timers";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf all {
            tailf:info "For all type of OSPF LSAs";
            tailf:cli-optional-in-sequence;
            tailf:cli-incomplete-command;
            type empty;
          }
          leaf start-interval {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<0-600000>;;Delay to generate first occurrence of LSA in milliseconds";
              range "0..600000";
            }
          }
          leaf hold-interval {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<0-600000>;;Minimum delay between originating the same LSA in milliseconds";
              range "0..600000";
            }
          }
          leaf max-interval {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<0-600000>;;Maximum delay between originating the same LSA in milliseconds";
              range "0..600000";
            }
          }
        }

        // router ospf * / timers throttle spf
        container spf {
          tailf:info "OSPF SPF throttle timers";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf spf-start {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<0-600000>;;Delay between receiving a change to SPF calculation in milliseconds";
              range "0..600000";
            }
          }
          leaf spf-hold {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<0-600000>;;Delay between first and second SPF calculation in milliseconds";
              range "0..600000";
            }
          }
          leaf spf-max-wait {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<0-600000>;;Maximum wait time in milliseconds for SPF calculations";
              range "0..600000";
            }
          }
        }
      }
    }

    // router ospf * / priority
    leaf priority {
      tailf:info "OSPF topology priority";
      type uint8 {
        tailf:info "<0-127>;;OSPF topology priority. Default 64";
        range "0..127";
      }
      default 64;
    }

    // router ospf * / router-id
    leaf router-id {
      tailf:cli-full-command;
      tailf:info "Override configured router identifier (peers will reset)";
      type inet:ipv4-address {
        tailf:info "A.B.C.D;;Manually configured router identifier";
      }
    }
  }

  // router ospf * /
  // router ospf * vrf * /
  grouping router-ospf-grouping {

    // router ospf * / capability
    container capability {
      tailf:info "Enable specific OSPF feature";

      // router ospf * / capability vrf-lite
      leaf vrf-lite {
        tailf:info "Do not perform PE specific checks";
        type empty;
      }

      // router ospf * / no capability opaque
      leaf opaque {
        tailf:info "Opaque LSA";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // router ospf * / no capability lls
      leaf lls {
        tailf:info "Link-local Signaling (LLS) support";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // router ospf * / no capability transit
      leaf transit {
        tailf:info "Transit Area";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }
    }

    // router ospf * / no compatible rfc1583
    container compatible {
      tailf:info "OSPF compatibility list";
      leaf rfc1583 {
        tailf:info "compatible with RFC 1583";
        tailf:cli-boolean-no;
        type boolean;
        default true;
      }
    }

    // router ospf * / distribute-list *
    uses router-distribute-list-grouping;

    // router ospf * / domain-id
    container domain-id {
      tailf:info "OSPF domain-id";
      choice domain-id-choice {
        case a {
          leaf ip-format {
            tailf:cli-drop-node-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;OSPF domain ID in IP address format";
            }
          }
          container ip-format-secondary {
            tailf:cli-drop-node-name;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf ip {
              tailf:cli-drop-node-name;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;OSPF domain ID in IP address format";
              }
            }
            leaf secondary {
              tailf:info "Secondary Domain-ID";
              type empty;
            }
          }
        }
        leaf Null {
          tailf:info "Null Domain-ID";
          tailf:cli-full-command;
          type empty;
        }
        container type {
          tailf:info "OSPF domain ID type in Hex format";
          tailf:cli-sequence-commands;
          tailf:cli-compact-syntax;
          leaf type-leaf {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type enumeration {
              enum "0005" {
                tailf:info "Type 0x0005";
              }
              enum "0105" {
                tailf:info "Type 0x0105";
              }
              enum "0205" {
                tailf:info "Type 0x0205";
              }
              enum "8005" {
                tailf:info "Type 0x8005";
              }
            }
          }
          leaf value {
            tailf:info "OSPF domain ID value in Hex format";
            type string {
              tailf:info "Hex-data;;OSPF domain ID ext. community value in Hex";
              pattern '[0-9a-fA-F]{12}';
            }
          }
        }
      }
    }

    // router ospf * / domain-tag
    leaf domain-tag {
      tailf:info "OSPF domain-tag";
      tailf:cli-full-command;
      type uint32 {
        tailf:info "<1-4294967295>;;OSPF domain tag - 32-bit value";
        range "1..4294967295";
      }
    }

    // router ospf * / ignore
    container ignore {
      tailf:info "Do not complain about specific event";
      container lsa {
        tailf:info "Do not complain upon receiving LSA of the specified type";
        leaf mospf {
          tailf:info "MOSPF Type 6 LSA";
          type empty;
        }
      }
    }

    // router ospf * / ispf
    leaf ispf {
      tailf:info "Enable incremental SPF computation";
      tailf:cli-full-command;
      type empty;
    }

    // router ospf * / limit
    container limit {
      tailf:info "Limit a specific OSPF feature";
      container retransmissions {
        tailf:info "LS update, DBD, and LS request retransmissions";
        tailf:cli-compact-syntax;
        leaf dc {
          tailf:info "Demand circuit retransmissions";
          type limit-dc-non-dc-type;
        }
        leaf non-dc {
          tailf:info "Non-demand-circuit retransmissions";
          type limit-dc-non-dc-type;
        }
      }
    }

    // router ospf * / local-rib-criteria
    container local-rib-criteria {
      tailf:info "Enable or disable usage of local RIB as route criteria";
      tailf:cli-compact-syntax;
      leaf forwarding-address {
        tailf:info "Local RIB used to validate external/NSSA forwarding addresses";
        type empty;
      }
      leaf inter-area-summary {
        tailf:info "Local RIB used as criteria for inter-area summaries";
        type empty;
      }
      leaf nssa-translation {
        tailf:info "Local RIB used as criteria for NSSA translation";
        type empty;
      }
    }

    // router ospf * / max-metric router-lsa
    container max-metric {
      tailf:info "Set maximum metric";
      container router-lsa {
        tailf:info "Maximum metric in self-originated router-LSAs";
        tailf:cli-compact-syntax;
        //tailf:cli-keep-when-empty;
        ios:trim-delete-when-empty "( router-lsa)";
        presence true;
        leaf include-stub {
          tailf:info "Set maximum metric for stub links in router-LSAs";
          type empty;
        }
        leaf summary-lsa {
          tailf:info "Override summary-lsa metric with max-metric value";
          type empty;
        }
        leaf summary-lsa-max-metric-value {
          when "../summary-lsa" {
            tailf:dependency "../summary-lsa";
          }
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-16777215>;;Overriding metric in summary-LSAs (default 16711680)";
            range "1..16777215";
          }
        }
        leaf external-lsa {
          tailf:info "Override external-lsa metric with max-metric value";
          type empty;
        }
        leaf external-lsa-max-metric-value {
          when "../external-lsa" {
            tailf:dependency "../external-lsa";
          }
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-16777215>;;Overriding metric in external-LSAs (default 16711680)";
            range "1..16777215";
          }
        }
        container on-startup {
          tailf:info "Set maximum metric temporarily after reboot";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          choice time-wait-for-bgp-choice {
            leaf seconds {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<5-86400>;;Time, in seconds, router-LSAs are originated with max-metric";
                range "5..86400";
              }
            }
            leaf wait-for-bgp {
              tailf:info "Let BGP decide when to originate router-LSA with normal metric";
              type empty;
            }
          }
        }
      }
    }

    // router ospf * / event-log
    container event-log {
      tailf:info "OSPF Event Logging";

      // router ospf * / event-log size
      leaf size {
        tailf:info "Maximum Number of Events Stored in the Event Log";
        type uint16 {
          tailf:info "<1-65534>;;Number of Events";
          range "1..65535";
        }
      }
    }

    // router ospf * / mpls
    container mpls {
      tailf:info "Configure MPLS routing protocol parameters";

      // router ospf * / mpls ldp
      container ldp {
        tailf:info "routing protocol commands for MPLS LDP";
        container autoconfig {
          tailf:info "Configure LDP automatic configuration";
          presence "Configure LDP automatic configuration";
          leaf area {
            tailf:info "Configure an OSPF area to run MPLS LDP";
            type ospf-area-type;
          }
        }
        container sync {
          tailf:info "Configure LDP-IGP Synchronization";
          presence "Configure LDP-IGP Synchronization";
        }
      }

      // router ospf * / mpls traffic-eng
      container traffic-eng {
        tailf:info "routing protocol commands for MPLS Traffic Engineering";

        // router ospf * / mpls traffic-eng router-id
        container router-id {
          tailf:info "Traffic Engineering stable IP address for system";
          uses interface-name-grouping;
        }

        // router ospf * / mpls traffic-eng area *
        leaf-list area {
          tailf:info "configure an ospf area to run MPLS Traffic Engineering";
          tailf:cli-list-syntax;
          tailf:cli-full-command;
          type ospf-area-type;
        }

        // router ospf * / mpls traffic-eng multicast-intact
        leaf multicast-intact {
          tailf:info "MPLS TE and PIM interaction";
          tailf:cli-full-command;
          type empty;
        }

        // router ospf * / mpls traffic-eng interface
        container interface {
          tailf:info "MPLS TE interface configuration for this OSPF process";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          container name {
            tailf:cli-drop-node-name;
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            uses interface-name-grouping;
          }
          leaf area {
            tailf:info "advertise MPLS TE information for this interface into area";
            type uint32 {
              tailf:info "<0-0>;;OSPF area ID as a decimal value";
            }
          }
        }

        // router ospf * / mpls traffic-eng mesh-group *
        list mesh-group {
          tailf:info "Traffic Engineering Mesh-Group advertisement";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          key "id area";
          leaf id {
            type uint32 {
              tailf:info "<0-4294967295>;;Mesh Group Id";
            }
          }
          leaf area {
            tailf:cli-expose-key-name;
            tailf:info "configure flooding scope as area";
            type ospf-area-type;
          }
          leaf interface {
            tailf:cli-drop-node-name;
            tailf:cli-prefix-key {
              tailf:cli-before-key 2;
            }
            type string {
              tailf:info "WORD;;Interface Name";
            }
          }
        }
      }
    }

    // router ospf * / neighbor *
    list neighbor {
      tailf:info "Specify a neighbor router";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key ip;
      leaf ip {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Neighbor address";
        }
      }

      // router ospf * / neighbor * / cost
      container cost-database-filter-container {
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        leaf cost {
          tailf:info "OSPF cost for point-to-multipoint neighbor";
          type uint32 {
            tailf:info "<1-65535>;;metric";
            range "1..65535";
          }
        }
        container database-filter {
          tailf:info "Filter OSPF LSA during synchronization and flooding for point-to-multipoint neighbor";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          container all {
            tailf:info "Filter all LSA";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            leaf out {
              tailf:info "Outgoing LSA";
              type empty;
            }
          }
        }
      }

      // router ospf * / neighbor * / poll-interval
      container poll-interval-priority-container {
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        leaf poll-interval {
          tailf:info "OSPF dead-router polling interval";
          type uint32 {
            tailf:info "<0-65535>;;Seconds";
            range "0..65535";
          }

        }
        leaf priority {
          tailf:info "OSPF priority of non-broadcast neighbor";
          type uint32 {
            tailf:info "<0-255>;;Priority";
            range "0..255";
          }
        }
      }
    }

    // router ospf * / network *
    list network {
      tailf:info "Enable routing on an IP network";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      key "ip mask";
      leaf ip {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Network number";
        }
      }
      leaf mask {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;OSPF wild card bits";
        }
      }
      leaf area {
        tailf:info "Set the OSPF area ID";
        type ospf-area-type;
      }
    }

    // router ospf * / nsf
    container nsf {
      tailf:info "Non-stop forwarding";
      tailf:cli-delete-when-empty;
      tailf:cli-diff-dependency "../nsf-ietf/nsf/ietf" {
        tailf:cli-trigger-on-set;
      }
      presence true;

      // router ospf * / nsf cisco
      container cisco {
        tailf:info "Cisco Non-stop forwarding";
        //tailf:cli-keep-when-empty;
        ios:trim-delete-when-empty "( cisco)";
        presence true;
        // router ospf * / nsf cisco enforce global
        leaf enforce {
          tailf:info "Cancel NSF restart when non-NSF-aware neighbors detected";
          type enumeration {
            enum global {
              tailf:info "For the whole OSPF process";
            }
          }
        }
      }
    }

    // router ospf * / nsf ietf
    container nsf-ietf {
      tailf:cli-drop-node-name;
      container nsf {
        tailf:info "Non-stop forwarding";
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        container ietf {
          tailf:info "IETF graceful restart";
          //tailf:cli-keep-when-empty;
          ios:trim-delete-when-empty "( ietf)";
          presence true;

          // router ospf * / nsf ietf restart-interval
          leaf restart-interval {
            tailf:info "Graceful restart interval";
            type uint16 {
              tailf:info "<1-1800>;;Maximum route lifetime following restart, in seconds. Default 120";
              range "1..1800";
            }
            default 120;
          }
        }
      }
    }

    // router ospf * / nsf cisco helper disable
    // router ospf * / nsf ietf helper disable
    container nsf-helper {
      tailf:cli-drop-node-name;
      container nsf {
        tailf:info "Non-stop forwarding";
        container cisco {
          tailf:info "Cisco Non-stop forwarding";
          container helper {
            tailf:info "helper support";
            leaf disable {
              tailf:info "disable helper support";
              type empty;
            }
          }
        }
        container ietf {
          tailf:info "IETF graceful restart";
          container helper {
            tailf:info "helper support";
            leaf disable {
              tailf:info "disable helper support";
              type empty;
            }
            // router ospf * / nsf ietf helper strict-lsa-checking
            leaf strict-lsa-checking {
              tailf:info "enable helper strict LSA checking";
              type empty;
            }
          }
        }
      }
    }

    // router ospf * / prefix-priority high route-map
    container prefix-priority {
      tailf:info "OSPF prefix priority";
      container high {
        tailf:info "High prefix priority";
        leaf route-map {
          tailf:info "Prefix priority selection by route-map";
          type string {
            tailf:info "WORD;;Route map name";
          }
        }
      }
    }

    // router ospf * / prefix-suppression
    leaf prefix-suppression {
      tailf:info "OSPF prefix suppression";
      tailf:cli-full-command;
      type empty;
    }

    // router ospf * / process-min-time percent
    container process-min-time {
      tailf:info "Percentage of quantum to be used before releasing CPU";
      leaf percent {
        tailf:info "percent";
        type uint32 {
          tailf:info "<1-100>;;Minimum CPU quantum";
          range "1..100";
        }
      }
    }

    // router ospf * / traffic-share min across-interfaces
    container traffic-share {
      tailf:info "How to compute traffic share over alternate paths";
      container min {
        tailf:info "All traffic shared among min metric paths";
        leaf across-interfaces {
          tailf:info "Use different interfaces for equal-cost paths";
          type empty;
        }
      }
    }

    // router ospf * / shutdown
    leaf shutdown {
      tailf:info "Shutdown the OSPF protocol under the current instance";
      type empty;
    }

    // router ospf * / summary-address *
    list summary-address {
      tailf:info "Configure IP address summaries";
      tailf:cli-suppress-mode;
      //tailf:cli-keep-when-empty;
      ios:trim-delete-when-empty "( summary-address \\S+ \\S+)";
      key "ip wildcard";
      leaf ip {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;IP summary address";
        }
      }
      leaf wildcard {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Summary mask";
        }
      }
      choice tag-no-advertise-choice {
        leaf tag {
          tailf:info "Set tag";
          type uint32 {
            tailf:info "<0-4294967295>;;32-bit tag value";
            range "0..4294967295";
          }
        }
        leaf not-advertise {
          tailf:info "Do not advertise when translating OSPF type-7 LSA";
          type empty;
        }
      }
    }

    // router ospf * / discard-route
    container discard-route {
      tailf:info "Enable or disable discard-route installation";
      cli:parse-compact-syntax;

      // router ospf * / discard-route external
      leaf external {
        tailf:info "Discard route for redistributed summarised routes";
        ios:delete-syntax " discard-route external";
        type union {
          type uint32 {
            tailf:info "<1-255>;;Administrative distance for redistributed summarised routes";
            range "1..255";
          }
          type enumeration {
            enum disabled {
              tailf:info "no discard-route external";
            }
          }
        }
      }

      // router ospf * / discard-route internal
      leaf internal {
        tailf:info "Discard route for summarised internal routes";
        ios:delete-syntax " discard-route internal";
        type union {
          type uint32 {
            tailf:info "<1-255>;;Administrative distance for summarised internal routes";
            range "1..255";
          }
          type enumeration {
            enum disabled {
              tailf:info "no discard-route internal";
            }
          }
        }
      }
    }

    // router ospf * / segment-routing
    container segment-routing {
      tailf:info "Segment routing parameters";
      tailf:cli-diff-dependency "/ios:segment-routing/mpls";

      // router ospf * / segment-routing area *
      list area {
        tailf:info "Area to enable SR in";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          type union {
            type uint32 {
              tailf:info "<0-4294967295>;;OSPF area ID as a decimal value";
            }
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;OSPF area ID in IP address format";
            }
          }
        }
        leaf status {
          tailf:cli-drop-node-name;
          type enumeration {
            enum disable {
              tailf:info "Disable segment routing in area";
            }
            enum mpls {
              tailf:info "Enable segment routing MPLS in area";
            }
          }
        }
      }

      // router ospf * / segment-routing mpls
      leaf mpls {
        tailf:info "Enable segment routing MPLS";
        type empty;
      }
    }

    // router ospf * / fast-reroute
    container fast-reroute {
      tailf:info "Configure Fast-Reroute";

      // router ospf * / fast-reroute keep-all-paths
      leaf keep-all-paths {
        tailf:info "Keep LFA FRR audit trail";
        tailf:cli-full-command;
        type empty;
      }

      // router ospf * / fast-reroute per-prefix
      container per-prefix {
        tailf:info "Per-prefix LFA FRR parameters";

        // router ospf * / fast-reroute per-prefix enable
        container enable {
          tailf:info "Enable LFA Fast Reroute";

          // router ospf * / fast-reroute per-prefix enable area * prefix-priority
          list area {
            tailf:info "Area to enable LFA FRR in";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            key area;
            leaf area {
              type ospf-area-type;
            }
            leaf prefix-priority {
              tailf:info "Priority of prefixes to be protected";
              type enumeration {
                enum "high" {
                  tailf:info "High priority prefixes";
                }
                enum "low" {
                  tailf:info "Low priority prefixes";
                }
              }
            }
          }

          // router ospf * / fast-reroute per-prefix enable prefix-priority
          leaf prefix-priority {
            tailf:info "Priority of prefixes to be protected";
            type enumeration {
              enum "high" {
                tailf:info "High priority prefixes";
              }
              enum "low" {
                tailf:info "Low priority prefixes";
              }
            }
          }
        }

        // router ospf * / fast-reroute per-prefix remote-lfa
        container remote-lfa {
          tailf:info "Remote LFA FastReroute parameters";

          // router ospf * / fast-reroute per-prefix remote-lfa area
          leaf area {
            tailf:info "Area for remote LFA command";
            tailf:cli-full-command;
            type ospf-area-type;
          }

          // router ospf * / fast-reroute per-prefix remote-lfa maximum-cost
          leaf maximum-cost {
            tailf:info "Maximum distance to tunnel endpoint";
            tailf:cli-full-command;
            type uint32 {
              tailf:info "<1-16777214>;;Value of the maximum distance to tunnel endpoint";
            }
          }

          // router ospf * / fast-reroute per-prefix remote-lfa tunnel
          leaf tunnel {
            tailf:info "Remote LFA tunnel type";
            tailf:cli-full-command;
            type enumeration {
              enum "mpls-ldp" {
                tailf:info "Enable remote LFA tunneling via MPLS";
              }
            }
          }
        }

        // router ospf * / fast-reroute per-prefix ti-lfa
        leaf ti-lfa {
          tailf:info "Topology Independent LFA parameters";
          tailf:cli-full-command;
          tailf:cli-full-no;
          type empty;
        }

        // router ospf * / fast-reroute per-prefix ti-lfa area *
        container ti-lfa-area {
          tailf:cli-drop-node-name;
          container ti-lfa {
            tailf:info "Topology Independent LFA parameters";
            tailf:cli-incomplete-command;
            tailf:cli-incomplete-no;
            list area {
              tailf:info "Area for Topology Independent LFA command";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key id;
              leaf id {
                type union {
                  type uint32 {
                    tailf:info "<0-4294967295>;;OSPF area ID as a decimal value";
                  }
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;OSPF area ID in IP address format";
                  }
                }
              }
              leaf disable {
                tailf:info "Disable TI-LFA under this area";
                type empty;
              }
            }
          }
        }
      }
    }

    // router ospf * / microloop avoidance
    container microloop {
      tailf:info "Traffic microloop control parameters";
      container avoidance {
        tailf:info "Traffic microloop avoidance parameters";
        tailf:cli-delete-when-empty;
        tailf:cli-reset-container;
        presence true;
        choice avoidance-choice {
          leaf protected {
            tailf:info "Microloop avoidance for protected prefixes only";
            type empty;
          }
          leaf disable {
            tailf:info "Microloop avoidance auto-enable prohibited";
            type empty;
          }
          leaf segment-routing {
            tailf:info "SR Microloop Avoidance";
            type empty;
          }
        }
      }
    }
  }

  grouping router-ospfv3-grouping {

    // router ospfv3 * / address-family [ipv4 | ipv6 | <vrf> ] summary-prefix *
    list summary-prefix {
      tailf:info "Configure IP summary prefix";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key prefix;
      leaf prefix {
        type union {
          type ios:ipv4-prefix;
          type ios:ipv6-prefix;
        }
      }
    }
  }


  grouping ospf-redistribute-match-grouping {
    leaf metric {
      tailf:info "Metric for redistributed routes";
      type uint32 {
        tailf:info "<0-16777214>;;OSPF default metric";
      }
    }
    leaf subnets {
      tailf:info "Consider subnets for redistribution into OSPF";
      type empty;
    }
    leaf route-map {
      tailf:info "Route map reference";
      type string {
        tailf:info "WORD;;Pointer to route-map entries";
      }
    }
    leaf tag {
      tailf:info "Set tag for routes redistributed into OSPF";
      type uint32 {
        tailf:info "<0-4294967295>;;32-bit tag value";
        range "0..4294967295";
      }
    }
  }


  // router isis * / redistribute * level-1
  // router isis * / redistribute * level-2
  // router isis * / redistribute * level-1-2
  // router isis * / authentication send-only
  // router isis * / authentication mode
  grouping router-isis-level-grouping {
    leaf level {
      tailf:cli-drop-node-name;
      type enumeration {
        enum level-1 {
          tailf:info "IS-IS level-1 routes only";
        }
        enum level-1-2 {
          tailf:info "IS-IS level-1 and level-2 routes";
        }
        enum level-2 {
          tailf:info "IS-IS level-2 routes only";
        }
      }
    }
  }


  // router * / redistribute * route-map
  grouping router-ospf-route-map-grouping {
    leaf route-map {
      tailf:info "Route map reference";
      tailf:non-strict-leafref {
        path "/ios:route-map/name";
      }
      type string {
        tailf:info "WORD;;Pointer to route-map entries";
      }
    }
  }

  // router ospf * / redistribute *
  grouping router-ospf-redistribute-grouping {

    // router ospf * / redistribute * vrf
    leaf vrf {
      tailf:info "VPN Routing/Forwarding Instance";
      tailf:cli-optional-in-sequence;
      tailf:cli-diff-dependency "/ios:ip/vrf";
      tailf:cli-diff-dependency "/ios:vrf/definition";
      type string {
        tailf:info "WORD;;VPN Routing/Forwarding Instance (VRF) name";
      }
    }

    // router ospf * / redistribute *  metric
    leaf metric {
      tailf:info "Metric for redistributed routes";
      type uint32 {
        tailf:info "<0-16777214>;;OSPF default metric";
      }
    }

    // router ospf * / redistribute *  metric-type
    leaf metric-type {
      tailf:info "OSPF/IS-IS exterior metric type for redistributed routes";
      type enumeration {
        enum "1" {
          tailf:info "Set OSPF External Type 1 metrics";
        }
        enum "2" {
          tailf:info "Set OSPF External Type 2 metrics";
        }
      }
      default "2";
    }

    // router ospf * / redistribute * subnets
    leaf subnets {
      tailf:info "Consider subnets for redistribution into OSPF";
      type empty;
    }

    // router ospf * / redistribute *  nssa-only
    leaf nssa-only {
      tailf:info "Limit redistributed routes to NSSA areas";
      type empty;
    }

    // router ospf * / redistribute *  tag
    leaf tag {
      tailf:info "Set tag for routes redistributed into OSPF";
      type uint32 {
        tailf:info "<0-4294967295>;;32-bit tag value";
      }
    }
  }


  // router rip
  // router rip / address-family ipv4 unicast
  // router rip / address-family ipv4 vrf *
  grouping router-rip-af-grouping {

    // router rip / no auto-summary
    leaf auto-summary {
      tailf:info "Enable automatic network number summarization";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
      default true;
    }

    // router rip / maximum-paths
    leaf maximum-paths {
      tailf:info "Forward packets over multiple paths";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "1-32;;Number of paths. Default 4";
        range "1..32";
      }
      default 4;
    }

    // router rip / neighbor *
    list neighbor {
      tailf:info "Specify a neighbor router";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key ip;
      leaf ip {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Neighbor address";
        }
      }
      leaf bfd {
        tailf:info "Enable BFD for the neighbor";
        type empty;
      }
    }

    // router rip / network *
    list network {
      tailf:info "Enable routing on an IP network";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key ip;
      leaf ip {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Network number";
        }
      }
    }

    // router rip / no validate-update-source
    leaf validate-update-source {
      tailf:info "Perform sanity checks against source address of routing updates";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
      default true;
    }

    // router rip / default-information
    container default-information {
      tailf:info "Control distribution of default information";
      container originate {
        tailf:info "Distribute a default route";
        presence true;
        leaf route-map {
          tailf:info "Route-map reference";
          type string {
            tailf:info "WORD;;Route map name";
          }
        }
      }
    }

    // router rip / default-metric
    leaf default-metric {
      tailf:info "Set metric of redistributed routes";
      tailf:cli-full-command;
      type uint32 {
        tailf:info "<1-4294967295>;;Default metric";
        range "1..4294967295";
      }
    }

    // router rip / distance
    container distance {
      tailf:info "Define an administrative distance";
      tailf:cli-compact-syntax;
      leaf distance-leaf {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        type uint8 {
          tailf:info "1-255;;Administrative distance. Default 120";
          range "1..255";
        }
        default 120;
      }

      // router rip / distance *
      list distance-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key "ip mask";
        leaf number {
          tailf:cli-prefix-key;
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "1-255;;Administrative distance";
            range "1..255";
          }
        }
        leaf ip {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP source address";
          }
        }
        leaf mask {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Wildcard bits";
          }
        }
        leaf access-list {
          tailf:cli-drop-node-name;
          type std-ip-acl-type;
        }
      }
    }

    // router rip / distribute-list *
    uses router-distribute-list-grouping;

    // router rip / offset-list *
    uses router-offset-list-grouping;

    // router rip / redistribute
    container redistribute {
      tailf:info "Redistribute information from another routing protocol";

      // router rip / redistribute connected
      container connected {
        tailf:info "Connected";
        tailf:cli-compact-syntax;
        presence true;
        uses router-rip-redistribute-grouping;
      }

      // router rip / redistribute bgp
      container bgp {
        tailf:info "Border Gateway Protocol (BGP)";
        tailf:cli-compact-syntax;
        leaf as-no {
          tailf:cli-drop-node-name;
          tailf:cli-delete-container-on-delete;
          ios:trim-delete-when-empty "( redistribute bgp \\d+)";
          type bgp-as-no-type;
        }
        uses router-rip-redistribute-grouping;
      }

      // router rip / redistribute eigrp *
      list eigrp {
        tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key as-no;
        leaf as-no {
          type eigrp-as-no-type;
        }
        uses router-rip-redistribute-grouping;
      }

      // router rip / redistribute isis
      container isis {
        tailf:info "ISO IS-IS";
        tailf:cli-compact-syntax;
        //tailf:cli-keep-when-empty;
        ios:trim-delete-when-empty "( isis)";
        presence true;

        // router rip / redistribute isis *
        list isis-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key name;
          leaf name {
            tailf:cli-disallow-value "level-1|level-2|level-1-2|metric|route-map";
            type string {
              tailf:info "WORD;;ISO routing area tag";
            }
          }
          leaf level {
            tailf:cli-drop-node-name;
            type isis-level-type;
          }
          uses router-rip-redistribute-grouping;
        }
        leaf level {
          tailf:cli-drop-node-name;
          type isis-level-type;
        }
        uses router-rip-redistribute-grouping;
      }

      // router rip / redistribute iso-igrp
      container iso-igrp {
        tailf:info "IGRP for OSI networks";
        presence true;
        list iso-igrp-list {
          tailf:info "Border Gateway Protocol (BGP)";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-drop-node-name;
          key name;
          leaf name {
            tailf:cli-disallow-value "metric|route-map";
            type string {
              tailf:info "WORD;;ISO routing area tag";
            }
          }
          uses router-rip-redistribute-grouping;
        }
        uses router-rip-redistribute-grouping;
      }

      // router rip / redistribute mobile
      container mobile {
        tailf:info "Mobile routes";
        tailf:cli-compact-syntax;
        presence "Mobile routes";
        uses router-rip-redistribute-grouping;
      }

      // router rip / redistribute odr
      container odr {
        tailf:info "On Demand stub Routes";
        tailf:cli-compact-syntax;
        presence "On Demand stub Routes";
        uses router-rip-redistribute-grouping;
      }

      // router rip / redistribute ospf *
      list ospf {
        tailf:info "Open Shortest Path First (OSPF)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          tailf:cli-suppress-range;
          type uint16 {
            tailf:info "<1-65535>;;Process ID";
            range "1..65535";
          }
        }
        uses router-rip-redistribute-grouping;
        uses redistribute-ospf-match-grouping;
      }

      // router rip / redistribute static
      container static {
        tailf:info "Static routes";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence "Static routes";
        uses router-rip-redistribute-grouping;
      }

      // router rip / redistribute rip
      container rip {
        tailf:info "Routing Information Protocol (RIP)";
        tailf:cli-compact-syntax;
        presence true;
        uses router-rip-redistribute-grouping;
      }

      // router rip / redistribute lisp
      container lisp {
        tailf:info "Locator ID Separation Protocol (LISP)";
        tailf:cli-compact-syntax;
        //tailf:cli-keep-when-empty;
        ios:trim-delete-when-empty "( lisp)";
        presence true;
        uses router-rip-redistribute-grouping;
      }
    }

    // router rip / timers basic
    container timers {
      tailf:info "Adjust routing timers";
      container basic {
        tailf:info "Basic routing protocol update timers";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-full-no;
        leaf updates {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          tailf:cli-no-value-on-delete;
          type uint32 {
            tailf:info "1-4294967295;;Interval between updates for RIP";
            range "1..4294967295";
          }
        }
        leaf invalid {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          tailf:cli-no-value-on-delete;
          type uint32 {
            tailf:info "1-4294967295;;Invalid";
            range "1..4294967295";
          }
        }
        leaf holddown {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          tailf:cli-no-value-on-delete;
          type uint32 {
            tailf:info "1-4294967295;;Holddown";
            range "1..4294967295";
          }
        }
        leaf flush {
          tailf:cli-drop-node-name;
          tailf:cli-no-value-on-delete;
          type uint32 {
            tailf:info "1-4294967295;;Flush";
            range "1..4294967295";
          }
        }
        leaf sleep {
          tailf:cli-drop-node-name;
          tailf:cli-no-value-on-delete;
          type uint32 {
            tailf:info "1-4294967295;;Sleep time, in milliseconds";
            range "1..4294967295";
          }
        }
      }
    }

    // router rip / version
    leaf version {
      tailf:info "Set routing protocol version";
      type uint8 {
        tailf:info "1-2;;rip version 1 or 2";
        range "1..2";
      }
    }

    // router rip / traffic-share min across-interfaces
    container traffic-share {
      tailf:info "How to compute traffic share over alternate paths";
      container min {
        tailf:info "All traffic shared among min metric paths";
        leaf across-interfaces {
          tailf:info "Use different interfaces for equal-cost paths";
          type empty;
        }
      }
    }
  }


  // router rip
  // router rip / address-family ipv4 unicast
  grouping router-rip-grouping {

    uses router-rip-af-grouping;

    // router rip / passive-interface
    uses passive-interface-grouping;

    // router rip / output-delay
    leaf output-delay {
      tailf:info "Interpacket delay for RIP updates";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "8-50;;Delay in milliseconds";
        range "8..50";
      }
    }

    // router rip / input-queue
    leaf input-queue {
      tailf:info "Specify input queue depth";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "0-1024;;queue depth. Default 150";
        range "0..1024";
      }
      default 150;
    }

    // router rip / flash-update-threshold
    leaf flash-update-threshold {
      tailf:info "Specify flash update threshold in second";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<0-30>;;threshold in seconds";
        range "0..30";
      }
    }
  }

  grouping router-rip-redistribute-grouping {

    // router rip / redistribute * metric
    leaf metric {
      tailf:info "Metric for redistributed routes";
      type union {
        type uint8 {
          tailf:info "<0-16>;;Default metric";
          range "0..16";
        }
        type enumeration {
          enum transparent {
            tailf:info "Transparently redistribute metric";
          }
        }
      }
    }

    // router rip / redistribute * route-map
    leaf route-map {
      tailf:info "Route map reference";
      type string {
        tailf:info "WORD;;Pointer to route-map entries";
      }
    }
  }

  grouping router-eigrp-redistribute-grouping {

    container metric {
      tailf:info "Metric for redistributed routes";
      tailf:cli-break-sequence-commands;
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf bandwidth-metric {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint32 {
          tailf:info "<1-4294967295>;;Bandwidth metric in Kbits per second";
        }
      }
      leaf delay-metric {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint32 {
          tailf:info "<0-4294967295>;;EIGRP delay metric, in 10 microsecond units";
        }
      }
      leaf reliability-metric {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint8 {
          tailf:info "<0-255>;;EIGRP reliability metric where 255 is 100% reliable";
        }
      }
      leaf effective-bandwidth-metric {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint8 {
          tailf:info "<1-255>;;EIGRP Effective bandwidth metric (Loading) where 255 is 100% loaded";
          range "1..255";
        }
      }
      leaf mtu-bytes {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<1-65535>;;EIGRP MTU of the path";
          range "1..65535";
        }
      }
    }

    leaf route-map {
      tailf:info "Route map reference";
      type string {
        tailf:info "WORD;;Pointer to route-map entries";
      }
    }
  }

  // router eigrp * /
  // router eigrp * / address-family ipv4 / topology base /
  grouping router-eigrp-grouping {

    // router eigrp * / bfd
    container bfd {
      tailf:info "BFD configuration commands";

      // router eigrp * / bfd all-interfaces
      leaf all-interfaces {
        tailf:info "Enable BFD on all interfaces";
        type empty;
      }

      // router eigrp * / bfd interface *
      list interface {
        tailf:info "Enable BFD on specific interface";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Interface Name";
          }
        }
      }
    }

    // router eigrp * / metric
    container metric {
      tailf:info "Modify metrics and parameters for advertisement";

      // router eigrp * / metric maximum-hops
      leaf maximum-hops {
        tailf:info "Advertise greater than <hops> as unreachable";
        type uint8 {
          tailf:info "<1-255>;;Hop count";
          range "1..255";
        }
      }

      // router eigrp * / metric weights
      container weights {
        tailf:info "Modify metric coefficients";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf tos {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<0-8>;;Type (Only TOS 0 supported)";
            range "0..8";
          }
        }
        leaf k1 {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<0-255>;;K1";
          }
        }
        leaf k2 {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<0-255>;;K2";
          }
        }
        leaf k3 {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<0-255>;;K3";
          }
        }
        leaf k4 {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<0-255>;;K4";
          }
        }
        leaf k5 {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<0-255>;;K5";
          }
        }
      }
    }

    // router eigrp * / network *
    container network-ip {
      tailf:cli-drop-node-name;
      list network {
        tailf:info "Enable routing on an IP network";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key ip;
        leaf ip {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Network number";
          }
        }
      }
    }
    list network {
      tailf:info "Enable routing on an IP network";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key "ip mask";
      leaf ip {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Network number";
        }
      }
      leaf mask {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;EIGRP wild card bits";
        }
      }
    }

    // router eigrp * / neighbor *
    container neighbor {
      tailf:info "Specify a neighbor router";
      list neighbor-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "address interface";
        leaf address {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Neighbor address";
          }
        }
        leaf interface {
          tailf:cli-diff-dependency "/ios:interface";
          type string {
            tailf:info "WORD;;Interface name";
          }
        }
      }
    }

    // router eigrp * / eigrp
    container eigrp {
      tailf:info "EIGRP specific commands";

      // router eigrp * / eigrp router-id
      leaf router-id {
        tailf:info "router id for this EIGRP process";
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;EIGRP Router-ID in IP address format";
        }
      }

      // router eigrp * / eigrp stub
      container stub {
        tailf:info "Set address-family in stubbed mode";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        leaf connected {
          tailf:info "Do advertise connected routes";
          type empty;
        }
        leaf static {
          tailf:info "Do advertise static routes";
          type empty;
        }
        leaf summary {
          tailf:info "Do advertise summary routes";
          type empty;
        }
        leaf redistributed {
          tailf:info "Do advertise redistributed routes";
          type empty;
        }
      }

      // router eigrp * / eigrp stub-site
      leaf stub-site {
        tailf:info "Set address-family in stub-site mode";
        tailf:cli-full-command;
        type string {
          tailf:info "ASN:nn or 4BASN:nn Stub-Site ID in aa:nn format";
          pattern "[0-9]+:[0-9]+";
        }
      }

      // router eigrp * / no eigrp log-neighbor-changes
      leaf log-neighbor-changes {
        tailf:info "Enable/Disable EIGRP neighbor logging";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }
    }
  }

  // router eigrp * /
  // router eigrp * / address-family ipv4 / topology base /
  grouping router-eigrp-base-grouping {

    // router eigrp * / distribute-list *
    uses router-distribute-list-grouping;

    // router eigrp * / maximum-secondary-paths
    leaf maximum-secondary-paths {
      tailf:info "Maximum secondary paths";
      type uint8 {
        tailf:info "<1-32>;;Number of paths";
        range "1..32";
      }
    }

    // router eigrp * / variance
    leaf variance {
      tailf:info "Control load balancing variance";
      type uint8 {
        tailf:info "<1-128>;;Metric variance multiplier";
        range "1..128";
      }
    }

    // router eigrp * / timers
    container timers {
      tailf:info "Adjust routing timers";

      // router eigrp * / timers nsf converge
      container nsf {
        tailf:info "EIGRP NSF timer";
        leaf converge {
          tailf:info "EIGRP time limit for convergence after switchover";
          type uint8 {
            tailf:info "<60-180>;;Seconds";
            range "60..180";
          }
        }
      }
    }

    // router eigrp * / maximum-paths
    leaf maximum-paths {
      tailf:info "Forward packets over multiple paths";
      type uint8 {
        tailf:info "<1-32>;;Number of paths";
        range "1..32";
      }
    }

    // router eigrp * / default-metric
    container default-metric {
      tailf:info "Set metric of redistributed routes";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf bandwidth {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint32 {
          tailf:info "<1-4294967295>;;Bandwidth in Kbits per second";
          range "1..4294967295";
        }
      }
      leaf delay {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint32 {
          tailf:info "<0-4294967295>;;delay metric in 10 microsecond units";
          range "0..4294967295";
        }
      }
      leaf reliability {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint8 {
          tailf:info "<0-255>;;Reliability metric where 255 is 100% reliable";
          range "0..255";
        }
      }
      leaf loading {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint8 {
          tailf:info "<1-255>;;Effective bandwidth metric (Loading) where 255 is 100% loaded";
          range "1..255";
        }
      }
      leaf mtu {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<1-65535>;;Maximum Transmission Unit metric of the path";
          range "1..65535";
        }
      }
    }

    // router eigrp * / summary-metric *
    list summary-metric {
      tailf:info "Specify summary to apply metric/filtering";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      key prefix;
      leaf prefix {
        type ios:ipv4-prefix {
          tailf:info "A.B.C.D/nn;;Summary <network>/<length>, e.g., 192.168.0.0/16";
        }
      }
      leaf bandwidth {
        tailf:cli-optional-in-sequence;
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint32 {
          tailf:info "<1-4294967295>;;Bandwidth metric in Kbits per second";
        }
      }
      leaf delay {
        when "../bandwidth" {
          tailf:dependency "../bandwidth";
        }
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint32 {
          tailf:info "<1-4294967295>;;delay metric in 10 microsecond units";
        }
      }
      leaf reliability {
        when "../delay" {
          tailf:dependency "../delay";
        }
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint8 {
          tailf:info "<0-255>;;reliability metric where 255 is 100% reliable";
        }
      }
      leaf load {
        when "../reliability" {
          tailf:dependency "../reliability";
        }
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint8 {
          tailf:info "<0-255>;;Effective bandwidth metric (Loading) where 255 is 100% loaded";
        }
      }
      leaf mtu {
        when "../load" {
          tailf:dependency "../load";
        }
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<1-65535>;;MTU of the path";
          range "1..65535";
        }
      }
      leaf distance {
        tailf:info "Set administrative distance for summary route";
        type uint8 {
          tailf:info "<1-255>;;Administrative distance";
          range "1..255";
        }
      }
    }

    // router eigrp * / offset-list *
    uses router-offset-list-grouping;

    // router eigrp * / redistribute
    container redistribute {
      tailf:info "Redistribute IPv4 routes from another routing protocol";

      // router eigrp * / redistribute connected
      container connected {
        tailf:info "Connected";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-eigrp-redistribute-grouping;
      }

      // router eigrp * / redistribute bgp
      container bgp {
        tailf:info "Border Gateway Protocol (BGP)";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        leaf as-no {
          tailf:cli-drop-node-name;
          type bgp-as-no-type;
        }
        uses router-eigrp-redistribute-grouping;
      }

      // router eigrp * / redistribute eigrp *
      list eigrp {
        tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key as-no;
        leaf as-no {
          type eigrp-as-no-type;
        }
        uses router-eigrp-redistribute-grouping;
      }

      // router eigrp * / redistribute isis
      container isis {
        tailf:info "ISO IS-IS";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence true;
        // router eigrp * / redistribute isis *
        list isis-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key name;
          leaf name {
            tailf:cli-disallow-value "level-1|level-2|level-1-2|metric|route-map";
            type string {
              tailf:info "WORD;;ISO routing area tag";
            }
          }
          leaf level {
            tailf:cli-drop-node-name;
            type isis-level-type;
          }
          uses router-eigrp-redistribute-grouping;
        }
        leaf level {
          tailf:cli-drop-node-name;
          type isis-level-type;
        }
        uses router-eigrp-redistribute-grouping;
      }

      // router eigrp * / redistribute iso-igrp
      container iso-igrp {
        tailf:info "IGRP for OSI networks";
        tailf:cli-delete-when-empty;
        presence true;
        list iso-igrp-list {
          tailf:info "Border Gateway Protocol (BGP)";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-drop-node-name;
          key name;
          leaf name {
            tailf:cli-disallow-value "metric|route-map";
            type string {
              tailf:info "WORD;;ISO routing area tag";
            }
          }
          uses router-eigrp-redistribute-grouping;
        }
        uses router-eigrp-redistribute-grouping;
      }

      // router eigrp * / redistribute mobile
      container mobile {
        tailf:info "Mobile routes";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-eigrp-redistribute-grouping;
      }

      // router eigrp * / redistribute odr
      container odr {
        tailf:info "On Demand stub Routes";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-eigrp-redistribute-grouping;
      }

      // router eigrp * / redistribute ospf *
      list ospf {
        tailf:info "Open Shortest Path First (OSPF)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          tailf:cli-suppress-range;
          type uint16 {
            tailf:info "<1-65535>;;Process ID";
            range "1..65535";
          }
        }
        leaf vrf {
          tailf:info "(DEPRECATED) TRAILING VRF KEYWORD";
          type string {
            tailf:info "WORD;;(DEPRECATED) TRAILING VRF STRING";
          }
        }
        uses redistribute-ospf-match-grouping;
        uses router-eigrp-redistribute-grouping;
      }

      // router eigrp * / redistribute static
      container static {
        tailf:info "Static routes";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-eigrp-redistribute-grouping;
      }

      // router eigrp * / redistribute rip
      container rip {
        tailf:info "Routing Information Protocol (RIP)";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-eigrp-redistribute-grouping;
      }
    }

    // router eigrp * / distance
    container distance {
      tailf:info "Define an administrative distance";

      // router eigrp * / distance eigrp
      container eigrp {
        tailf:info "Set distance for internal and external routes";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf internal-distance {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<1-255>;;Distance for internal routes";
            range "1..255";
          }
        }
        leaf external-distance {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<1-255>;;Distance for external routes";
            range "1..255";
          }
        }
      }

      // router eigrp * / distance *
      list distance-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key "ip-address wildcard-mask";
        leaf ip-address {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP source address";
          }
        }
        leaf wildcard-mask {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Wildcard bits";
          }
        }
        leaf weight {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type uint8 {
            tailf:info "<1-255>;;Administrative distance";
            range "1..255";
          }
        }
        leaf access-list {
          tailf:cli-drop-node-name;
          type std-ip-acl-type;
        }
      }
    }

    // router eigrp * / auto-summary
    leaf auto-summary {
      tailf:info "Enable automatic network number summarization";
      tailf:cli-full-command;
      type empty;
    }

    // router eigrp * / passive-interface
    uses passive-interface-grouping;

    // router eigrp * / nsf
    leaf nsf {
      tailf:info "Non-stop forwarding";
      type empty;
    }
  }


  // router eigrp * / address-family *
  grouping router-eigrp-af-virtual-instance-grouping {

    // router eigrp * / address-family * / af-interface *
    list af-interface {
      tailf:cli-break-sequence-commands;
      tailf:info "Enter Address Family interface configuration";
      tailf:cli-mode-name "config-router-af-interface";
      tailf:cli-exit-command "exit-af-interface" {
        tailf:info "Exit from Address Family Interface configuration";
      }
      tailf:cli-show-long-obu-diffs;
      ordered-by user;
      key name;
      leaf name {
        tailf:cli-diff-dependency "/ios:interface";
        type string {
          tailf:info "WORD;;Interface name";
        }
      }

      // router eigrp * / address-family * / af-interface * / summary-address
      list summary-address {
        tailf:info "Perform address summarization";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key "ip mask";
        leaf ip {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Summary network address";
          }
        }
        leaf mask {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Summary network mask";
          }
        }
        leaf leak-map {
          tailf:info "Allow dynamic prefixes based on the leak-map";
          type string {
            tailf:info "WORD;;leak-map name";
          }
        }
      }
      container summary-address-ipv6 {
        tailf:cli-drop-node-name;
        list summary-address {
          tailf:info "Perform address summarization";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key ipv6;
          leaf ipv6 {
            type ipv6-prefix {
              tailf:info "X:X:X:X::X/<0-128>;;Summary network prefix";
            }
          }
          leaf leak-map {
            tailf:info "Allow dynamic prefixes based on the leak-map";
            type string {
              tailf:info "WORD;;leak-map name";
            }
          }
        }
      }

      // router eigrp * / address-family * / af-interface * / authentication
      container authentication {
        tailf:info "authentication subcommands";

        // router eigrp * / address-family * / af-interface * / authentication mode md5
        container mode {
          tailf:info "authentication mode";
          leaf md5 {
            tailf:info "Keyed message digest";
            type empty;
          }
        }

        // router eigrp * / address-family * / af-interface * / authentication key-chain
        leaf key-chain {
          tailf:info "key-chain";
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;name of key-chain";
          }
        }
      }

      // router eigrp * / address-family * / af-interface * / hello-interval
      leaf hello-interval {
        tailf:info "Configures hello interval";
        type uint16 {
          tailf:info "<1-65535>;;Seconds between hello transmissions";
          range "1..65535";
        }
      }

      // router eigrp * / address-family * / af-interface * / hold-time
      leaf hold-time {
        tailf:info "Configures hold time";
        type uint16 {
          tailf:info "<1-65535>;;Seconds before neighbor is considered down";
          range "1..65535";
        }
      }

      // router eigrp * / address-family * / af-interface * / no next-hop-self
      leaf next-hop-self {
        tailf:info "Configures EIGRP next-hop-self";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // router eigrp * / address-family * / af-interface * / passive-interface
      // router eigrp * / address-family * / af-interface * / no passive-interface
      leaf passive-interface {
        tailf:info "Suppress address updates on an interface";
        tailf:cli-show-no;
        type empty;
      }

      // router eigrp * / address-family * / af-interface * / no split-horizon
      leaf split-horizon {
        tailf:info "Perform split horizon";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // router eigrp * / address-family * / af-interface * / stub-site wan-interface
      container stub-site {
        tailf:info "Stub-Site";
        leaf wan-interface {
          tailf:info "Wan Interface";
          type empty;
        }
      }
    }

    // router eigrp * / address-family * / topology base
    container topology {
      tailf:info "Topology configuration mode";
      container base {
        tailf:info "Base Topology";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-router-af-topology";
        tailf:cli-exit-command "exit-af-topology" {
          tailf:info "Exit from Address Family Topology configuration mode";
        }
        presence true;

        // router eigrp * / address-family * / topology base / redistribute
        uses router-eigrp-base-grouping;
      }
    }

    // router eigrp * / address-family * / network *
    // router eigrp * / address-family * / eigrp
    uses router-eigrp-grouping;

    // router eigrp * / address-family * / maximum-prefix
    container maximum-prefix {
      tailf:info "Maximum number of prefixes acceptable in aggregate";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      leaf max-prefix-no {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<1-4294967295>;;Number of prefixes for maximum-prefix limit";
          range "1..4294967295";
        }
      }
      leaf threshold {
        tailf:cli-drop-node-name;
        tailf:cli-break-sequence-commands;
        type uint8 {
          tailf:info "<1-100>;;Threshold value (%) at which to generate a warning message";
          range "1..100";
        }
      }
      leaf restart {
        tailf:info "Duration for which a prefix source is ignored";
        type uint16 {
          tailf:info "<1-65535>;;Restart interval in minutes";
          range "1..65535";
        }
      }
      leaf warning-only {
        tailf:info "Only give warning message when limit is exceeded";
        tailf:cli-full-command;
        type empty;
      }
    }
  }


  // router/isis grouping
  grouping spf-intervals-grouping {
    leaf interval {
      tailf:cli-drop-node-name;
      type uint8 {
        tailf:info "<1-120>;;Interval between consecutive SPFs in seconds";
        range "1..120";
      }
    }
    leaf initial-wait {
      tailf:cli-drop-node-name;
      type uint32 {
        tailf:info "<1-120000>;;Initial wait before first SPF in milliseconds";
        range "1..120000";
      }
    }
    leaf minimum-wait {
      tailf:cli-drop-node-name;
      type uint32 {
        tailf:info "<1-120000>;;Minimum wait between first and second SPF in milliseconds";
        range "1..120000";
      }
    }
  }

  // router/isis grouping
  grouping router-isis-authenticate-snp-grouping {
    leaf authenticate {
      tailf:info "Authentication";
      tailf:cli-incomplete-command;
      type empty;
    }
    leaf snp {
      tailf:info "SNP PDUs";
      type enumeration {
        enum send-only {
          tailf:info "Send but do not check PDUs on receiving";
        }
        enum validate {
          tailf:info "Send and check PDUs on receiving";
        }
      }
    }
  }

  // router/isis grouping
  grouping lsp-gen-interval-grouping {
    leaf interval {
      tailf:cli-drop-node-name;
      type uint32 {
        range "1..120";
        tailf:info "<1-120>;;Interval in seconds";
      }
    }
    leaf initial-wait {
      tailf:cli-drop-node-name;
      type uint32 {
        range "1..120000";
        tailf:info "<1-120000>;;Initial wait in milliseconds";
      }
    }
    leaf wait {
      tailf:cli-drop-node-name;
      type uint32 {
        range "1..120000";
        tailf:info "<1-120000>;;Wait between first and second lsp generation in milliseconds";
      }
    }
  }

  // router/isis grouping
  grouping set-overload-bit-suppress-grouping {
    leaf external {
      tailf:info "If overload-bit set, don't advertise IP prefixes learned from other protocols";
      tailf:cli-break-sequence-commands;
      type empty;
    }
    leaf interlevel {
      tailf:info "If overload-bit set, don't advertise IP prefixes learned from another ISIS level";
      type empty;
    }
  }


  // router/isis grouping
  grouping redist-level-grouping {
    leaf level {
      tailf:cli-drop-node-name;
      tailf:cli-break-sequence-commands;
      type isis-level-type;
    }
  }


  grouping router-isis-redistribute-grouping {

    // router isis * / redistribute * metric
    leaf metric {
      tailf:info "ISIS default metric";
      type uint32 {
        tailf:info "<0-4294967295>;;ISIS default metric";
        range "0..4294967295";
      }
    }

    // router isis * / redistribute * route-map
    leaf route-map {
      tailf:info "Route map reference";
      type string {
        tailf:info "WORD;;Pointer to route-map entries";
      }
    }

    // router isis * / redistribute * metric-type
    leaf metric-type {
      tailf:info "OSPF/IS-IS exterior metric type for redistributed routes";
      type enumeration {
        enum external {
          tailf:info "Set IS-IS External metric type";
        }
        enum internal {
          tailf:info "Set IS-IS Internal metric type";
        }
      }
      default internal;
    }

    // router isis * / redistribute * level-1
    // router isis * / redistribute * level-1-2
    uses router-isis-level-grouping;
  }


  grouping router-isis-af-redistribute-grouping {

    // router isis * / address-family ipv6 / redistribute * metric
    leaf metric {
      tailf:info "ISIS default metric";
      type uint32 {
        tailf:info "<0-4294967295>;;ISIS default metric";
        range "0..4294967295";
      }
    }

    // router isis * / address-family ipv6 / redistribute * metric-type
    leaf metric-type {
      tailf:info "OSPF/IS-IS exterior metric type for redistributed routes";
      type enumeration {
        enum external {
          tailf:info "Set IS-IS External metric type";
        }
        enum internal {
          tailf:info "Set IS-IS Internal metric type";
        }
      }
    }

    // router isis * / address-family ipv6 / redistribute * level-1
    // router isis * / address-family ipv6 / redistribute * level-1-2
    uses router-isis-level-grouping;

    // router isis * / address-family ipv6 / redistribute * route-map
    leaf route-map {
      tailf:info "Route map reference";
      type string {
        tailf:info "WORD;;Pointer to route-map entries";
      }
    }

    // router isis * / address-family ipv6 / redistribute * include-connected
    leaf include-connected {
      tailf:info "Include connected";
      type empty;
    }
  }


  // router/isis grouping
  grouping isis-redist-ospf-match-grouping {
    uses redist-level-grouping;
    leaf metric {
      tailf:info "ISIS default metric";
      type uint32 {
        tailf:info "<0-4294967295>;;ISIS default metric";
        range "0..4294967295";
      }
    }
    leaf route-map {
      tailf:info "Route map reference";
      type string {
        tailf:info "WORD;;Pointer to route-map entries";
      }
    }
  }

  // router isis
  // router isis *
  // interface * / isis
  grouping router-isis-interface-grouping {

    // router isis * / authentication
    container authentication {
      tailf:info "ISIS authentication for LSPs";

      // router isis * / authentication mode
      container mode {
        tailf:info "Authentication mode";
        choice mode-choice {

          // router isis * / authentication mode md5
          container md5 {
            tailf:info "Keyed message digest";
            tailf:cli-delete-when-empty;
            tailf:cli-reset-container;
            presence true;
            uses router-isis-level-grouping;
          }

          // router isis * / authentication mode text
          container text {
            tailf:info "Clear text password";
            tailf:cli-delete-when-empty;
            tailf:cli-reset-container;
            presence true;
            uses router-isis-level-grouping;
          }
        }
      }

      // router isis * / authentication key-chain * level-1|level-2
      list key-chain {
        tailf:info "Authentication key-chain";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        ios:level-1-2-expand;
        key level;
        leaf name {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type string {
            tailf:info "WORD;;Name of key-chain";
          }
        }
        leaf level {
          type enumeration {
            enum level-1 {
              tailf:info "ISIS authentication for level-1";
            }
            enum level-2 {
              tailf:info "ISIS authentication for level-2";
            }
          }
        }
      }

      // router isis * / authentication send-only
      container send-only {
        tailf:info "Authentication send only, receive ignore";
        tailf:cli-delete-when-empty;
        tailf:cli-reset-container;
        presence true;
        uses router-isis-level-grouping;
      }
    }
  }


  // router isis
  // router isis *
  // router isis * / address-family ipv6 unicast
  grouping router-isis-af-early-grouping {

    // router isis * / metric-style
    container metric-style {
      tailf:info "Use old-style (ISO 10589) or new-style packet formats";
      choice metric-style-choice {

        // router isis * / metric-style narrow
        container narrow {
          tailf:info "Use old style of TLVs with narrow metric";
          tailf:cli-compact-syntax;
          tailf:cli-delete-when-empty;
          tailf:cli-reset-container;
          presence true;
          uses router-isis-metric-type-grouping;
        }

        // router isis * / metric-style transition
        container transition {
          tailf:info "Send and accept both styles of TLVs during transition";
          tailf:cli-compact-syntax;
          tailf:cli-delete-when-empty;
          tailf:cli-reset-container;
          presence true;
          leaf level {
            tailf:cli-drop-node-name;
            type isis-level-type;
          }
        }

        // router isis * / metric-style wide
        container wide {
          tailf:info "Use new style of TLVs to carry wider metric";
          tailf:cli-compact-syntax;
          tailf:cli-delete-when-empty;
          tailf:cli-reset-container;
          presence true;
          uses router-isis-metric-type-grouping;
        }
      }
    }
  }


  // router/isis grouping
  grouping router-isis-metric-type-grouping {
    leaf transition {
      tailf:info "Accept both styles of TLVs during transition";
      type empty;
    }
    leaf level {
      tailf:cli-drop-node-name;
      tailf:cli-full-command;
      type isis-level-type;
    }
  }


  // router isis
  // router isis *
  // router isis * / address-family ipv6 unicast
  grouping router-isis-af-late-grouping {

    // router isis * / no adjacency-check
    leaf adjacency-check {
      tailf:info "Check ISIS neighbor protocol support";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
      default true;
    }

    // router isis * / set-overload-bit
    container set-overload-bit {
      tailf:info "Signal other routers not to use us in SPF";
      tailf:cli-delete-when-empty;
      tailf:cli-reset-container;
      presence true;

      choice set-overload-bit-choice {

        // router isis * / set-overload-bit on-startup
        container on-startup {
          tailf:info "Set overload-bit only temporarily after reboot";
          choice on-startup-choice {
            container time {
              tailf:cli-drop-node-name;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              leaf time {
                tailf:cli-drop-node-name;
                type uint32 {
                  tailf:info "<5-86400>;;Time in seconds to advertise ourself as overloaded after reboot";
                  range "5..86400";
                }
              }
              leaf suppress {
                tailf:info "If overload-bit set, suppress the following types of IP prefixes";
                tailf:cli-incomplete-command;
                type empty;
              }
              uses set-overload-bit-suppress-grouping;
            }
            container wait-for-bgp {
              tailf:info "Let BGP decide when to unset the overload bit";
              presence true;
              container suppress {
                tailf:info "If overload-bit set, suppress the following types of IP prefixes";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands;
                uses set-overload-bit-suppress-grouping;
              }
            }
          }
        }

        // router isis * / set-overload-bit suppress
        container suppress {
          tailf:info "If overload-bit set, suppress the following types of IP prefixes";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          uses set-overload-bit-suppress-grouping;
        }
      }
    }

    // router isis * / spf-interval
    container spf-interval {
      tailf:info "Minimum interval between SPF calculations";
      tailf:cli-compact-syntax;
      choice spf-interval-choice {
        list level-1-2 {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-incomplete-command;
          key level;
          leaf level {
            type enumeration {
              enum level-1 {
                tailf:info "Set interval for level 1 only";
              }
              enum level-2 {
                tailf:info "Set interval for level 2 only";
              }
            }
          }
          uses spf-intervals-grouping;
        }
        container intervals {
          tailf:cli-drop-node-name;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          uses spf-intervals-grouping;
        }
      }
    }

    // router isis * / prc-interval
    container prc-interval {
      tailf:info "Minimum interval between partial route calculations";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf interval {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<1-120>;;PRC interval in seconds";
          range "1..120";
        }
      }
      leaf initial-wait {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<1-120000>;;Initial wait for PRC in milliseconds";
          range "1..120000";
        }
      }
      leaf minimum-wait {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<1-120000>;;Minimum wait between first and second PRC in milliseconds";
          range "1..120000";
        }
      }
    }

    // router isis * / metric
    choice metric-choice {
      case default-case {
        container metric {
          tailf:info "Set ISIS metric for all interfaces";
          tailf:cli-diff-dependency "../metric-style";
          leaf default {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-16777214>;;Default metric";
              range "1..16777214";
            }
          }
        }
      }
      case level-case {
        container metric-level {
          tailf:cli-drop-node-name;
          tailf:cli-diff-dependency "../metric-style";
          list metric {
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            key level;
            leaf level {
              type enumeration {
                enum level-1 {
                  tailf:info "Apply metric to level-1 links";
                }
                enum level-2 {
                  tailf:info "Apply metric to level-2 links";
                }
              }
            }
            leaf default {
              tailf:cli-drop-node-name;
              tailf:cli-prefix-key;
              type uint32 {
                tailf:info "<1-16777214>;;Default metric";
                range "1..16777214";
              }
            }
          }
        }
      }
    }

    // router isis * / maximum-paths
    leaf maximum-paths {
      tailf:info "Forward packets over multiple paths";
      tailf:cli-full-command;
      type uint32 {
        tailf:info "<1-32>;;Number of paths";
        range "1..32";
      }
    }

    // router isis * / default-information originate
    container default-information {
      tailf:info "Control distribution of default information";
      container originate {
        tailf:info "Distribute a default route";
        tailf:cli-delete-when-empty;
        tailf:cli-reset-container;
        presence true;
        leaf route-map {
          tailf:info "Route-map reference";
          type string {
            tailf:info "WORD;;Route map name";
          }
        }
      }
    }
  }

  // router isis
  // router isis *
  grouping router-isis-grouping {

    // router isis * / vrf
    leaf vrf {
      tailf:info "VRF name for this process";
      tailf:cli-diff-dependency "/ios:ip/vrf";
      tailf:cli-diff-dependency "/ios:vrf/definition";
      type string {
        tailf:info "WORD;;VRF name";
      }
    }

    // router isis * / protocol shutdown
    container protocol {
      tailf:info "Set protocol's administrative state";
      leaf shutdown {
        tailf:info "Set protocol's administrative state to disable";
        type empty;
      }
    }

    // router isis * / max-area-addresses
    leaf max-area-addresses {
      tailf:info "Allow configuration of more manual area addresses";
      tailf:cli-full-command;
      type uint32 {
        tailf:info "<3-254>;;Max number of manual area addresses. Default 3";
        range "3..254";
      }
      default 3;
    }

    // router isis * / net *
    list net {
      tailf:info "A Network Entity Title for this process (OSI only)";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key tag;
      leaf tag {
        type string {
          tailf:info "XX.XXXX. ... .XXX.XX;;Network entity title (NET)";
        }
      }
    }

    // router isis * / is-type
    leaf is-type {
      tailf:info "IS Level for this routing process (OSI only)";
      tailf:cli-full-command;
      type enumeration {
        enum level-1 {
          tailf:info "Act as a station router only";
        }
        enum level-1-2 {
          tailf:info "Act as both a station router and an area router";
        }
        enum level-2-only {
          tailf:info "Act as an area router only";
        }
      }
      default level-1-2;
    }

    // router isis * / advertise
    container advertise {
      tailf:info "Control which IP routes flow in L1 and L2 LSPs";

      // router isis * / advertise passive-only
      leaf passive-only {
        tailf:info "only interface address of passive interfaces";
        type empty;
      }

      // router isis * / advertise link attributes
      container link {
        tailf:info "Advertise protocol link";
        leaf attributes {
          tailf:info "Advertise link attributes";
          type empty;
        }
      }
    }

    // router isis * / authentication
    uses router-isis-interface-grouping;

    // router isis * / area-password
    container area-password {
      tailf:info "Configure the authentication password for an area";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf name {
        tailf:cli-drop-node-name;
        ios:password-dequote-output "area-password (\\S+)";
        type NEDCOM_SECRET_TYPE {
          tailf:info "WORD;;Area password";
        }
      }
      uses router-isis-authenticate-snp-grouping;
    }

    // router isis * / ispf
    container ispf {
      tailf:info "Configure execution of incremental SPF";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf level {
        tailf:cli-drop-node-name;
        type enumeration {
          enum level-1 {
            tailf:info "Do incremental SPF for level-1";
          }
          enum level-1-2 {
            tailf:info "Do incremental SPF for both levels";
          }
          enum level-2 {
            tailf:info "Do incremental SPF for level-2";
          }
        }
      }
      leaf number {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<1-600>;;Number of seconds before activating incremental-spf";
          range "1..600";
        }
      }
    }

    // router isis * / purge-transmit strict
    container purge-transmit {
      tailf:info "LSP Purge TLV content";
      container strict {
        tailf:info "minimal TLVs in purges";
        leaf level-1 {
          tailf:info "purge transmit for level-1";
          type empty;
        }
        leaf level-2 {
          tailf:info "purge transmit for level-2";
          type empty;
        }
      }
    }

    // router isis * / metric-style
    uses router-isis-af-early-grouping;

    // router isis * / ignore-attached-bit
    leaf ignore-attached-bit {
      tailf:info "Never install default route to closest L2 route";
      type empty;
    }

    // router isis * / fast-flood
    container fast-flood {
      tailf:info "Flood LSPs (that triggered SPF) before running SPF";
      tailf:cli-delete-when-empty;
      tailf:cli-reset-container;
      presence true;
      leaf number {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-15>;;number of LSPs to be flooded before starting SPF";
          range "1..15";
        }
      }
    }

    // router isis * / ip route
    container ip {
      tailf:info "IP specific commands";
      container route {
        tailf:info "ISIS IP routes";
        container priority {
          tailf:info "Assign priority to IP prefixes";
          container high {
            tailf:info "Assign high priority to important IP prefixes in ISIS IP local RIB";
            leaf tag {
              tailf:info "Assign high priority to IP prefixes with a specific route tag";
              type uint32 {
                tailf:info "<1-4294967295>;;tag value";
                range "1..4294967295";
              }
            }
          }
        }
      }
    }

    // router isis * / set-attached-bit
    container set-attached-bit {
      tailf:info "Conditionally advertise us as attached to L2";
      leaf route-map {
        tailf:info "Route-map reference";
        type string {
          tailf:info "WORD;;Route map name";
        }
      }
    }

    // router isis * / max-lsp-lifetime
    leaf max-lsp-lifetime {
      tailf:info "Set maximum LSP lifetime";
      tailf:cli-full-command;
      type uint32 {
        tailf:info "<1-65535>;;Maximum LSP lifetime in seconds. Default 1200";
        range "1..65535";
      }
      default 1200;
    }

    // router isis * / lsp-refresh-interval
    leaf lsp-refresh-interval {
      tailf:info "Set LSP refresh interval";
      tailf:cli-full-command;
      type uint32 {
        tailf:info "<1-65535>;;LSP refresh time in seconds. Default 900";
        range "1..65535";
      }
      default 900;
    }

    // router isis * / lsp-gen-interval
    container lsp-gen-interval {
      tailf:info "Minimum interval between regenerating same LSP";
      choice lsp-gen-interval-choice {
        container intervals {
          tailf:cli-drop-node-name;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          uses lsp-gen-interval-grouping;
        }
        container intervals-levels {
          tailf:cli-drop-node-name;
          container intervals-level-1 {
            tailf:cli-drop-node-name;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf level-1 {
              tailf:info "Set interval for level 1 only";
              type empty;
            }
            uses lsp-gen-interval-grouping;
          }
          container intervals-level-2 {
            tailf:cli-drop-node-name;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf level-2 {
              tailf:info "Set interval for level 2 only";
              type empty;
            }
            uses lsp-gen-interval-grouping;
          }
        }
      }
    }

    // router isis * / use external-metrics
    container use {
      tailf:info "Use different algorithms during SPF";
      leaf external-metrics {
        tailf:info "Honour external metrics during SPF";
        type empty;
      }
    }

    // router isis * / no ignore-lsp-errors
    leaf ignore-lsp-errors {
      tailf:info "Ignore LSPs with bad checksums";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
      default true;
    }

    // router isis * / no hostname dynamic
    container hostname {
      tailf:info "Dynamic hostname for IS-IS";
      leaf dynamic {
        tailf:info "Dynamic hostname";
        tailf:cli-boolean-no;
        type boolean;
        default true;
      }
    }

    // router isis * / log-adjacency-changes
    container log-adjacency-changes {
      tailf:info "Log changes in adjacency state";
      tailf:cli-delete-when-empty;
      tailf:cli-reset-container;
      presence true;
      leaf all {
        tailf:info "Include changes generated by non-IIH event";
        type empty;
      }
    }

    // router isis * / partition avoidance
    container partition {
      tailf:info "CLNS area partition";
      leaf avoidance {
        tailf:info "Withdraw area prefix if partition detected";
        type empty;
      }
    }

    // router isis * / lsp-mtu
    leaf lsp-mtu {
      tailf:info "Set maximum LSP size";
      tailf:cli-full-command;
      type uint32 {
        tailf:info "<128-4352>;;Max LSP size in bytes. Default 1492";
        range "128..4352";
      }
      default 1492;
    }

    // router isis * / lsp-full
    container lsp-full {
      tailf:info "If we run out of LSP fragments";
      container suppress {
        tailf:info "suppress the following types of IP prefixes";
        choice lsp-full-choince {
          container external-interlevel-container {
            tailf:cli-drop-node-name;
            tailf:cli-compact-syntax;
            leaf external {
              tailf:info "don't advertise IP prefixes learned from other protocols";
              type empty;
            }
            leaf interlevel {
              tailf:info "don't advertise IP prefixes learned from another ISIS level";
              type empty;
            }
          }
          leaf none {
            tailf:info "don't suppress any prefixes";
            type empty;
          }
        }
      }
    }

    // router isis * / update-queue-depth
    leaf update-queue-depth {
      tailf:info "Set Update process queue depth";
      type uint32 {
        tailf:info "<1-2147483647>;;Max queue depth. Default 200";
        range "1..2147483647";
      }
      default 200;
    }

    // router isis * / nsf
    container nsf {
      tailf:info "Non-stop forwarding";

      // router isis * / nsf cisco
      leaf cisco {
        tailf:info "Checkpoint method";
        tailf:cli-diff-dependency "../../net";
        type empty;
      }

      // router isis * / nsf ietf
      leaf ietf {
        tailf:info "IETF method";
        type empty;
      }

      // router isis * / nsf interval
      leaf interval {
        tailf:info "Minimum required stable interval between restarts";
        tailf:cli-diff-dependency "../ietf";
        type uint16 {
          tailf:info "<0-1440>;;Minutes";
          range "0..1440";
        }
        default 5;
      }

      // router isis * / nsf interface wait
      container interface {
        tailf:info "Interface properties";
        leaf wait {
          tailf:info "Maximum time to wait for interface up";
          type uint8 {
            tailf:info "<1-60>;;Seconds";
            range "1..60";
          }
          default 10;
        }
      }
    }

    // router isis * / bfd all-interfaces
    container bfd {
      tailf:info "BFD configuration commands";
      leaf all-interfaces {
        tailf:info "Enable BFD on all interfaces";
        type empty;
      }
    }

    // router isis * / distance *
    container distance {
      tailf:info "Define an administrative distance";

      // router isis * / distance * ip
      container distance-ip {
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf distance {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<1-255>;;Administrative distance";
            range "1..255";
          }
        }
        leaf ip {
          tailf:info "Distance applied for IP derived routes";
          type empty;
        }
      }

      // router isis * / distance * <ip-address> <wildcard-bits>
      list distance-network-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key "ip-address wildcard-mask";
        leaf ip-address {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP Source address";
          }
        }
        leaf wildcard-mask {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Wildcard bits";
          }
        }
        leaf distance {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type uint8 {
            tailf:info "<1-255>;;Administrative distance";
            range "1..255";
          }
        }
        leaf access-list {
          tailf:cli-drop-node-name;
          type std-ip-acl-type;
        }
      }

      // router isis * / distance * clns
      container distance-clns {
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf distance {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<1-255>;;OSPF Administrative distance";
            range "1..255";
          }
        }
        leaf clns {
          tailf:info "Distance applied for CLNS derived routes";
          type empty;
        }
      }
    }

    // router isis * / domain-password
    container domain-password {
      tailf:info "Set the authentication password for a routing domain";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf name {
        tailf:cli-drop-node-name;
        ios:password-dequote-output "domain-password (\\S+)";
        type NEDCOM_SECRET_TYPE {
          tailf:info "WORD;;Routing domain password";
        }
      }
      uses router-isis-authenticate-snp-grouping;
    }

    // router isis * / no hello padding
    container hello {
      tailf:info "Pad ISIS hello PDUs to full MTU";
      choice padding-choice {

        // router isis * / no hello padding multi-point
        container padding-multi-point {
          tailf:cli-drop-node-name;
          container padding {
            tailf:info "Pad hello PDU";
            tailf:cli-incomplete-no;
            tailf:cli-incomplete-command;
            leaf multi-point {
              tailf:info "Pad LAN hello PDUs";
              tailf:cli-boolean-no;
              type boolean;
              default true;
            }
          }
        }

        // router isis * / no hello padding point-to-point
        container padding-point-to-point {
          tailf:cli-drop-node-name;
          container padding {
            tailf:info "Pad hello PDU";
            tailf:cli-incomplete-no;
            tailf:cli-incomplete-command;
            leaf point-to-point {
              tailf:info "Pad point-to-point hello PDUs";
              tailf:cli-boolean-no;
              type boolean;
              default true;
            }
          }
        }

        // router isis * / no hello padding
        leaf padding {
          tailf:info "Pad hello PDU";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          tailf:cli-full-no;
          type boolean;
          default true;
        }
      }
    }

    // router isis * / traffic-share
    container traffic-share {
      tailf:info "How to compute traffic share over alternate paths";
      container min {
        tailf:info "All traffic shared among min metric paths";
        leaf across-interfaces {
          tailf:info "Use different interfaces for equal-cost paths";
          type empty;
        }
      }
    }

    // router isis * / microloop avoidance
    container microloop {
      tailf:info "Enable microloop protection configuration commands";
      container avoidance {
        tailf:info "Enable local microloop avoidance";
        tailf:cli-delete-when-empty;
        tailf:cli-reset-container;
        presence true;
        choice avoidance-choice {
          // router isis * / microloop avoidance protected
          leaf protected {
            tailf:info "Microloop avoidance for protected link or prefix only";
            type empty;
          }
          // router isis * / microloop avoidance disable
          leaf disable {
            tailf:info "Disable Microloop avoidance";
            type empty;
          }
          leaf segment-routing {
            tailf:info "Configuring Segment-Routing Microloop Avoidance";
            type empty;
          }
        }
      }

      // router isis * / microloop avoidance
      container avoidance-conf {
        tailf:cli-drop-node-name;
        container avoidance {
          tailf:info "Enable local microloop avoidance";

          // router isis * / microloop avoidance segment-routing
          leaf segment-routing {
            tailf:info "Configuring Segment-Routing Microloop Avoidance";
            type empty;
          }

          // router isis * / microloop avoidance rib-update-delay
          leaf rib-update-delay {
            tailf:info "Microloop avoidance RIB update delay";
            type uint32 {
              tailf:info "<1-600000>;;Value of the delay in milliseconds (default 5000)";
              range "1..600000";
            }
          }
        }
      }
    }

    // router isis * / affinity-map * bit-position *
    list affinity-map {
      tailf:info "affinity-map";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      unique bit-position;
      key name;
      leaf name {
        type string {
          tailf:info "Affinity color name";
        }
      }
      leaf bit-position {
        tailf:info "Bit position";
        type uint8 {
          tailf:info "<0-255>;;index";
          range "0..255";
        }
      }
    }

    // router isis * / flex-algo *
    list flex-algo {
      tailf:info "Flex algorithm mode";
      tailf:cli-mode-name "config-isis-fa";
      tailf:cli-diff-delete-before "../net";
      key id;
      leaf id {
        type uint8 {
          tailf:info "<128-255>;;Flex algorithm value";
          range "128..255";
        }
      }

      // router isis * / flex-algo * / advertise-definition
      leaf advertise-definition {
        tailf:info "Advertise definition";
        type empty;
      }

      // router isis * / flex-algo * / priority
      leaf priority {
        tailf:info "Priority";
        type uint8 {
          tailf:info "<0-255>;;Value";
        }
      }

      // router isis * / flex-algo * / metric-type delay
      container metric-type {
        tailf:info "Metric type";
        leaf delay {
          tailf:info "delay";
          type empty;
        }
      }

      // router isis * / flex-algo * / affinity
      container affinity {
        tailf:info "Assign affinities to flex algorithm";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-fa-affinity";

        // router isis * / flex-algo * / affinity / *
        list attribute-list {
          tailf:cli-drop-node-name;
          tailf:cli-mode-name "config-fa-affinity-xxx";
          tailf:cli-exit-command "exit-fa-affinity-attr" {
            tailf:info "Exit from ISIS Flex affinity attr mode";
          }
          key id;
          leaf id {
            type enumeration {
              enum exclude-any {
                tailf:info "Affinity attributes to exclude";
              }
              enum include-all {
                tailf:info "Enter include-all mode";
              }
              enum include-any {
                tailf:info "Affinity attributes to include";
              }
            }
          }

          // router isis * / flex-algo * / affinity / * / name *
          list name {
            tailf:info "Affinity color name";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;Affinity color name";
              }
            }
          }
        }
      }
    }

    // router isis * / display-route-detail
    leaf display-route-detail {
      tailf:info "Display detailed IP route information";
      type empty;
    }

    // router isis * / distribute link-state
    container distribute {
      tailf:info "Configure distribute";
      container link-state {
        tailf:info "Enable link-state distribution";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        tailf:cli-reset-container;
        presence true;
        leaf instance-id {
          tailf:info "Set distribution process instance identifier";
          type uint32 {
            tailf:info "<32-4294967294>;;Instance ID Value";
            range "32..4294967294";
          }
        }
        leaf level {
          tailf:cli-drop-node-name;
          type enumeration {
            enum level-1 {
              tailf:info "Apply to level-1";
            }
            enum level-2 {
              tailf:info "Apply to level-2";
            }
          }
        }
        leaf throttle {
          tailf:info "Set throttle update in seconds";
          type uint8 {
            tailf:info "<5-20>;;Specify the throttle value in seconds";
            range "5..20";
          }
        }
      }
    }

    // router isis * / ucmp local
    container ucmp {
      tailf:info "Configure UCMP";
      container local {
        tailf:info "Enable UCMP Local";
        tailf:cli-delete-when-empty;
        tailf:cli-reset-container;
        presence true;
        leaf prefix-list {
          tailf:info "Filter prefixes in UCMP routing updates";
          type string {
            tailf:info "WORD;;Name of an IP prefix-list";
          }
        }
      }
    }

    // router isis * / segment-routing
    container segment-routing {
      tailf:info "Enable Segment Routing Feature";

      // router isis * / segment-routing mpls
      leaf mpls {
        tailf:info "Enable Segment Routing Feature using MPLS encapsulation";
        tailf:cli-diff-dependency "../../net";
        type empty;
      }

      // router isis * / segment-routing prefix-sid-map advertise-local
      container prefix-sid-map {
        tailf:info "Enable prefix-sid-map";
        leaf advertise-local {
          tailf:info "Advertise active local prefix-SID mappings";
          type empty;
        }
      }
    }

    // router isis * / fast-reroute
    container fast-reroute {
      tailf:info "Configure Fast-Reroute";

      // router isis * / fast-reroute per-prefix
      container per-prefix {
        tailf:info "Enable Fast-Reroute Per-Prefix";

        // router isis * / fast-reroute per-prefix level-1
        container level-1 {
          tailf:info "Apply to level-1";
          choice level-choice {
            leaf route-map {
              tailf:info "route-map for selecting primary paths for protection";
              type string {
                tailf:info "WORD;;route-map name";
              }
            }
            leaf all {
              tailf:info "Enable Fast-Reroute for primary paths";
              type empty;
            }
          }
        }

        // router isis * / fast-reroute per-prefix level-2
        container level-2 {
          tailf:info "Apply to level-2";
          choice level-choice {
            leaf route-map {
              tailf:info "route-map for selecting primary paths for protection";
              type string {
                tailf:info "WORD;;route-map name";
              }
            }
            leaf all {
              tailf:info "Enable Fast-Reroute for primary paths";
              type empty;
            }
          }
        }
      }

      // router isis * / fast-reroute tie-break *
      list tie-break {
        tailf:info "Set repair path preference";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key level;
        leaf level {
          type enumeration {
            enum level-1 {
              tailf:info "Apply to level-1";
            }
            enum level-2 {
              tailf:info "Apply to level-2";
            }
          }
        }

        // router isis * / fast-reroute tie-break * srlg-disjoint
        leaf srlg-disjoint {
          tailf:info "Prefer SRLG disjoint repair path";
          type uint8 {
            tailf:info "<1-255>;;priority number";
            range "1..255";
          }
        }
      }

      // router isis * / fast-reroute remote-lfa
      container remote-lfa {
        tailf:info "Configuring fast-reroute remote-lfa";
        // router isis * / fast-reroute remote-lfa level-1
        container level-1 {
          tailf:info "Apply to level-1";
          container mpls-ldp {
            tailf:info "Use mpls-ldp tunnel type";
            tailf:cli-delete-when-empty;
            presence true;
            leaf maximum-metric {
              tailf:info "maximum metric to reach release node";
              type uint32 {
                tailf:info "<1-4294967295>;;metric value";
              }
            }
          }
        }
        // router isis * / fast-reroute remote-lfa level-2
        container level-2 {
          tailf:info "Apply to level-2";
          container mpls-ldp {
            tailf:info "Use mpls-ldp tunnel type";
            tailf:cli-delete-when-empty;
            presence true;
            leaf maximum-metric {
              tailf:info "maximum metric to reach release node";
              type uint32 {
                tailf:info "<1-4294967295>;;metric value";
              }
            }
          }
        }
      }

      // router isis * / fast-reroute ti-lfa *
      list ti-lfa {
        tailf:info "Configuring fast-reroute TI-LFA";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key level;
        leaf level {
          type enumeration {
            enum level-1 {
              tailf:info "Apply to level-1";
            }
            enum level-2 {
              tailf:info "Apply to level-2";
            }
          }
        }
        leaf maximum-metric {
          tailf:info "Maximum metric to reach release node";
          type uint32 {
            tailf:info "<1-4294967295>;;Metric value";
            range "1..4294967295";
          }
        }
      }
    }

    // router isis * / mpls
    container mpls {
      tailf:info "Configure MPLS routing protocol parameters";
      tailf:cli-diff-dependency "../metric-style";
      tailf:cli-diff-delete-before "../metric-style/narrow" {
        tailf:cli-when-target-set;
      }

      // router isis * / mpls ldp
      container ldp {
        tailf:info "routing protocol commands for MPLS LDP";

        // router isis * / mpls ldp sync-igp-shortcuts
        leaf sync-igp-shortcuts {
          tailf:info "Configure LDP-IGP Synchronization on MPLS shortcuts";
          type empty;

        }

        // router isis * / mpls ldp sync
        leaf sync {
          tailf:info "Configure LDP-IGP Synchronization";
          type empty;
        }

        // router isis * / mpls ldp ac-igp-shortcuts
        container ac-igp-shortcuts {
          tailf:info "Autoconfigure LDP on IGP shortcuts";
          tailf:cli-delete-when-empty;
          tailf:cli-reset-container;
          presence true;
          leaf level {
            tailf:cli-drop-node-name;
            type enumeration {
              enum level-1 {
                tailf:info "Configure ISIS level-1 to run MPLS LDP";
              }
              enum level-2 {
                tailf:info "Configure ISIS level-2 to run MPLS LDP";
              }
            }
          }
        }

        // router isis * / mpls ldp auto-config
        container autoconfig {
          tailf:info "Configure LDP automatic configuration";
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          presence true;
          choice level-choice {
            leaf level-1 {
              tailf:info "Configure ISIS level-1 to run MPLS LDP";
              type empty;
            }
            leaf level-2 {
              tailf:info "Configure ISIS level-2 to run MPLS LDP";
              type empty;
            }
          }
        }
      }

      // router isis * / mpls traffic-eng
      container traffic-eng {
        tailf:info "routing protocol commands for MPLS Traffic Engineering";

        // router isis * / mpls traffic-eng level-1
        leaf level-1 {
          tailf:info "Run MPLS TE on IS-IS level 1 only";
          tailf:cli-full-command;
          type empty;
        }

        // router isis * / mpls traffic-eng level-2
        leaf level-2 {
          tailf:info "Run MPLS TE on IS-IS level 2 only";
          tailf:cli-full-command;
          type empty;
        }

        // router isis * / mpls traffic-eng multicast-intact
        leaf multicast-intact {
          tailf:info "MPLS TE and PIM interaction";
          tailf:cli-full-command;
          type empty;
        }

        // router isis * / mpls traffic-eng router-id
        container router-id {
          tailf:info "Traffic Engineering stable IP address for system";
          uses interface-name-grouping;
        }

        // router isis * / mpls traffic-eng scanner
        container scanner {
          tailf:info "Timer parameters for TE database";
          tailf:cli-compact-syntax;
          tailf:cli-delete-when-empty;
          presence true;
          leaf interval {
            tailf:info "time (secs) between LSPDB walks for TE";
            type uint8 {
              tailf:info "<1-60>;;interval between LSPDB walks for TE TLVs extraction";
              range "1..60";
            }
          }
          leaf max-flash {
            tailf:info "Number of ISIS LSPs to be processed with no delay";
            type uint8 {
              tailf:info "<0-200>;;Max. number of LSPs ISIS may send to TE db without delay";
              range "0..200";
            }
          }
        }
      }
    }

    // router isis * / passive-interface
    uses passive-interface-grouping;

    // router isis * / distribute-list
    uses router-distribute-list-grouping;

    //  router isis * / router-id
    container router-id {
      tailf:info "Stable IP Address";
      uses interface-name-grouping;
    }

    // router isis * / redistribute
    container redistribute {
      tailf:info "Redistribute information from another routing protocol";

      // router isis * / redistribute maximum-prefix
      container maximum-prefix {
        tailf:info "Maximum number of prefixes redistributed to protocol";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf number {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-4294967295>;;Maximum number of IP prefixes redistributed";
            range "1..4294967295";
          }
        }
        leaf threshold-value {
          tailf:cli-drop-node-name;
          tailf:cli-break-sequence-commands;
          type uint32 {
            tailf:info "<1-100>;;Threshold value (%) at which to generate a warning message";
            range "1..100";
          }
        }
        leaf warning-only {
          tailf:info "Only give warning message when limit is exceeded";
          tailf:cli-full-command;
          type empty;
        }
        leaf withdraw {
          tailf:info "Withdraw redistibuted prefixes";
          tailf:cli-full-command;
          type empty;
        }
      }

      // router isis * / redistribute connected
      container connected {
        tailf:info "Connected";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-isis-redistribute-grouping;
      }

      // router isis * / redistribute static
      container static {
        tailf:info "Static routes";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence true;
        // router isis * / redistribute static clns
        container clns {
          tailf:info "Redistribution of BGP NSAP routes";
          tailf:cli-delete-when-empty;
          presence true;
          leaf route-map {
            tailf:info "Route map reference";
            type string {
              tailf:info "WORD;;Pointer to route-map entries";
            }
          }
        }
        // router isis * / redistribute static ip
        container ip {
          tailf:info "Redistribution of IP static routes";
          tailf:cli-compact-syntax;
          tailf:cli-delete-when-empty;
          presence true;
          uses router-isis-redistribute-grouping;
        }
      }

      // router isis * / redistribute odr
      container odr {
        tailf:info "On Demand stub Routes";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-isis-redistribute-grouping;
      }

      // router isis * / redistribute rip
      container rip {
        tailf:info "Routing Information Protocol (RIP)";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-isis-redistribute-grouping;
      }

      // router isis * / redistribute bgp *
      list bgp {
        tailf:info "Border Gateway Protocol (BGP)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key as-no;
        leaf as-no {
          tailf:cli-suppress-range;
          type bgp-as-no-type;
        }
        // router isis * / redistribute bgp * clns
        container clns {
          tailf:info "Redistribution of BGP NSAP routes";
          tailf:cli-delete-when-empty;
          presence true;
          leaf route-map {
            tailf:info "Route map reference";
            type string {
              tailf:info "WORD;;Pointer to route-map entries";
            }
          }
        }
        uses router-isis-redistribute-grouping;
      }

      // router isis * / redistribute ospf *
      list ospf {
        tailf:info "Open Shortest Path First (OSPF)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          tailf:cli-suppress-range;
          type uint16 {
            tailf:info "<1-65535>;;Process ID";
            range "1..65535";
          }
        }
        uses redistribute-ospf-match-grouping;
        uses router-isis-redistribute-grouping;
      }

      // router isis * / redistribute isis
      container isis {
        tailf:info "ISO IS-IS";
        tailf:cli-compact-syntax;
        list isis-area-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-incomplete-command;
          key area-tag;
          leaf area-tag {
            tailf:cli-disallow-value "ip";
            type string {
              tailf:info "WORD;;ISO routing area tag";
            }
          }
          // router isis * / redistribute isis * ip
          leaf ip {
            tailf:info "Redistribution of IP routes between levels or processes";
            type empty;
          }
          // router isis * / redistribute isis * metric
          leaf metric {
            tailf:info "ISIS default metric";
            type uint32 {
              tailf:info "<0-4294967295>;;ISIS default metric";
              range "0..4294967295";
            }
          }
          // router isis * / redistribute isis * route-map
          leaf route-map {
            tailf:info "Route map reference";
            type string {
              tailf:info "WORD;;Pointer to route-map entries";
            }
          }
        }

        // router isis * / redistribute isis ip *
        list ip {
          tailf:info "Redistribution of IP routes between levels";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-incomplete-command;
          key "from into";
          leaf from {
            type enumeration {
              enum level-1 {
                tailf:info "Inter-area routes from level-1";
              }
              enum level-2 {
                tailf:info "Inter-area routes from level-2";
              }
            }
          }
          leaf into {
            tailf:info "from level-n into level-m";
            tailf:cli-expose-key-name;
            type enumeration {
              enum level-1 {
                tailf:info "Inter-area routes from level-1";
              }
              enum level-2 {
                tailf:info "Inter-area routes from level-2";
              }
            }
          }
          leaf distribute-list {
            tailf:info "select routes";
            type uint8 {
              tailf:info "<100-199>;;IP extended acces-list number";
              range "100..199";
            }
          }
          leaf route-map {
            tailf:info "Route map for route matching";
            type string {
              tailf:info "WORD;;Name of the route-map";
            }
          }
        }
      }

      // router isis * / redistribute eigrp *
      list eigrp {
        tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key as-no;
        leaf as-no {
          type eigrp-as-no-type;
        }
        uses router-isis-redistribute-grouping;
      }

      // router isis * / redistribute iso-igrp
      container iso-igrp {
        tailf:info "IGRP for OSI networks";
        presence "IGRP for OSI networks";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        choice iso-igrp-choice {
          container area-tag-route-map-container {
            tailf:cli-drop-node-name;
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf area-tag {
              tailf:cli-drop-node-name;
              tailf:cli-disallow-value "route-map";
              type string {
                tailf:info "WORD;;ISO routing area tag";
              }
            }
            leaf route-map {
              tailf:info "Route map reference";
              type string {
                tailf:info "WORD;;Pointer to route-map entries";
              }
            }
          }
          leaf route-map {
            tailf:info "Route map reference";
            type string {
              tailf:info "WORD;;Pointer to route-map entries";
            }
          }
        }
        uses redist-level-grouping;
        leaf metric {
          tailf:info "ISIS default metric";
          type uint32 {
            tailf:info "<0-4294967295>;;ISIS default metric";
            range "0..4294967295";
          }
        }
        leaf metric-type {
          tailf:info "OSPF/IS-IS exterior metric type for redistributed routes";
          type enumeration {
            enum external {
              tailf:info "Set IS-IS External metric type";
            }
            enum internal {
              tailf:info "Set IS-IS Internal metric type";
            }
          }
        }
      }

      // router isis * / redistribute mobile
      container mobile {
        tailf:info "Mobile routes";
        tailf:cli-compact-syntax;
        presence "Mobile routes";
        uses router-isis-redistribute-grouping;
      }
    }

    // router isis * / summary-address *
    list summary-address {
      tailf:info "Configure IP address summaries";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key "ip mask";
      leaf ip {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;IP summary address";
        }
      }
      leaf mask {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Summary mask";
        }
      }

      // router isis * / summary-address * level
      leaf level {
        tailf:cli-drop-node-name;
        type enumeration {
          enum level-1 {
            tailf:info "Summarize into level-1 area";
          }
          enum level-1-2 {
            tailf:info "Summarize into both area and sub-domain";
          }
          enum level-2 {
            tailf:info "Summarize into level-2 sub-domain";
          }
        }
      }

      // router isis * / summary-address * tag
      leaf tag {
        tailf:info "Set tag";
        type uint32 {
          tailf:info "<1-4294967295>;;32-bit tag value";
          range "1..4294967295";
        }
      }

      // router isis * / summary-address * metric
      leaf metric {
        tailf:info "Set metric for summay route";
        type uint32 {
          tailf:info "<1-4294967295>;;metric";
          range "1..4294967295";
        }
      }
    }

    // router isis * / no adjacency-check
    // router isis * / set-overload-bit
    // router isis * / spf-interval
    // router isis * / prc-interval
    // router isis * / metric
    // router isis * / maximum-paths
    // router isis * / default-information
    uses router-isis-af-late-grouping;

    // router isis * / address-family ipv6 unicast
    container address-family {
      tailf:info "Enter Address Family command mode";
      container ipv6 {
        tailf:info "Address family";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-router-af";
        tailf:cli-exit-command "exit-address-family" {
          tailf:info "Exit from Address Family configuration mode";
        }
        tailf:cli-diff-dependency "/ios:ipv6/unicast-routing";
        leaf af {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          tailf:cli-full-command;
          type enumeration {
            enum unicast {
              tailf:info "Address Family Modifier";
            }
          }
          //default unicast;   NSO 4.6.1 BUG: breaks delete
        }

        uses router-isis-af-early-grouping;

        // router isis * / address-family ipv6 / bfd all-interfaces
        container bfd {
          tailf:info "BFD configuration commands";
          leaf all-interfaces {
            tailf:info "Enable BFD on all interfaces";
            type empty;
          }
        }

        // router isis * / address-family ipv6 / summary-prefix *
        list summary-prefix {
          tailf:info "Configure IPv6 summary prefix";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key prefix;
          leaf prefix {
            type ipv6-prefix {
              tailf:info "X:X:X:X::X/<0-128>;;IPv6 prefix x:x::y/<z>";
            }
          }
          // router isis * / address-family ipv6 summary-prefix * level-X
          leaf level {
            tailf:cli-drop-node-name;
            type enumeration {
              enum level-1 {
                tailf:info "Summarize into level-1 area";
              }
              enum level-1-2 {
                tailf:info "Summarize into both area and sub-domain";
              }
              enum level-2 {
                tailf:info "Summarize into level-2 sub-domain";
              }
            }
          }
          // router isis * / address-family ipv6 summary-prefix * tag
          leaf tag {
            tailf:info "Set tag";
            type uint32 {
              tailf:info "<1-4294967295>;;32-bit tag value";
            }
          }
        }

        // router isis * / address-family ipv6 / distance
        leaf distance {
          tailf:info "Administrative distance";
          tailf:cli-full-command;
          type uint32 {
            tailf:info "<1-255>;;OSPF Administrative distance";
            range "1..255";
          }
        }

        // router isis * / address-family ipv6 / multi-topology
        container multi-topology {
          tailf:info "Enable multi-topology mode";
          presence true;
          leaf transition {
            tailf:info "Accept and generate both IS-IS IPv6 and Multi-topology IPv6 TLVs";
            type empty;
          }
        }

        // router isis * / address-family ipv6 / redistribute
        container redistribute {
          tailf:info "Redistribute IPv6 prefixes from another routing protocol";

          // router isis * / address-family ipv6 /redistribute connected
          container connected {
            tailf:info "Connected";
            tailf:cli-compact-syntax;
            tailf:cli-delete-when-empty;
            presence "Connected";
            uses router-isis-af-redistribute-grouping;
          }

          // router isis * / address-family ipv6 /redistribute static
          container static {
            tailf:info "Static routes";
            tailf:cli-compact-syntax;
            tailf:cli-delete-when-empty;
            presence "Static routes";
            uses router-isis-redistribute-grouping;
          }

          // router isis * / address-family ipv6 /redistribute bgp
          container bgp {
            tailf:info "Border Gateway Protocol (BGP)";
            tailf:cli-compact-syntax;
            leaf as-no {
              tailf:cli-drop-node-name;
              type bgp-as-no-type;
            }
            uses router-isis-af-redistribute-grouping;
          }

          // router isis * / address-family ipv6 / redistribute ospf *
          list ospf {
            tailf:info "Open Shortest Path First (OSPF)";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            key id;
            leaf id {
              tailf:cli-suppress-range;
              type uint16 {
                tailf:info "<1-65535>;;Process ID";
                range "1..65535";
              }
            }
            uses redistribute-ospf-match-grouping;
            uses router-isis-af-redistribute-grouping;
          }

          // router isis * / address-family ipv6 / redistribute rip
          list rip {
            tailf:info "IPv6 Routing Information Protocol (RIPv6)";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            key process;
            leaf process {
              type string {
                tailf:info "WORD;;User selected string identifying this process";
              }
            }
            uses router-isis-af-redistribute-grouping;
          }

          // router isis * / address-family ipv6 /redistribute eigrp *
          list eigrp {
            tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            key as-no;
            leaf as-no {
              type eigrp-as-no-type;
            }
            uses router-isis-af-redistribute-grouping;
          }

          // router isis * / address-family ipv6 /redistribute isis
          container isis {
            tailf:info "ISO IS-IS";
            tailf:cli-compact-syntax;

            // router isis * / address-family ipv6 /redistribute isis *
            list isis-list {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-incomplete-command;
              key "from into";
              leaf from {
                type enumeration {
                  enum level-1 {
                    tailf:info "Inter-area routes from level-1";
                  }
                  enum level-2 {
                    tailf:info "Inter-area routes from level-2";
                  }
                }
              }
              leaf into {
                tailf:info "from level-n into level-m";
                tailf:cli-expose-key-name;
                type enumeration {
                  enum level-1 {
                    tailf:info "Inter-area routes from level-1";
                  }
                  enum level-2 {
                    tailf:info "Inter-area routes from level-2";
                  }
                }
              }
              leaf distribute-list {
                tailf:info "select routes";
                type string {
                  tailf:info "WORD;;IPv6 prefix-list name";
                }
              }
              leaf route-map {
                tailf:info "Route map for route matching";
                type string {
                  tailf:info "WORD;;Name of the route-map";
                }
              }
            }
          }

          // router isis * / address-family ipv6 / redistribute nemo
          container nemo {
            tailf:info "Network Mobility (NEMO)";
            tailf:cli-compact-syntax;
            tailf:cli-delete-when-empty;
            uses router-isis-af-redistribute-grouping;
          }
        }

        uses router-isis-af-late-grouping;
      }
    }
  }


  /// =========================================================================
  /// grouping router-lisp-
  /// =========================================================================

  // router lisp / loc-reach-algorithm
  // router lisp / instance-id * / loc-reach-algorithm
  // router lisp / eid-table * / loc-reach-algorithm
  grouping router-lisp-loc-reach-algorithm-grouping {

    container loc-reach-algorithm {
      tailf:info "Configure locator reachability algorithm";

      // router lisp / eid-table * / loc-reach-algorithm lsb-reports
      leaf lsb-reports {
        tailf:info "Configure data packet LSB report handling";
        type enumeration {
          enum ignore {
            tailf:info "Ignore data packet LSB reports";
          }
        }
      }

      // router lisp / eid-table * / loc-reach-algorithm rloc-probing
      leaf rloc-probing {
        tailf:info "Probe high priority RLOCs with Map-Requests as last resort";
        type empty;
      }
    }
  }

  // router lisp / ipv4 route-import map-cache *
  // router lisp / ipv4 route-import database *
  grouping router-lisp-route-import-grouping {
    // router lisp / ipv4 route-import database connected
    // router lisp / ipv4 route-import database static
    // router lisp / ipv4 route-import database rip
    list static-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-incomplete-command;
      key protocol;
      leaf protocol {
        tailf:cli-suppress-range;
        type enumeration {
          enum connected {
            tailf:info "Connected";
          }
          enum static {
            tailf:info "Static routes";
          }
          enum rip {
            tailf:info "Routing Information Protocol (RIP)";
          }
        }
      }
      leaf route-map {
        tailf:info "Route map for route selection filtering";
        tailf:cli-optional-in-sequence;
        type string {
          tailf:info "WORD;;Route map name";
        }
      }
      leaf locator-set {
        tailf:info "Locator set to use with created database mapping entries";
        type string {
          tailf:info "WORD;;Locator set name";
        }
      }
    }

    // router lisp / ipv4 route-import database ospf *
    // router lisp / ipv4 route-import database ospfv3 *
    // router lisp / ipv4 route-import database eigrp *
    // router lisp / ipv4 route-import database bgp *
    // router lisp / ipv4 route-import database rip *
    list id-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      key "protocol id";
      leaf protocol {
        tailf:cli-suppress-range;
        type enumeration {
          enum bgp {
            tailf:info "Border Gateway Protocol (BGP)";
          }
          enum eigrp {
            tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
          }
          enum isis {
            tailf:info "ISO IS-IS";
          }
          enum ospf {
            tailf:info "Open Shortest Path First (OSPF)";
          }
          enum ospfv3 {
            tailf:info "OSPFv3";
          }
          enum rip {
            tailf:info "Routing Information Protocol (RIP)";
          }
        }
      }
      leaf id {
        tailf:cli-disallow-value "route-map";
        type string {
          tailf:info "WORD;;Process id";
        }
      }
      leaf route-map {
        tailf:info "Route map for route selection filtering";
        tailf:cli-optional-in-sequence;
        type string {
          tailf:info "WORD;;Route map name";
        }
      }
      leaf locator-set {
        tailf:info "Locator set to use with created database mapping entries";
        type string {
          tailf:info "WORD;;Locator set name";
        }
      }
    }
  }

  // router lisp / eid-table * / database-mapping * /
  // router lisp / service ipv4 / database-mapping *
  // router lisp / service ipv6 / database-mapping *
  grouping router-lisp-database-mapping-grouping {
    list database-mapping {
      tailf:info "Configures Locator addresses for an ETR";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      key prefix;
      max-elements 100;
      leaf prefix {
        type union {
          type ios:ipv4-prefix {
            tailf:info "A.B.C.D/nn;;EID-prefix to advertise locators for (max 100 prefixes)";
          }
          type ios:ipv6-prefix {
            tailf:info "X:X:X:X::X/<0-128>;;EID-prefix to advertise locators (max 100 prefixes)";
          }
        }
      }
      // router lisp / eid-table * / database-mapping * <rloc>
      choice rloc-choice {
        leaf ipv4-address {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IPv4 Address of loopback or other ETR interface";
          }
        }
        container IPv4-interface {
          tailf:info "Use IPv4 address of interface as locator";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-incomplete-command;
          uses interface-name-grouping;
        }
        container IPv6-interface {
          tailf:info "Use IPv6 address of interface as locator";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-incomplete-command;
          uses interface-name-grouping;
        }
        leaf ipv6-address {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type inet:ipv6-address {
            tailf:info "X:X:X:X::X;;IPv6 Address of loopback or other ETR interface";
          }
        }
        leaf auto-discover-rlocs {
          tailf:info "Auto discover locators registered by other xTRs";
          tailf:cli-full-command;
          type empty;
        }
        leaf locator-set {
          tailf:info "Use locators defined by locator-set";
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;Existing locator set";
          }
        }
      }
      leaf priority {
        tailf:info "Configures which Locators from a set are preferred";
        tailf:cli-incomplete-command;
        type uint8 {
          tailf:info "<0-255>;;Lower priority Locator takes preference";
        }
      }
      leaf weight {
        tailf:info "Traffic load-spreading among Locators";
        type uint8 {
          tailf:info "<0-100>;;Relative weight of locator";
        }
      }
    }

    // router lisp / service ipv4 / database-mapping X
    container database-mapping-conf {
      tailf:cli-drop-node-name;
      container database-mapping {
        tailf:info "Address family specific local EID prefixes database configuration";

        // router lisp / service ipv4 / database-mapping mac
        container mac {
          tailf:info "L2 EID records";
          leaf locator-set {
            tailf:info "Use locators defined by locator-set";
            type string {
              tailf:info "WORD;;Locator set name";
            }
          }
        }

        // router lisp / service ipv4 / database-mapping limit dynamic
        container limit {
          tailf:info "Configures the maximum size of local EID prefixes database";
          leaf dynamic {
            tailf:info "Configures the maximum size of dynamic local EID prefixes database";
            type uint16 {
              tailf:info "<1-5000>;;Maximum number of dynamic local EID prefixes database entries";
              range "1..5000";
            }
          }
        }
      }
    }
  }

  // router lisp / ipv4
  // router lisp / eid-table * ipv4
  grouping router-lisp-af4-common-grouping {

    // router lisp / ipv4 map-request-source
    leaf map-request-source {
      tailf:info "Configures inner header source address in Map-Request message";
      type inet:ipv4-address {
        tailf:info "A.B.C.D;;IPv4 Source address of inner header in Map-Request message";
      }
    }

    // router lisp / ipv4 proxy-itr
    container proxy-itr {
      tailf:info "Configures a LISP Proxy Ingress Tunnel Router (PITR)";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf ipv4-local-locator {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;IPv4 address in ITR-RLOC field of map-request";
        }
      }
      leaf ipv6-local-locator {
        tailf:cli-drop-node-name;
        type inet:ipv6-address {
          tailf:info "X:X:X:X::X;;IPv6 address in ITR-RLOC field of map-request";
        }
      }
    }
  }

  // router lisp / ipv6
  // router lisp / eid-table * ipv6
  grouping router-lisp-af6-common-grouping {

    // router lisp / ipv6 map-request-source
    leaf map-request-source {
      tailf:info "Configures inner header source address in Map-Request message";
      type inet:ipv6-address {
        tailf:info "X:X:X:X::X;;IPv6 Source address of inner header in Map-Request message";
      }
    }

    // router lisp / ipv6 proxy-itr
    container proxy-itr {
      tailf:info "Configures a LISP Proxy Ingress Tunnel Router (PITR)";
      tailf:cli-compact-syntax;
      leaf ipv6-local-locator {
        tailf:cli-drop-node-name;
        tailf:cli-reset-container;
        type inet:ipv6-address {
          tailf:info "X:X:X:X::X;;IPv6 address in ITR-RLOC field of map-request";
        }
      }
      leaf ipv4-local-locator {
        tailf:cli-drop-node-name;
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;IPv4 address in ITR-RLOC field of map-request";
        }
      }
    }
  }

  // router lisp / ipv4
  // router lisp / ipv6
  // router lisp / service ipv4
  // router lisp / service ipv6
  // router lisp / eid-table * ipv4
  // router lisp / eid-table * ipv6
  grouping router-lisp-af-grouping {

    // router lisp / ipv4 map-resolver
    leaf map-resolver {
      tailf:info "Configures a LISP Map Resolver (MR)";
      type empty;
    }

    // router lisp / ipv4 map-resolver map-request validate source
    container map-resolver-conf {
      tailf:cli-drop-node-name;
      container map-resolver {
        tailf:info "Configures a LISP Map Resolver (MR)";
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        container map-request {
          tailf:info "Map-Request processing options";
          container validate {
            tailf:info "Validation options";
            container source {
              tailf:info "Influence which source RLOCs map requests are accepted from";
              tailf:cli-compact-syntax;
              tailf:cli-reset-container;
              leaf registered {
                tailf:info "...from RLOCs that register EID-prefixes in the same IID on a co-located MapServer";
                tailf:cli-optional-in-sequence;
                type empty;
              }
              container list {
                tailf:info "Define allowed prefixes using an ip[v6] prefix list";
                choice list-choice {
                  leaf ipv4 {
                    tailf:info "IPv4 prefixes";
                    type string {
                      tailf:info "WORD;;IPv4 prefix-list name";
                    }
                  }
                  leaf ipv6 {
                    tailf:info "IPv6 prefixes";
                    type string {
                      tailf:info "WORD;;IPv6 prefix-list name";
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // router lisp / ipv4 itr map-resolver *
    container itr {
      tailf:info "Configures a LISP Ingress Tunnel Router (ITR)";
      tailf:cli-incomplete-command;
      tailf:cli-incomplete-no;
      list map-resolver {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key address;
        leaf address {
          type union {
            type inet:ipv4-address {
              tailf:info "IPv4 Address of map resolver";
            }
            type inet:ipv6-address {
              tailf:info "IPv6 Address of map resolver";
            }
          }
        }
      }

      // router lisp / ipv4 itr
      // router lisp / ipv6 itr
      leaf enable {
        tailf:cli-drop-node-name;
        type empty;
      }
    }

    // router lisp / ipv4 etr
    container etr {
      tailf:info "Configures a LISP Egress Tunnel Router (ETR)";
      tailf:cli-incomplete-command;
      tailf:cli-incomplete-no;

      // router lisp / ipv4 etr map-server *
      list map-server {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        key address;
        leaf address {
          type union {
            type inet:ipv4-address {
              tailf:info "IPv4 Address of map server";
            }
            type inet:ipv6-address {
              tailf:info "IPv6 Address of map server";
            }
          }
        }

        // router lisp / ipv4 etr map-server * key
        container key {
          tailf:info "Authentication key used with map server";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          uses crypto-key-grouping {
            refine "secret" {
              cli:secret " key <SECRET>";
            }
          }
          leaf hash-function {
            tailf:info "Map-Register authentication type";
            type enumeration {
              enum sha1 {
                tailf:info "Use the SHA-1-96 hash function";
              }
              enum sha2 {
                tailf:info "Use the SHA-256-128 hash function";
              }
            }
          }
        }

        // router lisp / ipv4 etr map-server * proxy-reply
        leaf proxy-reply {
          tailf:info "Request Map-Server to send Map-Replies on behalf of site";
          type empty;
        }
      }

      // router lisp / ipv4 etr accept-map-request-mapping
      container accept-map-request-mapping {
        tailf:info "Configures an ETR to cache mappings received in map request messages";
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        leaf verify {
          tailf:info "Send Map-Request back to originator of a Mapping Data Record";
          type empty;
        }
      }

      // router lisp / ipv4 etr
      leaf enable {
        tailf:cli-drop-node-name;
        type empty;
      }
    }

    // router lisp / ipv4 map-cache-limit
    leaf map-cache-limit {
      tailf:info "Configures maximum size of map-cache";
      type uint32 {
        tailf:info "<0-100000>;;Maximum number of map-cache entries";
        range "0..100000";
      }
    }

    // router lisp / ipv4 map-cache-persistent
    container map-cache-persistent {
      tailf:info "Dump map-cache onto flash, making it persistent across reboots";
      presence true;
      leaf interval {
        tailf:info "Interval in minutes of how often the map-cache is saved";
        type uint16 {
          tailf:info "<1-1440>;;Interval in minutes, default 60";
          range "1..1440";
        }
      }
    }

    // router lisp / ipv4 route-import
    container route-import {
      tailf:info "Import RIB routes by a routing protocol into LISP";

      // router lisp / ipv4 route-import map-cache *
      container map-cache {
        tailf:info "Use RIB routes to define EID address space in map-cache";
        uses router-lisp-route-import-grouping;
      }

      // router lisp / ipv4 route-import database *
      container database {
        tailf:info "Use RIB routes to define local EID database entries";
        uses router-lisp-route-import-grouping;
      }
    }

    // router lisp / ipv4 route-export site-registration
    // router lisp / ipv4 route-export site-registrations
    container route-export {
      tailf:info "Export routes into RIB from LISP";
      leaf site-registration {
        tailf:info "Export LISP site registrations to RIB";
        type empty;
      }
      leaf site-registrations {
        tailf:info "Export LISP site registrations to RIB";
        type empty;
      }
    }

    // router lisp / ipv4 distance
    container distance {
      tailf:info "Administrative distance for RIB route installation";

      // router lisp / ipv4 distance site-registrations
      leaf site-registrations {
        tailf:info "LISP installed routes of type site-registrations";
        type uint8 {
          tailf:info "<1-255>;;Administrative distance for RIB route installation";
          range "1..255";
        }
      }
    }

    // router lisp / ipv4 map-cache site-registration
    container map-cache {
      tailf:info "Address family specific map cache configuration";

      // router lisp / ipv4 map-cache *
      list prefix-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key prefix;
        leaf prefix {
          type union {
            type ios:ipv4-prefix {
              tailf:info "A.B.C.D/nn;;IPv4 EID-prefix for RLOC static mapping";
            }
            type ios:ipv6-prefix {
              tailf:info "X:X:X:X::X/<0-128>;;IPv6 EID-prefix for RLOC static mapping";
            }
          }
        }
        choice map-cache-choice {
          leaf map-request {
            tailf:info "Send Map-Request for LISP destination EID";
            type empty;
          }
          leaf native-forward {
            tailf:info "Natively forward packets that match this map-cache entry";
            type empty;
          }
          leaf drop {
            tailf:info "Drop packets that match this map-cache entry";
            type empty;
          }
        }
      }

      // router lisp / ipv4 map-cache site-registration
      leaf site-registration {
        tailf:info "Install map cache to map request for site registrations";
        type empty;
      }
    }

    // router lisp / ipv4 proxy-etr
    leaf proxy-etr {
      tailf:info "Configures a LISP Proxy Engress Tunnel Router (PETR)";
      tailf:cli-full-command;
      type empty;
    }

    // router lisp / ipv4 use-petr
    list use-petr {
      tailf:info "Encapsulate to Proxy ETR when matching forward-native entry";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      key address;
      leaf address {
        type union {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IPv4 locator address of PETR";
          }
          type inet:ipv6-address {
            tailf:info "X:X:X:X::X;;IPv6 locator address of PETR";
          }
        }
      }
      leaf priority {
        tailf:info "Configures which Locators from a set are preferred";
        tailf:cli-incomplete-command;
        type uint8 {
          tailf:info "<0-255>;;Lower priority Locator takes preference";
        }
      }
      leaf weight {
        tailf:info "Traffic load-spreading among Locators";
        type uint8 {
          tailf:info "<0-100>;;Relative weight of locator";
          range "0..100";
        }
      }
    }

    // router lisp / ipv4 map-server
    leaf map-server {
      tailf:info "Configures a LISP Map Server (MS)";
      type empty;
    }

    // router lisp / ipv4 locator reachability exclude-default
    container locator {
      tailf:info "Locator related configuration";
      container reachability {
        tailf:info "Configuration realted to locator reachability";
        leaf exclude-default {
          tailf:info "If a remote RLOC is reached via the default route, treat it as unreachable";
          type empty;
        }
      }
    }
  }

  // router-lisp-eid-table-grouping
  grouping router-lisp-eid-table-grouping {

    // router lisp / eid-table * instance-id
    leaf instance-id {
      tailf:info "EID instance-ID";
      tailf:cli-hide-in-submode;
      type uint32 {
        tailf:info "<0-16777214>;;Instance-ID";
        range "0..16777214";
      }
    }

    // router lisp / eid-table * / map-cache *
    list map-cache {
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-incomplete-command;
      key prefix;
      leaf prefix {
        type union {
          type ios:ipv4-prefix {
            tailf:info "A.B.C.D/nn;;IPv4 EID-prefix for RLOC static mapping";
          }
          type ios:ipv6-prefix {
            tailf:info "X:X:X:X::X/<0-128>;;IPv6 EID-prefix for RLOC static mapping";
          }
        }
      }
      choice map-cache-choice {
        // router lisp / eid-table * / map-cache * <locator>
        case locator {
          leaf locator {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type union {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IPv4 Address of loopback or other ETR interface";
              }
              type inet:ipv6-address {
                tailf:info "X:X:X:X::X;;IPv6 Address of loopback or other ETR interface";
              }
            }
          }
          leaf priority {
            tailf:info "Lower priority Locator takes preference";
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-255>;;Lower priority Locator takes preference";
            }
          }
          leaf weight {
            tailf:info "Traffic load-spreading among Locators";
            type uint8 {
              tailf:info "<0-100>;;Relative weight of locator";
              range "0..100";
            }
          }
        }
        // router lisp / eid-table * / map-cache * map-request
        leaf map-request {
          tailf:info "Send Map-Request for LISP destination EID";
          tailf:cli-full-command;
          type empty;
        }
        // router lisp / eid-table * / map-cache * native-forward
        leaf native-forward {
          tailf:info "Natively forward packets that match this map-cache entry";
          tailf:cli-full-command;
          type empty;
        }
        // router lisp / eid-table * / map-cache * drop
        leaf drop {
          tailf:info "Drop packets that match this map-cache entry";
          tailf:cli-full-command;
          type empty;
        }
      }
    }

    // router lisp / eid-table * / database-mapping *
    uses router-lisp-database-mapping-grouping;

    // router lisp / eid-table * / loc-reach-algorithm
    uses router-lisp-loc-reach-algorithm-grouping;

    // router lisp / eid-table * / ipv4
    container ipv4 {
      tailf:info "IPv4 address family";
      uses router-lisp-af-grouping;
      uses router-lisp-af4-common-grouping;
    }

    // router lisp / eid-table * / ipv6
    container ipv6 {
      tailf:info "IPv6 address family";
      uses router-lisp-af-grouping;
      uses router-lisp-af6-common-grouping;
    }
  }

  // router lisp / service ipv4 /
  // router lisp / service ipv6 /
  grouping router-lisp-service-af-grouping {

    // router lisp / service ipv4 / eid-table
    container eid-table {
      tailf:info "Bind an eid-table";

      // router lisp / service ipv4 / eid-table default
      leaf default {
        tailf:info "Default VRF";
        type empty;
      }

      // router lisp / service ipv4 / eid-table vrf
      leaf vrf {
        tailf:info "VRF name";
        tailf:cli-remove-before-change;
        tailf:cli-diff-dependency "/ios:vrf/definition";
        type string {
          tailf:info "WORD;;VRF name";
        }
      }

      // router lisp / service ethernet / eid-table vlan
      leaf vlan {
        tailf:info "VLAN configuration";
        tailf:cli-remove-before-change;
        type uint16 {
          tailf:info "<1-4094>;;vlan-id";
          range "1..4094";
        }
      }
    }

    // router lisp / service ipv4 / database-mapping *
    uses router-lisp-database-mapping-grouping;

    // router lisp / service ipv4 / sgt
    leaf sgt {
      tailf:info "Enable security group tag propagation in LISP encapsulated traffic";
      type empty;
    }

    // router lisp / service ipv4 / encapsulation
    leaf encapsulation {
      tailf:info "Select encapsulation type for data packets";
      type enumeration {
        enum lisp {
          tailf:info "Use LISP encapsulation for data packets";
        }
        enum vxlan {
          tailf:info "Use VXLAN encapsulation for data packets";
        }
      }
    }
  }

  // router lisp /
  // router lisp / instance-id * /
  grouping router-lisp-service-grouping {

    // router lisp / loc-reach-algorithm
    uses router-lisp-loc-reach-algorithm-grouping;

    // router lisp / disable-ttl-propagate
    leaf disable-ttl-propagate {
      tailf:info "Disable ttl propagation";
      type empty;
    }

    // router lisp / service
    container service {
      tailf:info "Select service type";

      // router lisp / service ipv4
      container ipv4 {
        tailf:info "Select service type as IPv4";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-router-lisp-serv-ipv4";
        tailf:cli-exit-command "exit-service-ipv4" {
          tailf:info "Exit from LISP service-ipv4 configuration mode";
        }
        presence true;
        uses router-lisp-service-af-grouping;
        uses router-lisp-af-grouping;
        uses router-lisp-af4-common-grouping;
      }

      // router lisp / service ipv6
      container ipv6 {
        tailf:info "Select service type as IPv6";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-router-lisp-serv-ipv6";
        tailf:cli-exit-command "exit-service-ipv6" {
          tailf:info "Exit from LISP service-ipv6 configuration mode";
        }
        presence true;
        uses router-lisp-service-af-grouping;
        uses router-lisp-af-grouping;
        uses router-lisp-af6-common-grouping;
      }

      // router lisp / service ethernet
      container ethernet {
        tailf:info "Select service type as Ethernet";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-router-lisp-serv-eth";
        tailf:cli-exit-command "exit-service-ethernet" {
          tailf:info "Exit from LISP service-ethernet configuration mode";
        }
        presence true;
        uses router-lisp-service-af-grouping;
        uses router-lisp-af-grouping;
      }
    }
  }

  // router-lisp-grouping
  grouping router-lisp-grouping {

    // router lisp / syslog
    container syslog {
      tailf:info "Configure syslog option";

      // router lisp / syslog verbose
      leaf verbose {
        tailf:info "Enable verbose syslog";
        type empty;
      }

      // router lisp / syslog session changes
      container session {
        tailf:info "Enable session syslog";
        leaf changes {
          tailf:info "Enable session change syslog";
          type empty;
        }
      }
    }

    // router lisp / site-id
    leaf site-id {
      tailf:info "Configure a site-id for this site";
      type uint32 {
        tailf:info "<0-4294967295>;;site-ID";
      }
    }

    // router lisp / etr map-server source-address
    container etr {
      tailf:info "Configures a LISP Egress Tunnel Router (ETR)";
      container map-server {
        tailf:info "Configures map server for ETR registration";
        container source-address {
          tailf:info "Configures map server source address";
          uses interface-name-grouping;
        }
      }
    }

    // router lisp / locator-table
    container locator-table {
      tailf:info "Specify the RLOC table";
      choice locator-table-choice {
        leaf default {
          tailf:info "Default VRF";
          type empty;
        }
        leaf vrf {
          tailf:info "VRF name";
          type string {
            tailf:info "WORD;;VRF name";
          }
        }
      }
    }

    // router lisp / locator-set *
    list locator-set {
      tailf:info "Configure a named locator set";
      tailf:cli-mode-name "config-router-lisp-locator-set";
      //IWAN3: tailf:cli-exit-command "exit-locator-set";
      tailf:cli-full-command;
      key name;
      leaf name {
        type string {
          tailf:info "Configure a named locator set";
        }
      }

      // router lisp / locator-set * / a.b.c.d
      list IPv4-address {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        key name;
        leaf name {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP address";
          }
        }
        leaf priority {
          tailf:info "Configures which Locators from a set are preferred";
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<0-255>;;Lower priority Locator takes preference";
          }
        }
        leaf weight {
          tailf:info "Traffic load-spreading among Locators";
          type uint8 {
            tailf:info "<0-100>;;Relative weight of locator";
            range "0..100";
          }
        }
      }

      // router lisp / locator-set * / X:X:X:X::X
      list IPv6-address {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type inet:ipv6-address {
            tailf:info "X:X:X:X::X;;Address of loopback or other ETR interface";
          }
        }
        leaf priority {
          tailf:info "Configures which Locators from a set are preferred";
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<0-255>;;Lower priority Locator takes preference";
          }
        }
        leaf weight {
          tailf:info "Traffic load-spreading among Locators";
          type uint8 {
            tailf:info "<0-100>;;Relative weight of locator";
            range "0..100";
          }
        }
      }

      // router lisp / locator-set * / IPv4-interface *
      list IPv4-interface {
        tailf:info "Use IPv4 address of interface as locator";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Interface name";
          }
        }
        leaf priority {
          tailf:info "Configures which Locators from a set are preferred";
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<0-255>;;Lower priority Locator takes preference";
          }
        }
        leaf weight {
          tailf:info "Traffic load-spreading among Locators";
          type uint8 {
            tailf:info "<0-100>;;Relative weight of locator";
            range "0..100";
          }
        }
      }

      // router lisp / locator-set * / IPv6-interface *
      list IPv6-interface {
        tailf:info "Use IPv6 address of interface as locator";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Interface name";
          }
        }
        leaf priority {
          tailf:info "Configures which Locators from a set are preferred";
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<0-255>;;Lower priority Locator takes preference";
          }
        }
        leaf weight {
          tailf:info "Traffic load-spreading among Locators";
          type uint8 {
            tailf:info "<0-100>;;Relative weight of locator";
            range "0..100";
          }
        }
      }

      // router lisp / locator-set * / auto-discover-rlocs
      leaf auto-discover-rlocs {
        tailf:info "Auto discover locators registered by other xTRs";
        type empty;
      }
    }

    // router lisp / locator default-set
    container locator {
      tailf:info "Locator configuration";
      leaf default-set {
        tailf:info "Specify a default locator-set";
        tailf:non-strict-leafref {
          path "../../locator-set/name";
        }
        type string {
          tailf:info "WORD;;Existing locator set name";
        }
      }
    }

    // router lisp / service
    uses router-lisp-service-grouping {
      refine "service/ipv4" {
        tailf:cli-diff-dependency "../../locator-set";
      }
      refine "service/ipv6" {
        tailf:cli-diff-dependency "../../locator-set";
      }
    }

    // router lisp / map-request
    container map-request {
      tailf:info "Configure map-request handling";
      leaf itr-rlocs {
        tailf:info "Configure to use the specified RLOC set as ITR RLOC in map-request";
        type string {
          tailf:info "WORD;;Existing locator set";
        }
        tailf:non-strict-leafref {
          path "../../locator-set/name";
        }
      }
    }

    // router lisp / eid-table
    container eid-table {
      tailf:info "Configure an EID instance for a VRF";
      tailf:cli-diff-dependency "../locator-set";

      // router lisp / eid-table default
      list default-vrf {
        tailf:cli-drop-node-name;
        tailf:cli-mode-name "config-router-lisp-eid-table";
        tailf:cli-explicit-exit;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type enumeration {
            enum "default" {
              tailf:info "Default VRF";
            }
          }
        }
        uses router-lisp-eid-table-grouping;
      }

      // router lisp / eid-table vrf *
      list vrf {
        tailf:info "VRF name";
        tailf:cli-mode-name "config-router-lisp-eid-table";
        tailf:cli-explicit-exit;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          tailf:cli-suppress-range;
          type string {
            tailf:info "WORD;;VRF name";
          }
        }
        uses router-lisp-eid-table-grouping;
      }
    }

    // router lisp / site *
    list site {
      tailf:info "Configure a LISP site on a map server (MS)";
      tailf:cli-mode-name "config-router-lisp-site";
      tailf:cli-full-command;
      key name;
      leaf name {
        tailf:cli-suppress-range;
        type string {
          tailf:info "WORD;;The site name";
        }
      }

      // router lisp / site * / description
      leaf description {
        tailf:info "Provide a description string for the LISP site";
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE;;Site description";
        }
      }

      // router lisp / site * / authentication-key
      container authentication-key {
        tailf:info "Authentication key used by LISP site";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        uses crypto-key-grouping {
          refine "secret" {
            cli:secret " authentication-key <SECRET>";
          }
        }
      }

      // router lisp / site * / eid-record
      container eid-record {
        tailf:info "Site EID address record";

        // router lisp / site * / eid-record instance-id *
        list instance-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key "instance-id prefix";
          leaf instance-id {
            tailf:info "EID instance-ID";
            tailf:cli-expose-key-name;
            type uint32 {
              tailf:info "<1-16777214>;;Instance-ID";
              range "1..16777214";
            }
          }
          leaf prefix {
            type union {
              type ios:ipv4-prefix {
                tailf:info "A.B.C.D/nn;;IPv4 EID prefix belonging to the SITE";
              }
              type ios:ipv6-prefix {
                tailf:info "X:X:X:X::X/<0-128>;;IPv6 EID prefix belonging to the SITE";
              }
              type enumeration {
                enum any-mac {
                  tailf:info "Accept registrations for any L2 EID records";
                }
              }
            }
          }
          leaf route-tag {
            tailf:info "ALT RIB route tag for EID prefix";
            type uint32 {
              tailf:info "<0-4294967295>;;RIB route tag";
            }
          }
          leaf accept-more-specifics {
            tailf:info "Accept registrations for more specific EID prefixes";
            type empty;
          }
        }
      }

      // router lisp / site * / eid-prefix *
      list eid-prefix {
        tailf:info "Site EID address prefix";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key prefix;
        leaf prefix {
          type union {
            type ios:ipv4-prefix {
              tailf:info "A.B.C.D/nn;;IPv4 EID prefix belonging to the SITE";
            }
            type ios:ipv6-prefix {
              tailf:info "X:X:X:X::X/<0-128>;;IPv6 EID prefix belonging to the SITE";
            }
          }
        }
        // router lisp / site * / eid-prefix * route-tag
        leaf route-tag {
          tailf:info "ALT RIB route tag for EID prefix";
          type uint32 {
            tailf:info "<0-4294967295>;;RIB route tag";
          }
        }
        // router lisp / site * / eid-prefix * accept-more-specifics
        leaf accept-more-specifics {
          tailf:info "Accept registrations for more specific EID prefixes";
          type empty;
        }
      }

      // router lisp / site * / eid-prefix instance-id *
      container eid-prefix-instance {
        tailf:cli-drop-node-name;
        list eid-prefix {
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key "instance-id prefix";
          leaf instance-id {
            tailf:info "EID instance-ID";
            tailf:cli-expose-key-name;
            type uint32 {
              tailf:info "<1-16777214>;;Instance-ID";
              range "1..16777214";
            }
          }
          leaf prefix {
            type union {
              type ios:ipv4-prefix {
                tailf:info "A.B.C.D/nn;;IPv4 EID prefix belonging to the SITE";
              }
              type ios:ipv6-prefix {
                tailf:info "X:X:X:X::X/<0-128>;;IPv6 EID prefix belonging to the SITE";
              }
            }
          }
          leaf route-tag {
            tailf:info "ALT RIB route tag for EID prefix";
            type uint32 {
              tailf:info "<0-4294967295>;;RIB route tag";
            }
          }
          leaf accept-more-specifics {
            tailf:info "Accept registrations for more specific EID prefixes";
            type empty;
          }
        }
      }

      // router lisp / site * / allowed-locator *
      list allowed-locator {
        tailf:info "Locator from LISP site";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key rloc;
        leaf rloc {
          type union {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IPv4 locator allowed in registered locator-set";
            }
            type inet:ipv6-address {
              tailf:info "X:X:X:X::X;;IPv6 locator allowed in registered locator-set";
            }
          }
        }
      }
    }

    // router lisp / ipv4
    container ipv4 {
      tailf:info "IPv4 address family";
      uses router-lisp-af-grouping {
        refine "map-cache-persistent" {
          tailf:cli-show-no;
        }
      }
      uses router-lisp-af4-common-grouping;
    }

    // router lisp / ipv6
    container ipv6 {
      tailf:info "IPv6 address family";
      uses router-lisp-af-grouping {
        refine "map-cache-persistent" {
          tailf:cli-show-no;
        }
      }
      uses router-lisp-af6-common-grouping;
    }

    // router lisp / instance-id *
    list instance-id {
      tailf:info "EID instance-ID";
      tailf:cli-mode-name "config-router-lisp-inst";
      //IWAN3: tailf:cli-exit-command "exit-instance-id";
      tailf:cli-diff-dependency "../locator-set";
      tailf:cli-diff-dependency "/ios:vrf/definition";
      key id;
      leaf id {
        tailf:cli-suppress-range;
        type uint32 {
          tailf:info "<0-16777214>;;Instance-ID";
          range "0..16777214";
        }
      }

      // router lisp / instance-id * / remote-rloc-probe
      container remote-rloc-probe {
        tailf:info "Configure parameters for probing of remote RLOCs";
        // router lisp / instance-id * / remote-rloc-probe on-route-change
        // router lisp / instance-id * / no remote-rloc-probe on-route-change
        leaf on-route-change {
          tailf:info "Trigger probing upon routing changes for remote RLOC";
          tailf:cli-boolean-no;
          type boolean;
        }
        // router lisp / instance-id * / remote-rloc-probe on-membership-change
        // router lisp / instance-id * / no remote-rloc-probe on-membership-change
        leaf on-membership-change {
          tailf:info "Trigger probing upon membership changes for remote RLOC";
          tailf:cli-boolean-no;
          type boolean;
        }
      }

      // router lisp / instance-id * / dynamic-eid *
      list dynamic-eid {
        tailf:info "Configure a dynamic EID";
        tailf:cli-mode-name "config-lisp-inst-dyn-eid";
        //IWAN3: tailf:cli-exit-command "exit-dynamic-eid";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;The name of the dynamic EID";
          }
        }
        // router lisp / instance-id * / dynamic-eid * / database-mapping
        uses router-lisp-database-mapping-grouping;
      }

      // router lisp / instance-id * / service
      uses router-lisp-service-grouping;
    }

    // router lisp / map-server
    container map-server {
      tailf:info "Map-Server commands";

      // router lisp / map-server session passive-open
      container session {
        tailf:info "Map-server session";
        leaf passive-open {
          tailf:info "Open passive TCP sockets to listen for incoming connections";
          tailf:cli-remove-before-change;
          tailf:non-strict-leafref {
            path "../../../locator-set/name";
          }
          type string {
            tailf:info "WORD;;The name of the locator set";
          }
        }
      }
    }

    // router lisp / encapsulation vxlan
    container encapsulation {
      tailf:info "Select encapsulation type for data packets";
      leaf vxlan {
        tailf:info "Use VXLAN encapsulation for data packets";
        type empty;
      }
    }
  }


  /// =========================================================================
  /// grouping ip-nat-
  /// =========================================================================

  grouping ip-nat-outside-source-grouping {

    leaf redundancy {
      tailf:cli-break-sequence-commands;
      tailf:info "NAT redundancy operation";
      type uint8 {
        tailf:info "<1-2>;IP redundancy ID";
      }
    }
    leaf mapping-id {
      when "../redundancy" {
        tailf:dependency "../redundancy";
      }
      tailf:info "Associate a mapping id to this mapping";
      type uint32 {
        tailf:info "<1-2147483647>;;Stateful NAT mapping id";
        range "1..2147483647";
      }
    }

    leaf add-route {
      tailf:info "Add a static route for outside local address";
      type empty;
    }

    leaf no-payload {
      tailf:info "No translation of embedded address/port in the payload";
      type empty;
    }
  }

  grouping ip-nat-source-static-grouping {

    leaf redundancy {
      tailf:cli-break-sequence-commands;
      tailf:info "NAT redundancy operation";
      type union {
        type uint8 {
          tailf:info "<1-2>;IP redundancy ID";
        }
        type string {
          tailf:info "WORD;;IP redundancy name";
        }
      }
    }
    leaf mapping-id {
      when "../redundancy" {
        tailf:dependency "../redundancy";
      }
      tailf:info "Associate a mapping id to this mapping";
      type uint32 {
        tailf:info "<1-2147483647>;;Stateful NAT mapping id";
        range "1..2147483647";
      }
    }

    leaf extendable {
      tailf:info "Extend this translation when used";
      type empty;
    }

    leaf no-alias {
      tailf:info "Do not create an alias for the global address";
      type empty;
    }

    leaf no-payload {
      tailf:info "No translation of embedded address/port in the payload";
      type empty;
    }

    leaf add-route {
      tailf:info "Add a static route for outside local address";
      type empty;
    }

    leaf route-map {
      tailf:info "Specify route-map";
      type string {
        tailf:info "WORD;;Route-map name";
      }
    }
    leaf reversible {
      when "../route-map" {
        tailf:dependency "../route-map";
      }
      type empty;
    }

    leaf match-in-vrf {
      tailf:info "Match incoming vrf";
      type empty;
    }

    leaf forced {
      tailf:info "Delete this entry and its children, even if in use";
      type empty;
    }

    leaf overload {
      tailf:info "Overload an address translation";
      type empty;
    }
  }

  grouping ip-nat-inside-options-grouping {

    // [no-payload]
    leaf no-payload {
      tailf:cli-break-sequence-commands;
      tailf:info "No translation of embedded address/port in the payload";
      type empty;
    }

    // [reversible]
    leaf reversible {
      tailf:info "Allow out->in traffic";
      type empty;
    }

    // [overload]
    leaf overload {
      tailf:info "Overload an address translation";
      type empty;
    }

    // [oer]
    leaf oer {
      tailf:info "Use with vtemplate only. On new translation, "+
        "if OER BR is UP, OER will select IP from outgoing Interface. "+
        "All packets matching translation are forwarded over "+
        "Interface for duration of translation.";
      type empty;
    }
    // [ portmap name ]
  }

  grouping ip-nat-inside-grouping {

    // <pool>
    leaf pool {
      tailf:info "Name pool of global addresses";
      tailf:cli-optional-in-sequence;
      tailf:non-strict-leafref {
        path "/ios:ip/nat/pool/id";
      }
      type string {
        tailf:info "WORD;;Pool name for global addresses";
      }
    }

    // [ redundancy <rg-id> ]
    leaf redundancy {
      tailf:info "NAT redundancy operation";
      tailf:cli-optional-in-sequence;
      type uint8 {
        tailf:info "<1-2>;;IP redundancy ID";
        range "1..2";
      }
    }

    // [ mapping-id <map-id> ]
    leaf mapping-id {
      tailf:info "Associate a mapping id to this mapping";
      tailf:cli-optional-in-sequence;
      type uint32 {
        tailf:info "<1-2147483647>;;Stateful NAT mapping id";
        range "1..2147483647";
      }
    }

    // <interface>
    leaf interface {
      when "not(../pool)" {
        tailf:dependency "../pool";
      }
      tailf:info "Specify interface for global address";
      tailf:cli-optional-in-sequence;
      tailf:cli-diff-dependency "../../../../../../interface";
      type string {
        tailf:info "WORD;;Interface name";
      }
    }
  }

  grouping ip-nat-inside-vrf-grouping {

    // <pool>
    leaf pool {
      tailf:info "Name pool of global addresses";
      tailf:cli-prefix-key {
        tailf:cli-before-key 2;
      }
      tailf:cli-optional-in-sequence;
      type string {
        tailf:info "WORD;;Pool name for global addresses";
      }
      tailf:non-strict-leafref {
        path "/ios:ip/nat/pool/id";
      }
    }

    // [ redundancy <rg-id> ]
    leaf redundancy {
      tailf:info "NAT redundancy operation";
      tailf:cli-prefix-key {
        tailf:cli-before-key 2;
      }
      tailf:cli-optional-in-sequence;
      type uint8 {
        tailf:info "<1-2>;;IP redundancy ID";
        range "1..2";
      }
    }

    // [ mapping-id <map-id> ]
    leaf mapping-id {
      tailf:info "Associate a mapping id to this mapping";
      tailf:cli-prefix-key {
        tailf:cli-before-key 2;
      }
      tailf:cli-optional-in-sequence;
      type uint32 {
        tailf:info "<1-2147483647>;;Stateful NAT mapping id";
        range "1..2147483647";
      }
    }

    // <interface>
    leaf interface {
      when "not(../pool)" {
        tailf:dependency "../pool";
      }
      tailf:info "Specify interface for global address";
      tailf:cli-prefix-key {
        tailf:cli-before-key 2;
      }
      tailf:cli-optional-in-sequence;
      tailf:cli-diff-dependency "../../../../../../../interface";
      type string {
        tailf:info "WORD;;Interface name";
      }
    }

    // [vrf]
    leaf vrf {
      tailf:info "Specify vrf";
      tailf:cli-expose-key-name;
      type string {
        tailf:info "WORD;;vrf name";
      }
    }

    // [match-in-vrf]
    leaf match-in-vrf {
      tailf:info "Match incoming vrf";
      tailf:cli-optional-in-sequence;
      type empty;
    }
  }


  /// =========================================================================
  /// grouping xxx
  /// =========================================================================

  grouping mobile-ip-spi-grouping {
    choice spi-type-choice {
      leaf hex {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "<100-FFFFFFFF>;;SPI hex value";
          pattern "[xa-fA-F0-9]+";
        }
      }
      leaf decimal {
        tailf:info "decimal Security parameter index - bidirectional";
        type uint32 {
          tailf:info "<256-4294967295>;;SPI decimal value";
          range "256..4294967295";
        }
      }
    }
  }


  // interface * / xconnect
  grouping xconnect-if-grouping {
    choice xconnect-choice {

      // interface * / xconnect * encapsulation
      container xconnect {
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-if-xconn";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        tailf:cli-diff-dependency "../encapsulation";
        tailf:cli-diff-set-after "../ip/address/primary/address" {
          tailf:cli-when-target-delete;
        }
        presence true;
        leaf address {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          tailf:cli-hide-in-submode;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP address of peer";
          }
        }
        leaf vcid {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          tailf:cli-hide-in-submode;
          type uint32 {
            tailf:info "<1-4294967295>;;Enter VC ID value";
            range "1..4294967295";
          }
        }
        leaf encapsulation {
          tailf:info "Data encapsulation method";
          tailf:cli-hide-in-submode;
          tailf:cli-optional-in-sequence;
          tailf:cli-remove-before-change;
          type enumeration {
            enum mpls {
              tailf:info "Use MPLS encapsulation";
            }
            enum l2tpv3 {
              tailf:info "Use L2TPv3 encapsulation";
            }
          }
        }
        leaf manual {
          tailf:info "Manually configure session parameters";
          tailf:cli-optional-in-sequence;
          tailf:cli-hide-in-submode;
          type empty;
        }
        leaf pw-class {
          tailf:info "Optional pseudowire-class to use for advanced configuration";
          tailf:cli-optional-in-sequence;
          tailf:cli-hide-in-submode;
          type string {
            tailf:info "WORD;;Pseudowire-class name";
          }
          tailf:non-strict-leafref {
            path "/ios:pseudowire-class/name";
          }
        }
        leaf sequencing {
          tailf:info "Configure sequencing options for xconnect";
          tailf:cli-full-command;
          tailf:cli-hide-in-submode;
          when "../encapsulation = 'l2tpv3'" {
            tailf:dependency "../encapsulation";
          }
          type enumeration {
            enum both {
              tailf:info "Transmit and receive sequence numbers";
            }
            enum receive {
              tailf:info "Receive sequence numbers";
            }
            enum transmit {
              tailf:info "Transmit sequence numbers";
            }
          }
        }

        // interface * / xconnect encapsulation / backup
        container backup {
          tailf:cli-break-sequence-commands;
          tailf:info "Xconnect backup configuration commands";

          // interface * / xconnect encapsulation / backup peer
          container peer {
            tailf:info "Backup pseudowire";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf peer-router-ip-addr {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IP address of peer";
              }
            }
            leaf vcid {
              tailf:cli-drop-node-name;
              tailf:cli-remove-before-change;
              type uint32 {
                tailf:info "<1-4294967295>;;Enter VC ID value";
                range "1..4294967295";
              }
            }
            leaf pw-class {
              tailf:cli-optional-in-sequence;
              type string {
                tailf:info "Optional Pseudowire-class to use for backup pseudowire";
              }
              tailf:non-strict-leafref {
                path "/ios:pseudowire-class/name";
              }
            }
            leaf priority {
              tailf:info "Optional priority to use for backup pseudowire.";
              type uint8 {
                tailf:info "Peer priority";
                range "1..10";
              }
            }
          }

          // interface * / xconnect encapsulation / backup delay
          container delay {
            tailf:info "Backup delay";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf enable-delay {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint8 {
                tailf:info "<0-180>;;Enable delay";
                range "0..180";
              }
              default 0;
            }
            leaf disable-delay {
              tailf:cli-drop-node-name;
              type union {
                type uint8 {
                  tailf:info "<0-180>;;Disable delay";
                  range "0..180";
                }
                type enumeration {
                  enum never {
                    tailf:info "Disallow disable";
                  }
                }
              }
              default 0;
            }
          }
        }

        // interface * / xconnect encapsulation / mpls
        container mpls {
          tailf:info "MPLS manual configuration commands";

          // interface * / xconnect encapsulation / mpls label
          container label {
            tailf:info "MPLS local and remote pseudowire labels";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf local {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint32 {
                tailf:info "NUM;;Local pseudowire label";
              }
            }
            leaf remote {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "NUM;;Remote pseudowire label";
              }
            }
          }

          // interface * / xconnect encapsulation / mpls control-word
          leaf control-word {
            tailf:info "Include control-word in pseudowire packets";
            tailf:cli-show-no;
            type empty;
          }
        }

        // interface * / xconnect encapsulation / mtu
        leaf mtu {
          tailf:info "set XCONNECT Maximum Transfer Unit";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<64-9216>;;per Xconnect MTU size in bytes";
            range "64..9216";
          }
        }

        // interface * / xconnect encapsulation / no remote link failure notification
        container remote {
          tailf:info "Xconnect remote peer configuration commands";
          container link {
            tailf:info "Link information";
            container failure {
              tailf:info "Failure information";
              leaf notification {
                tailf:info "Notify in case of remote link failure";
                tailf:cli-boolean-no;
                type boolean;
                default true;
              }
            }
          }
        }
      }

      // interface * / xconnect vfi
      container xconnect-vfi {
        tailf:cli-drop-node-name;
        container xconnect {
          tailf:info "Xconnect commands";
          tailf:cli-incomplete-command;
          leaf vfi {
            tailf:info "connect to a virtual forwarding instance";
            // dep: before this created, must change l2 vfi
            tailf:cli-diff-dependency "/ios:l2/vfi" {
              tailf:cli-trigger-on-set;
            }
            tailf:non-strict-leafref {
              path "/ios:l2/vfi/name";
            }
            type string {
              tailf:info "WORD;VFI name";
            }
          }
        }
      }
    }
  }


  // connect * / xconnect
  // interface CEM* / cem * / xconnect
  // interface ATM* / pvc * / xconnect
  grouping xconnect-grouping {
    container xconnect {
      tailf:info "Xconnect commands";
      tailf:cli-add-mode;
      tailf:cli-mode-name "cfg-xconn";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      presence true;
      leaf address {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        tailf:cli-hide-in-submode;
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;IP address of peer";
        }
      }
      leaf vcid {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        tailf:cli-hide-in-submode;
        type uint32 {
          tailf:info "<1-4294967295>;;Enter VC ID value";
          range "1..4294967295";
        }
      }
      leaf encapsulation {
        tailf:info "Data encapsulation method";
        tailf:cli-hide-in-submode;
        tailf:cli-optional-in-sequence;
        tailf:cli-remove-before-change;
        tailf:cli-delete-container-on-delete;
        type enumeration {
          enum mpls {
            tailf:info "Use MPLS encapsulation";
          }
          enum l2tpv3 {
            tailf:info "Use L2TPv3 encapsulation";
          }
        }
      }
      leaf manual {
        tailf:info "Manually configure session parameters";
        tailf:cli-optional-in-sequence;
        tailf:cli-hide-in-submode;
        type empty;
      }
      leaf pw-class {
        tailf:info "Optional pseudowire-class to use for advanced configuration";
        tailf:cli-optional-in-sequence;
        tailf:cli-hide-in-submode;
        tailf:non-strict-leafref {
          path "/ios:pseudowire-class/name";
        }
        type string {
          tailf:info "WORD;;Pseudowire-class name";
        }
      }
      leaf sequencing {
        when "../encapsulation = 'l2tpv3'" {
          tailf:dependency "../encapsulation";
        }
        tailf:info "Configure sequencing options for xconnect";
        tailf:cli-full-command;
        tailf:cli-hide-in-submode;
        type enumeration {
          enum both {
            tailf:info "Transmit and receive sequence numbers";
          }
          enum receive {
            tailf:info "Receive sequence numbers";
          }
          enum transmit {
            tailf:info "Transmit sequence numbers";
          }
        }
      }

      // interface CEM* / cem * / xconnect encapsulation / backup
      container backup {
        tailf:cli-break-sequence-commands;
        tailf:info "Xconnect backup configuration commands";

        // interface CEM* / cem * / xconnect encapsulation / backup peer
        container peer {
          tailf:info "Backup pseudowire";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf peer-router-ip-addr {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP address of peer";
            }
          }
          leaf vcid {
            tailf:cli-drop-node-name;
            tailf:cli-remove-before-change;
            type uint32 {
              tailf:info "<1-4294967295>;;Enter VC ID value";
              range "1..4294967295";
            }
          }
          leaf pw-class {
            tailf:cli-optional-in-sequence;
            tailf:non-strict-leafref {
              path "/ios:pseudowire-class/name";
            }
            type string {
              tailf:info "Optional Pseudowire-class to use for backup pseudowire";
            }
          }
          leaf priority {
            tailf:info "Optional priority to use for backup pseudowire.";
            type uint8 {
              tailf:info "Peer priority";
              range "1..10";
            }
          }
        }

        // interface CEM* / cem * / xconnect encapsulation / backup delay
        container delay {
          tailf:info "Backup delay";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf enable-delay {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-180>;;Enable delay";
              range "0..180";
            }
            default 0;
          }
          leaf disable-delay {
            tailf:cli-drop-node-name;
            type union {
              type uint8 {
                tailf:info "<0-180>;;Disable delay";
                range "0..180";
              }
              type enumeration {
                enum never {
                  tailf:info "Disallow disable";
                }
              }
            }
            default 0;
          }
        }
      }
    }
  }


  // ip pim
  // ip pim vrf *
  grouping ip-pim-grouping {

    // ip pim mpls source
    container mpls {
      tailf:info "pim mpls commands";
      container source {
        tailf:info "Configure source interface for multicast RPF";
        uses interface-name-grouping;
      }
    }

    // ip pim ssm
    container ssm {
      tailf:info "Configure Source Specific Multicast";
      choice ip-pim-ssm-choice {
        leaf default {
          tailf:info "Use 232/8 group range for SSM";
          type empty;
        }
        leaf range {
          tailf:info "ACL for group range to be used for SSM";
          type union {
            type uint16 {
              tailf:info "<1-99>;;Access list number";
              range "1..99";
            }
            type string {
              tailf:info "WORD;;IP named access list";
              pattern '[a-zA-Z].*';
            }
          }
        }
      }
    }

    // ip pim register-rate-limit
    leaf register-rate-limit {
      tailf:info "Rate limit for PIM data registers";
      type uint32 {
        tailf:info "<8000-2000000000>;;Bits per second";
      }
    }

    // ip pim register-source
    container register-source {
      tailf:info "Source address for PIM Register";
      uses interface-name-grouping;
    }

    // ip pim accept-rp
    container accept-rp {
      tailf:info "RP accept filter";

      // ip pim accept-rp *
      list list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key address;
        leaf address {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP address of RP for group";
          }
        }
        leaf access-list {
          tailf:cli-drop-node-name;
          type std-acl-type;
        }
      }

      // ip pim accept-rp auto-rp
      leaf auto-rp {
        tailf:info "only RP-mapping from Auto-RP";
        type empty;
      }
    }

    // ip pim accept-register list
    container accept-register {
      tailf:info "Registers accept filter";
      leaf list {
        tailf:info "Access list";
        type ext-acl-type;
      }
    }

    // ip pim snooping
    leaf snooping {
      tailf:info "Global PIM Snooping enable for Catalyst Vlans";
      type empty;
    }

    // ip pim bidir-enable
    leaf bidir-enable {
      tailf:info "Enable Bidir-PIM";
      type empty;
    }

    // ip pim bsr-candidate *
    list bsr-candidate {
      tailf:info "Candidate bootstrap router (candidate BSR)";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Interface name";
        }
      }
      leaf hash-mask-length {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<0-32>;;Hash Mask length for RP selection";
          range "0..32";
        }
      }
      leaf priority {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<0-255>;;Priority value for candidate bootstrap router";
        }
      }
      leaf accept-rp-candidate {
        tailf:info "BSR RP candidate filter";
        type exp-ip-acl-type;
      }
    }

    // ip pim send-rp-announce
    container send-rp-announce {
      tailf:info "Auto-RP send RP announcement";
      tailf:cli-compact-syntax;
      container interface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        uses interface-name-grouping;
      }
      leaf scope {
        tailf:info "RP announcement scope";
        type uint8 {
          tailf:info "<1-255>;;TTL of the RP announce packet ";
          range "1..255";
        }
      }
      leaf group-list {
        tailf:info "Group access-list";
        type union {
          type uint16 {
            tailf:info "<1-99>;;Access list number";
            range "1..99";
          }
          type string {
            tailf:info "WORD;;IP named access list";
            pattern '[a-zA-Z].*';
          }
        }
      }
      leaf interval {
        tailf:info "RP announcement interval";
        type uint16 {
          tailf:info "<1-16383>;;number of seconds";
          range "1..16383";
        }
      }
    }

    // ip pim send-rp-discovery
    container send-rp-discovery {
      tailf:info "Auto-RP send RP discovery message (as RP-mapping agent)";
      tailf:cli-compact-syntax;
      container interface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        uses interface-name-grouping;
      }
      container scope {
        tailf:info "Scope of the RP discovery packets";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf ttl {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<1-255>;;TTL";
            range "1..255";
          }
        }
        leaf interval {
          tailf:info "RP discovery interval";
          type uint16 {
            tailf:info "<1-16383>;;number of seconds";
            range "1..16383";
          }
        }
      }
    }

    // ip pim rp-address *
    list rp-address {
      tailf:info "PIM RP-address (Rendezvous Point)";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      key address;
      leaf address {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;IP address of Rendezvous-point for group";
        }
      }
      leaf access-list {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        tailf:cli-disallow-value "override";
        type std-acl-type;
      }
      leaf override {
        tailf:info "Overrides dynamically learnt RP mappings";
        type empty;
      }
    }

    // ip pim rp-candidate *
    list rp-candidate {
      tailf:info "To be a PIMv2 RP candidate";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Interface name";
        }
      }
      leaf bidir {
        type empty;
      }
      leaf group-list {
        tailf:info "group-list";
        type union {
          type uint8 {
            tailf:info "<1-99>;;Access-list reference for group prefixes";
            range "1..99";
          }
          type string {
            tailf:info "WORD;;Named access list";
          }
        }
      }
      leaf interval {
        tailf:info "RP candidate advertisement interval";
        type uint16 {
          tailf:info "<1-16383>;;number of seconds";
          range "1..16383";
        }
      }
      leaf priority {
        tailf:info "RP candidate priority";
        type uint8 {
          tailf:info "<0-255>;;Priority value";
        }
      }
    }

    // ip pim spt-threshold
    container spt-threshold {
      tailf:info "Source-tree switching threshold";

      // ip pim spt-threshold infinity
      // ip pim spt-threshold ?
      leaf value {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        type union {
          type enumeration {
            enum infinity {
              tailf:info "Never switch to source-tree";
            }
          }
          type uint32 {
            tailf:info "<0-4294967>;;Traffic rate in kilobits per second";
            range "0..4294967";
          }
        }
      }

      // ip pim spt-threshold ? group-list *
      list group-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        key group-list;
        leaf value {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type union {
            type enumeration {
              enum infinity {
                tailf:info "Never switch to source-tree";
              }
            }
            type uint32 {
              tailf:info "<0-4294967>;;Traffic rate in kilobits per second";
              range "0..4294967";
            }
          }
        }
        leaf group-list {
          tailf:info "Group address access-list";
          tailf:cli-expose-key-name;
          type std-acl-type;
        }
      }
    }

    // ip pim autorp
    choice autorp-choice {
      // no ip pim autorp
      leaf autorp {
        tailf:info "Configure AutoRP global operations";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }
      // ip pim autorp listener
      container conf {
        tailf:cli-drop-node-name;
        container autorp {
          tailf:info "Configure AutoRP global operations";
          tailf:cli-incomplete-no;
          tailf:cli-incomplete-command;
          leaf listener {
            tailf:info "Allow AutoRP packets across sparse mode interface";
            type empty;
          }
        }
      }
    }

    // ip pim dm-fallback
    leaf dm-fallback {
      tailf:info "Fallback group mode is Dense";
      tailf:cli-full-command;
      type empty;
    }

    // no ip pim v1-rp-reachability
    leaf v1-rp-reachability {
      tailf:info "Send PIMv1 RP-reachability packet";
      tailf:cli-boolean-no;
      type boolean;
      default true;
    }
  }

  // event manager applet * / event
  // event manager applet * / event tag *
  grouping event-manager-applet-event-grouping {

    // event manager applet * / event none
    container none {
      tailf:info "Manually run policy event";
      tailf:cli-delete-when-empty;
      tailf:cli-reset-container;
      presence true;

      choice none-choice {
        // event manager applet * / event none maxrun
        leaf maxrun {
          tailf:info "Maximum runtime of applet";
          type uint32 {
            tailf:info "<0-31536000>;;Enter seconds[.milliseconds] value";
          }
        }
        // event manager applet * / event none sync
        leaf sync {
          tailf:info "EEM policy execution sync or async";
          type enumeration {
            enum no {
              tailf:info "Policy and CLI will run asynchronously";
            }
            enum yes {
              tailf:info "Policy and CLI will run synchronously";
            }
          }
        }
      }
    }

    // event manager applet * / event snmp-notification
    container snmp-notification {
      tailf:info "SNMP Notification Event";
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      leaf oid {
        tailf:info "Object ID of data element";
        type string {
          tailf:info "WORD;;OID string";
        }
      }
      leaf oid-val {
        tailf:info "Comparison value";
        type string {
          tailf:info "WORD;;Comparision value";
        }
      }
      leaf op {
        tailf:info "Operator";
        type operator-type;
      }
      leaf src-ip-address {
        tailf:info "Source ip address";
        type union {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Source ip address value";
          }
          type inet:ipv6-address {
            tailf:info "X:X:X:X::X;;Source ip address value";
          }
        }
      }
      leaf dest-ip-address {
        tailf:info "Destination ip address";
        type union {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Destination ip address value";
          }
          type inet:ipv6-address {
            tailf:info "X:X:X:X::X;;Destination ip address value";
          }
        }
      }
    }

    // event manager applet * / event syslog
    container syslog {
      tailf:info "Syslog event";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf serverity {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        tailf:cli-incomplete-command;
        type enumeration {
          enum severity-debugging {
            tailf:info "Debugging messages";
          }
          enum severity-notification {
            tailf:info "Basic notification, informational messages";
          }
          enum severity-minor {
            tailf:info "Minor conditions";
          }
          enum severity-normal {
            tailf:info "Normal event, signifying returning to normal state";
          }
          enum severity-warning {
            tailf:info "Warning conditions";
          }
          enum severity-major {
            tailf:info "Major conditions";
          }
          enum severity-fatal {
            tailf:info "System is unusable";
          }
          enum severity-critical {
            tailf:info "Critical conditions, immediate attention needed";
          }
        }
      }
      leaf pattern {
        tailf:info "Pattern match string for the entire message";
        tailf:cli-optional-in-sequence;
        type string {
          tailf:info "WORD;;Pattern match string for the entire message";
        }
      }
      leaf facility {
        tailf:info "Match string for facility";
        tailf:cli-optional-in-sequence;
        type string {
          tailf:info "WORD;;Match string for facility";
        }
      }
      leaf maxrun {
        tailf:info "Maximum runtime of applet";
        type uint32 {
          tailf:info "<0-31536000>;;Enter seconds[.milliseconds] value";
          range "0..31536000";
        }
      }
    }

    // event manager applet * / event cli pattern
    container cli {
      tailf:info "CLI event";
      tailf:cli-compact-syntax;
      container pattern {
        tailf:info "CLI command pattern match";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf regular-expression {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;Pattern match string";
          }
        }
        leaf sync {
          tailf:info "CLI and EEM policy execution sync or async";
          tailf:cli-optional-in-sequence;
          type enumeration {
            enum no {
              tailf:info "Policy and CLI will run asynchronously";
            }
            enum yes {
              tailf:info "Run policy and the result determines whether to run CLI";
            }
          }
        }
        leaf skip {
          tailf:info "Whether to skip CLI command execution";
          type enumeration {
            enum no {
              tailf:info "CLI command should be executed";
            }
            enum yes {
              tailf:info "CLI command should not be executed";
            }
          }
        }
      }
    }

    // event manager applet * / event track
    container track {
      tailf:info "Tracking object event";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf object-number {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<1-1000>;;Tracking object number";
        }
      }
      leaf state {
        tailf:info "State of tracking object";
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum any {
            tailf:info "Any state";
          }
          enum down {
            tailf:info "Down state";
          }
          enum up {
            tailf:info "Up state";
          }
        }
      }
      leaf maxrun {
        tailf:info "Maximum runtime of applet";
        type uint32 {
          tailf:info "<0-31536000>;;Enter seconds[.milliseconds] value";
          range "0..31536000";
        }
      }
    }

    // event manager applet * / event neighbor-discovery
    container neighbor-discovery {
      tailf:info "Neighbor Discovery event";
      tailf:cli-compact-syntax;
      container interface {
        tailf:info "Interface name";
        tailf:cli-flatten-container;
        leaf regexp {
          tailf:info "Specify a regexp for interfaces";
          type string {
            tailf:info "WORD;;interface name string";
          }
        }
      }
      leaf cdp {
        tailf:info "Monitor CDP events";
        type enumeration {
          enum add {
            tailf:info "Monitor only CDP add events";
          }
          enum all {
            tailf:info "Monitor all CDP events";
          }
          enum delete {
            tailf:info "Monitor only CDP delete events";
          }
          enum update {
            tailf:info "Monitor CDP add and update events";
          }
        }
      }
    }

    // event manager applet * / event timer
    container timer {
      tailf:info "Timer event";
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      leaf trigger {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type enumeration {
          enum absolute {
            tailf:info "Absolute timer event";
          }
          enum countdown {
            tailf:info "Countdown timer event";
          }
          enum watchdog {
            tailf:info "Watchdog timer event";
          }
          enum cron {
            tailf:info "Cron timer event";
          }
        }
      }
      leaf name {
        tailf:info "Name of the timer";
        type string {
          tailf:info "WORD;;Timer name string";
        }
      }
      leaf cron-entry {
        tailf:info "Cron entry for cron timer";
        type string {
          tailf:info "WORD;;Cron entry string";
        }
      }
      leaf time {
        tailf:info "Time period for watchdog / countdown / absolute timer";
        type uint32 {
          tailf:info "<1-4294967295>;;Enter seconds[.milliseconds] value";
          range "1..4294967295";
        }
      }
      leaf maxrun {
        tailf:info "Maximum runtime of applet";
        type uint32 {
          tailf:info "<0-31536000>;;Enter seconds[.milliseconds] value";
          range "0..31536000";
        }
      }
      leaf ratelimit {
        tailf:info "Limit trigger to once per given time period";
        type uint32 {
          tailf:info "<0-31536000>;;Enter seconds[.milliseconds] value";
          range "0..31536000";
        }
      }
    }

    // event manager applet * / event snmp
    container snmp {
      tailf:info "SNMP event";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf oid {
        tailf:info "Object ID of data element";
        type string {
          tailf:info "WORD;;OID string";
        }
      }
      leaf get-type {
        tailf:cli-break-sequence-commands;
        tailf:info "Type of SNMP get operation";
        type enumeration {
          enum exact {
            tailf:info "Exact oid specified";
          }
          enum next {
            tailf:info "Next available oid";
          }
        }
      }
      leaf entry-op {
        tailf:info "Entry comparison operator";
        type operator-type;
      }
      leaf entry-val {
        tailf:info "Entry comparison value";
        type string {
          tailf:info "WORD;;Entry value";
        }
      }
      leaf exit-time {
        tailf:info "Time before event monitoring is reenabled";
        type uint32 {
          tailf:info "<0-4294967295>;;Enter seconds[.milliseconds] value";
        }
      }
      leaf exit-op {
        tailf:info "Exit operator";
        type operator-type;
      }
      leaf exit-val {
        tailf:info "Exit comparison value";
        type string {
          tailf:info "WORD;;Entry value";
        }
      }
      leaf poll-interval {
        tailf:info "Poll interval value";
        type uint32 {
          tailf:info "<0-4294967295>;;Enter seconds[.milliseconds] value";
        }
      }
      leaf maxrun {
        tailf:info "Maximum runtime of applet";
        type uint32 {
          tailf:info "<0-31536000>;;Enter seconds[.milliseconds] value";
          range "0..31536000";
        }
      }
    }

    // event manager applet * / event ipsla
    container ipsla {
      tailf:info "IPSLA Event";
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      leaf operation-id {
        tailf:info "IPSLA Operation ID";
        type uint32 {
          tailf:info "<1-2147483647>;;Operation ID value";
          range "1..2147483647";
        }
      }
      leaf reaction-type {
        tailf:info "IPSLA Reaction Type";
        type string {
          tailf:info "WORD;;Reaction Type";
        }
      }
      leaf maxrun {
        tailf:info "Maximum runtime of applet";
        type uint32 {
          tailf:info "<0-31536000>;;Enter seconds[.milliseconds] value";
          range "0..31536000";
        }
      }
    }
  }

  // vrf definition * / route-target
  // vrf definition * / address-family ipv4 / route-target
  // l2vpn vfi context * / autodiscovery bgp signaling * / route-target
  // l2 vfi * / route-target
  grouping route-target-grouping {

    list export {
      tailf:info "Export Target-VPN community";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key asn-ip;
      leaf asn-ip {
        type asn-ip-type {
          tailf:info "ASN:nn or IP-address:nn;;Target VPN Extended Community";
        }
      }
    }

    list import {
      tailf:info "Import Target-VPN community";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key asn-ip;
      leaf asn-ip {
        type asn-ip-type {
          tailf:info "ASN:nn or IP-address:nn;;Target VPN Extended Community";
        }
      }
    }
  }

  // vrf definition * / address-family ipv4
  // vrf definition * / address-family ipv6
  grouping vrf-definition-af-grouping {

    // vrf definition * / address-family ipv4 / import
    container import {
      tailf:info "VRF import";

      // vrf definition * / address-family ipv4 / import ipv4 unicast map
      container ipv4 {
        tailf:info "Address family based VRF import";
        container unicast {
          tailf:info "Import prefixes from IPv4 Unicast table";
          leaf map {
            tailf:info "Route-map based VRF import";
            tailf:non-strict-leafref {
              path "/ios:route-map/name";
            }
            type string {
              tailf:info "WORD;;VRF import route-map name";
            }
          }
        }
      }

      // vrf definition * / address-family ipv4 / import map
      leaf map {
        tailf:info "Route-map based VRF import";
        tailf:non-strict-leafref {
          path "/ios:route-map/name";
        }
        type string {
          tailf:info "WORD;;Route-map reference";
        }
      }
    }

    // vrf definition * / address-family ipv4 / export
    container export {
      tailf:info "VRF export";

      // vrf definition * / address-family ipv4 / export ipv4 unicast map
      container ipv4 {
        tailf:info "Address family based VRF export";
        container unicast {
          tailf:info "Export prefixes from IPv4 Unicast table";
          leaf map {
            tailf:info "Route-map based VRF export";
            tailf:non-strict-leafref {
              path "/ios:route-map/name";
            }
            type string {
              tailf:info "WORD;;VRF export route-map name";
            }
          }
        }
      }

      // vrf definition * / address-family ipv4 / export map
      leaf map {
        tailf:info "Route-map based VRF export";
        type string {
          tailf:info "WORD;;Route-map reference";
        }
      }
    }

    // vrf definition * / address-family ipv4 / route-target
    container route-target {
      tailf:info "Specify Target VPN Extended Communities";
      uses route-target-grouping;
    }

    // vrf definition * / address-family ipv4 / maximum routes
    container maximum {
      tailf:info "Set a limit";
      container routes {
        tailf:info "Maximum number of routes allowed in this routing table";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf limit {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<1-4294967294>;;Maximum number of routes allowed";
          }
        }
        choice action {
          case a {
            leaf warning-only {
              tailf:info "Only give a warning message if limit is exceeded";
              type empty;
            }
          }
          case b {
            leaf warn-threshold {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<1-100>;;Threshold value (%) at which to generate a warning msg";
                range "1..100";
              }
            }
            leaf reinstall {
              tailf:info "Reinstall previous rejected route due to over maximum route limit";
              type uint8 {
                tailf:info "<1-100>;;Threshold value (%) at which to reinstall routes back to VRF";
                range "1..100";
              }
            }
          }
        }
      }
    }

    // vrf definition * / address-family ipv4 / bgp nexthop Loopback
    container bgp {
      tailf:info "Commands pertaining to BGP";
      container next-hop {
        tailf:info "Next-hop for the routes of a VRF in the backbone";
        leaf Loopback {
          tailf:info "Loopback interface number";
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          type uint32 {
            tailf:info "<0-2147483647>;;Loopback interface number";
            range "0..2147483647";
          }
        }
      }
    }

    // vrf definition * / address-family ipv4 / snmp context
    uses snmp-context-grouping;
  }

  // snmp-server host *
  grouping snmp-server-host-grouping {

    // snmp-server host * traps
    // snmp-server host * informs
    leaf message-type {
      tailf:key-default traps;
      type enumeration {
        enum informs {
          tailf:info "Send Inform messages to this host";
        }
        enum traps {
          tailf:info "Send Trap messages to this host";
        }
      }
    }

    // snmp-server host * version
    container version {
      tailf:info "SNMP version to use for notification messages";
      tailf:cli-optional-in-sequence;
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      tailf:cli-incomplete-command;
      leaf version {
        tailf:cli-drop-node-name;
        type enumeration {
          enum "1" {
            tailf:info "Use SNMPv1";
          }
          enum "2c" {
            tailf:info "Use SNMPv2c";
          }
          enum "3" {
            tailf:info "Use SNMPv3";
          }
        }
      }
      leaf security-level {
        tailf:cli-drop-node-name;
        when "../version = '3'" {
          tailf:dependency "../version";
        }
        type enumeration {
          enum auth {
            tailf:info "Use the SNMPv3 authNoPriv Security Level";
          }
          enum noauth {
            tailf:info "Use the SNMPv3 noAuthNoPriv Security Level";
          }
          enum priv {
            tailf:info "Use the SNMPv3 authPriv Security Level";
          }
        }
      }
    }

    // snmp-server host * community-string
    leaf community-string {
      tailf:cli-drop-node-name;
      tailf:cli-disallow-value "version|informs|traps|vrf";
      tailf:cli-remove-before-change;
      type string {
        tailf:info "WORD;;SNMPv1/v2c community string or SNMPv3 user name";
      }
    }

    // snmp-server host * udp-port
    leaf udp-port {
      tailf:info "The notification host's UDP port number (default port 162)";
      tailf:cli-optional-in-sequence;
      type uint16 {
        tailf:info "<0-65535>;;The notification host's port number";
      }
      default 162;
    }

    // snmp-server host * allowed-traps *
    leaf-list allowed-traps {
      tailf:cli-drop-node-name;
      tailf:cli-flat-list-syntax {
        tailf:cli-replace-all;
      }
      type snmp-traps-type;
    }
  }

  // snmp-server host *
  grouping snmp-server-host-new-grouping {

    // snmp-server host * traps|informs
    leaf message-type {
      type enumeration {
        enum informs {
          tailf:info "Send Inform messages to this host";
        }
        enum traps {
          tailf:info "Send Trap messages to this host";
        }
      }
    }

    // snmp-server host * version
    leaf version {
      tailf:info "SNMP version to use for notification messages";
      tailf:cli-optional-in-sequence;
      tailf:cli-prefix-key {
        tailf:cli-before-key 3;
      }
      type enumeration {
        enum "1" {
          tailf:info "Use SNMPv1";
        }
        enum "2c" {
          tailf:info "Use SNMPv2c";
        }
        enum "3" {
          tailf:info "Use SNMPv3";
        }
      }
    }
    leaf security-level {
      when "../version = '3'" {
        tailf:dependency "../version";
      }
      tailf:cli-drop-node-name;
      tailf:cli-optional-in-sequence;
      tailf:cli-prefix-key {
        tailf:cli-before-key 3;
      }
      type enumeration {
        enum auth {
          tailf:info "Use the SNMPv3 authNoPriv Security Level";
        }
        enum noauth {
          tailf:info "Use the SNMPv3 noAuthNoPriv Security Level";
        }
        enum priv {
          tailf:info "Use the SNMPv3 authPriv Security Level";
        }
      }
    }

    // snmp-server host * <community-string>
    leaf community-string {
      tailf:cli-disallow-value "version|informs|traps|vrf|auth|noauth|priv";
      type string {
        tailf:info "WORD;;SNMPv1/v2c community string or SNMPv3 user name";
      }
    }

    // snmp-server host * udp-port
    leaf udp-port {
      tailf:info "The notification host's UDP port number (default port 162)";
      tailf:cli-optional-in-sequence;
      type uint16 {
        tailf:info "<0-65535>;;The notification host's port number";
      }
      default 162;
    }

    // snmp-server host * allowed-traps
    leaf-list allowed-traps {
      tailf:cli-drop-node-name;
      tailf:cli-flat-list-syntax {
        tailf:cli-replace-all;
      }
      type snmp-traps-type;
    }
  }

  // snmp-server group *
  grouping snmp-server-group-grouping {

    // snmp-server group * match
    leaf match {
      tailf:info "context name match criteria";
      tailf:cli-optional-in-sequence;
      type enumeration {
        enum exact {
          tailf:info "match the exact context";
        }
        enum prefix {
          tailf:info "only match the context prefix";
        }
      }
    }

    // snmp-server group * read
    leaf read {
      tailf:info "specify a read view for the group";
      tailf:cli-optional-in-sequence;
      type string {
        tailf:info "WORD;;read view name";
      }
    }

    // snmp-server group * write
    leaf write {
      tailf:info "specify a write view for the group";
      tailf:cli-optional-in-sequence;
      type string {
        tailf:info "WORD;;write view name";
      }
    }

    // snmp-server group * notify
    leaf notify {
      tailf:info "specify a notify view for the group";
      tailf:cli-optional-in-sequence;
      type string {
        tailf:info "WORD;;notify view name";
      }
    }

    // snmp-server group * access
    leaf access {
      tailf:info "specify an access-list associated with this group";
      tailf:cli-incomplete-command;
      type empty;
    }
    leaf ipv6 {
      tailf:info "Specify IPv6 Named Access-List";
      when "../access" {
        tailf:dependency "../access";
      }
      tailf:cli-optional-in-sequence;
      tailf:non-strict-leafref {
        path "/ios:ipv6/access-list/named-acl/name";
      }
      type string {
        tailf:info "WORD;;IPv6 Access-list name";
      }
    }
    leaf acl {
      tailf:cli-drop-node-name;
      when "../access" {
        tailf:dependency "../access";
      }
      type union {
        type uint8 {
          tailf:info "<1-99>;;Std IP accesslist allowing access with this group";
          range "1..99";
        }
        type string {
          tailf:info "WORD;;Access-list name";
        }
      }
    }
  }

  // snmp-server user *
  grouping snmp-server-user-grouping {

    choice security-model {
      // snmp-server user * v1
      leaf v1 {
        tailf:info "user using the v1 security model";
        type empty;
      }

      // snmp-server user * v2c
      leaf v2c {
        tailf:info "user using the v2c security model";
        type empty;
      }

      // snmp-server user * v3 [encrypted] [auth {md5 | sha} auth-password]
      case v3 {
        leaf v3 {
          tailf:info "user using the v3 security model";
          type empty;
        }
        // snmp-server user * v3 encrypted
        leaf encrypted {
          tailf:cli-drop-node-name;
          tailf:cli-optional-in-sequence;
          tailf:cli-incomplete-command;
          type enumeration {
            enum encrypted {
              tailf:info "specifying passwords as MD5 or SHA digests";
            }
          }
          default encrypted;
        }
        leaf auth {
          tailf:info "authentication parameters for the user";
          tailf:cli-optional-in-sequence;
          tailf:cli-no-name-on-delete;
          tailf:cli-no-value-on-delete;
          tailf:cli-incomplete-command;
          type enumeration {
            enum md5 {
              tailf:info "Use HMAC MD5 algorithm for authentication";
            }
            enum sha {
              tailf:info "Use HMAC SHA algorithm for authentication";
            }
          }
        }
        leaf auth-password {
          when "../auth" {
            tailf:dependency "../auth";
          }
          tailf:cli-drop-node-name;
          tailf:cli-no-value-on-delete;
          ios:password-dequote-output "auth (?:md5|sha) (\\S+)";
          type NEDCOM_SECRET_TYPE {
            tailf:info "WORD;;authentication pasword for user";
          }
        }
        leaf priv {
          tailf:info "encryption parameters for the user";
          tailf:cli-optional-in-sequence;
          tailf:cli-no-name-on-delete;
          tailf:cli-no-value-on-delete;
          tailf:cli-incomplete-command;
          type enumeration {
            enum "3des" {
              tailf:info "Use 168 bit 3DES algorithm for encryption";
            }
            enum aes {
              tailf:info "Use AES algorithm for encryption";
            }
            enum des {
              tailf:info "Use 56 bit DES algorithm for encryption";
            }
          }
        }
        leaf bits {
          when "../priv = 'aes'" {
            tailf:dependency "../priv";
          }
          tailf:cli-drop-node-name;
          tailf:cli-no-value-on-delete;
          tailf:cli-incomplete-command;
          type enumeration {
            enum "128" {
              tailf:info "128 bit keys.";
            }
            enum "192" {
              tailf:info "192 bit keys.";
            }
            enum "256" {
              tailf:info "256 bit keys.";
            }
          }
        }
        leaf priv-password {
          when "../priv" {
            tailf:dependency "../priv";
          }
          tailf:cli-drop-node-name;
          tailf:cli-no-value-on-delete;
          ios:password-dequote-output "priv (?:3des|aes|des)(?: 128| 192| 256)? (\\S+)";
          type NEDCOM_SECRET_TYPE {
            tailf:info "WORD;;privacy pasword for user";
          }
        }
      }
    }

    // snmp-server user * access
    container access {
      tailf:info "specify an access-list associated with this group";
      tailf:cli-flatten-container;
      choice access-choice {
        leaf access-list-std {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-99>;;Standard access list";
            range "1..99";
          }
        }
        leaf access-list-named {
          tailf:cli-drop-node-name;
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;Named access list";
          }
        }
        leaf ipv6 {
          tailf:info "Specify IPv6 Named Access-List";
          tailf:non-strict-leafref {
            path "/ios:ipv6/access-list/named-acl/name";
          }
          type string {
            tailf:info "WORD;;IPv6 Access-list name";
          }
        }
      }
    }
  }


  // cisco-ios api new-aaa-list-syntax
  grouping new-aaa-list-syntax-grouping {
    leaf-list method {
      cli:parse-global-when;
      when "/ios:tailfned/api/new-aaa-list-syntax";
      tailf:cli-drop-node-name;
      tailf:cli-replace-all;
      tailf:cli-flat-list-syntax;
      ios:new-aaa-list-syntax;
      ordered-by user;
      type union {
        type enumeration {
          enum none {
            tailf:info "NO authentication.";
          }
          enum if-needed {
            tailf:info "Only authenticate if needed.";
          }
          enum local {
            tailf:info "Use local username authentication.";
          }
          enum local-case {
            tailf:info "Use case-sensitive local username authentication.";
          }
          enum line {
            tailf:info "Use line password for authentication.";
          }
          enum enable {
            tailf:info "Use enable password for authentication.";
          }
          enum krb5 {
            tailf:info "Use Kerberos 5 authentication.";
          }
          enum krb5-instance {
            tailf:info "Use Kerberos instance privilege maps.";
          }
          enum "tacacs+" {
            tailf:info "Use enable password for authentication.";
          }
        }
        type string {
          tailf:info "group-<groupname>;;Use Server-group <groupname>";
          pattern "group-.+";
        }
        type string {
          tailf:info "cache-<groupname>;;Use Cached-group <groupname>";
          pattern "cache-.+";
        }
      }
    }
  }


  // aaa authentication dot1x *
  // aaa authentication login *
  // aaa authentication ppp *
  // aaa authentication enable default
  // WARNING: DO NOT REORDER CONFIG BELOW, WILL BREAK AUTH ORDER ON DEVICE!!
  grouping aaa-authentication-method-grouping {

    // New model used with 'ned-settings cisco-ios api new-aaa-list-syntax true'
    uses new-aaa-list-syntax-grouping;

    // aaa authentication login * cache
    leaf cache {
      when "not(/ios:tailfned/api/new-aaa-list-syntax)";
      tailf:info "Use Cached-group";
      type aaa-group-type;
    }

    // aaa authentication login * group
    leaf group {
      tailf:info "Use Server-group";
      when "not(/ios:tailfned/api/new-aaa-list-syntax)";
      type aaa-group-type;
    }
    container group2 {
      when "not(/ios:tailfned/api/new-aaa-list-syntax) and ../group";
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      leaf group {
        tailf:info "Use Server-group 2";
        type aaa-group-type;
      }
    }
    container group3 {
      when "not(/ios:tailfned/api/new-aaa-list-syntax) and ../group2";
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      leaf group {
        tailf:info "Use Server-group 3";
        type aaa-group-type;
      }
    }

    // aaa authentication login * krb5
    leaf krb5 {
      when "not(/ios:tailfned/api/new-aaa-list-syntax)";
      tailf:info "Use Kerberos 5 authentication.";
      type empty;
    }

    choice local-choice {
      // aaa authentication login * local
      leaf local {
        when "not(/ios:tailfned/api/new-aaa-list-syntax)";
        tailf:info "Use local username authentication.";
        type empty;
      }
      // aaa authentication login * local-case
      leaf local-case {
        when "not(/ios:tailfned/api/new-aaa-list-syntax)";
        tailf:info "Use case-sensitive local username authentication.";
        type empty;
      }
    }

    // aaa authentication login * tacacs+
    leaf tacacsplus {
      when "not(/ios:tailfned/api/new-aaa-list-syntax)";
      tailf:alt-name "tacacs+";
      tailf:info "Use enable password for authentication.";
      type empty;
    }

    // aaa authentication login * line
    leaf line {
      when "not(/ios:tailfned/api/new-aaa-list-syntax)";
      tailf:info "Use line password for authentication.";
      type empty;
    }

    // aaa authentication login * enable
    leaf enable {
      when "not(/ios:tailfned/api/new-aaa-list-syntax)";
      tailf:info "Use enable password for authentication.";
      type empty;
    }

    // aaa authentication login * none
    leaf none {
      when "not(/ios:tailfned/api/new-aaa-list-syntax)";
      tailf:info "NO authentication.";
      tailf:cli-full-command;
      type empty;
    }
  }

  // aaa authorization exec *
  // aaa authorization commands *
  // aaa authorization eventmanager *
  // aaa authorization network *
  // aaa authorization auth-proxy *
  // aaa authorization subscriber-service *
  // aaa authorization reverse-access *
  grouping aaa-authorization-method-grouping {

    // New model used with 'ned-settings cisco-ios api new-aaa-list-syntax true'
    uses new-aaa-list-syntax-grouping;

    // aaa authorization exec * cache
    leaf cache {
      when "not(/ios:tailfned/api/new-aaa-list-syntax)";
      tailf:info "Use Cached-group";
      type aaa-group-type;
    }

    // aaa authorization exec * group
    leaf group {
      when "not(/ios:tailfned/api/new-aaa-list-syntax)";
      tailf:info "Use server-group";
      type aaa-group-type;
    }
    container group2 {
      when "not(/ios:tailfned/api/new-aaa-list-syntax) and ../group";
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      leaf group {
        tailf:info "Use Server-group 2";
        type aaa-group-type;
      }
    }
    container group3 {
      when "not(/ios:tailfned/api/new-aaa-list-syntax) and ../group2";
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      leaf group {
        tailf:info "Use Server-group 3";
        type aaa-group-type;
      }
    }

    // aaa authorization exec * krb5-instance
    leaf krb5-instance {
      when "not(/ios:tailfned/api/new-aaa-list-syntax)";
      tailf:info "Use Kerberos instance privilege maps.";
      type empty;
    }

    // aaa authorization exec * tacacs+
    leaf tacacsplus {
      when "not(/ios:tailfned/api/new-aaa-list-syntax)";
      tailf:alt-name "tacacs+";
      tailf:info "Use enable password for authorization.";
      type empty;
    }

    // aaa authorization exec * local
    leaf local {
      when "not(/ios:tailfned/api/new-aaa-list-syntax)";
      tailf:info "Use local database.";
      type empty;
    }

    // aaa authorization exec * if-authenticated
    leaf if-authenticated {
      when "not(/ios:tailfned/api/new-aaa-list-syntax)";
      tailf:info "Succeed if user has authenticated.";
      type empty;
    }

    // aaa authorization exec * none
    leaf none {
      when "not(/ios:tailfned/api/new-aaa-list-syntax)";
      tailf:info "No authorization (always succeeds).";
      tailf:cli-full-command;
      type empty;
    }
  }

  // aaa accounting exec *
  // aaa accounting commands *
  // aaa accounting network *
  // aaa accounting connection *
  // aaa accounting system default
  grouping aaa-accounting-method-grouping {

    // aaa accounting exec * none
    // aaa accounting exec * start-stop
    // aaa accounting exec * stop-only
    leaf action-type {
      tailf:cli-drop-node-name;
      tailf:cli-no-value-on-delete;
      ios:aaa-accounting-mode-format;
      type enumeration {
        enum none {
          tailf:info "No accounting.";
        }
        enum start-stop {
          tailf:info "Record start and stop without waiting";
        }
        enum stop-only {
          tailf:info "Record stop when service terminates.";
        }
      }
    }

    // aaa accounting exec * broadcast
    leaf broadcast {
      tailf:info "Use Broadcast for Accounting";
      tailf:cli-no-name-on-delete;
      type empty;
    }

    // aaa accounting exec * group
    leaf group {
      tailf:info "Use Server-group";
      tailf:cli-no-name-on-delete;
      tailf:cli-no-value-on-delete;
      type aaa-group-type;
    }
    container group2 {
      when "../group" {
        tailf:dependency "../group";
      }
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      tailf:cli-optional-in-sequence;
      leaf group {
        tailf:info "Use Server-group 2";
        tailf:cli-no-name-on-delete;
        tailf:cli-no-value-on-delete;
        type string {
          tailf:info "WORD;;Server-group2 name";
        }
      }
    }
    container group3 {
      when "../group2/group" {
        tailf:dependency "../group2/group";
      }
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      leaf group {
        tailf:info "Use Server-group 3";
        tailf:cli-no-name-on-delete;
        tailf:cli-no-value-on-delete;
        type aaa-group-type;
      }
    }
  }

  // cable modulation-profile *
  grouping cable-modulation-profile-grouping {
    leaf fec-tbytes {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type uint8 {
        tailf:info "<0-16>;;FEC tbytes";
      }
    }
    leaf fec-len {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type uint8 {
        tailf:info "<16-253>;;FEC codeword length in k bytes";
      }
    }
    leaf burst-len {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type uint8 {
        tailf:info "<0-255>;;max burst size in minislots";
      }
    }
    leaf guard-t {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type uint8 {
        tailf:info "<0-255>;;guard time in symbols";
      }
    }
    leaf mod {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type enumeration {
        enum "8qam" {
          tailf:info "8-QAM modulation";
        }
        enum "16qam" {
          tailf:info "16-QAM modulation";
        }
        enum "32qam" {
          tailf:info "32-QAM modulation";
        }
        enum "64qam" {
          tailf:info "64-QAM modulation";
        }
        enum "qpsk" {
          tailf:info "qpsk modulation";
        }
      }
    }
    leaf scrambler {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type enumeration {
        enum no-scrambler {
          tailf:info "scrambler disabled";
        }
        enum scrambler {
          tailf:info "scrambler enabled";
        }
      }
    }
    leaf seed {
      when "../scrambler = 'scrambler'" {
        tailf:dependency "../scrambler";
      }
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type string {
        tailf:info "<0x0-0x7FFF>;;scrambler seed in hex";
      }
    }
    leaf diff {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type enumeration {
        enum diff {
          tailf:info "diff encoding enabled";
        }
        enum no-diff {
          tailf:info "diff encoding disabled";
        }
      }
    }
    leaf pre-len {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type uint16 {
        tailf:info "<4-1536>;;preamble length in bits";
      }
    }
    leaf last-cw {
      tailf:cli-drop-node-name;
      type enumeration {
        enum fixed {
          tailf:info "fixed codeword";
        }
        enum shortened {
          tailf:info "shortened codeword";
        }
      }
    }
    leaf preamble {
      tailf:cli-drop-node-name;
      type enumeration {
        enum qpsk0 {
          tailf:info "QPSK0 preamble";
        }
        enum qpsk1 {
          tailf:info "QPSK1 preamble";
        }
      }
    }
    leaf rs-interleave-depth {
      tailf:cli-drop-node-name;
      type uint8 {
        tailf:info "<0-114>;;RS interleave depth";
      }
    }
    leaf rs-interleave-block {
      tailf:cli-drop-node-name;
      type uint16 {
        tailf:info "<18-2048>;;RS interleave block size";
      }
    }
  }

  // cable modulation-profile *
  grouping cable-modulation-profile-list-grouping {

    // cable modulation-profile * request
    container request {
      tailf:info "Request Burst";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      uses cable-modulation-profile-grouping;
    }

    // cable modulation-profile * initial
    container initial {
      tailf:info "Initial Ranging Burst";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      uses cable-modulation-profile-grouping;
    }

    // cable modulation-profile * station
    container station {
      tailf:info "Station Ranging Burst";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      uses cable-modulation-profile-grouping;
    }

    // cable modulation-profile * short
    container short {
      tailf:info "Short Grant Burst";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      uses cable-modulation-profile-grouping;
    }

    // cable modulation-profile * long
    container long {
      tailf:info "Long Grant Burst";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      uses cable-modulation-profile-grouping;
    }

    // cable modulation-profile * a-short
    container a-short {
      tailf:info "Advanced Phy Short Grant Burst";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      uses cable-modulation-profile-grouping;
    }

    // cable modulation-profile * a-long
    container a-long {
      tailf:info "Advanced Phy Long Grant Burst";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      uses cable-modulation-profile-grouping;
    }

    // cable modulation-profile * a-ugs
    container a-ugs {
      tailf:info "Advanced Phy Unsolicited Grant Burst";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      uses cable-modulation-profile-grouping;
    }
  }

  // cable load-balance docsis-group *
  // cable load-balance docsis-group FN *
  grouping cable-load-balance-docsis-group-grouping {

    // cable load-balance docsis-group * / restricted
    leaf restricted {
      tailf:info "Set load balance group as restricted";
      type empty;
    }

    // cable load-balance docsis-group * / downstream
    container downstream {
      tailf:info "Set downstream RF channels";

      // cable load-balance docsis-group * / downstream Modular-Cable *
      list Modular-Cable {
        tailf:info "Modular cable";
        tailf:cli-allow-join-with-key;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "<slot>/<card>/<port>;;Enter slot/subslot/bay";
          }
        }
        leaf rf-channel {
          tailf:info "RF channel";
          tailf:cli-multi-value;
          type string {
            tailf:info "<grouplist>;;List of port numbers and number ranges";
          }
        }
      }

      // cable load-balance docsis-group * / downstream Integrated-Cable *
      list Integrated-Cable {
        tailf:info "Integrated cable";
        tailf:cli-allow-join-with-key;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "<slot>/<card>/<port>;;Enter slot/subslot/bay";
          }
        }
        leaf rf-channel {
          tailf:info "RF channel";
          tailf:cli-multi-value;
          type string {
            tailf:info "<grouplist>;;List of port numbers and number ranges";
          }
        }
      }

      // cable load-balance docsis-group * / downstream Downstream-Cable *
      list Downstream-Cable {
        tailf:info "Downstream-Cable interface";
        tailf:cli-allow-join-with-key;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "<slot>/<card>/<port>;;Enter slot/subslot/bay";
          }
        }
        leaf rf-channel {
          tailf:info "RF channel";
          tailf:cli-multi-value;
          type string {
            tailf:info "<grouplist>;;List of port numbers and number ranges";
          }
        }
      }
    }

    // cable load-balance docsis-group * / upstream
    container upstream {
      tailf:info "Set upstream channels";

      // cable load-balance docsis-group * / upstream Upstream-Cable *
      list Upstream-Cable {
        tailf:info "Upstream Cable Controller";
        tailf:cli-allow-join-with-key;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "<slot>/<card>/<port>;;Enter slot/subslot/bay";
          }
        }
        leaf us-channel {
          tailf:info "Associate physical us channels";
          tailf:cli-multi-value;
          type string {
            tailf:info "<grouplist>;;Physical us channel numbers and number ranges";
          }
        }
      }

      // cable load-balance docsis-group * / upstream Cable *
      list Cable {
        tailf:info "CMTS interface";
        tailf:cli-allow-join-with-key;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "<slot>/<card>/<port>;;Enter slot/subslot/bay";
          }
        }
        leaf upstream-list {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "<grouplist>;;List of Ranges for upstream channels <0-7>";
          }
        }
      }
    }

    // cable load-balance docsis-group * / method
    container method {
      tailf:info "Set load balancing type/method";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf type {
        tailf:cli-drop-node-name;
        type enumeration {
          enum modems {
            tailf:info "Number of modems";
          }
          enum utilization {
            tailf:info "Interface utilization";
          }
        }
      }
      leaf us-method {
        tailf:info "Set load balancing type/method for US";
        type enumeration {
          enum modems {
            tailf:info "Number of modems";
          }
          enum utilization {
            tailf:info "Interface utilization";
          }
        }
      }
    }

    // cable load-balance docsis-group * / threshold
    container threshold {
      tailf:info "Load balancing threshold in %";

      // cable load-balance docsis-group * / threshold load
      container load {
        tailf:info "Interface load threshold settings";
        leaf percentage {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<1-100>;;Threshold value in %";
            range "1..100";
          }
        }
        // cable load-balance docsis-group * / threshold load minimum
        leaf minimum {
          tailf:info "Set minimum number of modems/flows difference before loadbalancing starts";
          type uint8 {
            tailf:info "<1-100>;;Minimum number of modems/flows";
            range "1..100";
          }
        }
      }

      // cable load-balance docsis-group * / threshold stability
      leaf stability {
        tailf:info "Threshold for stability detection";
        type uint8 {
          tailf:info "<0-100>;;Stability condition detection threshold in %";
          range "0..100";
        }
      }
    }

    // cable load-balance docsis-group * / policy
    leaf policy {
      tailf:info "Set load balancing policy";
      type enumeration {
        tailf:info "pure-ds-load;;Do not count US load when calculating DS utilization";
        enum pcmm {
          tailf:info "Enable balancing of modems with active PCMM service flows";
        }
        enum pure-ds-load {
          tailf:info "Do not count US load when calculating DS utilization";
        }
        enum ugs {
          tailf:info "Enable balancing of modems with active UGS service flows";
        }
        enum us-across-ds {
          tailf:info "Load balancing on US groups across DS, DS method will be ignored";
        }
      }
    }

    // cable load-balance docsis-group * / interval
    leaf interval {
      tailf:info "Set interface polling interval";
      type uint16 {
        tailf:info "<1-1000>;;Interface polling interval in seconds";
        range "1..1000";
      }
    }

    // cable load-balance docsis-group * / init-tech-list
    container init-tech-list {
      tailf:info "Set DCC initialization technique list";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf grouplist {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "<grouplist> ";
        }
      }
      leaf ucc {
        tailf:info "Allow the use of UCC in upstream load balancing";
        type empty;
      }
    }

    // cable load-balance docsis-group * / docsis-policy
    leaf docsis-policy {
      tailf:info "Enter load balance group policy";
      tailf:non-strict-leafref {
        path "../../../docsis-policy/policy-id";
      }
      type uint32 {
        tailf:info "<0-4294967295>;;Load balance group policy number";
        range "0..4294967295";
      }
    }

    // cable load-balance docsis-group * / tag *
    list tag {
      tailf:info "Add tag to load balancing group";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;tag name";
        }
      }
    }
  }

  // cable submgmt default filter-group cm
  // cable submgmt default filter-group cpe
  // cable submgmt default filter-group mta
  // cable submgmt default filter-group stb
  // cable submgmt default filter-group ps
  grouping cable-submgmt-default-filter-group-grouping {
    leaf upstream {
      tailf:info "Default Upstream Group";
      type uint8 {
        tailf:info "<1-254>;;Group ID";
        range "1..254";
      }
    }
    leaf downstream {
      tailf:info "Default Downstream Group";
      type uint8 {
        tailf:info "<1-254>;;Group ID";
        range "1..254";
      }
    }
  }


  // facility-alarm outlet-temperature
  grouping facility-alarm-grouping {

    // facility-alarm outlet-temperature major
    container major {
      tailf:info "Major warning threshold";
      leaf temperature {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<20-100>;;<##> threshold temperature (degrees C)";
          range "20..100";
        }
      }
    }

    // facility-alarm outlet-temperature minor
    container minor {
      tailf:info "Minor warning threshold";
      leaf temperature {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<20-100>;;<##> threshold temperature (degrees C)";
          range "20..100";
        }
      }
    }

    // facility-alarm outlet-temperature critical
    container critical {
      tailf:info "Critical warning threshold";

      // facility-alarm outlet-temperature critical exceed-action shutdown
      leaf exceed-action {
        tailf:info "Critical outlet temperature exceed action";
        tailf:cli-full-command;
        type enumeration {
          enum shutdown {
            tailf:info "Auto-shutdown when critical outlet temperature is exceeded";
          }
        }
      }

      // facility-alarm outlet-temperature critical
      leaf temperature {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<1-255>;;<##> threshold temperature (degrees C)";
          range "1..255";
        }
      }
    }
  }

  // process cpu threshold type total
  // process cpu threshold type interrupt
  // process cpu threshold type process
  grouping process-cpu-threshold-grouping {
    leaf rising {
      tailf:info "rising threshold";
      tailf:cli-incomplete-command;
      type uint8 {
        tailf:info "<1-100>";
        range "1..100";
      }
    }
    leaf interval {
      tailf:info "observation interval";
      type uint32 {
        tailf:info "<5-86400>";
        range "5..86400";
      }
    }
    leaf falling {
      tailf:info "falling threshold ";
      type uint8 {
        tailf:info "<1-100>";
        range "1..100";
      }
    }
    container falling-interval {
      tailf:cli-flatten-container;
      tailf:cli-drop-node-name;
      leaf interval {
        tailf:info "observation interval";
        type uint32 {
          tailf:info "<5-86400>";
          range "5..86400";
        }
      }
    }
  }

  grouping logging-host-grouping {

    // logging host * discriminator
    leaf discriminator {
      tailf:info "Specify a message discriminator identifier for this logging session";
      type string {
        tailf:info "WORD;;Message discriminator identifier for this logging session (8 chars. max)";
      }
    }

    // logging host * session-id
    container session-id {
      tailf:info "Specify syslog message session ID tagging";
      tailf:cli-flatten-container;
      choice session-id-choice {
        leaf hostname {
          tailf:info "Include hostname in session ID tag";
          type empty;
        }
        leaf ipv4 {
          tailf:info "Include logging source IP address in session ID tag";
          type empty;
        }
        leaf ipv6 {
          tailf:info "Include logging source IPV6 address in session ID tag";
          type empty;
        }
        leaf string {
          tailf:info "Include custom string in session ID tag";
          type string {
            tailf:info "WORD;;Custom string in [s_id=\"custom_string\"] tag";
          }
        }
      }
    }

    // logging host * transport
    leaf transport {
      tailf:info "Specify the transport protocol (default=UDP)";
      type enumeration {
        enum beep {
          tailf:info "Blocks Extensible Exchange Protocol";
        }
        enum tcp {
          tailf:info "Transport Control Protocol";
        }
        enum udp {
          tailf:info "User Datagram Protocol";
        }
      }
      default udp;
    }

    // logging host * port
    leaf port {
      tailf:info "Specify the transport port number";
      when "../transport" {
        tailf:dependency "../transport";
      }
      type uint16 {
        tailf:info "<1-65535>;;Port number";
        range "1..65535";
      }
      default 514;
    }
  }

  grouping logging-discriminator-pattern-grouping {
    choice pattern-choice {
      leaf drops {
        tailf:info "To drop messages including the specified regexp string";
        type string {
          tailf:info "WORD;;Specify a regular expression string for message filtering";
        }
      }
      leaf includes {
        tailf:info "To deliver messages including the specified regexp string";
        type string {
          tailf:info "WORD;;Specify a regular expression string for message filtering";
        }
      }
    }
  }

  grouping crypto-ikev2-profile-aaa-authorization-group-list {

    container list {
      tailf:info "AAA method list";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf list-name {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "WORD;;AAA list name";
        }
      }
      leaf aaa-username {
        tailf:cli-break-sequence-commands;
        tailf:cli-drop-node-name;
        tailf:cli-disallow-value "name-mangler|password";
        type string {
          tailf:info "WORD;;AAA username";
        }
      }
      leaf name-mangler {
        tailf:info "Specify the name-mangler to derive AAA username";
        tailf:non-strict-leafref {
          path "../../../../../../../../ikev2/name-mangler/name";
        }
        type string {
          tailf:info "WORD;;mangler name";
        }
      }
      container password {
        tailf:info "Specify the AAA password";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        uses crypto-key-grouping {
          refine "secret" {
            cli:secret " password <SECRET>";
          }
        }
      }
    }
  }

  // parameter-map type inspect * / aggressive-aging
  // parameter-map type inspect * / max-incomplete ? aggressive-aging
  // parameter-map type inspect * / per-box aggressive-aging
  grouping parameter-map-aggressive-aging-grouping {
    container aggressive-aging {
      tailf:info "Aggressive Aging parameters";
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      container high {
        tailf:info "Specify the high watermark for aggressive-aging";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        choice high-choice {
          leaf value {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<1-4294967295>;;High watermark in absolute values";
              range "1..4294967295";
            }
          }
          leaf percent {
            tailf:info "high watermark in percentage of max-incomplete value";
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<1-100>;;High watermark in percentage";
              range "1..100";
            }
          }
        }
      }
      container low {
        tailf:info "Specify the low watermark for aggressive-aging";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        choice low-choice {
          leaf value {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-4294967295>;;Low watermark in absolute values";
              range "1..4294967295";
            }
          }
          leaf percent {
            tailf:info "low watermark in percentage of max-incomplete value";
            type uint8 {
              tailf:info "<1-100>;;Low watermark in percentage";
              range "1..100";
            }
          }
        }
      }
    }
  }

  // parameter-map type inspect * / max-incomplete
  // parameter-map type inspect * / per-box max-incomplete
  grouping parameter-map-max-incomplete-grouping {

    // parameter-map type inspect * / max-incomplete ?
    container half-open-sessions {
      tailf:cli-drop-node-name;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf number {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<1-4294967295>;;half-open sessions";
          range "1..4294967295";

        }
      }
      uses parameter-map-aggressive-aging-grouping;
    }

    // parameter-map type inspect * / max-incomplete tcp
    leaf tcp {
      tailf:info "Specify max half-open TCP connections";
      type uint32 {
        tailf:info "<1-4294967295>;;half-open sessions";
        range "1..4294967295";
      }
    }

    // parameter-map type inspect * / max-incomplete udp
    leaf udp {
      tailf:info "Specify max half-open UDP connections";
      type uint32 {
        tailf:info "<1-4294967295>;;half-open sessions";
        range "1..4294967295";
      }
    }

    // parameter-map type inspect * / max-incomplete icmp
    leaf icmp {
      tailf:info "Specify max half-open ICMP connections";
      type uint32 {
        tailf:info "<1-4294967295>;;half-open sessions";
        range "1..4294967295";
      }
    }
  }

  // parameter-map type inspect * /
  // parameter-map type inspect-global /
  grouping parameter-map-grouping {

    // parameter-map type inspect * / alert
    leaf alert {
      tailf:info "Turn on/off alert";
      type enumeration {
        enum off {
          tailf:info "Turn off alert";
        }
        enum on {
          tailf:info "Turn on alert";
        }
      }
    }

    // parameter-map type inspect * / audit-trail
    leaf audit-trail {
      tailf:info "Turn on/off audit trail";
      type enumeration {
        enum off {
          tailf:info "Turn off audit trail";
        }
        enum on {
          tailf:info "Turn on audit trail";
        }
      }
    }

    // parameter-map type inspect * / dns-timeout
    leaf dns-timeout {
      tailf:info "Specify timeout for DNS";
      type uint32 {
        tailf:info "<1-2147483>;;Timeout in seconds";
        range "1..2147483";
      }
    }

    // parameter-map type inspect * / icmp
    container icmp {
      tailf:info "Config timeout values for icmp";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf idle-time {
        tailf:info "Specify timeout for icmp";
        type uint32 {
          tailf:info "<1-2147483>;;Timeout in seconds";
          range "1..2147483";
        }
      }
      leaf ageout-time {
        tailf:info "Specify aggressive age-out time for icmp";
        type uint32 {
          tailf:info "<1-2147483>;;Timeout in seconds";
          range "1..2147483";
        }
      }
    }

    // parameter-map type inspect * / max-destination
    leaf max-destination {
      tailf:info "config maximum destination";
      type uint32 {
        tailf:info "<1-4294967295>;;maximum destination value";
        range "1..4294967295";
      }
    }

    // parameter-map type inspect * / one-minute
    container one-minute {
      tailf:info "Specify one-minute-sample watermarks for clamping";
      leaf high {
        tailf:info "Specify high-watermark for clamping";
        type uint32 {
          tailf:info "<1-2147483647>;;Number of connections";
          range "1..2147483647";
        }
      }
      leaf low {
        tailf:info "Specify low-watermark for clamping";
        type uint32 {
          tailf:info "<1-2147483647>;;Number of connections";
          range "1..2147483647";
        }
      }
    }

    // parameter-map type inspect * / session
    container session {
      tailf:info "Configure session total";

      // parameter-map type inspect * / session packet
      leaf packet {
        tailf:info "Simultaneous packets per session";
        type uint16 {
          tailf:info "<25-100>;;Number of simultaneous packets ";
          range "25..100";
        }
      }

      // parameter-map type inspect * / session total
      container total {
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf number {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-4294967295>;;session total number";
            range "1..4294967295";
          }
        }
        container aggressive-aging {
          tailf:info "Aggressive Aging parameters";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf high {
            tailf:info "Specify the high watermark for aggressive-aging";
            type uint32 {
              tailf:info "<1-4294967295>;;High watermark in absolute values";
              range "1..4294967295";
            }
          }
          leaf low {
            tailf:info "Specify the low watermark for aggressive-aging";
            type uint32 {
              tailf:info "<1-4294967295>;;Low watermark in absolute values";
              range "1..4294967295";
            }
          }
        }
      }
    }

    // parameter-map type inspect * / sessions maximum
    container sessions {
      tailf:info "Maximum number of inspect sessions";
      leaf maximum {
        tailf:info "Maximum sessions";
        type uint32 {
          tailf:info "<1-2147483647>;;Number of sessions";
          range "1..2147483647";
        }
      }
    }

    // parameter-map type inspect * / log
    container log {
      tailf:info "Inspect packet logging";

      // parameter-map type inspect * / log flow-export
      container flow-export {
        tailf:info "Configure inspect external logging parameters";

        // parameter-map type inspect * / log flow-export v9 udp destination
        container v9 {
          tailf:info "Netflow version 9";
          container udp {
            tailf:info "Use UDP to export records";
            container destination {
              tailf:info "Specify the flow-export destination";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf address {
                tailf:cli-drop-node-name;
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Destination IP address";
                }
              }
              leaf port {
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<1-65535>;;Destination port number";
                }
              }
            }
          }
        }

        // parameter-map type inspect * / log flow-export template timeout-rate
        container template {
          tailf:info "Configure record template parameters";
          leaf timeout-rate {
            tailf:info "Rate to resend the template in seconds";
            type uint16 {
              tailf:info "<0-65535>;;Rate to resend in seconds";
            }
          }
        }
      }

      // parameter-map type inspect * / log dropped-packets
      leaf dropped-packets {
        tailf:info "log packets dropped by the firewall";
        type empty;
      }
    }

    // parameter-map type inspect * / lisp inner-packet-inspection
    container lisp {
      tailf:info "Turn on LISP options";
      leaf inner-packet-inspection {
        tailf:info "LISP inner packet inspection";
        type empty;
      }
    }

    // parameter-map type inspect * / multi-tenancy
    leaf multi-tenancy {
      tailf:info "Enable multi-tenancy";
      type empty;
    }

    // parameter-map type inspect * / icmp-unreachable-allow
    leaf icmp-unreachable-allow {
      tailf:info "ICMP unreachable packets are allowed";
      type empty;
    }

    // parameter-map type inspect * / tcp
    container tcp {
      tailf:info "Config timeout values for tcp connections";

      // parameter-map type inspect * / tcp finwait-time
      container finwait-time {
        tailf:info "Specify timeout for TCP connections after a FIN";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf seconds {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-2147483>;;Timeout in seconds";
            range "1..2147483";
          }
        }
        leaf ageout-time {
          tailf:info "Specify aggressive age-out time for fin wait=time";
          type uint32 {
            tailf:info "<1-2147483>;;Timeout in seconds";
          }
        }
      }

      // parameter-map type inspect * / tcp idle-time
      container idle-time {
        tailf:info "Specify idle timeout for tcp connections";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf seconds {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-2147483>;;Timeout in seconds";
            range "1..2147483";
          }
        }
        leaf ageout-time {
          tailf:info "Specify aggressive age-out time for tcp";
          type uint32 {
            tailf:info "<1-2147483>;;Timeout in seconds";
            range "1..2147483";
          }
        }
      }

      // parameter-map type inspect * / tcp max-incomplete
      container max-incomplete {
        tailf:info "Specify max half-open connection per host";
        leaf host {
          tailf:info "Specify max half-open connection per host";
          type uint32 {
            tailf:info "<1-4294967295>;;half-open sessions";
            range "1..4294967295";
          }
        }
      }

      // parameter-map type inspect * / tcp synwait-time
      container synwait-time {
        tailf:info "Specify timeout for TCP connections after a SYN and no";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf seconds {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-2147483>;;Timeout in seconds";
            range "1..2147483";
          }
        }
        leaf ageout-time {
          tailf:info "Specify aggressive age-out time syn wait-time";
          type uint32 {
            tailf:info "<1-2147483>;;Timeout in seconds";
            range "1..2147483";
          }
        }
      }

      // parameter-map type inspect * / tcp syn-flood
      container syn-flood {
        tailf:info "syn-flood config";

        // parameter-map type inspect * / tcp syn-flood limit
        leaf limit {
          tailf:info "syn-flood limit";
          type uint32 {
            tailf:info "<1-4294967295>;;number of half-open connections that triggers SYN cookie";
            range "1..4294967295";
          }
        }

        // parameter-map type inspect * / tcp syn-flood rate per-destination
        container rate {
          tailf:info "maximum syn packet rate";
          leaf per-destination {
            tailf:info "per destination";
            type uint32 {
              tailf:info "<1-1000000000>;;maximum rate of TCP SYN packets";
              range "1..1000000000";
            }
          }
        }
      }

      // parameter-map type inspect * / tcp window-scale-enforcement
      container window-scale-enforcement {
        tailf:info "Specify tcp window scaling enforcement";
        leaf loose {
          tailf:info "Loose enforcement";
          type empty;
        }
      }
    }

    // parameter-map type inspect * / udp
    container udp {
      tailf:info "Config timeout values for udp flows";

      // parameter-map type inspect * / udp idle-time
      container idle-time {
        tailf:info "Specify idle timeout for udp";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf seconds {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-2147483>;;Timeout in seconds";
            range "1..2147483";
          }
        }
        leaf ageout-time {
          tailf:info "Specify aggressive age-out time for udp";
          type uint32 {
            tailf:info "<1-2147483>;;Timeout in seconds";
            range "1..2147483";
          }
        }
      }

      // parameter-map type inspect * / udp half-open
      container half-open {
        tailf:info "Config timeout values for udp half open flow";
        container idle-time {
          tailf:info "Specify idle timeout for udp half open";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf seconds {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-2147483>;;Timeout in miliseconds";
              range "1..2147483";
            }
          }
          leaf ageout-time {
            tailf:info "Specify aggressive age-out time for udp half open";
            type uint32 {
              tailf:info "<1-2147483>;;Timeout in miliseconds";
              range "1..2147483";
            }
          }
        }
      }
    }

    // parameter-map type inspect * / application-inspect no-list *
    container application-inspect {
      tailf:info "Turn off application inspection";
      list no-list {
        tailf:info "'no application-inspect <name>' entry";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type enumeration {
            enum all {
              tailf:info "all supported L7 protocols";
            }
            enum dns {
              tailf:info "Domain Name Server";
            }
            enum exec {
              tailf:info "Remote Process Execution";
            }
            enum ftp {
              tailf:info "File Transfer Protocol";
            }
            enum gtp {
              tailf:info "GPRS Tunneling Protocol";
            }
            enum h323 {
              tailf:info "H.323 Protocol (e.g, MS NetMeeting)";
            }
            enum http {
              tailf:info "Hypertext Transfer Protocol";
            }
            enum imap {
              tailf:info "Internet Message Access Protocol";
            }
            enum login {
              tailf:info "Remote login";
            }
            enum msrpc {
              tailf:info "Microsoft Remote Procedure Call";
            }
            enum netbios {
              tailf:info "NETBIOS";
            }
            enum pop3 {
              tailf:info "Post Office Protocol - Version 3";
            }
            enum rtsp {
              tailf:info "Real Time Streaming Protocol";
            }
            enum shell {
              tailf:info "shell";
            }
            enum sip {
              tailf:info "Session Initiation Protocol";
            }
            enum skinny {
              tailf:info "Skinny Client Control Protocol";
            }
            enum smtp {
              tailf:info "Simple Mail Transfer Protocol";
            }
            enum sunrpc {
              tailf:info "SUN Remote Procedure Call";
            }
            enum tftp {
              tailf:info "Trivial File Transfer Protocol";
            }
          }
        }
      }
    }

    // parameter-map type inspect * / max-incomplete
    container max-incomplete {
      tailf:info "Specify maximum number of incomplete connections before clamping";

      // parameter-map type inspect * / max-incomplete high
      leaf high {
        tailf:info "Specify high-watermark for clamping";
        tailf:cli-full-command;
        type uint32 {
          tailf:info "<1-2147483647>;;Number of connections";
          range "1..2147483647";
        }
      }

      // parameter-map type inspect * / max-incomplete low
      leaf low {
        tailf:info "Specify low-watermark for clamping";
        tailf:cli-full-command;
        type uint32 {      // parameter-map type inspect * / max-incomplete high
          tailf:info "<1-2147483647>;;Number of connections";
          range "1..2147483647";
        }
      }

      // parameter-map type inspect * / max-incomplete ?
      // parameter-map type inspect * / max-incomplete tcp
      // parameter-map type inspect * / max-incomplete udp
      // parameter-map type inspect * / max-incomplete icmp
      uses parameter-map-max-incomplete-grouping;
    }

    // parameter-map type inspect * / aggressive-aging
    uses parameter-map-aggressive-aging-grouping;

    // parameter-map type inspect * / inspect
    container inspect {
      tailf:info "vrf binding with parameter map";

      // parameter-map type inspect * / inspect ?
      leaf name {
        tailf:cli-drop-node-name;
        tailf:cli-disallow-value "vrf";
        tailf:cli-full-command;
        tailf:non-strict-leafref {
          path "/ios:parameter-map/type/inspect-vrf/name";
        }
        type string {
          tailf:info "WORD;;parameter-map name";
        }
      }

      // parameter-map type inspect * / inspect vrf *
      list vrf {
        tailf:info "vrf binding with parameter map";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          tailf:cli-diff-dependency "../../../../../../ip/vrf";
          tailf:cli-diff-dependency "../../../../../../vrf/definition";
          type string {
            tailf:info "WORD;;vrf name";
          }
        }
        leaf name {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;parameter-map name";
          }
        }
      }
    }

    // parameter-map type inspect * / threat-detection
    container threat-detection {
      tailf:info "Configure Threat Detection";

      // parameter-map type inspect * / threat-detection basic-threat
      leaf basic-threat {
        tailf:info "Enable Threat Detection";
        tailf:cli-full-command;
        type empty;
      }

      // parameter-map type inspect * / threat-detection rate
      container rate {
        tailf:info "Configure Threat Detection rate";

        // parameter-map type inspect * / threat-detection rate syn-attack
        container syn-attack {
          tailf:info "Configure Threat Detection rate for syn attack events";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf average-time-frame {
            tailf:info "Configure Threat Detection average time frame";
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<600-3600>;;average time frame in seconds";
              range "6..3600";
            }
          }
          leaf average-threshold {
            tailf:info "Configure Threat Detection average threshold";
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<1-4294967295>;;average threshold in pkts/sec";
              range "1..4294967295";
            }
          }
          leaf burst-threshold {
            tailf:info "Configure Threat Detection burst threshold";
            type uint32 {
              tailf:info "<1-1000000000>;;burst threshold in pkts/sec";
              range "1..1000000000";
            }
          }
        }

        // parameter-map type inspect * / threat-detection rate inspect-drop
        container inspect-drop {
          tailf:info "Configure Threat Detection rate for firewall inspection based drop events";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf average-time-frame {
            tailf:info "Configure Threat Detection average time frame";
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<600-3600>;;average time frame in seconds";
              range "6..3600";
            }
          }
          leaf average-threshold {
            tailf:info "Configure Threat Detection average threshold";
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<1-4294967295>;;average threshold in pkts/sec";
              range "1..4294967295";
            }
          }
          leaf burst-threshold {
            tailf:info "Configure Threat Detection burst threshold";
            type uint32 {
              tailf:info "<1-1000000000>;;burst threshold in pkts/sec";
              range "1..1000000000";
            }
          }
        }

        // parameter-map type inspect * / threat-detection rate fw-drop
        container fw-drop {
          tailf:info "Configure Threat Detection rate for firewall drop events";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf average-time-frame {
            tailf:info "Configure Threat Detection average time frame";
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<600-3600>;;average time frame in seconds";
              range "6..3600";
            }
          }
          leaf average-threshold {
            tailf:info "Configure Threat Detection average threshold";
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<1-4294967295>;;average threshold in pkts/sec";
              range "1..4294967295";
            }
          }
          leaf burst-threshold {
            tailf:info "Configure Threat Detection burst threshold";
            type uint32 {
              tailf:info "<1-1000000000>;;burst threshold in pkts/sec";
              range "1..1000000000";
            }
          }
        }
      }
    }

    // parameter-map type inspect * / per-box
    container per-box {
      tailf:info "Configure per-box attributes";

      // parameter-map type inspect * / per-box tcp syn-flood limit
      container tcp {
        tailf:info "Configure tcp syn-flood limit";
        container syn-flood {
          tailf:info "syn-flood limit";
          leaf limit {
            tailf:info "syn-flood limit";
            type uint32 {
              tailf:info "<1-4294967295>;;number of half-open connections that triggers SYN cookie";
            }
          }
        }
      }

      // parameter-map type inspect * / per-box aggressive-aging
      uses parameter-map-aggressive-aging-grouping;

      // parameter-map type inspect * / per-box max-incomplete
      container max-incomplete {
        tailf:info "Specify maximum number of incomplete connections before clamping";
        uses parameter-map-max-incomplete-grouping;
      }
    }

    // parameter-map type inspect * / vrf * inspect
    list vrf {
      tailf:info "vrf binding with parameter map";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      key vrf;
      leaf vrf {
        tailf:cli-diff-dependency "../../../../../ip/vrf";
        tailf:cli-diff-dependency "../../../../../vrf/definition";
        type string {
          tailf:info "WORD;;vrf name";
        }
      }
      leaf inspect {
        tailf:info "vrf binding with parameter map";
        tailf:non-strict-leafref {
          path "../../../inspect-vrf/name";
        }
        type string {
          tailf:info "WORD;;parameter-map name";
        }
      }
    }

    // parameter-map type inspect * / zone-mismatch drop
    container zone-mismatch {
      tailf:info "Configure zone-mismatch option";
      leaf drop {
        tailf:info "Drop packets mode";
        type empty;
      }
    }
  }


  // mls qos map cos-dscp
  grouping cos-value-0-7-grouping {
    leaf cos-value0 {
      tailf:cli-drop-node-name;
      tailf:cli-no-value-on-delete;
      type uint8 {
        tailf:info "<0-63>;;CoS values separated by spaces (up to 8 values total)";
        range "0..63";
      }
    }
    leaf cos-value1 {
      tailf:cli-drop-node-name;
      tailf:cli-no-value-on-delete;
      type uint8 {
        tailf:info "<0-63>;;CoS values separated by spaces (up to 8 values total)";
        range "0..63";
      }
    }
    leaf cos-value2 {
      tailf:cli-drop-node-name;
      tailf:cli-no-value-on-delete;
      type uint8 {
        tailf:info "<0-63>;;CoS values separated by spaces (up to 8 values total)";
        range "0..63";
      }
    }
    leaf cos-value3 {
      tailf:cli-drop-node-name;
      tailf:cli-no-value-on-delete;
      type uint8 {
        tailf:info "<0-63>;;CoS values separated by spaces (up to 8 values total)";
        range "0..63";
      }
    }
    leaf cos-value4 {
      tailf:cli-drop-node-name;
      tailf:cli-no-value-on-delete;
      type uint8 {
        tailf:info "<0-63>;;CoS values separated by spaces (up to 8 values total)";
        range "0..63";
      }
    }
    leaf cos-value5 {
      tailf:cli-drop-node-name;
      tailf:cli-no-value-on-delete;
      type uint8 {
        tailf:info "<0-63>;;CoS values separated by spaces (up to 8 values total)";
        range "0..63";
      }
    }
    leaf cos-value6 {
      tailf:cli-drop-node-name;
      tailf:cli-no-value-on-delete;
      type uint8 {
        tailf:info "<0-63>;;CoS values separated by spaces (up to 8 values total)";
        range "0..63";
      }
    }
    leaf cos-value7 {
      tailf:cli-drop-node-name;
      tailf:cli-no-value-on-delete;
      type uint8 {
        tailf:info "<0-63>;;CoS values separated by spaces (up to 8 values total)";
        range "0..63";
      }
    }
  }


  // controller Modular-Cable * / rf-channel *
  grouping controller-modular-cable-rf-channel-grouping {

    // controller Modular-Cable * / rf-channel *
    list rf-channel {
      tailf:info "RF channel configuration";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key rf-port;
      leaf rf-port {
        type uint8 {
          tailf:info "<0-23>;;RF channel number";
          range "0..23";
        }
      }

      // controller Modular-Cable * / rf-channel * description
      leaf description {
        tailf:info "configure RF channel name/description";
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE;;Description of this RF channel that will be truncated to 80 characters";
        }
      }

      // controller Modular-Cable * / rf-channel * cable downstream
      container cable {
        tailf:info "configure RF channel cable downstream channel-id";
        container downstream {
          tailf:info "configure RF channel cable downstream channel-id";
          leaf channel-id {
            tailf:info "configure RF channel cable downstream channel-id";
            type uint8 {
              tailf:info "<1-255>;;RF channel cable downstream channel-id";
              range "1..255";
            }
          }
        }
      }

      // controller Modular-Cable * / rf-channel * frequency
      container frequency {
        tailf:info "configure RF channel frequency in Hz";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf freq {
          tailf:cli-drop-node-name;
          type union {
            type uint32 {
              tailf:info "<55000000-1050000000>;;Frequency in Hz";
              range "55000000..1050000000";
            }
            type enumeration {
              enum none {
                tailf:info "No Frequency configured";
              }
            }
          }
        }
        leaf annex {
          tailf:info "ITU-T J.83 MPEG standard";
          tailf:cli-incomplete-command;
          type enumeration {
            enum "A" {
              tailf:info "Annex A, European Standard";
            }
            enum "B" {
              tailf:info "Annex B, North American Standard";
            }
          }
        }
        leaf modulation {
          tailf:info "configure RF channel modulation type";
          type enumeration {
            enum "256qam" {
              tailf:info "256-QAM modulation";
            }
            enum "64qam" {
              tailf:info "64-QAM modulation";
            }
          }
        }
        leaf interleave {
          tailf:info "Interleave depth";
          type enumeration {
            enum 128 {
              tailf:info "R/S Interleave I=128, J=1";
            }
            enum 16 {
              tailf:info "R/S Interleave I=16, J=8";
            }
            enum 32 {
              tailf:info "R/S Interleave I=32, J=4";
            }
            enum 64 {
              tailf:info "R/S Interleave I=64, J=2";
            }
            enum 8 {
              tailf:info "R/S Interleave I=8, J=16";
            }
            enum 12 {
              tailf:info "R/S Interleave I=12, J=17";
            }
          }
        }
      }

      // controller Modular-Cable * / rf-channel * network-delay auto


      // controller Modular-Cable * / rf-channel * ip-address
      container ip-address {
        tailf:info "configure IP address of edge QAM";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf ip-address {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP address of edge QAM";
          }
        }
        leaf mac-address {
          tailf:info "MAC address of edge QAM";
          tailf:cli-incomplete-command;
          type string {
            tailf:info "H.H.H;;MAC address of edge QAM";
          }
        }
        leaf depi-remote-id {
          tailf:info "configure DEPI session ID for edge QAM";
          type uint32 {
            tailf:info "<1-4294967295>;;DEPI remote ID";
            range "1..4294967295";
          }
        }
        leaf eqam-headroom {
          tailf:info "Headroom for Edge QAM channel";
          type uint8 {
            tailf:info "<0-28>;;EdgeQAM Headroom";
            range "0..28";
          }
        }
      }

      // controller Modular-Cable * / rf-channel * network-delay
      container network-delay {
        tailf:info "Delay through Converged Interconnect Network (CIN) to EQAM";
        choice network-delay-choice {
          leaf usec {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<0-3000>;;CIN delay in usec";
              range "0..3000";
            }
          }
          // controller Modular-Cable * / rf-channel * network-delay
          container auto {
            tailf:info "CIN Delay via DLM Measurements";
            tailf:cli-delete-when-empty;
            presence true;
            leaf sampling-rate {
              tailf:info "Sampling Rate for DLM Request";
              type uint16 {
                tailf:info "<1-500>;;DLM Sampling Rate in sec";
                range "1..500";
              }
            }
          }
        }
      }

      // controller Modular-Cable * / rf-channel * depi-tunnel
      container depi-tunnel {
        tailf:info "DEPI Data Session Configuration";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf depi-tunnel-name {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type string {
            tailf:info "WORD;;depi-tunnel name";
          }
        }
        leaf tsid {
          tailf:info "tsid ";
          type uint16 {
            tailf:info "<0-65535>;;tsid value";
          }
        }
      }

      // controller Modular-Cable * / rf-channel * rf-power
      leaf rf-power {
        tailf:info "Set RF Power";
        type string {
          tailf:info "<1-100>;;dBmV (The format is XY.Z; by default, .Z is .0)";
        }
      }

      // controller Modular-Cable * / no rf-channel * rf-shutdown
      leaf rf-shutdown {
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }
    }
  }

  // controller Integrated-Cable * / rf-chan *
  grouping controller-integrated-cable-rf-chan-grouping {

    // controller Integrated-Cable * / rf-chan * / shutdown
    leaf shutdown {
      tailf:info "Shutdown RF Channel";
      type empty;
    }

    // controller Integrated-Cable * / rf-chan * / type
    container type {
      tailf:info "QAM Data Type";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf value {
        tailf:cli-drop-node-name;
        type enumeration {
          enum DOCSIS {
            tailf:info "DOCSIS";
          }
          enum VIDEO {
            tailf:info "VIDEO";
          }
        }
      }
      leaf mode {
        tailf:cli-drop-node-name;
        when "../value = 'VIDEO'" {
          tailf:dependency "../value";
        }
        type enumeration {
          enum ASYNC {
            tailf:info "Asynchronous Mode on R-PHY System for MPEG-TS Video";
          }
          enum SYNC {
            tailf:info "Synchronous Mode on R-PHY System for MPEG-TS Video";
          }
        }
      }
    }

    // controller Integrated-Cable * / rf-chan * / frequency
    leaf frequency {
      tailf:info "RF Channel Frequency";
      type uint32 {
        tailf:info "<93000000-861000000>;;frequency";
        range "93000000..861000000";
      }
    }

    // controller Integrated-Cable * / rf-chan * / rf-output
    leaf rf-output {
      tailf:info "QAM Output Mode";
      type enumeration {
        enum ALT {
          tailf:info "ALT";
        }
        enum CW {
          tailf:info "CW";
        }
        enum NORMAL {
          tailf:info "NORMAL";
        }
        enum PRBS {
          tailf:info "PRBS";
        }
      }
    }

    // controller Integrated-Cable * / rf-chan * / power-adjust
    leaf power-adjust {
      tailf:info "Channel Power Adjust";
      type string {
        tailf:info "WORD;;Power Adjust Range:  -8.0 -  0.0 dBmV";
      }
    }

    // controller Integrated-Cable * / rf-chan * / qam-profile
    leaf qam-profile {
      tailf:info "QAM Profile Number";
      type uint8 {
        tailf:info "<0-31>;;qam profile number";
        range "0..31";
      }
    }

    // controller Integrated-Cable * / rf-chan * / docsis-channel-id
    leaf docsis-channel-id {
      tailf:info "Docsis Channel Id";
      type uint8 {
        tailf:info "<1-255>;;dcid";
        range "1..255";
      }
    }

    // controller Integrated-Cable * / rf-chan * / ofdm channel-profile
    container ofdm {
      tailf:info "OFDM channel parameters";
      container channel-profile {
        tailf:info "OFDM channel profile";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf id {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<0-255>;;OFDM channel profile id";
          }
        }
        leaf start-frequency {
          tailf:info "Frequency in Hz of the left edge of the spectrum allocated to the channel";
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<108000000-1218000000>;;Frequency in Hz of the left edge of the spectrum allocated to the channel";
          }
        }
        leaf width {
          tailf:info "width in Hz of the spectrum allocated to the channel";
          type uint32 {
            tailf:info "<24000000-192000000>;;width in Hz of the spectrum allocated to the channel";
          }
        }
        leaf plc {
          tailf:info "Specifiy plc spectrum start frequency";
          type uint32 {
            tailf:info "<108000000-1218000000>;;plc spectrum start frequency";
          }
        }
      }
    }
  }

  // cable video / logical-edge-device * / protocol gqi
  // cable video / logical-edge-device * / protocol table-based
  grouping cable-video-logical-edge-device-protocol-grouping {

    // cable video / logical-edge-device * / protocol gqi / mgmt-ip
    leaf mgmt-ip {
      tailf:info "Local management IP";
      tailf:cli-remove-before-change;
      tailf:cli-diff-dependency "/ios:cable/video/mgmt-intf/VirtualPortGroup";
      type inet:ipv4-address {
        tailf:info "A.B.C.D;;IP address";
      }
    }

    // cable video / logical-edge-device * / protocol gqi / mac-address
    leaf mac-address {
      tailf:info "MAC Address to represent the LED";
      type string {
        tailf:info "H.H.H;;MAC address";
      }
    }

    // cable video / logical-edge-device * / protocol gqi / server *
    list server {
      tailf:info "Up to 3 server IP addresses";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-show-long-obu-diffs;
      ordered-by user;
      max-elements 3;
      key address;
      leaf address {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;IP address";
        }
      }
    }

    // cable video / logical-edge-device * / protocol gqi / keepalive
    container keepalive {
      tailf:info "Keepalive setting for GQI connection";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf retry {
        tailf:info "Number of retries. Default is 3 times";
        tailf:cli-incomplete-command;
        type uint8 {
          tailf:info "<0-10>;;number of retries";
          range "0..10";
        }
      }
      leaf interval {
        tailf:info "interval number. Default is 5 seconds";
        type uint8 {
          tailf:info "<1-45>;;interval of retries in seconds";
          range "1..45";
        }
      }
    }

    // cable video / logical-edge-device * / protocol gqi / reset
    container reset {
      tailf:info "reset indication send configuration.";

      // cable video / logical-edge-device * / protocol gqi / reset interval
      leaf interval {
        tailf:info "reset interval setting. Default is 5 seconds.";
        type uint16 {
          tailf:info "<1-300>;;interval of retries in seconds";
          range "1..300";
        }
        default 5;
      }

      // cable video / logical-edge-device * / protocol gqi / reset on-active
      leaf on-active {
        tailf:info "Send resetIndication when LED configuring active";
        type empty;
      }
    }

    // cable video / logical-edge-device * / protocol gqi / event-profile
    leaf event-profile {
      tailf:info "Announce Event profile to be applied to the LED";
      tailf:non-strict-leafref {
        path "../../../../announce-event-profile/name";
      }
      type string {
        tailf:info "WORD;;Announce Event profile name";
      }
    }

    // cable video / logical-edge-device * / protocol gqi / create-session-response-max-delay
    leaf create-session-response-max-delay {
      tailf:info "Delay sending GQI createSession response to ERM";
      type uint16 {
        tailf:info "<500-2000>;;delay in msec";
        range "500..2000";
      }
    }

    // cable video / logical-edge-device * / protocol gqi / udp-port-mapping-method
    leaf udp-port-mapping-method {
      tailf:info "Auto generated UDP port id";
      type enumeration {
        enum 10-6 {
          tailf:info "10 MSB for output port number, and 6 LSB for program number";
        }
      }
    }

    // cable video / logical-edge-device * / protocol gqi / virtual-edge-input-ip *
    list virtual-edge-input-ip {
      tailf:info "Destination IP";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key ip-address;
      leaf ip-address {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;IP address";
        }
      }
      leaf vrf {
        tailf:info "Video Source VRF";
        type string {
          tailf:info "WORD;;Name of the VRF used for video sources";
        }
      }
      leaf input-port-number {
        tailf:info "Input port number";
        tailf:cli-remove-before-change;
        type uint16 {
          tailf:info "<1-65535>;;Input Port Number";
          range "1..65535";
        }
      }
    }

    // cable video / logical-edge-device * / protocol gqi / vcg *
    leaf-list vcg {
      tailf:info "virtual carrier group assigned to this LED";
      tailf:cli-diff-delete-before "../../../../virtual-carrier-group";
      tailf:cli-list-syntax;
      type string {
        tailf:info "WORD;;VCG name";
      }
    }

    // cable video / logical-edge-device * / protocol gqi / discovery-protocol d6
    container discovery-protocol {
      tailf:info "discovery protocol";
      container d6 {
        tailf:info "discovery protocol d6";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-video-led-proto-d6";
        tailf:cli-diff-delete-before "../../mgmt-ip";
        presence true;

        // cable video / logical-edge-device * / protocol gqi / discovery-protocol d6 / mgmt-ip
        leaf mgmt-ip {
          tailf:info "Local management IP";
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP address";
          }
        }

        // cable video / logical-edge-device * / protocol gqi / discovery-protocol d6 / vendor-string
        leaf vendor-string {
          tailf:info "Vendor string to report in D6 Open message";
          type string {
            tailf:info "WORD;;Vendor String to report in Open message, Default is Cisco CBR8k";
          }
        }

        // cable video / logical-edge-device * / protocol gqi / discovery-protocol d6 / streaming-zone
        leaf streaming-zone {
          tailf:info "Streaming Zone of LED";
          type string {
            tailf:info "WORD;;Streaming Zone";
          }
        }

        // cable video / logical-edge-device * / protocol gqi / discovery-protocol d6 / component-name led38002
        leaf component-name {
          tailf:info "Component name of LED";
          type string {
            tailf:info "WORD;;Component name";
          }
        }

        // cable video / logical-edge-device * / protocol gqi / discovery-protocol d6 / d6-server
        container d6-server {
          tailf:info "D6 Server Details";

          // cable video / logical-edge-device * / protocol gqi / discovery-protocol d6 / d6-server fqdn
          container fqdn {
            tailf:info "Fully Qualified Domain Name";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf domain-name {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "WORD;;Domain Name";
              }
            }
            leaf port {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<1024-65535>;;Server Port, default is 6069.";
                range "1024..65535";
              }
            }
          }

          // cable video / logical-edge-device * / protocol gqi / discovery-protocol d6 / d6-server ?
          container address {
            tailf:cli-drop-node-name;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf ip {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IP address";
              }
            }
            leaf port {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<1024-65535>;;Server Port, default is 6069.";
                range "1024..65535";
              }
            }
          }
        }

        // cable video / logical-edge-device * / protocol gqi / discovery-protocol d6 / timeout 10
        leaf timeout {
          tailf:info "Time to wait for connection to server.";
          type uint8 {
            tailf:info "<1-255>;;Timeout in seconds, default is 10.";
            range "1..255";
          }
          tailf:ned-default-handling report-all;
          default 10;
        }

        // cable video / logical-edge-device * / protocol gqi / discovery-protocol d6 / holdtime
        leaf holdtime {
          tailf:info "Time to wait for server response";
          type uint16 {
            tailf:info "<0-300>;;Holdtime in seconds, default is 30.";
            range "0..300";
          }
          tailf:ned-default-handling report-all;
          default 30;
        }

        // cable video / logical-edge-device * / protocol gqi / discovery-protocol d6 / report-output-port-number
        leaf report-output-port-number {
          tailf:info "Send output port number configured for each rf channel instead of vcg id";
          type empty;
        }

        // cable video / logical-edge-device * / protocol gqi / discovery-protocol d6 / input-group led vei-ip *
        container input-group {
          tailf:info "input group configurations for virtual edge inputs";
          list led {
            tailf:info "Logical Edge Device input group configurations";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            tailf:cli-incomplete-command;
            key vei-ip;
            leaf vei-ip {
              tailf:info "Logical Edge Device virtual edge input ip";
              tailf:cli-expose-key-name;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Enter Virtual edge input IP assigned to LED";
              }
            }
            leaf group-name {
              tailf:info "Logical Edge Device virtual edge input group name";
              type string {
                tailf:info "WORD;;input group name";
              }
            }
            leaf bandwidth {
              tailf:info "Logical Edge Device virtual edge input max bandwidth";
              type uint32 {
                tailf:info "<100-100000>;;Bandwidth in mbps, default is 20000 mbps.";
                range "100..100000";
              }
            }
          }
        }

        // cable video / logical-edge-device * / protocol gqi / discovery-protocol d6 / enable
        leaf enable {
          tailf:info "Enable D6 on this Logical Edge Device";
          cli:ned-diff-move-first {
            cli:arguments "when-delete";
          }
          type empty;
        }
      }
    }

    // cable video / logical-edge-device * / protocol gqi / pmv
    leaf pmv {
      tailf:info "Make specifying PMV for table based sessions mandatory";
      type empty;
    }

    // cable video / logical-edge-device * / protocol gqi / active
    leaf active {
      tailf:info "activate the LED";
      cli:ned-diff-move-first {
        cli:arguments "when-delete";
      }
      type empty;
    }
  }


  // cable rpd * / core-interface Te*
  // cable rpd * / core-interface Hu*
  grouping cable-rpd-core-if-grouping {

    // cable rpd * / core-interface Te* / principal
    leaf principal {
      tailf:info "Specify the principal core";
      type empty;
    }

    // cable rpd * / core-interface Te* / rpd-ds 0 downstream* *
    list rpd-ds {
      tailf:info "RPD DS port";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      key "port name id";
      leaf port {
        type uint8 {
          tailf:info "<uint8>;;RPD DS port num";
        }
      }
      leaf name {
        type string {
          tailf:info "WORD;;downstream-cable | downstream-oob-vom | static-pseudowire";
          pattern '(downstream|static-pseudowire).*';
        }
      }
      leaf id {
        type string {
          tailf:info "WORD;;DS controller|port number";
        }
      }
      leaf profile {
        tailf:info "DS controller profile";
        type uint32 {
          tailf:info "<0-4294967295>;;Profile number|id";
        }
      }
    }

    // cable rpd * / core-interface Te* / rpd-us * upstream* *
    list rpd-us {
      tailf:info "RPD US port";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      key "port name id";
      leaf port {
        type uint8 {
          tailf:info "<uint8>;;RPD US port num";
        }
      }
      leaf name {
        type string {
          tailf:info "WORD;;upstream-cable | upstream-oob-varpd | static-pseudowire";
          pattern '(upstream|static-pseudowire).*';
        }
      }
      leaf id {
        type string {
          tailf:info "WORD;;US controller|port number";
        }
      }
      leaf profile {
        tailf:info "US controller profile";
        type uint32 {
          tailf:info "<0-4294967295>;;Profile number|id";
        }
      }
    }

    // cable rpd * / core-interface Te* / network-delay
    container network-delay {
      tailf:info "CIN delay";

      // cable rpd * / core-interface Te* / network-delay dlm
      container dlm {
        tailf:info "DLM measurement";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf seconds {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-420>;;Sampling interval in seconds";
          }
        }
        leaf measure-only {
          tailf:info "Don't update MAP advance";
          type empty;
        }
      }

      // cable rpd * / core-interface Te* / network-delay static
      leaf static {
        tailf:info "Static CIN delay";
        type uint32 {
          tailf:info "<30-100000>;;Static CIN delay in us";
        }
      }
    }

  }

  // interface Cable* / cable map-advance1
  grouping cable-map-advance-grouping {
    container map-advance {
      tailf:info "Set algorithm for the look-ahead time in MAPs";
      choice map-advance-choice {
        // interface Cable* / cable map-advance static
        leaf static {
          type uint16 {
            tailf:info "<100-20000>;;max map advance - usecs";
            range "100..20000";
          }
        }
        // interface Cable* / cable map-advance dynamic
        container dynamic {
          tailf:info "Automatically tune the value to the current propagation delay";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf safety {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<300-1500>;;Safety factor - usecs";
              range "300..1500";
            }
          }
          leaf max-delay {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<100-20000>;;max map advance - usecs";
              range "100..20000";
            }
          }
        }
      }
    }
  }

  grouping object-group-service-protocol-match {
    choice match-choice {
      leaf eq {
        tailf:info "Match only packets on a given port number";
        tailf:cli-prefix-key;
        type empty;
      }
      leaf gt {
        tailf:info "Match only packets with a greater port number";
        tailf:cli-prefix-key;
        type empty;
      }
      leaf lt {
        tailf:info "Match only packets with a lower port number";
        tailf:cli-prefix-key;
        type empty;
      }
    }
  }

  // arp *
  // arp vrf *
  grouping arp-grouping {
    list arp-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      key ip-address;
      leaf ip-address {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;IP address of ARP entry";
        }
      }
      leaf hardware-address {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type string {
          tailf:info "H.H.H;;48-bit hardware address of ARP entry";
          pattern '[0-9a-fA-F]+\.[0-9a-fA-F]+\.[0-9a-fA-F]+';
        }
      }
      leaf type {
        tailf:cli-drop-node-name;
        type enumeration {
          enum ARPA {
            tailf:info "ARP type ARPA";
          }
          enum SAP {
            tailf:info "ARP type SAP (HP's ARP type)";
          }
          enum SMDS {
            tailf:info "ARP type SMDS";
          }
          enum SNAP {
            tailf:info "ARP type SNAP (FDDI and TokenRing)";
          }
          enum SRP-A {
            tailf:info "ARP type SRP (side A)";
          }
          enum SRP-B {
            tailf:info "ARP type SRP (side B)";
          }
        }
      }
      // [interface-type]
      leaf alias {
        tailf:info "Respond to ARP requests for the IP address";
        type empty;
      }
    }
  }

  // interface Dot11Radio * / encryption
  // interface Dot11Radio * / encryption vlan *
  grouping interface-encryption-mode-grouping {

    container mode {
      tailf:info "encryption mode";

      // interface Dot11Radio * / encryption mode ciphers
      // interface Dot11Radio * / encryption vlan * mode ciphers
      container ciphers {
        tailf:info "Optional data ciphers";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        choice suite-choice {
          leaf ckip {
            tailf:info "Cisco Per packet key hashing";
            type empty;
          }
          leaf ckip-cmic {
            tailf:info "Cisco Per packet key hashing and MIC (MMH)";
            type empty;
          }
          leaf cmic {
            tailf:info "Cisco MIC (MMH)";
            type empty;
          }
          case a {
            leaf aes-ccm {
              tailf:info "WPA AES CCMP";
              type empty;
            }
            leaf tkip {
              tailf:info "WPA Temporal Key encryption";
              type empty;
            }
            leaf wep {
              tailf:cli-drop-node-name;
              type enumeration {
                enum wep128 {
                  tailf:info "128 bit key";
                }
                enum wep40 {
                  tailf:info "40 bit key";
                }
              }
            }
          }
        }
      }
    }
  }

  grouping ip-ssh-algorithm-grouping {

    container algorithm {
      tailf:info "Configure different algorithms used in SSH";

      // ip ssh server algorithm mac *
      leaf-list mac {
        tailf:info "MAC algorithms advertised to other party";
        tailf:cli-replace-all;
        tailf:cli-flat-list-syntax;
        ordered-by user;
        type enumeration {
          enum hmac-sha1 {
            tailf:info "HMAC-SHA1 (digest length = key length = 160 bits)";
          }
          enum hmac-sha1-96 {
            tailf:info "HMAC-SHA1-96 (digest length = 96 bits, key length = 160 bits)";
          }
          enum hmac-sha2-256 {
            tailf:info "HMAC-SHA2-256 (digest length = 256 bits, key length = 256 bits)";
          }
          enum hmac-sha2-512 {
            tailf:info "HMAC-SHA2-512 (digest length = 512 bits, key length = 512 bits)";
          }
        }
      }

      // ip ssh server algorithm encryption *
      leaf-list encryption {
        tailf:info "Encrytption algorithms advertised to other party";
        tailf:cli-replace-all;
        tailf:cli-flat-list-syntax;
        ordered-by user;
        type enumeration {
          enum "3des-cbc" {
            tailf:info "Three-key 3DES in CBC mode";
          }
          enum aes128-cbc {
            tailf:info "AES with 128-bit key in CBC mode";
          }
          enum aes128-ctr {
            tailf:info "AES with 128-bit key in CTR mode";
          }
          enum aes192-cbc {
            tailf:info "AES with 192-bit key in CBC mode";
          }
          enum aes192-ctr {
            tailf:info "AES with 192-bit key in CTR mode";
          }
          enum aes256-cbc {
            tailf:info "AES with 256-bit key in CBC mode";
          }
          enum aes256-ctr {
            tailf:info "AES with 256-bit key in CTR mode";
          }
          enum aes256-gcm {
            tailf:info "AES with 256-bit key GCM mode";
          }
        }
      }

      // ip ssh server algorithm authentication *
      leaf-list authentication {
        tailf:info "User authentication methods advertised to client";
        tailf:cli-replace-all;
        tailf:cli-flat-list-syntax;
        ordered-by user;
        type enumeration {
          enum password {
            tailf:info "Password based authentication";
          }
          enum keyboard {
            tailf:info "Keyboard-interactive based authentication";
          }
          enum publickey {
            tailf:info "Publickey based authentication";
          }
        }
      }

      // ip ssh server algorithm kex
      leaf kex {
        tailf:info "KEX algorithms advertised to other party";
        type enumeration {
          enum diffie-hellman-group14-sha1 {
            tailf:info "DH_GRP14_SHA1 diffie-hellman key exchange algorithm";
          }
        }
      }
    }
  }


  // policy-map * / class * / bandwidth remaining percent
  // policy-map * / class * / bandwidth remaining ratio
  grouping bandwidth-remaining-account-grouping {
    container account {
      tailf:info "Overhead Accounting";
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      choice account-choice {
        case dot1q-qing {
          leaf bras-side {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type enumeration {
              enum dot1q {
                tailf:info "dot1Q at BRAS side";
              }
              enum qinq {
                tailf:info "QinQ at BRAS side";
              }
            }
          }
          leaf aal {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type enumeration {
              enum aal3 {
                tailf:info "AAL3 Layer type";
              }
              enum aal5 {
                tailf:info "AAL5 Layer type";
              }
            }
          }
          leaf subscriber-encapsulation {
            tailf:cli-drop-node-name;
            type enumeration {
              enum mux-1483routed {
                tailf:info "Mux 1483 Routed";
              }
              enum mux-dot1q-rbe {
                tailf:info "Mux Bridging and dot1Q encapsulation";
              }
              enum mux-pppoa {
                tailf:info "Mux PPPoA";
              }
              enum mux-rbe {
                tailf:info "Mux Bridging encapsulation";
              }
              enum snap-1483routed {
                tailf:info "Snap 1483 Routed";
              }
              enum snap-dot1q-rbe {
                tailf:info "Snap Bridging and dot1Q encapsulation";
              }
              enum snap-pppoa {
                tailf:info "Snap PPPoA encapsulation";
              }
              enum snap-rbe {
                tailf:info "Snap Bridging encapsulation";
              }
            }
          }
        }
        leaf user-defined {
          tailf:info "Offset Size";
          type int8 {
            tailf:info "<-63 - 63>;;User Defined size";
          }
        }
      }
    }
  }


  grouping result-type-method-grouping {
    leaf authoritative {
      tailf:info "failure type";
      type empty;
    }
    leaf agent-not-found {
      tailf:info "agent not found type";
      type empty;
    }
    leaf none {
      tailf:info "no type";
      type empty;
    }
    leaf success {
      tailf:info "success type";
      type empty;
    }
    leaf method-timeout {
      tailf:info "method_timeout type";
      type empty;
    }
    leaf aaa-timeout {
      tailf:info "aaa timeout type";
      type empty;
    }
  }

  // interface * / vrrp *
  // interface * / vrrp * address-family ipv4 /
  // interface * / vrrp * address-family ipv6 /
  grouping interface-vrrp-grouping {

    // interface * / vrrp * name
    leaf name {
      tailf:info "Register unique name with VRRS";
      type string {
        tailf:info "WORD;;Unique VRRS identifier (max 48 characters)";
        length "1..48";
      }
    }

    // interface * / vrrp * description
    leaf description {
      tailf:info "Group specific description";
      tailf:cli-multi-value;
      tailf:cli-preformatted;
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;Up to 80 characters describing this group";
        length "1..80";
      }
    }

    // interface * / vrrp * vrrs leader
    container vrrs {
      tailf:info "VRRS related commands";
      list leader {
        tailf:info "Name of VRRS Tag for which this group is the leader";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of the VRRS Tag to lead";
          }
        }
      }
    }

    // interface * / vrrp * preempt delay minimum
    container preempt {
      tailf:info "Enable preemption of lower priority Master";
      container delay {
        tailf:info "Wait before preempting";
        leaf minimum {
          tailf:info "Delay at least this long";
          type uint16 {
            tailf:info "<0-3600>;;Seconds to delay";
            range "0..3600";
          }
        }
      }
    }

    // interface * / vrrp *  vrrpv2
    leaf vrrpv2 {
      tailf:info "Set VRRPv2 compatibility mode";
      type empty;
    }

    // interface * / vrrp * priority
    leaf priority {
      tailf:info "Priority of this VRRP group";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<1-254>;;Priority level";
        range "1..254";
      }
    }

    // interface * / vrrp * timers
    container timers {
      tailf:info "Set the VRRP timers";

      // interface * / vrrp * timers advertise
      container advertise {
        tailf:info "Set the Advertisement timer";
        leaf seconds {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-40950>;;Advertisement interval in (milli)seconds";
            range "1..40950";
          }
        }
        leaf msec {
          tailf:info "Specify time in milliseconds";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<50-999>;;Advertisement interval in milliseconds";
            range "50..999";
          }
        }
      }

      // interface * / vrrp * timers learn
      leaf learn {
        tailf:info "Learn timer values from current Master";
        tailf:cli-full-command;
        type empty;
      }
    }

    // interface * / vrrp * track *
    list track {
      tailf:info "Event Tracking";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        type uint16 {
          tailf:info "<1-1000>;;Tracked object";
          range "1..1000";
        }
      }

      // interface Vlan * / vrrp * track * decrement
      leaf decrement {
        tailf:info "Priority decrement";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<1-255>;;Decrement value";
        }
      }
    }

    // interface * / vrrp * shutdown
    leaf shutdown {
      tailf:info "Disable VRRP Configuration";
      tailf:cli-full-command;
      type empty;
    }
  }


  // ip dns view * /
  grouping ip-dns-view-grouping {

    // ip dns view * / domain
    container domain {
      tailf:info "Configure DNS Resolver parameters";

      // ip dns view * / domain name-server
      container name-server {
        tailf:info "Domain server IP address";

        // ip dns view * / domain name-server *
        list vrf-default {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-show-long-obu-diffs;
          ordered-by user;
          key address;
          leaf address {
            type union {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Host IP address";
              }
              type inet:ipv6-address {
                tailf:info "X:X:X:X::X;;Host IPv6 address";
              }
            }
          }
        }

        // ip dns view * / domain name-server vrf *
        list vrf {
          tailf:info "Specify VRF name";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-show-long-obu-diffs;
          ordered-by user;
          key "name address";
          leaf name {
            type string {
              tailf:info "WORD;;VRF name";
            }
          }
          leaf address {
            type union {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Host IP address";
              }
              type inet:ipv6-address {
                tailf:info "X:X:X:X::X;;Host IPv6 address";
              }
            }
          }
        }

        // ip dns view * / domain name-server interface
        container interface {
          tailf:info "Gather dynamically from interface address acquisition";
          uses interface-name-grouping;
        }
      }

      // ip dns view * / domain resolver source-interface
      container resolver {
        tailf:info "Configure DNS resolver";
        container source-interface {
          tailf:info "Specify source address for DNS resolver";
          uses interface-name-grouping;
        }
      }
    }

    // ip dns view * / dns
    container dns {
      tailf:info "Configure DNS Server parameters";

      // ip dns view * / dns forwarding
      container forwarding {
        tailf:info "Configure DNS server forwarding";

        // ip dns view * / dns forwarding source-interface
        container source-interface {
          tailf:info "Specify source address when forwarding queries";
          uses interface-name-grouping;
        }
      }
    }
  }

  // ip igmp
  // ip igmp vrf *
  grouping ip-igmp-grouping {

    // ip igmp limit
    leaf limit {
      tailf:info "IGMP limit";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<1-64000>;;Max Allowed State";
        range "1..64000";
      }
    }

    // ip igmp ssm-map
    container ssm-map {
      tailf:info "SSM mapping commands";

      // ip igmp ssm-map enable
      leaf enable {
        tailf:info "Enable SSM group to source mapping";
        type empty;
      }

      // no ip igmp ssm-map query dns
      container query {
        tailf:info "Which database should we query for the source";
        leaf dns {
          tailf:info "Use DNS for source lookup";
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }
      }

      // ip igmp ssm-map static *
      list static {
        tailf:info "SSM static group to source mapping";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "access-list source-address";
        leaf access-list {
          tailf:cli-diff-dependency "/ios:ip/access-list";
          type std-ip-acl-type;
        }
        leaf source-address {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;SSM source address";
          }
        }
      }
    }
  }

  // ip msdp
  // ip msdp vrf *
  grouping ip-msdp-grouping {

    // ip msdp peer *
    list peer {
      tailf:info "Configure an MSDP peer";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key address;
      leaf address {
        type inet:host {
          tailf:info "Hostname or A.B.C.D;;Peer name or address";
        }
      }
      container connect-source {
        tailf:info "Configure source address used for MSDP connection";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        uses interface-name-grouping;
      }
      leaf remote-as {
        tailf:info "Configured AS number";
        type uint16 {
          tailf:info "<1-65535>;;Autonomous System Number";
          range "1..65535";
        }
      }
    }

    // ip msdp description *
    list description {
      tailf:info "Peer specific description";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-diff-dependency "../peer";
      key address;
      leaf address {
        type inet:host {
          tailf:info "Hostname or A.B.C.D;;Peer name or address";
        }
      }
      leaf text {
        tailf:cli-drop-node-name;
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        type string {
          tailf:info "LINE;;Up to 80 characters describing this pee";
        }
      }
    }

    // ip msdp keepalive *
    list keepalive {
      tailf:info "Configure keepalive parameters for a peer";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-incomplete-command;
      tailf:cli-diff-dependency "../peer";
      key address;
      leaf address {
        type inet:host {
          tailf:info "Hostname or A.B.C.D;;Peer name or address";
        }
      }
      leaf keepalive-interval {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-60>;;Send keepalive period in seconds";
          range "1..60";
        }
      }
      leaf hold-time-interval {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-75>;;Maximum time in seconds to wait for a message";
          range "1..75";
        }
      }
    }

    // ip msdp sa-filter in *
    // ip msdp sa-filter out *
    list sa-filter {
      tailf:info "Filter SA messages from peer";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-incomplete-command;
      tailf:cli-diff-dependency "../peer";
      key "direction address";
      leaf direction {
        type enumeration {
          enum in {
            tailf:info "Enable incoming SA filtering";
          }
          enum out {
            tailf:info "Enable outgoing SA filtering";
          }
        }
      }
      leaf address {
        type inet:host {
          tailf:info "Hostname or A.B.C.D;;Peer name or address";
        }
      }
      choice list-choice {
        leaf list {
          tailf:info "Access-list";
          type ext-acl-type;
        }
        leaf route-map {
          tailf:info "Route-map";
          type string {
            tailf:info "WORD;;route-map name";
          }
        }
        leaf rp-list {
          tailf:info "Access-list for originating RP";
          type union {
            type uint16 {
              tailf:info "<1-99>;;Standard IP access list";
              range "1..99";
            }
            type string {
              tailf:info "WORD;;IP Named Standard Access list";
            }
          }
        }
        leaf rp-route-map {
          tailf:info "Route-map for originating RP";
          type string {
            tailf:info "WORD;;Route-map reference";
          }
        }
      }
    }

    // ip msdp sa-limit *
    list sa-limit {
      tailf:info "Configure SA limit for a peer";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      tailf:cli-diff-dependency "../peer";
      key address;
      leaf address {
        type inet:host {
          tailf:info "Hostname or A.B.C.D;;Peer name or address";
        }
      }
      leaf value {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<1-2147483646>;;Limit of SAs";
          range "1..2147483646";
        }
      }
    }

    // ip msdp password peer *
    container password {
      tailf:info "Configure MSDP password";
      list peer {
        tailf:info "MSDP peer on which the password is to be set";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        tailf:cli-diff-dependency "../../peer";
        key address;
        leaf address {
          type inet:host {
            tailf:info "Hostname or A.B.C.D;;Peer name or address";
          }
        }
        container password {
          tailf:cli-drop-node-name;
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          uses password-grouping {
            refine "secret" {
              cli:secret " peer \\S+ <SECRET>";
            }
          }
        }
      }
    }

    // Note: Constant ("ip msdp cache-sa-state" cannot be disabled.")
    // ip msdp cache-sa-state

    // ip msdp rpf rfc3618
    container rpf {
      tailf:info "MSDP rpf";
      leaf rfc3618 {
        tailf:info "Configure MSDP rfc 3618 RPF rules";
        type empty;
      }
    }

    // ip msdp originator-id
    container originator-id {
      tailf:info "Configure MSDP Originator ID";
      uses interface-name-grouping;
    }

    // NOTE: Can not be disabled: ip msdp cache-sa-state

    // ip msdp mesh-group
    container mesh-group {
      tailf:info "Configure an MSDP mesh-group";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf name {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "WORD;;Name of mesh-group";
        }
      }
      leaf address {
        tailf:cli-drop-node-name;
        type inet:host {
          tailf:info "Hostname or A.B.C.D;;Peer name or address";
        }
      }
    }

    // ip msdp redistribute list
    container redistribute {
      tailf:info "Inject multicast route entries into MSDP";
      leaf list {
        tailf:info "Access-list";
        tailf:cli-diff-dependency "/ios:ip/access-list";
        type ext-acl-type;
      }
    }

    // ip msdp timer
    leaf timer {
      tailf:info "MSDP timer";
      type uint8 {
        tailf:info "<1-60>;;Connection retry period";
        range "1..60";
      }
      default 30;
    }
  }

  grouping if-srv-encapsulation-dot1q-grouping {
    leaf-list id {
      tailf:cli-drop-node-name;
      tailf:cli-range-list-syntax;
      tailf:cli-replace-all;
      ios:leaf-list-modify-replace;
      type uint16 {
        tailf:info "<1-4094>;;VLAN id";
        range "1..4094";
      }
    }
    leaf second-dot1q {
      tailf:cli-break-sequence-commands;
      tailf:info "inner 802.1Q Virtual LAN or C-VLAN";
      type union {
        type uint16 {
          tailf:info "<1-4094>;;VLAN id";
          range "1..4094";
        }
        type string {
          tailf:info "WORD;;VLAN range, e.g. 2001-2010,2015";
          pattern '([0-9\-,]+)';
        }
      }
    }
    leaf cos {
      tailf:info "cos Vlan";
      type uint8 {
        tailf:info "<0-7>;;cos values";
        range "0..7";
      }
    }
    leaf etype {
      tailf:info "payload ethertype after Vlan Field";
      type enumeration {
        enum ipv4 {
          tailf:info "IPv4";
        }
        enum ipv6 {
          tailf:info "IPv6";
        }
        enum pppoe-all {
          tailf:info "PPPoE ALL";
        }
        enum pppoe-discovery {
          tailf:info "PPPoE Discovery Stage";
        }
        enum pppoe-session {
          tailf:info "PPPoE Session Stage";
        }
      }
    }
  }


  // ip wccp
  // ip wccp vrf *
  // ipv6 wccp
  // ipv6 wccp vrf *
  grouping ip-wccp-grouping {

    // ip wccp source-interface
    container source-interface {
      tailf:info "Set source interface for Router ID";
      uses interface-name-grouping;
    }

    // ip wccp web-cache
    container web-cache {
      tailf:info "Standard web caching service";
      presence true;
    }

    // ip wccp *
    list wccp-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      key service-number;
      leaf service-number {
        tailf:cli-suppress-range;
        type uint8 {
          tailf:info "<0-254>;;Dynamically defined service identifier number";
          range "0..254";
        }
      }

      // ip wccp * redirect-list
      leaf redirect-list {
        tailf:cli-break-sequence-commands;
        tailf:info "Set the access-list used to permit redirection";
        type exp-ip-acl-type;
      }

      // ip wccp * group-list
      leaf group-list {
        tailf:info "Set the access-list used to permit group membership";
        type std-acl-type;
      }

      // ip wccp * password
      container password {
        tailf:info "Authentication password (key)";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        uses password-grouping {
          refine "secret" {
            cli:secret " password <SECRET>";
          }
        }
      }
    }
  }

  // interface * / ip wccp
  // interface * / ip wccp vrf *
  // interface * / ipv6 wccp
  // interface * / ipv6 wccp vrf *
  grouping interface-ip-wccp-grouping {

    // interface * / ip wccp *
    list wccp-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key service-number;
      leaf service-number {
        tailf:cli-suppress-range;
        type uint8 {
          tailf:info "<0-254>;;Dynamically defined service identifier number";
          range "0..254";
        }
      }
      // interface * / ip wccp * redirect
      container redirect {
        tailf:info "Set packet redirection options for the service";
        leaf in {
          tailf:info "Redirect to a Cache Engine appropriate inbound packets";
          type empty;
        }
        leaf out {
          tailf:info "Redirect to a Cache Engine appropriate outbound packets";
          type empty;
        }
      }
    }
  }


  // spanning-tree portfast
  // spanning-tree portfast edge
  grouping spanning-tree-portfast-grouping {

    // spanning-tree portfast default
    leaf default {
      tailf:info "Enable portfast by default on all access ports";
      tailf:cli-full-command;
      type empty;
    }

    // spanning-tree portfast bpdufilter default
    container bpdufilter {
      tailf:info "Enable portfast bdpu filter on this switch";
      leaf default {
        tailf:info "Enable portfast by default on all access ports";
        type empty;
      }
    }

    // spanning-tree portfast bpduguard default
    container bpduguard {
      tailf:info "Enable portfast bpdu guard on this switch";
      leaf default {
        tailf:info "Enable portfast by default on all access ports";
        type empty;
      }
    }
  }


  grouping domain-path-preference-grouping {

    container path-preference {
      tailf:info "Specify the preferred provider";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf path1 {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type string {
          tailf:info "WORD;;Primary service provider";
        }
      }
      leaf path2 {
        tailf:cli-optional-in-sequence;
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        tailf:cli-disallow-value "fallback";
        type string {
          tailf:info "WORD;;Primary service provider";
        }
      }
      leaf path3 {
        tailf:cli-optional-in-sequence;
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        tailf:cli-disallow-value "fallback";
        type string {
          tailf:info "WORD;;Primary service provider";
        }
      }
      leaf fallback {
        tailf:info "Specify the fallback provider's color";
        tailf:cli-incomplete-command;
        type empty;
      }
      leaf fallback-path1 {
        tailf:cli-optional-in-sequence;
        tailf:cli-drop-node-name;
        tailf:cli-disallow-value "blackhole|routing|next-fallback";
        type string {
          tailf:info "WORD;;Fallback service provider";
        }
      }
      leaf fallback-path2 {
        tailf:cli-optional-in-sequence;
        tailf:cli-drop-node-name;
        tailf:cli-disallow-value "blackhole|routing|next-fallback";
        type string {
          tailf:info "WORD;;Fallback service provider";
        }
      }
      leaf fallback-path3 {
        tailf:cli-optional-in-sequence;
        tailf:cli-drop-node-name;
        tailf:cli-disallow-value "blackhole|routing|next-fallback";
        type string {
          tailf:info "WORD;;Fallback service provider";
        }
      }
      leaf next-fallback {
        when "../fallback-path1" {
          tailf:dependency "../fallback-path1";
        }
        tailf:info "Specify the next-fallback service provider";
        tailf:cli-optional-in-sequence;
        tailf:cli-incomplete-command;
        type empty;
      }
      leaf blackhole {
        tailf:info "Drop the packet if primary unavailable";
        tailf:cli-optional-in-sequence;
        tailf:cli-full-command;
        type empty;
      }
      leaf routing {
        tailf:info "No Fallback provider";
        tailf:cli-optional-in-sequence;
        tailf:cli-full-command;
        type empty;
      }
      leaf next-fallback-path1 {
        tailf:cli-drop-node-name;
        tailf:cli-disallow-value "blackhole|routing|next-fallback";
        type string {
          tailf:info "WORD;;Next-fallback service provider";
        }
      }
      leaf next-fallback-path2 {
        tailf:cli-drop-node-name;
        tailf:cli-disallow-value "blackhole|routing|next-fallback";
        type string {
          tailf:info "WORD;;Next-fallback service provider";
        }
      }
      leaf next-fallback-path3 {
        tailf:cli-drop-node-name;
        tailf:cli-disallow-value "blackhole|routing|next-fallback";
        type string {
          tailf:info "WORD;;Next-fallback service provider";
        }
      }
    }
  }


  // key chain * / key * / accept-lifetime
  // key chain * / key * / accept-lifetime local
  // key chain * / key * / send-lifetime
  // key chain * / key * / send-lifetime local
  grouping lifetime-grouping {
    leaf start-time {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type hhmm-type {
        tailf:info "hh:mm;;Time to start (hh:mm)";
      }
    }
    leaf start-month {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type month-type {
        tailf:info "MONTH;;Month of the year to start";
      }
    }
    leaf start-date {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type uint8 {
        tailf:info "<1-31>;;Day of the month to start";
        range "1..31";
      }
    }
    leaf start-year {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type uint16 {
        tailf:info "<1993-2035>;;Year to start";
        range "1993..2035";
      }
    }

    leaf duration {
      tailf:info "Set key lifetime duration";
      tailf:cli-optional-in-sequence;
      tailf:cli-full-command;
      type uint32 {
        tailf:info "<1-2147483646>;;Seconds";
        range "1..2147483646";
      }
    }
    leaf infinite {
      tailf:info "Never expires";
      tailf:cli-optional-in-sequence;
      tailf:cli-full-command;
      type empty;
    }

    leaf stop-time {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type hhmm-type {
        tailf:info "hh:mm;;Time to stop (hh:mm)";
      }
    }
    leaf stop-month {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type month-type {
        tailf:info "MONTH;;Month of the year to stop";
      }
    }
    leaf stop-date {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type uint8 {
        tailf:info "<1-31>;;Day of the month to stop";
        range "1..31";
      }
    }
    leaf stop-year {
      tailf:cli-drop-node-name;
      type uint16 {
        tailf:info "<1993-2035>;;Year to stop";
        range "1993..2035";
      }
    }
  }


  // controller Upstream-Cable * /
  // cable upstream controller-profile * /
  grouping us-channel-grouping {

    // controller Upstream-Cable * / us-channel *
    list us-channel {
      tailf:info "Upstream channel configuration";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key id;
      leaf id {
        type uint8 {
          tailf:info "<0-15>;;Upstream channel number";
          range "0..15";
        }
      }

      // controller Upstream-Cable * / us-channel * description
      uses description-grouping;

      // controller Upstream-Cable * / us-channel * spectrum-group
      leaf spectrum-group {
        tailf:info "Set spectrum group";
        type uint8 {
          tailf:info "<1-40>;;Spectrum group number";
        }
      }

      // controller Upstream-Cable * / us-channel * chan-class-id
      leaf chan-class-id {
        tailf:info "Channel Class ID";
        type string {
          tailf:info "<0-FFFFFFFF>;;Class ID Extension";
        }
      }

      // controller Upstream-Cable * / us-channel * frequency
      leaf frequency {
        tailf:info "Frequency";
        tailf:cli-remove-before-change;
        tailf:cli-no-value-on-delete;
        cli:ned-diff-move-first {
          cli:arguments "when-delete";
        }
        type uint32 {
          tailf:info "<5000000-85000000>;;Upstream Frequency in Hz";
          range "5000000..85000000";
        }
      }

      // controller Upstream-Cable * / us-channel * channel-width
      container channel-width {
        tailf:info "Channel width in HZ";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf first-choice-width {
          tailf:cli-drop-node-name;
          tailf:cli-remove-before-change;
          tailf:cli-no-value-on-delete;
          cli:ned-diff-move-first {
            cli:arguments "when-delete";
          }
          type uint32 {
            tailf:info "Channel width Hz";
          }
        }
        leaf last-choice-width {
          tailf:cli-drop-node-name;
          tailf:cli-no-value-on-delete;
          type uint32 {
            tailf:info "Channel width Hz";
          }
        }
      }

      // controller Upstream-Cable * / us-channel * threshold
      container threshold {
        tailf:info "Spectrum Management thresholds";

        // controller Upstream-Cable * / us-channel * threshold snr-profiles
        container snr-profiles {
          tailf:info "SNR thresholds in dB";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf snr-threshold1 {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "SNR threshold for modulation profile 1 in dB. 0 to bypass";
              range "0|5..35";
            }
          }
          leaf snr-threshold2 {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "SNR threshold for modulation profile 2 in dB. 0 to bypass";
              range "0|5..35";
            }
          }
        }

        // controller Upstream-Cable * / us-channel * threshold corr-fec
        leaf corr-fec {
          tailf:info "Corrected FEC threshold";
          type uint8 {
            tailf:info "<0-30>;;Corrected FEC Threshold in %, 0 denote bypass threshold";
            range "0..30";
          }
        }

        // controller Upstream-Cable * / us-channel * threshold hysteresis
        leaf hysteresis {
          tailf:info "CNR/SNR upgrade threshold hysteresis value";
          type uint8 {
            tailf:info "<0-10>;;CNR/SNR Upgrade Threshold Hysteresis in dB";
            range "0..10";
          }
        }
      }

      // controller Upstream-Cable * / us-channel * power-level
      leaf power-level {
        tailf:info "Input power level";
        type int8 {
          tailf:info "<-13 - 23>;;Power level in dBmV";
          range "-13..23";
        }
      }

      // controller Upstream-Cable * / us-channel * hop-priority
      container hop-priority {
        tailf:info "Hopping Criteria";

        // controller Upstream-Cable * / us-channel * hop-priority modulation frequency channel-width
        container modulation {
          tailf:info "Modulation Priority";
          container frequency {
            tailf:info "Frequency Priority";
            leaf channel-width {
              tailf:info "Channel Width Priority";
              type empty;
            }
          }
        }
      }

      // controller Upstream-Cable * / us-channel * docsis-mode
      leaf docsis-mode {
        tailf:info "Upstream channel DOCSIS mode";
        type enumeration {
          enum atdma {
            tailf:info "DOCSIS 2.0 ATDMA-only channel";
          }
          enum scdma {
            tailf:info "DOCSIS 2.0 SCDMA-only channel";
          }
          enum tdma {
            tailf:info "DOCSIS 1.x-only channel";
          }
          enum tdma-atdma {
            tailf:info "DOCSIS 1.x and DOCSIS 2.0 mixed channel";
          }
          enum ofdma {
            tailf:info "DOCSIS3.1 ofdma mode";
          }
        }
      }

      // controller Upstream-Cable * / us-channel * frequency-range
      container frequency-range {
        tailf:info "set frequency range for OFDMA channel";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf lower {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<4500000-197100000>;;Lower edge of frequency range";
          }
        }
        leaf higher {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<12400000-101000000>;;Higher edge of frequency range";
          }
        }
      }

      // controller Upstream-Cable * / us-channel * initial-rng-frequency-start
      leaf initial-rng-frequency-start {
        tailf:info "set start frequency for initial ranging";
        type uint32 {
          tailf:info "<30900000-39500000>;;frequency value";
        }
      }

      // controller Upstream-Cable * / us-channel * subcarrier-spacing
      leaf subcarrier-spacing {
        tailf:info "set subcarrier spacing for OFDMA only";
        type enumeration {
          enum "25KHz" {
            tailf:info "OFDMA subcarrier spacing 25 kHz";
          }
          enum "50KHz" {
            tailf:info "OFDMA subcarrier spacing 50 kHz";
          }
        }
      }

      // controller Upstream-Cable * / us-channel * symbols-per-frame
      leaf symbols-per-frame {
        tailf:info "set number of symbols per frame for OFDMA only";
        type uint8 {
          tailf:info "<6-18>;;symbols per frame";
        }
      }

      // controller Upstream-Cable * / us-channel * cyclic-prefix
      container cyclic-prefix {
        tailf:info "set cyclic prefix for OFDMA only";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf value {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "OFDMA cyclic prefix 128 samples";
            range "96..640";
          }
        }
        leaf roll-off-period {
          tailf:info "set roll off period for OFDMA only";
          type uint8 {
            tailf:info "OFDMA roll off period samples";
            range "0..224";
          }
        }
      }

      // controller Upstream-Cable * / us-channel * minislot-size
      leaf minislot-size {
        tailf:info "Minislot size";
        type uint8 {
          tailf:info "Minislot size in time ticks";
          range "1|2|4|8|16|32|64|128";
        }
      }

      // controller Upstream-Cable * / us-channel * modulation-profile
      container modulation-profile {
        tailf:info "Modulation Profile Number";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf primary-profile-number {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "VALUE;;modulation number";
          }
        }
        leaf secondary-profile-number {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "VALUE;;secondary modulation number";
          }
        }
        leaf tertiary-profile-number {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "VALUE;;tertiary modulation number";
          }
        }
      }

      // controller Upstream-Cable * / us-channel * equalization-coefficient
      leaf equalization-coefficient {
        tailf:info "Enable equalization coefficient";
        type empty;
      }

      // controller Upstream-Cable * / no us-channel * shutdown
      leaf shutdown {
        tailf:info "Shutdown the upstream channel";
        tailf:cli-show-no;
        type empty;
      }
    }
  }


  // ip explicit-path identifier * / index *
  // ip explicit-path name * / index *
  grouping ip-explicit-path-grouping {

    // ip explicit-path identifier * / index *
    list index {
      tailf:info "Specify entry index ";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key id;
      leaf id {
        type uint16 {
          tailf:info "<1-65535>;;Entry index number";
        }
      }
      choice address-choice {

        // ip explicit-path name * / index * next-address
        leaf next-address {
          tailf:info "Specify the next address in the path";
          tailf:cli-no-name-on-delete;
          tailf:cli-no-value-on-delete;
          type inet:ipv4-address {
            tailf:info "WORD;;Enter IP address (A.B.C.D)";
          }
        }

        // ip explicit-path name * / index * next-address loose
        container next-address-loose {
          tailf:cli-drop-node-name;
          container next-address {
            tailf:info "Specify the next address in the path";
            tailf:cli-incomplete-no;
            tailf:cli-incomplete-command;
            leaf loose {
              tailf:info "Target address is loose";
              tailf:cli-no-name-on-delete;
              tailf:cli-no-value-on-delete;
              type inet:ipv4-address {
                tailf:info "WORD;;Enter IP address (A.B.C.D)";
              }
            }
          }
        }

        // ip explicit-path name * / index * exclude-address
        leaf exclude-address {
          tailf:info "Exclude an address from subsequent partial path segments";
          tailf:cli-no-name-on-delete;
          tailf:cli-no-value-on-delete;
          type inet:ipv4-address {
            tailf:info "WORD;;Enter IP address (A.B.C.D)";
          }
        }

        // ip explicit-path name * / index * next-label
        leaf next-label {
          tailf:info "Specify the next MPLS label in the path";
          type uint32 {
            tailf:info "<0-1048575>;;Label value";
            range "0..1048575";
          }
        }
      }
    }
  }

  // radius-server host *
  // aaa group server radius * / server-private *
  grouping radius-server-grouping {

    // radius-server host * auth-port
    leaf auth-port {
      tailf:info "UDP port for RADIUS authentication server (default is 1645)";
      type uint16 {
        tailf:info "<0-65535>;;Port number";
        range "0..65535";
      }
    }

    // radius-server host * acct-port
    leaf acct-port {
      tailf:info "UDP port for RADIUS accounting server (default is 1646)";
      type uint16 {
        tailf:info "<0-65535>;;Port number";
        range "0..65535";
      }
    }

    // radius-server host * timeout
    leaf timeout {
      tailf:info "Time to wait for this RADIUS server to reply (overrides default)";
      type uint16 {
        tailf:info "<1-1000>;;Timeout value in seconds to wait for server to reply";
        range "1..1000";
      }
    }

    // radius-server host * retransmit
    leaf retransmit {
      tailf:info "Specify the number of retries to active server (overrides default)";
      type uint8 {
        tailf:info "<0-100>;;Number of retries to this server for a transaction";
        range "0..100";
      }
    }

    // radius-server host * test username
    container test {
      tailf:info "Configure server automated testing.";
      tailf:cli-flatten-container;
      leaf username {
        tailf:info "A name (from local database) that should be used to send requests.";
        type string {
          tailf:info "WORD;;User Name";
        }
      }
    }

    // radius-server host * ignore-auth-port
    leaf ignore-auth-port {
      tailf:info "Do not test authentication port of the servers.";
      type empty;
    }

    // radius-server host * ignore-acct-port
    leaf ignore-acct-port {
      tailf:info "Do not test accounting ports of the servers.";
      type empty;
    }

    // radius-server host * idle-time
    leaf idle-time {
      tailf:info "Minutes of idle-time after which server state should be verified.";
      type uint16 {
        tailf:info "<1-35791>;;Idle-time in minutes (default 60 mins).";
        range "1..35791";
      }
    }

    // radius-server host * probe-on
    leaf probe-on {
      tailf:info "Send a packet to verify the server status";
      type empty;
    }

    // radius-server host * key
    container key {
      tailf:info "per-server encryption key (overrides default)";
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      uses password-grouping {
        refine "secret" {
          cli:secret " key <SECRET>";
        }
      }
    }
  }


  /// ========================================================================
  /// grouping domain-
  /// ========================================================================

  grouping domain-advanced-smart-probes-burst-grouping {

    // domain * / vrf * / master hub / advanced / smart-probes burst
    container burst {
      tailf:info "Specify smart probe burst profile for channels monitored by general monitor";

      // domain * / vrf * / master hub / advanced / smart-probes burst
      container burst {
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf number {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<1-100>;;Specify number of packets in one burst";
            range "1..100";
          }
        }
        leaf packets {
          tailf:info "packet(s) in every burst";
          tailf:cli-incomplete-command;
          type empty;
        }
        leaf every {
          tailf:info "every burst interval";
          tailf:cli-incomplete-command;
          type empty;
        }
        leaf interval {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<1-30>;;Specify the interval between the starts of two adjacent bursts";
            range "1..30";
          }
        }
        leaf seconds {
          tailf:info "interval length in the scale of seconds";
          type empty;
        }
        leaf only-burst {
          tailf:info "only allow burst probe packets";
          type empty;
        }
      }

      // domain * / vrf * / master hub / advanced / smart-probes burst quick
      container quick {
        tailf:info "Specify smart probe burst profile for channels monitored by quick monitor";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf number {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<1-100>;;Specify number of packets in one burst";
            range "1..100";
          }
        }
        leaf packets {
          tailf:info "packet(s) in every burst";
          tailf:cli-incomplete-command;
          type empty;
        }
        leaf every {
          tailf:info "every burst interval";
          tailf:cli-incomplete-command;
          type empty;
        }
        leaf interval {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<1-30>;;Specify the interval between the starts of two adjacent bursts";
            range "1..30";
          }
        }
        leaf seconds {
          tailf:info "interval length in the scale of seconds";
          type empty;
        }
        leaf only-burst {
          tailf:info "only allow burst probe packets";
          type empty;
        }
      }
    }
  }

  grouping domain-advanced-smart-probes-grouping {

    container smart-probes {
      tailf:info "Smart probes configuration";

      // domain * / border / advanced / smart-probes burst
      uses domain-advanced-smart-probes-burst-grouping;

      // domain * / border / advanced / smart-probes * burst
      list profile {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key id;
        leaf id {
          type uint8 {
            tailf:info "<0-2>;;Specify smart-probe profile ID";
            range "0..2";
          }
        }
        uses domain-advanced-smart-probes-burst-grouping;
      }
    }
  }

  grouping domain-master-grouping {
    list master {
      tailf:info "Enter master controller configuration submode";
      tailf:cli-mode-name "config-domain-vrf-mc";
      tailf:cli-sequence-commands;
      max-elements 1;
      key type;
      leaf type {
        type enumeration {
          enum branch {
            tailf:info "Set master type as branch hub";
          }
          enum hub {
            tailf:info "Set master type as a hub";
          }
          enum regional-hub {
            tailf:info "Set master type as a regional hub";
          }
          enum transit {
            tailf:info "Set master type as a transit hub";
          }
        }
      }

      leaf pop-id {
        when "../type = 'transit'" {
          tailf:dependency "../type";
        }
        tailf:cli-drop-node-name;
        tailf:cli-hide-in-submode;
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<1-62>;;Pop ID";
          range "1..62";
        }
      }

      // domain * / vrf * / master hub / source-interface
      container source-interface {
        tailf:info "Source Interface for master controller";
        tailf:cli-break-sequence-commands;
        uses interface-name-grouping;
      }

      // domain * / vrf * / master hub / site-prefixes prefix-list
      container site-prefixes {
        tailf:info "site prefixes configuration";
        leaf prefix-list {
          tailf:info "Specify prefix-list with static site prefixes";
          type string {
            tailf:info "WORD;;prefix-list containing list of site prefixes";
          }
        }
      }

      // domain * / vrf * / master hub / hub
      leaf hub {
        tailf:info "Specify regional-hub master controller to peer with";
        tailf:cli-remove-before-change;
        tailf:cli-full-command;
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;IP address of regional-hub master controller";
        }
      }

      // domain * / vrf * / master hub / collector
      container collector {
        tailf:info "NMS/v9 collector configuration";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf ip-address {
          tailf:cli-drop-node-name;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP address of NMS/v9 collector";
          }
        }
        leaf port {
          tailf:info "Specify collector port number";
          type uint16 {
            tailf:info "<1-65535>;;Specify collector port number";
            range "1..65535";
          }
        }
      }

      // domain * / vrf * / master hub / load-balance advanced
      container load-balance {
        tailf:info "load balance non-policy traffic";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-domain-vrf-mc-load-balance";
        leaf option {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum advanced {
              tailf:info "Load balancing configuration mode";
            }
          }
          default advanced;
        }

        // domain * / vrf * / master hub / load-balance advanced / path-preference
        uses domain-path-preference-grouping;
      }

      // domain * / vrf * / master hub / password
      container password {
        tailf:info "MD5 password to be used with BRs";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        uses password-grouping {
          refine "secret" {
            cli:secret " password <SECRET>";
          }
        }
      }

      // domain * / vrf * / master hub / enterprise-prefix prefix-list
      container enterprise-prefix {
        tailf:info "Enterprise prefix configuration";
        leaf prefix-list {
          tailf:info "Specify prefix-list with static site targets";
          type string {
            tailf:info "WORD;;prefix-list containing list of site targets";
          }
        }
      }

      // domain * / vrf * / master hub / monitor-interval *
      list monitor-interval {
        tailf:info "Monitoring interval";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "seconds dscp";
        leaf seconds {
          type uint16 {
            tailf:info "<1-300>;;interval (second)";
          }
        }
        leaf dscp {
          tailf:info "specify DSCP";
          tailf:cli-expose-key-name;
          type dscp-type;
        }
      }

      // domain * / vrf * / master hub / advanced
      container advanced {
        tailf:info "Advanced configuration submode";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-domain-vrf-mc-advanced";
        presence true;

        // domain * / vrf * / master hub / advanced / smart-probes burst
        uses domain-advanced-smart-probes-grouping;

        // domain * / vrf * / master hub / advanced / channel-unreachable-timer
        leaf channel-unreachable-timer {
          tailf:info "Unreach interval detection";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<1-65535>;;Specify new timer interval value in seconds";
            range "1..65535";
          }
        }

        // domain * / vrf * / master hub / advanced / inter-dc
        leaf inter-dc {
          tailf:info "Enable inter-DC optimization";
          type empty;
        }
      }

      // domain * / vrf * / master hub / class * sequence
      list class {
        tailf:info "Create domain class and enter domain class command mode";
        tailf:cli-mode-name "config-domain-vrf-mc-class";
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;domain class name";
          }
        }
        leaf sequence {
          tailf:info "Set the Sequence for the class";
          tailf:cli-hide-in-submode;
          type uint16 {
            tailf:info "<1-65535>;;Sequence number for the class";
            range "1..65535";
          }
        }

        // domain * / vrf * / master hub / class * / match
        container match {
          tailf:info "Specify the applications the policy applies to.";
          tailf:cli-break-sequence-commands;

          // domain * / vrf * / master hub / class * / match dscp *
          list dscp {
            tailf:info "specify DSCP";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key services-value;
            leaf services-value {
              type dscp-type;
            }
            leaf policy {
              tailf:info "Specify the policy (user defined/predefined)";
              type enumeration {
                enum best-effort {
                  tailf:info "domain policy type best effort";
                }
                enum bulk-data {
                  tailf:info "domain policy type bulk data";
                }
                enum custom {
                  tailf:info "custom user-defined policy";
                }
                enum low-latency-data {
                  tailf:info "domain policy type low latency data";
                }
                enum real-time-video {
                  tailf:info "domain policy type real-time-video";
                }
                enum scavenger {
                  tailf:info "domain policy type scavenger";
                }
                enum voice {
                  tailf:info "domain policy type voice";
                }
              }
            }
          }

          // domain * / vrf * / master hub / class * / match application *
          list application {
            tailf:info "Specify the application names";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key services-value;
            leaf services-value {
              type string {
                tailf:info "WORD;;user-defined application name";
              }
            }
            leaf policy {
              tailf:info "Specify the policy (user defined/predefined)";
              type enumeration {
                enum best-effort {
                  tailf:info "domain policy type best effort";
                }
                enum bulk-data {
                  tailf:info "domain policy type bulk data";
                }
                enum custom {
                  tailf:info "custom user-defined policy";
                }
                enum low-latency-data {
                  tailf:info "domain policy type low latency data";
                }
                enum real-time-video {
                  tailf:info "domain policy type real-time-video";
                }
                enum scavenger {
                  tailf:info "domain policy type scavenger";
                }
                enum voice {
                  tailf:info "domain policy type voice";
                }
              }
            }
          }
        }

        // domain * / vrf * / master hub / class * / path-preference
        uses domain-path-preference-grouping;

        // domain * / vrf * / master hub / class * / path-last-resort
        leaf path-last-resort {
          tailf:info "Specify path of last resort provider";
          type string {
            tailf:info "Specify path of last resort provider";
          }
        }
      }
    }
  }

  grouping domain-border-grouping {
    container border {
      tailf:info "Enter border router configuration submode";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-domain-vrf-br";
      tailf:cli-full-command;
      presence true;

      // domain * / vrf * / border / master
      leaf master {
        tailf:info "Specify IP address of Domain master controller";
        tailf:cli-remove-before-change;
        tailf:cli-full-command;
        type union {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP address of Domain master controller";
          }
          type enumeration {
            enum local {
              tailf:info "local;;Local Domain master controller";
            }
          }
        }
      }

      // domain * / vrf * / border / source-interface
      container source-interface {
        tailf:info "Source Interface for border";
        uses interface-name-grouping;
      }

      // domain * / vrf * / border / password
      container password {
        tailf:info "MD5 password to be used with MC";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        uses password-grouping {
          refine "secret" {
            cli:secret " password <SECRET>";
          }
        }
      }
    }
  }

  grouping carrier-delay-grouping {
    choice delay-choice {
      leaf seconds {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<0-60>;;Carrier Transitions delay seconds";
          range "0..60";
        }
      }
      leaf msec {
        tailf:info "delay specified in milliseconds";
        type uint16 {
          tailf:info "<0-1000>;;Carrier Transitions delay milliseconds";
          range "0..1000";
        }
      }
    }
  }

  grouping crypto-pki-server-lifetime-grouping {
    leaf days {
      tailf:cli-drop-node-name;
      type uint16 {
        tailf:info "<0-7305>;;Lifetime in days";
        range "0..7305";
      }
    }
    leaf hours {
      tailf:cli-drop-node-name;
      type uint16 {
        tailf:info "<0-23>;;hours";
        range "0..23";
      }
    }
    leaf minutes {
      tailf:cli-drop-node-name;
      type uint16 {
        tailf:info "<0-59>;;minutes";
        range "0..59";
      }
    }
  }

  // crypto gdoi group * / server local /
  // crypto gkm group * / server local /
  grouping crypto-gdoi-local-server-grouping {

    // crypto gdoi group * / server local / no split-resilency
    leaf split-resilency {
      tailf:info "Configure split resiliency for the group";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
      default true;
    }

    // crypto gdoi group * / server local / no gdoi
    leaf gdoi {
      tailf:info "Enable GDOI (ISAKMP) Protocol for Registration & Rekey";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
      default true;
    }

    // crypto gdoi group * / server local / gikev2
    leaf gikev2 {
      tailf:info "Enable G-IKEv2 (IKEv2) Protocol for Registration & Rekey";
      type string {
        tailf:info "WORD;;IKEv2 Profile Name";
      }
    }

    // crypto gdoi group * / server local / rekey
    container rekey {
      tailf:info "Configure rekey policy for the group";

      // crypto gdoi group * / server local / rekey lifetime
      container lifetime {
        tailf:info "Define the rekey lifetime";
        choice lifetime-choice {
          leaf seconds {
            tailf:info "Time-based key duration in seconds";
            type uint32 {
              tailf:info "<300-86400>;;Lifetime in seconds";
            }
            default 86400;
          }
          leaf days {
            tailf:info "Time-based key duration in days";
            type uint32 {
              tailf:info "Lifetime in days";
            }
          }
          default seconds;
        }
      }

      // crypto gdoi group * / server local / rekey algorithm
      container algorithm {
        tailf:info "Set the rekey encryption algorithm";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf encryption {
          tailf:cli-drop-node-name;
          type enumeration {
            enum "3des-cbc" {
              tailf:info "Triple DES in CBC mode";
            }
            enum des-cbc {
              tailf:info "DES in CBC mode";
            }
            enum aes {
              tailf:info "AES mode (also set bits)";
            }
          }
          default 3des-cbc;
        }
        leaf bits {
          when "../encryption = 'aes'" {
            tailf:dependency "../encryption";
          }
          tailf:cli-drop-node-name;
          type enumeration {
            enum "128" {
              tailf:info "128 bit keys.";
            }
            enum "192" {
              tailf:info "192 bit keys.";
            }
            enum "256" {
              tailf:info "256 bit keys.";
            }
          }
          default 128;
        }
      }

      // crypto gdoi group * / server local / rekey sig-hash algorithm
      container sig-hash {
        tailf:info "Set rekey signature-hash parameters";
        leaf algorithm {
          tailf:info "Set the rekey signature-hash algorithm";
          type enumeration {
            enum sha {
              tailf:info "Secure Hash Standard 1 (96 bit)";
            }
            enum sha256 {
              tailf:info "Secure Hash Standard 2 (256 bit)";
            }
            enum sha384 {
              tailf:info "Secure Hash Standard 2 (384 bit)";
            }
            enum sha512 {
              tailf:info "Secure Hash Standard 2 (512 bit)";
            }
          }
        }
      }

      // crypto gdoi group * / server local / rekey retransmit
      container retransmit {
        tailf:info "Define the rekey retransmission parameters";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf number-of-seconds {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<10-60>;;Retransmit after this many seconds";
            range "10..60";
          }
        }
        choice retransmit-choice {
          leaf number {
            tailf:info "Retransmit this many times";
            type uint8 {
              tailf:info "<1-10>;;Number of retransmissions";
              range "1..10";
            }
          }
          leaf periodic {
            tailf:info "Periodically send retransmit rekeys";
            type empty;
          }
        }
      }

      // crypto gdoi group * / server local / rekey authentication
      container authentication {
        tailf:info "Identify the rekey authentication keypair";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        choice authentication-choice {
          leaf mypubkey {
            tailf:info "Identify a keypair associated with this device";
            type empty;
          }
          leaf pubkey {
            type empty;
          }
        }
        leaf rsa {
          tailf:info "Identify an RSA keypair";
          type string {
            tailf:info "WORD;;Key name";
          }
        }
      }

      // crypto gdoi group * / server local / rekey transport unicast
      container transport {
        tailf:info "Specify the rekey distribution method";
        leaf unicast {
          tailf:info "specify unicast rekey distribution";
          type empty;
        }
      }
    }

    // crypto gdoi group * / server local / authorization
    container authorization {
      tailf:info "Configure authorization for the group(Applicable only for GDOI and not for GIKEV2)";

      // crypto gdoi group * / server local / authorization address ipv4
      container address {
        tailf:info "Set authorization by address";
        leaf ipv4 {
          tailf:info "Set authorization by ipv4 address";
          type union {
            type uint8 {
              tailf:info "<1-99>;;Standard IP access-list number";
              range "1..99";
            }
            type string {
              tailf:info "WORD;;Access-list name";
            }
          }
        }
      }

      // crypto gdoi group * / server local / authorization identify
      leaf identity {
        tailf:info "Set authorization by identity";
        type string {
          tailf:info "WORD;;Identity tag";
        }
      }
    }

    // crypto gdoi group * / server local / replay
    container replay {
      container time {
        leaf window-size {
          type uint32 {
          }
        }
      }
    }

    // crypto gdoi group * / server local / sa
    container sa {
      tailf:info "Configure a security association";

      // crypto gdoi group * / server local / sa receive-only
      leaf receive-only {
        tailf:info "Configure SA to work only in inbound direction";
        type empty;
      }

      // crypto gdoi group * / server local / sa ipsec *
      list ipsec {
        tailf:info "Configure an IPsec SA";
        tailf:cli-mode-name "gdoi-sa-ipsec";
        key id;
        leaf id {
          type uint32 {
            tailf:info "<1-65535>;;Sequence to insert into SA list";
            range "1..65535";
          }
        }

        // crypto gdoi group * / server local / sa ipsec * / profile
        leaf profile {
          tailf:info "Configure an ipsec profile for the SA";
          tailf:non-strict-leafref {
            path "../../../../../../../../crypto/ipsec/profile/name";
          }
          type string {
            tailf:info "WORD;;Profile name";
          }
        }

        // crypto gdoi group * / server local / sa ipsec * / match
        container match {
          tailf:info "Match characteristics of packets to encrypt";
          container address {
            tailf:info "Match addresses of packets to encrypt";
            choice address-choice {
              leaf ipv4 {
                tailf:info "Match ipv4 packets";
                tailf:cli-diff-dependency "../../../../../../../../../../ip/access-list";
                type ext-ip-acl-type;
              }
              leaf ipv6 {
                tailf:info "Match ipv6 packets";
                tailf:non-strict-leafref {
                  path "../../../../../../../../../../ipv6/access-list/named-acl/name";
                }
                type string {
                  tailf:info "WORD;;IPv6 access list";
                }
              }
            }
          }
        }

        // crypto gdoi group * / server local / sa ipsec * / replay
        container replay {
          tailf:info "Set replay method";
          choice replay-choice {
            // crypto gdoi group * / server local / sa ipsec * / replay counter time
            container time {
              tailf:info "Enable anti-replay check for any traffic by using time";
              leaf window-size {
                tailf:info "Time based replay window size";
                type uint8 {
                  tailf:info "<1-100>;;Window-size seconds";
                  range "1..100";
                }
              }
            }
            // crypto gdoi group * / server local / sa ipsec * / replay counter window-size
            container counter {
              tailf:info "Enable anti-replay check for single source traffic by using sequence number";
              leaf window-size {
                tailf:info "Set replay window size.";
                type ipsec-window-size-type;
              }
            }
          }
        }

        // crypto gdoi group * / server local / sa ipsec * / tag cts sgt
        // crypto gdoi group * / server local / sa ipsec * / no tag
        choice tag-choice {
          container tag {
            tailf:info "Set inline tagging method";
            tailf:cli-incomplete-command;
            tailf:cli-incomplete-no;
            container cts {
              tailf:info "Cisco Trust Security";
              leaf sgt {
                tailf:info "Security Group Tag";
                type empty;
              }
            }
          }
          container tag-enable {
            tailf:cli-drop-node-name;
            leaf tag {
              tailf:info "Set inline tagging method";
              tailf:cli-boolean-no;
              type boolean;
              default true;
            }
          }
        }
      }
    }

    // crypto gdoi group * / server local / address ipv4
    container address {
      tailf:info "Configure server source address";
      leaf ipv4 {
        tailf:info "Set ipv4 address of local server";
        type union {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IPv4 local address";
          }
          type string {
            tailf:info "WORD;;Interface name";
          }
        }
      }
    }

    // crypto gdoi group * / server local / redundancy
    container redundancy {
      tailf:info "Enter cooperative key server configuration mode";
      tailf:cli-add-mode;
      tailf:cli-mode-name "gdoi-coop-ks-config";
      tailf:cli-full-command;

      // crypto gdoi group * / server local / redundancy / local
      container local {
        tailf:info "Local key server configurations";
        tailf:cli-delete-when-empty;
        presence true;
        leaf priority {
          tailf:info "Set local server priority";
          type uint8 {
            tailf:info "<1-255>;;Local server priority";
          }
        }
      }

      // crypto gdoi group * / server local / redundancy / peer address ipv4 *
      container peer {
        tailf:info "Peer server configurations";
        container address {
          tailf:info "Peer server address";
          leaf-list ipv4 {
            tailf:info "Set peer server ipv4 address";
            tailf:cli-list-syntax;
            tailf:cli-remove-before-change;
            tailf:cli-diff-delete-before "../../../../address/ipv4";
            ordered-by user;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Peer server ipv4 address";
            }
          }
        }
      }

      // crypto gdoi group * / server local / redundancy / protocol
      container protocol {
        tailf:info "Specify various protocol operational values";

        // crypto gdoi group * / server local / redundancy / protocol version
        leaf version {
          tailf:info "Set COOP ANN version";
          type enumeration {
            enum base {
              tailf:info "Base version COOP protocol (4000 GM scale)";
            }
            enum optimize {
              tailf:info "Optimized version COOP protocol (8000 GM scale)";
            }
          }
          default base;
        }
      }
    }
  }

  // crypto pki certificate chain * /
  // crypto pki certificate pool /
  grouping crypto-pki-certificate-grouping {
    list certificate {
      tailf:info "Certificate issued by the CA";
      tailf:cli-mode-name "config-pki-hexmode-quotedstring";
      tailf:cli-delete-when-empty;
      tailf:cli-exit-command "quit";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-full-command;
      tailf:cli-reset-container;
      key serial;
      leaf serial {
        tailf:cli-disallow-value "rollover|ca|ra-encrypt|ra-general|ra-sign|self-signed";
        type string {
          tailf:info "WORD;;Certificate serial number";
        }
      }
      leaf cert-type {
        tailf:cli-optional-in-sequence;
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        type enumeration {
          enum ca {
            tailf:info "A certificate";
          }
          enum ra-encrypt {
            tailf:info "A encryption certificate";
          }
          enum ra-general {
            tailf:info "A general purpose certificate";
          }
          enum ra-sign {
            tailf:info "A signing certificate";
          }
          enum rollover {
            tailf:info "Shadow rollover certificate";
          }
          enum self-signed {
            tailf:info "Self-signed certificate";
          }
        }
      }
      leaf rollover {
        tailf:info "Shadow rollover certificate";
        tailf:cli-optional-in-sequence;
        tailf:cli-prefix-key;
        type empty;
      }
      leaf cert {
        tailf:cli-drop-node-name;
        tailf:cli-disallow-value "rollover|ca|ra-encrypt|ra-general|ra-sign|self-signed";
        type string {
          tailf:info "WORD;;file specification";
        }
      }
    }
  }

  grouping mpls-label-mode-grouping {
    container protocol {
      tailf:info "MPLS Label allocation protocol";
      choice protocol-choice {
        leaf all-afs {
          tailf:info "All VRF (IPv4 and IPv6) address families";
          tailf:cli-remove-before-change;
          type mpls-label-mode-type;
          default per-prefix;
        }
        case per-af {
          leaf bgp-vpnv4 {
            tailf:info "VRF IPv4 address family";
            tailf:cli-remove-before-change;
            type mpls-label-mode-type;
            default per-prefix;
          }
          leaf bgp-vpnv6 {
            tailf:info "VRF IPv6 address family";
            tailf:cli-remove-before-change;
            type mpls-label-mode-type;
            default per-prefix;
          }
        }
      }
    }
  }

  grouping track-timer-grouping {
    choice timer-choice {
      leaf seconds {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<1-3000>;;Time in seconds";
          range "1..3000";
        }
      }
      leaf msec {
        tailf:info "Specify polling interval in milliseconds";
        type uint16 {
          tailf:info "<500-5000>;;Time in milliseconds";
          range "500..5000";
        }
      }
    }
  }

  // utd web-filter
  // utd engine standard multi-tenancy / web-filter
  grouping utd-web-filter-grouping {
    container web-filter {
      tailf:info "UTD web-filter profile configuration";

      // utd web-filter block
      container block {
        tailf:info "UTD block profile information";

        // utd web-filter block local-server profile *
        container local-server {
          tailf:info "UTD local block server configuration profile";
          list profile {
            tailf:info "Provide the profile ID";
            tailf:cli-mode-name "config-utd-webf-blk-srvr";
            key id;
            leaf id {
              type string {
                tailf:info "<1-255>;;ID of the web filter local block server profile";
              }
            }

            // utd web-filter block local-server profile * / block-page-interface Loopback
            container block-page-interface {
              tailf:info "Provide the interface to be used for the block server";
              leaf Loopback {
                tailf:info "Loopback interface";
                tailf:cli-allow-join-with-value {
                  tailf:cli-display-joined;
                }
                tailf:non-strict-leafref {
                  path "/ios:interface/Loopback/name";
                }
                type string {
                  tailf:info "<0-2147483647>;;Loopback interface number";
                  pattern '([0-9\.])+';
                }
              }
            }

            // utd web-filter block local-server profile * / content
            container content {
              tailf:info "Provide the content to be served from the server";
              choice content-choice {
                // utd web-filter block local-server profile * / content text
                leaf text {
                  tailf:info "Provide the text to be printed in the web page served";
                  ios:string-remove-quotes "content text <STRING>";
                  type string {
                    tailf:info "LINE;;Provide the text string";
                  }
                }
                // utd web-filter block local-server profile * / content file
                leaf file {
                  tailf:info "Provide the HTML file to be served";
                  type string {
                    tailf:info "WORD;;HTML file to be server used as the block page";
                  }
                }
              }
            }

            // utd web-filter block local-server profile * / http-ports
            leaf http-ports {
              tailf:info "Provide the HTTP ports to be used";
              type string {
                tailf:info "WORD;;Provide the ports seperated by ',' Eg., 80,443,22232";
              }
            }
          }
        }

        // utd web-filter block page profile *
        container page {
          tailf:info "UTD inline block page response profile";
          tailf:cli-diff-dependency "../local-server";
          list profile {
            tailf:info "Provide the profile ID";
            tailf:cli-mode-name "config-utd-block-urc";
            key id;
            leaf id {
              type string {
                tailf:info "<1-255>;;ID of the web filter block profile";
              }
            }
            choice page-choice {
              // utd web-filter block page profile * / file
              leaf file {
                tailf:info "Specify the file name to be used for the block page";
                type string {
                  tailf:info "WORD;;HTML file to be used as block page";
                }
              }

              // utd web-filter block page profile * / redirect-url
              leaf redirect-url {
                tailf:info "Specify the URL to be used for redirection";
                type string {
                  tailf:info "WORD;;URL (or) IP address to be used for redirection";
                }
              }

              // utd web-filter block page profile * / text
              leaf text {
                tailf:info "Specify the text to be used to be sent back";
                ios:string-remove-quotes "text <STRING>";
                type string {
                  tailf:info "LINE;;Enter the string to be used";
                }
              }
            }
          }
        }
      }

      // utd web-filter domain profile *
      container domain {
        tailf:info "UTD Domain based web-filtering submode";
      }

      // utd web-filter sourcedb *
      list sourcedb {
        tailf:info "UTD Web filtering source DB configuration submode";
        tailf:cli-mode-name "config-utd-webf-srcdb";
        key id;
        leaf id {
          type string {
            tailf:info "<1-255>;;ID of the source DB profile";
          }
        }

        // utd web-filter sourcedb * / logging level
        container logging {
          tailf:info "Provide source DB logging information";
          leaf level {
            tailf:info "Provide the logging level";
            type enumeration {
              enum debug {
                tailf:info "Provide debug level logs";
              }
              enum error {
                tailf:info "Provide error level logs";
              }
              enum info {
                tailf:info "Provide info level logs";
              }
              enum trace {
                tailf:info "Provide trace level logs";
              }
              enum warning {
                tailf:info "Provide warning level logs";
              }
            }
          }
        }
      }

      // utd web-filter url profile *
      container url {
        tailf:info "UTD URL based web-filtering submode";
        tailf:cli-diff-dependency "../block";
        list profile {
          tailf:info "Provide the profile ID";
          tailf:cli-mode-name "config-utd-webfltr-url";
          key id;
          leaf id {
            type string {
              tailf:info "<1-255>;;ID of the URL based web filter profile";
            }
          }

          // utd web-filter url profile * / alert *
          leaf-list alert {
            tailf:info "Provide the logging alert level";
            tailf:cli-flat-list-syntax;
            tailf:cli-replace-all;
            type enumeration {
              enum all {
                tailf:info "Log all the alerts";
              }
              enum blacklist {
                tailf:info "Log alerts for Blacklisted URLs";
              }
              enum categories-reputation {
                tailf:info "Log alerts for Category/reputation based blocking";
              }
              enum whitelist {
                tailf:info "Log alerts for Whitelisted URLs";
              }
            }
          }

          // utd web-filter url profile * / blacklist
          container blacklist {
            tailf:info "Choose the blacklist parameter-map";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-utd-webf-url-bl";
            presence true;

            // utd web-filter url profile * / blacklist / parameter-map regexp
            container parameter-map {
              tailf:info "Enter the parameter-map information for the regex";
              leaf regex {
                tailf:info "Provide the regex parameter-map name";
                tailf:non-strict-leafref {
                  path "/ios:parameter-map/type/regex/name";
                }
                type string {
                  tailf:info "WORD;;Enter the name of the regex parameter-map";
                }
              }
            }
          }

          // utd web-filter url profile * / categories
          container categories {
            tailf:info "Choose from a list of categories";

            // utd web-filter url profile * / categories allow
            container allow {
              tailf:info "Choose the list of categories to be allowed";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-utd-webf-url-cat";
              tailf:cli-full-command;
              tailf:cli-diff-dependency "../block" {
                tailf:cli-trigger-on-set;
              }
              presence true;

              // utd web-filter url profile * / categories allow / *
              list category {
                tailf:cli-drop-node-name;
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                key name;
                leaf name {
                  tailf:cli-suppress-range;
                  type utd-category-type;
                }
              }
            }

            // utd web-filter url profile * / categories block
            container block {
              tailf:info "Choose the list of categories to be blocked";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-utd-webf-url-cat";
              tailf:cli-full-command;
              tailf:cli-diff-dependency "../allow" {
                tailf:cli-trigger-on-set;
              }
              presence true;

              // utd web-filter url profile * / categories block / *
              list category {
                tailf:cli-drop-node-name;
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                key name;
                leaf name {
                  tailf:cli-suppress-range;
                  type utd-category-type;
                }
              }
            }
          }

          // utd web-filter url profile * / block
          container block {
            tailf:info "Provide information on the block page/server to be used";

            // utd web-filter url profile * / block local-server
            leaf local-server {
              tailf:info "Provide the local block server profile ID";
              tailf:cli-diff-dependency "../../../../block/local-server/profile";
              tailf:cli-diff-dependency "../page-profile" {
                tailf:cli-trigger-on-set;
              }
              type string {
                tailf:info "<1-255>;;ID of the local block server profile";
              }
            }

            // utd web-filter url profile * / block page-profile
            leaf page-profile {
              tailf:info "Provide the ID of the block page profile to be used";
              tailf:cli-diff-dependency "../../../../block/page/profile";
              tailf:cli-diff-dependency "../local-server" {
                tailf:cli-trigger-on-set;
              }
              type string {
                tailf:info "<1-255>;;ID of the web filter block profile";
              }
            }
          }

          // utd web-filter url profile * / log level
          container log {
            tailf:info "Choose the URL filtering preprocessor debug log options";
            leaf level {
              tailf:info "Choose the URL filtering preprocessor log level";
              type enumeration {
                enum detailed {
                  tailf:info "Enable detailed logs (enables everything)";
                }
                enum error {
                  tailf:info "Enable only error level logs";
                }
                enum info {
                  tailf:info "Enable info level logs";
                }
              }
            }
          }

          // utd web-filter url profile * / reputation
          container reputation {
            tailf:info "Choose the reputation range for the URLs to be blocked";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-utd-webf-url-rep";
            presence true;

            // utd web-filter url profile * / reputation /  block-threshold
            leaf block-threshold {
              tailf:info "Block the URLs with reputation at or above the specified level";
              type enumeration {
                enum high-risk {
                  tailf:info "High risk URLS (Reputation score 0-20 will be blocked)";
                }
                enum low-risk {
                  tailf:info "Low risk URLS (Reputation score 0-80 will be blocked)";
                }
                enum moderate-risk {
                  tailf:info "Moderate risk URLS (Reputation score 0-60 will be blocked)";
                }
                enum suspicious {
                  tailf:info "Suspicious URLS (Reputation score 0-40 will be blocked)";
                }
                enum trustworthy {
                  tailf:info "Trusted URLS (Reputation score 0-100 will be blocked)";
                }
              }
            }
          }

          // utd web-filter url profile * / sourcedb fail close
          container sourcedb {
            tailf:info "Choose source DB related configs";
            container fail {
              tailf:info "Choose the fail option to apply when the source DB is down";
              leaf close {
                tailf:info "Drop all URL filtering traffic on source DB failure";
                type empty;
              }
            }
          }

          // utd web-filter url profile * / whitelist
          container whitelist {
            tailf:info "Choose the whitelist parameter-map";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-utd-webf-dmn-wl";
            presence true;

            // utd web-filter url profile * / whitelist / parameter-map regexp
            container parameter-map {
              tailf:info "Enter the parameter-map information for the regex";
              leaf regex {
                tailf:info "Provide the regex parameter-map name";
                tailf:non-strict-leafref {
                  path "/ios:parameter-map/type/regex/name";
                }
                type string {
                  tailf:info "WORD;;Enter the name of the regex parameter-map";
                }
              }
            }
          }
        }
      }
    }
  }

  // utd engine standard
  // utd engine standard multi-tenancy / utd global
  grouping utd-engine-standard-grouping {

    // utd engine standard / logging
    container logging {
      tailf:info "Provide logging server information";

      // utd engine standard / logging host *
      list host {
        tailf:info "Log the alerts to a host";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          tailf:cli-suppress-range;
          type string {
            tailf:info "WORD;;Provide the URL/IP address of the host";
          }
        }
      }

      // utd engine standard / logging syslog
      leaf syslog {
        tailf:info "Log the alerts to IOS syslogs";
        type empty;
      }
    }

    // utd engine standard / threat-inspection
    container threat-inspection {
      tailf:info "IPS (or IDS) specific config commands";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-utd-engstd-insp";
      presence true;

      // utd engine standard / threat-inspection / signature update
      container signature {
        tailf:info "Provide config options for the signatures";
        container update {
          tailf:info "Provide config options for the signature updates";

          // utd engine standard / threat-inspection / signature update server
          container server {
            tailf:info "Provide config options for the signature update server";
            choice server-choice {
              // utd engine standard / threat-inspection / signature update server cisco
              container cisco {
                tailf:info "Use Cisco site to provide updates";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                leaf username {
                  tailf:info "Provide the username for authentication";
                  tailf:cli-incomplete-command;
                  type string {
                    tailf:info "WORD;;Provide the username for authentication";
                  }
                }
                leaf password {
                  tailf:info "Provide the password for authentication";
                  cli:secret {
                    cli:arguments "always-encrypted";
                  }
                  type NEDCOM_SECRET_TYPE {
                    tailf:info "password;;Provide the password for authentication";
                  }
                }
              }

              // utd engine standard / threat-inspection / signature update server url
              container url {
                tailf:info "Enter the complete URL for the path to the update server";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                leaf path {
                  tailf:cli-drop-node-name;
                  type string {
                    tailf:info "WORD;;URL for update location (http/https) Example: http://1.2.3.4/path/";
                  }
                }
                leaf username {
                  tailf:info "Provide the username for authentication";
                  tailf:cli-incomplete-command;
                  type string {
                    tailf:info "WORD;;Provide the username for authentication";
                  }
                }
                leaf password {
                  tailf:info "Provide the password for authentication";
                  cli:secret "secret";
                  type NEDCOM_SECRET_TYPE {
                    tailf:info "password;;Provide the password for authentication";
                  }
                }
              }
            }
          }

          // utd engine standard / threat-inspection / signature update / occur-at
          container occur-at {
            tailf:info "Specify update occurence by calendar time";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            choice occur-at-choice {
              leaf daily {
                tailf:info "Option for daily update";
                tailf:cli-incomplete-command;
                type empty;
              }
              leaf weekly {
                tailf:info "Option for weekly update";
                tailf:cli-incomplete-command;
                type string {
                  tailf:info "WORD;;Days of the week from 0-6, Sunday=0, examples: 0-2 or 1,3,5";
                }
              }
              leaf monthly {
                tailf:info "Option for monthly update";
                tailf:cli-incomplete-command;
                type string {
                  tailf:info "WORD;;Days of the month from 1-31, examples: 1,10,20,30 or 1-11";
                }
              }
            }
            leaf hours {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint8 {
                tailf:info "<0-23>;;Hours of the day in 24-hr time, 0-23, examples: 13 or 7";
                range "0..23";
              }
            }
            leaf minutes {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<0-59>;;The minutes from the top of the hour";
                range "0..59";
              }
            }
          }
        }
      }
    }
  }

  // utd engine standard / threat-inspection /
  grouping utd-engine-threat-inspection-grouping {
    // utd engine standard / threat-inspection / threat
    leaf threat {
      tailf:info "Provide the threat detection/protection option (default=detection)";
      type enumeration {
        enum detection {
          tailf:info "Provide threat detection";
        }
        enum protection {
          tailf:info "Provide threat protection";
        }
      }
    }

    // utd engine standard / threat-inspection / policy
    leaf policy {
      tailf:info "Provide the policy option (default=balanced)";
      type enumeration {
        enum balanced {
          tailf:info "Set the policy to balanced (this is the default option)";
        }
        enum connectivity {
          tailf:info "Set the policy to connectivity (stresses on connectivity over security)";
        }
        enum security {
          tailf:info "Set the policy to security (provide mode exhaustive coverage)";
        }
      }
    }

    // utd engine standard / threat-inspection / logging level
    container logging {
      tailf:info "Provide logging level for the alerts for IPS/IDS";
      leaf level {
        tailf:info "Provide the log level";
        type enumeration {
          enum emerg {
            tailf:info "Provide emergency level logs (severity = 1)";
            value 1;
          }
          enum alert {
            tailf:info "Provide alert level logs     (severity = 2)";
            value 2;
          }
          enum crit {
            tailf:info "Provide critical level logs  (severity = 3)";
            value 3;
          }
          enum err {
            tailf:info "Provide error level logs     (severity = 4)(default)";
            value 4;
          }
          enum warning {
            tailf:info "Provide warning level logs   (severity = 5)";
            value 5;
          }
          enum notice {
            tailf:info "Provide notice level logs    (severity = 6)";
            value 6;
          }
          enum info {
            tailf:info "Provide info level logs      (severity = 7)";
            value 7;
          }
          enum debug {
            tailf:info "Provide all logs             (severity = 8)";
            value 8;
          }
        }
      }
    }
  }

  grouping pseudowire-preferred-path-grouping {
    container preferred-path {
      tailf:info "Preferred path";
      choice path-choice {
        leaf peer {
          tailf:info "Peer Address";
          type inet:host {
            tailf:info "Hostname or A.B.C.D;;IP address or host name of Peer PE";
          }
        }
        container interface {
          tailf:info "Output Interface";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf Tunnel {
            tailf:info "Tunnel interface";
            tailf:cli-allow-join-with-value {
              tailf:cli-display-joined;
            }
            tailf:non-strict-leafref {
              path "/ios:interface/Tunnel/name";
            }
            type uint32 {
              tailf:info "<0-2147483647>;;Tunnel interface number";
            }
          }
          leaf disable-fallback {
            tailf:info "disable fall back to alternative route";
            type empty;
          }
        }
      }
    }
  }

  // enable secret
  grouping enable-secret-grouping {
    leaf algorithm-type {
      tailf:info "Algorithm to use for hashing the plaintext secret for the user";
      tailf:ned-ignore-compare-config;
      tailf:cli-incomplete-command;
      tailf:cli-optional-in-sequence;
      default sha256;
      type enumeration {
        enum md5 {
          tailf:info "Encode the password using the MD5 algorithm";
        }
        enum scrypt {
          tailf:info "Encode the password using the SCRYPT hashing algorithm";
        }
        enum sha256 {
          tailf:info "Encode the password using the PBKDF2 hashing algorithm";
        }
      }
    }
    leaf type {
      tailf:cli-drop-node-name;
      tailf:cli-optional-in-sequence;
      tailf:cli-incomplete-command;
      type enumeration {
        enum "0" {
          tailf:info "Specifies an UNENCRYPTED password will follow";
        }
        enum "4" {
          tailf:info "Specifies a HIDDEN secret will follow"; // which?
        }
        enum "5" {
          tailf:info "Specifies an ENCRYPTED secret will follow";
        }
        enum "8" {
          tailf:info "Specifies a PBKDF2 HASHED secret will follow";
        }
        enum "9" {
          tailf:info "Specifies a SCRYPT HASHED secret will follow";
        }
      }
    }
    leaf secret {
      tailf:cli-drop-node-name;
      tailf:cli-reset-container;
      tailf:cli-full-command;
      tailf:cli-disallow-value "0|4|5|8|9|algorithm-type";
      cli:secret " secret <SECRET>";
      type NEDCOM_SECRET_TYPE {
        tailf:info "LINE;;The UNENCRYPTED (cleartext) 'enable' secret";
      }
    }
  }


  // interface * / pppoe-client
  // interface ATM* / pvc * / pppoe-client
  grouping pppoe-client-grouping {
    container pppoe-client {
      tailf:info "pppoe-client";

      // interface * / pppoe-client / dial-pool-number *
      list dial-pool-number {
        tailf:info "dialer pool keyword";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-remove-before-change;
        key id;
        leaf id {
          type uint8 {
            tailf:info "<1-255>;;Dialer pool number";
          }
        }

        // interface * / pppoe-client / dial-pool-number * / dial-on-demand
        leaf dial-on-demand {
          tailf:info "dial on demand enabled";
          type empty;
        }

        // interface * / pppoe-client / dial-pool-number * / restart
        leaf restart {
          tailf:info "Set restart timeout value";
          type uint16 {
            tailf:info "<1-3600>;;Restart timeout, in seconds";
            range "1..3600";
          }
        }

        // interface * / pppoe-client / dial-pool-number * / mac-override
        leaf mac-override {
          tailf:info "Use mac-address from dialer interface";
          tailf:cli-full-command;
          type empty;
        }

        // interface * / pppoe-client / dial-pool-number * / service-name
        leaf service-name {
          tailf:info "Service name requested by the PPPoE client for this dial-pool-number";
          type string {
            tailf:info "LINE;;Service Name string";
          }
        }
      }

      // interface * / pppoe-client / ppp-max-payload
      leaf ppp-max-payload {
        tailf:info "Send PPP Max-Payload tag in PPPoE control packets";
        type uint16 {
          tailf:info "<64-18000>;;Maximum MRU value to be negotiated during PPP LCP negotiation";
        }
      }
    }
  }


  // interface * / tunnel mpls traffic-eng path-option *
  // interface * / tunnel mpls traffic-eng path-option protect *
  grouping if-tunnel-mpls-traffic-eng-path-option-grouping {
    leaf segment-routing {
      tailf:cli-break-sequence-commands;
      tailf:info "specify segment-routing for this pathoption";
      type empty;
    }
    leaf pce {
      tailf:info "Use PCE for path computation";
      type empty;
    }
    leaf attributes {
      tailf:info "Specify an LSP attribute list";
      tailf:cli-full-command;
      tailf:non-strict-leafref {
        path "/ios:mpls/traffic-eng/lsp/attributes/name";
      }
      type string {
        tailf:info "WORD;;Name of LSP attribute list";
      }
    }
    leaf lockdown {
      tailf:info "not a candidate for reoptimization";
      type empty;
    }
    container bandwidth {
      tailf:info "override the bandwidth configured on the tunnel";
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf sub-pool {
        tailf:info "tunnel uses sub-pool bandwidth";
        tailf:cli-optional-in-sequence;
        type empty;
      }
      leaf value {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<1-4294967295>;;bandwidth requirement in kbps";
          range "1..4294967295";
        }
      }
    }
    leaf verbatim {
      tailf:info "do not validate links from the ERO object";
      type empty;
    }
  }


  grouping interface-isdn-outgoing-ie-grouping {
    container codeset_0 {
      tailf:info "ISDN IE Codeset";
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      presence true;
      container message {
        tailf:info "messages";
        leaf alerting {
          tailf:info "ALERTING meaasage";
          type empty;
        }
        leaf callproc {
          tailf:info "CALL PROCEEDING message";
          type empty;
        }
        leaf connect {
          tailf:info "CONNECT message";
          type empty;
        }
        leaf disconnect {
          tailf:info "DISCONNECT message";
          type empty;
        }
        leaf facility {
          tailf:info "FACILITY message";
          type empty;
        }
        leaf information {
          tailf:info "INFORMATION message";
          type empty;
        }
        leaf progress {
          tailf:info "PROGRESS message";
          type empty;
        }
        leaf rel_comp {
          tailf:info "RELEASE COMP message";
          type empty;
        }
        leaf release {
          tailf:info "RELEASE message";
          type empty;
        }
        leaf setup {
          tailf:info "SETUP message";
          type empty;
        }
        leaf setup-ack {
          tailf:info "SETUP ACK message";
          type empty;
        }
      }
    }
  }


  // interface CEM* /
  // interface CEM-ACR* /
  grouping interface-cem-grouping {

    // interface CEM* / cem *
    list cem {
      tailf:info "Configure a CEM channel";
      tailf:cli-mode-name "config-if-cem";
      key id;
      leaf id {
        type uint16 {
          tailf:info "<0-65535>;;Enter the group value";
        }
      }

      // interface CEM* / cem * / cem class
      container cem {
        tailf:info "Apply CEM class";
        leaf class {
          tailf:info "Apply CEM class";
          tailf:non-strict-leafref {
            path "../../../../../class/cem/name";
          }
          type string {
            tailf:info "WORD;;cem class name";
          }
        }
      }

      // interface CEM* / cem * / service-policy input
      container service-policy {
        tailf:info "Attach a policy-map to CEM Circuit";
        leaf input {
          tailf:info "Attach a policy-map to ingress of CEM Circuit";
          tailf:non-strict-leafref {
            path "../../../../../policy-map/name";
          }
          type string {
            tailf:info "WORD;;Policy-map name";
          }
        }
      }

      // interface CEM* / cem * / idle-pattern
      leaf idle-pattern {
        tailf:info "Set 8 bit idle pattern";
        type string {
          tailf:info "<0x0-0xFF>;;8 bit hex number";
        }
      }

      // interface CEM* / cem * / xconnect
      uses xconnect-grouping;
    }
  }


  // bridge-domain * / snmp context
  // vrf definition * / address-family ipv4 / snmp context
  grouping snmp-context-grouping {
    container snmp {
      tailf:info "Modify snmp parameters";
      list context {
        tailf:info "Configure a SNMP context";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        max-elements 1;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Context Name";
          }
        }

        // vrf definition * / address-family ipv4 / snmp context * community
        container community {
          tailf:info "Configure a SNMP v2c Community string and access privs";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf community-string {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;Community string ";
            }
          }
          leaf access {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            type enumeration {
              enum RO {
                tailf:info "Read-only access with this community string";
              }
              enum RW {
                tailf:info "Read-write access with this community string";
              }
            }
          }
          leaf ipv6 {
            tailf:info "Specify IPv6 Named Access-List";
            tailf:cli-optional-in-sequence;
            tailf:non-strict-leafref {
              path "/ios:ipv6/access-list/named-acl/name";
            }
            type string {
              tailf:info "WORD;;IPv6 Access-list name";
            }
          }
          leaf access-list-name {
            tailf:cli-drop-node-name;
            tailf:cli-disallow-value "RO|RW|ipv6";
            type std-ip-acl-type;
          }
        }

        // vrf definition * / address-family ipv4 / snmp context * user
        container user {
          tailf:info "Configure a SNMP v3 user";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf name {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;Name of the user";
            }
          }
        }
      }
    }
  }


  // ptp clock ordinary domain *
  // ptp clock boundary domain *
  grouping ptp-clock-domain-grouping {

    // ptp clock ordinary domain * / profile
    leaf profile {
      tailf:info "PTP profile";
      tailf:cli-hide-in-submode;
      type enumeration {
        enum "g8265.1" {
          tailf:info "Telecom Profile ITU-T G.8265.1";
        }
        enum "g8275.2" {
          tailf:info "Telecom Profile ITU-T G.8275.2";
        }
      }
    }

    // ptp clock ordinary domain * / local-priority
    leaf local-priority {
      tailf:info "Set clock local priority (for use with G.8275.1 profile)";
      type uint8 {
        tailf:info "<1-255>;;Local priority";
        range "1..255";
      }
    }

    // ptp clock ordinary domain * / priority1
    leaf priority1 {
      tailf:info "Set priority1";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<0-255>;;Priority1";
        range "0..255";
      }
    }

    // ptp clock ordinary domain * / priority2
    leaf priority2 {
      tailf:info "Set priority2";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<0-255>;;Priority2";
        range "0..255";
      }
    }

    // ptp clock ordinary domain * / servo
    container servo {
      tailf:info "Configure servo parameters";

      // ptp clock ordinary domain * / servo tracking-type
      leaf tracking-type {
        tailf:info "Configure tracking-type mode";
        type enumeration {
          enum Frequency {
            tailf:info "Configure frequency tracking-type";
          }
          enum R-DTI {
            tailf:info "Configure Remote-DTI tracking-type";
          }
        }
      }
    }

    // ptp clock ordinary domain * / time-properties
    container time-properties {
      tailf:info "Set the PTP timePropertiesDS";
      container gps {
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf timeScale {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type enumeration {
            enum timeScaleFALSE {
              tailf:info "Set the timepropertiesDS.timeScale to FALSE";
            }
            enum timeScaleTRUE {
              tailf:info "Set the timepropertiesDS.timeScale to TRUE";
            }
          }
        }
        leaf currentUtcOffsetValid {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type enumeration {
            enum currentUtcOffsetValidFALSE {
              tailf:info "Set the timepropertiesDS.currentUtcOffsetValid to FALSE";
            }
            enum currentUtcOffsetValidTRUE {
              tailf:info "Set the timepropertiesDS.currentUtcOffsetValid to TRUE";
            }
          }
        }
        leaf leap59 {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type enumeration {
            enum leap59FALSE {
              tailf:info "Set the timepropertiesDS.leap59 to FALSE";
            }
            enum leap59TRUE {
              tailf:info "Set the timepropertiesDS.leap59 to TRUE";
            }
          }
        }
        leaf leap61 {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type enumeration {
            enum leap61FALSE {
              tailf:info "Set the timepropertiesDS.leap61 to FALSE";
            }
            enum leap61TRUE {
              tailf:info "Set the timepropertiesDS.leap61 to TRUE";
            }
          }
        }
        leaf currentUtcOffset {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-1000>;;Set the timepropertiesDS.currentUtcOffset (in seconds)";
            range "0..1000";
          }
        }
      }
    }

    // ptp clock ordinary domain * / clock-port *
    list clock-port {
      tailf:info "Configure clock port";
      tailf:cli-mode-name "config-ptp-port";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Port name";
        }
      }
      leaf mode {
        tailf:cli-drop-node-name;
        tailf:cli-hide-in-submode;
        type enumeration {
          enum master {
            tailf:info "Configure as Master";
          }
          enum slave {
            tailf:info "Configure as Slave";
          }
        }
      }
      leaf profile {
        tailf:info "PTP profile";
        tailf:cli-hide-in-submode;
        type enumeration {
          enum g8265.1 {
            tailf:info "Telecom Profile ITU-T G.8265.1";
          }
          enum g8275.1 {
            tailf:info "Telecom Profile ITU-T G.8275.1";
          }
          enum g8275.2 {
            tailf:info "Telecom Profile ITU-T G.8275.2";
          }
        }
      }
      leaf local-priority {
        tailf:info "Set port local priority";
        tailf:cli-hide-in-submode;
        type uint8 {
          tailf:info "<1-255>;;Local priority";
          range "1..255";
        }
      }

      // ptp clock ordinary domain * / clock-port * / delay-req interval
      container delay-req {
        tailf:info "Set parameters for delay-req packets";
        leaf interval {
          tailf:info "Set interval for PTP delay-req packets";
          type int8 {
            tailf:info "<-7 - 4>;;Interval for PTP delay-req packets";
            range "-7..4";
          }
        }
      }

      // ptp clock ordinary domain * / clock-port * / announce
      container announce {
        tailf:info "Set parameters for announcement packets";

        // ptp clock ordinary domain * / clock-port * / announce interval
        leaf interval {
          tailf:info "Set interval for announcement packets";
          type int8 {
            tailf:info "<-3 - 3>;;Interval for announcement packets";
            range "-3..3";
          }
        }

        // ptp clock ordinary domain * / clock-port * / announce timeout
        leaf timeout {
          tailf:info "Set timeout interval for announcement packets";
          type uint8 {
            tailf:info "<1 - 10>;;Timeout for announcement packets";
            range "1..10";
          }
        }
      }

      // ptp clock ordinary domain * / clock-port * / sync
      container sync {
        tailf:info "Set parameters for sync packets";

        // ptp clock ordinary domain * / clock-port * / sync interval
        leaf interval {
          tailf:info "Set interval for sync packets";
          type int8 {
            tailf:info "<-7-4>;;Interval for sending sync packets";
            range "-7..4";
          }
        }

        // ptp clock ordinary domain * / clock-port * / sync one-step
        leaf one-step {
          tailf:info "One-step clock";
          type empty;
        }
      }

      // ptp clock ordinary domain * / clock-port * / transport
      container transport {
        tailf:info "Set port transport parameters";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf proto {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type enumeration {
            enum ethernet {
              tailf:info "Use Ethernet encapsulation";
            }
            enum ipv4 {
              tailf:info "Use IPv4 encapsulation";
            }
            enum ipv6 {
              tailf:info "Use IPv6 encapsulation";
            }
          }
        }
        choice af-choice {
          leaf unicast {
            tailf:info "Use unicast communication channel";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          leaf multicast {
            tailf:info "Use multicast communication channel";
            type empty;
          }
        }
        leaf interface {
          tailf:info "Transport interface";
          tailf:cli-optional-in-sequence;
          type string {
            tailf:info "WORD;;Abbreviated interface name";
          }
        }
        leaf negotiation {
          tailf:info "Enable unicast negotiation";
          tailf:cli-optional-in-sequence;
          type empty;
        }
        leaf single-hop {
          tailf:info "Enable single hop transport";
          type empty;
        }
      }

      // ptp clock ordinary domain * / clock-port * / clock source
      container clock {
        tailf:info "Set clock parameters";

        // ptp clock ordinary domain * / clock-port * / clock source
        choice source-choice {
          leaf source {
            tailf:info "Local clock address";
            tailf:cli-remove-before-change;
            tailf:cli-disallow-value "ipv6";
            type string {
              tailf:info "WORD;;MAC/IP address";
            }
          }
          // ptp clock ordinary domain * / clock-port * / clock source ipv6
          container source-conf {
            tailf:cli-drop-node-name;
            container source {
              tailf:info "Local clock address";
              tailf:cli-incomplete-no;
              leaf ipv6 {
                tailf:info "IPV6";
                type inet:ipv6-address {
                  tailf:info "X:X:X:X::X;;Protocol specific address";
                }
              }
            }
          }
        }

        // ptp clock ordinary domain * / clock-port * / clock source <ip> *
        list source-priority {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-remove-before-change;
          tailf:cli-diff-dependency "../source";
          key priority;
          leaf source {
            tailf:info "Local clock address";
            tailf:cli-prefix-key;
            type string {
              tailf:info "WORD;;MAC/IP address";
            }
          }
          leaf priority {
            type uint8 {
              tailf:info "<1-2>;;local priority";
              range "1..2";
            }
          }
        }

        // ptp clock ordinary domain * / clock-port * / clock destination
        leaf destination {
          tailf:info "Destination clock address";
          tailf:cli-full-command;
          type string {
            tailf:info "H.H.H;;MAC address";
          }
        }
      }
    }
  }


  // controller SONET * /
  // controller SONET-ACR * /
  grouping controller-SONET-grouping {

    // controller SONET * / description
    leaf description {
      tailf:info "Controller specific description";
      tailf:cli-multi-value;
      tailf:cli-preformatted;
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;Up to 240 characters describing this controller";
        length "1..240";
      }
    }

    // controller SONET * / shutdown
    leaf shutdown {
      tailf:info "Shut down the Sonet/SDH controller";
      type empty;
    }

    // controller SONET * / rate
    leaf rate {
      tailf:info "Set the SONET/SDH rates";
      tailf:cli-remove-before-change;
      tailf:cli-full-command;
      type string {
        tailf:info "OC<X>;;Set the controller to OC<X> rate";
        pattern "OC.*";
      }
    }

    // controller SONET * / ais-shut
    // controller SONET * / no ais-shut
    leaf ais-shut {
      tailf:info "Send LAIS when shutdown";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
    }

    // controller SONET * / no TU-AIS
    leaf TU-AIS {
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
      default true;
    }

    // controller SONET * / alarm-report
    leaf alarm-report {
      tailf:info "Enable reporting of selected alarms";
      type enumeration {
        enum "all" {
          tailf:info "All alarm reports";
        }
        // Note, skipping the other options, since no other except
        // "all" is displayed by the device
      }
    }

    // controller SONET * / threshold
    container threshold {
      tailf:info "Set BER threshold values";

      // controller SONET * / threshold sf-ber
      leaf sf-ber {
        tailf:info "set Signal Fail BER threshold";
        type uint8 {
          tailf:info "<3-5>;;Bit error rate (10 to the minus n)";
          range "3..5";
        }
      }
    }

    // controller SONET * / framing
    leaf framing {
      tailf:info "Configure to use in Sonet or SDH mode";
      tailf:cli-full-command;
      type enumeration {
        enum sdh {
          tailf:info "Use SDH Framing";
        }
        enum sonet {
          tailf:info "Use Sonet Framing";
        }
      }
    }

    // controller SONET * / clock source
    container clock {
      tailf:info "Specify the clock source for Sonet/SDH port";
      leaf source {
        tailf:info "Specify the clock source for Sonet/SDH port";
        tailf:cli-full-command;
        type enumeration {
          enum line {
            tailf:info "Recovered Clock";
          }
          enum internal {
            tailf:info "Internal Clock";
          }
        }
      }
    }

    // controller SONET * / loopback
    container loopback {
      tailf:info "Put the entire Sonet/SDH line into loopback";
      choice loopback-choice {
        container local {
          tailf:info "Local loopback";
          presence true;
        }
        container network {
          tailf:info "Network line loopback";
          presence true;
        }
      }
    }

    // controller SONET * / aug mapping
    container aug {
      tailf:info "Specify AU-3 or AU-4 mapping";
      leaf mapping {
        tailf:info "Specify AU-3 or AU-4 mapping";
        type enumeration {
          enum au-3 {
            tailf:info "AU-3";
          }
          enum au-4 {
            tailf:info "AU-4 (default)";
          }
        }
      }
    }

    // controller SONET * / overhead
    container overhead {
      tailf:info "Specify overhead settings";

      // controller SONET * / overhead j0
      leaf j0 {
        tailf:info "Set the j0 trace byte";
        type uint8 {
          tailf:info "<0-255>;;j0 trace byte";
        }
      }
    }

    // controller SONET * / au-3 *
    list au-3 {
      tailf:info "Specify au-3 number";
      tailf:cli-mode-name "config-ctrlr-au3";
      key id;
      leaf id {
        type uint8 {
          tailf:info "<1-3>;;au-3 number";
          range "1..3";
        }
      }

      // controller SONET * / au-3 * / overhead
      container overhead {
        tailf:info "Configure sonet path overhead flags";
        container j1 {
          tailf:info "Path trace buffer config";
          tailf:cli-compact-syntax;
          leaf length {
            tailf:info "Path trace buffer length (16 or 64 bytes)";
            type enumeration {
              enum "16" {
                tailf:info "Path trace buffer length, 16 bytes";
              }
              enum "64" {
                tailf:info "Path trace buffer length, 64 bytes";
              }
            }
          }
        }
      }

      // controller SONET * / au-3 * / mode
      leaf mode {
        tailf:info "Specify path operation mode";
        tailf:cli-full-command;
        type enumeration {
          enum c-11 {
            tailf:info "Mode C-11";
          }
        }
      }

      // controller SONET * / au-3 * / tug-2 * t1 *
      list tug-2 {
        tailf:info "Tug-2 configuration";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key "tug-2 t1";
        leaf tug-2 {
          type uint8 {
            tailf:info "<1-7>;;Tug-2 number <1-7>";
            range "1..7";
          }
        }
        leaf t1 {
          tailf:info "T1 line configuration";
          tailf:cli-expose-key-name;
          type uint8 {
            tailf:info "<1-3>;;E1 line number <1-4>";
            range "1..4";
          }
        }

        // controller SONET * / au-3 * / tug-2 * t1 * clock source
        container clock {
          tailf:info "Specify the clock source for a T1";
          leaf source {
            tailf:info "Specify the clock source for a T1";
            tailf:cli-full-command;
            type enumeration {
              enum line {
                tailf:info "Line Recovered Clock";
              }
              enum internal {
                tailf:info "Internal Clock";
              }
            }
          }
        }
      }
    }

    // controller SONET * / au-4 *
    list au-4 {
      tailf:info "Specify AU-4 number and TUG-3 number";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      key id;
      leaf id {
        type uint8 {
          tailf:info "<1-4>;;au-4 number";
          range "1..4";
        }
      }

      // controller SONET * / au-4 * threshold b3-tca
      container threshold {
        tailf:info "Set Path BER threshold values";
        leaf b3-tca {
          tailf:info "B3 BER threshold crossing alarm";
          type uint8 {
            tailf:info "<3-9>;;Bit error rate (10 to the minus n)";
            range "3..9";
          }
        }
      }

      // controller SONET * / au-4 * tug-3 *
      list tug-3 {
        tailf:info "TUG-3 number";
        tailf:cli-mode-name "config-ctrlr-tug3";
        key id;
        leaf id {
          type uint8 {
            tailf:info "<1-3>;;tug-3 number <1..3>";
            range "1..3";
          }
        }

        // controller SONET * / au-4 * tug-3 * / mode
        leaf mode {
          tailf:info "Specify path operation mode";
          tailf:cli-full-command;
          type enumeration {
            enum c-12 {
              tailf:info "Mode C-12";
            }
          }
        }

        // controller SONET * / au-4 * tug-3 * / tug-2 * e1 *
        list tug-2 {
          tailf:info "Tug-2 configuration";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          key "tug-2 e1";
          leaf tug-2 {
            type uint8 {
              tailf:info "<1-7>;;Tug-2 number <1-7>";
              range "1..7";
            }
          }
          leaf e1 {
            tailf:info "E1 line configuration";
            tailf:cli-expose-key-name;
            type uint8 {
              tailf:info "<1-3>;;E1 line number <1-3>";
              range "1..3";
            }
          }

          // controller SONET * / au-4 * tug-3 * / tug-2 * e1 * ima-group
          container ima-group {
            tailf:info "Configure IMA group";
            leaf group-number {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<0-41>;;IMA group ID";
                range "0..41";
              }
            }
          }

          // controller SONET * / au-4 * tug-3 * / tug-2 * e1 * channel-group *
          list channel-group {
            tailf:info "Specify the timeslots to channel-group mapping for an E1 interface";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key id;
            leaf id {
              type uint8 {
                tailf:info "<0-30>;;Channel group number";
                range "0..30";
              }
            }

            // controller SONET * / au-4 * tug-3 * / tug-2 * e1 * channel-group * timeslots
            leaf-list timeslots {
              tailf:info "List of timeslots in the channel group";
              tailf:cli-replace-all;
              tailf:cli-range-list-syntax;
              type uint16 {
                tailf:info "<1-31>;;List of timeslots which comprise the channel";
                range "1..31";
              }
            }
          }

          // controller SONET * / au-4 * tug-3 * / tug-2 * e1 * cem-group *
          list cem-group {
            tailf:info "Specify the timeslots to cem-group mapping";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key id;
            leaf id {
              type uint16 {
                tailf:info "<0-65535>;;Channel number";
              }
            }

            // controller SONET * / au-4 * tug-3 * / tug-2 * e1 * cem-group * unframed
            leaf unframed {
              tailf:info "Unframed in the cem group";
              tailf:cli-full-command;
              type empty;
            }

            // controller SONET * / au-4 * tug-3 * / tug-2 * e1 * cem-group * timeslots
            leaf-list timeslots {
              tailf:info "List of timeslots in the cem group";
              tailf:cli-range-list-syntax;
              tailf:cli-remove-before-change;
              tailf:cli-full-command;
              type uint8 {
                tailf:info "<1-31>;List of timeslots which comprise the channel";
                range "1..31";
              }
            }
          }

          // controller SONET * / au-4 * tug-3 * / tug-2 * e1 * framing
          leaf framing {
            tailf:info "Specify the type of Framing on an E1 line";
            type enumeration {
              enum crc4 {
                tailf:info "E1 with CRC";
              }
              enum no-crc4 {
                tailf:info "E1 with no CRC";
              }
              enum unframed {
                tailf:info "No Framing Format";
              }
            }
          }

          // controller SONET * / au-4 * tug-3 * / tug-2 * e1 * unframed
          leaf unframed {
            tailf:info "Unframed E1";
            type empty;
          }

          // controller SONET * / au-4 * tug-3 * / tug-2 * e1 * clock source
          container clock {
            tailf:info "Specify the clock source for Sonet/SDH port";
            leaf source {
              tailf:info "Specify the clock source for Sonet/SDH port";
              tailf:cli-full-command;
              type enumeration {
                enum line {
                  tailf:info "Recovered Clock";
                }
                enum internal {
                  tailf:info "Internal Clock";
                }
              }
            }
          }

          // controller SONET * / au-4 * tug-3 * / tug-2 * e1 * description
          uses description-grouping;
        }
      }
    }

    // controller SONET * / sts-1 * mode sts-3c
    container sts-3c {
      tailf:cli-drop-node-name;
      list sts-1 {
        tailf:info "Specify STS-1 number";
        tailf:cli-mode-name "config-ctrlr-sts3c";
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          type string {
            tailf:info "<sts-1 start> - <sts-1 end>";
          }
        }
        leaf mode {
          tailf:info "mode to configure sts-3c";
          tailf:cli-hide-in-submode;
          type enumeration {
            enum sts-3c {
              tailf:info "to assign set of sts as sts-3c";
            }
          }
        }

        // controller SONET * / sts-1 * mode sts-3c / cem-group ? cep
        container cem-group {
          tailf:info "Specify the timeslots to cem-group mapping";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf id {
            tailf:cli-drop-node-name;
            tailf:cli-remove-before-change;
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<0-5375>;;Channel number";
              range "0..5375";
            }
          }
          leaf cep {
            tailf:info "cep configuration";
            type empty;
          }
        }

        // controller SONET * / sts-1 * mode sts-3c / clock source
        container clock {
          tailf:info "Specify the clock source for a PATH";
          leaf source {
            tailf:info "Specify the clock source for a PATH";
            type enumeration {
              enum line {
                tailf:info "Line Recovered Clock";
              }
              enum internal {
                tailf:info "Internal Clock";
              }
              enum recovered {
                tailf:info "packet recovered Clock";
              }
              enum enhanced {
                tailf:info "enhanced Clock";
              }
            }
          }
        }
      }
    }

    // controller SONET * / sts-1 *
    list sts-1 {
      tailf:info "Specify STS-1 number";
      tailf:cli-mode-name "config-ctrlr-sts1";
      tailf:cli-full-command;
      key id;
      leaf id {
        type uint8 {
          tailf:info "<1-12>;;sts-1 number";
          range "1..12";
        }
      }

      // controller SONET * / sts-1 * / description
      uses description-grouping;

      // controller SONET * / sts-1 * / clock source
      container clock {
        tailf:info "Specify the clock source for a PATH";
        leaf source {
          tailf:info "Specify the clock source for a PATH";
          type enumeration {
            enum line {
              tailf:info "Line Recovered Clock";
            }
            enum internal {
              tailf:info "Internal Clock";
            }
            enum recovered {
              tailf:info "packet recovered Clock";
            }
            enum enhanced {
              tailf:info "enhanced Clock";
            }
          }
        }
      }

      // controller SONET * / sts-1 * / loopback
      container loopback {
        tailf:info "Put the STS-1 Sonet/SDH line into loopback";
        choice loopback-choice {
          container local {
            tailf:info "Local loopback";
            presence true;
          }
          container network {
            tailf:info "Network line loopback";
            tailf:cli-delete-when-empty;
            tailf:cli-reset-container;
            presence true;
            leaf line {
              tailf:info "T1 line loopback toward network";
              type empty;
            }
          }
        }
      }

      // controller SONET * / sts-1 * / cem-group
      container cem-group {
        tailf:info "Specify the timeslots to cem-group mapping";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf id {
          tailf:cli-drop-node-name;
          tailf:cli-remove-before-change;
          tailf:cli-incomplete-command;
          tailf:cli-diff-dependency "../../mode";
          type uint16 {
            tailf:info "<0-5375>;;Channel number";
            range "0..5375";
          }
        }
        leaf unframed {
          tailf:info "Unframed in the cem group";
          tailf:cli-optional-in-sequence;
          type empty;
        }
        leaf cep {
          tailf:info "cep configuration";
          type empty;
        }
      }

      // controller SONET * / sts-1 * / t3
      container t3 {
        tailf:info "t3 configuration";
        when "../mode/t3" {
          tailf:dependency "../mode/t3";
        }
        tailf:cli-diff-dependency "../mode/t3";

        // controller SONET * / sts-1 * / t3 framing
        // note: Not modelled, can't be modified(?)

        // controller SONET * / sts-1 * / t3 clock source
        container clock {
          tailf:info "Specify the clock source for a T3 link";
          leaf source {
            tailf:info "Specify the clock source for a T3 link";
            type enumeration {
              enum line {
                tailf:info "Line Recovered Clock";
              }
              enum internal {
                tailf:info "Internal Clock";
              }
              enum recovered {
                tailf:info "Recovered Clock";
              }
            }
          }
        }
      }

      // controller SONET * / sts-1 * / vtg
      list vtg {
        tailf:info "vt-15 configuration";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        when "../mode/vt-15" {
          tailf:dependency "../mode/vt-15";
        }
        tailf:cli-diff-dependency "../mode/vt-15";
        key "id t1";
        leaf id {
          type uint8 {
            tailf:info "<1-7>;;vtg number <1-7>";
          }
        }
        leaf t1 {
          tailf:cli-expose-key-name;
          tailf:info "T1 line configuration";
          type uint8 {
            tailf:info "<1-4>;;t1 line number <1-4>";
          }
        }

        // controller SONET * / sts-1 * / vtg * t1 * description
        leaf description {
          tailf:info "Controller specific description";
          tailf:cli-multi-value;
          tailf:cli-preformatted;
          tailf:cli-full-command;
          type string {
            tailf:info "LINE;;Up to 80 characters describing this interface";
          }
        }

        // controller SONET * / sts-1 * / vtg * t1 * Loopback
        container Loopback {
          tailf:info "Put the T1/VT line into loopback";
          choice loopback-choice {
            leaf Local {
              tailf:info "Loopback locally at the T1/VT framer";
              cli:parse-alt-name "local";
              type empty;
            }
            container Network {
              tailf:info "T1 loopback toward network";
              tailf:cli-delete-when-empty;
              tailf:cli-reset-container;
              cli:parse-alt-name "network";
              presence true;
              leaf line {
                tailf:info "T1 loopback toward network";
                type empty;
              }
            }
          }
        }

        // controller SONET * / sts-1 * / vtg * t1 * framing
        leaf framing {
          tailf:info "Specify the type of Framing on a T1";
          type enumeration {
            enum ESF {
              tailf:info "Extended Superframe Framing Format";
            }
            enum SF {
              tailf:info "Superframe Framing Format";
            }
            enum unframed {
            }
          }
          default ESF;
        }

        // controller SONET * / sts-1 * / vtg * t1 * cem-group
        container cem-group {
          tailf:info "Specify the timeslots to cem-group mapping";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf id {
            tailf:cli-drop-node-name;
            tailf:cli-remove-before-change;
            tailf:cli-incomplete-command;
            tailf:cli-diff-dependency "../../framing";
            type uint16 {
              tailf:info "<0-5375>;;Channel number";
            }
          }
          leaf unframed {
            tailf:info "Unframed in the cem group";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          leaf-list timeslots {
            tailf:info "List of timeslots in the channel group";
            tailf:cli-range-list-syntax;
            tailf:cli-remove-before-change;
            type uint8 {
              tailf:info "<1-24>;;List of timeslots which comprise the channel";
              range "1..24";
            }
          }
        }

        // controller SONET * / sts-1 * / vtg * t1 * channel-group * timeslots
        list channel-group {
          tailf:info "Specify the timeslots to channel-group mapping for an T1 interface";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          key id;
          leaf id {
            type uint8 {
              tailf:info "<0-23>;;Channel group number";
            }
          }
          leaf-list timeslots {
            tailf:info "List of timeslots in the channel group";
            tailf:cli-range-list-syntax;
            tailf:cli-remove-before-change;
            type uint8 {
              tailf:info "<1-24>;;List of timeslots which comprise the channel";
              range "1..24";
            }
          }
        }
      }

      // controller SONET * / sts-1 * / mode
      container mode {
        tailf:info "Specify path operation mode";
        choice mode-choice {
          leaf ct3 {
            tailf:info "Mode CT3";
            type empty;
          }
          leaf ct3-e1 {
            tailf:info "Mode CT3-E1";
            type empty;
          }
          leaf t3 {
            tailf:info "Mode T3";
            type empty;
          }
          leaf unframed {
            tailf:info "Mode UNFRAMED";
            type empty;
          }
          leaf vt-15 {
            tailf:info "Mode VT-15";
            type empty;
          }
          leaf vt-2 {
            tailf:info "MODE VT-2";
            type empty;
          }
        }
      }
    }

    // controller SONET * / aps
    container aps {
      tailf:info "Modify APS parameters";

      // controller SONET * / aps group
      container group {
        tailf:info "Group association";
        leaf value {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<0-255>;;group number";
          }
        }

        // controller SONET * / aps group acr
        leaf acr {
          tailf:info "ACR Group Configuration";
          type uint8 {
            tailf:info "<1-255>;;acr number";
            range "1..255";
          }
        }
      }

      // controller SONET * / aps working
      leaf working {
        tailf:info "Working channel number";
        type uint8 {
          tailf:info "<1-1>;;channel";
        }
      }

      // controller SONET * / aps timers
      container timers {
        tailf:info "APS timers";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf seconds1 {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<1-255>;;Hello interval";
            range "1..255";
          }
        }
        leaf seconds2 {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<1-255>;;Holdtime";
            range "1..255";
          }
        }
        leaf seconds3 {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-600>;;Hello fail revert interval";
            range "1..600";
          }
        }
      }

      // controller SONET * / aps authentication
      leaf authentication {
        tailf:info "Authentication string";
        type string {
          tailf:info "WORD;;authentication string";
        }
      }

      // controller SONET * / aps hspw-icrm-grp
      leaf hspw-icrm-grp {
        tailf:info "HSPW interchassis group number to associate this aps group";
        type uint32 {
          tailf:info "<1-4294967295>;;ICRM group number";
          range "1..4294967295";
        }
      }

      // controller SONET * / aps protect *
      list protect {
        tailf:info "Protect specified circuit";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          type uint8 {
            tailf:info "<1-1>;;channel";
          }
        }
        leaf address {
          tailf:cli-drop-node-name;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;channel's router address";
          }
        }
      }
    }
  }


  // mls rate-limit *
  // mls rate-limit unicast
  grouping mls-rate-limit-grouping {
    leaf pps {
      tailf:cli-drop-node-name;
      tailf:cli-no-value-on-delete;
      type uint32 {
        tailf:info "<0|10-1000000>;;packets per second";
        range "0|10..1000000";
      }
    }
    leaf packets-in-burst {
      tailf:cli-drop-node-name;
      tailf:cli-no-value-on-delete;
      type uint8 {
        tailf:info "<1-255>;;packets in burst";
        range "1..255";
      }
    }
  }


  // ap dot11 24ghz
  // ap dot11 5ghz
  grouping ap-dot11-ghz-grouping {

    // ap dot11 * shutdown
    leaf shutdown {
      tailf:info "Disable 802.11 network";
      type empty;
    }

    // ap dot11 * rrm
    container rrm {
      tailf:info "Radio resource management";

      // ap dot11 * rrm monitor
      container monitor {
        tailf:info "802.11b statistics monitoring";

        // ap dot11 * rrm monitor channel-list
        leaf channel-list {
          tailf:info "Sets the 802.11b noise/interference/rogue monitoring channel-list";
          type enumeration {
            enum all {
              tailf:info "Monitor all channels";
            }
            enum country {
              tailf:info "Monitor channels used in configured country code";
            }
            enum dca {
              tailf:info "Monitor channels used by dynamic channel assignment";
            }
          }
          default country;
        }
      }

      // ap dot11 * rrm channel
      container channel {
        tailf:info "Configure advanced 802.11 channel assignment parameters";

        // ap dot11 * rrm channel cleanair-event
        leaf cleanair-event {
          tailf:info "Configure cleanair event-driven RRM parameters";
          type empty;
        }

        // ap dot11 * rrm channel cleanair-event X
        container cleanair-event-conf {
          tailf:cli-drop-node-name;
          container cleanair-event {
            tailf:info "Configure cleanair event-driven RRM parameters";
            tailf:cli-incomplete-command;
            tailf:cli-incomplete-no;

            // ap dot11 * rrm channel cleanair-event sensitivity
            leaf sensitivity {
              tailf:info "Set sensitivity for cleanair event-driven RRM";
              type enumeration {
                enum low {
                  tailf:info "Event-driven RRM sensitivity threshold";
                }
                enum medium {
                  tailf:info "Event-driven RRM sensitivity threshold";
                }
                enum high {
                  tailf:info "Event-driven RRM sensitivity threshold";
                }
                enum custom {
                  tailf:info "Event-driven RRM sensitivity threshold";
                }
              }
            }
          }
        }

        // ap dot11 * rrm channel dca *
        list dca {
          tailf:info "Config 802.11b dynamic channel assignment algorithm parameters";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key id;
          leaf id {
            type uint8 {
              tailf:info "<1-255>;;This command has been deprecated. please use 'dca add/remove *channel-value*' instead";
            }
          }
          leaf action {
            tailf:cli-drop-node-name;
            tailf:cli-prefix-key;
            tailf:cli-remove-before-change;
            type enumeration {
              enum add {
                tailf:info "Add 802.11b DCA channels to RRM allowed channel list";
              }
              enum remove {
                tailf:info "Remove 802.11b DCA channels from RRM allowed channel list";
              }
            }
          }
        }

        // ap dot11 * rrm channel dca
        container dca-conf {
          tailf:cli-drop-node-name;
          container dca {
            tailf:info "Config 802.11b dynamic channel assignment algorithm parameters";

            // ap dot11 * rrm channel dca chan-width
            container chan-width {
              tailf:info "Configure channel width for 802.11 radios";

              // ap dot11 * rrm channel dca chan-width width-max
              leaf width-max {
                tailf:info "Configure Max Best Channel Width Allowed for Dynamic Bandwidth Selection";
                type string {
                  tailf:info "WORD;;WIDTH_XXX";
                }
              }

              // ap dot11 * rrm channel dca chan-width
              leaf value {
                tailf:cli-drop-node-name;
                type enumeration {
                  enum 20 {
                    tailf:info "Channel width in Mhz";
                  }
                  enum 40 {
                    tailf:info "Channel width in Mhz";
                  }
                  enum 80 {
                    tailf:info "Channel width in Mhz";
                  }
                  enum 80+80 {
                    tailf:info "Channel width in Mhz";
                  }
                  enum 160 {
                    tailf:info "Channel width in Mhz";
                  }
                  enum best {
                    tailf:info "Enter the DCA Channel width";
                  }
                }
                default best;
              }
            }

            // ap dot11 * rrm channel dca interval
            leaf interval {
              tailf:info "Configure DCA interval value";
              type uint8 {
                tailf:info "<0-24>;;Valid values 1,2,3,4,6,8,12 and 24 hours, 0 = 10 minutes (default)";
              }
              default 0;
            }
          }
        }
      }

      // ap dot11 * rrm txpower
      container txpower {
        tailf:info "Configure the 802.11a Tx Power Level";

        // ap dot11 * rrm txpower max
        leaf max {
          tailf:info "Configures maximum auto-RF tx power";
          type int8 {
            tailf:info "<-10 - 30>;;Enter value in dBm";
          }
        }

        // ap dot11 * rrm txpower min
        leaf min {
          tailf:info "Configures minimum auto-RF tx power";
          type int8 {
            tailf:info "<-10 - 30>;;Enter value in dBm";
          }
        }
      }

      // ap dot11 * rrm tpc
      container tpc {
        tailf:info "Configures the Tx Power Control Threshold used by RRM";

        // ap dot11 * rrm tpc threshold
        leaf threshold {
          tailf:info "Configures the Tx Power Control Threshold used by RRM for auto power assignment";
          type int8 {
            tailf:info "<-80 - -50>;;Enter value in dBm";
          }
        }
      }
    }

    // ap dot11 * beamforming
    leaf beamforming {
      tailf:info "Enable/Disable 802.11b tx beamforming - 2.4 GHz";
      type empty;
    }

    // ap dot11 * cac
    container cac {
      tailf:info "Configure Call Admision Control parameters for 802.11b radios";

      // ap dot11 * cac voice
      container voice {
        tailf:info "Configure CAC parameters for voice access category";

        // ap dot11 * cac voice sip
        container sip {
          tailf:info "SIP based CAC for non-TSPEC SIP clients";
          presence true;
        }

        // ap dot11 * cac voice acm
        leaf acm {
          tailf:info "Enable admission control on voice access category";
          type empty;
        }
      }
    }

    // ap dot11 * exp-bwreq
    leaf exp-bwreq {
      tailf:info "Enable 802.11a Expedited BW Request support";
      type empty;
    }

    // ap dot11 * tsm
    leaf tsm {
      tailf:info "Enable 802.11a traffic stream metrics support";
      type empty;
    }

    // ap dot11 * edca-parameters
    leaf edca-parameters {
      tailf:info "Configure 802.11a EDCA (Enhanced Distributed Channel Access) parameters";
      type enumeration {
        enum custom-voice {
          tailf:info "Enable Custom Voice parameters for 802.11a";
        }
        enum fastlane {
                       tailf:info "Enable Fastlane parameters for 802.11a";
        }
        enum optimized-video-voice {
          tailf:info "Enable combined video-voice-optimized parameters for 802.11a";
        }
        enum optimized-voice {
          tailf:info "Enable non-spectralink voice-optimized parameters for 802.11a";
        }
        enum svp-voice {
          tailf:info "Enable SpectraLink Voice Priority (SVP) parameters for 802.11a";
        }
        enum wmm-default {
          tailf:info "Enable WMM default parameters for 802.11a";
        }
      }
      default wmm-default;
    }

    // ap dot11 * channelswitch quiet
    container channelswitch-conf {
      tailf:cli-drop-node-name;
      container channelswitch {
        tailf:info "Configures the 802.11h channel switch announcement";
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        leaf quiet {
          tailf:info "802.11h channel switch quiet mode";
          type empty;
        }
      }
    }

    // ap dot11 * rate *
    list rate {
      tailf:info "Configures 802.11 operational rates.";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Name of 802.11 Rate, e.g. RATE_11M";
          pattern 'RATE_.+';
        }
      }
      leaf mode {
        tailf:cli-drop-node-name;
        type enumeration {
          enum disable {
            tailf:info "Disables a rate.";
          }
          enum mandatory {
            tailf:info "Configures a rate to mandatory.";
          }
          enum supported {
            tailf:info "Configures a rate to supported.";
          }
        }
      }
    }

    // ap dot11 * rf-profile *
    list rf-profile {
      tailf:info "Sets the RF-Profile Name";
      tailf:cli-mode-name "config-rf-profile";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Specify the name of the RF profile to configure.";
        }
      }

      // ap dot11 * rf-profile * / channel
      container channel {
        tailf:info "Configures the RF Profile DCA settings";

        // ap dot11 * rf-profile * / channel add *
        list add {
          tailf:info "Adds channel to the RF Profile DCA channel list";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key id;
          leaf id {
            type uint8 {
              tailf:info "<1-14>;;Enter channel number to be added to the DCA allowed channel list";
            }
          }
        }

        // ap dot11 * rf-profile * / channel remove *
        list remove {
          tailf:info "Removes channel from the RF Profile DCA channel list";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-diff-delete-before "../add";
          key id;
          leaf id {
            type uint8 {
              tailf:info "<1-14>;;Enter channel number to be added to the DCA remove channel list";
            }
          }
        }

        // ap dot11 * rf-profile * / channel chan-width
        leaf chan-width {
          tailf:info "Configures the RF Profile DCA channel width";
          type enumeration {
            enum 20 {
              tailf:info "Enter the DCA Channel width";
            }
            enum 40 {
              tailf:info "Enter the DCA Channel width";
            }
            enum 80 {
              tailf:info "Enter the DCA Channel width";
            }
            enum 80+80 {
              tailf:info "Enter the DCA Channel width";
            }
            enum 160 {
              tailf:info "Enter the DCA Channel width";
            }
            enum best {
              tailf:info "Enter the DCA Channel width";
            }
          }
          default best;
        }
      }

      // ap dot11 * rf-profile * / client-network-preference
      leaf client-network-preference {
        tailf:info "Configures Client Network Preference";
        type enumeration {
          enum connectivity {
            tailf:info "Preference on Connectivity";
          }
          enum default {
            tailf:info "No Client Network Preference Applied";
          }
          enum throughput {
            tailf:info "Preference on Throughput";
          }
        }
        default default;
      }

      // ap dot11 * rf-profile * / coverage
      container coverage {
        tailf:info "Configures the RF Profile Coverage";

        // ap dot11 * rf-profile * / coverage data rssi threshold
        container data {
          tailf:info "Configure Coverage Hole Detection for data packets";
          container rssi {
            tailf:info "Set RSSI thresholds";
            leaf threshold {
              tailf:info "configure Minimum RSSI value for data packets received by the access point";
              type int8 {
                tailf:info "<-90 - -60>;;Enter value in dBm";
              }
            }
          }
        }

        // ap dot11 * rf-profile * / coverage level
        leaf level {
          tailf:info "Sets Cisco AP client minimum exception level";
          type uint8 {
            tailf:info "<1 - 200>;;Minimum exception level between 1 and 200 clients";
            range "1..200";
          }
        }

        // ap dot11 * rf-profile * / coverage voice rssi threshold
        container voice {
          tailf:info "Configure Coverage Hole Detection for voice packets";
          container rssi {
            tailf:info "Set RSSI thresholds";
            leaf threshold {
              tailf:info "configure Minimum RSSI value for voice packets received by the access point";
              type int8 {
                tailf:info "<-90 - -60>;;Enter value in dBm";
              }
            }
          }
        }

        // ap dot11 * rf-profile * / coverage exception
        leaf exception {
          tailf:info "Sets Cisco AP coverage exception level";
          type uint8 {
            tailf:info "<0-100>;;Cisco AP coverage exception level between 0 and 100 percent";
          }
        }
      }

      // ap dot11 * rf-profile * / description
      leaf description {
        tailf:info "Add a description";
        type string {
          tailf:info "WORD;;Description";
        }
      }

      // ap dot11 * rf-profile * / high-density
      container high-density {
        tailf:info "Configures the RF Profile High Density";

        // ap dot11 * rf-profile * / high-density rx-sop threshold
        container rx-sop {
          tailf:info "Configures the RF Profile Rx SOP threshold";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf threshold {
            tailf:info "Configures the value for RF Profile Rx SOP threshold";
            type enumeration {
              enum auto {
                tailf:info "Reverts radio receiver SOP to auto";
              }
              enum custom {
                tailf:info "Sets radio receiver SOP to custom";
              }
              enum low {
                tailf:info "Sets radio receiver SOP to low";
              }
              enum medium {
                tailf:info "Sets radio receiver SOP to medium";
              }
              enum high {
                tailf:info "Sets radio receiver SOP to high";
              }
            }
          }
          leaf value {
            tailf:cli-drop-node-name;
            when "../threshold = 'custom'";
            type int8 {
              tailf:info "<-85 - -60>;;Enter Rx SOP value in dBm";
            }
          }
        }
      }

      // ap dot11 * rf-profile * / tx-power
      container tx-power {
        tailf:info "Configures Tx Power levels.";

        // ap dot11 * rf-profile * / tx-power max
        leaf max {
          tailf:info "Configures maximum Auto-RF transmit power";
          type int8 {
            tailf:info "<-10 - 30>;;Enter value in dBm";
          }
        }

        // ap dot11 * rf-profile * / tx-power min
        leaf min {
          tailf:info "Configures maximum Auto-RF transmit power";
          type int8 {
            tailf:info "<-10 - 30>;;Enter value in dBm";
          }
        }

        // ap dot11 * rf-profile * / tx-power v1 threshold
        container v1 {
          tailf:info "Configures Transmit Power Control version 1";
          leaf threshold {
            tailf:info "Configures TPCv1 Threshold.";
            type int8 {
              tailf:info "<-80 - -50>;;Enter value in dBm";
            }
          }
        }
      }

      // ap dot11 * rf-profile * / rate *
      list rate {
        tailf:info "Configures 802.11 operational rates.";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          tailf:cli-incomplete-command;
          type string {
            tailf:info "WORD;;Name of 802.11 Rate, e.g. RATE_11M";
            pattern 'RATE_.+';
          }
        }
        leaf mode {
          tailf:cli-drop-node-name;
          type enumeration {
            enum disable {
              tailf:info "Disables a rate.";
            }
            enum mandatory {
              tailf:info "Configures a rate to mandatory.";
            }
            enum supported {
              tailf:info "Configures a rate to supported.";
            }
          }
        }
      }

      // ap dot11 * rf-profile * / no shutdown
      leaf shutdown {
        tailf:info "Shuts down the profile and disables network";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }
    }
  }


  grouping bfd-template-grouping {
    // bfd-template single-hop * / interval
    container interval {
      tailf:info "Transmit interval between BFD packets";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf min-tx {
        tailf:info "Minimum transmit interval capability";
        tailf:cli-incomplete-command;
        type uint16 {
          tailf:info "<4-9999>;;Milliseconds";
          range "4..9999";
        }
      }
      leaf min-rx {
        tailf:info "Minimum receive interval capability";
        tailf:code-name "bfd-template-min-rx";
        type uint16 {
          tailf:info "<4-9999>;;Milliseconds";
          range "4..9999";
        }
      }
      leaf multiplier {
        tailf:info "Multiplier value used to compute holddown";
        type uint8 {
          tailf:info "<3-50>;;value used to multiply the interval";
          range "3..50";
        }
      }
    }
    // bfd-template single-hop * / echo
    leaf echo {
      tailf:info "Use echo adjunct as bfd detection mechanism";
      type empty;
    }
  }


  // l2 vfi * / neighbor * /
  // l2 vfi * / neighbor * * /
  grouping l2-vfi-grouping {
    // l2 vfi * / neighbor * * encapsulation
    // l2 vfi * / neighbor * * pw-class
    choice neighbor-choice {
      leaf encapsulation {
        tailf:info "Connection encapsulation type";
        tailf:cli-optional-in-sequence;
        tailf:cli-hide-in-submode;
        type enumeration {
          enum mpls {
            tailf:info "Use MPLS encapsulation";
          }
          enum l2tpv3 {
            tailf:info "Use L2TPv3 encapsulation";
          }
        }
      }
      leaf pw-class {
        tailf:info "Pseudowire-class configuration";
        tailf:cli-hide-in-submode;
        tailf:non-strict-leafref {
          path "/ios:pseudowire-class/name";
        }
        type string {
          tailf:info "WORD;;Pseudowire-class name";
        }
      }
    }

    // l2 vfi * / neighbor * * no-split-horizon
    leaf no-split-horizon {
      tailf:info "Disable split-horizon forwarding";
      tailf:cli-hide-in-submode;
      type empty;
    }

    // l2 vfi * / neighbor * * / mpls
    container mpls {
      tailf:info "MPLS manual configuration commands";
      when "../pw-class";

      // l2 vfi * / neighbor * * / mpls control-word
      // l2 vfi * / neighbor * * / no mpls control-word
      leaf control-word {
        tailf:info "Include control-word in pseudowire packets";
        tailf:cli-show-no;
        type empty;
      }

      // l2 vfi * / neighbor * * / mpls label
      container label {
        tailf:info "MPLS local and remote pseudowire labels";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf local {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "NUM;;Local pseudowire label";
          }
        }
        leaf remote {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "NUM;;Remote pseudowire label";
          }
        }
      }
    }
  }

  // interface Bundle*
  // interface Bundle#.#
  grouping bundle-interface-cable-common {

    // interface Bundle* / no cable nd
    leaf nd {
      tailf:info "Enable IPv6 ND gleaning";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
      default true;
    }

    // no cable arp
    container conf {
      tailf:cli-drop-node-name;
      leaf arp {
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }
    }

    // interface Bundle* / no cable proxy-arp
    leaf proxy-arp {
      tailf:info "Enable proxy arp";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
      default true;
    }

    // interface Bundle* / cable source-verify
    leaf source-verify {
      tailf:info "Enable verification of source of packets";
      tailf:cli-full-command;
      type empty;
    }

    // interface Bundle* / cable source-verify X
    container source-verify-conf {
      tailf:cli-drop-node-name;
      container source-verify {
        tailf:info "Enable verification of source of packets";
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;

        // interface Bundle* / cable source-verify dhcp
        container dhcp {
          tailf:info "Verify address with the DHCPv4 server";
          presence true;
          leaf server {
            tailf:info "Specify the lease query server where the DHCPv4 lease queries should be sent";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IPv4 Address of the lease query server";
            }
          }
        }

        // interface Bundle* / cable source-verify leasequery-filter upstream
        container leasequery-filter {
          tailf:info "Filter x IPv4 lease query requests every y seconds or none";
          container upstream {
            tailf:info "Lease query for upstream pkts";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf threshold {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint8 {
                tailf:info "<0-20>;;Number of IPv4 lease queries per sid";
                range "0..20";
              }
            }
            leaf interval {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<1-5>;;size of time window in seconds for IPv4";
                range "1..5";
              }
            }
          }
        }

        // interface Bundle* / cable source-verify leasetimer
        leaf leasetimer {
          tailf:info "Specify the IPv4 lease timer value";
          type uint8 {
            tailf:info "<1-240>;;IPv4 Time in minutes";
            range "1..240";
          }
        }
      }
    }

    // interface Bundle* / cable ipv6
    container ipv6 {
      tailf:info "IPv6 related configuration";

      // interface Bundle* / cable ipv6 source-verify
      container source-verify {
        tailf:info "Enable verification of source of IPv6 packets";

        // interface Bundle* / cable ipv6 source-verify dhcp
        container dhcp {
          tailf:info "Verify address with the DHCPv6 server";
          presence true;
          leaf server {
            tailf:info "Specify the lease query server where the DHCPv6 lease queries should be sent";
            type inet:ipv6-address {
              tailf:info "X:X:X:X::X;;IPv6 Address of the lease query server";
            }
          }
        }

        // interface Bundle* / cable ipv6 source-verify leasequery-filter upstream
        container leasequery-filter {
          tailf:info "Filter x IPv6 lease query requests every y seconds or none";
          container upstream {
            tailf:info "IPv6 Lease query for upstream pkts";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf threshold {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint8 {
                tailf:info "<0-20>;;Number of IPv6 lease queries per sid";
                range "0..20";
              }
            }
            leaf interval {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<1-5>;;size of time window in seconds for IPv6";
                range "1..5";
              }
            }
          }
        }

        // interface Bundle* / cable ipv6 leasetimer
        leaf leasetimer {
          tailf:info "Specify the IPv6 lease timer value";
          type uint8 {
            tailf:info "<1-240>;;IPv6 Time in minutes";
            range "1..240";
          }
        }
      }
    }

    // interface Bundle* / cable dhcp-giaddr
    container dhcp-giaddr {
      tailf:info "Control of giaddr in relayed DHCP requests";
      choice dhcp-giaddr-choice {
        container policy {
          tailf:info "Use primary address for CMs, secondary addresses for hosts";
          presence true;
        }
        leaf primary {
          tailf:info "Use primary address for all devices";
          type empty;
        }
      }
    }

    // interface Bundle* / cable helper-address *
    list helper-address {
      tailf:info "Specify a destination address for UDP broadcasts";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key IP-address;
      leaf IP-address {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;IP destination address";
        }
      }
    }
  }

  // ip sla reaction-configuration * react *
  // ip sla ethernet-monitor reaction-configuration * react *
  grouping ip-sla-reaction-grouping {

    container threshold-value {
      tailf:cli-break-sequence-commands;
      tailf:info "Threshold value";
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf upper-threshold {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<1-60000>;;Upper limit for Threshold";
        }
      }
      leaf lower-threshold {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<1-60000>;;Lower limit for Threshold";
        }
      }
    }

    container threshold-type {
      tailf:info "Threshold Type";
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      choice threshold-type-choice {
        // ip sla reaction-configuration * threshold-type average N
        case average {
          leaf average {
            tailf:info "Average over N attempts";
            tailf:cli-incomplete-command;
            tailf:cli-incomplete-no;
            type empty;
          }
          leaf n {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-16>;;N Value";
              range "1..16";
            }
          }
        }

        // ip sla reaction-configuration * threshold-type average
        container average-no-n {
          tailf:cli-drop-node-name;
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          leaf average {
            tailf:info "Average over N attempts";
            type empty;
          }
        }

        // ip sla reaction-configuration * threshold-type consecutive
        case consecutive {
          leaf consecutive {
            tailf:info "Consecutive occurrences";
            type empty;
          }
          leaf number {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-16>;;Number of occurrences";
              range "1..16";
            }
            default 5;
          }
        }

        // ip sla reaction-configuration * threshold-type immediate
        leaf immediate {
          tailf:info "React immediately";
          type empty;
        }

        // ip sla reaction-configuration * threshold-type never
        leaf never {
          tailf:info "Never react";
          type empty;
        }

        // ip sla reaction-configuration * threshold-type xOfy
        container xOfy {
          tailf:info "X out of Y occurrences";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf x {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<1-16>;;X Value";
              range "1..16";
            }
          }
          leaf y {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-16>;;Y Value";
              range "1..16";
            }
          }
        }
      }
    }

    leaf action-type {
      tailf:info "IP SLAs Reaction Action Type";
      type enumeration {
        enum none {
          tailf:info "No action";
        }
        enum trapAndTrigger {
          tailf:info "Trap and Trigger action";
        }
        enum trapOnly {
          tailf:info "Trap Only action";
        }
        enum triggerOnly {
          tailf:info "Trigger Only action";
        }
      }
      default none;
    }
  }

  // segment-routing mpls / connected-prefix-sid-map / address-family ipv4 / *
  // segment-routing mpls / connected-prefix-sid-map / address-family ipv4 strict-spf / *
  // segment-routing mpls / connected-prefix-sid-map / address-family ipv4 algorithm * / *
  grouping sr-connected-prefix-sid-map-af-grouping {
    list address-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              tailf:cli-incomplete-command;
              key prefix;
              leaf prefix {
                type ios:ipv4-prefix {
                  tailf:info "A.B.C.D/nn;;Starting Prefix";
                }
              }
              choice absolute-or-index {
                leaf absolute {
                  tailf:info "SID Absolute";
                  type uint32 {
                    tailf:info "<0-1048575>;;Start of SID";
                    range "0..1048575";
                  }
                }
                leaf index {
                  tailf:info "SID Index";
                  type uint32 {
                    tailf:info "<0-1048575>;;Start of SID";
                    range "0..1048575";
                  }
                }
              }
              leaf range {
                tailf:info "Set # of SIDs in range";
                type uint32 {
                  tailf:info "<1-1048575>;;Range value";
                  range "1..1048575";
                }
              }
            }

  }

  // segment-routing traffic-eng / policy * / candidate-paths / preference *
  // segment-routing traffic-eng / on-demand color * / candidate-paths / preference *
  grouping segment-routing-preference-grouping {

    // segment-routing traffic-eng / on-demand color * / candidate-paths / preference * / explicit segment-list *
    container explicit {
      tailf:info "Preconfigured path";
      list segment-list {
        tailf:info "Specify Segment-list";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key name;
        leaf name {
          tailf:non-strict-leafref {
            path "/ios:segment-routing/traffic-eng/segment-list/name/name";
          }
          type string {
            tailf:info "WORD;;Identifying name for Segment-list";
          }
        }
        leaf weight {
          tailf:info "Path option weight";
          type uint32 {
            tailf:info "<1-4294967295>;;Weight";
            range "1..4294967295";
          }
        }
      }
    }

    // segment-routing traffic-eng / on-demand color * / candidate-paths / preference * / description
    uses description-grouping;

    // segment-routing traffic-eng / on-demand color * / candidate-paths / preference * / constraints
    container constraints {
      tailf:info "Constraints configuration";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-srte-odn-path-pref-constr";
      presence true;

      // segment-routing traffic-eng / on-demand color * / candidate-paths / preference * / constraints / bandwidth
      leaf bandwidth {
        tailf:info "set bandwidth for the preference";
        type uint32 {
          tailf:info "<1-4294967295>;;Bandwidth value in kbps";
          range "1..4294967295";
        }
      }

      // segment-routing traffic-eng / on-demand color * / candidate-paths / preference * / constraints / segments
      container segments {
        tailf:info "Segments constraints";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-srte-odn-path-pref-constr-seg";

        // segment-routing traffic-eng / on-demand color * / candidate-paths / preference * / constraints / segments / dataplane mpls
        container dataplane {
          tailf:info "Dataplane type";
          leaf mpls {
            tailf:info "Specify MPLS dataplane";
            type empty;
          }
        }

        // segment-routing traffic-eng / on-demand color * / candidate-paths / preference * / constraints / segments / type
        leaf type {
          tailf:info "Specify segment type configuration";
          type enumeration {
            enum protected {
              tailf:info "Protected Segment";
            }
            enum unprotected {
              tailf:info "Unprotected Segment";
            }
          }
        }

        // segment-routing traffic-eng / on-demand color * / candidate-paths / preference * / constraints / segments / algorithm
        leaf algorithm {
          tailf:info "Specify algorithm";
          type uint8 {
            tailf:info "<128-255>;;Algorithm number";
            range "128..255";
          }
        }
      }

      // segment-routing traffic-eng / on-demand color * / candidate-paths / preference * / constraints / affinity
      container affinity {
        tailf:info "Assign affinities to path";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-srte-odn-path-pref-constr-aff";

        // segment-routing traffic-eng / on-demand color * / candidate-paths / preference * / constraints / affinity / *
        list attribute-list {
          tailf:cli-drop-node-name;
          tailf:cli-mode-name "config-srte-odn-path-pref-constr-aff-attr";
          tailf:cli-full-command;
          key id;
          leaf id {
            type enumeration {
              enum exclude-any {
                tailf:info "Affinity attributes to exclude - presence of at least one excludes link";
              }
              enum include-all {
                tailf:info "Affinity attributes - all must be included";
              }
              enum include-any {
                tailf:info "Affinity attributes - at least one must be included";
              }
            }
          }

          // segment-routing traffic-eng / on-demand color * / candidate-paths / preference * / constraints / affinity / * / name *
          list name {
            tailf:info "Affinity color name";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;Affinity color name";
              }
            }
          }
        }
      }

      // segment-routing traffic-eng / on-demand color * / candidate-paths / preference * / constraints / association-group
      container association-group {
        tailf:info "Association group constraints";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-srte-odn-path-pref-constr-asso";

        // segment-routing traffic-eng / on-demand color * / candidate-paths / preference * / constraints / association-group / identifier
        leaf identifier {
          tailf:info "Association group identifier";
          type uint16 {
            tailf:info "<1-65535>;;Association group identifier";
            range "1..65535";
          }
        }

        // segment-routing traffic-eng / on-demand color * / candidate-paths / preference * / constraints / association-group / disjointness type
        container disjointness {
          tailf:info "Disjointness parameters";
          leaf type {
            tailf:info "Disjointness type";
            type enumeration {
              enum link {
                         tailf:info "Link Disjointness";
              }
              enum node {
                         tailf:info "Node Disjointness";
              }
              enum srlg {
                         tailf:info "SRLG Disjointness";
              }
            }
          }
        }

        // segment-routing traffic-eng / on-demand color * / candidate-paths / preference * / constraints / association-group / source
        leaf source {
          tailf:info "Association source";
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Enter ipv4 address";
          }
        }
      }
    }

    // segment-routing traffic-eng / on-demand color * / candidate-paths / preference * / dynamic
    container dynamic {
      tailf:info "Dynamic configuration";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-srte-odn-path-pref-dyn";
      presence true;

      // segment-routing traffic-eng / on-demand color * / candidate-paths / preference * / dynamic / pcep
      leaf pcep {
        tailf:info "Use PCE for path calculation";
        type empty;
      }

      // segment-routing traffic-eng / on-demand color * / candidate-paths / preference * / dynamic / metric
      container metric {
        tailf:info "Metric configuration";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-srte-odn-path-pref-dyn-metric";

        // segment-routing traffic-eng / on-demand color * / candidate-paths / preference * / dynamic / metric / type
        leaf type {
          tailf:info "Specify metric type configuration";
          type enumeration {
            enum delay {
              tailf:info "Specify Delay metric";
            }
            enum igp {
              tailf:info "Specify IGP metric";
            }
            enum te {
              tailf:info "Specify TE metric";
            }
          }
        }

        // segment-routing traffic-eng / on-demand color * / candidate-paths / preference * / dynamic / metric / sid-limit
        leaf sid-limit {
          tailf:info "Maximum number of sid's";
          type uint8 {
            tailf:info "<0-255>;;Maximum number of sid's";
          }
        }

        // segment-routing traffic-eng / on-demand color * / candidate-paths / preference * / dynamic / metric / margin
        container margin {
          tailf:info "Margin configuration";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-srte-odn-path-pref-dyn-metric-margin";

          // segment-routing traffic-eng / on-demand color * / candidate-paths / preference * / dynamic / metric / margin / absolute
          leaf absolute {
            tailf:info "Absolute margin";
            type uint32 {
              tailf:info "<0-2147483647>;;Absolute margin";
              range "0..2147483647";
            }
          }

          // segment-routing traffic-eng / on-demand color * / candidate-paths / preference * / dynamic / metric / margin / relative
          leaf relative {
            tailf:info "Relative margin";
            type uint8 {
              tailf:info "<0-100>;;Relative margin";
            }
          }
        }
      }
    }

    // segment-routing traffic-eng / on-demand color * / candidate-paths / preference * / per-flow
    container per-flow {
      tailf:info "Per-flow configuration";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-srte-odn-path-pref-pfp";
      presence true;

      // segment-routing traffic-eng / on-demand color * / candidate-paths / preference * / per-flow / forward-class *
      list forward-class {
        tailf:info "Specify forward class for per-flow based routing";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          type uint8 {
            tailf:info "<0-7>;;Forward-class";
            range "0..7";
          }
        }
        leaf color {
          tailf:info "Specify corresponding policy color for the forwarding class";
          type uint32 {
            tailf:info "<1-4294967295>;;Color";
            range "1..4294967295";
          }
        }
      }
    }
  }


  // ip sla * / distribution delay
  // ip sla * / distribution delay-variation
  grouping ip-sla-distribution-delay-grouping {
    // ip sla * / distribution delay one-way
    container one-way {
      tailf:info "Specify one-way distribution parameters";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf number-of-bins {
        tailf:cli-drop-node-name;
        tailf:cli-remove-before-change;
        tailf:cli-incomplete-command;
        type uint8 {
          tailf:info "<1-10>;;Specify number of bins";
          range "1..10";
        }
      }
      leaf boundary {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "WORD;;Specify a comma separated list of bin upper boundaries in microsec";
        }
      }
    }

    // ip sla * / distribution delay two-way
    container two-way {
      tailf:info "Specify two-way distribution parameters";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf number-of-bins {
        tailf:cli-drop-node-name;
        tailf:cli-remove-before-change;
        tailf:cli-incomplete-command;
        type uint8 {
          tailf:info "<1-10>;;Specify number of bins";
          range "1..10";
        }
      }
      leaf boundary {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "WORD;;Specify a comma separated list of bin upper boundaries in microsec";
        }
      }
    }
  }


  // =========================================================================
  //                        MODEL
  // =========================================================================


  /// ========================================================================
  /// hostname
  /// ========================================================================

  leaf hostname {
    tailf:info "Set system's network name";
    tailf:cli-full-command;
    type string {
      tailf:info "This system's network name";
    }
  }


  /// ========================================================================
  /// upgrade
  /// ========================================================================

  container upgrade {
    tailf:info "Global upgrade configuration subcommands";

    // upgrade fpd
    container fpd {
      tailf:info "Configure field programmable devices upgrade options";
      // upgrade fpd auto
      leaf auto {
        tailf:info "Auto upgrade all FPD images";
        type empty;
      }
      // upgrade fpd path
      leaf path {
        tailf:info "Set path to locate the FPD image package file for auto upgrade";
        type string;
      }
    }
  }


  /// ========================================================================
  /// tailfned
  /// ========================================================================
  /// TAILF NED device info used for device specific support.

  container tailfned {

    // tailfned police
    leaf police {
      tailf:cli-no-value-on-delete;
      type string {
        tailf:info "cirmode | bpsflat | numflat | cirflat";
      }
    }

    // tailfned api
    container api {
      tailf:info "DO NOT MODIFY, contents here are set by ned-settings only";
      leaf new-ip-access-list {
        tailf:info "DO NOT MODIFY, this leaf is set by ned-settings only";
        type empty;
      }
      leaf resequence-access-list {
        tailf:info "DO NOT MODIFY, this leaf is set by ned-settings only";
        type empty;
      }
      leaf new-snmp-server-host {
        tailf:info "DO NOT MODIFY, this leaf is set by ned-settings only";
        type empty;
      }
      leaf expanded-line-vty-format {
        tailf:info "DO NOT MODIFY, this leaf is set by ned-settings only";
        type empty;
      }
      leaf new-mls-qos {
        tailf:info "DO NOT MODIFY, this leaf is set by ned-settings only";
        type empty;
      }
      leaf snmp-server-enable-all-traps {
        tailf:info "DO NOT MODIFY, this leaf is set by ned-settings only";
        type empty;
      }
      leaf new-aaa-list-syntax {
        tailf:info "DO NOT MODIFY, this leaf is set by ned-settings only";
        type empty;
      }
    }

    leaf raw-run {
      type empty;
    }
  }


  /// ========================================================================
  /// version
  /// ========================================================================

  leaf version {
    tailf:info "Version";
    type string {
      tailf:info "WORD;;Version number";
    }
  }


  /// ========================================================================
  /// service
  /// ========================================================================

  container service {
    tailf:info "Modify use of network based services";

    // service config
    leaf config {
      tailf:info "TFTP load config files";
      tailf:cli-full-command;
      type empty;
    }

    // service exec-callback
    leaf exec-callback {
      tailf:info "Enable exec callback";
      tailf:cli-full-command;
      type empty;
    }

    // service nagle
    leaf nagle {
      tailf:info "Enable Nagle's congestion control algorithm";
      tailf:cli-full-command;
      type empty;
    }

    // no service slave-log
    leaf slave-log {
      tailf:info "Enable log capability of slave IPs";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
      default true;
    }

    // service pad cmns
    // service pad from-xot
    // service pad to-xot
    container pad {
      tailf:info "Enable PAD commands";
      tailf:cli-incomplete-no;
      tailf:cli-incomplete-command;
      leaf to-xot {
        tailf:info "Allow outgoing PAD over XOT connections";
        tailf:cli-full-command;
        type empty;
      }
      leaf from-xot {
        tailf:info "Accept XOT to PAD connections";
        tailf:cli-full-command;
        type empty;
      }
      leaf cmns {
        tailf:info "Enable PAD over CMNS connections";
        tailf:cli-full-command;
        type empty;
      }
    }

    // no service pad
    container conf {
      tailf:cli-drop-node-name;
      leaf pad {
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }
    }

    // service tcp-keepalives-in
    leaf tcp-keepalives-in {
      tailf:info "Generate keepalives on idle incoming network connections";
      tailf:cli-full-command;
      type empty;
    }

    // service tcp-keepalives-out
    leaf tcp-keepalives-out {
      tailf:info "Generate keepalives on idle outgoing network connections";
      tailf:cli-full-command;
      type empty;
    }

    // service timestamps
    container timestamps {
      tailf:info "Timestamp debug/log messages";
      tailf:cli-compact-syntax;
      tailf:cli-delete-when-empty;
      presence true;

      // service timestamps debug
      container debug {
        tailf:info "Timestamp debug messages";

        choice timestamp-choice {
          // service timestamps debug uptime
          leaf uptime {
            tailf:info "Timestamp with system uptime";
            type empty;
          }
          // service timestamps debug datetime
          container datetime {
            tailf:info "Timestamp with date and time";
            tailf:cli-compact-syntax;
            tailf:cli-delete-when-empty;
            presence true;
            leaf msec {
              tailf:info "Include milliseconds in timestamp";
              type empty;
            }
            leaf localtime {
              tailf:info "Use local time zone for timestamps";
              type empty;
            }
            leaf show-timezone {
              tailf:info "Add time zone information to timestamp";
              type empty;
            }
            leaf year {
              tailf:info "Include year in timestamp";
              type empty;
            }
          }
        }
      }

      // service timestamps log
      container log {
        tailf:info "Timestamp log messages";

        choice timestamp-choice {
          // service timestamps log uptime
          leaf uptime {
            tailf:info "Timestamp with system uptime";
            type empty;
          }
          // service timestamps log datetime
          container datetime {
            tailf:info "Timestamp with date and time";
            tailf:cli-compact-syntax;
            tailf:cli-delete-when-empty;
            presence true;
            leaf msec {
              tailf:info "Include milliseconds in timestamp";
              type empty;
            }
            leaf localtime {
              tailf:info "Use local time zone for timestamps";
              type empty;
            }
            leaf show-timezone {
              tailf:info "Add time zone information to timestamp";
              type empty;
            }
            leaf year {
              tailf:info "Include year in timestamp";
              type empty;
            }
          }
        }
      }
    }

    // service password-encryption
    container password-encryption {
      tailf:info "Encrypt system passwords";
      tailf:cli-show-no;
      presence true;
    }

    // service password-recovery
    // no service password-recovery
    leaf password-recovery {
      tailf:info "Disable password recovery";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
    }

    // service exec-wait
    leaf exec-wait {
      tailf:info "Delay EXEC startup on noisy lines";
      tailf:cli-full-command;
      type empty;
    }

    // service linenumber
    leaf linenumber {
      tailf:info "enable line number banner for each exec";
      tailf:cli-full-command;
      type empty;
    }

    // service compress-config
    leaf compress-config {
      tailf:info "Compress the configuration file";
      tailf:cli-full-command;
      type empty;
    }

    // service udp-small-servers
    leaf udp-small-servers {
      tailf:info "Enable small UDP servers (e.g., ECHO)";
      tailf:cli-full-command;
      type empty;
    }

    // no service prompt config
    container prompt {
      tailf:info "Enable mode specific prompt (WARNING: will deadlock NED) if set to 'no'";
      leaf config {
        tailf:info "Enable configuration mode prompt";
        tailf:cli-boolean-no;
        type boolean;
        default true;
      }
    }

    // service tcp-small-servers
    leaf tcp-small-servers {
      tailf:info "Enable small TCP servers (e.g., ECHO)";
      tailf:cli-full-command;
      type empty;
    }

    // service old-slip-prompts
    leaf old-slip-prompts {
      tailf:info "Allow old scripts to operate with slip/ppp";
      tailf:cli-full-command;
      type empty;
    }

    // service pt-vty-logging
    leaf pt-vty-logging {
      tailf:info "Log significant VTY-Async events";
      tailf:cli-full-command;
      type empty;
    }

    // service disable-ip-fast-frag
    leaf disable-ip-fast-frag {
      tailf:info "Disable IP particle-based fast fragmentation";
      tailf:cli-full-command;
      type empty;
    }

    // service sequence-numbers
    leaf sequence-numbers {
      tailf:info "Stamp logger messages with a sequence number";
      tailf:cli-full-command;
      type empty;
    }

    // service divert-rate-limit
    container divert-rate-limit {
      tailf:info "Set WAN-side divert-rate-limit parameters";

      // service divert-rate-limit ip *
      list ip {
        tailf:info "WAN-IPv4 configuration";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        key divert-code;
        leaf divert-code {
          type string {
            tailf:info "WORD;;divert code";
          }
        }
        leaf rate {
          tailf:info "rate in packets/sec";
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<1-65535>;;rate in packets/second";
          }
        }
        leaf limit {
          tailf:info "limit in packets";
          type uint16 {
            tailf:info "<4-4194>;;limit in packets";
            range "4..4194";
          }
        }
      }

      // service divert-rate-limit ipv6 *
      list ipv6 {
        tailf:info "WAN-IPv6 configuration";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        key divert-code;
        leaf divert-code {
          type string {
            tailf:info "WORD;;divert code";
          }
        }
        leaf rate {
          tailf:info "rate in packets/sec";
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<1-65535>;;rate in packets/second";
          }
        }
        leaf limit {
          tailf:info "limit in packets";
          type uint16 {
            tailf:info "<4-4194>;;limit in packets";
            range "4..4194";
          }
        }
      }

      // service divert-rate-limit trusted-site *
      list trusted-site {
        tailf:info "trusted-site configuration for WAN-IPv4";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "ip-address mask-ip-address tos mask";
        max-elements 4;
        leaf ip-address {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;source IP address";
          }
        }
        leaf mask-ip-address {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP prefix mask";
          }
        }
        leaf tos {
          tailf:info "ToS value";
          tailf:cli-expose-key-name;
          type string {
            tailf:info "<0-255>;;ToS value";
          }
        }
        leaf mask {
          tailf:info "ToS mask";
          tailf:cli-expose-key-name;
          type string {
            tailf:info "<0-255>;;ToS mask";
          }
        }
        // [ global | vrf vrf-name ]
      }

      // service divert-rate-limit trusted-site-ipv6 *
      list trusted-site-ipv6 {
        tailf:info "trusted-site configuration for WAN-IPv6";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "ip-address traffic-class mask";
        max-elements 4;
        leaf ip-address {
          type ios:ipv6-prefix {
            tailf:info "X:X:X:X::X/<0-128>;;IPv6 Source address/Prefix length.(e.g., 1234::1/<prefix-length>)";
          }
        }
        leaf traffic-class {
          tailf:info "traffic-class value";
          tailf:cli-expose-key-name;
          type string {
            tailf:info "<0-255>;;traffic-class value";
          }
        }
        leaf mask {
          tailf:info "traffic-class mask";
          tailf:cli-expose-key-name;
          type string {
            tailf:info "<0-255>;;traffic-class mask";
          }
        }
        // [ global | vrf vrf-name ]
      }
    }

    // service counters max age
    container counters {
      tailf:info "Control aging of interface counters";
      container max {
        tailf:info "Maximum counter aging threshold";
        leaf age {
          tailf:info "Aging threshold";
          type uint8 {
            tailf:info "<0-60>;;Aging threshold value in seconds. Default 0";
            range "0..60";
          }
          default 0;
        }
      }
    }

    // service alignment
    container alignment {
      tailf:info "Control alignment correction and logging";
      // no service alignment detection
      leaf detection {
        tailf:info "Enable detection of alignment issues";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }
      // no service alignment logging
      leaf logging {
        tailf:info "Enable logging of alignment issues";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }
    }

    // service call-home
    leaf call-home {
      tailf:info "Enable call-home service";
      tailf:cli-full-command;
      type empty;
    }

    // no service dhcp
    leaf dhcp {
      tailf:info "Enable DHCP server and relay agent";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
      default true;
    }

    // service finger
    leaf finger {
      tailf:info "Allow responses to finger requests";
      tailf:cli-full-command;
      type empty;
    }

    // service heartbeat
    container heartbeat {
      tailf:info "Enable heartbeat processing";

      // service heartbeat fatal-count
      leaf fatal-count {
        tailf:info "Set heartbeat fatal count";
        type uint8 {
          tailf:info "<1-60>;;Number of timeouts until fatal error occurs";
          range "1..60";
        }
      }

      // service heartbeat interrupt-interval
      leaf interrupt-interval {
        tailf:info "Set heartbeat interrupt test interval";
        type uint8 {
          tailf:info "<0-60>;;Interval between interrupt level tests";
          range "0..60";
        }
      }

      // service heartbeat interrupt-max
      leaf interrupt-max {
        tailf:info "Set maximum message count from interrupt test";
        type uint8 {
          tailf:info "<0-60>;;Maximum number of messages from interrupt test";
          range "0..60";
        }
      }

      // service heartbeat transmit-interval
      leaf transmit-interval {
        tailf:info "Set heartbeat transmit interval";
        type uint8 {
          tailf:info "<1-30>;;Interval between heartbeat transmissions";
          range "1..30";
        }
      }

      // service heartbeat warning-timeout
      leaf warning-timeout {
        tailf:info "Set heartbeat warning timeout interval";
        type uint8 {
          tailf:info "<3-60>;;Interval between heartbeat timeout warnings";
          range "3..60";
        }
      }

      // service heartbeat fatal-timeout
      leaf fatal-timeout {
        tailf:info "Set heartbeat warning timeout interval";
        type uint8 {
          tailf:info "<5-60>;;Interval between heartbeat timeouts until a fatal timeout error occurs";
          range "5..60";
        }
      }

      // service heartbeat cslipc-timeout
      leaf cslipc-timeout {
        tailf:info "Set heartbeat csl ipc timeout interval";
        type uint16 {
          tailf:info "<10-4800>;;Interval between linecard insertion and csl ipc reception";
          range "10..4800";
        }
      }

      // service heartbeat alive-timeout
      leaf alive-timeout {
        tailf:info "Set heartbeat alive timeout interval";
        type uint16 {
          tailf:info "<600-1200>;;Interval between linecard insertion and heartbeat starting";
          range "600..1200";
        }
      }
    }

    // service hide-telnet-addresses
    leaf hide-telnet-addresses {
      tailf:info "Hide destination addresses in telnet command";
      tailf:cli-full-command;
      type empty;
    }

    // service unsupported-adapter
    leaf unsupported-adapter {
      tailf:cli-full-command;
      type empty;
    }

    // service unsupported-transceiver
    leaf unsupported-transceiver {
      tailf:info "enable support for third-party transceivers";
      tailf:cli-full-command;
      type empty;
    }

    // service internal
    leaf internal {
      tailf:info "Enable/Disable Internal commands";
      // Note: allow additional control of the LTE modem
      type empty;
    }

    // service log backtrace
    container log {
      tailf:info "log";
      leaf backtrace {
        tailf:info "backtrace";
        type empty;
      }
    }

    // service log-hidden
    leaf log-hidden {
      tailf:info "Enable syslog msgs for hidden/internal commands";
      type empty;
    }

    // no service image-version efsu
    container image-version {
      tailf:info "image-version";
      leaf efsu {
        tailf:info "efsu";
        tailf:cli-boolean-no;
        type boolean;
        default true;
      }
    }

    // no service single-slot-reload-enable
    leaf single-slot-reload-enable {
      tailf:cli-boolean-no;
      type boolean;
      default true;
    }
  }


  /// ========================================================================
  /// profile
  /// ========================================================================

  // profile *
  list profile {
    tailf:cli-suppress-mode;
    tailf:cli-delete-when-empty;
    key "start end increment";
    leaf start {
      type string {
        tailf:info "<0-FFFFFFFF>;;start addr";
      }
    }
    leaf end {
      type string {
        tailf:info "<0-FFFFFFFF>;;end addr";
      }
    }
    leaf increment {
      type string {
        tailf:info "<0-FFFFFFFF>;;increment";
      }
    }
  }


  /// ========================================================================
  /// environment
  /// ========================================================================

  container environment {
    tailf:info "Configure environmental monitor command";

    // environment router altitude
    container router {
      tailf:info "router environment settings";
      leaf altitude {
        tailf:info "router environment settings";
        type uint16 {
          tailf:info "<0-4000>;;Altitude value (in metres)";
          range "0..4000";
        }
      }
    }

    // environment temperature-controlled
    container temperature-controlled {
      presence true;
    }
  }


  /// ========================================================================
  /// boot
  /// ========================================================================

  container boot {
    tailf:info "Modify system boot parameters";

    // boot config
    leaf config {
      tailf:info "Configuration file";
      tailf:cli-full-command;
      type string {
        tailf:info "WORD;;URL of the config file";
      }
    }

    // boot network
    container network {
      tailf:info "Network-wide config file";

      // boot network * * *
      list list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "protocol filename address";
        leaf protocol {
          type enumeration {
            enum ftp {
              tailf:info "Boot from a server via ftp";
            }
            enum mop {
              tailf:info "Boot from a Decnet MOP server";
            }
            enum rcp {
              tailf:info "Boot from a server via rcp";
            }
            enum tftp {
              tailf:info "Boot from a tftp server";
            }
          }
        }
        leaf filename {
          type string {
            tailf:info "WORD;;configuration filename";
          }
        }
        leaf address {
          type inet:host {
            tailf:info "Hostname or A.B.C.D;;Address from which to download the file";
          }
        }
      }

      // boot network flash
      leaf flash {
        tailf:info "Boot from flash memory";
        tailf:cli-full-command;
        tailf:cli-full-no;
        type empty;
      }

      // boot network flash *
      container list-flash {
        tailf:cli-drop-node-name;
        list flash {
          tailf:info "Boot from flash memory";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;System image filename";
            }
          }
        }
      }

      // boot network <remote-url>
      leaf remote-url {
        tailf:cli-drop-node-name;
        tailf:cli-disallow-value "tftp|rcp|mop|ftp|flash";
        type string {
          tailf:info "WORD;;TFTP filename or URL";
        }
      }
    }

    // boot bootldr
    leaf bootldr {
      tailf:info "Boot loader (RxBoot) image name";
      type string {
        tailf:info "WORD;;URL of the Boot helper image";
      }
    }
  }


  /// ========================================================================
  /// warm-reboot
  /// ========================================================================

  container warm-reboot {
    tailf:info "Warm reboot allows quick reload in case of a crash or by request";
    presence true;
  }


  /// ========================================================================
  /// stack-mac
  /// ========================================================================

  // stack-mac persistent timer
  container stack-mac {
    tailf:info "Global stack mac-address feature configurations";
    container persistent {
      tailf:info "persistent stack mac-address";
      leaf timer {
        tailf:info "use stack mac-address timer after master failure";
        type uint8 {
          tailf:info "<0-60>;;Interval in minutes before using the new master's mac-address."
            +" Enter 0 to continue using current stack-mac after master switchover";
          range "0..60";
        }
      }
    }
  }


  /// ========================================================================
  /// password
  /// ========================================================================

  container password {
    tailf:info "Configure encryption password (key)";
    container encryption {
      tailf:info "Encrypt system passwords";

      // password encryption aes
      leaf aes {
        tailf:info "Enable stronger (AES) password encryption";
        tailf:cli-diff-dependency "../../../key/config-key/password-encrypt";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// login
  /// ========================================================================

  container login {
    tailf:info "Enable secure login checking";

    // login delay
    leaf delay {
      tailf:info "Set delay between successive fail login";
      type uint8 {
        tailf:info "<1-10>;;Time period in seconds";
        range "1..10";
      }
    }

    // login block-for
    container block-for {
      tailf:info "Set quiet-mode active time period";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf seconds {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint16 {
          tailf:info "<1-65535>;;Time period in seconds";
          range "1..65535";
        }
      }
      leaf attempts {
        tailf:info "Set max number of fail attempts";
        tailf:cli-incomplete-command;
        type uint16 {
          tailf:info "<1-65535>;;Fail attempts max value";
          range "1..65535";
        }
      }
      leaf within {
        tailf:info "Watch period for fail attempts";
        type uint16 {
          tailf:info "<1-65535>;;Time period in seconds";
          range "1..65535";
        }
      }
    }

    // login on-failure
    container on-failure {
      tailf:info "Set options for failed login attempt";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf log {
        tailf:info "Generate syslogs on failure logins";
        type empty;
      }
      leaf every {
        tailf:info "Periodicity for logs generated";
        type uint16 {
          tailf:info "<1-65535>;;Number defining periodicity";
          range "1..65535";
        }
        default 1;
      }
    }

    // login on-success
    container on-success {
      tailf:info "Set options for successful login attempt";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf log {
        tailf:info "Generate syslogs on successful logins";
        type empty;
      }
      leaf every {
        tailf:info "Periodicity for logs generated";
        type uint16 {
          tailf:info "<1-65535>;;Number defining periodicity";
          range "1..65535";
        }
        default 1;
      }
    }

    // login quiet-mode access-class
    container quiet-mode {
      tailf:info "Set quiet-mode options";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf access-class {
        tailf:info "Set access class";
        type exp-ip-acl-type;
      }
      leaf vrf-also {
        tailf:info "Enter vrf-also if ACL needs to be applied with vrf-also";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// cdp
  /// ========================================================================
  // Must be before interface * / cdp enable

  container cdp {
    tailf:info "Global CDP configuration subcommands";

    // cdp timer
    leaf timer {
      tailf:info "Specify the rate at which CDP packets are sent (in sec)";
      type uint8 {
        tailf:info "<5-254>;;Rate at which CDP packets are sent (in sec";
        range "5..254";
      }
    }

    // cdp holdtime
    leaf holdtime {
      tailf:info "Specify the holdtime (in sec) to be sent in packets";
      type uint8 {
        tailf:info "<10-255>;;Length of time (in sec) that receiver must keep this packet";
        range "10..255";
      }
    }

    // no cdp run
    leaf run {
      tailf:info "Enable CDP";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      cli:ned-diff-move-last {
        cli:arguments "when-delete";
      }
      type boolean;
      default true;
    }

    // no cdp advertise-v2
    leaf advertise-v2 {
      tailf:info "CDP sends version-2 advertisements";
      tailf:cli-boolean-no;
      type boolean;
      default true;
    }

    container tlv {
      tailf:info "Enable exchange of specific tlv information";

      // no cdp tlv location
      leaf location {
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // no cdp tlv app
      leaf app {
        tailf:info "Enable app tlv";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }
    }

    // cdp tlv-list *
    list tlv-list {
      tailf:info "Configure tlv-list";
      tailf:cli-mode-name "config-tlv-list";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Tlv-list";
        }
      }
      leaf-list tlv {
        tailf:cli-drop-node-name;
        tailf:cli-list-syntax;
        type enumeration {
          enum address {
            tailf:info "Select address TLV";
          }
          enum capability {
            tailf:info "Select capability TLV";
          }
          enum cos {
            tailf:info "Select cos TLV";
          }
          enum duplex {
            tailf:info "Select duplex TLV";
          }
          enum ext-port-id {
            tailf:info "Select external port id TLV";
          }
          enum hello-protocol {
            tailf:info "Select hello-protocol TLV";
          }
          enum ip-prefix {
            tailf:info "Select ip-prefix TLV";
          }
          enum location {
            tailf:info "Select location TLV";
          }
          enum location-server {
            tailf:info "Select location-server TLV";
          }
          enum mgmt-address {
            tailf:info "Select management address TLV";
          }
          enum native-vlan {
            tailf:info "Select native-vlan TLV";
          }
          enum platform {
            tailf:info "Select platform TLV";
          }
          enum port-id {
            tailf:info "Select port id TLV";
          }
          enum power-available {
            tailf:info "Select power-available TLV";
          }
          enum powernet {
            tailf:info "Select powernet-event TLV";
          }
          enum spare-pair-poe {
            tailf:info "Select spair pair poe TLV";
          }
          enum trust {
            tailf:info "Select trust TLV";
          }
          enum unidirectional-mode {
            tailf:info "Select unidirectional-mode TLV";
          }
          enum version {
            tailf:info "Select version TLV";
          }
          enum vtp-mgmt-domain {
            tailf:info "Select vtp mgmt domain TLV";
          }
          enum vvid {
            tailf:info "Select vvid TLV";
          }
        }
      }
    }

    // cdp filter-tlv-list
    leaf filter-tlv-list {
      tailf:info "Apply tlv-list globally";
      tailf:cli-remove-before-change;
      tailf:non-strict-leafref {
        path "../tlv-list/name";
      }
      type string {
        tailf:info "WORD;;Filter tlv-list";
      }
    }
  }


  /// ========================================================================
  /// platform
  /// ========================================================================

  container platform {
    tailf:info "platform specific configuration";

    // platform acl
    container acl {
      tailf:info "Platform specific ACL Options";

      // platform acl egress-disable
      leaf egress-disable {
        tailf:info "Disable Egress ACL lookup";
        type empty;
      }
    }

    // platform shell
    leaf shell {
      tailf:info "Control platform shell access command availability";
      tailf:cli-full-command;
      type empty;
    }

    // platform console
    leaf console {
      tailf:info "Direct IOS output to console";
      tailf:cli-full-command;
      type enumeration {
        enum auto {
          tailf:info "Autodetect console (Serial,VGA) for IOS output";
        }
        enum serial {
          tailf:info "Use Serial console for IOS output";
        }
        enum virtual {
          tailf:info "Use VM (VGA) console for IOS output";
        }
      }
    }

    // platform mpls mtu-enable
    container mpls {
      tailf:info "Configure MPLS parameters";
      leaf mtu-enable {
        tailf:info "Enable MPLS MTU configuation";
        type empty;
      }
    }

    // platform resource
    leaf resource {
      tailf:info "Select resource template";
      type enumeration {
        enum control-plane-heavy {
          tailf:info "Use Control Plane Heavy template";
        }
        enum control-plane-extra-heavy {
          tailf:info "Use Control Plane Extra Heavy template";
        }
        enum data-plane-normal {
          tailf:info "Use Data Plane Normal template";
        }
        enum data-plane-heavy {
          tailf:info "Use Data Plane Heavy template";
        }
        enum service-plane-medium {
          tailf:info "Use Service Plane Medium template";
        }
        enum service-plane-heavy {
          tailf:info "Use Service Plane Heavy template";
        }
      }
    }

    // platform bfd allow-svi
    container bfd {
      tailf:info "Platform specific BFD commands";
      leaf allow-svi {
        tailf:cli-full-command;
        type empty;
      }
    }

    // platform bfd-debug-trace
    leaf bfd-debug-trace {
      tailf:info "Enable bfd debug infra";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<0-1>;;Disable/Enable";
        range "0..1";
      }
    }

    // platform enable controller *
    container enable {
      tailf:info "enable port license";
      list controller {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        cli:ned-diff-move-last {
          cli:arguments "when-delete";
        }
        key name;
        leaf name {
          tailf:cli-multi-word-key;
          type string {
            tailf:info "WORD;;Controller name";
          }
        }
      }
    }

    // platform hardware
    container hardware {
      tailf:info "Configure platform hardware";

      // platform hardware throughput level
      container throughput {
        tailf:info "Configure throughput";
        container level {
          tailf:info "Configure the current traffic throughput level";
          choice throughput-choice {
            leaf MB {
              tailf:info "throughput in mbps";
              type uint32;
            }
            leaf kbps {
              tailf:cli-drop-node-name;
              type uint32;
            }
          }
        }

        // platform hardware throughput crypto
        leaf crypto {
          tailf:info "Configure crypto throughput";
          tailf:cli-full-command;

          type enumeration {
            enum "250000" {
              tailf:info "throughput in kbps";
            }
            enum "50000" {
              tailf:info "throughput in kbps";
            }
            enum "100M" {
              tailf:info "100 mbps bidirectional thput";
            }
            enum "10M" {
              tailf:info "10 mbps bidirectional thput";
            }
            enum "15M" {
              tailf:info "15 mbps bidirectional thput";
            }
            enum "250M" {
              tailf:info "250 mbps bidirectional thput";
            }
            enum "25M" {
              tailf:info "25 mbps bidirectional thput";
            }
            enum "50M" {
              tailf:info "50 mbps bidirectional thput";
            }
            enum "2.5G" {
             tailf:info "2.5 gbps bidirectional thput";
            }
          }
        }
      }

      // platform hardware crypto-throughput level
      container crypto-throughput {
        tailf:info "Configure crypto throughput commands";
        leaf level {
          tailf:info "Configure the current crypto throughput level";
          type enumeration {
            enum 8g {
              tailf:info "crypto throughput level, bits per second";
            }
            enum 8-16g {
              tailf:info "crypto throughput upgrade, bits per second";
            }
            enum 8-25g {
              tailf:info "crypto throughput upgrade, bits per second";
            }
            enum 16-25g {
              tailf:info "crypto throughput upgrade, bits per second";
            }
          }
        }
      }
    }

    // platform memory add
    container memory {
      tailf:info "Configure platform memory options";
      leaf add {
        tailf:info "Dynamically add memory to the system";
        type uint32 {
          tailf:info "VAL;;Memory to be added (in MB)";
        }
      }
    }

    // platform ipccl log-history
    container ipccl {
      leaf log-history {
        type uint32;
      }
    }

    // platform ipsla classify cpu packets
    container ipsla {
      tailf:info "Configures ipsla";
      container classify {
        tailf:info "Classifies ipsla traffic";
        container cpu {
          tailf:info "CPU packets";
          leaf packets {
            tailf:info "CPU packets";
            type empty;
          }
        }
      }
    }

    // platform ip cef load-sharing
    container ip {
      tailf:info "ip keyword";
      container cef {
        tailf:info "cef keyword";
        leaf load-sharing {
          tailf:info "load balancing";
          type enumeration {
            enum dst-only {
              tailf:info "load balancing algorithm to include destination IP/L4 port";
            }
            enum full {
              tailf:info "default load balancing algorithm to include src/dst IPs/L4 ports";
            }
            enum ip-only {
              tailf:info "load balancing algorithm to include src/dst IP";
            }
          }
        }
      }
    }

    // platform ipv4 pbr optimize tcam
    container ipv4 {
      tailf:info "platform specific IP configuration";
      container pbr {
        tailf:info "Policy Based Routing";
        container optimize {
          tailf:info "optimize keyword";
          leaf tcam {
            tailf:info "Enable optimization of ACL TCAM entry usage";
            type empty;
          }
        }
      }
    }

    // platform ipsec
    container ipsec {
      tailf:info "Platform specific ipsec command";

      // platform ipsec flexvpn-bypass-tcam
      leaf flexvpn-bypass-tcam {
        tailf:info "bypass TCAM for FlexVPN";
        type empty;
      }

      // platform ipsec reassemble transit
      container reassemble {
        tailf:info "reassemble packets";
        leaf transit {
          tailf:info "transit IPSEC packets";
          type empty;
        }
      }
    }

    // platform ring rx 256
    container ring {
      leaf rx {
        type uint32;
      }
    }

    // platform vfi
    container vfi {
      tailf:info "VPLS and EoMPLS configuration";

      // platform vfi dot1q-transparency
      leaf dot1q-transparency {
        tailf:info "Conditional per Vlan dot1q transparency";
        type empty;
      }
    }

    // platform tcam-parity-error enable
    container tcam-parity-error {
      tailf:info "Platform specific TCAM Options";
      leaf enable {
        tailf:info "Enable TCAM Parity error monitoring";
        type empty;
      }
    }

    // platform tcam-threshold alarm-frequency
    container tcam-threshold {
      tailf:info "threshold on the TCAM usage";
      leaf alarm-frequency {
        tailf:info "Configure TCAM threshold alarm frequency";
        type uint32 {
          tailf:info "<1-75>;;Alarm frequency (per hour)";
        }
      }
    }

    // platform multicast lre off
    container multicast {
      tailf:info "Configure multicast";
      container lre {
        leaf off {
          type empty;
        }
      }
    }

    // platform issu reload interface-module sequence *
    container issu {
      tailf:info "Configure sequence of IM reload in ISSU";
      container reload {
        tailf:info "Specifies issu IM reload";
        container interface-module {
          tailf:info "Specific interface-module";
          leaf-list sequence {
            tailf:info "User specified sequence";
            tailf:cli-flat-list-syntax {
              tailf:cli-replace-all;
            }
            ordered-by user;
            type uint16 {
              tailf:info "<0-15>;;Enter range <0-15> followed by space";
              range "0..15";
            }
          }
        }
      }
    }

    // platform expect-single-psu
    leaf expect-single-psu {
      tailf:info "Platform can run with single psu";
      type empty;
    }

    // platform punt-keepalive
    container punt-keepalive {
      tailf:info "punt-keepalive messages";

      // platform punt-keepalive disable-kernel-core
      // no platform punt-keepalive disable-kernel-core
      leaf disable-kernel-core {
        tailf:info "Disable IOSXE kernel core generation for keepalive fault";
        tailf:cli-boolean-no;
        type boolean;
      }

      // platform punt-keepalive settings
      container settings {
        tailf:info "Set the keepalive parameters";

        // platform punt-keepalive settings transmit-interval
        leaf transmit-interval {
          tailf:info "Set punt-inject keepalive transmit interval";
          type uint8 {
            tailf:info "<2-30>;;Interval between punt/inject keepalive transmissions";
            range "2..30";
          }
        }

        // platform punt-keepalive settings warning-count
        leaf warning-count {
          tailf:info "Set punt-inject keepalive warning count";
          type uint8 {
            tailf:info "<10-60>;;Interval between punt/inject keepalive timeout warnings";
            range "10..60";
          }
        }

        // platform punt-keepalive settings fatal-count
        leaf fatal-count {
          tailf:info "Set punt-inject keepalive fatal count";
          type uint8 {
            tailf:info "<15-60>;;Number of timeouts until fatal error occurs";
            range "15..60";
          }
        }
      }
    }

    // platform punt-policer *
    list punt-policer {
      tailf:info "Configures punt policers";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-incomplete-command;
      key cause;
      leaf cause {
        type union {
          type uint8 {
            tailf:info "<1-141>;;Punt cause to be policed";
            range "1..141";
          }
          type string {
            tailf:info "WORD;;Punt cause name";
          }
        }
      }
      leaf rate {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<10-300000>;;max punt rate for cause Incomplete adjacency";
          range "10..300000";
        }
      }
      leaf burst {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<1-300000>;;max burst size for cause cable SNMP";
          range "1..300000";
        }
      }
    }

    // platform punt-policer * high
    container punt-policer-high {
      tailf:cli-drop-node-name;
      list punt-policer {
        tailf:info "Configures punt policers";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-incomplete-command;
        key cause;
        leaf cause {
          type union {
            type uint8 {
              tailf:info "<1-108>;;Punt cause to be policed";
              range "1..108";
            }
            type string {
              tailf:info "WORD;;Punt cause name";
            }
          }
        }
        leaf rate {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<10-300000>;;max punt rate for cause Incomplete adjacency";
            range "10..300000";
          }
        }
        leaf burst {
          tailf:cli-drop-node-name;
          tailf:cli-optional-in-sequence;
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<1-300000>;;max burst size for cause cable SNMP";
            range "1..300000";
          }
        }
        leaf high {
          tailf:info "High priority traffic only";
          type empty;
        }
      }
    }

    // platform punt-sbrl
    container punt-sbrl {
      tailf:info "Punt-path Source-Based Rate-Limit configuration";

      // platform punt-sbrl wan punt-cause *
      container wan {
        tailf:info "SBRL WAN-side config";
        list punt-cause {
          tailf:info "sub-side punt-cause for per-MAC-addr rate-limiting";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-incomplete-command;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;punt-cause";
            }
          }
          leaf rate-per-1-sec {
            tailf:info "WAN-side rate in pkts-per-1-sec";
            type uint16 {
              tailf:info "<1-256>;;rate (powers-of-2 only) for: SSLVPN session control";
              range "1..256";
            }
          }
          leaf quarantine-time {
            tailf:info "WAN-side quarantine time";
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<1-60>;;quarantine time in minutes";
              range "1..60";
            }
          }
          leaf burst-factor {
            tailf:info "WAN-side quarantine burst-factor";
            type uint16 {
              tailf:info "<50-1000>;;quarantine burst-factor in packets";
              range "50..1000";
            }
          }
        }
      }

      // platform punt-sbrl subscriber
      container subscriber {
        tailf:info "SBRL subscriber-side config";

        // platform punt-sbrl subscriber punt-cause *
        list punt-cause {
          tailf:info "subscriber-side punt-cause";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-incomplete-command;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;punt-cause";
            }
          }
          leaf rate-per-4-sec {
            tailf:info "pkt rate in pkts-per-4-sec";
            type union {
              type enumeration {
                enum no-drop {
                  tailf:info "no drops for this punt-cause";
                }
              }
              type uint8 {
                tailf:info "<1-255>;;rate in pkts-per-4-sec";
                range "1..255";
              }
            }
          }
          leaf bucket-size {
            tailf:info "bucket size";
            tailf:cli-optional-in-sequence;
            type uint8 {
              tailf:info "<1-255>;;bucket size in pkts";
              range "1..255";
            }
          }
          leaf quarantine-time {
            tailf:info "subscriber-side quarantine time";
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<1-60>;;quarantine time in minutes";
              range "1..60";
            }
          }
          leaf burst-factor {
            tailf:info "quarantine burst-factor";
            type uint16 {
              tailf:info "<50-1000>;;quarantine burst-factor in packets";
              range "50..1000";
            }
          }
        }

        // platform punt-sbrl subscriber rate
        leaf rate {
          tailf:info "subscriber-side CM rate in pkts-per-sec";
          type uint16 {
            tailf:info "<1-256>;;rate (powers-of-2 only)";
            range "1..256";
          }
        }

        // platform punt-sbrl subscriber ping-bypass
        leaf ping-bypass {
          tailf:info "allow console pings to bypass SBRL/punt-policer";
          type empty;
        }
      }

      // platform punt-sbrl ping-bypass
      leaf ping-bypass {
        tailf:info "allow console pings to bypass SBRL/punt-policer";
        type empty;
      }
    }

    // platform qfp utilization monitor load
    container qfp {
      tailf:info "Platform specific qfp commands";
      container utilization {
        tailf:info "utilization";
        container monitor {
          tailf:info "monitor";
          leaf load {
            tailf:info "load";
            type uint8 {
              tailf:info "<50-99>;;load warming threashold(default value is 80%)";
              range "50..99";
            }
          }
        }
      }
    }

    // platform qos
    container qos {
      tailf:info "Platform specific qos configuration";

      // platform qos queueing-only
      leaf queueing-only {
        tailf:info "queueing-only (no QoS rewrite,  no policing)";
        type empty;
      }

      // platform qos marker-statistics
      leaf marker-statistics {
        tailf:info "Configure marking statistics";
        tailf:cli-full-command;
        type empty;
      }

      // platform qos match-statistics
      container match-statistics {
        tailf:info "Configure match stats";
        leaf per-filter {
          tailf:info "Configure per-filter match statistics";
          type empty;
        }
        leaf per-ace {
          tailf:info "Configure per-ace match statistics (per-filter must be enabled first)";
          tailf:cli-diff-dependency "../per-filter";
          type empty;
        }
      }

      // platform qos performance-monitor
      leaf performance-monitor {
        tailf:info "Configure performance-monitor statistics";
        tailf:cli-full-command;
        type empty;
      }

      // platform qos punt-path-matching
      leaf punt-path-matching {
        tailf:info "Configure punt-path matching on input interface (PPPoE-Discovery, PPPoE-PPP-LCP)";
        tailf:cli-full-command;
        type empty;
      }

      // platform qos port-channel-aggregate *
      leaf-list port-channel-aggregate {
        tailf:info "Configure port-channel to aggregate mode";
        tailf:cli-list-syntax;
        cli:ned-diff-move-after ">no interface Port-channel" {
          cli:arguments "when-delete";
        }
        type uint8 {
          tailf:info "<1-64>;;port-channel interface number";
          range "1..64";
        }
      }
    }

    // platform qos-adjust-policer enable
    container qos-adjust-policer {
      tailf:info "Adjust policer value";
      leaf enable {
        tailf:info "Enable policer adjustment to next avialable value";
        type empty;
      }
    }

    // platform power redundancy-mode nplus1
    container power {
      tailf:info "Platform power command";
      container redundancy-mode {
        leaf nplus1 {
          type empty;
        }
      }
    }

    // no platform rate-limit unicast acl vacl_log
    container rate-limit {
      tailf:info "rate-limiter";
      container unicast {
        tailf:info "Unicast rate-limiters";
        container acl {
          tailf:info "ACL BRIDGE cases";
          leaf vacl_log {
            tailf:info "Vlan ACL logging requiring punt to RP";
            tailf:cli-boolean-no;
            type boolean;
            default true;
          }
        }
      }
    }

    // platform hw-module configuration
    container hw-module {
      tailf:info "Configure the hw-modules of chassis";
      container configuration {
        tailf:info "Configure mode";
        tailf:cli-add-mode;
        tailf:cli-mode-name "conf-plat-hw-conf";
        presence true;

        // platform hw-module configuration / hw-module *
        list hw-module {
          tailf:info "Configure subslot to desired IM type";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-incomplete-command;
          key slot;
          leaf slot {
            type string {
              tailf:info "WORD;;Card slot/subslot";
            }
          }
          leaf im-type {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;IM type name";
            }
          }
          leaf mode {
            tailf:info "Configure Operating mode of the IM";
            type string {
              tailf:info "WORD;;Mode";
            }
          }
        }
      }
    }

    // platform time-source ntp
    container time-source {
      tailf:info "Configure platform time-source";
      container ntp {
        tailf:info "Configure NTP clock source";
        tailf:cli-delete-when-empty;
        tailf:cli-reset-container;
        presence true;
        leaf time-scale {
          tailf:info "Configure time-scale format";
          type enumeration {
            enum epoch-1900 {
              tailf:info "Configure epoch-1900";
            }
            enum epoch-1970 {
              tailf:info "Configure epoch-1970";
            }
          }
        }
      }
    }

    // platform xconnect load-balance-hash-algo mac-ip-instanceid
    container xconnect {
      tailf:info "Configure xconnect load balance hash";
      container load-balance-hash-algo {
        tailf:info "Configure xconnect load balance hash";
        leaf mac-ip-instanceid {
          tailf:info "Configure xconnect load balance hash";
          type empty;
        }
      }
    }

    // platform smart-sfp interface *
    container smart-sfp {
      tailf:info "Configure Port-Type for Smart SFP";
      list interface {
        tailf:info "Select the Ethernet Interface";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Interface name";
          }
        }
        leaf type {
          type string;
        }
      }
    }

    // platform feature-manager capture rate-limit
    container feature-manager {
      tailf:info "platform specific feature-manager configuration";
      container capture {
        tailf:info "Rate limits CAPTURE packets of  OAL, VACL Capture, IPv6 Copy and VM";
        leaf rate-limit {
          tailf:info "Rate limits CAPTURE packets";
          type uint32 {
            tailf:info "<0-1000000>;;packets per second";
            range "0..1000000";
          }
        }
      }
    }

    // platform l2vpn
    container l2vpn {
      tailf:info "Configure platform l2vpn global configuration";

      // platform l2vpn hdlc-pass-through
      leaf hdlc-pass-through {
        tailf:info "l2vpn HDLC force pass through";
        type empty;
      }
    }

    // platform cos-mark protocol * cos-value
    container cos-mark {
      tailf:info "Configures cos-marking";
      list protocol {
        tailf:info "Configures protocol";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Protocol Name, e.g. arp|dns|telnet|etc.";
          }
        }
        leaf cos-value {
          tailf:info "CoS value";
          type uint8 {
            tailf:info "<1-7>;;CoS value";
            range "1..7";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// boot system
  /// ========================================================================

  container boot-marker {
    tailf:cli-drop-node-name;

    // boot-start-marker

    container boot {
      tailf:info "Modify system boot parameters";

      // boot system *
      list system {
        tailf:info "System image file";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-show-long-obu-diffs;
        ordered-by user;
        key entry;
        leaf entry {
          tailf:cli-multi-word-key;
          type string {
            tailf:info "WORD;;boot system entry";
          }
        }
      }
    }

    // boot-end-marker
  }


  /// ========================================================================
  /// shell
  /// ========================================================================

  container shell {
    tailf:info "Configure shell command";

    choice processing-choice {
      // no shell processing
      leaf processing {
        tailf:info "Enable shell processing";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        tailf:cli-full-no;
        type boolean;
        default true;
      }
      // shell processing full
      container processing-full {
        tailf:cli-drop-node-name;
        container processing {
          tailf:info "Enable shell processing";
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          leaf full {
            tailf:info "Enable shell processing in all IOS modes";
            ios:delete-syntax "shell processing";
            type empty;
          }
        }
      }
      default processing;
    }
  }


  /// ========================================================================
  /// aqm-register-fnf
  /// ========================================================================

  container aqm-register-fnf {
    tailf:info "Export audio/voice stats to flow record";
    presence true;
  }


  /// ========================================================================
  /// service-module
  /// ========================================================================

  // service-module wlan-ap 0 bootimage
  container service-module {
    tailf:info "Service Module bootimage config";
    list wlan-ap {
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-incomplete-command;
      key interface-number;
      leaf interface-number {
        type uint8 {
          tailf:info "<0-0>;;wlan-ap interface number";
          range "0";
        }
      }
      leaf bootimage {
        tailf:info "AP boot image";
        type enumeration {
          enum autonomous {
            tailf:info "Set AP boot image to autonomous";
          }
          enum unified {
            tailf:info "Set AP boot image to unified";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// vrf
  /// ========================================================================
  // Note: /vrf must be before /ip and /ipv6

  container vrf {
    tailf:info "VRF commands";

    // vrf definition *
    list definition {
      tailf:info "VRF definition mode";
      tailf:cli-full-command;
      tailf:cli-diff-dependency "../../mls/ipv6/vrf";
      unique rd;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;VRF name";
        }
      }

      // vrf definition * / description
      leaf description {
        tailf:info "VRF specific description";
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE;;Up to 244 characters describing this VRF";
          length "1..244";
        }
      }

      // vrf definition * / rd
      leaf rd {
        tailf:info "Specify Route Distinguisher";
        tailf:cli-remove-before-change;
        tailf:cli-full-command;
        type rd-type;
      }

      // vrf definition * / vpn id
      container vpn {
        tailf:info "Configure VPN ID as specified in rfc2685";
        leaf id {
          tailf:info "Configure VPN ID in rfc2685 format";
          type vpn-id-type;
        }
      }

      // vrf definition * / ipv4 multicast multitopology
      container ipv4 {
        tailf:info "VRF IPv4 configuration";
        container multicast {
          tailf:info "IP multicast configuration";
          leaf multitopology {
            tailf:info "Enable Multicast-Specific RPF Topology";
            type empty;
          }
        }
      }

      // vrf definition * / route-target
      container route-target {
        tailf:info "Specify Target VPN Extended Communities";
        tailf:cli-diff-dependency "../rd";
        uses route-target-grouping;
      }

      // vrf definition * / address-family
      container address-family {
        tailf:info "Enter Address Family command mode";
        tailf:cli-diff-dependency "../rd";

        // vrf definition * / address-family ipv4
        container ipv4 {
          tailf:info "Address family";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-vrf-af";
          tailf:cli-exit-command "exit-address-family";
          tailf:cli-full-command;
          presence true;
          uses vrf-definition-af-grouping;

          // vrf definition * / address-family ipv4 / mdt
          container mdt {
            tailf:info "Backbone Multicast Distribution Tree";

            // vrf definition * / address-family ipv4 / mdt default
            container default {
              tailf:info "The default group";

              // vrf definition * / address-family ipv4 / mdt default address
              leaf address {
                // Note: when set, mdt/data & mdt/log-reuse should be deleted
                tailf:cli-drop-node-name;
                tailf:cli-full-command;
                tailf:cli-remove-before-change;
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IP multicast group address";
                }
              }

              // vrf definition * / address-family ipv4 / mdt default mpls
              container mpls {
                tailf:info "MPLS tunnel options";

                // vrf definition * / address-family ipv4 / mdt default mpls mldp *
                list mldp {
                  tailf:info "Use a MLDP LSP to create the default MDT";
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  key address;
                  leaf address {
                    type inet:ipv4-address {
                      tailf:info "A.B.C.D;;MP2MP LSP root address";
                    }
                  }
                }
              }
            }

            // vrf definition * / address-family ipv4 / mdt data
            container data {
              tailf:info "MDT data trees";

              // vrf definition * / address-family ipv4 / mdt data multicast
              list multicast {
                tailf:cli-drop-node-name;
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                key "address wildcard";
                leaf address {
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;IP multicast group address";
                  }
                }
                leaf wildcard {
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;Wildcard bits";
                  }
                }
              }

              // vrf definition * / address-family ipv4 / mdt data list
              leaf list {
                tailf:info "Access-list";
                type ext-acl-type;
              }

              // vrf definition * / address-family ipv4 / mdt data mpls mldp *
              container mpls {
                tailf:info "MPLS tunnel options";
                list mldp {
                  tailf:info "Use a MLDP LSP to create the data MDT";
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  key id;
                  leaf id {
                    type uint16 {
                      tailf:info "<1-5000>;;Number of data mdts";
                      range "1..5000";
                    }
                  }
                }
              }

              // vrf definition * / address-family ipv4 / mdt data threshold
              leaf threshold {
                tailf:info "MDT switching threshold";
                type uint32 {
                  tailf:info "<1-4294967>;;Traffic rate in kilobits per second";
                }
              }
            }

            // vrf definition * / address-family ipv4 / mdt log-reuse
            leaf log-reuse {
              tailf:info "Event logging for data MDT reuse";
              type empty;
            }

            // vrf definition * / address-family ipv4 / mdt preference
            leaf-list preference {
              tailf:info "MDT preference (default pim mldp)";
              tailf:cli-flat-list-syntax {
                tailf:cli-replace-all;
              }
              type enumeration {
                enum mldp {
                  tailf:info "MDT preference mLDP";
                }
                enum pim {
                  tailf:info "MDT preference PIM";
                }
              }
            }
          }
        }

        // vrf definition * / address-family ipv4 multicast
        container ipv4-multicast {
          tailf:cli-drop-node-name;
          container ipv4 {
            tailf:info "Address family";
            container multicast {
              tailf:info "Address Family modifier";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-vrf-af";
              tailf:cli-exit-command "exit-address-family";
              tailf:cli-full-command;
              tailf:cli-diff-dependency "../../../../ipv4/multicast/multitopology";
              presence true;
              uses vrf-definition-af-grouping;
            }
          }
        }

        // vrf definition * / address-family ipv6
        container ipv6 {
          tailf:info "Address family";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-vrf-af";
          tailf:cli-exit-command "exit-address-family";
          tailf:cli-full-command;
          presence true;
          uses vrf-definition-af-grouping;
        }
      }
    }
  }


  /// ========================================================================
  /// security
  /// ========================================================================

  container security {
    tailf:info "Infra Security CLIs";

    // security passwords min-length
    container passwords {
      tailf:info "Password security CLIs";
      leaf min-length {
        tailf:info "Minimum length of passwords";
        type uint8 {
          tailf:info "<0-16>;;Minimum length of all user/enable passwords";
          range "0..16";
        }
      }
    }

    // security authentication failure rate
    container authentication {
      tailf:info "Authentication security CLIs";
      container failure {
        tailf:info "Authentication failure logging";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf rate {
          tailf:info "Authentication failure threshold rate";
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<2-1024>;;Authentication failure threshold rate";
            range "2..1024";
          }
        }
        leaf log {
          tailf:info "log a message if the Authentication failures over the last one minute equalled this number";
          type empty;
        }
      }
    }
  }


  /// ========================================================================
  /// enable
  /// ========================================================================

  container enable {
    tailf:info "Modify enable password parameters";

    // enable password
    container password {
      tailf:info "Assign the privileged level password (MAX of 25 characters)";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      uses password-grouping {
        refine "secret" {
          cli:secret " password <SECRET>";
        }
      }
    }

    // enable password level *
    container password-conf {
      tailf:cli-drop-node-name;
      container password {
        tailf:info "Assign the privileged level password (MAX of 25 characters)";
        list level {
          tailf:info "Set exec level password";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          key level;
          leaf level {
            type uint8 {
              tailf:info "<1-15>;;Level number";
              range "1..15";
            }
          }
          uses password-grouping {
            refine "secret" {
              cli:secret " level \\d+ <SECRET>";
            }
          }
        }
      }
    }

    // enable last-resort
    leaf last-resort {
      tailf:info "Define enable action if no TACACS servers respond";
      tailf:cli-full-command;
      type enumeration {
        enum password {
          tailf:info "Enable by giving the local enable password";
        }
        enum succeed {
          tailf:info "Enable without further question";
        }
      }
    }

    // enable secret
    container secret {
      tailf:info "Assign the privileged level secret";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      uses enable-secret-grouping;
    }

    // enable secret level *
    container secret-conf {
      tailf:cli-drop-node-name;
      container secret {
        tailf:info "Assign the privileged level secret";
        list level {
          tailf:info "Set exec level password";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-incomplete-command;
          key level;
          leaf level {
            tailf:cli-suppress-range;
            type uint8 {
              tailf:info "<1-15>;;Level number";
              range "1..15";
            }
          }
          uses enable-secret-grouping;
        }
      }
    }

    // enable use-tacacs
    leaf use-tacacs {
      tailf:info "Use TACACS to check enable passwords";
      tailf:cli-full-command;
      type empty;
    }

  }


  /// ========================================================================
  /// aaa
  /// ========================================================================

  container aaa {
    tailf:info "Authentication, Authorization and Accounting.";
    tailf:cli-incomplete-command;

    // aaa new-model
    leaf new-model {
      tailf:info "Enable NEW access control commands and functions. (Disables OLD commands.)";
      type empty;
    }

    // aaa password restriction
    container password {
      tailf:info "Configure password/secret related settings";
      leaf restriction {
        tailf:info "Configure restrictions to the passwords";
        type empty;
      }
    }

    // aaa local authentication
    container local {
      tailf:info "AAA Local method options";
      container authentication {
        tailf:info "Local authentication options";

        // aaa local authentication default authorization
        container default {
          tailf:info "default authen method list";
          leaf authorization {
            tailf:info "Local Authentication method list";
            type string {
              tailf:info "WORD;;method list name | default";
            }
          }
        }

        // aaa local authentication attempts max-fail
        container attempts {
          tailf:info "Local authentication attempts";
          leaf max-fail {
            tailf:info "Max failed attempts to lock the user";
            type uint16 {
              tailf:info "<1-65535>;;Specify the value for max failed attempts";
              range "1..65535";
            }
          }
        }
      }
    }

    // aaa group
    container group {
      tailf:info "AAA group definitions";
      tailf:cli-diff-dependency "../new-model";

      // aaa group server
      container server {
        tailf:info "AAA Server group definitions";

        // aaa group server radius *
        list radius {
          tailf:info "Radius server-group definition";
          tailf:cli-mode-name "config-sg-radius";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Server-group name";
            }
          }

          // aaa group server radius * / server
          container server {
            tailf:info "Specify a RADIUS server";

            // aaa group server radius * / server name *
            list name {
              tailf:info "Name of radius server";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-show-long-obu-diffs;
              ordered-by user;
              key name;
              leaf name {
                tailf:non-strict-leafref {
                  path "../../../name";
                }
                type string {
                  tailf:info "WORD;;Name";
                }
              }
            }

            // aaa group server radius * / server *
            list direct {
              tailf:cli-drop-node-name;
              tailf:cli-compact-syntax;
              tailf:cli-suppress-mode;
              key name;
              leaf name {
                tailf:cli-disallow-value "name";
                type inet:host {
                  tailf:info "Hostname or A.B.C.D;;IP address of RADIUS server";
                }
              }
              leaf auth-port {
                tailf:info "UDP port for RADIUS authentication server (default is 1645)";
                type uint16 {
                  tailf:info "<0-65535>;;Port number";
                  range "0..65535";
                }
              }
              leaf acct-port {
                tailf:info "UDP port for RADIUS accounting server (default is 1646)";
                type uint16 {
                  tailf:info "<0-65535>;;Port number";
                  range "0..65535";
                }
              }
            }
          }

          // aaa group server radius * / server-private *
          list server-private {
            tailf:info "Define a private RADIUS server (per group)";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            key name;
            leaf name {
              type inet:host {
                tailf:info "WORD;;Hostname or X:X:X:X::X or A.B.C.D address of RADIUS server";
              }
            }
            uses radius-server-grouping;
          }

          // aaa group server radius * / backoff exponential
          container backoff {
            tailf:info "Retry backoff pattern (Default is retransmits with constant delay)";
            container exponential {
              tailf:info "Exponential retransmit backoff";
              tailf:cli-delete-when-empty;
              presence true;
              // aaa group server radius * / backoff exponential max-delay
              leaf max-delay {
                tailf:info "Max delay between retransmits(default is 3 min)";
                type uint8 {
                  tailf:info "<1-120>;;Max time (in minutes) to delay between retransmits";
                  range "1..120";
                }
                default 3;
              }
              leaf backoff-retry {
                tailf:info "Exponential backoff retry number(default is 8)";
                type uint8 {
                  tailf:info "<1-50>;;Number of retransmits in the exponential backoff mode";
                  range "1..50";
                }
                default 8;
              }
            }
          }

          // aaa group server radius * / ip
          container ip {
            tailf:info "Internet Protocol config commands";

            // aaa group server radius * / ip vrf forwarding
            container vrf {
              tailf:info "Set VPN Routing Forwarding to use with the servers";
              leaf forwarding {
                tailf:info "Configure forwarding table";
                tailf:cli-diff-dependency "../../../../../../../ip/vrf";
                tailf:non-strict-leafref {
                  path "../../../../../../../ip/vrf/name";
                }
                type string {
                  tailf:info "WORD;;VRF name";
                }
              }
            }

            // aaa group server radius * / ip radius source-interface
            container radius {
              tailf:info "RADIUS configuration commands";
              container source-interface {
                tailf:info "Specify interface for source address in RADIUS packets";
                uses interface-name-grouping;
              }
            }
          }

          // aaa group server radius * / deadtime
          leaf deadtime {
            tailf:info "Specify time in minutes to ignore an unresponsive server";
            type uint16 {
              tailf:info "<0-1440>;;Dead-time in minutes for this server group";
              range "0..1440";
            }
          }

          // aaa group server radius * / throttle
          container throttle {
            tailf:info "Throttle requests to radius server";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf accounting {
              tailf:info "Throttle accounting requests sent to a radius server";
              tailf:cli-optional-in-sequence;
              type uint16 {
                tailf:info "<0-65535>;;Number of outstanding accounting transactions after which throttling should be performed";
              }
            }
            leaf access {
              tailf:info "Throttle access requests sent to a radius server";
              type uint16 {
                tailf:info "<0-65535>;;Number of outstanding access transactions after which throttling should be performed";
              }
            }
            leaf access-timeout {
              tailf:info "Number of consecutive timeouts exceeding which the access request is dropped";
              type uint8 {
                tailf:info "<1-10>;;Number of timeouts for a transaction (Default 3)";
                range "1..10";
              }
            }
          }

          // aaa group server radius * / retransmit
          leaf retransmit {
            tailf:info "Number of retries to active server (overrides default)";
            type uint8 {
              tailf:info "<0-100>;;Number of retries to this server for a transaction";
            }
          }

          // aaa group server radius * / timeout
          leaf timeout {
            tailf:info "Time to wait (in seconds) for this radius server to reply (overrides default)";
            type uint16 {
              tailf:info "<1-1000>;;Timeout value in seconds";
              range "1..1000";
            }
          }

          // aaa group server radius * / load-balance method least-outstanding
          container load-balance {
            tailf:info "Server group load-balancing options.";
            container method {
              tailf:info "Method by which the next host will be picked.";
              container least-outstanding {
                tailf:info "Pick the server with the least transactions outstanding.";
                tailf:cli-reset-container;
                tailf:cli-delete-when-empty;
                presence true;
                leaf batch-size {
                  tailf:info "Size of the transaction batch that should be load-balanced.";
                  type uint32 {
                    tailf:info "<1-2147483647>;;Number of transactions after which load-balancing should be performed (Default 25)";
                    range "1..2147483647";
                  }
                  default 25;
                }
              }
            }
          }

          // aaa group server radius * / attribute nas-port
          container attribute {
            tailf:info "Customize selected radius attributes";
            container nas-port {
              tailf:info "NAS-Port attribute configuration";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              choice attr-choice {
                leaf none {
                  tailf:info "Don't send nas-port attribute";
                  type empty;
                }
                case format {
                  leaf format {
                    tailf:info "Set the format of the NAS-Port attribute";
                    type enumeration {
                      enum a {
                        tailf:info "Format is type, channel, port";
                      }
                      enum b {
                        tailf:info "Either interface(16) or isdn(16), async(16)";
                      }
                      enum c {
                        tailf:info "Data format(bits): shelf(2), slot(4), port(5), channel(5)";
                      }
                      enum d {
                        tailf:info "Data format(bits): slot(4), module(1), port(3), vpi(8), vci(16)";
                      }
                      enum e {
                        tailf:info "Configurable data format";
                      }
                    }
                  }
                  leaf string {
                    tailf:cli-drop-node-name;
                    type string {
                      tailf:info "LINE;;A 32 character string representing the format to be used";
                    }
                  }
                }
              }
            }
          }
        }

        // aaa group server tacacs+ *
        list tacacs-plus {
          tailf:alt-name "tacacs+";
          tailf:info "Tacacs+ server-group definition";
          tailf:cli-mode-name "config-sg-tacacs+";
          tailf:cli-full-command;
          cli:ned-diff-move-after ">no aaa auth" {
            cli:arguments "when-delete";
          }
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Server-group name";
            }
          }

          // aaa group server tacacs+ * / server
          container server {
            tailf:info "Specify a TACACS server";

            // aaa group server tacacs+ * / server name *
            list name {
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-show-long-obu-diffs;
              ordered-by user;
              key name;
              leaf name {
                tailf:non-strict-leafref {
                  path "/ios:tacacs/server/name";
                }
                type string {
                  tailf:info "WORD;;Tacacs server name";
                }
              }
            }

            // aaa group server tacacs+ * / server *
            list server-list {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key name;
              leaf name {
                tailf:cli-disallow-value "name";
                type inet:host {
                  tailf:info "Hostname or A.B.C.D;;IP address of TACACS server";
                }
              }
            }
          }

          // aaa group server tacacs+ * / server-private *
          list server-private {
            tailf:info "Define a private TACACS server (per group)";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            key name;
            leaf name {
              type inet:host {
                tailf:info "Hostname or A.B.C.D;;IP address of TACACS server";
              }
            }

            // aaa group server tacacs+ * / server-private * timeout
            leaf timeout {
              tailf:info "Time to wait for this TACACS server to reply (overrides default)";
              tailf:cli-optional-in-sequence;
              type uint16 {
                tailf:info "<1-1000>;;Timeout value in seconds to wait for server to reply";
                range "1..1000";
              }
            }

            // aaa group server tacacs+ * / server-private * key
            container key {
              tailf:info "per-server encryption key (overrides default)";
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              uses password-grouping {
                refine "secret" {
                  cli:secret " key <SECRET>";
                }
              }
            }
          }

          // aaa group server tacacs+ * / ip
          container ip {
            tailf:info "Internet Protocol config commands";

            // aaa group server tacacs+ * / ip vrf forwarding
            container vrf {
              tailf:info "Set VPN Routing Forwarding to use with the servers";
              leaf forwarding {
                tailf:info "Configure forwarding table";
                tailf:cli-diff-dependency "../../../../../../../ip/vrf";
                tailf:non-strict-leafref {
                  path "../../../../../../../ip/vrf/name";
                }
                type string {
                  tailf:info "WORD;;VRF name";
                }
              }
            }

            // aaa group server tacacs+ * / ip tacacs source-interface
            container tacacs {
              tailf:info "TACACS configuration commands";
              container source-interface {
                tailf:info "Specify interface for source address in TACACS packets";
                uses interface-name-grouping;
              }
            }
          }

          // aaa group server tacacs+ * / ipv6
          container ipv6 {
            tailf:info "IPv6 config commands";
            tailf:cli-diff-dependency "../../../../../ipv6/unicast-routing";

            // aaa group server tacacs+ * / ipv6 vrf forwarding
            container vrf {
              tailf:info "Set VPN Routing Forwarding to use with the servers";
              leaf forwarding {
                tailf:info "Configure forwarding table";
                tailf:cli-diff-dependency "../../../../../../../ip/vrf";
                tailf:non-strict-leafref {
                  path "../../../../../../../ip/vrf/name";
                }
                type string {
                  tailf:info "WORD;;VRF name";
                }
              }
            }

            // aaa group server tacacs+ * / ipv6 tacacs source-interface
            container tacacs {
              tailf:info "TACACS configuration commands";
              container source-interface {
                tailf:info "Specify interface for source address in TACACS packets";
                uses interface-name-grouping;
              }
            }
          }

          // aaa group server tacacs+ * / timeout
          leaf timeout {
            tailf:info "Time to wait for a TACACS server to reply";
            type uint16 {
              tailf:info "<1-1000>;;Wait time (default 5 seconds)";
              range "1..1000";
            }
            default 5;
          }
        }
      }
    }

    // aaa authentication
    container authentication {
      tailf:info "Authentication configurations parameters.";
      tailf:cli-diff-dependency "../new-model";

      // aaa authentication banner
      leaf banner {
        tailf:info "Message to use when starting login/authentication.";
        tailf:cli-no-value-on-delete;
        type string {
          tailf:info "LINE;;Quoted string. Use \\r\\n for newline. delimeter ^ is added automatically.";
        }
      }

      // aaa authentication fail-message
      leaf fail-message {
        tailf:info "Message to use for failed login/authentication.";
        tailf:cli-no-value-on-delete;
        type string {
          tailf:info "LINE;;Quoted string. Use \\r\\n for newline. delimeter ^ is added automatically.";
        }
      }

      // aaa authentication attempts login
      container attempts {
        tailf:info "Set the maximum number of authentication attempts";
        leaf login {
          tailf:info "Set the max. number of attempts for login service";
          type uint8 {
            tailf:info "<1-25>;;Specify value for the number of attempts. Default 3";
            range "1..25";
          }
          default 3;
        }
      }

      // aaa authentication username-prompt
      leaf username-prompt {
        tailf:info "Text to use when prompting for a username";
        type string {
          tailf:info "WORD;;Text of prompt";
        }
      }

      // aaa authentication password-prompt
      leaf password-prompt {
        tailf:info "Text to use when prompting for a password";
        type string {
          tailf:info "WORD;;Text of prompt";
        }
      }

      // aaa authentication dot1x *
      list dot1x {
        tailf:info "Set authentication lists for IEEE 802.1x.";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type aaa-authentication-name-type;
        }
        uses aaa-authentication-method-grouping;
      }

      // aaa authentication login *
      list login {
        tailf:info "Set authentication lists for logins.";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type aaa-authentication-name-type;
        }
        uses aaa-authentication-method-grouping;
      }

      // aaa authentication enable default
      container enable {
        tailf:info "Set authentication list for enable.";
        container default {
          tailf:info "The default authentication list.";
          tailf:cli-compact-syntax;
          uses aaa-authentication-method-grouping;
        }
      }

      // aaa authentication ppp *
      list ppp {
        tailf:info "Set authentication lists for ppp.";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type aaa-authentication-name-type;
        }
        uses aaa-authentication-method-grouping;
      }
    }

    // aaa authorization
    container authorization {
      tailf:info "Authorization configurations parameters.";
      tailf:cli-incomplete-command;
      tailf:cli-diff-dependency "../new-model";

      // aaa authorization console
      leaf console {
        tailf:info "For enabling console authorization";
        type empty;
      }

      // aaa authorization config-commands
      leaf config-commands {
        tailf:info "For configuration mode commands.";
        type empty;
      }

      // aaa authorization exec *
      list exec {
        tailf:info "For starting an exec (shell).";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        tailf:cli-reset-container;
        key name;
        leaf name {
          type aaa-authorization-name-type;
        }
        uses aaa-authorization-method-grouping;
      }

      // aaa authorization commands *
      list commands {
        tailf:info "For exec (shell) commands.";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        tailf:cli-reset-container;
        key "level name";
        leaf level {
          type uint8 {
            tailf:info "<0-15>;;Enable level";
            range "0..15";
          }
        }
        leaf name {
          type aaa-authorization-name-type;
        }
        uses aaa-authorization-method-grouping;
      }

      // aaa authorization eventmanager *
      list eventmanager {
        tailf:info "For starting an exec (shell).";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type aaa-authorization-name-type;
        }
        uses aaa-authorization-method-grouping;
      }

      // aaa authorization network *
      list network {
        tailf:info "For network services. (PPP, SLIP, ARAP)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type aaa-authorization-name-type;
        }
        uses aaa-authorization-method-grouping;
      }

      // aaa authorization auth-proxy *
      list auth-proxy {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type aaa-authorization-name-type;
        }
        uses aaa-authorization-method-grouping;
      }

      // aaa authorization subscriber-service *
      list subscriber-service {
        tailf:info "For iEdge subscriber services (VPDN etc)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        tailf:cli-reset-container;
        key name;
        leaf name {
          type aaa-authorization-name-type;
        }
        uses aaa-authorization-method-grouping;
      }

      // aaa authorization reverse-access *
      list reverse-access {
        tailf:info "For reverse access connections";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        tailf:cli-reset-container;
        key name;
        leaf name {
          type aaa-authorization-name-type;
        }
        uses aaa-authorization-method-grouping;
      }

      // aaa authorization credential-download *
      list credential-download {
        tailf:info "For downloading EAP credential from Local/RADIUS/LDAP";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        tailf:cli-reset-container;
        key name;
        leaf name {
          type aaa-authorization-name-type;
        }
        uses aaa-authorization-method-grouping;
      }
    }

    // aaa accounting
    container accounting {
      tailf:info "Accounting configurations parameters.";
      tailf:cli-incomplete-command;
      tailf:cli-diff-dependency "../new-model";

      // aaa accounting send stop-record authentication
      container send {
        tailf:info "Send records to accounting server.";
        container stop-record {
          tailf:info "Generate STOP records for a specified event.";
          container authentication {
            tailf:info "Generate STOP records for authentication failures.";

            // aaa accounting send stop-record authentication failure
            leaf failure {
              tailf:info "Generate STOP records for authentication failures.";
              type empty;
            }

            // aaa accounting send stop-record authentication failure vrf *
            container failure-vrf {
              tailf:cli-drop-node-name;
              container failure {
                tailf:info "Generate STOP records for authentication failures.";
                tailf:cli-incomplete-command;
                tailf:cli-incomplete-no;
                list vrf {
                  tailf:info "VPN Routing/Forwarding parameters";
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  key name;
                  leaf name {
                    tailf:cli-diff-dependency "../../../../../../../../../ip/vrf";
                    tailf:cli-diff-dependency "../../../../../../../../../vrf/definition";
                    type string {
                      tailf:info "WORD;;VRF name";
                    }
                  }
                }
              }
            }
          }
        }
      }

      // aaa accounting nested
      container nested {
        tailf:info "When starting PPP from EXEC, generate NETWORK records before EXEC-STOP record.";
        tailf:cli-delete-when-empty;
        presence true;
        // aaa nested suppress stop
        container suppress {
          tailf:info "Exec accounting records suppression options";
          leaf stop {
            tailf:info "Suppress stop record for exec if network start record sent";
            type empty;
          }
        }
      }

      // aaa accounting commands *
      list commands {
        tailf:info "For exec (shell) commands.";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        key "level name";
        leaf level {
          type uint8 {
            tailf:info "<0-15>;;Enable level";
            range "0..15";
          }
        }
        leaf name {
          type aaa-accounting-name-type;
        }
        uses aaa-accounting-method-grouping;
      }

      // aaa accounting exec *
      list exec {
        tailf:info "For starting an exec (shell).";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        key name;
        leaf name {
          type aaa-accounting-name-type;
        }
        uses aaa-accounting-method-grouping;
      }

      // aaa accounting network *
      list network {
        tailf:info "For network services. (PPP, SLIP, ARAP)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        key name;
        leaf name {
          type aaa-accounting-name-type;
        }
        uses aaa-accounting-method-grouping;
      }

      // aaa accounting auth-proxy *
      list auth-proxy {
        tailf:info "For authentication proxy events.";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        key name;
        leaf name {
          type aaa-accounting-name-type;
        }
        uses aaa-accounting-method-grouping;
      }

      // aaa accounting identity *
      list identity {
        tailf:info "For identity sessions.";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        key name;
        leaf name {
          type aaa-accounting-name-type;
        }
        uses aaa-accounting-method-grouping;
      }

      // aaa accounting connection *
      list connection {
        tailf:info "For outbound connections. (telnet, rlogin)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        key name;
        leaf name {
          type aaa-accounting-name-type;
        }
        uses aaa-accounting-method-grouping;
      }

      // aaa accounting dot1x *
      list dot1x {
        tailf:info "For dot1x sessions.";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        key name;
        leaf name {
          type aaa-accounting-name-type;
        }
        uses aaa-accounting-method-grouping;
      }

      // aaa accounting multicast default
      container multicast {
        tailf:info "For multicast accounting.";
        container default {
          tailf:info "The default accounting list.";
          tailf:cli-compact-syntax;
          tailf:cli-delete-when-empty;
          tailf:cli-reset-container;
          presence true;
          uses aaa-accounting-method-grouping;
        }
      }

      // aaa accounting onep default
      container onep {
        tailf:info "For ONEP events.";
        container default {
          tailf:info "The default accounting list.";
          tailf:cli-compact-syntax;
          tailf:cli-delete-when-empty;
          tailf:cli-reset-container;
          presence true;
          uses aaa-accounting-method-grouping;
        }
      }

      // aaa accounting system default
      container system {
        tailf:info "For system events.";

        // aaa accounting system default
        container default {
          tailf:cli-compact-syntax;
          tailf:cli-delete-when-empty;
          tailf:cli-reset-container;
          presence true;
          uses aaa-accounting-method-grouping;
        }

        // no aaa accounting system guarantee-first
        leaf guarantee-first {
          tailf:info "Guarantee system accounting as first record.";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }
      }

      // aaa accounting suppress
      container suppress {
        tailf:info "Do not generate accounting records for a specific type of user.";
        leaf null-username {
          tailf:info "Do not generate accounting records for users with a null-username";
          type empty;
        }
      }

      // aaa accounting session-duration ntp-adjusted
      container session-duration {
        tailf:info "Set the preference for calculating session durations";
        leaf ntp-adjusted {
          tailf:info "Session durations will be calculated with NTP adjusted clock";
          type empty;
        }
      }

      // aaa accounting jitter maximum
      container jitter {
        tailf:info "Set jitter parameters for periodic interval";
        leaf maximum {
          tailf:info "Set maximum jitter value for periodic interval(in seconds)";
          type uint32 {
            tailf:info "<0-2147483>;;Maximum jitter value for periodic interval(in seconds), default is 300 seconds";
            range "0..2147483";
          }
          default 300;
        }
      }

      // aaa accounting update
      container update {
        tailf:info "Enable accounting update records.";
        tailf:cli-compact-syntax;
        leaf newinfo {
          tailf:info "Only send accounting update records when we have new acct info.";
          type empty;
        }
        leaf periodic {
          tailf:info "Send accounting update records at regular intervals.";
          type uint32 {
            tailf:info "<1-71582>;;Periodic intervals to send accounting update records(in minutes)";
            range "1..71582";
          }
        }
        container jitter {
          tailf:info "Set jitter parameters for periodic interval (DEPRECATED)";
          tailf:cli-flatten-container;
          leaf maximum {
            tailf:info "Set maximum jitter value for periodic interval(in seconds)";
            type uint32 {
              tailf:info "<0-2147483>;;Maximum jitter value for periodic interval(in seconds), default is 300 seconds";
            }
          }
        }
      }

      // aaa accounting delay-start
      container delay-start {
        tailf:info "Delay PPP Network start record until peer IP address is known.";
        //tailf:cli-keep-when-empty;
        presence true;
        // aaa accounting delay-start all
        leaf all {
          tailf:info "Delay start records for all vrf and non-vrf users.";
          type empty;
        }
      }
    }

    // aaa common-criteria policy *
    container common-criteria {
      tailf:info "AAA Common Criteria";
      list policy {
        tailf:info "Policy definition";
        tailf:cli-mode-name "config-cc-policy";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Policy name";
          }
        }

        // aaa common-criteria policy * / min-length
        leaf min-length {
          tailf:info "Specify the minimum length of the password";
          type uint8 {
            tailf:info "<1-127>;;Min Length 1-127";
            range "1..127";
          }
        }

        // aaa common-criteria policy * / max-length
        leaf max-length {
          tailf:info "Specify the maximum length of the password";
          type uint8 {
            tailf:info "<1-127>;;Max Length 1-127";
            range "1..127";
          }
        }

        // aaa common-criteria policy * / numeric-count
        leaf numeric-count {
          tailf:info "Number of numeric characters";
          type uint8 {
            tailf:info "<0-127>;;Number of digits from 0-127";
            range "0..127";
          }
        }

        // aaa common-criteria policy * / special-case
        leaf special-case {
          tailf:info "Number of special characters";
          type uint8 {
            tailf:info "<0-127>;;Number of digits from 0-127";
            range "0..127";
          }
        }

        // aaa common-criteria policy * / char-changes
        leaf char-changes {
          tailf:info "Number of change characters between old and new passwords";
          type uint8 {
            tailf:info "<1-127>;;Change range 1-127";
          }
        }

        // aaa common-criteria policy * / upper-case
        leaf upper-case {
          tailf:info "Number of upper-case characters";
          type uint8 {
            tailf:info "<0-127>;;Number of upper-case characters from 0-127";
          }
        }

        // aaa common-criteria policy * / lower-case
        leaf lower-case {
          tailf:info "Number of lower-case characters";
          type uint8 {
            tailf:info "<0-127>;;Number of lower-case characters from 0-127";
          }
        }
      }
    }

    // aaa session-id
    leaf session-id {
      tailf:info "AAA Session ID";
      tailf:cli-diff-dependency "../new-model";
      ios:delete-syntax "!";
      type enumeration {
        enum common {
          tailf:info "Common Session ID";
        }
        enum "unique" {
          tailf:info "Unique Session ID for different accounting types";
        }
      }
    }

    // aaa policy interface-config allow-subinterface
    container policy {
      tailf:info "AAA policy parameters";
      container interface-config {
        tailf:info "LCP interface config policy parameters";
        leaf allow-subinterface {
          tailf:info "Do not by default create a full virtual-access";
          type empty;
        }
      }
    }

    // aaa attribute list *
    container attribute {
      tailf:info "AAA attribute definitions";
      tailf:cli-diff-dependency "../new-model";
      list list {
        tailf:info "AAA attribute list definition";
        tailf:cli-mode-name "config-attr-list";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;name";
          }
        }

        // aaa attribute list * / attribute type
        container attribute {
          tailf:info "Specify an AAA attribute";
          container type {
            tailf:info "Specify an AAA attribute type";

            // aaa attribute list * / attribute type interface-config *
            list interface-config {
              tailf:info "Configuration commands for an interface";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-show-long-obu-diffs;
              ordered-by user;
              key line;
              leaf line {
                type string {
                  tailf:info "WORD;;string";
                }
              }
            }

            // aaa attribute list * / attribute type * *
            list list {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-incomplete-command;
              tailf:cli-incomplete-no;
              key name;
              leaf name {
                tailf:cli-disallow-value "interface-config";
                type string {
                  tailf:info "WORD;;Attribute name";
                }
              }
              list attributes {
                tailf:cli-drop-node-name;
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                tailf:cli-show-long-obu-diffs;
                ordered-by user;
                key line;
                leaf line {
                  type string {
                    tailf:info "WORD;;string";
                  }
                }
              }
            }
          }
        }
      }
    }

    // aaa server radius dynamic-author
    container server {
      tailf:info "Local AAA server";
      tailf:cli-diff-dependency "../new-model";
      container radius {
        tailf:info "Profile for local radius server";
        container dynamic-author {
          tailf:info "Local server profile for RFC 3576 support";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-locsvr-da-radius";

          // aaa server radius dynamic-author / client *
          list client {
            tailf:info "Specify a RADIUS client";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-show-long-obu-diffs;
            ordered-by user;
            key address;
            leaf address {
              type inet:host {
                tailf:info "Hostname or A.B.C.D;;IP address of RADIUS client";
              }
            }

            // aaa server radius dynamic-author / client * server-key
            container server-key {
              tailf:info "Specify a RADIUS client server-key";
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              uses password-grouping {
                refine "secret" {
                  cli:secret " server-key <SECRET>";
                }
              }
            }
          }

          // aaa server radius dynamic-author / port
          leaf port {
            tailf:info "Specify port on which local radius server listens";
            type uint16 {
              tailf:info "<0-65535>;;Radius server port (default is 1700)";
            }
            default 1700;
          }

          // aaa server radius dynamic-author / auth-type
          leaf auth-type {
            tailf:info "Specify the server authorization type";
            type enumeration {
              enum all {
                tailf:info "Matches when all attributes match";
              }
              enum any {
                tailf:info "Matches when all sent attributes match";
              }
              enum session-key {
                tailf:info "Matches with session key attribute only";
              }
            }
          }

          // aaa server radius dynamic-author / server-key
          container server-key {
            tailf:info "Encryption key shared with the radius clients";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            uses password-grouping {
              refine "secret" {
                cli:secret " server-key <SECRET>";
              }
            }
          }

          // aaa server radius dynamic-author / ignore
          container ignore {
            tailf:info "Override behaviour to ignore certain parameters";
            leaf session-key {
              tailf:info "Ignore attr 151";
              type empty;
            }
            leaf server-key {
              tailf:info "Ignore shared secret";
              type empty;
            }
            leaf retransmission {
              tailf:info "Drop packets using same radius id";
              type empty;
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// ppp
  /// ========================================================================

  container ppp {
    tailf:info "PPP global configuration";

    // ppp packet throttle
    container packet {
      tailf:info "Configure control packet rate throttling";
      container throttle {
        tailf:info "Configure control packet rate throttling";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf N {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<1-100000>;;Number of control packets allowed per session per specific time";
            range "1..100000";
          }
        }
        leaf T1 {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<1-3600>;;Time in seconds for allowing N packets per session";
            range "1..3600";
          }
        }
        leaf T2 {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<6-3600>;;Time in seconds for blocking packets per session";
            range "6..3600";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// pppoe
  /// ========================================================================

  container pppoe {
    tailf:info "Point to Point Protocol over Ethernet";

    // pppoe intermediate-agent format-type
    container intermediate-agent {
      tailf:info "Intermediate Agent";
      tailf:cli-incomplete-command;
      tailf:cli-incomplete-no;
      container format-type {
        tailf:info "Tag Format";

        // pppoe intermediate-agent format-type circuit-id
        container circuit-id {
          tailf:info "Circuit Id";
          choice circuit-id-choice {
            container hostname {
              tailf:info "add hostname in the circuit-id";
              leaf portname {
                tailf:info "add interface name in the circuit-id";
                type empty;
              }
            }
            leaf string {
              tailf:info "User defined string for circuit-id";
              type string {
                tailf:info "WORD;;Use string for circuit-id (max length 63 characters)";
              }
            }
          }
        }
      }
    }

    // pppoe intermediate-agent
    container intermediate-agent-enable {
      tailf:cli-drop-node-name;
      leaf intermediate-agent {
        tailf:info "Intermediate Agent";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// svclc
  /// ========================================================================

  container svclc {
    tailf:info "Specify secure VLANs groups and tie them to svclc modules";

    // svclc vlan-group *
    list vlan-group {
      tailf:info "Secure group which VLANs will be tied to";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      key id;
      leaf id {
        tailf:cli-suppress-range;
        type uint16 {
          tailf:info "<1-65535>;;group-number";
          range "1..65535";
        }
      }
      leaf-list vlan {
        tailf:cli-drop-node-name;
        tailf:cli-range-list-syntax;
        type uint16 {
          tailf:info "WORD;;vlan range (2-1001,1006-4094) ex: 2-65,72,300-320";
        }
      }
    }
  }


  /// ========================================================================
  /// wan
  /// ========================================================================

  container wan {
    leaf mode {
      type enumeration {
        enum dsl;
        enum ethernet;
      }
    }
  }


  /// ========================================================================
  /// cisp
  /// ========================================================================

  // cisp enable
  container cisp {
    tailf:info "Set CISP parameters";
    leaf enable {
      tailf:info "Enable CISP";
      type empty;
    }
  }


  /// ========================================================================
  /// switch
  /// ========================================================================

  container switch {
    tailf:info "Config commands for the switches in the stack";

    // switch virtual domain *
    container virtual {
      tailf:info "Virtual switch configuration mode";
      list domain {
        tailf:info "Virtual switch domain";
        tailf:cli-mode-name "config-vs-domain";
        key id;
        leaf id {
          tailf:cli-suppress-range;
          type uint8 {
            tailf:info "<1-255>;;Virtual switch domain number";
            range "1..255";
          }
        }

        // switch virtual domain * / switch
        container switch {
          tailf:info "Configure switch command";

          // switch virtual domain * / switch * priority
          list list {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key id;
            leaf id {
              type uint8 {
                tailf:info "<1-2>;;Virtual switch number";
              }
            }
            leaf priority {
              tailf:info "Virtual switch priority";
              type uint8 {
                tailf:info "<1-255>;;Virtual switch priority value";
                range "1..255";
              }
            }
          }

          // switch virtual domain * / switch mode virtual
          container mode {
            leaf virtual {
              type empty;
            }
          }
        }

        // switch virtual domain * / mac-address
        leaf mac-address {
          tailf:info "router mac address scheme";
          type union {
            type string {
              tailf:info "H.H.H;;Manually set router mac address";
            }
            type enumeration {
              enum chassis {
                tailf:info "Use mac-address range reserved for Chassis";
              }
              enum use-virtual {
                tailf:info "Use mac-address range reserved for Virtual Switch System ";
              }
            }
          }
        }

        // switch virtual domain * / dual-active
        container dual-active {
          tailf:info "Virtual switch dual-active config";

          // switch virtual domain * / dual-active detection
          container detection {
            tailf:info "Dual-active detection enable";

            // switch virtual domain * / dual-active detection pagp channel-group *
            container pagp {
              tailf:info "Dual-active detection pagp enable";
              container trust {
                tailf:info "Dual-active trust mode";
                list channel-group {
                  tailf:info "Etherchannel/port bundling to be used for pagp dual-active detection";
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  key id;
                  leaf id {
                    type uint16 {
                      tailf:info "<1-512>;;Channel group number";
                      range "1..512";
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // switch * provision
    list list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      key id;
      leaf id {
        type uint8 {
          tailf:info "<1-9>;;Switch Number";
          range "1..9";
        }
      }
      leaf provision {
        tailf:info "Configure Switch provision / offline config";
        type string {
          tailf:info "WORD;;provision a XXX switch with YYY";
        }
      }
    }
  }


  /// ========================================================================
  /// stackwise-virtual
  /// ========================================================================

  // stackwise-virtual
  container stackwise-virtual {
    tailf:info "Enter Stackwise Virtual mode";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-stackwise-virtual";
    presence true;

    // stackwise-virtual / domain
    leaf domain {
      tailf:info "Set the Stackwise Virtual switch domain number";
      type uint8 {
        tailf:info "<1-255>;;Stackwise Virtual switch domain number";
        range "1..255";
      }
    }
  }


  /// ========================================================================
  /// resource
  /// ========================================================================

  container resource {
    tailf:info "Configure Embedded Resource Manager (ERM)";

    // resource policy
    container policy {
      tailf:info "policy  Configure Embedded Resource Manager (ERM)";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-erm";
      tailf:cli-full-command;
      presence true;

      // resource policy / policy * global
      list policy {
        tailf:info "Configure Resource Policy";
        tailf:cli-mode-name "config-erm-policy";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Resource Policy Name";
          }
        }
        leaf global {
          tailf:info "Configure a Global Policy";
          tailf:cli-hide-in-submode;
          type empty;
        }

        // resource policy / policy * global / system
        leaf system {
          tailf:info "Configure System Level Resource Owners";
          type empty;
        }
      }
    }
  }


  /// ========================================================================
  /// cns
  /// ========================================================================

  container cns {
    tailf:info "CNS agents";

    // no cns aaa enable
    container aaa {
      tailf:info "CNS AAA options";
      leaf enable {
        tailf:info "enable AAA operation";
        tailf:cli-boolean-no;
        type boolean;
        default true;
      }
    }

    // cns trusted-server *
    list trusted-server {
      tailf:info "Trusted Server Configuration";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key "agent name";
      leaf agent {
        type enumeration {
          enum "all-agents" {
            tailf:info "trusted  for all agents";
          }
          enum "config" {
            tailf:info "trusted for config agent";
          }
          enum "event" {
            tailf:info "trusted for event agent";
          }
          enum "exec" {
            tailf:info "trusted for exec agent";
          }
          enum "image" {
            tailf:info "trusted for image agent";
          }
        }
      }
      leaf name {
        type string {
          tailf:info "WORD;;Host name or address of trusted-server";
        }
      }
    }

    // cns id
    container id {
      tailf:info "Get CNS ID for CNS agents";

      // cns id string
      leaf string {
        tailf:info "Use an arbitrary string as the unique ID";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;e.g. hostname";
        }
      }

      // cns id string ? image
      // cns id string ? event
      container id-services-list {
        tailf:cli-drop-node-name;
        list string {
          tailf:info "Use an arbitrary string as the unique ID";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          key service;
          leaf string {
            tailf:cli-prefix-key;
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;e.g. hostname";
            }
          }
          leaf service {
            type enumeration {
              enum event {
                tailf:info "Set this ID as the event ID";
              }
              enum image {
                tailf:info "Set this ID as the image ID";
              }
            }
          }
        }
      }
    }

    // cns event *
    list event {
      tailf:info "Event Agent";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Host name or ip address of event gateway";
        }
      }
      leaf port-number {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<0-65535>;;Event Gateway port number, default is 11011";
          range "0..65535";
        }
      }
      // cns event * source
      container source {
        tailf:info "bind socket to a source ip";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        uses interface-name-grouping;
      }
      // cns event * keepalive
      container keepalive {
        tailf:info "Keepalive timeout retry_count";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf seconds {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<0-65535>;;timeout in seconds , default is 0";
          }
        }
        leaf retry-count {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-65535>;;retry count , default is 0";
          }
        }
      }
    }

    // cns image X
    container image {
      tailf:info "CNS Image Agent";
      tailf:cli-incomplete-command;
      tailf:cli-incomplete-no;

      // cns image server
      container server {
        tailf:info "CNS Image Agent management server";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf server-url {
          tailf:cli-drop-node-name;
          tailf:cli-remove-before-change;
          type string {
            tailf:info "WORD;;URL to POST to for the management server";
          }
        }
        leaf status {
          tailf:info "CNS Image Agent status server";
          type string {
            tailf:info "WORD;;URL to POST status messages to";
          }
        }
      }
    }

    // cns config
    container config {
      tailf:info "Configuration Agent";

      // cns config notify
      container notify {
        tailf:info "Configuration change notification";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf capture {
          tailf:cli-drop-node-name;
          type enumeration {
            enum all {
              tailf:info "notify all config commands";
            }
            enum diff {
              tailf:info "notify config changes only";
            }
          }
        }
        leaf interval {
          tailf:info "send config change event if nothing entered in config mode for this many minutes";
          type uint16 {
            tailf:info "<0-35791>;;number in minutes, default is 5";
            range "0..35791";
          }
        }
      }

      // cns config initial
      container initial {
        tailf:info "Initial Configuration";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf host {
          tailf:cli-drop-node-name;
          tailf:cli-remove-before-change;
          type inet:host {
            tailf:info "WORD;;Host name or address of configuration server";
          }
        }
        leaf port-number {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-65535>;;the port number of the config service. default is 80";
          }
        }
      }

      // cns config partial
      container partial {
        tailf:info "Partial Configuration";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf host {
          tailf:cli-drop-node-name;
          tailf:cli-remove-before-change;
          type inet:host {
            tailf:info "WORD;;Host name or address of configuration server";
          }
        }
        leaf port-number {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-65535>;;the port number of the config service. default is 80";
          }
        }
      }
    }

    // cns exec
    list exec {
      tailf:info "Exec Agent";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      max-elements 1;
      key port-number;
      leaf encrypt {
        tailf:info "Use an encrypted link to the server";
        tailf:cli-prefix-key;
        tailf:cli-optional-in-sequence;
        type empty;
      }
      leaf port-number {
        type uint16 {
          tailf:info "<1-65535>;;port number of plaintext exec service.";
          range "1..65535";
        }
      }
      container source {
        tailf:info "bind socket to a source ip";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        uses interface-name-grouping;
      }
    }

    // cns dhcp
    leaf dhcp {
      tailf:info "Allow DHCP option 43 message to pass in config commands";
      type empty;
    }

    // cns image
    container image-enable {
      tailf:cli-drop-node-name;
      leaf image {
        tailf:info "CNS Image Agent";
        tailf:cli-diff-delete-before "../../image";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// epm
  /// ========================================================================

  container epm {
    tailf:info "EPM Global Configuration Commands";

    // epm access-control Open
    leaf access-control {
      tailf:info "set the access-control directive";
      type enumeration {
        enum Open {
          tailf:info "Enable/Disable the Open Access control directive";
        }
      }
    }

    // epm logging
    leaf logging {
      tailf:info "Enable EPM logging";
      type empty;
    }
  }


  /// ========================================================================
  /// clock
  /// ========================================================================

  container clock {
    tailf:info "Configure time-of-day clock";

    // clock timezone
    container timezone {
      tailf:info "Configure time zone";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf zone {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type string {
          tailf:info "WORD;;name of time zone";
        }
      }
      leaf offset {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        tailf:cli-incomplete-command;
        type enumeration {
          enum +;
          enum -;
        }
      }
      leaf hours {
        tailf:cli-drop-node-name;
        type int8 {
          tailf:info "<-23 - 23>;;Hours offset from UTC";
          range "-23..23";
        }
      }
      leaf minutes {
        tailf:cli-drop-node-name;
        type int8 {
          tailf:info "<0-59>;;Minutes ofset from UTC";
          range "0..59";
        }
      }
    }

    // clock summer-time
    container summer-time {
      tailf:info "Configure summer (daylight savings) time";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf zone {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        tailf:cli-disallow-value "date|recurring";
        type string {
          tailf:info "WORD;;name of time zone in summer";
        }
      }
      choice summer-choice {
        // clock summer-time date
        case date-case {
          leaf date {
            tailf:info "Configure absolute summer time";
            type empty;
          }
          leaf date-start-month {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type month-type {
              tailf:info "MONTH;;Month to start";
            }
          }
          leaf date-start-date {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<1-31>;;Date to start";
              range "1..31";
            }
          }
          leaf date-start-year {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<1993-2035>;;Year to start";
              range "1993..2035";
            }
          }
          leaf date-start-time {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type hhmm-type {
              tailf:info "hh:mm;;Time to start (hh:mm)";
            }
          }
          leaf date-end-month {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type month-type {
              tailf:info "MONTH;;Month to end";
            }
          }
          leaf date-end-date {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<1-31>;;Date to end";
              range "1..31";
            }
          }
          leaf date-end-year {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<1993-2035>;;Year to end";
              range "1993..2035";
            }
          }
          leaf date-end-time {
            tailf:cli-drop-node-name;
            type hhmm-type {
              tailf:info "hh:mm;;Time to end (hh:mm)";
            }
          }
          leaf date-offset {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<1-1440>;;Offset to add in minutes";
              range "1..1440";
            }
          }
        }

        // clock summer-time recurring
        case recurring-case {
          leaf recurring {
            tailf:info "Configure recurring summer time";
            type empty;
          }
          leaf start {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type union {
              type uint8 {
                tailf:info "<1-4>;;Week number to start";
                range "1..4";
              }
              type enumeration {
                enum first {
                  tailf:info "First week of the month";
                }
                enum last {
                  tailf:info "Last week of the month";
                }
              }
            }
          }
          leaf start-day {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type weekday-type {
              tailf:info "DAY;;Weekday to start";
            }
          }
          leaf start-month {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type month-type {
              tailf:info "MONTH;;Month to start";
            }
          }
          leaf start-time {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type hhmm-type {
              tailf:info "hh:mm;;Time to start (hh:mm)";
            }
          }
          leaf end {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type union {
              type uint8 {
                tailf:info "<1-4>;;Week number to end";
                range "1..4";
              }
              type enumeration {
                enum first {
                  tailf:info "First week of the month";
                }
                enum last {
                  tailf:info "Last week of the month";
                }
              }
            }
          }
          leaf end-day {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type weekday-type {
              tailf:info "DAY;;Weekday to end";
            }
          }
          leaf end-month {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type month-type {
              tailf:info "MONTH;;Month to end";
            }
          }
          leaf end-time {
            tailf:cli-drop-node-name;
            type hhmm-type {
              tailf:info "hh:mm;;Time to end (hh:mm)";
            }
          }
          leaf offset {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<1-1440>;;Offset to add in minutes";
              range "1..1440";
            }
          }
        }
      }
    }

    // clock calendar-valid
    container calendar-valid {
      tailf:info "Calendar time is authoritative";
      presence true;
    }

  }


  /// ========================================================================
  /// device-sensor
  /// ========================================================================

  container device-sensor {
    tailf:info "IOS Sensor Commands";

    // device-sensor filter-list
    container filter-list {
      tailf:info "Sensor Protocol Filter List Configuration";

      // device-sensor filter-list cdp list *
      container cdp {
        tailf:info "CDP Filter List";
        list list {
          tailf:cli-mode-name "config-sensor-cdplist";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;TLV/Option List name";
            }
          }

          // device-sensor filter-list cdp list * / tlv
          container tlv {
            tailf:info "tlv types list";

            // device-sensor filter-list cdp list * / tlv name *
            leaf-list name {
              tailf:info "tlv names";
              tailf:cli-list-syntax;
              type string {
                tailf:info "WORD;;Type name";
              }
            }
          }
        }
      }

      // device-sensor filter-list lldp list *
      container lldp {
        tailf:info "LLDP Filter List";
        list list {
          tailf:cli-mode-name "config-sensor-lldplist";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;TLV/Option List name";
            }
          }

          // device-sensor filter-list cdp list * / tlv
          container tlv {
            tailf:info "tlv types list";

            // device-sensor filter-list cdp list * / tlv name *
            leaf-list name {
              tailf:info "tlv names";
              tailf:cli-list-syntax;
              type string {
                tailf:info "WORD;;Type name";
              }
            }
          }
        }
      }

      // device-sensor filter-list dhcp list *
      container dhcp {
        tailf:info "DHCP Filter List";
        list list {
          tailf:info "Protocol Filter List";
          tailf:cli-mode-name "config-sensor-dhcplist";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;TLV/Option List name";
            }
          }

          // device-sensor filter-list dhcp list * / option name *
          container option {
            tailf:info "option types list";
            leaf-list name {
              tailf:info "option names";
              tailf:cli-list-syntax;
              type string {
                tailf:info "WORD;;Option name";
              }
            }
          }
        }
      }
    }

    // device-sensor filter-spec
    container filter-spec {
      tailf:info "Sensor Protocol Filter Spec Configuration";

      // device-sensor filter-spec dhcp
      container dhcp {
        tailf:info "DHCP Filter Spec";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf type {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type enumeration {
            enum exclude {
              tailf:info "Exclude Filter";
            }
            enum include {
              tailf:info "Include Filter";
            }
          }
        }
        choice list-choice {
          leaf all {
            tailf:info "All";
            type empty;
          }
          leaf list {
            tailf:info "Protocol Filter Spec list";
            tailf:non-strict-leafref {
              path "../../../filter-list/dhcp/list/name";
            }
            type string {
              tailf:info "WORD;;TLV/Option List name";
            }
          }
        }
      }

      // device-sensor filter-spec lldp
      container lldp {
        tailf:info "LLDP Filter Spec";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf type {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type enumeration {
            enum exclude {
              tailf:info "Exclude Filter";
            }
            enum include {
              tailf:info "Include Filter";
            }
          }
        }
        choice list-choice {
          leaf all {
            tailf:info "All";
            type empty;
          }
          leaf list {
            tailf:info "Protocol Filter Spec list";
            tailf:non-strict-leafref {
              path "../../../filter-list/lldp/list/name";
            }
            type string {
              tailf:info "WORD;;TLV/Option List name";
            }
          }
        }
      }

      // device-sensor filter-spec cdp
      container cdp {
        tailf:info "CDP Filter Spec";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf type {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type enumeration {
            enum exclude {
              tailf:info "Exclude Filter";
            }
            enum include {
              tailf:info "Include Filter";
            }
          }
        }
        choice list-choice {
          leaf all {
            tailf:info "All";
            type empty;
          }
          leaf list {
            tailf:info "Protocol Filter Spec list";
            tailf:non-strict-leafref {
              path "../../../filter-list/cdp/list/name";
            }
            type string {
              tailf:info "WORD;;TLV/Option List name";
            }
          }
        }
      }
    }

    // device-sensor accounting
    leaf accounting {
      tailf:info "Trigger accounting updates with sensor TLVs/Options";
      type empty;
    }

    // device-sensor notify
    leaf notify {
      tailf:info "Options for when to trigger identity update events";
      type enumeration {
        enum all-changes {
          tailf:info "Trigger identity update when TLVs are added/modified/removed";
        }
        enum new-tlvs {
          tailf:info "Trigger identity update only when TLVs are added";
        }
      }
      default new-tlvs;
    }
  }


  /// ========================================================================
  /// process-restart
  /// ========================================================================

  container process-restart {
    tailf:info "Process-restart configuration";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-process-restart";

    // process-restart / no lcha-preferred
    leaf lcha-preferred {
      tailf:info "Select lcha if available";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
      default true;
    }
  }


  /// ========================================================================
  /// call-home
  /// ========================================================================

  container call-home {
    tailf:info "Enter call-home configuration mode";
    tailf:cli-add-mode;
    tailf:cli-mode-name "cfg-call-home";

    // call-home / contact-email-addr
    leaf contact-email-addr {
      tailf:info "System Contact's email address";
      tailf:cli-full-command;
      type string {
        tailf:info "WORD;;Contact person's email address";
      }
    }

    // call-home / site-id
    leaf site-id {
      tailf:info "Site identification for Cisco Smart Call Home";
      type string {
        tailf:info "WORD;;Alphanumeric site identification";
      }
    }

    // call-home / rate-limit
    leaf rate-limit {
      tailf:info "Configure call-home message rate-limit threshold";
      type uint8 {
        tailf:info "<1-60>;;call-home message rate-limit threshold per minute";
        range "1..60";
      }
    }

    // call-home / sender
    container sender {
      tailf:info "Call home msg's sender email addresses";

      // call-home / sender from
      leaf from {
        tailf:info "Call home msg's from email address";
        type string {
          tailf:info "WORD;;Email address";
        }
      }

      // call-home / sender reply-to
      leaf reply-to {
        tailf:info "Call home msg's reply-to email address";
        type string {
          tailf:info "WORD;;Email address";
        }
      }
    }

    // call-home / mail-server *
    list mail-server {
      tailf:info "Configure call-home mail_server";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      key host;
      leaf host {
        type inet:host {
          tailf:info "WORD;;Hostname or IPv4/IPv6 address of the email server";
        }
      }
      leaf priority {
        tailf:info "Mail server priority order";
        type uint8 {
          tailf:info "<1-100>;;Mail server with lower # will be used first";
          range "1..100";
        }
      }
    }

    // call-home / source-interface
    container source-interface {
      tailf:info "Specify source interface";
      uses interface-name-grouping;
    }

    // call-home / vrf
    leaf vrf {
      tailf:info "VPN Routing/Forwarding instance name";
      tailf:cli-diff-dependency "../../ip/vrf";
      tailf:cli-diff-dependency "../../vrf/definition";
      type string {
        tailf:info "WORD;;VRF instance name";
      }
    }

    // call-home / http-proxy
    container http-proxy {
      tailf:info "Specify proxy server for http request";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf server {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type string {
          tailf:info "WORD;;Http proxy server";
        }
      }
      leaf port {
        tailf:info "proxy server port number";
        type uint16 {
          tailf:info "<1-65535>;;http proxy server port number";
          range "1..65535";
        }
      }
    }

    // call-home / no http secure server-identity-check
    container http {
      tailf:info "Set parameters for http transport method";
      container secure {
        tailf:info "Specify secure settings for http transport method";
        leaf server-identity-check {
          tailf:info "check server identity";
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }
      }
    }

    // call-home / profile *
    list profile {
      tailf:info "Enter call-home profile configuration mode";
      tailf:cli-mode-name "cfg-call-home-profile";
      tailf:cli-full-command;
      tailf:cli-recursive-delete;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Profile name";
        }
      }

      // call-home / profile * / active
      // call-home / profile * / no active
      leaf active {
        tailf:info "Activate the current profile";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        ios:trim-when-list "create";
        type boolean;
      }

      // call-home / profile * / anonymous-reporting-only
      leaf anonymous-reporting-only {
        tailf:info "Enable call-home anonymous reporting only";
        type empty;
      }

      // call-home / profile * / reporting
      container reporting {
        tailf:info "Choose what data to report";

        // call-home / profile * / reporting smart-call-home-data
        // call-home / profile * / no reporting smart-call-home-data
        leaf smart-call-home-data {
          tailf:info "Report Smart Call Home data";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
        }

        // call-home / profile * / reporting smart-licensing-data
        // call-home / profile * / no reporting smart-licensing-data
        leaf smart-licensing-data {
          tailf:info "Report Smart Licensing data";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          tailf:cli-diff-set-after "../../../profile/reporting/smart-licensing-data[.='false']" {
            tailf:cli-when-target-set;
          }
          tailf:cli-diff-set-after "../../../profile/reporting/smart-licensing-data" {
            tailf:cli-when-target-delete;
          }
          ios:trim-when-list "create";
          type boolean;
        }
      }

      // call-home / profile * / destination
      container destination {
        tailf:info "Message destination related configuration";

        // call-home / profile * / destination transport-method
        container transport-method {
          tailf:info "To specify transport method for this profile";

          // call-home / profile * / destination transport-method http
          leaf http {
            tailf:info "Enable http as transport method";
            type empty;
          }

          // call-home / profile * /  no destination transport-method email
          leaf email {
            tailf:info "Enable email as transport method";
            tailf:cli-boolean-no;
            tailf:cli-full-command;
            type boolean;
            default true;
          }
        }

        // call-home / profile * / destination address
        container address {
          tailf:info "To add destination address to this profile";

          // call-home / profile * / destination address http *
          leaf-list http {
            tailf:info "To add http address to this profile";
            tailf:cli-list-syntax;
            tailf:cli-full-command;
            type string {
              tailf:info "WORD;;HTTP url (1-200) characters";
            }
          }

          // call-home / profile * / destination address email *
          leaf-list email {
            tailf:info "To add email address to this profile";
            tailf:cli-list-syntax;
            tailf:cli-full-command;
            type string {
              tailf:info "WORD;;Email address (1-200) characters";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// facility-alarm
  /// ========================================================================

  container facility-alarm {
    tailf:info "Alarm thresholds configuration";

    // facility-alarm core-temperature
    container core-temperature {
      tailf:info "Threshold for processor module temperature";
      uses facility-alarm-grouping;
    }

    // facility-alarm outlet-temperature
    container outlet-temperature {
      tailf:info "Threshold for air outlet temperature";
      uses facility-alarm-grouping;
    }

    // facility-alarm intake-temperature
    container intake-temperature {
      tailf:info "Threshold for air inlet temperature";
      uses facility-alarm-grouping;
    }

    // facility-alarm critical exceed-action shutdown
    container critical {
      tailf:info "Behavior on critical threshold exceed";
      leaf exceed-action {
        tailf:info "Behavior on critical threshold exceed";
        type enumeration {
          enum shutdown {
            tailf:info "Behavior on critical threshold exceed";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// cef
  /// ========================================================================

  container cef {
    tailf:info "Cisco Express Forwarding";
    container table {
      tailf:info "Set CEF forwarding table characteristics";
      container output-chain {
        tailf:info "Set table output chain characteristics";
        container build {
          tailf:info "Set table output chain building characteristics";

          // cef table output-chain build favor
          leaf favor {
            tailf:info "Set which table output chain building characteristics to favor";
            type enumeration {
              enum convergence-speed {
                tailf:info "Favor faster convergence";
              }
              enum memory-utilization {
                tailf:info "Favor smaller memory utilization";
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// ipdr
  /// ========================================================================

  container ipdr {
    tailf:info "IPDR Configuration";

    // ipdr session *
    list session {
      tailf:info "IPDR session";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-incomplete-command;
      key session-id;
      leaf session-id {
        type uint8 {
          tailf:info "<1-255>;;IPDR session id";
          range "1..255";
        }
      }
      leaf session-name {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type string {
          tailf:info "WORD;;IPDR session name";
        }
      }
      leaf session-descr {
        tailf:cli-drop-node-name;
        tailf:cli-multi-value;
        type string {
          tailf:info "LINE;;IPDR session description";
        }
      }
    }

    // ipdr type *
    list type {
      tailf:info "IPDR session type";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-incomplete-command;
      key session-id;
      leaf session-id {
        type uint8 {
          tailf:info "<1-255>;;IPDR session id";
          range "1..255";
        }
      }
      choice type-choice {
        leaf ad-hoc {
          tailf:info "Ad-hoc type session";
          type empty;
        }
        leaf event {
          tailf:info "Event type session";
          type empty;
        }
        leaf time-interval {
          tailf:info "Time interval type session";
          type uint16 {
            tailf:info "<15-1440>;;Interval in minute";
          }
        }
      }
    }

    // ipdr collector *
    list collector {
      tailf:info "IPDR collector";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-incomplete-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;IPDR collector name string";
        }
      }
      leaf ip-addr {
        tailf:cli-drop-node-name;
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;IPDR collector ip address";
        }
      }
      leaf port {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<1-65535>;;IPDR collector port";
          range "1..65535";
        }
      }
    }

    // ipdr associate *
    list associate {
      tailf:info "IPDR collector to session association";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-incomplete-command;
      key session-id;
      leaf session-id {
        type uint8 {
          tailf:info "<1-255>;;IPDR session id";
          range "1..255";
        }
      }
      leaf collector-name {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type string {
          tailf:info "WORD;;IPDR collector name";
        }
      }
      leaf priority {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-10>;;Priority of the collector in session, lower number is higher priority";
          range "1..10";
        }
      }
    }

    // ipdr template *
    list template {
      tailf:info "IPDR template";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-incomplete-command;
      key session-id;
      leaf session-id {
        type uint8 {
          tailf:info "<1-255>;;IPDR session id";
          range "1..255";
        }
      }
      leaf template-name {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "WORD;;Template name";
        }
      }
    }

    // ipdr exporter
    container exporter {
      tailf:info "IPDR exporter";

      // ipdr exporter start
      leaf start {
        tailf:info "start IPDR exporter";
        type empty;
      }

      // ipdr exporter keepalive
      leaf keepalive {
        tailf:info "keep alive";
        type uint16 {
          tailf:info "<5-300>;;keep alive time in second (default 300)";
          range "5..300";
        }
        default 300;
      }
    }
  }


  /// ========================================================================
  /// qos
  /// ========================================================================

  // qos
  container qos-conf {
    tailf:cli-drop-node-name;
    leaf qos {
      tailf:info "Global QoS configuration subcommands";
      type empty;
    }
  }

  // qos X
  container qos {
    tailf:info "Global QoS configuration subcommands";
    tailf:cli-incomplete-command;
    tailf:cli-incomplete-no;

    // qos dbl
    container dbl {
      tailf:info "Global DBL configuration";
      tailf:cli-display-separated;
      presence true;

      // qos dbl exceed-action
      container exceed-action {
        tailf:info "mark the packets when dbl limit is exceeded";

        // qos dbl exceed-action ecn
        leaf ecn {
          tailf:info "use explicit congestion notification";
          type empty;
        }

        // qos dbl exceed-action probability
        leaf probability {
          tailf:info "specify marking probability";
          type uint8 {
            tailf:info "<0-100>;;probability";
            range "0..100";
          }
        }
      }
    }

    // qos map
    container map {
      tailf:info "QoS mapping tables";

      // qos map dscp
      container dscp {
        tailf:info "Configure DSCP mapping tables";

        // qos map dscp * to tx-queue
        list dscp-to-tq-queue {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-incomplete-command;
          ios:delete-syntax "no qos map dscp \\d+ to (\\S+) \\d+" {
            cli:arguments "no qos map dscp to $1";
          }
          key dscp;
          leaf dscp {
            type uint8 {
              tailf:info "<0-63>;;Differentiated services codepoint value";
              range "0..63";
            }
          }
          leaf to {
            tailf:info "Map DSCP to";
            tailf:cli-incomplete-command;
            type empty;
          }
          leaf tx-queue {
            tailf:info "Map DSCP to transmit queue";
            type uint8 {
              tailf:info "<1-4>;;Transmit queue number";
              range "1..4";
            }
          }
        }

        // qos map dscp * to cos
        list dscp-to-cos {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-incomplete-command;
          ios:delete-syntax "no qos map dscp \\d+ to (\\S+) \\d+" {
            cli:arguments "no qos map dscp to $1";
          }
          key dscp;
          leaf dscp {
            type uint8 {
              tailf:info "<0-63>;;Differentiated services codepoint value";
              range "0..63";
            }
          }
          leaf to {
            tailf:info "Map DSCP to";
            tailf:cli-incomplete-command;
            type empty;
          }
          leaf cos {
            tailf:info "Map DSCP to CoS";
            type uint8 {
              tailf:info "<0-7>;;Mapped CoS value";
              range "0..7";
            }
          }
        }

        // qos map dscp policed * to dscp
        list policed {
          tailf:info "Policed DSCP markdown table";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-incomplete-command;
          ios:delete-syntax "no qos map dscp policed";
          key value;
          leaf value {
            type uint8 {
              tailf:info "<0-63>;;Differentiated services codepoint value";
              range "0..63";
            }
          }
          leaf to {
            tailf:info "Map DSCP to";
            tailf:cli-incomplete-command;
            type empty;
          }
          leaf dscp {
            tailf:info "Map DSCP to DSCP";
            type uint8 {
              tailf:info "<0-63>;;Policed DSCP Value";
              range "0..63";
            }
          }
        }
      }

      // qos map cos * to dscp
      container cos {
        tailf:info "Configure CoS mapping tables";
        list cos-to-dscp {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-incomplete-command;
          ios:delete-syntax "no qos map cos \\d+ to (\\S+) \\d+" {
            cli:arguments "no qos map cos to $1";
          }
          key cos;
          leaf cos {
            type uint8 {
              tailf:info "<0-7>;;cos value";
              range "0..7";
            }
          }
          leaf to {
            tailf:info "Map CoS to";
            tailf:cli-incomplete-command;
            type empty;
          }
          leaf dscp {
            tailf:info "Map CoS to DSCP";
            type uint8 {
              tailf:info "<0-63>;;Mapped DSCP value";
              range "0..63";
            }
          }
        }
      }
    }

    // qos account layer2 encapsulation
    container account {
      tailf:info "Additional lengths to be accounted by QoS Features";
      container layer2 {
        tailf:info "Accounting Layer 2 headers";
        container encapsulation {
          tailf:info "Account Layer 2 Encapsulation when applying QoS features";

          // qos account layer2 encapsulation length
          leaf length {
            tailf:info "Layer2 Encapsulation length in bytes";
            type uint8 {
              tailf:info "<0-64>;;Layer2 Encapsulation length in bytes";
              range "0..64";
            }
          }
        }
      }
    }

    // no qos rewrite ip dscp
    container rewrite {
      tailf:info "QoS Rewrite Configuration";
      container ip {
        tailf:info "QoS IP Rewrite Configuration";
        leaf dscp {
          tailf:info "Rewrite DSCP bits in the ToS Byte of IP Header";
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }
      }
    }

    // qos aggregate-policer *
    list aggregate-policer {
      tailf:info "Named aggregate policer";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Aggregate policer name";
        }
      }
      leaf rate {
        tailf:cli-drop-node-name;
        type uint64 {
          tailf:info "<32000-32000000000>;;Rate in bits per second (postfix k, m, g optional; decimal point allowed)";
          range "32000..32000000000";
        }
      }
      leaf xps {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum pps {
                    tailf:info "Treat 'rate' value in packets-per-second";
          }
          enum bps {
                    tailf:info "Treat 'rate' value in bytes-per-second";
          }
        }
      }
      leaf burst {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<1000-512000000>;;Normal burst bytes";
          range "1000..512000000";
        }
      }
      leaf burst-type {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum byte {
                     tailf:info "Treat 'burst' value as bytes";
          }
        }
      }
      container conform-action {
        tailf:info "action when rate is not exceeded";
        tailf:cli-optional-in-sequence;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        choice action-choice {
          leaf drop {
            tailf:info "drop packet";
            type empty;
          }
          leaf transmit {
            tailf:info "transmit packet";
            type empty;
          }
        }
      }
      leaf exceed-action {
        tailf:info "action when rate is exceeded";
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum drop {
                     tailf:info "drop packet";
          }
          enum policed-dscp-transmit {
            tailf:info "change dscp per policed-dscp map and send it";
          }
          enum transmit {
                         tailf:info "transmit packet";
          }
        }
      }
    }

    // qos queue-softmax-multiplier
    leaf queue-softmax-multiplier {
      tailf:info "global multiplier(%) for queue soft buffer maximal size";
      type uint16 {
        tailf:info "<100-1200>;;multiplier(%) 100 - 1200";
        range "100..1200";
      }
    }

    // qos wireless-default-untrust
    leaf wireless-default-untrust {
      type empty;
    }
  }


  /// ========================================================================
  /// card
  /// ========================================================================

  container card {
    tailf:info "Configure card type";

    // card * 4jacket-1
    // Note: Cisco 10000
    list card-slot {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key "slot card-type";
      leaf slot {
        type uint8 {
          tailf:info "<1-3>;;Enter odd slot";
          range "1|3";
        }
      }
      leaf card-type {
        type enumeration {
          enum "4jacket-1" {
            tailf:info "create a 4jacket-1 cardtype";
          }
        }
      }
    }

    // card *
    // Note: Cisco 10000
    list card-slot-subslot {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      key "slot-subslot card-type";
      leaf slot-subslot {
        type string {
          tailf:info "<0-9>/<0-3>;;Enter slot/subslot (subslot 2 and 3 is for SPA only)";
          pattern "[0-9]/[0-3]";
        }
      }
      leaf card-type {
        type union {
          type enumeration {
            enum "24rfchannel-spa-1" {
              tailf:info "create a Wideband DOCSIS SPA";
            }
            enum "2cable-dtcc" {
              tailf:info "Utility Card w/DTI (EightBells)";
            }
            enum "2cable-tccplus" {
              tailf:info "Utility Card";
            }
            enum SPA-1XTENGE-XFP-V2 {
              tailf:info "create a 10GE SPA 1 PORT cardtype";
            }
            enum SPA-2X1GE-V2 {
              tailf:info "create a GE SPA 2 PORT cardtype";
            }
            enum SPA-5X1GE-V2 {
              tailf:info "create a GE SPA 5 PORT cardtype";
            }
            enum SPA-8X1GE-V2 {
              tailf:info "create a GE SPA 8 PORT cardtype";
            }
            enum SPA-DOCSIS-HD-V1 {
              tailf:info "create a High Density DOCSIS SPA";
            }
            enum ubr10k-clc-3g60 {
              tailf:info "create a uBR10000 line card with MC3Gx60";
            }
            enum ubr10k-clc-mc2020v {
              tailf:info "create a uBR10000 line card with MC20x20";
            }
            enum 1gigethernet-1 {
              tailf:info "create a GE_1_PORT cardtype";
            }
            enum 1gigethernet-hh-1 {
              tailf:info "create a GE1H_1_PORT cardtype";
            }
            enum cBR-CCAP-LC-40G {
              tailf:info "create a cBR line card with CCAP-LC-40G";
            }
            enum sup-pic-8x10g {
              tailf:info "create a sup-pic 8x10G card";
            }
          }
          type string {
            tailf:info "WORD;;Card name";
          }
        }
      }
      leaf SPA-DOCSIS-HD-V1-port {
        when "../card-type = 'SPA-DOCSIS-HD-V1'" {
          tailf:dependency "../card-type";
        }
        tailf:cli-drop-node-name;
        type enumeration {
          enum "1x10GE" {
            tailf:info "using 1x10GE port";
          }
          enum "3x1GE" {
            tailf:info "using 3x1GE port";
          }
        }
      }
      leaf r-phy {
        tailf:info "set the line card working in the remote phy mode";
        tailf:cli-optional-in-sequence;
        tailf:cli-full-command;
        type empty;
      }
      leaf license {
        tailf:info "create a license for the line card";
        type string {
          tailf:info "WORD;;License string";
        }
      }
    }

    // card type
    container type {
      tailf:info "Configure card type";

      // card type t1 *
      list t1 {
        tailf:info "T1";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key slot;
        leaf slot {
          type uint8;
        }
      }

      // card type t1 * *
      container t1-bay {
        tailf:cli-drop-node-name;
        list t1 {
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key "slot bay";
          leaf slot {
            type uint8 {
              tailf:info "<0-2>;;Card slot number (always 0 for 1800 series & 2801 routers)";
            }
          }
          leaf bay {
            type uint8 {
              tailf:info "<0-3>;;WIC slot number (0:WIC, 1:Onboard for NM-HDV2)";
            }
          }
        }
      }

      // card type t3 *
      container t3-slot {
        tailf:cli-drop-node-name;
        list t3 {
          tailf:info "T3";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key slot;
          leaf slot {
            type uint8 {
              tailf:info "<0-6>;;Card slot number";
            }
          }
        }
      }

      // card type t3 * *
      list t3 {
        tailf:info "T3";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "slot subslot";
        leaf slot {
          type uint8 {
            tailf:info "<0-6>;;Card slot number";
          }
        }
        leaf subslot {
          type uint8 {
            tailf:info "<0-6>;;Card subslot number";
          }
        }
      }

      // card type e1 *
      container e1-slot {
        tailf:cli-drop-node-name;
        list e1 {
          tailf:info "E1";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key slot;
          leaf slot {
            type uint8 {
              tailf:info "<0-x>;;Card slot number";
            }
          }
        }
      }

      // card type e1 * *
      list e1 {
        tailf:info "E1";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "slot bay";
        leaf slot {
          type uint8 {
            tailf:info "<0-x>;;Card slot number";
          }
        }
        leaf bay {
          type uint8 {
            tailf:info "<0-x>;;WIC slot number";
          }
        }
      }

      // card type e3 * *
      list e3 {
        tailf:info "E3";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "slot subslot";
        leaf slot {
          type uint8 {
            tailf:info "<0-6>;;Card slot number";
          }
        }
        leaf subslot {
          type uint8 {
            tailf:info "<0-6>;;Card subslot number";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// kron
  /// ========================================================================

  container kron {
    tailf:info "Kron interval Facility";

    // kron occurrence *
    list occurrence {
      tailf:info "Define the name, time, interval of kron occurrence";
      tailf:cli-mode-name "config-kron-occurrence";
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-incomplete-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;The name of this occurrence";
        }
      }
      choice occurrence-choice {
        case at {
          leaf at {
            tailf:info "Date of kron occurrence eg. 14:30 Feb 13";
            tailf:cli-hide-in-submode;
            type string {
              tailf:info "hh:mm;;Time of day for occurrence (hh:min eg. 14:30)";
            }
          }
          leaf month {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            tailf:cli-hide-in-submode;
            type month-type;
          }
          leaf day-of-week {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            tailf:cli-hide-in-submode;
            type weekday-type;
          }
          leaf day-of-month {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            tailf:cli-hide-in-submode;
            type uint8 {
              tailf:info "<1-31>;;Day of month";
              range "1..31";
            }
          }
        }
        leaf in {
          tailf:info "Delta time to kron occurrence";
          tailf:cli-hide-in-submode;
          type string {
            tailf:info "Delay before occurrence (mmm or hhh:mm or ddd:hh:mm)";
          }
        }
      }
      choice when-choice {
        leaf oneshot {
          tailf:info "Schedule kron occurrence exactly once";
          tailf:cli-hide-in-submode;
          type empty;
        }
        case recurring {
          leaf recurring {
            tailf:info "Schedule kron occurrence repeatedly";
            tailf:cli-hide-in-submode;
            type empty;
          }
          leaf system-startup {
            tailf:info "Schedule kron occurrence at system start-up";
            tailf:cli-hide-in-submode;
            type empty;
          }
        }
      }

      // kron occurrence * / policy-list *
      leaf-list policy-list {
        tailf:info "Specify the Policy List to be executed";
        tailf:cli-list-syntax;
        tailf:non-strict-leafref {
          path "../../policy-list/name";
        }
        type string {
          tailf:info "WORD;;Name of Policy to be executed";
        }
      }
    }

    // kron policy-list *
    list policy-list {
      tailf:info "Define the name and type of policy-list";
      tailf:cli-mode-name "config-kron-policy";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Name of the policy-list being defined";
        }
      }
      leaf conditional {
        tailf:info "Execution of the list of cli will stop on failure return values";
        tailf:cli-hide-in-submode;
        type empty;
      }

      // kron policy-list * / cli *
      list cli {
        tailf:info "Specify the exec level cli to be executed";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          tailf:cli-suppress-range;
          type string {
            tailf:info "LINE;;Quoted exec level cli to be executed";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// hw-module
  /// ========================================================================

  container hw-module {
    tailf:info "Slot/subslot/port level commands";

    // hw-module bay * shutdown
    list bay {
      tailf:info "Bay level commands";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-incomplete-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;<1-3>/<0-3>";
        }
      }
      leaf shutdown {
        tailf:info "Shutdown the target subslot";
        type empty;
      }
      choice power-choice {
        leaf powered {
          tailf:info "Hold the target subslot in reset";
          type empty;
        }
        leaf unpowered {
          tailf:info "Power-off the target subslot";
          type empty;
        }
      }
    }

    // hw-module ism *
    list ism {
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        type string {
          tailf:info "<0-1>;;Service module slot number";
        }
      }
    }

    // hw-module pvdm *
    list pvdm {
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        type string;
      }
    }

    // hw-module sm *
    list sm {
      tailf:info "Service module";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        type string {
          tailf:info "<1-1>;;Service module slot number";
        }
      }
    }

    // hw-module slot *
    list slot {
      tailf:info "Specify a linecard slot for the hw-module command";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        type uint32 {
          tailf:info "<1-9>;;slot number of line card";
        }
      }

      // hw-module slot * memory test full
      container memory {
        tailf:info "Module memory settings";
        container test {
          tailf:info "Memory test options";
          leaf full {
            tailf:info "Perform full memory test on LC's power on";
            type empty;
          }
        }
      }

      // hw-module slot * process-max-time
      leaf process-max-time {
        tailf:info "Maximum time for process to run before voluntarily relinquishing processor";
        type uint16 {
          tailf:info "<20-200>;;The number of millisecs before voluntary suspend";
          range "20..200";
        }
      }

      // hw-module slot * sp process-max-time
      container sp {
        tailf:info "processor-max-time for Switch Processor";
        leaf process-max-time {
          tailf:info "Maximum time for process to run before voluntarily relinquishing processor";
          type uint16 {
            tailf:info "<20-200>;;The number of millisecs before voluntary suspend";
            range "20..200";
          }
        }
      }

      // hw-module slot * rp process-max-time
      container rp {
        tailf:info "processor-max-time for Route Processor";
        leaf process-max-time {
          tailf:info "Maximum time for process to run before voluntarily relinquishing processor";
          type uint16 {
            tailf:info "<20-200>;;The number of millisecs before voluntary suspend";
            range "20..200";
          }
        }
      }

      // hw-module slot * ipv6-hbh-rl
      leaf ipv6-hbh-rl {
        type uint32;
      }
    }

    // hw-module module
    container module {
      tailf:info "Specify a linecard slot for the hw-module command";

      // hw-module module * port-group *
      list module-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key "name port-group";
        leaf name {
          type uint8 {
            tailf:info "<1-7>;;module slot number";
          }
        }
        leaf port-group {
          tailf:info "configure port-group";
          tailf:cli-expose-key-name;
          type uint8 {
            tailf:info "<1-4>;;port-group number";
          }
        }
        leaf select {
          tailf:info "Select a port-group interface type";
          type enumeration {
            enum gigabitethernet {
              tailf:info "Select this port-group's gigabit interfaces";
            }
            enum tengigabitethernet {
              tailf:info "Select this port-group's 10G interfaces";
            }
          }
        }
      }

      // hw-module module * port-group *
      list module-list-mode {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type uint8 {
            tailf:info "<1-7>;;module slot number";
          }
        }
        leaf mode {
          type uint8 {
            tailf:info "<1-3>;;mode";
          }
        }
      }

      // no hw-module module * logging onboard
      // hw-module module no-list * logging onboard
      list no-list {
        tailf:info "'no hw-module module * logging onboard' entry";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type uint8 {
            tailf:info "<1-7>;;module slot number";
          }
        }
        container logging {
          tailf:info "Logging";
          leaf onboard {
            tailf:info "Onboard logging";
            type empty;
          }
        }
      }
    }

    // hw-module usb disable
    container usb {
      tailf:info "USB Subsystem";
      leaf disable {
        tailf:info "Disable USB Subsystem (Warning: requires reload)";
        type empty;
      }
    }

    // hw-module uplink select
    container uplink {
      tailf:info "Configure uplink";
      leaf select {
        tailf:info "Select an uplink interface type";
        type enumeration {
          enum all {
            tailf:info "Select 10G and gigabit uplinks";
          }
          enum gigabitethernet {
            tailf:info "Select the gigabit uplinks";
          }
          enum tengigabitethernet {
            tailf:info "Select the 10G uplinks";
          }
        }
      }
    }

    // hw-module system
    container system {
      tailf:info "Specify the system parameter";

      // hw-module system max-queue-limit
      leaf max-queue-limit {
        tailf:info "Specify the maximum queue limit";
        type uint16 {
          tailf:info "<1024-8184>;;custom queue size limit";
          range "1024..8184";
        }
      }
    }
  }


  /// ========================================================================
  /// cable
  /// ========================================================================

  container cable {
    tailf:info "Global cable configuration";

    // cable profile
    container profile {
      tailf:info "Global profile configuration";

      // cable profile mac-domain *
      list mac-domain {
        tailf:info "Select a mac-domain common profile to configure";
        tailf:cli-mode-name "config-profile-md";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;mac-domain common profile name";
          }
        }

        // cable profile mac-domain * / cable
        container cable {
          tailf:info "Cable interface subcommands";

          // cable profile mac-domain * / cable dynamic-secret
          container dynamic-secret {
            tailf:info "Enable dynamic secret for CM config files";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf option {
              tailf:cli-drop-node-name;
              type enumeration {
                enum lock {
                  tailf:info "Lock modems violating dynamic secret";
                }
                enum mark {
                  tailf:info "Mark modems violating dynamic secret";
                }
                enum reject {
                  tailf:info "Reject registration request from modems violating dynamic secret";
                }
              }
            }
            leaf nocrypt {
              tailf:info "Do not encrypt modem config file name";
              type empty;
            }
          }

          // cable profile mac-domain * / cable privacy
          container privacy {
            tailf:info "Cable Privacy";

            // cable profile mac-domain * / cable privacy mandatory
            leaf mandatory {
              tailf:info "force privacy be mandatory";
              type empty;
            }

            // cable profile mac-domain * / cable privacy skip-validity-period
            leaf skip-validity-period {
              tailf:info "Skip certificate validity period";
              type empty;
            }

            // cable profile mac-domain * / cable privacy bpi-plus-policy total-enforcement
            leaf bpi-plus-policy {
              tailf:info "Privacy requires BPI+";
              type enumeration {
                enum capable-enforcement {
                  tailf:info "BPI+ required for all capable modems with BPI+ enabled (policy 1)";
                }
                enum d11-enabled-enforcement {
                  tailf:info "BPI+ required for all D1.1 and later modems with BPI+ enabled (policy 2)";
                }
                enum d11-enforcement {
                  tailf:info "BPI+ required for all D1.1 and later modems (policy 3)";
                }
                enum total-enforcement {
                  tailf:info "BPI+ required for all modems (policy 4)";
                }
              }
            }
          }

          // cable profile mac-domain * / cable cm-status enable *
          container cm-status {
            tailf:info "CM-STATUS events";
            leaf-list enable {
              tailf:info "enable CM-STATUS events";
              tailf:cli-range-list-syntax;
              ios:device-range-list-last;
              type uint8 {
                tailf:info "<grouplist>;;CM-STATUS event list to enable: 3|6-11|16-18|20-27";
              }
            }
          }

          // cable profile mac-domain * / cable map-advance
          uses cable-map-advance-grouping;

          // cable profile mac-domain * / cable upstream
          container upstream {
            tailf:info "Upstream configuration";

            // cable profile mac-domain * / cable upstream *
            list cable-upstream-list {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-incomplete-command;
              key id;
              leaf id {
                type uint8 {
                  tailf:info "<0-15>;;US channel index in the MAC domain";
                }
              }
              leaf attribute-mask {
                tailf:info "Upstream Channel Provisioned Attribute Mask";
                type string {
                  tailf:info "<0-FFFFFFFF>;;Attribute mask in hex";
                }
              }
              container power-adjust {
                tailf:info "Power adjust threshold";
                leaf threshold {
                  tailf:info "Power adjustment threshold";
                  type uint8 {
                    tailf:info "<0-10>;;Power difference in dB";
                    range "0..10";
                  }
                }
                leaf continue {
                  tailf:info "Minimum power adjustment which set CONTINUE ranging status";
                  type uint8 {
                    tailf:info "<2-15>;;Power level in dB";
                    range "2..15";
                  }
                }
                leaf noise {
                  tailf:info "% of power adjust pkts required for changing the adjustment method";
                  type uint8 {
                    tailf:info "<10-100>;;Percentage of power adjustment pkts";
                    range "10..100";
                  }
                }
              }
            }

            // cable profile mac-domain * / cable upstream balance-scheduling
            leaf balance-scheduling {
              tailf:info "upstream channel balance scheduling on one mac-domain";
              type empty;
            }
          }

          // cable profile mac-domain * / cable enable-trap
          container enable-trap {
            tailf:info "Enable an SNMP cable trap";
            leaf cmonoff-notification {
              tailf:info "Cable Modem Online/Offline notification";
              type empty;
            }
            leaf cmonoff-interval {
              tailf:info "Interval in Seconds";
              type uint32 {
                tailf:info "<0-86400>;;Interval in secs";
                range "0..86400";
              }
              default 0;
            }
          }
        }

        // cable profile mac-domain * / load-interval
        leaf load-interval {
          tailf:info "Specify interval for load calculation for an interface";
          type uint16 {
            tailf:info "<30-600>;;Load interval delay in seconds";
            range "30..600";
          }
          default 300;
        }
      }

      // cable profile wideband-interface *
      list wideband-interface {
        tailf:info "Select a wideband interface common profile to configure";
        tailf:cli-mode-name "config-profile-wb";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;wideband interface common profile name";
          }
        }

        // cable profile wideband-interface * / cable downstream
        container cable {
          tailf:info "Wideband-Cable interface subcommands";
          container downstream {
            tailf:info "Downstream parameter configuration";
            leaf attribute-mask {
              tailf:info "Downstream channel provisioned Attribute Mask";
              type string {
                tailf:info "<0-FFFFFFFF>;;The attribute bitmap in hex";
              }
            }
          }
        }

        // cable profile wideband-interface * / load-interval
        leaf load-interval {
          tailf:info "Specify interval for load calculation for an interface";
          type uint16 {
            tailf:info "<30-600>;;Load interval delay in seconds";
            range "30..600";
          }
          default 300;
        }

        // cable profile wideband-interface * / description
        uses description-grouping;
      }

      // cable profile downstream *
      list downstream {
        tailf:info "Select a downstream interface common profile to configure";
        tailf:cli-mode-name "config-profile-ds";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;downstream interface common profile name";
          }
        }

        // cable profile downstream * / cable
        container cable {
          tailf:info "Integrated-Cable interface subcommands";

          // cable profile downstream * / cable rf-bandwidth-percent
          container rf-bandwidth-percent {
            tailf:info "% of reserved RF channel bandwidth";
            leaf percent-value {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<1-100>;;% bandwidth";
                range "1..100";
              }
            }
          }

          // cable profile downstream * / cable attribute-mask
          leaf attribute-mask {
            tailf:info "Downstream channel provisioned Attribute Mask";
            type string {
              tailf:info "<0-FFFFFFFF>;;The attribute bitmap in hex";
            }
          }
        }
      }

      // cable profile load-balance *
      list load-balance {
        tailf:info "Select a load-balance common profile to configure";
        tailf:cli-mode-name "config-profile-lb";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;load-balance common profile name";
          }
        }

        // cable profile load-balance * / restricted
        leaf restricted {
          tailf:info "Set load balance group as restricted";
          type empty;
        }

        // cable profile load-balance * / method
        container method {
          tailf:info "Set load balancing type/method";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf method {
            tailf:cli-drop-node-name;
            type enumeration {
              enum modems {
                tailf:info "Number of modems";
              }
              enum utilization {
                tailf:info "Interface utilization";
              }
            }
            default modems;
          }
          leaf us-method {
            tailf:info "Set load balancing type/method for US";
            type enumeration {
              enum modems {
                tailf:info "Number of modems";
              }
              enum utilization {
                tailf:info "Interface utilization";
              }
            }
            default modems;
          }
        }

        // cable profile load-balance * / threshold
        container threshold {
          tailf:info "Load balancing threshold in %";

          // cable profile load-balance * / threshold load
          container load {
            tailf:info "Interface load threshold settings";
            leaf value {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<1-100>;;Threshold value in %";
                range "1..100";
              }
            }
            leaf minimum {
              tailf:info "Set minimum number of modems/flows difference before loadbalancing starts";
              type uint8 {
                tailf:info "<1-100>;;Minimum number of modems/flows";
                range "1..100";
              }
            }
          }

          // cable profile load-balance * / threshold stability
          leaf stability {
            tailf:info "Threshold for stability detection";
            type uint8 {
              tailf:info "<0-100>;;Stability condition detection threshold in %";
              range "0..100";
            }
          }
        }

        // cable profile load-balance * / policy
        container policy {
          tailf:info "Set load balancing policy";

          // cable profile load-balance * / policy ugs
          leaf ugs {
            tailf:info "Enable balancing of modems with active UGS service flows";
            type empty;
          }

          // cable profile load-balance * / policy pure-ds-load
          leaf pure-ds-load {
            tailf:info "Do not count US load when calculating DS utilization";
            type empty;
          }
        }

        // cable profile load-balance * / init-tech-list
        leaf init-tech-list {
          tailf:info "Set DCC initialization technique list";
          type string {
            tailf:info "<grouplist>;;DCC Initialization technique list";
          }
        }

        // cable profile load-balance * / docsis-policy
        leaf docsis-policy {
          tailf:info "Enter load balance group policy";
          tailf:non-strict-leafref {
            path "../../../load-balance/docsis-policy/policy-id";
          }
          type uint32 {
            tailf:info "<0-4294967295>;;Load balance group policy number";
            range "0..4294967295";
          }
        }

        // cable profile load-balance * / interval
        leaf interval {
          tailf:info "Set interface polling interval";
          type uint16 {
            tailf:info "<1-1000>;;Interface polling interval in seconds";
            range "1..1000";
          }
        }

        // cable profile load-balance * / tag *
        list tag {
          tailf:info "Add tag to load balancing group";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-diff-set-after "../../../tag";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;tag name";
            }
          }
        }
      }

      // cable profile service-group *
      list service-group {
        tailf:info "Create fiber-node service group profile";
        tailf:cli-mode-name "config-profile-sg";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;fiber-node service group profile name";
          }
        }

        // cable profile service-group * / cable bundle
        container cable {
          tailf:info "cable subcommand";
          leaf bundle {
            tailf:info "Bundle number for bundling of cable interfaces";
            type uint8 {
              tailf:info "<1-255>;;Bundle number";
              range "1..255";
            }
          }
        }

        // cable profile service-group * / mac-domain *
        list mac-domain {
          tailf:info "Cable Mac Domain";
          tailf:cli-mode-name "config-profile-sg-md";
          tailf:cli-sequence-commands;
          key id;
          leaf id {
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-15>;;mac-domain id";
              range "0..15";
            }
          }
          leaf profile {
            tailf:info "mac-domain profile";
            tailf:cli-hide-in-submode;
            tailf:cli-full-command;
            tailf:non-strict-leafref {
              path "../../../mac-domain/name";
            }
            type string {
              tailf:info "WORD;;mac-domain profile name";
            }
          }

          // cable profile service-group * / mac-domain * / downstream
          container downstream {
            tailf:cli-break-sequence-commands;
            tailf:info "Add a ds service group channel to a MD";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;

            // cable profile service-group * / mac-domain * / downstream sg-channel *
            list sg-channel {
              tailf:info "ds service group channel";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              key profile;
              leaf profile {
                tailf:info "IC interface profile";
                tailf:cli-expose-key-name;
                tailf:cli-suppress-range;
                type string {
                  tailf:info "WORD;;IC interface profile name";
                }
              }
              leaf-list id {
                // Note: List separated by ',' in NCS, on device by ' '. Java converts.
                tailf:cli-drop-node-name;
                tailf:cli-prefix-key;
                tailf:cli-range-list-syntax;
                tailf:cli-incomplete-command;
                tailf:cli-incomplete-no;
                type uint8 {
                  tailf:info "<grouplist>;;List of Ranges for sg-channels <0-254>";
                  range "0..254";
                }
              }
              // NOTE: ncs-4.5.6 get internal error if use leaf-list here too.
              leaf upstream {
                tailf:info "Upstream sg-channels serving these downstream sg-channels";
                type string {
                  tailf:info "<grouplist>;;List of Ranges for upstream sg-channels <0-7>";
                }
              }
            }
          }

          // cable profile service-group * / mac-domain * / cable downstream dsg
          container cable {
            tailf:info "Cable";
            container downstream {
              tailf:info "Cable downstream settings";
              container dsg {
                tailf:info "Downstream DSG settings";

                // cable profile service-group * / mac-domain * / cable downstream dsg timer
                leaf timer {
                  tailf:info "DSG Timer Setting";
                  type uint16 {
                    tailf:info "<1-65535>;;DSG timer index.";
                    range "1..65535";
                  }
                }

                // cable profile service-group * / mac-domain * / cable downstream dsg chan-list
                leaf chan-list {
                  tailf:info "DSG Channel List Setting";
                  type uint16 {
                    tailf:info "<1-65535>;;DSG channel list index.";
                    range "1..65535";
                  }
                }

                // cable profile service-group * / mac-domain * / cable downstream dsg tg *
                list tg {
                  tailf:info "DSG Tunnel group";
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  key tgid;
                  leaf tgid {
                    type uint16 {
                      tailf:info "<1-65535>;;DSG Tunnel Group ID";
                      range "1..65535";
                    }
                  }
                }
              }
            }
          }

          // cable profile service-group * / mac-domain * / upstream *
          list upstream {
            tailf:info "Add a us service group channel to a MD";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key id;
            leaf id {
              type uint16 {
                tailf:info "<0-15>;;US channel index in MD";
                range "0..15";
              }
            }
            leaf sg-channel {
              tailf:info "us service group channel";
              type uint8 {
                tailf:info "<0-254>;;US sg-channel index";
                range "0..254";
              }
            }
          }

          // cable profile service-group * / mac-domain * / us-bonding-group *
          list us-bonding-group {
            tailf:info "Configure upstream bonding group";
            tailf:cli-mode-name "config-profile-sg-md-usb";
            key id;
            leaf id {
              type uint16 {
                tailf:info "<1-65535>;;bonding group id";
                range "1..65535";
              }
            }

            // cable profile service-group * / mac-domain * / us-bonding-group * / admission-control
            container admission-control {
              tailf:info "Configure Cable Admission Control";
              leaf max-reserved-bandwidth {
                tailf:info "Configure maximum AC reserved bandwidth for this bonding group.";
                type uint32 {
                  tailf:info "NUM;;Maximum AC reserved bandwidth Value in kbps";
                }
              }
            }

            // cable profile service-group * / mac-domain * / us-bonding-group * / upstream *
            list upstream {
              tailf:info "Add an upstream to this bonding group";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key id;
              leaf id {
                type uint8 {
                  tailf:info "<0-15>;;upstream to add";
                  range "0..15";
                }
              }
            }
          }
        }

        // cable profile service-group * / load-balance docsis-group * profile *
        list load-balance {
          tailf:info "load-balance group";
          tailf:cli-mode-name "config-profile-sg-lb";
          key "docsis-group profile";
          leaf docsis-group {
            tailf:info "docsis-group";
            tailf:cli-expose-key-name;
            type uint8 {
              tailf:info "<0-15>;;load-balance group id";
              range "0..15";
            }
          }
          leaf profile {
            tailf:info "load-balance profile";
            tailf:cli-expose-key-name;
            tailf:non-strict-leafref {
              path "../../../load-balance/name";
            }
            type string {
              tailf:info "WORD;;load-balance profile name";
            }
          }

          // cable profile service-group * / load-balance docsis-group * profile * / downstream sg-channel *
          container downstream {
            tailf:info "Add a ds service group channel to a LB";
            leaf-list sg-channel {
              tailf:info "ds service group channel";
              tailf:cli-range-list-syntax;
              type uint8 {
                tailf:info "<grouplist>;;List of Ranges for sg-channels <0-254>";
                range "0..254";
              }
            }
          }

          // cable profile service-group * / load-balance docsis-group * profile * / upstream * sg-channel
          list upstream {
            tailf:info "Add a us service group channel to a LB";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key id;
            leaf id {
              type uint16 {
                tailf:info "<0-15>;;US channel index in MD";
                range "0..15";
              }
            }
            leaf sg-channel {
              tailf:info "us service group channel";
              type uint8 {
                tailf:info "<0-254>;;US sg-channel index";
                range "0..254";
              }
            }
          }
        }

        // cable profile service-group * /  wideband-interface * profile
        list wideband-interface {
          tailf:info "Downstream bonding group";
          tailf:cli-mode-name "config-profile-sg-bg";
          key id;
          leaf id {
            type uint8 {
              tailf:info "<0-63>;;downstream bonding group id";
              range "0..63";
            }
          }
          leaf profile {
            tailf:info "wideband interface profile";
            tailf:cli-hide-in-submode;
            tailf:non-strict-leafref {
              path "../../../wideband-interface/name";
            }
            type string {
              tailf:info "WORD;;wideband interface profile name";
            }
          }

          // cable profile service-group * / wideband-interface * / cable ds-resiliency
          container cable {
            tailf:info "cable config";
            leaf ds-resiliency {
              tailf:info "Downstream resiliency bonding group";
              type empty;
            }
          }

          // cable profile service-group * / wideband-interface * / downstream sg-channel *
          container downstream {
            tailf:info "Add a ds service group channel to a BG";
            list sg-channel {
              tailf:info "ds service group channel";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-incomplete-command;
              key id;
              leaf id {
                tailf:cli-multi-word-key;
                tailf:cli-suppress-range;
                tailf:cli-disallow-value ".*rf-bandwidth-percent.*";
                type string {
                  tailf:info "<grouplist>;;List of Ranges for sg-channels <0-254>";
                }
              }
              leaf rf-bandwidth-percent {
                tailf:info "ds service group channel";
                type uint8 {
                  tailf:info "<1-100>;;bandwidth";
                  range "1..100";
                }
              }
            }
          }
        }
      }

      // cable profile rpd-event *
      list rpd-event {
        tailf:info "rpd-event profile configuration";
        tailf:cli-mode-name "config rpd-event";
        key id;
        leaf id {
          type uint8 {
            tailf:info "<0-63>;;RPD event profile number";
            range "0..63";
          }
        }

        // cable profile rpd-event * / priority *
        list priority {
          tailf:info "Event Reporting Priority";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          key name;
          leaf name {
            type enumeration {
              enum emergency {
                tailf:info "Event reporting for emergency priority";
              }
              enum alert {
                tailf:info "Event reporting for alert priority";
              }
              enum critical {
                tailf:info "Event reporting for critical priority";
              }
              enum error {
                tailf:info "Event reporting for error priority";
              }
              enum warning {
                tailf:info "Event reporting for warning priority";
              }
              enum notice {
                tailf:info "Event reporting for notice priority";
              }
              enum informational {
                tailf:info "Event reporting for informational priority";
              }
              enum debug {
                tailf:info "Event reporting for debug priority";
              }
            }
          }
          leaf flags {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "<0x0-0x3>;;Event Reporting flags value in Hex (0x0:no, 0x1:local, 0x2:report, 0x3:local&report";
            }
          }
        }

        // cable profile rpd-event * / enable-notify
        leaf enable-notify {
          tailf:info "Enable notification";
          type empty;
        }
      }

      // cable profile ssd *
      list ssd {
        tailf:info "rpd ssd profile configuration";
        tailf:cli-mode-name "config rpd-ssd";
        key id;
        leaf id {
          type uint8 {
            tailf:info "<1-64>;;RPD SSD profile number";
            range "1..64";
          }
        }

        // cable profile ssd * / description
        uses description-grouping;

        // cable profile ssd * / ssd
        container ssd {
          tailf:info "rpd security software download";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf address {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type union {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IP address of the ssd server";
              }
              type inet:ipv6-address {
                tailf:info "X:X:X:X::X;;IPv6 address of the ssd server";
              }
            }
          }
          choice file-choice {
            leaf http {
              tailf:info "RPD ssd protocal http";
              type string {
                tailf:info "WORD;;ssd file name";
              }
            }
            leaf tftp {
              tailf:info "RPD ssd protocal tftp";
              type string {
                tailf:info "WORD;;ssd file name";
              }
            }
          }
          leaf m-cvc-c {
            tailf:info "SSD Manufacturer CVC Chain";
            tailf:cli-optional-in-sequence;
            type string {
              tailf:info "WORD;;URL of c-cvc-c file";
            }
          }
          leaf c-cvc-c {
            tailf:info "SSD Co-signer CVC Chain";
            type string {
              tailf:info "WORD;;URL of c-cvc-c file";
            }
          }
        }
      }
    }

    // cable depi
    container depi {
      tailf:info "depi";

      // cable depi multicast pool *
      container multicast {
        tailf:info "depi multicast";
        list pool {
          tailf:info "Create DEPI Multicast Pool for DS Virtual Splitting";
          tailf:cli-mode-name "config-multicast-pool";
          key id;
          leaf id {
            type uint8 {
              tailf:info "<0-127>;;cable depi multicast pool id";
              range "0..127";
            }
          }

          // cable depi multicast pool * / description
          uses description-grouping;

          // cable depi multicast pool * / ip address
          container ip {
            tailf:info "DS Virtual Splitting Multicast Pool config commands";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf address {
              tailf:info "Set the IP address range for multicast pool";
              tailf:cli-incomplete-command;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Net IP";
              }
            }
            leaf mask {
              tailf:cli-drop-node-name;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Net Mask";
              }
            }
          }

          // cable depi multicast pool * / ipv6 address
          container ipv6 {
            tailf:info "DS Virtual Splitting Multicast Pool ipv6 config commands";
            tailf:cli-diff-delete-before "../ip";
            leaf address {
              tailf:info "Set the IPv6 address range for multicast pool";
              type ios:ipv6-prefix {
                tailf:info "X:X:X:X::X/<0-128>;;IPv6 Net Prefix";
              }
            }
          }
        }
      }

      // cable depi fragment
      leaf fragment {
        tailf:info "enable/disable depi fragment";
        type enumeration {
          enum off {
            tailf:info "disable depi fragment";
          }
          enum on {
            tailf:info "enable depi fragment (default)";
          }
        }
        default on;
      }
    }

    // cable dynamic-bonding-group
    container dynamic-bonding-group-enable {
      tailf:cli-drop-node-name;
      leaf dynamic-bonding-group {
        tailf:info "Enable downstream dynamic bonding group";
        type empty;
      }
    }

    // cable dynamic-punt
    container dynamic-punt {
      tailf:info "Configure cable dynamic punt";

      // cable dynamic-punt enable
      leaf enable {
        tailf:info "Enable cable dynamic punt, default enabled";
        type empty;
      }
    }

    // cable downstream
    container downstream {
      tailf:info "configure at chassis level";

      // cable downstream freq-profile *
      list freq-profile {
        tailf:info "configure chassis level freq profile";
        tailf:cli-mode-name "config-freq-prof";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;RFGW Frequency profile ID or Name";
          }
        }

        // cable downstream freq-profile * / lane *
        list lane {
          tailf:info "lane configurations";
          tailf:cli-mode-name "config-freq-prof-lane";
          tailf:cli-incomplete-command;
          key id;
          leaf id {
            type uint8 {
              tailf:info "<1-4>;;lane id ";
              range "1..4";
            }
          }
          leaf start-freq {
            tailf:info "starting freq keyword for the lane";
            tailf:cli-hide-in-submode;
            type uint32 {
              tailf:info "<48000000-995000000>;;lane start frequency";
              range "48000000..995000000";
            }
          }

          // cable downstream freq-profile * / lane * / block *
          list block {
            tailf:info "block configurations";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key id;
            leaf id {
              type uint8 {
                tailf:info "<1-4>;;block id ";
                range "1..4";
              }
            }
            leaf start-freq {
              tailf:info "starting freq keyword for the block";
              type uint32 {
                tailf:info "<48000000-995000000>;;block start frequency";
              }
            }
          }
        }
      }

      // cable downstream rf-profile *
      list rf-profile {
        tailf:info "configure chassis level rf profile";
        tailf:cli-mode-name "config-rf-prof";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;RFGW RF profile ID or Name";
          }
        }

        // cable downstream rf-profile * / cable downstream
        container cable {
          tailf:info "cable keyword under rf profile config mode";
          container downstream {
            tailf:info "downstream configurations for the rf profile";

            // cable downstream rf-profile * / cable downstream annex
            leaf annex {
              tailf:info "MPEG framing format, annex A|B|C";
              tailf:cli-full-command;
              type enumeration {
                enum "A" {
                  tailf:info "annex A, European Standard";
                }
                enum "B" {
                  tailf:info "annex B, North American Standard";
                }
                enum "C" {
                  tailf:info "annex C, Japan Standard";
                }
              }
            }

            // cable downstream rf-profile * / cable downstream modulation
            leaf modulation {
              tailf:info "set QAM modulation format";
              tailf:cli-full-command;
              type enumeration {
                enum "256" {
                  tailf:info "256QAM";
                }
                enum "64" {
                  tailf:info "64QAM ";
                }
              }
            }

            // cable downstream interleaver-depth
            container interleaver-depth {
              tailf:info "Interleaver Depth, allows 2 options";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf option1 {
                tailf:info "Interleaver Depth option 1";
                tailf:cli-incomplete-command;
                type cable-downstream-interleaver-depth-option;
              }
              leaf option2 {
                tailf:info "Interleaver Depth option 2";
                type cable-downstream-interleaver-depth-option;
              }
            }

            // cable downstream symbol-rate
            leaf symbol-rate {
              tailf:info "set the symbol rate";
              tailf:cli-full-command;
              type uint32 {
                tailf:info "<3500000-7000000>;;symbols per second";
              }
            }
          }
        }
      }

      // cable downstream qam-profile *
      list qam-profile {
        tailf:info "configure chassis level qam profile";
        tailf:cli-mode-name "config-qam-prof";
        key name;
        leaf name {
          type string {
            tailf:info "<0-31>;;Qam Profile ID (<0-3> system defined, <4-31> user defined)";
          }
        }

        // cable downstream qam-profile * / annex
        container annex {
          tailf:info "MPEG framing format, annex A|B|C";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf format {
            tailf:cli-drop-node-name;
            type enumeration {
              enum "A" {
                tailf:info "annex A, European Standard";
              }
              enum "B" {
                tailf:info "annex B, North American Standard";
              }
              enum "C" {
                tailf:info "annex C, Japan Standard";
              }
            }
          }
          leaf freq-spacing {
            tailf:cli-drop-node-name;
            when "../format = 'A'";
            type enumeration {
              enum "6MHZ" {
                tailf:info "6MHZ Freq spacing for ANNEX A";
              }
              enum "7MHZ" {
                tailf:info "7MHZ Freq spacing for ANNEX A";
              }
            }
          }
        }

        // cable downstream qam-profile * / modulation 64
        leaf modulation {
          tailf:info "set QAM modulation format";
          type enumeration {
            enum "256" {
              tailf:info "256QAM";
            }
            enum "64" {
              tailf:info "64QAM ";
            }
          }
        }

        // cable downstream qam-profile * / interleaver-depth I32-J4
        leaf interleaver-depth {
          tailf:info "Interleaver Depth";
          type enumeration {
            enum I12-J17 {
              tailf:info "INTERLEAVER-I-12-J-17 for Annex A or C";
            }
            enum I128-J1 {
              tailf:info "INTERLEAVER-I-128-J-1 for Annex B";
            }
            enum I128-J2 {
              tailf:info "INTERLEAVER-I-128-J-2 for Annex B";
            }
            enum I128-J3 {
              tailf:info "INTERLEAVER-I-128-J-3 for Annex B";
            }
            enum I128-J4 {
              tailf:info "INTERLEAVER-I-128-J-4 for Annex B";
            }
            enum I128-J5 {
              tailf:info "INTERLEAVER-I-128-J-5 for Annex B";
            }
            enum I128-J6 {
              tailf:info "INTERLEAVER-I-128-J-6 for Annex B";
            }
            enum I128-J7 {
              tailf:info "INTERLEAVER-I-128-J-7 for Annex B";
            }
            enum I128-J8 {
              tailf:info "INTERLEAVER-I-128-J-8 for Annex B";
            }
            enum I16-J8 {
              tailf:info "INTERLEAVER-I-16-J-8 for Annex B ";
            }
            enum I32-J4 {
              tailf:info "INTERLEAVER-I-32-J-4 for Annex B ";
            }
            enum I64-J2 {
              tailf:info "INTERLEAVER-I-64-J-2 for Annex B ";
            }
            enum I8-J16 {
              tailf:info "INTERLEAVER-I-8-J-16 for Annex B ";
            }
          }
        }

        // cable downstream qam-profile * / symbol-rate 5057
        leaf symbol-rate {
          tailf:info "set the symbol rate";
          type uint32 {
            tailf:info "<NUM>;;set symbol rate value in kilo-symbol/sec";
          }
        }

        // cable downstream qam-profile * / spectrum-inversion off
        leaf spectrum-inversion {
          tailf:info "set spectrum inversion";
          type enumeration {
            enum off {
              tailf:info "spectrum-inversion off ";
            }
            enum on {
              tailf:info "spectrum-inversion on";
            }
          }
        }

        // cable downstream qam-profile * / description default-annex-b-64-qam
        uses description-grouping;
      }

      // cable downstream controller-profile *
      list controller-profile {
        tailf:info "configure downstream controller profile mode";
        tailf:cli-mode-name "config-controller-profile";
        key id;
        leaf id {
          type uint8 {
            tailf:info "<0-255>;;Downstream controller-profile ID";
          }
        }

        // cable downstream controller-profile * / shutdown
        leaf shutdown {
          tailf:info "Shutdown RF Port";
          type empty;
        }

        // cable downstream controller-profile * / description
        uses description-grouping;

        // cable downstream controller-profile * / broadcast
        leaf broadcast {
          tailf:info "Broadcast to all rpd-ds ports of RPD";
          type empty;
        }

        // cable downstream controller-profile * / max-carrier
        leaf max-carrier {
          tailf:info "Max Carrier of a RF Port";
          type uint8 {
            tailf:info "<1-158>;;RF Port Max Carrier Value";
            range "1..158";
          }
        }

        // cable downstream controller-profile * / max-ofdm-spectrum
        leaf max-ofdm-spectrum {
          tailf:info "Maximum spectrum used by all OFDM channels on port";
          type uint32 {
            tailf:info "<24000000-1170000000>;;Maximum OFDM spectrum value (Hz), in 1 MHz increments";
          }
        }

        // cable downstream controller-profile * / base-channel-power
        leaf base-channel-power {
          tailf:info "set base channel power level";
          type uint8 {
            tailf:info "<35-44>;;Base Channel Power Value in dBmV";
          }
        }

        // cable downstream controller-profile * / rf-chan *
        container rf-chan {
          tailf:info "Configure RF Channel";
          list rf-chan {
            tailf:cli-drop-node-name;
            tailf:cli-mode-name "config-prof-rf-chan";
            cli:ned-diff-move-first {
              cli:arguments "when-delete";
            }
            key start;
            leaf start {
              type uint8 {
                tailf:info "<0-162>;;Starting Qam ID";
              }
            }
            leaf end {
              tailf:cli-drop-node-name;
              tailf:cli-hide-in-submode;
              type uint8 {
                tailf:info "<1-162>;;Ending QAM ID";
                range "1..162";
              }
            }
            uses controller-integrated-cable-rf-chan-grouping;
          }
        }

        // cable downstream controller-profile * / multicast-pool
        leaf multicast-pool {
          tailf:info "Multicast Pool of controller profile";
          tailf:non-strict-leafref {
            path "../../../depi/multicast/pool/id";
          }
          type uint8 {
            tailf:info "<0-127>;;Multicast Pool Profile Number";
            range "0..127";
          }
        }
      }

      // cable downstream ofdm-modulation-profile *
      list ofdm-modulation-profile {
        tailf:info "configure chassis level ofdm modulation profile";
        tailf:cli-mode-name "config-ofdm-mod-prof";
        key id;
        leaf id {
          type uint8 {
            tailf:info "<0-255>;;OFDM modulation profile ID (0-7 reserved for system)";
          }
        }

        // cable downstream ofdm-modulation-profile * / description
        uses description-grouping;

        // cable downstream ofdm-modulation-profile * / subcarrier-spacing
        leaf subcarrier-spacing {
          tailf:info "Configure subcarrier-spacing";
          type enumeration {
            enum "25KHz" {
              tailf:info "25 KHz spacing between 8192 subcarriers";
            }
            enum "50KHz" {
              tailf:info "50 KHz spacing between 4096 subcarriers";
            }
            enum "25KHZ" {
              tailf:info "25 KHz spacing between 8192 subcarriers";
            }
            enum "50KHZ" {
              tailf:info "50 KHz spacing between 4096 subcarriers";
            }
          }
        }

        // cable downstream ofdm-modulation-profile * / width
        leaf width {
          tailf:info "Specify width of profile";
          type uint32 {
            tailf:info "<24000000-192000000>;;Profile width in Hz";
          }
        }

        // cable downstream ofdm-modulation-profile * / start-freq
        leaf start-freq {
          tailf:info "Specify start frequency to use absolute frequencies instead of offsets in modulation assignments";
          type uint32 {
            tailf:info "<108000000-1218000000>;;OFDM channel start frequency in Hz";
          }
        }

        // cable downstream ofdm-modulation-profile * / assign
        container assign {
          tailf:info "Assign modulations to subcarriers";

          // cable downstream ofdm-modulation-profile * / assign modulation-default
          leaf modulation-default {
            tailf:info "Assign default modulation for all subcarriers";
            type qam-modulation-type9;
          }

          // cable downstream ofdm-modulation-profile * / assign modulation *
          container modulation {
            tailf:info "Assign modulation a to a subset of subcarriers";
            list modulation-range-subcarriers {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              tailf:cli-incomplete-command;
              key "name freq-abs";
              leaf name {
                type qam-modulation-type9;
              }
              leaf range-subcarriers {
                tailf:info "Assign modulation to range of subcarriers";
                tailf:cli-prefix-key {
                  tailf:cli-before-key 2;
                }
                type empty;
              }
              leaf freq-abs {
                tailf:info "Specify range using absolute frequencies";
                tailf:cli-expose-key-name;
                type uint32 {
                  tailf:info "<108000000-1218000000>;;Minimum absolute frequency in Hz";
                }
              }
              leaf width {
                tailf:info "Specify width of range in Hz";
                type uint32 {
                  tailf:info "<25000-192000000>;;Width of range in Hz";
                }
              }
            }
            list modulation-range-subcarriers-offset {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              tailf:cli-incomplete-command;
              key "name freq-offset";
              leaf name {
                type qam-modulation-type9;
              }
              leaf range-subcarriers {
                tailf:info "Assign modulation to range of subcarriers";
                tailf:cli-prefix-key {
                  tailf:cli-before-key 2;
                }
                type empty;
              }
              leaf freq-offset {
                tailf:info "Specify range using frequency offsets from lowest possible active subcarrier";
                tailf:cli-expose-key-name;
                type uint32 {
                  tailf:info "<0-191975000>;;Minimum frequency offset in Hz - must be multiple of configured subcarrier spacing";
                }
              }
              leaf width {
                tailf:info "Specify width of range in Hz";
                type uint32 {
                  tailf:info "<25000-192000000>;;Width of range in Hz";
                }
              }
            }
          }
        }
      }

      // cable downstream ofdm-chan-profile *
      list ofdm-chan-profile {
        tailf:info "configure chassis level ofdm channel profile";
        tailf:cli-mode-name "config-ofdm-chan-prof";
        tailf:cli-diff-dependency "../ofdm-modulation-profile";
        key id;
        leaf id {
          type uint8 {
            tailf:info "<0-255>;;OFDM channel profile ID (0-19 reserved for system)";
          }
        }

        // cable downstream ofdm-chan-profile * / description
        uses description-grouping;

        // cable downstream ofdm-chan-profile * / cyclic-prefix
        leaf cyclic-prefix {
          tailf:info "Configure cyclic prefix";
          type enumeration {
            enum "192" {
              tailf:info "192 samples (0.9375 usecs)";
            }
            enum "256" {
              tailf:info "256 samples (1.25 usecs)";
            }
            enum "512" {
              tailf:info "512 samples (2.5 usecs)";
            }
            enum "768" {
              tailf:info "768 samples (3.75 usecs)";
            }
            enum "1024" {
              tailf:info "1024 samples (5.0 usecs)";
            }
          }
        }

        // cable downstream ofdm-chan-profile * / interleaver-depth
        leaf interleaver-depth {
          tailf:info "Configure interleaver-depth";
          type uint8 {
            tailf:info "<1-32>;;Value: 1 - 16 (25 KHz spacing), 1 - 32 (50 KHz spacing)";
            range "1..32";
          }
        }

        // cable downstream ofdm-chan-profile * / pilot-scaling
        leaf pilot-scaling {
          tailf:info "Configure pilot-scaling";
          type uint8 {
            tailf:info "<48-120>;;pilot scaling value";
          }
        }

        // cable downstream ofdm-chan-profile * / roll-off
        leaf roll-off {
          tailf:info "Configure roll-off";
          type enumeration {
            enum "64" {
              tailf:info "64 samples (0.3125 usecs)";
            }
            enum "128" {
              tailf:info "128 samples (0.625 usecs)";
            }
            enum "192" {
              tailf:info "192 samples (0.9375 usecs)";
            }
            enum "256" {
              tailf:info "256 samples (1.25 usecs)";
            }
          }
        }

        // cable downstream ofdm-chan-profile * / subcarrier-spacing
        leaf subcarrier-spacing {
          tailf:info "Configure subcarrier-spacing";
          tailf:cli-diff-modify-after "../profile-data" {
            tailf:cli-when-target-delete;
          }
          type enumeration {
            enum "25KHz" {
              tailf:info "25 KHz spacing between 8192 subcarriers";
            }
            enum "50KHz" {
              tailf:info "50 KHz spacing between 4096 subcarriers";
            }
            enum "25KHZ" {
              tailf:info "25 KHz spacing between 8192 subcarriers";
            }
            enum "50KHZ" {
              tailf:info "50 KHz spacing between 4096 subcarriers";
            }
          }
        }

        // cable downstream ofdm-chan-profile * / profile-control modulation-default
        container profile-control {
          tailf:info "Assign default modulation or profile as the channel control profile";
          leaf modulation-default {
            tailf:info "Assign default modulation to channel profile";
            type qam-modulation-type;
          }
        }

        // cable downstream ofdm-chan-profile * / profile-ncp modulation-default
        container profile-ncp {
          tailf:info "Assign default modulation or profile as the channel ncp profile";
          leaf modulation-default {
            tailf:info "Assign default modulation to channel profile";
            type enumeration {
              enum "16-QAM" {
                tailf:info "Assign 16 QAM modulation";
              }
              enum "64-QAM" {
                tailf:info "Assign 64 QAM modulation";
              }
              enum "QPSK" {
                tailf:info "Assign QPSK modulation";
              }
            }
          }
        }

        // cable downstream ofdm-chan-profile * / guardband-override
        leaf guardband-override {
          tailf:info "Configure guardband-override to override roll-off based system defined guardband defaults";
          type uint32 {
            tailf:info "<0-4000000>;;OFDM channel guardband override in 50000HZ increments";
            range "0..4000000";
          }
        }

        // cable downstream ofdm-chan-profile * / profile-data *
        list profile-data {
          tailf:info "Assign default modulation or profile as a channel data profile";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          key id;
          leaf id {
            type uint8 {
              tailf:info "<1-5>;;One of the channel's data profiles";
              range "1..5";
            }
          }
          choice modulation-choice {
            // cable downstream ofdm-chan-profile * / profile-data * modulation-default
            leaf modulation-default {
              tailf:info "Assign default modulation to channel profile";
              type qam-modulation-type;
            }
            // cable downstream ofdm-chan-profile * / profile-data * modulation-profile
            leaf modulation-profile {
              tailf:info "Assign global modulation profile to channel profile";
              // NOTE: Do not use non-strict-leafref or complex delete will fail
              type uint8 {
                tailf:info "<0-255>;;Global modulation profile identifier";
              }
            }
          }
        }
      }

      // cable downstream ofdm-power-profile *
      list ofdm-power-profile {
        tailf:info "Configure OFDM channel power profile";
        tailf:cli-mode-name "config-ofdm-power-prof";
        key id;
        leaf id {
          type uint8 {
            tailf:info "<1-64>;;OFDM power profile ID";
          }
        }

        // cable downstream ofdm-power-profile * / description
        uses description-grouping;

        // cable downstream ofdm-power-profile * / ofdm-channel-width
        leaf ofdm-channel-width {
          tailf:info "OFDM channel width determines number of 6MHz power bands";
          type uint32 {
            tailf:info "<24000000-192000000>;;OFDM channel width in Hz";
          }
        }

        // cable downstream ofdm-power-profile * / power-adjust-default
        leaf power-adjust-default {
          tailf:info "Configure the default power level for 6Mhz power bands";
          type string {
            tailf:info "WORD;;Power Adjust Range: -9.0 to +8.0 dB";
          }
        }

        // cable downstream ofdm-power-profile * / power-tilt-linear
        leaf power-tilt-linear {
          tailf:info "Configures a linear power tilt across all OFDM power bands";
          type string {
            tailf:info "WORD;;Power Tilt Range: -9.0 to +8.0 dB";
          }
        }
      }

      // cable downstream ofdm-prof-mgmt
      container ofdm-prof-mgmt {
        tailf:info "Chassis level ofdm profile management configuration";

        // cable downstream ofdm-prof-mgmt prof-dwngrd-auto
        leaf prof-dwngrd-auto {
          tailf:info "Toggle automatic profile downgrade";
          type empty;
        }

        // cable downstream ofdm-prof-mgmt exempt-sc-pct
        leaf exempt-sc-pct {
          tailf:info "Subcarrier percent exempted from comparison";
          type uint8 {
            tailf:info "<0-100>;;percent";
            range "0..100";
          }
        }

        // cable downstream ofdm-prof-mgmt unfit-profile-age
        leaf unfit-profile-age {
          tailf:info "Unfit profile age";
          type uint16 {
            tailf:info "<5-1440>;;minutes";
            range "5..1440";
          }
        }

        // cable downstream ofdm-prof-mgmt mer-margin-qdb
        leaf mer-margin-qdb {
          tailf:info "RxMER margin offset in quarter DB";
          type uint8 {
            tailf:info "<0-40>;;quarter DBs";
            range "0..40";
          }
        }

        // cable downstream ofdm-prof-mgmt rxmer-poll-interval
        leaf rxmer-poll-interval {
          tailf:info "RxMER polling interval";
          type uint16 {
            tailf:info "<5-1440>;;minutes";
            range "5..1440";
          }
          default 60;
        }
      }

      // cable downstream ofdm-flow-to-profile
      container ofdm-flow-to-profile {
        tailf:info "Specify the OFDM channel's data profile assigned to a modem's flows";

        // cable downstream ofdm-flow-to-profile profile-data * mac-address
        list profile-data {
          tailf:info "OFDM channel's data profile";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          key id;
          leaf id {
            type uint8 {
              tailf:info "<1-5>;;data profile identifier";
            }
          }
          leaf mac-address {
            tailf:info "Modem's MAC address";
            type string {
              tailf:info "H.H.H;;MAC address";
            }
          }
        }
      }
    }

    // cable downstream-pilot-tone profile *
    container downstream-pilot-tone {
      tailf:info "Cable downstream pilot tone profile";
      list profile {
        tailf:info "profile";
        tailf:cli-mode-name "config-ds-pilot-tone-prof";
        key id;
        leaf id {
          type uint16 {
            tailf:info "<0-511>;;Profile identifier";
          }
        }

        // cable downstream-pilot-tone profile * / rf-chan *
        list rf-chan {
          tailf:info "Downstream RF channel identifier";
          tailf:cli-mode-name "config-rf-chan";
          key id;
          leaf id {
            type uint16 {
              tailf:info "<0-65534>;;Downstream RF channel identifier";
              range "0..65534";
            }
          }

          // cable downstream-pilot-tone profile * / rf-chan * / frequency
          leaf frequency {
            tailf:info "Set frequency";
            type uint32 {
              tailf:info "<54000000-999000000>;;Set frequency value in Hz ";
              range "54000000..999000000";
            }
          }

          // cable downstream-pilot-tone profile * / rf-chan * / no mute
          leaf mute {
            tailf:info "Mute RF channel";
            tailf:cli-boolean-no;
            tailf:cli-full-command;
            type boolean;
            default true;
          }
        }
      }
    }

    // cable upstream
    container upstream {
      tailf:info "global upstream parameters";

      // cable upstream rate-adapt
      container rate-adapt {
        tailf:info "rate adapt";
        tailf:cli-compact-syntax;
        leaf priority {
          tailf:info "Configure priority to enable rate-adapt";
          type uint8 {
            tailf:info "<0-7>;;priority at or above enables rate-adapt.";
            range "0..7";
          }
        }
        leaf rate {
          tailf:info "Configure rate to enable rate-adapt";
          type uint32 {
            tailf:info "<0-30000000>;;rate at or above enables rate-adapt.";
            range "0..30000000";
          }
        }
        leaf local {
          tailf:info "Enable rate-adapt locally per upstream";
          type empty;
        }
      }

      // cable upstream ofdma-prof-mgmt
      container ofdma-prof-mgmt {
        tailf:info "Chassis level ofdma profile management configuration";

        // cable upstream ofdma-prof-mgmt exempt-mslot-pct
        leaf exempt-mslot-pct {
          tailf:info "Minislot percent exempted from comparison";
          type uint8 {
            tailf:info "<1-100>;;percent";
            range "1..100";
          }
        }

        // cable upstream ofdma-prof-mgmt prof-upgrade-auto
        // no cable upstream ofdma-prof-mgmt prof-upgrade-auto
        leaf prof-upgrade-auto {
          tailf:info "automatic profile downgrade";
          tailf:cli-boolean-no;
          type boolean;
        }

        // cable upstream ofdma-prof-mgmt rxmer-poll-interval
        leaf rxmer-poll-interval {
          tailf:info "RxMER polling interval";
          type uint16 {
            tailf:info "<5-1440>;;minutes";
            range "5..1440";
          }
          default 60;
        }

        // cable upstream ofdma-prof-mgmt eq-poll-interval
        leaf eq-poll-interval {
          tailf:info "Equalization polling interval";
          type uint16 {
            tailf:info "<5-1440>;;minutes";
            range "5..1440";
          }
        }

        // cable upstream ofdma-prof-mgmt downgrade
        container downgrade {
          tailf:info "automatic profile downgrade";

          // cable upstream ofdma-prof-mgmt downgrade enable
          leaf enable {
            tailf:info "Enable automatic profile downgrade";
            type empty;
          }

          // cable upstream ofdma-prof-mgmt downgrade interval
          leaf interval {
            tailf:info "Interval in which downgrade criteria is checked (seconds)";
            type uint16 {
              tailf:info "<10-3600>;;seconds";
              range "10..3600";
            }
            default 60;
          }

          // cable upstream ofdma-prof-mgmt downgrade min-cws
          leaf min-cws {
            tailf:info "Minimum codewords needed to evaluate errors.";
            type uint16 {
              tailf:info "<1-65535>;;codewords";
              range "1..65535";
            }
          }

          // cable upstream ofdma-prof-mgmt downgrade partial-threshold
          leaf partial-threshold {
            tailf:info "Hundredths of a percent of errors during an interval to downgrade to Partial Mode";
            type uint32 {
              tailf:info "<0-10000>;;hundredths of a percent or errors";
              range "0..10000";
            }
            default 0;
          }

          // cable upstream ofdma-prof-mgmt downgrade partial-hold-down
          leaf partial-hold-down {
            tailf:info "Time in minutes that upgrade is disabled after a downgrade to partial-mode";
            type uint16 {
              tailf:info "<0-1440>;;minutes";
              range "0..1440";
            }
            default 30;
          }

          // cable upstream ofdma-prof-mgmt downgrade rxmer-enable
          leaf rxmer-enable {
            tailf:info "Enable downgrade to partial based on RxMER data.";
            type empty;
          }

          // cable upstream ofdma-prof-mgmt downgrade rxmer-exempt-mslot-pct
          leaf rxmer-exempt-mslot-pct {
            tailf:info "Minislot percent exempted from comparison from RxMER downgrade";
            type uint16 {
              tailf:info "<0-1000>;;tenths of a precent allowed below IUC";
              range "0..1000";
            }
          }
        }
      }

      // cable upstream controller-profile *
      list controller-profile {
        tailf:info "configure upstream controller profile mode";
        tailf:cli-mode-name "config-controller-profile";
        key name;
        leaf name {
          type uint16 {
            tailf:info "<0-511>;;upstream controller-profile number";
          }
        }

        // cable upstream controller-profile * / description
        uses description-grouping;

        // cable upstream controller-profile * / cable
        container cable {
          tailf:info "Upstream Controller Level cable feature configuration";

          // cable upstream controller-profile * / cable ofdma-frequency-exclusion-band
          container ofdma-frequency-exclusion-band {
            tailf:info "OFDMA controller frequency exclusion band";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf start-value {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint32 {
                tailf:info "<5000000-204000000>;;Lower edge of frequency exclusion band";
              }
            }
            leaf end-value {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<5000000-204000000>;;Higher edge of frequency exclusion band";
              }
            }
          }
        }

        // cable upstream controller-profile * / us-channel *
        uses us-channel-grouping;
      }
    }

    // cable mod-profile-ofdma *
    list mod-profile-ofdma {
      tailf:info "OFDMA Modulation profile";
      tailf:cli-mode-name "config-ofdma-mod-profile";
      key id;
      leaf id {
        type uint16 {
          tailf:info "<401-500>;;OFDMA Modulation Profile Range";
          range "401..500";
        }
      }

      // cable mod-profile-ofdma * / subcarrier-spacing
      leaf subcarrier-spacing {
        tailf:info "define subcarrier spacing";
        type enumeration {
          enum "25KHz" {
            tailf:info "OFDMA subcarrier spacing 25 kHz";
          }
          enum "50KHz" {
            tailf:info "OFDMA subcarrier spacing 50 kHz";
          }
        }
      }

      // cable mod-profile-ofdma * / initial-rng-subcarrier
      leaf initial-rng-subcarrier {
        tailf:info "Number of subcarriers for initial ranging";
        type uint8 {
          tailf:info "<16-64>;;initial ranging subcarriers (even number)";
          range "16..64";
        }
      }

      // cable mod-profile-ofdma * / initial-rng-preamble
      leaf initial-rng-preamble {
        tailf:info "Number of symbols per subcarrier for initial ranging preamble";
        type uint8 {
          tailf:info "<1-8>;;symbols per initial ranging subcarrier";
          range "1..8";
        }
        default 4;
      }

      // cable mod-profile-ofdma * / fine-rng-sub
      leaf fine-rng-subcarrier {
        tailf:info "Number of subcarriers for fine ranging";
        type uint16 {
          tailf:info "<64-256>;;fine ranging subcarriers (even number)";
          range "64..256" {
            tailf:step 2;
          }
        }
      }

      // cable mod-profile-ofdma * / data-iuc *
      list data-iuc {
        tailf:info "Config the data iuc profile";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          type uint8 {
            tailf:info "<5-13>;;Data IUC type";
          }
        }
        leaf modulation {
          tailf:info "Config the data iuc modulation";
          tailf:cli-incomplete-command;
          type enumeration {
            enum "8-QAM" {
              tailf:info "8-QAM";
            }
            enum "16-QAM" {
              tailf:info "16-QAM";
            }
            enum "32-QAM" {
              tailf:info "32-QAM";
            }
            enum "64-QAM" {
              tailf:info "64-QAM";
            }
            enum "128-QAM" {
              tailf:info "128-QAM";
            }
            enum "256-QAM" {
              tailf:info "256-QAM";
            }
            enum "512-QAM" {
              tailf:info "512-QAM";
            }
            enum "1024-QAM" {
              tailf:info "1024-QAM";
            }
            enum "2048-QAM" {
              tailf:info "2048-QAM";
            }
            enum "4096-QAM" {
              tailf:info "4096-QAM";
            }
            enum "BPSK" {
              tailf:info "BPSK";
            }
            enum "NONE" {
              tailf:info "no bit-loading";
            }
            enum "QPSK" {
              tailf:info "QPSK";
            }
          }
        }
        leaf pilot-pattern {
          tailf:info "Config the data iuc pilot pattern";
          type uint8 {
            tailf:info "<1-11>;;pilot pattern index";
          }
        }
      }
    }

    // cable linecard *
    list linecard {
      tailf:info "Linecard related configuration";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-incomplete-command;
      key id;
      leaf id {
        type uint8 {
          tailf:info "<3-12>;;linecard slot number";
          range "3..12";
        }
      }

      // cable linecard * encryption
      leaf encryption {
        tailf:info "encryption options are pkey or dvb or or pme or clear";
        type enumeration {
          enum clear {
            tailf:info "Encryption type is CLEAR";
          }
          enum dual-crypt {
            tailf:info "Encryption type is dual-crypt";
          }
          enum dvb {
            tailf:info "Encryption type is DVB";
          }
          enum pkey {
            tailf:info "Encryption type is PowerKEY";
          }
          enum pme {
            tailf:info "Encryption type is PME";
          }
        }
      }

      // cable linecard * scrambler
      leaf scrambler {
        tailf:info "scrambler options are des or csa or none";
        type enumeration {
          enum none {
            tailf:info "Scrambling algorithm is NONE";
          }
          enum csa {
            tailf:info "Scrambling algorithm is CSA";
          }
          enum des {
            tailf:info "Scrambling algorithm is DES";
          }
        }
      }
    }

    // cable admission-control preempt priority-voice
    // no cable admission-control preempt priority-voice
    container admission-control {
      tailf:info "Configure Cable Admission Control";
      container preempt {
        tailf:info "Reason for preemption";
        leaf priority-voice {
          tailf:info "Priority Voice call can preempt normal";
          tailf:cli-show-no;
          type empty;
        }
      }
    }

    // cable flap-list
    container flap-list {
      tailf:info "Cable flap-list configuration";

      // cable flap-list size
      leaf size {
        tailf:info "Size of flap-list";
        type uint16 {
          tailf:info "<1-8191>;;Maximum number of Cable Modems in the flap-list";
          range "1..8191";
        }
      }

      // cable flap-list aging
      leaf aging {
        tailf:info "Flap-list aging";
        type uint32 {
          tailf:info "<1-86400>;;Maximum number of minutes the cable modem is kept in the flap-list";
          range "1..86400";
        }
      }

      // cable flap-list power-adjust threshold
      container power-adjust {
        tailf:info "Power adjust threshold";
        leaf threshold {
          tailf:info "Power adjust threshold";
          type uint8 {
            tailf:info "<1-10>;;Power adjust threshold in dB";
            range "1..10";
          }
        }
      }

      // cable flap-list miss-threshold
      leaf miss-threshold {
        tailf:info "Per modem threshold which triggers polling flap detector";
        type uint8 {
          tailf:info "<1-12>;;missing consecutive polling messages";
          range "1..12";
        }
      }
    }

    // cable source-verify
    container source-verify {
      tailf:info "Source verify";

      // cable source-verify group *
      list group {
        tailf:info "SAV group";
        tailf:cli-mode-name "config-sav";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of the SAV group, upto 15 characters";
          }
        }
      }

      // cable source-verify enable-sav-static
      leaf enable-sav-static {
        tailf:info "Enable support for SAV group and prefix";
        type empty;
      }

      // cable source-verify leasequery-filter
      container leasequery-filter {
        tailf:info "Source verify Lease query filter";

        // cable source-verify leasequery-filter downstream
        container downstream {
          tailf:info "Source verify Lease query filter for downstream pkts";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf threshold {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-255>;;Number of lease queries for unknown sid";
            }
          }
          leaf interval {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-10>;;size of time window in seconds";
              range "1..10";
            }
          }
        }
      }
    }

    // cable modem
    container modem {
      tailf:info "Modem polling using SNMP query";
      tailf:cli-diff-dependency "../../snmp-server";

      // cable modem remote-query
      container remote-query {
        tailf:info "Modem polling using SNMP query";

        // cable modem remote-query
        container gather {
          tailf:cli-drop-node-name;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf polling-interval {
            tailf:cli-drop-node-name;
            tailf:cli-remove-before-change;
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<1-86400>;;Periodic polling interval in seconds";
              range "1..86400";
            }
          }
          leaf community-string {
            tailf:cli-drop-node-name;
            tailf:cli-remove-before-change;
            type string {
              tailf:info "WORD;;Community string ";
            }
          }
        }

        // cable modem remote-query src-ip
        leaf src-ip {
          tailf:info "source IP address";
          tailf:cli-diff-delete-before "../gather/polling-interval";
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Source IP addr";
          }
        }
      }

      // cable modem max-cpe
      leaf max-cpe {
        tailf:info "Max CPE override";
        type union {
          type uint8 {
            tailf:info "<1-255>;;Number";
          }
          type enumeration {
            enum unlimited {
              tailf:info "Max CPE not enforced";
            }
          }
        }
      }

      // cable modem v6-max-cpe-prefix
      leaf v6-max-cpe-prefix {
        tailf:info "Max CPE override";
        type uint16 {
          tailf:info "<0-1023>;;Number";
          range "0..1023";
        }
      }

      // cable modem vendor *
      list vendor {
        tailf:info "Cable modem vendor information";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key oui;
        leaf oui {
          type string {
            tailf:info "WORD;;OUI of the vendor in the format xx.xx.xx or xx:xx:xx";
          }
        }
        leaf vendor-name {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;Vendor name";
          }
        }
      }
    }

    // cable modulation-profile
    container modulation-profile {
      tailf:info "Modulation profile";

      // cable modulation-profile *
      list modulation-profile-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key profile;
        leaf profile {
          type string {
            tailf:info "WORD;;Modulation Profile Group";
          }
        }
        // cable modulation-profile * atdma
        container atdma {
          tailf:info "DOCSIS2.0 atdma mode";
          uses cable-modulation-profile-list-grouping;
        }
        // cable modulation-profile * tdma
        container tdma {
          tailf:info "DOCSIS1.x tdma mode";
          uses cable-modulation-profile-list-grouping;
        }
        // cable modulation-profile * mixed
        container mixed {
          tailf:info "DOCSIS1.x/2.0 tdma-atdma mixed mode";
          uses cable-modulation-profile-list-grouping;
        }
        uses cable-modulation-profile-list-grouping;
      }
    }

    // cable tag *
    list tag {
      tailf:info "cable tag";
      tailf:cli-mode-name "config-cmts-tag";
      key id;
      leaf id {
        type uint16 {
          tailf:info "<1-1000>;;The id of the tag";
          range "1..1000";
        }
      }
      // cable tag * / name
      leaf name {
        tailf:info "Name of the tag";
        type string {
          tailf:info "WORD;;Globally unique name string of the tag";
        }
      }

      // cable tag * / service-type-id
      leaf service-type-id {
        tailf:info "Set the match rule for service type id";
        type string {
          tailf:info "WORD;;Service Type ID";
        }
      }

      // cable tag * / docsis-version
      leaf docsis-version {
        tailf:info "Set the match rule for DOCSIS version";
        type enumeration {
          enum docsis10 {
            tailf:info "Match docsis 1.0 modems";
          }
          enum docsis11 {
            tailf:info "Match docsis 1.1 modems";
          }
          enum docsis20 {
            tailf:info "Match docsis 2.0 modems";
          }
          enum docsis30 {
            tailf:info "Match docsis 3.0 modems";
          }
        }
      }

      // cable tag * / service-class
      leaf service-class {
        tailf:info "Set the match rule for service class name";
        type string {
          tailf:info "WORD;;Service class name";
        }
      }
    }

    // cable service
    container service {
      tailf:info "Service flow/class setting";

      // cable service class *
      list class {
        tailf:info "Service class settings";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key class-index;
        leaf class-index {
          type uint16 {
            tailf:info "<1-1023>;;Class Index";
            range "1..1023";
          }
        }

        // cable service class * name
        leaf name {
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;The ascii string identifier for this Service Class";
          }
        }

        // cable service class * downstream
        // cable service class * upstream
        choice direction-choice {
          leaf downstream {
            tailf:info "Service Class is downstream";
            tailf:cli-full-command;
            tailf:cli-diff-dependency "../name";
            type empty;
          }
          leaf upstream {
            tailf:info "Service Class is upstream";
            tailf:cli-full-command;
            tailf:cli-diff-dependency "../name";
            type empty;
          }
        }

        // cable service class * peak-rate
        leaf peak-rate {
          tailf:info "Peak Rate within maximum traffic burst";
          tailf:cli-diff-dependency "../name";
          type uint32 {
            tailf:info "<0-4294967295>;;Enter Peak Rate (bps";
          }
        }

        // cable service class * max-concat-burst
        leaf max-concat-burst {
          tailf:info "Max Concat Burst";
          tailf:cli-diff-dependency "../name";
          type uint16 {
            tailf:info "<0-65535>;;Enter Max Concat Burst (bytes)";
          }
        }

        // cable service class * tos-overwrite
        container tos-overwrite {
          tailf:info "Overwrite TOS byte by setting mask bits to value";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-diff-dependency "../name";
          leaf and-mask {
            tailf:cli-drop-node-name;
            tailf:cli-no-value-on-delete;
            tailf:cli-incomplete-command;
            type string {
              tailf:info "<0x0-0xFF>;,TOS-overwrite-mask-and byte in hex";
            }
          }
          leaf or-mask {
            tailf:cli-drop-node-name;
            tailf:cli-no-value-on-delete;
            type string {
              tailf:info "<0x0-0xFF>;;TOS-overwrite-mask-or byte in hex";
            }
          }
        }

        // cable service class * req-trans-policy
        leaf req-trans-policy {
          tailf:info "Request Transmission Policy Bit Field";
          tailf:cli-full-command;
          tailf:cli-diff-dependency "../name";
          type string {
            tailf:info "<0x0-0xFFFFFFFF>;;Enter Request Transmission Policy Bit Field in hex";
          }
        }

        // cable service class * max-rate
        leaf max-rate {
          tailf:info "Max Rate";
          tailf:cli-diff-dependency "../name";
          type uint32 {
            tailf:info "<0-4294967295>;;Enter Max Rate (bps)";
          }
        }

        // cable service class * max-burst
        leaf max-burst {
          tailf:info "Max Tx Burst";
          tailf:cli-diff-dependency "../name";
          type uint32 {
            tailf:info "<1522-4294967295>;;Enter Max Tx Burst (bytes)";
            range "1522..4294967295";
          }
        }

        // cable service class * min-rate
        leaf min-rate {
          tailf:info "Min Rate";
          tailf:cli-diff-dependency "../name";
          type uint32 {
            tailf:info "<0-4294967295>;;Enter Min Resv Rate (bps)";
          }
        }

        // cable service class * min-packet-size
        leaf min-packet-size {
          tailf:info "Min Packet Size for Reserved Rate";
          tailf:cli-diff-dependency "../name";
          type uint16 {
            tailf:info "<0-65535>;;Enter Min Packet Size for Reserved Rate(bytes)";
          }
        }

        // cable service class * max-latency
        leaf max-latency {
          tailf:info "Max Latency";
          tailf:cli-diff-dependency "../name";
          type uint32 {
            tailf:info "<0-4294967295>;;Enter Max Latency(usecs)";
          }
        }

        // cable service class * req-attr-mask
        leaf req-attr-mask {
          tailf:info "Required Attribute Mask";
          tailf:cli-full-command;
          tailf:cli-diff-dependency "../name";
          type string {
            tailf:info "<0-FFFFFFFF>;;The attribute bitmap in hex";
          }
        }

        // cable service class * admission-timeout
        leaf admission-timeout {
          tailf:info "Admitted QoS Param Set Timeout";
          tailf:cli-diff-dependency "../name";
          type uint16 {
            tailf:info "<0-65535>;;Enter Admitted QoS Param Set Timeout";
          }
        }

        // cable service class * activity-timeout
        leaf activity-timeout {
          tailf:info "QoS Param Set Activity Timeout";
          tailf:cli-diff-dependency "../name";
          type uint16 {
            tailf:info "<0-65535>;;Enter QoS Param Set Activity Timeout";
          }
        }

        // cable service class * priority
        leaf priority {
          tailf:info "Priority";
          tailf:cli-diff-dependency "../name";
          type uint8 {
            tailf:info "<0-7>;;Enter Priority";
            range "0..7";
          }
        }

        // cable service class * sched-type
        leaf sched-type {
          tailf:info "Service Class Schedule Type";
          tailf:cli-diff-dependency "../name";
          type enumeration {
            enum "2" {
              tailf:info "Best Effort Schedule Type";
            }
            enum "3" {
              tailf:info "Non Real-Time Polling Service Schedule Type";
            }
            enum "4" {
              tailf:info "Real-Time Polling Service Schedule Type";
            }
            enum "5" {
              tailf:info "Unsolicited Grant Service with Activity Detection Schedule Type";
            }
            enum "6" {
              tailf:info "Unsolicited Grant Service Schedule Type";
            }
          }
        }
      }

      // cable service type *
      list type {
        tailf:info "service type";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          tailf:cli-suppress-range;
          type string {
            tailf:info "WORD;;Service Type Id";
          }
        }
        leaf ds-frequency {
          tailf:info "downstream frequency";
          type uint32 {
            tailf:info "<55000000-858000000>;;Frequency - Hz";
            range "55000000..858000000";
          }
        }
      }

      // cable service attribute
      container attribute {
        tailf:info "Service attribute settings";

        // cable service attribute ds-bonded downstream-type bonding-enabled
        container ds-bonded {
          tailf:info "Downstream Bonding Settings";
          container downstream-type {
            tailf:info "Bonding downstream-type settings";
            container bonding-enabled {
              tailf:info "Channel Bonding only supported on Bonding-capable interfaces";
              tailf:cli-delete-when-empty;
              presence true;
              leaf enforce {
                tailf:info "Enforce Bonding-capable interface selection";
                type empty;
              }
            }
          }
        }

        // cable service attribute withhold-tlvs peak-rate
        container withhold-tlvs {
          tailf:info "Withhold D3.0 TLVs from pre-D3.0 modems";
          leaf peak-rate {
            tailf:info "Peak Traffic Rate TLV 24/25.27";
            type empty;
          }
        }
      }

      // cable service flow activity-timeout
      container flow {
        tailf:info "Service flow settings";
        leaf activity-timeout {
          tailf:info "Default value for Service flow activity timeout";
          type uint16 {
            tailf:info "<0-65535>;;Seconds";
          }
        }
      }
    }

    // cable qos
    container qos {
      tailf:info "Cable Quality of Service";

      // cable qos permission
      container permission {
        tailf:info "Permission for Creating Cable Quality of Service Profile";
        // cable qos permission create
        // no cable qos permission create
        leaf create {
          tailf:info "Allow create by management";
          tailf:cli-show-no;
          type empty;
        }
        // cable qos permission update
        // no cable qos permission update
        leaf update {
          tailf:info "Allow update by management";
          tailf:cli-show-no;
          type empty;
        }
        // cable qos permission modems
        // no cable qos permission modems
        leaf modems {
          tailf:info "Allow create by modems";
          tailf:cli-show-no;
          type empty;
        }
      }
    }

    // cable multicast mdf-disable
    container multicast {
      tailf:info "Cable Multicast";
      container mdf-disable {
        tailf:info "Disable Multicast DSID Forwarding mode";

        // cable multicast mdf-disable WB-Incapable-CM
        leaf WB-Incapable-CM {
          tailf:info "Wideband Incapable modems only";
          type empty;
        }

        // cable multicast mdf-disable DSG
        leaf DSG {
          tailf:info "DSG eCMs";
          type empty;
        }
      }
    }

    // cable filter
    container filter {
      tailf:info "CMTS packet filter settings";

      // cable filter group *
      list group {
        tailf:info "CMTS packet filter group settings";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key group-id;
        leaf group-id {
          type uint8 {
            tailf:info "<1-254>;;Group ID";
            range "1..254";
          }
        }
        // cable filter group * index *
        list index {
          tailf:info "CMTS packet filter index settings";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key index-num;
          leaf index-num {
            type uint8 {
              tailf:info "<1-255>;;Filter Index";
            }
          }
          // cable filter group * index * src-ip
          leaf src-ip {
            tailf:info "IP source address";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Enter IP source address";
            }
          }
          // cable filter group * index * src-mask
          leaf src-mask {
            tailf:info "IP source address mask";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Enter IP source address mask";
            }
          }
          // cable filter group * index * dest-ip
          leaf dest-ip {
            tailf:info "IP destination address";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Enter IP destination address";
            }
          }
          // cable filter group * index * dest-mask
          leaf dest-mask {
            tailf:info "IP destination address mask";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Enter IP destination address mask";
            }
          }
          // cable filter group * index * v6-src-address
          leaf v6-src-address {
            tailf:info "IPv6 source address";
            type inet:ipv6-address {
              tailf:info "X:X:X:X::X;;Enter IPv6 source address";
            }
          }
          // cable filter group * index * v6-src-pfxlen
          leaf v6-src-pfxlen {
            tailf:info "IPv6 source address prefix length";
            type uint8 {
              tailf:info "<0-128>;;Enter Source Address Prefix Length";
              range "0..128";
            }
          }
          // cable filter group * index * v6-dest-address
          leaf v6-dest-address {
            tailf:info "IPv6 destination address";
            type inet:ipv6-address {
              tailf:info "X:X:X:X::X;;Enter IPv6 destination address";
            }
          }
          // cable filter group * index * v6-dest-pfxlen
          leaf v6-dest-pfxlen {
            tailf:info "IPv6 destination address prefix length";
            type uint8 {
              tailf:info "<0-128>;;Enter Destination Address Prefix Length";
              range "0..128";
            }
          }
          // cable filter group * index * v6-flow-label
          leaf v6-flow-label {
            tailf:info "IPv6 flow label";
            type uint32 {
              tailf:info "<0-1048575>;;Enter IPv6 flow label";
              range "0..1048575";
            }
          }
          // cable filter group * index * ip-proto
          leaf ip-proto {
            tailf:info "IP protocol";
            type uint16 {
              tailf:info "<0-256>;;Enter IP protocol type";
              range "0..256";
            }
          }
          // cable filter group * index * ip-tos
          container ip-tos {
            tailf:info "IP TOS byte settings";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf tos-mask {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type string {
                tailf:info "<0x0-0xFF>;;Enter mask against TOS value, byte in hex";
              }
            }
            leaf tos-value {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "<0x0-0xFF>;;Enter TOS value, byte in hex";
              }
            }
          }
          // cable filter group * index * src-port
          leaf src-port {
            tailf:info "TCP/UDP source port";
            type uint16 {
              tailf:info "<0-65535>;;Enter TCP/UDP Source Port";
            }
          }
          // cable filter group * index * dest-port
          leaf dest-port {
            tailf:info "TCP/UDP destination port";
            type uint16 {
              tailf:info "<0-65535>;;Enter TCP/UDP Destination Port";
            }
          }
          // cable filter group * index * ip-version
          leaf ip-version {
            tailf:info "IP version of filter";
            type enumeration {
              enum IPv4 {
                tailf:info "Filter is for IPv4 (default)";
              }
              enum IPv6 {
                tailf:info "Filter is for IPv6";
              }
            }
            default IPv4;
          }
          // cable filter group * index * tcp-flags
          container tcp-flags {
            tailf:info "TCP flags settings";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf flags-mask {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type string {
                tailf:info "<0x0-0x3F;;Enter TCP Flags Mask in Hex";
              }
            }
            leaf flags-value {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "<0x0-0x3F>;;Enter TCP Flags Value in Hex";
              }
            }
          }
          // cable filter group * index * match-action
          leaf match-action {
            tailf:info "Filter Match action processing";
            type enumeration {
              enum accept {
                tailf:info "Accept Packet on Match";
              }
              enum drop {
                tailf:info "Drop Packet on Match";
              }
            }
          }
          // cable filter group * index * status
          leaf status {
            tailf:info "Status of filter";
            type enumeration {
              enum active {
                tailf:info "Filter is active";
              }
              enum inactive {
                tailf:info "Filter is inactive";
              }
            }
            default active;
          }
        }
      }
    }

    // cable monitor
    container monitor {
      tailf:info "cable monitor";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-cable-monitor";

      // cable monitor / sniff card * *
      list sniff {
        tailf:info "cable monitor sniff";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "card param";
        leaf card {
          tailf:info "sniff card";
          tailf:cli-expose-key-name;
          type uint8 {
            tailf:info "<0-9>;;card slot number";
            range "0..9";
          }
        }
        leaf param {
          tailf:cli-multi-word-key;
          type string {
            tailf:info "LINE;;cable sniff <card> parameters";
          }
        }
      }
    }

    // cable submgmt
    container submgmt {
      tailf:info "CMTS Subscriber Management Objects";
      container default {
        tailf:info "Defaults";
        container filter-group {
          tailf:info "Configure Filter Group";
          // cable submgmt default filter-group cm
          container cm {
            tailf:info "CM Group Defaults";
            uses cable-submgmt-default-filter-group-grouping;
          }
          // cable submgmt default filter-group cpe
          container cpe {
            tailf:info "CPE Group Defaults";
            uses cable-submgmt-default-filter-group-grouping;
          }
          // cable submgmt default filter-group mta
          container mta {
            tailf:info "MTA Group Defaults";
            uses cable-submgmt-default-filter-group-grouping;
          }
          // cable submgmt default filter-group stb
          container stb {
            tailf:info "STB Group Defaults";
            uses cable-submgmt-default-filter-group-grouping;
          }
          // cable submgmt default filter-group ps
          container ps {
            tailf:info "PS Group Defaults";
            uses cable-submgmt-default-filter-group-grouping;
          }
        }
        // cable submgmt default active
        leaf active {
          tailf:info "CPE Control for Subscriber Management Filtering";
          type empty;
        }
      }
    }

    // cable logging
    container logging {
      tailf:info "Logs specific cable messages";

      // cable logging badipsource
      container badipsource {
        tailf:info "cable BADIPSOURCE messages";
        tailf:cli-delete-when-empty;
        presence true;
        leaf buffer-size {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<4096-4121440>;;Buffer size";
          }
        }
      }

      // cable logging layer2events
      container layer2events {
        tailf:info "cable layer 2 messages";
        tailf:cli-delete-when-empty;
        presence true;
        leaf buffer-size {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<4096-4121440>;;Buffer size";
          }
        }
      }

      // cable logging overlapip
      container overlapip {
        tailf:info "cable OVERLAPIP messages";
        tailf:cli-delete-when-empty;
        presence true;
        leaf buffer-size {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<4096-4121440>;;Buffer size";
          }
        }
      }

      // cable logging ironbus
      container ironbus {
        tailf:info "cable IRONBUS messages";
        tailf:cli-delete-when-empty;
        presence true;
        leaf buffer-size {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<4096-4121440>;;Buffer size";
          }
        }
      }

      // cable logging downstream-index
      container downstream-index {
        tailf:info "cable downstream index messages";
        tailf:cli-delete-when-empty;
        presence true;
        leaf buffer-size {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<4096-4121440>;;Buffer size";
          }
        }
      }
    }

    // cable us-freq-use-cm-cap
    leaf us-freq-use-cm-cap {
      tailf:info "Use CM Capability TLV 5.20 for US freq range";
      type empty;
    }

    // cable default-tos-qos10 tos-overwrite
    container default-tos-qos10 {
      tailf:info "Default DOCSIS 1.0 ToS Overwrite";
      container tos-overwrite {
        tailf:info "Overwrite ToS byte by setting mask bits to value";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf tos-and {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type string {
            tailf:info "<0x0-0xFF>;;ToS-overwrite-mask-and byte in hex";
          }
        }
        leaf tos-or {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "<0x0-0xFF>;;ToS-overwrite-mask-or byte in hex";
          }
        }
      }
    }

    // cable primary-sflow-qos11 keep
    container primary-sflow-qos11 {
      tailf:info "Keep the primary service flows after CM in QoS DOCSIS11 mode offline";
      leaf keep {
        tailf:info "Keep the primary service flows after CM in QoS DOCSIS11 mode offline";
        type enumeration {
          enum all {
            tailf:info "Keep CLI and SNMP counters after CM in QoS DOCSIS11 mode offline";
          }
          enum snmp-only {
            tailf:info "Keep SNMP counters only after CM in QoS DOCSIS11 mode offline";
          }
        }
      }
    }

    // cable sflog
    container sflog {
      tailf:info "CMTS Service Flow Logging Configuration";

      // cable sflog max-entry
      container max-entry {
        tailf:info "Max. number of entries in service flow log.";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf value {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<30000-59999>;;Max. number of entries in the service flow log.";
            range "30000..59999";
          }
        }
        leaf entry-duration {
          tailf:info "Service flow log entry duration in second";
          type uint32 {
            tailf:info "<3600-86400>;;Service flow log entry duration in second.";
            range "3600..86400";
          }
        }
      }

      // cable sflog stop-record-time-overwrite
      leaf stop-record-time-overwrite {
        tailf:info "Overwrite SAMIS 2.0/3.0 record create time with sflog generate time, for service-flow stop record only.";
        type empty;
      }
    }

    // cable trust *
    list trust {
      tailf:info "Trusted cable hosts list";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key address;
      leaf address {
        type string {
          tailf:info "H.H.H;;MAC address of the trusted host";
        }
      }
    }

    // cable dynamic-secret
    container dynamic-secret {
      tailf:info "Cable dynamic secret";

      // cable dynamic-secret exclude
      container exclude {
        tailf:info "Exclude single modem";
        // cable dynamic-secret exclude modem
        leaf modem {
          tailf:info "Exclude single modem";
          type string {
            tailf:info "H.H.H;;MAC address of the modem to exclude";
          }
        }
        // cable dynamic-secret exclude oui
        leaf oui {
          tailf:info "Exclude group of modems based on OUI";
          type string {
            tailf:info "WORD;;OUI to exclude";
          }
        }
      }

      // cable dynamic-secret tftp
      container tftp {
        tailf:info "TFTP Proxy Options";
        // cable dynamic-secret tftp insert-upgrade-server
        leaf insert-upgrade-server {
          tailf:info "Automatically insert upgrade server TLV into the DOCSIS configuration file";
          type empty;
        }
      }
    }

    // cable docsis30-voice downstream
    container docsis30-voice {
      tailf:info "Docsis 3.0 voice default configurations";
      container downstream {
        tailf:info "Downstream Service parameters";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf req-attr-mask {
          tailf:info "SF Required Attribute Mask";
          tailf:cli-incomplete-command;
          type string {
            tailf:info "<0-FFFFFFFF>;;The attribute bitmap in hex";
          }
        }
        leaf forb-attr-mask {
          tailf:info "SF Forbidden Attribute Mask";
          type string {
            tailf:info "<0-FFFFFFFF>;;The attribute bitmap in hex";
          }
        }
      }
    }

    // cable util-interval
    leaf util-interval {
      tailf:info "Set channel utilization interval";
      type uint32 {
        tailf:info "<1-86400>;;The time interval in seconds";
        range "1..86400";
      }
    }

    // cable clock
    container clock {
      tailf:info "Clock card";

      // cable clock dti
      leaf dti {
        tailf:info "set DTI clock reference mode";
        type empty;
      }

      // cable clock dti-server-type
      leaf dti-server-type {
        tailf:info "Server type configuration (Polylink/Symmetricom)";
        type enumeration {
          enum polylink {
            tailf:info "DTI server type - Polylink";
          }
          enum symmetricom {
            tailf:info "DTI server type - Symmetricom";
          }
        }
      }
    }

    // cable bgsync
    container bgsync {
      tailf:info "switch snmp sync state";

      // no cable bgsync active
      leaf active {
        tailf:info "set background sync status";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // cable bgsync ptime
      leaf ptime {
        tailf:info "set how long(unit second) a p packet sent";
        type uint32 {
          tailf:info "<5-86400>;;in second";
          range "5..86400";
        }
        default 5;
      }

      // cable bgsync itime
      leaf itime {
        tailf:info "set how long(unit second) a i packet sent";
        type uint32 {
          tailf:info "<5-31536000>;;in second";
          range "5..31536000";
        }
        default 86400;
      }
    }

    // cable privacy
    container privacy {
      tailf:info "Cable Privacy";

      // cable privacy encrypt-alg-priority
      leaf encrypt-alg-priority {
        tailf:info "Encryption algorithm priority";
        type enumeration {
          enum aes128-des40-des56 {
            tailf:info "Priority AES128, DES40, DES56";
          }
          enum aes128-des56-des40 {
            tailf:info "Priority AES128, DES56, DES40";
          }
          enum des40-aes128-des56 {
            tailf:info "Priority DES40, AES128, DES56";
          }
          enum des40-des56-aes128 {
            tailf:info "Priority DES40, DES56, AES128";
          }
          enum des56-aes128-des40 {
            tailf:info "Priority DES56, AES128, DES40";
          }
          enum des56-des40-aes128 {
            tailf:info "Priority DES56, DES40, AES128";
          }
        }
      }

      // cable privacy hotlist
      container hotlist {
        tailf:info "Add host list";

        // cable privacy hotlist cm *
        list cm {
          tailf:info "Add cm hotlist";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key address;
          leaf address {
            type string {
              tailf:info "H.H.H;;MAC address H.H.H";
            }
          }
        }
      }
    }

    // cable dsg
    container dsg {
      tailf:info "Set DSG advance mode global parameters";

      // cable dsg client-list * id-index *
      list client-list {
        tailf:info "DSG client list settings";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key client-list-id;
        leaf client-list-id {
          type uint16 {
            tailf:info "<1-65535>;;DSG client list ID";
            range "1..65535";
          }
        }
        list id-index {
          tailf:info "DSG Client ID settings";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          key id;
          leaf id {
            type uint16 {
              tailf:info "<1-65535>;;DSG client ID index for the client list";
              range "1..65535";
            }
          }
          choice parameter-choice {
            leaf application-id {
              tailf:info "DSG Client type Application ID";
              type string {
                tailf:info "<1-FFFF>;;Hex value of DSG Client type Application ID";
              }
            }
            leaf broadcast {
              tailf:info "DSG Client type broadcast";
              type uint16 {
                tailf:info "<1-65535>;;DSG Broadcast client";
                range "1..65535";
              }
            }
            leaf ca-system-id {
              tailf:info "DSG Client type CA system ID";
              type string {
                tailf:info "<1-FFFF>;;Hex value of DSG Client type CA system ID";
              }
            }
            leaf mac-addr {
              tailf:info "DSG Client type Mac address";
              type string {
                tailf:info "H.H.H;;DSG Client MAC address";
              }
            }
          }
        }
      }

      // cable dsg tg *
      list tg {
        tailf:info "DSG Tunnel Group";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        ios:display-separated "((?:no )?cable dsg tg \\d+)";
        key group-id;
        leaf group-id {
          type uint16 {
            tailf:info "<1-65535>;;DSG Tunnel Group ID";
            range "1..65535";
          }
        }
        // cable dsg tg * channel *
        list channel {
          tailf:info "DSG Channel";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key channel-id;
          leaf channel-id {
            type uint16 {
              tailf:info "<1-65535>;;DSG Channel ID";
              range "1..65535";
            }
          }
          // cable dsg tg * channel * priority
          leaf priority {
            tailf:info "DSG Rule priority";
            type uint8 {
              tailf:info "<0-255>;;DSG Rule priority";
            }
          }
          // cable dsg tg * channel * enable
          // cable dsg tg * channel * disable
          leaf status {
            tailf:cli-drop-node-name;
            type enumeration {
              enum disable {
                tailf:info "Disable DSG tunnel group";
              }
              enum enable {
                tailf:info "Enable DSG tunnel group";
              }
            }
            default enable;
          }
        }
      }

      // cable dsg tunnel *
      list tunnel {
        tailf:info "DSG tunnel";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        key tunnel-id;
        leaf tunnel-id {
          type uint16 {
            tailf:info "<1-65535>;;Tunnel id";
            range "1..65535";
          }
        }
        leaf mac-addr {
          tailf:info "destination MAC address";
          tailf:cli-incomplete-command;
          type string {
            tailf:info "H.H.H;;Multicast group MAC address";
          }
        }
        leaf tg {
          tailf:info "tunnel group id";
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<1-65535>;;tunnel group id";
            range "1..65535";
          }
        }
        leaf clients {
          tailf:info "DSG Clients";
          type uint16 {
            tailf:info "<1-65535>;;DSG Clients";
            range "1..65535";
          }
        }
        leaf status {
          tailf:cli-drop-node-name;
          type enumeration {
            enum disable {
              tailf:info "disable tunnel";
            }
            enum enable {
              tailf:info "enable tunnel";
            }
          }
          default enable;
        }
      }

      // cable dsg cfr *
      list cfr {
        tailf:info "DSG classifier";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        key index;
        leaf index {
          type uint16 {
            tailf:info "<1-65535>;;Classifier index";
            range "1..65535";
          }
        }
        leaf dest-ip {
          tailf:info "destination IP address";
          type string {
            tailf:info "WORD;;Multicast group IP address or hostname";
          }
        }
        leaf tunnel {
          tailf:cli-break-sequence-commands;
          tailf:info "tunnel index";
          type uint16 {
            tailf:info "<1-65535>;;tunnel index";
            range "1..65535";
          }
        }
        leaf priority {
          tailf:info "Classifier priority";
          type uint8 {
            tailf:info "<0-255>;;Classifier priority";
          }
        }
        leaf src-ip {
          tailf:info "source IP address";
          type string {
            tailf:info "WORD;;source IP address or hostname";
          }
        }
        leaf in-dcd {
          tailf:info "classifier is included in DCD or not";
          type enumeration {
            enum ignore {
              tailf:info "classifier is not included in DCD regardless of tunnel MAC address";
            }
            enum no {
              tailf:info "classifier is not included in DCD";
            }
            enum yes {
              tailf:info "classifier is included in DCD";
            }
          }
        }
      }

      // cable dsg timer *
      list timer {
        tailf:info "DSG Timer settings";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key index;
        leaf index {
          type uint16 {
            tailf:info "<1-65535>;;DSG Timer index";
            range "1..65535";
          }
        }
        leaf Tdsg1 {
          tailf:info "DSG Initialization Timeout (Tdsg1) setting";
          type uint16 {
            tailf:info "<1-65535>;;DSG Initialization Timeout (Tdsg1) value";
            range "1..65535";
          }
        }
        leaf Tdsg2 {
          tailf:info "DSG Operational Timeout (Tdsg2) setting";
          type uint16 {
            tailf:info "<1-65535>;;DSG Initialization Timeout (Tdsg2) value";
            range "1..65535";
          }
        }
        leaf Tdsg3 {
          tailf:info "DSG Two-Way Retry Timer (Tdsg3) setting";
          type uint16 {
            tailf:info "<0-65535>;;DSG Initialization Timeout (Tdsg3) value";
          }
        }
        leaf Tdsg4 {
          tailf:info "DSG One-Way Retry Timer (Tdsg4) setting";
          type uint16 {
            tailf:info "<0-65535>;;DSG Initialization Timeout (Tdsg4) value";
          }
        }
      }

      // cable dsg chan-list * index * freq
      list chan-list {
        tailf:info "DSG Channel List settings";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-incomplete-command;
        key "id index";
        leaf id {
          type uint16 {
            tailf:info "<1-65535>;;DSG Channel List index";
            range "1..65535";
          }
        }
        leaf index {
          tailf:info "DSG channel frequency entry setting";
          tailf:cli-expose-key-name;
          type uint16 {
            tailf:info "<1-65535>;;DSG channel frequency entry index";
            range "1..65535";
          }
        }
        leaf freq {
          tailf:info "DSG Channel Frequency setting";
          type uint32 {
            tailf:info "<47000000-862000000>;;Center frequency of the downstream channel in Hz";
          }
        }
      }
    }

    // cable load-balance
    container load-balance {
      tailf:info "DOCSIS load balancing";

      // cable load-balance docsis-enable
      leaf docsis-enable {
        tailf:info "Enable docsis 2.0 load balancing";
        type empty;
      }

      // cable load-balance docsis30-enable
      container docsis30-enable {
        tailf:info "Enable docsis 3.0 load balancing";
        tailf:cli-delete-when-empty;
        presence true;
        // cable load-balance docsis30-enable downstream-only
        leaf downstream-only {
          type empty;
        }
        // cable load-balance docsis30-enable dynamic downstream
        container dynamic {
          tailf:info "Enable doscis 3.0 dynamic load balancing";
          leaf downstream {
            tailf:info "Enable doscis 3.0 dynamic downstream load balancing";
            type empty;
          }
        }
      }

      // cable load-balance method-utilization min-threshold
      container method-utilization {
        tailf:info "method-utilization settings";
        leaf min-threshold {
          tailf:info "Set the minimum threshold of method utilization";
          type uint8 {
            tailf:info "<10-90>;;minimum threshold value of method utilization in %";
          }
        }
      }

      // cable load-balance us-attribute-mask force-check
      container us-attribute-mask {
        tailf:info "Upstream attribute mask setting";
        leaf force-check {
          tailf:info "Force check upstream attribute";
          type empty;
        }
      }

      // cable load-balance fixed-primary-channel
      leaf fixed-primary-channel {
        tailf:info "Move the modem without primary channel change";
        type empty;
      }

      // cable load-balance modem max-failures
      container modem {
        tailf:info "Modem settings";
        leaf max-failures {
          tailf:info "Set the time of failed movements before modem is removed from dynamic LB";
          type uint8 {
            tailf:info "<0-100>;;Maximum failures before modem is removed from dynamic LB";
            range "0..100";
          }
        }
      }

      // cable load-balance rule *
      list rule {
        tailf:info "Enter docsis load balance rule";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        key rule-id;
        leaf rule-id {
          type uint32 {
            tailf:info "<1-4294967295>;;DOCSIS load balance rule ID";
            range "1..4294967295";
          }
        }
        choice status-choice {
          container ds {
            tailf:cli-drop-node-name;
            container disable-throughput-lowerbound {
              tailf:info "load balance is disabled if CM throughput is lower than a threshold";
              // cable load-balance rule * disable-throughput-lowerbound ds
              leaf ds {
                tailf:info "Specify DS throughput lowerbound";
                type uint32 {
                  tailf:info "<0-1000000>;;Throughput lowerbound in kbps";
                  range "0..1000000";
                }
              }
            }
          }
          container us {
            tailf:cli-drop-node-name;
            container disable-throughput-lowerbound {
              tailf:info "load balance is disabled if CM throughput is lower than a threshold";
              // cable load-balance rule * disable-throughput-lowerbound us
              leaf us {
                tailf:info "Specify US throughput lowerbound";
                type uint32 {
                  tailf:info "<0-1000000>;;Throughput lowerbound in kbps";
                  range "0..1000000";
                }
              }
            }
          }
          leaf disabled {
            tailf:info "load balance is always disabled";
            type empty;
          }
          leaf enabled {
            tailf:info "load balance is always enabled";
            type empty;
          }
        }
      }

      // cable load-balance docsis-policy *
      list docsis-policy {
        tailf:info "Enter docsis load balance policy";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key policy-id;
        leaf policy-id {
          type uint32 {
            tailf:info "<1-4294967295>;;DOCSIS load balance policy ID";
            range "1..4294967295";
          }
        }
        // cable load-balance docsis-policy * rule *
        list rule {
          tailf:info "Enter docsis load balance rule";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key rule-id;
          leaf rule-id {
            tailf:non-strict-leafref {
              path "../../../rule/rule-id";
            }
            type uint32 {
              tailf:info "<1-4294967295>;;DOCSIS load balance rule ID";
            }
          }
        }
        // cable load-balance docsis-policy * tag *
        list tag {
          tailf:info "Tag name";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Tag name";
            }
          }
          leaf override {
            tailf:info "Override the default";
            type empty;
          }
        }
      }

      // cable load-balance d20-ggrp-default
      container d20-ggrp-default {
        tailf:info "Set DOCSIS 2.0 general group default value ";

        // cable load-balance d20-ggrp-default init-tech-list
        leaf init-tech-list {
          tailf:info "Set DOCSIS GGRP DCC/DBC init tech as default";
          type uint32 {
            tailf:info "<grouplist>;;Set DCC/DBC Initialization technique list as default";
          }
        }

        // cable load-balance d20-ggrp-default method utilization
        container method {
          tailf:info "Set default load balancing type/method";
          container utilization {
            tailf:info "Interface utilization";
            presence true;
          }
        }

        // cable load-balance d20-ggrp-default policy
        container policy {
          tailf:info "Set default load balancing policy";

          // cable load-balance d20-ggrp-default policy pure-ds-load
          leaf pure-ds-load {
            tailf:info "Do not count US load when calculating DS utilization";
            type empty;
          }
        }

        // cable load-balance d20-ggrp-default threshold
        container threshold {
          tailf:info "Set default load balancing threshold in %";

          // cable load-balance d20-ggrp-default threshold load
          container load {
            tailf:info "Set default interface load threshold setting";
            leaf value {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<1-100>;;Set threshold value in % as default";
                range "1..100";
              }
            }
          }
        }
      }

      // cable load-balance d30-ggrp-default
      container d30-ggrp-default {
        tailf:info "Set DOCSIS 3.0 general group default value";

        // cable load-balance d30-ggrp-default disable
        leaf disable {
          tailf:info "Set disable DOCSIS GGRP as default";
          type empty;
        }

        // cable load-balance d30-ggrp-default init-tech-list
        leaf init-tech-list {
          tailf:info "Set DOCSIS GGRP DCC/DBC init tech as default";
          type string {
            tailf:info "<grouplist>;;Set DCC/DBC Initialization technique list as default";
          }
        }

        // cable load-balance d30-ggrp-default docsis-policy
        leaf docsis-policy {
          tailf:info "Set DOCSIS GGRP policy ID as default";
          tailf:non-strict-leafref {
            path "/ios:cable/load-balance/docsis-policy/policy-id";
          }
          type uint32 {
            tailf:info "<0-4294967295>;;Set DOCSIS load balance policy ID as default";
          }
        }

        // cable load-balance d30-ggrp-default policy
        leaf policy {
          tailf:info "Set default load balancing policy";
          type enumeration {
            enum pcmm {
              tailf:info "Enable balancing of modems with active PCMM service flows";
            }
            enum pure-ds-load {
              tailf:info "Do not count US load when calculating DS utilization";
            }
            enum ugs {
              tailf:info "Enable balancing of modems with active UGS service flows";
            }
            enum us-across-ds {
              tailf:info "Load balancing on US groups across DS, DS method will be ignored";
            }
          }
        }

        // cable load-balance d30-ggrp-default threshold
        container threshold {
          tailf:info "Set default load balancing threshold in %";

          // cable load-balance d30-ggrp-default threshold load
          container load {
            tailf:info "Set default interface load threshold setting";
            leaf load-value {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<1-100>;;Set threshold value in % as default";
                range "1..100";
              }
            }
            // cable load-balance d30-ggrp-default threshold load minimum
            leaf minimum {
              tailf:info "Set minimum number of modems/flows difference before loadbalancing starts as default";
              type uint8 {
                tailf:info "<1-100>;;Set minimum number of modems/flows as default";
                range "1..100";
              }
            }
          }
        }

        // cable load-balance d30-ggrp-default method
        container method {
          tailf:info "Set default load balancing type/method";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-full-no;
          leaf value {
            tailf:cli-drop-node-name;
            type enumeration {
              enum utilization {
                tailf:info "Interface utilization";
              }
              enum modems {
                tailf:info "Number of modems";
              }
            }
          }
          leaf primary-distributed {
            tailf:info "Distribute the cm on all of the primary channel";
            tailf:cli-optional-in-sequence;
            when "../value = 'utilization'" {
              tailf:dependency "../value";
            }
            type empty;
          }
          leaf us-method {
            tailf:info "Set default load balancing type/method for US";
            type enumeration {
              enum utilization {
                tailf:info "Interface utilization";
              }
              enum modems {
                tailf:info "Number of modems";
              }
            }
          }
        }
      }

      // cable load-balance docsis-group
      container docsis-group {
        tailf:info "DOCSIS group";

        // cable load-balance docsis-group FN *
        list FN {
          tailf:cli-mode-name "config-lb-group";
          key fn-id;
          leaf fn-id {
            type uint16 {
              tailf:info "<1-256>;;cable fiber-node ID";
              range "1..256";
            }
          }
          container MD {
            tailf:info "Enter MAC-domain interface";
            tailf:cli-hide-in-submode;
            tailf:cli-flatten-container;
            leaf Cable {
              tailf:info "Cable;;CMTS interface";
              tailf:cli-allow-join-with-value {
                tailf:cli-display-joined;
              }
              tailf:cli-hide-in-submode;
              tailf:non-strict-leafref {
                path "../../../../../../interface/Cable/name";
              }
              type string {
                pattern '[0-9]+.*';
              }
            }
          }
          uses cable-load-balance-docsis-group-grouping;
        }

        // cable load-balance docsis-group *
        list docsis-group-list {
          tailf:cli-drop-node-name;
          tailf:cli-mode-name "config-lb-group";
          key docsis-group-id;
          leaf docsis-group-id {
            type uint32 {
              tailf:info "<1-2147483647>;;DOCSIS load balance group number";
              range "1..2147483647";
            }
          }
          uses cable-load-balance-docsis-group-grouping;
        }
      }

      // cable load-balance group *
      list group {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key id;
        leaf id {
          type uint16 {
            tailf:info "<1-256>;;Load balance group number";
            range "1..256";
          }
        }
      }

      // cable load-balance exclude
      container exclude {
        tailf:info "Exclude modems from load balancing";

        // cable load-balance exclude modem *
        list modem {
          tailf:info "Exclude single modem";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key address;
          leaf address {
            type string {
              tailf:info "H.H.H;;MAC address of modem to exclude";
            }
          }
        }

        // cable load-balance exclude oui *
        list oui {
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-reset-container;
          key word;
          leaf word {
            type string {
              tailf:info "WORD;;OUI of exclude modem in the formatxx.xx.xx or xx:xx:xx";
            }
          }
          leaf assignment {
            tailf:info "Exclude modem at assigning phase";
            tailf:cli-full-command;
            type empty;
          }
          leaf enforce {
            tailf:info "Exclude only for enforced load balancing";
            tailf:cli-full-command;
            type empty;
          }
          leaf static {
            tailf:info "Exclude only for static load balancing";
            type empty;
          }
          leaf strict {
            tailf:info "Exclude all forms of load balancing";
            tailf:cli-full-command;
            type empty;
          }
        }
      }
    }

    // cable metering
    container metering {
      tailf:info "CMTS Metering Configuration";

      // cable metering destination
      // cable metering ipdr-d3 session
      choice cable-metering-choice {
        container destination {
          tailf:info "Cable Metering Collector IP address";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf ip-address {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            tailf:cli-remove-before-change;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Enter IP address of primary";
            }
          }
          leaf port {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<1-65535>;;Enter Port Number of primary";
              range "1..65535";
            }
          }
          leaf ip-address2 {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            tailf:cli-incomplete-command;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Enter IP address of secondary";
            }
          }
          leaf port2 {
            when "../ip-address2" {
              tailf:dependency "../ip-address2";
            }
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<1-65535>;;Enter Port Number of secondary";
              range "1..65535";
            }
          }
          leaf retries {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-5>;;Enter number of retries ";
              range "0..5";
            }
          }
          leaf minutes {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<2-1440>;;Enter metering data collection interval in minutes";
              range "2..1440";
            }
          }
          leaf security {
            tailf:cli-drop-node-name;
            type enumeration {
              enum non-secure {
                tailf:info "Non secure streaming";
              }
              enum secure {
                tailf:info "Secure streaming";
              }
            }
          }
          leaf flow-aggregate {
            tailf:cli-break-sequence-commands;
            tailf:info "Only aggregate service flow information";
            type empty;
          }
          leaf cpe-list-suppress {
            tailf:info "Suppress cpe information";
            type empty;
          }
          leaf full-records {
            tailf:info "Full service flow (active and idle) records";
            type empty;
          }
        }
        container ipdr-d3 {
          tailf:info "Cable Metering Exporter through IPDR D3.0";
          container session {
            tailf:info "IPDR D3 session";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf session-id {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint8 {
                tailf:info "<1-255>;;Enter metering ipdr D3 session id";
                range "1..255";
              }
            }
            leaf type {
              tailf:info "IPDR D3 Service Definition Type of Metering";
              type uint8 {
                tailf:info "<1-2>;;Enter metering IPDR D3 Service Definition Type";
                range "1..2";
              }
            }
            leaf flow-aggregate {
              tailf:info "Only aggregate service flow information";
              tailf:cli-optional-in-sequence;
              type empty;
            }
            leaf full-records {
              tailf:info "Full service flow (active and idle) records";
              type empty;
            }
          }
        }
      }

      // cable metering ipdr ? session ?
      container ipdr {
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf interval {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<2-1440>;;Enter metering data streaming interval in minutes";
            range "2..1440";
          }
        }
        leaf session {
          tailf:info "IPDR session";
          type uint8 {
            tailf:info "<1-255>;;Enter metering ipdr session id";
            range "1..255";
          }
        }
        leaf flow-aggregate {
          tailf:info "Only aggregate service flow information";
          tailf:cli-optional-in-sequence;
          type empty;
        }
        leaf full-records {
          tailf:info "Full service flow (active and idle) records";
          type empty;
        }
      }

      // cable metering source-interface
      container source-interface {
        tailf:info "source-interface for the billing packets";
        uses interface-name-grouping;
      }

      // cable metering data-per-session
      container data-per-session {
        tailf:info "Number of flows per session";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf data-per-session {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<3-30>;;Enter # of data flows per session";
            range "3..30";
          }
        }
        leaf timer {
          tailf:info "CLC timer to wake up ";
          type uint16 {
            tailf:info "<8-500>;;Enter timer wake up interval in msec";
            range "8..500";
          }
        }
      }
    }

    // cable rf-change-trigger
    container rf-change-trigger {
      tailf:info "NP RF status change trigger";
      tailf:cli-compact-syntax;
      leaf percent {
        tailf:info "% of CM report NP RF status change";
        type uint8 {
          tailf:info "<1-100>;;% of CM report NP RF status change";
          range "1..100";
        }
      }
      leaf count {
        tailf:info "#of CM report NP RF status change";
        type uint16 {
          tailf:info "<1-65535>;;#of CM report NP RF status change";
          range "1..65535";
        }
      }
      leaf secondary {
        tailf:info "move secondary service flows";
        type empty;
      }
    }

    // cable ofdm-rf-change-trigger
    container ofdm-rf-change-trigger {
      tailf:info "NP OFDM RF status change trigger";
      tailf:cli-compact-syntax;
      leaf percent {
        tailf:info "% of CM report NP OFDM RF status change";
        type uint8 {
          tailf:info "<1-100>;;% of CM report NP OFDM RF status change";
          range "1..100";
        }
      }
      leaf count {
        tailf:info "#of CM report NP OFDM RF status change";
        type uint16 {
          tailf:info "<1-65535>;;#of CM report NP OFDM RF status change";
          range "1..65535";
        }
      }
    }

    // cable rf-change-dampen-time
    leaf rf-change-dampen-time {
      tailf:info "NP RF status change dampen time";
      type uint16 {
        tailf:info "<1-65535>;;#of seconds NP RF status change must persist";
        range "1..65535";
      }
    }

    // cable rf-change-up-multiplier
    leaf rf-change-up-multiplier {
      tailf:info "NP RF status change up multiplier";
      type uint8 {
        tailf:info "<1-100>;;#of times NP RF status up change";
        range "1..100";
      }
      default 2;
    }

    // cable resiliency
    container resiliency {
      tailf:info "Resiliency functionality";

      // cable resiliency ds-bonding
      leaf ds-bonding {
        tailf:info "Downstream resiliency bonding groups";
        type empty;
      }

      // cable resiliency free-interval
      leaf free-interval {
        tailf:info "Wideband resiliency bonding group free interval";
        type uint16 {
          tailf:info "<30-600>;;free interval in seconds";
          range "30..600";
        }
      }
    }

    // cable throttle-modem
    container throttle-modem {
      tailf:info "Manage CM initialization/registration throttling on large systems";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf init-rate {
        tailf:info "Maximum number of modems pass the initialization step per second";
        tailf:cli-incomplete-command;
        type uint16 {
          tailf:info "<1-1000>;;Default value is 32 CM/Sec";
          range "1..1000";
        }
      }
      leaf holdoff-time {
        tailf:info "Maximum number of seconds a modem waiting in throttling queue";
        tailf:cli-incomplete-command;
        type uint8 {
          tailf:info "<5-100>;;Default value is 45 Seconds";
          range "5..100";
        }
      }
      leaf flush-rate {
        tailf:info "Maximum number of modems flushing from throttling queue once holdoff time is expired";
        type uint16 {
          tailf:info "<100-1000>;;Default value is 300 CM/Sec";
          range "100..1000";
        }
      }
    }

    // cable ds-max-burst
    container ds-max-burst {
      tailf:info "Enable maximum traffic burst";
      tailf:cli-delete-when-empty;
      presence true;
      choice optional {
        leaf burst-threshold {
          tailf:info "Threshold to enable maximum traffic burst";
          type uint32 {
            tailf:info "<64-1000000>;;Burst Threshold in Kbytes (default = 1000)";
            range "64..1000000";
          }
          default 1000;
        }
        leaf peak-rate {
          tailf:info "Peak rate within the maximum traffic burst";
          type uint32 {
            tailf:info "<0-1000000>;;Peak Rate in Kbps (default is unshaped)";
            range "0..1000000";
          }
        }
      }
    }

    // cable acfe
    container acfe {
      tailf:info "Configure Fairness across DOCSIS interfaces";

      // cable acfe enable
      leaf enable {
        tailf:info "Enable Fairness across DOCSIS interfaces (Adaptive CIR Fair EIR)";
        type empty;
      }

      // cable acfe period
      leaf period {
        tailf:info "Set EIR rebalance period";
        type uint8 {
          tailf:info "<5-60>;;seconds";
          range "5..60";
        }
      }
    }

    // cable l2-vpn-service xconnect
    container l2-vpn-service {
      tailf:info "Use Layer-2 Tunnels for CPE traffic behind certain CMs";
      container xconnect {
        tailf:info "Tunnel traffic to L2VPN circuit";

        // cable l2-vpn-service xconnect extended-mtu
        container extended-mtu {
          tailf:info "D3.1 Extended Packet Length Support";
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          presence true;
          leaf value {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<1500-2000>;;Customized MTU";
              range "1500..2000";
            }
          }
        }

        // cable l2-vpn-service xconnect nsi
        container nsi {
          tailf:info "Network System Interface";

          // cable l2-vpn-service xconnect nsi dot1q
          container dot1q {
            tailf:info "Tunnel traffic to DOT1Q L2VPN";
            tailf:cli-display-separated;
            presence true;
            // cable l2-vpn-service xconnect nsi dot1q interface
            container interface {
              tailf:info "Default Ethernet NSI interface";
              uses interface-name-grouping;
            }
          }

          // cable l2-vpn-service xconnect nsi mpls
          container mpls {
            tailf:info "Tunnel traffic to ATOM/MPLS PW";
            presence true;
          }
        }
      }
    }

    // cable dot1q-vc-map *
    list dot1q-vc-map {
      tailf:info "Map a CM to an Ethernet VLAN";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-incomplete-command;
      key mac-address;
      leaf mac-address {
        type string {
          tailf:info "H.H.H;;Modem MAC address";
        }
      }
      container ethernet-interface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        uses interface-name-grouping;
      }
      leaf vlan-id {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<2-4095>;;IEEE 802.1Q VLAN ID";
          range "2..4095";
        }
      }
      leaf cust-name {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "WORD;;Customer Name";
        }
      }
    }

    // cable l2vpn *
    list l2vpn {
      tailf:info "Cable Modem Ethernet L2VPN Service";
      tailf:cli-mode-name "config-l2vpn";
      tailf:cli-sequence-commands;
      key mac-address;
      leaf mac-address {
        type string {
          tailf:info "H.H.H;;Modem MAC address";
        }
      }
      leaf customer-name {
        tailf:cli-drop-node-name;
        tailf:cli-hide-in-submode;
        type string {
          tailf:info "WORD;;Customer Name";
        }
      }

      // cable l2vpn * / service instance *
      container service {
        tailf:cli-break-sequence-commands;
        tailf:info "Ethernet service";
        list instance {
          tailf:info "Ethernet service Instance";
          tailf:cli-mode-name "config-ethsrv";
          tailf:cli-sequence-commands;
          tailf:cli-incomplete-command;
          max-elements 1;
          key id;
          leaf id {
            type uint16 {
              tailf:info "<1-8000>;;Ethernet service Instance id";
            }
          }
          leaf ethernet {
            tailf:info "Service Type  - Ethernet";
            tailf:cli-hide-in-submode;
            tailf:cli-full-command;
            type empty;
          }

          // cable l2vpn * / service instance * / encapsulation
          // encapsulation default  - READ ONLY

          // cable l2vpn * / service instance * / xconnect
          container xconnect {
            tailf:cli-break-sequence-commands;
            tailf:info "Xconnect service";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-xconn";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            tailf:cli-incomplete-command;
            tailf:cli-delete-when-empty;
            presence true;
            leaf address {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              tailf:cli-hide-in-submode;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Pseudo-wire Peer IP address";
              }
            }
            leaf vcid {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              tailf:cli-hide-in-submode;
              type uint32 {
                tailf:info "<1-4294967295>;;Pseudo Wire VCID";
                range "1..4294967295";
              }
            }
            leaf encapsulation {
              tailf:info "Data encapsulation method";
              tailf:cli-hide-in-submode;
              type enumeration {
                enum mpls {
                  tailf:info "Use MPLS encapsulation";
                }
              }
            }
            leaf pw-type {
              tailf:info "MPLS Pseudo-wire Type";
              tailf:cli-optional-in-sequence;
              tailf:cli-hide-in-submode;
              type uint8 {
                tailf:info "<4-5>;;Type-5 : Ethernet Port, Type-4 : Ethernet VLAN";
                range "4..5";
              }
            }

            // cable l2vpn * / service instance * / xconnect / backup
            container backup {
              tailf:cli-break-sequence-commands;
              tailf:info "Xconnect backup configuration commands";

              // cable l2vpn * / service instance * / xconnect / backup peer *
              list peer {
                tailf:info "Backup pseudowire";
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                tailf:cli-compact-syntax;
                max-elements 3;
                key "peer-router-ip-addr vcid";
                leaf peer-router-ip-addr {
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;IP address of peer";
                  }
                }
                leaf vcid {
                  type uint32 {
                    tailf:info "<1-4294967295>;;Enter VC ID value";
                    range "1..4294967295";
                  }
                }
                leaf priority {
                  tailf:info "Optional priority to use for backup pseudowire.";
                  type uint8 {
                    tailf:info "Peer priority";
                    range "1..10";
                  }
                }
              }

              // interface * / xconnect encapsulation / backup delay
              container delay {
                tailf:info "Backup delay";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands;
                leaf enable-delay {
                  tailf:cli-drop-node-name;
                  tailf:cli-incomplete-command;
                  type uint8 {
                    tailf:info "<0-180>;;Enable delay";
                    range "0..180";
                  }
                  default 0;
                }
                leaf disable-delay {
                  tailf:cli-drop-node-name;
                  type union {
                    type uint8 {
                      tailf:info "<0-180>;;Disable delay";
                      range "0..180";
                    }
                    type enumeration {
                      enum never {
                        tailf:info "Disallow disable";
                      }
                    }
                  }
                  default 0;
                }
              }
            }
          }

          // cable l2vpn * / service instance * / cable set
          container cable {
            tailf:info "Cable Specific commands";
            container set {
              tailf:info "Set parameters";
              leaf mpls-experimental {
                tailf:info "Set MPLS Pseudo-wire Experimental bits";
                type uint8 {
                  tailf:info "<0-7>;;MPLS Experimental Bits Value";
                }
              }
            }
          }
        }
      }
    }

    // cable wideband auto-reset
    container wideband {
      tailf:info "Wideband Configuration";

      // cable wideband auto-reset
      leaf auto-reset {
        tailf:info "Reset WCMs reg'd traditional-DOCSIS";
        type empty;
      }

      // cable wideband rphy-auto-reset
      leaf rphy-auto-reset {
        tailf:info "Reset Wcms reg'd traditional-DOCSIS for RPHY";
        type empty;
      }
    }

    // cable rcc-template *
    list rcc-template {
      tailf:info "Create Cable RCC-Template";
      tailf:cli-mode-name "config-rcc-template";
      key index;
      leaf index {
        type uint8 {
          tailf:info "<1-255>;;cable rcc-template id";
          range "1..255";
        }
      }

      // cable rcc-template * / rcp-id
      leaf rcp-id {
        tailf:info "Receive Channel Profile ID";
        tailf:cli-multi-value;
        tailf:cli-full-command;
        type string {
          tailf:info "<0x0-0xFF>;;RCP ID in hex";
        }
      }

      // cable rcc-template * / receive-module
      list receive-module {
        tailf:info "Receive Module entry";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        key index;
        leaf index {
          type uint8 {
            tailf:info "<1-10>;;Receive Module index";
            range "1..10";
          }
        }
        leaf first-center-frequency {
          tailf:info "Module Center frequency";
          type uint32 {
            tailf:info "<55000000-1050000000>;;Center Frequency - Hz";
            range "55000000..1050000000";
          }
        }
        leaf connected-receive-module {
          tailf:info "Receive Modules";
          type uint8 {
            tailf:info "<1-10>;;Connected Receive Module index";
            range "1..10";
          }
        }
      }

      // cable rcc-template * / receive-channel
      list receive-channel {
        tailf:info "Receive Channel entry";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        key index;
        leaf index {
          type uint8 {
            tailf:info "<1-24>;;Receive Channel index";
            range "1..24";
          }
        }
        leaf center-frequency {
          tailf:info "Channel Center frequency";
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<55000000-1050000000>;;Center Frequency - Hz";
            range "55000000..1050000000";
          }
        }
        leaf connected-receive-module {
          tailf:info "Receive Modules";
          type uint8 {
            tailf:info "<1-10>;;Connected Receive Module index";
            range "1..10";
          }
        }
        leaf primary {
          tailf:info "Receive Channel Primary indicator";
          type empty;
        }
      }
    }

    // cable virtual-service-group *
    list virtual-service-group {
      tailf:info "Virtual service group configuration";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-remove-before-change;
      tailf:cli-incomplete-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Virtual Service Group Name";
        }
      }
      choice cable-choice {
        leaf downstream-cable {
          tailf:info "RPD downstream cable interface";
          tailf:cli-remove-before-change;
          tailf:cli-incomplete-command;
          type string {
            tailf:info "<slot>/<card>/<port>;;Enter slot/subslot/bay";
          }
        }
        leaf upstream-cable {
          tailf:info "Upstream Cable";
          tailf:cli-remove-before-change;
          tailf:cli-incomplete-command;
          type string {
            tailf:info "<slot>/<card>/<port>;;Enter slot/subslot/bay";
          }
        }
        leaf downstream-video {
          tailf:info "Downstream Video";
          tailf:cli-remove-before-change;
          tailf:cli-incomplete-command;
          type string {
            tailf:info "<slot>/<card>/<port>;;Enter slot/subslot/bay";
          }
        }
      }
      leaf profile {
        tailf:info "Controller Profile";
        type uint16 {
          tailf:info "<0-1056>;;Controller Profile id";
        }
      }
    }

    // cable oob
    container oob {
      tailf:info "Cable oob config commands";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-oob";
      presence true;

      // cable oob / virtual-om *
      list virtual-om {
        tailf:info "Define a virtual om configuration";
        tailf:cli-mode-name "config-oob-vom";
        key id;
        leaf id {
          type uint8 {
            tailf:info "<1-10>;;virtual om id";
            range "1..10";
          }
        }

        // cable oob / virtual-om * / ip
        container ip {
          tailf:info "virtual om source ip address";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf address {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP address";
            }
          }
          leaf mask {
            tailf:cli-drop-node-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP subnet mask";
            }
          }
        }

        // cable oob / virtual-om * / join-group
        container join-group {
          tailf:info "join multicast group address";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf group-ip {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;group IP address";
            }
          }
          leaf source-ip {
            tailf:info "SSM source address";
            tailf:cli-incomplete-command;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP address";
            }
          }
          leaf out-group {
            tailf:info "local om group";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;group IP address";
            }
          }
        }
      }

      // cable oob / virtual-arpd *
      list virtual-arpd {
        tailf:info "Define a virtual arpd configuration";
        tailf:cli-mode-name "config-oob-varpd";
        key id;
        leaf id {
          type uint8 {
            tailf:info "<1-32>;;1-32";
            range "1..32";
          }
        }

        // cable oob / virtual-arpd * / ip
        container ip {
          tailf:info "Source IP address";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf address {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP address";
            }
          }
          leaf mask {
            tailf:cli-drop-node-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP subnet mask";
            }
          }
        }

        // cable oob / virtual-arpd * / nc
        container nc {
          tailf:info "Network controller";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf address {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP address";
            }
          }
          leaf udp-port {
            tailf:info "NC's UDP port configuration";
            type uint16 {
              tailf:info "<1-65535>;;Destination UDP port number";
              range "1..65535";
            }
          }
        }

        // cable oob / virtual-arpd * / source-id
        leaf source-id {
          tailf:info "Source ID";
          type uint32 {
            tailf:info "<1-4294967295>;;Source ID value";
            range "1..4294967295";
          }
        }
      }

      // cable oob / static-pseudowire *
      list static-pseudowire {
        tailf:info "Define a Static Pseudowire";
        tailf:cli-mode-name "config-oob-spw";
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Static Pseudowire name";
          }
        }
        leaf type {
          tailf:info "Static-pseudowire type: type <ndf | ndr>";
          tailf:cli-incomplete-command;
          tailf:cli-hide-in-submode;
          tailf:cli-remove-before-change;
          type enumeration {
            enum ndf {
              tailf:info "NDF Static-pseudowire";
            }
            enum ndr {
              tailf:info "NDR Static-pseudowire";
            }
          }
        }
        leaf id {
          tailf:info "Static Pseudowire Identifier";
          tailf:cli-hide-in-submode;
          tailf:cli-full-command;
          type uint32 {
            tailf:info "<1-4294967295>;;Static-pseudowire id";
            range "1..4294967295";
          }
        }

        // cable oob / static-pseudowire * / dest-ip
        container dest-source {
          tailf:cli-drop-node-name;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          when "../type = 'ndf'" {
            tailf:dependency "../type";
          }
          leaf dest-ip {
            tailf:info "Destination unicast or multicast IP";
            type union {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Unicast (0.0.0.0) or multicast IPv4 address";
              }
              type inet:ipv6-address {
                tailf:info "X:X:X:X::X;;Unicast (0::0) or multicast group IPv6 address";
              }
            }
          }
          leaf source-ip {
            tailf:info "Source ip address";
            type union {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Source IPv4 address";
              }
              type inet:ipv6-address {
                tailf:info "X:X:X:X::X;;Source IPv6 address";
              }
            }
          }
        }

        // cable oob / static-pseudowire * / server-ip
        leaf server-ip {
          tailf:info "Static Pseudowire: Source/Server ip address";
          when "../type = 'ndr'" {
            tailf:dependency "../type";
          }
          type union {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Server IPv4 address";
            }
            type inet:ipv6-address {
              tailf:info "X:X:X:X::X;;Server IPv6 address";
            }
          }
        }

        // cable oob / static-pseudowire * / session-id
        leaf session-id {
          tailf:info "session-id";
          type string {
            tailf:info "<0x1-0xFFFFFFFF>;;NDF session id";
          }
        }
      }
    }

    // cable rphy
    container rphy {
      tailf:info "rphy";

      // cable rphy ccap-core-event *
      list ccap-core-event {
        tailf:info "configure ccap core event report";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          tailf:cli-incomplete-command;
          type enumeration {
            enum evt-66080102 {
              tailf:info "configure rpd connection lost event";
            }
            enum evt-66080100 {
              tailf:info "configure rpd connection refuse event";
            }
            enum evt-66080101 {
              tailf:info "configure GCP connection close for multi-act-pri core event";
            }
            enum evt-66080104 {
              tailf:info "configure Successfully reconnected to RPD event";
            }
            enum evt-66080105 {
              tailf:info "configure RPD reconnect rejected event";
            }
            enum evt-66080200 {
              tailf:info "configure Session Latency Threshold warning event";
            }
            enum evt-66080201 {
              tailf:info "configure Session Latency Threshold critical event";
            }
            enum evt-66080400 {
              tailf:info "configure GCP/RCP Communication Error event";
            }
          }
        }
        leaf enable {
          tailf:info "enable rpd connection refuse report";
          type empty;
        }
      }

      // cable rphy link redundancy
      container link {
        tailf:info "Digi-PIC link";
        leaf redundancy {
          tailf:info "Enable/disable Digi-PIC link redundancy";
          tailf:cli-remove-before-change;
          type enumeration {
            enum cold {
              tailf:info "Cold mode";
            }
            enum hot {
              tailf:info "Hot mode";
            }
          }
        }
      }
    }

    // cable video
    container video {
      tailf:info "Cable video config commands";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-video";
      tailf:cli-diff-dependency "../../interface";
      presence true;

      // cable video / multicast-uplink
      container multicast-uplink {
        tailf:info "Interface name used for Video Routing Multicast Joins";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        // dep: before this created, must change interface
        tailf:cli-diff-dependency "../../../interface" {
          tailf:cli-trigger-on-set;
        }
        uses interface-name-grouping;
        leaf access-list {
          tailf:info "Customer supplied access list in form of 'ip access-list standard <name>' used for Multicast SSM Joins.";
          tailf:cli-diff-dependency "/ios:ip/access-list";
          type string {
            tailf:info "WORD;;Multicast Access List name";
          }
        }
        leaf access-list-global {
          tailf:info "Customer supplied access list in form of 'ip access-list standard <name>' used for Global config of Multicast SSM and ASM Joins. Defaults to SSM only global access list name";
          tailf:cli-optional-in-sequence;
          type string {
            tailf:info "WORD;;Global SSM/ASM Multicast Access List name";
          }
        }
        leaf rp {
          tailf:info "Head End Multicast Redndezvous Point IP address.";
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;RP IP address";
          }
        }
      }

      // cable video / default-onid
      leaf default-onid {
        tailf:info "set global default ONID";
        type uint16 {
          tailf:info "<0-65535>;;0-65535";
        }
      }

      // cable video / default-psi-interval
      leaf default-psi-interval {
        tailf:info "set global default psi-interval";
        type uint16 {
          tailf:info "<40-1000>;;40-1000 msec";
          range "40..1000";
        }
      }

      // cable video / use-pcr-fo
      leaf use-pcr-fo {
        tailf:info "Configure use-pcr-fo option";
        type empty;
      }

      // cable video / pcr-based-source-switch
      leaf pcr-based-source-switch {
        tailf:info "pcr-based-source-switch configuration";
        type empty;
      }

      // cable video / default-nit-reference
      leaf default-nit-reference {
        tailf:info "set global default NIT reference";
        type uint16 {
          tailf:info "<1-8190>;;1-8190";
          range "1..8190";
        }
      }

      // cable video / mgmt-intf VirtualPortGroup
      container mgmt-intf {
        tailf:info "Cable Video Control Plane Management Interface";
        leaf VirtualPortGroup {
          tailf:info "Virtual Port Group";
          tailf:cli-remove-before-change;
          cli:ned-diff-move-last {
            cli:arguments "when-delete";
          }
          tailf:non-strict-leafref {
            path "/ios:interface/VirtualPortGroup/name";
          }
          type uint8 {
            tailf:info "<0-31>;;VirtualPortGroup interface number";
            range "0..31";
          }
        }
      }

      // cable video / service-distribution-group *
      list service-distribution-group {
        tailf:info "Define a group of Physical RF channels";
        tailf:cli-mode-name "config-video-sdg";
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Group name";
          }
        }
        leaf id {
          tailf:info "service distribution identifier";
          tailf:cli-hide-in-submode;
          type uint16 {
            tailf:info "<1-65535>;;1-65535";
            range "1..65535";
          }
        }

        // cable video / service-distribution-group * / rpd downstream-cable
        container rpd {
          tailf:info "Remote PHY device configuration";
          leaf downstream-cable {
            tailf:info "downstream-cable interface";
            tailf:cli-remove-before-change;
            type string {
              tailf:info "<slot>/<card>/<port>;;Enter slot/subslot/bay";
            }
          }
        }

        // cable video / service-distribution-group * / onid
        leaf onid {
          tailf:info "Original Network Identifier";
          type uint16 {
            tailf:info "<1-65535>;;1-65535";
            range "1..65535";
          }
        }

        // cable video / service-distribution-group * / psi-interval
        leaf psi-interval {
          tailf:info "Set Program Specific Information interval";
          type uint16 {
            tailf:info "<40-1000>;;40-1000 msec";
            range "40..1000";
          }
        }

        // cable video / service-distribution-group * / rf-port integrated-cable *
        container rf-port {
          tailf:info "Physical RF port";
          list integrated-cable {
            tailf:info "integrated-cable interface";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key name;
            leaf name {
              type string {
                tailf:info "<slot>/<card>/<port>;;Enter slot/subslot/bay";
              }
            }
          }
        }

        // cable video / service-distribution-group * / serving-area
        leaf serving-area {
          tailf:info "Set serving area id";
          type uint16 {
            tailf:info "<0-65535>;;0-65535";
          }
        }
      }

      // cable video / virtual-carrier-group *
      list virtual-carrier-group {
        tailf:info "Define a group of virtual RF channels";
        tailf:cli-mode-name "config-video-vcg";
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Group name";
          }
        }
        leaf id {
          tailf:info "virtual varrier group identifier";
          tailf:cli-hide-in-submode;
          type uint16 {
            tailf:info "<1-65535>;;1-65535";
            range "1..65535";
          }
        }

        // cable video / virtual-carrier-group * / virtual-edge-input-ip *
        list virtual-edge-input-ip {
          tailf:info "destination IP";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-incomplete-command;
          key address;
          leaf address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP address";
            }
          }
          leaf vrf {
            tailf:info "Video Source VRF";
            tailf:cli-optional-in-sequence;
            type string {
              tailf:info "WORD;;Name of the VRF used for video sources";
            }
          }
          leaf input-port-number {
            tailf:info "Input port number";
            type uint16 {
              tailf:info "<1-65535>;;Input Port Number";
              range "1..65535";
            }
          }
        }

        // cable video / virtual-carrier-group * / low-latency
        leaf low-latency {
          tailf:info "set low latency VCG";
          type empty;
        }

        // cable video / virtual-carrier-group * / encrypt
        leaf encrypt {
          tailf:info "encrypt the VCG";
          type empty;
        }

        // cable video / virtual-carrier-group * / service-type
        leaf service-type {
          tailf:info "VCG service type";
          type enumeration {
            enum broadcast {
              tailf:info "Broadcast";
            }
            enum narrowcast {
              tailf:info "Narrowcast";
            }
          }
        }

        // cable video / virtual-carrier-group * / override-tsid
        leaf override-tsid {
          tailf:info "Override TSID in PAT for all QAMs in this VCG";
          type uint16 {
            tailf:info "<0-65535>;;TSID (0-65535)";
          }
        }

        // cable video / virtual-carrier-group * / rf-channel
        container rf-channel {
          tailf:info "Virtual RF channel";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf channel {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type string {
              tailf:info "RANGE;;start[-end] channel (0-157), e.g. 20-47";
              pattern '[0-9\-]+';
            }
          }
          leaf tsid {
            tailf:info "Transmitting Station Id (TSID)";
            tailf:cli-incomplete-command;
            type string {
              tailf:info "RANGE;;start-end TSID (0-65535), e.g. 28020-28047";
              pattern '[0-9\-]+';
            }
          }
          leaf output-port-number {
            tailf:info "Output port number";
            type string {
              tailf:info "RANGE;;start-end output port (1-65535), e.g. 20-47";
              pattern '[0-9\-]+';
            }
          }
        }
      }

      // cable video / bind-vcg
      container bind-vcg {
        tailf:info "bind virtual RF to physical RF for MPEG video services";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-video-bd";

        // cable video / bind-vcg / vcg *
        list vcg {
          tailf:info "Virtual Carrier Group name";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-diff-dependency "../../service-distribution-group";
          tailf:cli-diff-dependency "../../virtual-carrier-group";
          key "name sdg";
          leaf name {
            type string {
              tailf:info "WORD;;virtual carrier group name";
            }
          }
          leaf sdg {
            tailf:info "Service distribution group";
            tailf:cli-expose-key-name;
            type string {
              tailf:info "WORD;;service-distribution-group name";
            }
          }
        }
      }

      // cable video / announce-event-profile * id
      list announce-event-profile {
        tailf:info "Anounce event template defined to sending events to SRM";
        tailf:cli-mode-name "config-video-evp";
        key name;
        unique id;
        leaf name {
          type string {
            tailf:info "WORD;;Profile name";
          }
        }
        leaf id {
          tailf:info "announce event profile identifier";
          tailf:cli-hide-in-submode;
          type uint16 {
            tailf:info "<1-65535>;;1-65535";
            range "1..65535";
          }
        }

        // cable video / announce-event-profile * / ack-timeout
        leaf ack-timeout {
          tailf:info "Announce Acknowledge timeout. default is 0";
          type uint8 {
            tailf:info "<1-240>;;1-240 seconds";
            range "1..240";
          }
        }

        // cable video / announce-event-profile * / filter
        leaf filter {
          tailf:info "Filtering individual event or all events";
          type enumeration {
            enum 2104 {
              tailf:info "Delivery succeeded (Start of stream reached)";
            }
            enum 4400 {
              tailf:info "Error Reading Content Data - PID Conflict";
            }
            enum 4401 {
              tailf:info "Input Transport Stream Invalid";
            }
            enum 5200 {
              tailf:info "Server Resource Unavailable";
            }
            enum 5401 {
              tailf:info "Downstream Failure";
            }
            enum 5404 {
              tailf:info "Unable to Join";
            }
            enum 5405 {
              tailf:info "Input Failure - Unable to update configuration for existing sessions";
            }
            enum 5406 {
              tailf:info "Failover to Redundant Source";
            }
            enum 5502 {
              tailf:info "Internal Software Error";
            }
            enum 5602 {
              tailf:info "Input Bandwidth Exceed";
            }
            enum all-events {
              tailf:info "Disable all announce events";
            }
          }
        }
      }

      // cable video / logical-edge-device *
      list logical-edge-device {
        tailf:info "Configure GQI or Table-based LED";
        tailf:cli-mode-name "config-video-led";
        tailf:cli-incomplete-command;
        tailf:cli-diff-dependency "../service-distribution-group";
        tailf:cli-diff-dependency "../bind-vcg/vcg";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;LED name";
          }
        }
        leaf id {
          tailf:info "LED identifier";
          tailf:cli-hide-in-submode;
          type uint8 {
            tailf:info "<1-32>;;LED id (1-32)";
            range "1..32";
          }
        }

        // cable video / logical-edge-device * / protocol
        container protocol {
          tailf:info "GQI or Table-based";

          // cable video / logical-edge-device * / protocol gqi
          container gqi {
            tailf:info "GQI protocol";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-video-led-protocol";
            ios:shutdown-before-modify "active" {
              cli:arguments "delete-to-disable";
            }
            presence true;
            uses cable-video-logical-edge-device-protocol-grouping;
          }

          // cable video / logical-edge-device * / protocol table-based
          container table-based {
            tailf:info "Table-based protocol";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-video-led-protocol";
            ios:shutdown-before-modify "active" {
              cli:arguments "delete-to-disable";
            }
            presence true;
            uses cable-video-logical-edge-device-protocol-grouping;
          }
        }
      }

      // cable video / table-based
      container table-based {
        tailf:info "table-based configuration";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-video-tb";

        // cable video / table-based / multicast-label *
        list multicast-label {
          tailf:info "Multicast S,G assignment label";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-incomplete-command;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Multicast label name";
            }
          }
          leaf group {
            tailf:info "Multicast Primary Group address";
            tailf:cli-incomplete-command;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Multicast Primary Group IP address";
            }
          }
          leaf source {
            tailf:info "Multicast Primary Source address (default = 0, ASM)";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Multicast Primary Source IP address";
            }
          }
          leaf source2 {
            tailf:info "Multicast Secondary Source 2 address (default = 0, ASM)";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Multicast Seconday Source 2 IP address";
            }
          }
          leaf source3 {
            tailf:info "Multicast Secondary Source 3 address (default = 0, ASM)";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Multicast Secondary Source 3 IP address";
            }
          }
          leaf source4 {
            tailf:info "Multicast Secondary Source 4 address (default = 0, ASM)";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Multicast Secondary Source 4 IP address";
            }
          }
        }

        // cable video / table-based / vcg *
        list vcg {
          tailf:info "name of virtual carrier group";
          tailf:cli-mode-name "config-video-tb-vcg";
          tailf:cli-diff-dependency "../../logical-edge-device";
          tailf:cli-diff-dependency "../../bind-vcg/vcg";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;virtual-carrier-group name";
            }
          }

          // cable video / table-based / vcg * / rf-channel *
          list rf-channel {
            tailf:info "range of rf-channels";
            tailf:cli-mode-name "config-video-tb-vcg-sess";
            key name;
            leaf name {
              tailf:cli-suppress-range;
              type string {
                tailf:info "RANGE;;start[-end] rf_channel (0-157), e.g. 20-47";
                pattern '[0-9]+(\-[0-9]+)?';
              }
            }

            // cable video / table-based / vcg * / rf-channel * / session *
            list session {
              tailf:info "session name";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              tailf:cli-remove-before-change;
              tailf:cli-incomplete-command;
              key name;
              leaf name {
                type string {
                  tailf:info "WORD;;session name";
                }
              }
              choice session-id-choice {
                leaf input-port {
                  tailf:info "Input Port number";
                  type uint16 {
                    tailf:info "<1-65535>;;1-65535";
                    range "1..65535";
                  }
                }
                leaf multicast-label {
                  tailf:info "Multicast S,G assignment label";
                  type string {
                    tailf:info "WORD;;Multicast label name for this session";
                  }
                }
                leaf group {
                  tailf:info "Multicast Primary Group address";
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;Multicast Primary Group IP address";
                  }
                }
              }
              leaf source {
                tailf:info "Multicast Primary Source address (default = 0, ASM)";
                tailf:cli-optional-in-sequence;
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Multicast Primary Source IP address";
                }
              }
              leaf start-udp-port {
                tailf:info "Starting Unicast UDP Port Number";
                tailf:cli-optional-in-sequence;
                type uint16 {
                  tailf:info "<1-65535>;;Unicast UDP port (1-65535)";
                  range "1..65535";
                }
              }
              leaf num-sessions-per-qam {
                tailf:info "Number of sessions created per qam, default = 1";
                tailf:cli-optional-in-sequence;
                type uint8 {
                  tailf:info "<1-80>;;Max sessions per QAM channel";
                  range "1..80";
                }
              }
              leaf increment-by {
                tailf:info "Increment to apply to UDP Port or Group IP for each session creation";
                tailf:cli-optional-in-sequence;
                type uint8 {
                  tailf:info "<1-65535>;;Session increment (1-65535), default = 1";
                }
              }
              leaf processing-type {
                tailf:info "Data, passthru, or remap";
                type enumeration {
                  enum data {
                     tailf:info "data piping";
                  }
                  enum passthru {
                     tailf:info "passthru from MPTS stream";
                  }
                  enum remap {
                     tailf:info "remap first program from SPTS/MPTS video stream";
                  }
                  enum remux {
                     tailf:info "program from MPTS video stream";
                  }
                }
              }
              leaf input-program-num {
                tailf:info "input program number 1-65535  (default = 1)";
                tailf:cli-optional-in-sequence;
                //when "../processing-type = 'remux'";
                type uint16 {
                  tailf:info "<1-65535>;;1-65535 ";
                  range "1..65535";
                }
              }
              leaf output-program-num {
                tailf:info "output program number 1-65535";
                tailf:cli-optional-in-sequence;
                //when "(../processing-type = 'remux') or (../processing-type = 'remap')";
                type uint16 {
                  tailf:info "<1-65535>;;1-65535 ";
                  range "1..65535";
                }
              }
              leaf start-program {
                tailf:info "start program number 1-65535";
                tailf:cli-optional-in-sequence;
                type uint16 {
                  tailf:info "<1-65535>;;1-65535";
                  range "1..65535";
                }
              }
              leaf bit-rate {
                tailf:info "set bit rate <bps>, default = 0";
                tailf:cli-optional-in-sequence;
                type uint32 {
                  tailf:info "<0-51250000>;;bit rate";
                }
                default 0;
              }
              leaf repeat {
                tailf:info "Repeat the start-program ID for each carrier";
                tailf:cli-optional-in-sequence;
                type empty;
              }
              choice bit-rate-choice {
                leaf cbr {
                  tailf:info "constant bit rate";
                  tailf:cli-optional-in-sequence;
                  type empty;
                }
                leaf vbr {
                  tailf:info "variable bit rate";
                  tailf:cli-optional-in-sequence;
                  type empty;
                }
              }
              leaf master-slave {
                tailf:info "Master/Slave clock recovery";
                tailf:cli-optional-in-sequence;
                type empty;
              }
              leaf pcr-pid {
                tailf:info "PCR PID for master slave clock recovery mode";
                tailf:cli-optional-in-sequence;
                type uint16 {
                  tailf:info "<0-8191>;;(0 - 8191)";
                  range "0..8191";
                }
              }
              leaf psip {
                tailf:info "Program and System Information Protocol stream";
                tailf:cli-optional-in-sequence;
                type empty;
              }
              leaf eas {
                tailf:info "Emergency Alert Signaling stream";
                type empty;
              }
            }
          }
        }
      }

      // cable video / report-stream-error cc-error
      container report-stream-error {
        tailf:info "Enable stream related error reporting";
        container cc-error {
          tailf:info "Enable CC error reporting on the chassis level";
          tailf:cli-compact-syntax;
          tailf:cli-delete-when-empty;
          presence true;

          // cable video / report-stream-error cc-error report-interval
          leaf report-interval {
            tailf:info "Event report interval in minutes, default is 10 mins";
            type uint16 {
              tailf:info "<1-65535>;;1-65535";
              range "1..65535";
            }
            default 10;
          }

          // cable video / report-stream-error cc-error threshold
          leaf threshold {
            tailf:info "Threshold value to report the event, default is 5 errors/review period(5 seconds)";
            type uint16 {
              tailf:info "<1-65535>;;1-65535";
              range "1..65535";
            }
            default 5;
          }

          // cable video / report-stream-error cc-error syslog
          leaf syslog {
            tailf:info "Syslog notification for Error events";
            type enumeration {
              enum disable {
                            tailf:info "Disable syslog notification for Error events";
              }
              enum enable {
                           tailf:info "Enable syslog notification for Error events";
              }
            }
            default disable;
          }
        }
      }
    }

    // cable fiber-node *
    list fiber-node {
      tailf:info "Create Cable fiber-node";
      tailf:cli-mode-name "config-fiber-node";
      ios:cable-fiber-node-modify;
      key fiber-node-id;
      leaf fiber-node-id {
        type uint16 {
          tailf:info "<1-256>;;cable fiber-node id";
          range "1..256";
        }
      }

      // cable fiber-node * / description
      leaf description {
        tailf:info "Fiber node name/description";
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE;;Description of this fiber node that will be truncated to 80 characters.";
        }
      }

      // cable fiber-node * / downstream
      container downstream {
        tailf:info "Set downstream RF channels";

        // cable fiber-node * / downstream Downstream-Cable *
        list Downstream-Cable {
          tailf:info "Downstream-Cable controller";
          tailf:cli-allow-join-with-key;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-diff-delete-after "../sg-channel";
          key name;
          leaf name {
            type string {
              tailf:info "<slot>/<card>/<port>;;Enter slot/subslot/bay";
            }
          }
          leaf rf-channel {
            tailf:info "RF channel";
            type string {
              tailf:info "<grouplist>;;List of port numbers and number ranges";
            }
          }
        }

        // cable fiber-node * / downstream Modular-Cable *
        list Modular-Cable {
          tailf:info "Modular cable";
          tailf:cli-allow-join-with-key;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-diff-delete-after "../sg-channel";
          key name;
          leaf name {
            type string {
              tailf:info "<slot>/<card>/<port>;;Enter slot/subslot/bay";
            }
          }
          leaf rf-channel {
            tailf:info "RF channel";
            type string {
              tailf:info "<grouplist>;;List of port numbers and number ranges";
            }
          }
        }

        // cable fiber-node * / downstream Integrated-Cable *
        list Integrated-Cable {
          tailf:info "Integrated cable";
          tailf:cli-allow-join-with-key;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-diff-delete-after "../sg-channel";
          key name;
          leaf name {
            type string {
              tailf:info "<slot>/<card>/<port>;;Enter slot/subslot/bay";
            }
          }
          leaf rf-channel {
            tailf:info "RF channel";
            type string {
              tailf:info "<grouplist>;;List of port numbers and number ranges";
            }
          }
        }

        // cable fiber-node * / downstream sg-channel *
        list sg-channel {
          tailf:info "Associate/Remove DS-SG channels into this FN";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          key low;
          leaf low {
            tailf:cli-suppress-range;
            type uint8 {
              tailf:info "<0-254>;;Low DS SG channel";
              range "0..254";
            }
          }
          leaf high {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-254>;;High DS SG channel";
              range "0..254";
            }
          }
          choice cable-choice {
            leaf downstream-Cable {
              tailf:info "downstream-Cable controller";
              tailf:cli-incomplete-command;
              type string {
                tailf:info "WORD;;Controller number";
              }
            }
            leaf integrated-Cable {
              tailf:info "integrated-Cable controller";
              tailf:cli-incomplete-command;
              type string {
                tailf:info "WORD;;Controller number";
              }
            }
            leaf downstream-cable {
              tailf:info "downstream-cable controller (XE)";
              tailf:cli-incomplete-command;
              type string {
                tailf:info "WORD;;Controller number";
              }
            }
            leaf integrated-cable {
              tailf:info "integrated-Cable controller (XE)";
              tailf:cli-incomplete-command;
              type string {
                tailf:info "WORD;;Controller number";
              }
            }
          }
          leaf rf-channel {
            tailf:info "Associate/Remove Downstream channels into this FN";
            type uint8 {
              tailf:info "<0-162>;;Low Downstream rf-channel";
              range "0..162";
            }
          }
          leaf rf-channel-high {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-162>;;High Downstream rf-channel";
              range "1..162";
            }
          }
        }
      }

      // cable fiber-node * / upstream
      container upstream {
        tailf:info "Cable upstream channel";

        // cable fiber-node * / upstream Upstream-Cable *
        list Upstream-Cable {
          tailf:info "Upstream cable";
          tailf:cli-allow-join-with-key;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-diff-delete-after "../sg-channel";
          key name;
          leaf name {
            type string {
              tailf:info "<slot>/<card>/<port>;;Enter slot/subslot/bay";
            }
          }
          leaf connector {
            tailf:info "Physical upstream port connector on LC";
            type string {
              tailf:info "<grouplist>;;List of port numbers and number ranges";
            }
          }
        }

        // cable fiber-node * / upstream Cable *
        list Cable {
          tailf:cli-allow-join-with-key;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-diff-delete-after "../sg-channel";
          key name;
          leaf name {
            type string {
              tailf:info "<slot>/<card>/<port>;;Enter slot/subslot/bay";
            }
          }
          leaf connector {
            tailf:info "Physical upstream port connector on LC";
            type string {
              tailf:info "<grouplist>;;List of port numbers and number ranges";
            }
          }
        }

        // cable fiber-node * / upstream sg-channel *
        list sg-channel {
          tailf:info "Associate/Remove US-SG channels into this FN";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          ios:cable-sg-channel-split-range;
          key id;
          leaf id {
            type uint8 {
              tailf:info "<0-254>;;US SG channel";
              range "0..254";
            }
          }
          leaf peer-node-us {
            tailf:info "US sg-channel mapping in another fiber-node";
            tailf:cli-optional-in-sequence;
            tailf:cli-full-command;
            type empty;
          }
          leaf Upstream-Cable {
            tailf:info "Upstream-Cable controller";
            tailf:cli-incomplete-command;
            type string {
              tailf:info "WORD;;Controller number";
            }
          }
          leaf us-channel {
            tailf:info "Associate/Remove Upstream channels into this FN";
            tailf:cli-remove-before-change;
            cli:ned-diff-move-first {
              cli:arguments "when-delete";
            }
            type uint8 {
              tailf:info "<0-15>;;Upstream us-channel";
              range "0..15";
            }
          }
        }
      }

      // cable fiber-node * / service-group
      container service-group {
        tailf:info "Fiber node service group profile association";

        // cable fiber-node * / service-group managed md *
        list managed {
          tailf:info "Fiber node service group managed";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-remove-before-change;
          tailf:cli-diff-delete-after "../profile";
          key md;
          leaf md {
            tailf:info "Fiber node service group managed mac-domain";
            tailf:cli-expose-key-name;
            type uint8 {
              tailf:info "<0-15>;;mac-domain id in service group profile";
              range "0..15";
            }
          }
          leaf Cable {
            tailf:info "CMTS interface";
            tailf:cli-allow-join-with-value;
            type string {
              tailf:info "<slot>/<card>/<port>;;Enter slot/subslot/bay";
            }
          }
        }

        // cable fiber-node * / service-group profile
        leaf profile {
          tailf:info "Fiber node service group profile";
          tailf:cli-remove-before-change;
          ios:config-lock " service-group profile (\\S+) :: cable profile service-group $1";
          cli:ned-diff-move-first {
            cli:arguments "when-delete";
          }
          cli:ned-diff-move-after ">controller " {
            cli:arguments "parent|when-set";
          }
          type string {
            tailf:info "LINE;;Fiber Node(Service Group) Profile name will be truncated to 16 characters.";
          }
        }
      }
    }

    // cable rpd *
    list rpd {
      tailf:info "Create Cable RPD";
      tailf:cli-mode-name "config-rpd";
      tailf:cli-explicit-exit;
      tailf:cli-diff-dependency "../oob";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Unique RPD Name";
        }
      }

      // cable rpd * / description
      uses description-grouping;

      // cable rpd * / identifier
      leaf identifier {
        tailf:info "Identifier";
        tailf:cli-full-command;
        type string {
          tailf:info "H.H.H;;MAC Address of This RPD";
        }
      }

      // cable rpd * / type
      leaf type {
        tailf:info "RPD type";
        type enumeration {
          enum node {
            tailf:info "RPD type is NODE";
          }
          enum shelf {
            tailf:info "RPD type is SHELF";
          }
        }
      }

      // cable rpd * / ssd
      leaf ssd {
        tailf:info "SSD profile set";
        tailf:non-strict-leafref {
          path "../../profile/ssd/id";
        }
        type uint8 {
          tailf:info "<1-64>;;SSD Profile number";
        }
      }

      // cable rpd * / sbfd
      container sbfd {
        tailf:info "SBFD RPD configuration commands";

        // cable rpd * / sbfd enable
        // cable rpd * / no sbfd enable
        leaf enable {
          tailf:info "Enable SBFD";
          tailf:cli-show-no;
          type empty;
        }
      }

      // cable rpd * / rpd-ds *
      list rpd-ds {
        tailf:info "rpd downstream RF port configuration commands";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        tailf:cli-diff-dependency "../type";
        key port;
        leaf port {
          type uint8 {
            tailf:info "<0-1>;;RPD DS port num";
            range "0..1";
          }
        }

        // cable rpd * / rpd-ds * max-carrier
        leaf max-carrier {
          tailf:info "Max Carrier of a RF Port";
          tailf:cli-no-value-on-delete;
          type uint8 {
            tailf:info "<1-158>;;RF Port Max Carrier Value";
            range "1..158";
          }
        }

        // cable rpd * / rpd-ds * base-power
        leaf base-power {
          tailf:info "set port base power level";
          tailf:cli-no-value-on-delete;
          tailf:ned-ignore-compare-config; // device change 34 to 35 but I cant set 35!?
          ios:cable-rpd-diff-add;
          type decimal64 {
            tailf:info "<decimal64>;;Base Channel Power Value in dBmV";
            fraction-digits 1;
          }
        }

        // cable rpd * / rpd-ds * downstream-pilot-tone profile
        container downstream-pilot-tone {
          tailf:info "Downstream pilot tone";
          leaf profile {
            tailf:info "profile";
            tailf:cli-remove-before-change;
            tailf:non-strict-leafref {
              path "../../../../../cable/downstream-pilot-tone/profile/id";
            }
            type uint16 {
              tailf:info "<0-511>;;Profile identifier";
              range "0..511";
            }
          }
        }

        // cable rpd * / rpd-ds * tilt-slope
        leaf tilt-slope {
          tailf:info "tilt slope";
          type decimal64 {
            tailf:info "<0-8>.<0-9>;;tilt slope value in dBmV";
            fraction-digits 1;
            range "0..8";
          }
          default 0;
        }

        // cable rpd * / rpd-ds * tilt-pivot-freq
        leaf tilt-pivot-freq {
          tailf:info "tilt pivot frequency";
          type uint32 {
            tailf:info "<0-1218000000>;;tilt pivot frequency";
            range "0..1218000000";
          }
          default 0;
        }

        // cable rpd * / rpd-ds * rf-channel *
        list rf-channel {
          tailf:info "Configure RF Channel";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            tailf:cli-suppress-range;
            type string {
              tailf:info "<grouplist>;;List of rf-channels and ranges of rf-channels";
            }
          }
          leaf power-adjust {
            tailf:info "Channel Power Adjust";
            type string {
              tailf:info "WORD;;Power Adjust Range:  -3.0 -  1.0 dBmV";
            }
          }
          leaf mute {
            tailf:info "RF channel mute";
            type empty;
          }
        }

        // cable rpd * / rpd-ds * mute
        leaf mute {
          tailf:info "mute";
          type empty;
        }

        // cable rpd * / rpd-ds * shutdown
        leaf shutdown {
          tailf:info "shutdown";
          type empty;
        }
      }

      // cable rpd * / core-interface
      container core-interface {
        tailf:info "Core-interface configuration";
        tailf:cli-diff-set-after "../../../controller";

        // cable rpd * / core-interface Te*
        list Te {
          tailf:info "Ten Gigabit Ethernet";
          tailf:cli-allow-join-with-key {
            tailf:cli-display-joined;
          }
          tailf:cli-mode-name "config-rpd-core";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;TenGigabitEthernet interface number";
              pattern '[0-9]+.*';
            }
          }
          uses cable-rpd-core-if-grouping;
        }

        // cable rpd * / core-interface Hu*
        list Hu {
          tailf:info "Hundred Gigabit Ethernet";
          tailf:cli-allow-join-with-key {
            tailf:cli-display-joined;
          }
          tailf:cli-mode-name "config-rpd-core";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;HundredGigabitEthernet interface number";
              pattern '[0-9]+.*';
            }
          }
          uses cable-rpd-core-if-grouping;
        }
      }

      // cable rpd * / r-dti
      leaf r-dti {
        tailf:info "R-DTI set";
        type uint8 {
          tailf:info "<1-64>;;R-DTI configuration ID";
          range "1..64";
        }
      }

      // cable rpd * / rpd-event profile
      container rpd-event {
        tailf:info "rpd-event profile set";
        leaf profile {
          tailf:info "rpd-event profile set";
          tailf:cli-show-with-default;
          type uint8 {
            tailf:info "<0-63>;;rpd-event profile ID";
            range "0..63";
          }
          tailf:ned-default-handling report-all;
          default 0;
        }
      }

      // cable rpd * / rpd-55d1-us-event
      container rpd-55d1-us-event {
        tailf:info "rpd-55d1-us-event profile set";
        leaf profile {
          tailf:info "rpd-55d1-us-event profile set";
          type uint8 {
            tailf:info "<0-63>;;rpd-55d1-us-event profile ID";
            range "0..63";
          }
        }
      }

      // cable rpd * / ptp profile
      container ptp {
        tailf:info "PTP clock set";
        leaf profile {
          tailf:info "PTP clock profile set";
          type uint8 {
            tailf:info "<0-63>;;PTP Clock Profile ID";
            range "0..63";
          }
        }
      }
    }

    // cable ipv6
    container ipv6 {
      tailf:info "Configure CMTS-wide IPv6 commands";

      // cable ipv6 pd-route
      container pd-route {
        tailf:info "Configure PD enclosing route";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf prefix {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type ios:ipv6-prefix {
            tailf:info "X:X:X:X::X/<0-128>;;IPv6 prefix";
          }
        }
        leaf Bundle {
          tailf:info "Virtual Bundle";
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          type uint8 {
            tailf:info "<1-255>;;Bundle interface number";
            range "1..255";
          }
        }
      }

      // cable ipv6 source-verify
      container source-verify {
        tailf:info "IPv6 Source verify";
        container leasequery-filter {
          tailf:info "Source verify Lease query filter";
          container downstream {
            tailf:info "Source verify IPv6 Lease query filter for downstream pkts";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf threshold {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint8 {
                tailf:info "<0-255>;;Number of ipv6 lease queries for unknown sid";
                range "0..255";
              }
            }
            leaf interval {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<1-10>;;size of time window in seconds";
                range "1..10";
              }
            }
          }
        }
      }
    }

    // cable reconcilation
    container reconcilation {
      tailf:info "on-schedule reconcilation";

      // cable reconcilation enable
      leaf enable {
        tailf:info "Enable on-schedule reconcilation";
        type empty;
      }

      // cable reconcilation time
      leaf time {
        tailf:info "on-schedule reconcilation time";
        type uint8 {
          tailf:info "<0-23>;;on-schedule reconcilation time at xx o'clock";
          range "0..23";
        }
      }
    }
  }


  /// ========================================================================
  /// l2tp
  /// ========================================================================

  container l2tp {
    tailf:info "Layer 2 Tunneling Protocol (L2TP) parameters";

    // l2tp congestion-control
    leaf congestion-control {
      tailf:info "Enable L2TPv2/v3 congestion control for control channel packets";
      type empty;
    }
  }

  /// ========================================================================
  /// l2tp-class
  /// ========================================================================

  // l2tp-class *
  list l2tp-class {
    tailf:info "l2tp-class configuration";
    tailf:cli-mode-name "config-l2tp-class";
    key l2tp-class-name;
    leaf l2tp-class-name {
      type string {
        tailf:info "WORD;;l2tp-class name";
      }
    }

    // l2tp-class * / authentication
    leaf authentication {
      tailf:info "Authenticate the L2TP control connection";
      type empty;
    }

    // l2tp-class * / hello
    leaf hello {
      tailf:info "Set HELLO message interval";
      type uint16 {
        tailf:info "<0-1000>;;Seconds, default is 60";
        range "0..1000";
      }
      default 60;
    }

    // l2tp-class * / password
    container password {
      tailf:info "Password for control connection authentication, AVP hiding";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      uses password-grouping {
        refine "secret" {
          cli:secret " password <SECRET>";
        }
      }
    }

    // l2tp-class * / retransmit
    container retransmit {
      tailf:info "Control message retransmission parameters";

      // l2tp-class * / retransmit retries
      leaf retries {
        tailf:info "Number of retries before tearing down a control connection";
        type uint16 {
          tailf:info "<5-1000>;;Maximum retransmissions";
          range "5..1000";
        }
        default 15;
      }

      // l2tp-class * / retransmit timeout
      container timeout {
        tailf:info "Control packet retransmission timeout parameters";
        choice timeout-choice {
          leaf max {
            tailf:info "Maximum timeout";
            type uint8 {
              tailf:info "<1-8>;;Seconds";
              range "1..8";
            }
            default 8;
          }
          leaf min {
            tailf:info "Minimum timeout";
            type uint8 {
              tailf:info "<1-8>;;Seconds";
              range "1..8";
            }
            default 1;
          }
        }
      }

      // l2tp-class * / initial retransmit retries
      container initial {
        tailf:info "SCCRQ message retries/timeout settings";
        leaf retries {
          tailf:info "Number of initial retries before halting attempts";
          type uint16 {
            tailf:info "<1-1000>;;Maximum SCCRQ retransmissions";
            range "1..1000";
          }
          default 2;
        }
      }
    }

    // l2tp-class * / digest
    container digest {
      tailf:info "Message Digest Authentication for the L2TP control connection";

      // l2tp-class * / digest secret
      container secret {
        tailf:info "Message Digest shared secret";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        uses password-grouping {
          refine "secret" {
            cli:secret " digest secret <SECRET>";
          }
        }
      }
    }

    // l2tp-class * / timeout setup
    container timeout {
      tailf:info "Control connection timeout parameters";
      leaf setup {
        tailf:info "Time permitted to set up a control connection";
        type uint16 {
          tailf:info "<60-6000>;;Seconds";
          range "60..6000";
        }
        default 300;
      }
    }

    // l2tp-class * / cookie size
    container cookie {
      tailf:info "Local cookie options";
      leaf size {
        tailf:info "local cookie size";
        type enumeration {
          enum 4 {
            tailf:info "4 byte receive cookie";
          }
          enum 8 {
            tailf:info "8 byte receive cookie";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// packetcable
  /// ========================================================================

  container packetcable {
    tailf:info "Global packetcable configuration";
    tailf:cli-incomplete-command;
    tailf:cli-incomplete-no;

    // packetcable element-id
    leaf element-id {
      tailf:info "configure element id for event message";
      type uint32 {
        tailf:info "<0-99999>;;element id of cmts in PacketCable Event Message";
        range "0..99999";
      }
    }

    // packetcable timer
    container timer {
      tailf:info "change default timer values";

      // packetcable timer T0
      leaf T0 {
        tailf:info "T0 timer";
        type uint32 {
          tailf:info "<1-1000000000>;;T0 timer value (msec)";
          range "1..1000000000";
        }
      }

      // packetcable timer T1
      leaf T1 {
        tailf:info "T1 timer";
        type uint32 {
          tailf:info "<1-1000000000>;;T1 timer value (msec)";
          range "1..1000000000";
        }
      }
    }

    // packetcable authorize vanilla-docsis-mta
    container authorize {
      tailf:info "authorize non-packetcable settings";
      leaf vanilla-docsis-mta {
        tailf:info "vanilla docsis mta";
        type empty;
      }
    }

    // packetcable multimedia
    leaf multimedia {
      tailf:info "Enable Packetcable Multimedia functionality";
      type empty;
    }

    // packetcable gate
    container gate {
      tailf:info "configure gate settings";

      // packetcable gate send-subscriberID
      leaf send-subscriberID {
        tailf:info "Send Subscriber-ID in Gate-Open/Gate-Close";
        type empty;
      }
    }
  }

  // packetcable
  container packetcable-enable {
    tailf:cli-drop-node-name;
    leaf packetcable {
      tailf:info "Global packetcable configuration";
      type empty;
    }
  }


  /// ========================================================================
  /// depi-class
  /// ========================================================================

  // depi-class *
  list depi-class {
    tailf:info "depi-class configuration";
    tailf:cli-mode-name "config-depi-class";
    key depi-class-name;
    leaf depi-class-name {
      type string {
        tailf:info "WORD;;depi-class name";
      }
    }

    // depi-class * / mode
    container mode {
      tailf:info "Set DEPI Mode";
      leaf mpt {
        tailf:info "MPT Mode";
        type empty;
      }
    }

    // depi-class * / l2tp-class
    leaf l2tp-class {
      tailf:info "Set l2tp-class";
      tailf:non-strict-leafref {
        path "../../l2tp-class/l2tp-class-name";
      }
      type string {
        tailf:info "WORD;;depi-l2tp-class name";
      }
    }
  }


  /// ========================================================================
  /// depi-tunnel
  /// ========================================================================

  // depi-tunnel *
  list depi-tunnel {
    tailf:info "depi-tunnel configuration";
    tailf:cli-mode-name "config-depi-tunnel";
    key depi-tunnel-name;
    leaf depi-tunnel-name {
      type string {
        tailf:info "WORD;depi-tunnel name";
      }
    }

    // depi-tunnel * / dest-ip
    leaf dest-ip {
      tailf:info "Set Destination IP address of Tunnel";
      type inet:ipv4-address {
        tailf:info "A.B.C.D;;Peer IP address";
      }
    }

    // depi-tunnel * / l2tp-class
    leaf l2tp-class {
      tailf:info "Set l2tp-class to associate depi tunnel with";
      type string {
        tailf:info "WORD;;L2TP class with which this depi-tunnel is associated";
      }
    }

    // depi-tunnel * / depi-class
    leaf depi-class {
      tailf:info "Set depi-class to associate depi tunnel with";
      type string {
        tailf:info "WORD;;depi-class with which this depi-tunnel is associated";
      }
    }

    // depi-tunnel * / protect-tunnel
    leaf protect-tunnel {
      tailf:info "Specify protect depi-tunnel";
      type string {
        tailf:info "WORD;;protect depi-tunnel with which this depi-tunnel is associated";
      }
    }
  }


  /// ========================================================================
  /// chat-script
  /// ========================================================================

  list chat-script {
    tailf:info "Define a modem chat script";
    tailf:cli-suppress-mode;
    tailf:cli-delete-when-empty;
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;Name of chat script";
      }
    }
    leaf line {
      tailf:cli-drop-node-name;
      tailf:cli-full-command;
      tailf:cli-no-value-on-delete;
      type string {
        tailf:info "LINE;;Quoted chat script in form EXPECT SEND EXPECT SEND ...";
      }
    }
  }


  /// ========================================================================
  /// autonomic
  /// ========================================================================

  container autonomic {
    tailf:info "Autonomic Networking";
    tailf:cli-incomplete-command;
    tailf:cli-incomplete-no;

    // autonomic registrar
    container registrar {
      tailf:info "Registrar";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-registrar";

      // autonomic registrar / domain-id
      leaf domain-id {
        tailf:info "Autonomic Domain ID";
        type string {
          tailf:info "WORD;;Autonomic Domain ID in string format";
        }
      }

      // autonomic registrar / CA
      container CA {
        tailf:info "Create a Certificate Authority";
        choice CA-choice {

          // autonomic registrar / CA local
          leaf local {
            tailf:info "Create local Certificate Authority";
            type empty;
          }

          // autonomic registrar / CA url
          leaf url {
            tailf:info "url to enroll";
            type string {
              tailf:info "WORD;;HTTP URL";
            }
          }
        }
      }

      // autonomic registrar / whitelist
      leaf whitelist {
        tailf:info "File with list of whitelisted devices";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;File with list of whitelisted devices";
        }
      }

      // autonomic registrar / no shut
      leaf shut {
        tailf:info "Shut the Autonomic Registrar";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }
    }
  }


  // autonomic
  container autonomic-enable {
    tailf:cli-drop-node-name;
    leaf autonomic {
      tailf:info "Autonomic Networking";
      tailf:cli-full-command;
      type empty;
    }
  }


  /// ========================================================================
  /// controller
  /// ========================================================================

  container controller {
    tailf:info "Configure controller";

    // controller E1 *
    // controller T1 *
    // controller T3 *
    list controller-tx-ex-list {
      tailf:cli-mode-name "config-controller";
      tailf:cli-drop-node-name;
      key "name number";
      leaf name {
        type enumeration {
          tailf:info "Controller name";
          enum T1 {
            tailf:info "T1 controller";
          }
          enum E1 {
            tailf:info "E1 controller";
          }
          enum T3 {
            tailf:info "T3 controller";
          }
        }
      }
      leaf number {
        type string {
          tailf:info "WORD;;slot/subslot or port[/:]port";
        }
      }

      // controller * / secondary-admin-state
      leaf secondary-admin-state {
        type enumeration {
          enum auto-in-service;
          enum maintenance;
          enum normal;
        }
      }

      // controller * / ais-shut
      leaf ais-shut {
        tailf:info "Send LAIS when shutdown";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default false;
      }

      // controller * / attach profile
      container attach {
        tailf:info "Attach a profile to a port";
        leaf profile {
          tailf:info "Alarm profile name";
          tailf:non-strict-leafref {
            path "/ios:alarm-profile/entry-list/name";
          }
          type string {
            tailf:info "WORD;;Alarm profile name";
          }
        }
      }

      // controller * / forward-alarm
      container forward-alarm {
        tailf:info "Forward physical layer alarms (AIS,RAI) to other T1 port";
        leaf ais {
          tailf:info "Alarm Indication Signal";
          type empty;
        }
        leaf rai {
          tailf:info "Remote Alarm Indication";
          type empty;
        }
      }

      // controller * / threshold
      container threshold {
        tailf:info "Set BER threshold values";

        // controller * / threshold sd-ber
        leaf sd-ber {
          tailf:info "set Signal Degrade BER threshold";
          type uint8 {
            tailf:info "<5-9>;;Bit error rate (10 to the minus n)";
            range "5..9";
          }
        }

        // controller * / threshold sf-ber
        leaf sf-ber {
          tailf:info "set Signal Fail BER threshold";
          type uint8 {
            tailf:info "<3-5>;;Bit error rate (10 to the minus n)";
            range "3..5";
          }
        }
      }

      // controller * / framing
      leaf framing {
        tailf:info "Specify the type of Framing on a DS1 link";
        tailf:cli-full-command;
        type string;
      }

      // controller * / service-type
      leaf service-type {
        type enumeration {
          enum data;
          enum ccs-voice;
          enum cas-voice;
        }
      }

      // controller * / fdl
      leaf fdl {
        tailf:info "Specify the FDL standard for a DS1 data link";
        tailf:cli-full-command;
        type enumeration {
          enum ansi {
            tailf:info "ANSI T1.403";
          }
          enum att {
            tailf:info "AT&T TR54016";
          }
          enum both {
            tailf:info "ANSI T1.403 and AT&T TR54016";
          }
        }
      }

      // controller * / cem-group *
      list cem-group {
        tailf:info "Specify the timeslots to cem-group mapping";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-remove-before-change;
        tailf:cli-diff-dependency "../framing";
        key id;
        leaf id {
          type uint8 {
            tailf:info "<0-30>;;Channel number";
            range "0..30";
          }
        }

        // controller * / cem-group * unframed
        choice type-choice {
          leaf framed {
            tailf:info "Framed SAToP in the cem group";
            tailf:cli-full-command;
            type empty;
          }
          leaf unframed {
            tailf:info "Unframed in the cem group";
            tailf:cli-full-command;
            type empty;
          }
          // controller * / cem-group * cep
          leaf cep {
            tailf:info "cep configuration";
            tailf:cli-full-command;
            type empty;
          }
        }

        // controller * / cem-group * timeslots *
        leaf-list timeslots {
          tailf:info "List of timeslots in the cem group";
          tailf:cli-range-list-syntax;
          tailf:cli-remove-before-change;
          type uint8 {
            tailf:info "<1-31>;List of timeslots which comprise the channel";
            range "1..31";
          }
        }
      }

      // controller * / clock
      container clock {
        tailf:info "Specify the clock source for a DS1 link";

        // controller * / clock source
        container source {
          tailf:info "Specify the clock source for a DS1 link";
          choice source-choice {
            container line {
              tailf:info "Recovered Clock";
              tailf:cli-delete-when-empty;
              presence true;
              leaf line-mode {
                tailf:cli-drop-node-name;
                tailf:cli-full-command;
                type enumeration {
                  enum primary {
                    tailf:info "Primary Source";
                  }
                  enum secondary {
                  }
                  enum bits {
                    tailf:info "Bits Clocking";
                  }
                  enum independent {
                    tailf:info "Independent Source";
                  }
                }
              }
            }
            leaf internal {
              tailf:info "Internal Clock";
              tailf:cli-full-command;
              type empty;
            }
            leaf loop-timed {
              tailf:cli-full-command;
              type empty;
            }
            leaf free-running {
              tailf:info "Free Running Clock";
              tailf:cli-full-command;
              type empty;
            }
          }
        }
      }

      // controller * / linecode
      leaf linecode {
        tailf:info "Specify the line encoding method for a DS1 link";
        tailf:cli-full-command;
        type enumeration {
          enum ami {
            tailf:info "AMI encoding";
          }
          enum b8zs {
            tailf:info "B8ZS encoding";
          }
          enum hdb3 { // E1 only (default)
          }
        }
      }

      // controller * / loopback
      container loopback {
        tailf:info "Put the entire T1 line into loopback";
        choice loopback-choice {
          leaf diag {
            type empty;
          }
          container local {
            tailf:info "Local loopback";
            tailf:cli-reset-container;
            tailf:cli-delete-when-empty;
            presence true;
            leaf payload {
              type empty;
            }
          }
        }
      }

      // controller * / cablelength
      container cablelength {
        tailf:info "Specify the cable length for a DS1 link";
        choice cablelength-choice {
          leaf value {
            tailf:cli-drop-node-name;
            tailf:cli-full-command;
            type uint32;
          }
          leaf long {
            tailf:info "long cable";
            when "../../name != 'T3'" {
              tailf:dependency "../../name";
            }
            type string;
          }
          leaf short {
            when "../../name != 'T3'" {
              tailf:dependency "../../name";
            }
            tailf:info "short cable";
            type string;
          }
          container short-novalue {
            tailf:cli-drop-node-name;
            when "../../name = 'T3'" {
              tailf:dependency "../../name";
            }
            leaf short {
              tailf:info "Short";
              tailf:cli-full-command;
              tailf:cli-full-no;
              type empty;
            }
          }
          container long-novalue {
            tailf:cli-drop-node-name;
            when "../../name = 'T3'" {
              tailf:dependency "../../name";
            }
            leaf long {
              tailf:info "Long";
              tailf:cli-full-command;
              tailf:cli-full-no;
              type empty;
            }
          }
        }
      }

      // controller * / pri-group
      container pri-group {
        tailf:info "Configure the specified timeslots for PRI";
        list timeslots {
          tailf:info "List of timeslots in the pri-group";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-range-list-syntax;
          key id;
          leaf id {
            type uint8;
          }
          leaf nfas_d {
            tailf:info "Specify the operation of the D-channel timeslot.";
            type enumeration {
              enum primary {}
              enum backup {}
              enum none {}
            }
          }
          leaf nfas_int {
            when "../nfas_d" {
              tailf:dependency "../nfas_d";
            }
            tailf:info "Specify the provisioned NFAS interface value.";
            type uint32 {
              tailf:info "<0-48>;;The NFAS interface value.";
            }
          }
          leaf nfas_group {
            when "../nfas_int" {
              tailf:dependency "../nfas_int";
            }
            tailf:info "Specify the NFAS group.";
            type uint8 {
              range "1..24";
            }
          }
          leaf service {
            tailf:info "Specify the service type";
            type enumeration {
              enum mgcp {
                tailf:info "Media Gateway Control Protocol service";
              }
            }
          }
        }
      }

      // controller * / channel-group *
      list channel-group {
        tailf:info "Specify the timeslots to channel-group mapping for an interface";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key number;
        leaf number {
          type uint8 {
            range "0..30";
          }
        }

        // controller * / channel-group * unframed
        leaf unframed {
          tailf:info "Unframed channel-group";
          type empty;
        }

        // controller * / channel-group * timeslots *
        leaf-list timeslots {
          tailf:info "List of timeslots in the channel group";
          tailf:cli-replace-all;
          tailf:cli-range-list-syntax;
          type uint16 {
            tailf:info "<1-31>;;List of timeslots which comprise the channel";
          }
        }
      }

      // controller * / description
      leaf description {
        tailf:info "Controller specific description";
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-no-value-on-delete;
        type string {
          tailf:info "LINE;;Up to 240 characters describing this interface";
        }
      }

      // controller * / t1 *
      list t1 {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          type uint8;
        }
        leaf channel-group {
          type uint8 {
            range "0..23";
          }
        }
        leaf-list timeslots {
          tailf:cli-range-list-syntax;
          type uint8 {
            range "1..24";
          }
        }
        leaf speed {
          type enumeration {
            enum "56" {}
            enum "64" {}
          }
        }
        container clock {
          leaf source {
            type enumeration {
              enum line {
                tailf:info "Recovered Clock";
              }
              enum internal {
                tailf:info "Internal Clock";
              }
            }
          }
        }
      }

      // controller * / ima-group
      container ima-group {
        tailf:info "Configure IMA group";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf group-number {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<0-41>;;IMA group ID";
            range "0..41";
          }
        }
        leaf scrambling-payload {
          type empty;
        }
      }

      // controller * / shutdown
      leaf shutdown {
        tailf:info "Shut down a DS1 link (send Blue Alarm)";
        type empty;
      }

      // controller * / no snmp trap link-status
      container snmp {
        tailf:info "Modify SNMP controller parameters";
        container trap {
          tailf:info "Allow a specific SNMP trap";
          leaf link-status {
            tailf:info "Allow SNMP LINKUP and LINKDOWN traps";
            tailf:cli-boolean-no;
            type boolean;
            default true;
          }
        }
      }
    }

    // controller BITS input applique
    container BITS {
      tailf:info "Configure BITS Interface";
      container input {
        tailf:info "Configure BITS input";
        container applique {
          tailf:info "Link type E1 or T1";
          container E1 {
            tailf:info "E1;;Link type E1";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            choice E1-choice {
              case clock-case {
                leaf clock-if {
                  tailf:cli-drop-node-name;
                  type enumeration {
                    enum "2048KHz" {
                      tailf:info "2048 KHz clock interface";
                    }
                  }
                }
              }
              case framing-case {
                leaf framing {
                  tailf:info "BITS framing options for E1";
                  tailf:cli-incomplete-command;
                  type enumeration {
                    enum fas_crc4 {
                      tailf:info "FASCRC4";
                    }
                    enum fas_nocrc {
                      tailf:info "FAS";
                    }
                    enum mfas_crc4 {
                      tailf:info "MFASCRC4";
                    }
                    enum mfas_nocrc {
                      tailf:info "MFAS";
                    }
                  }
                }
                leaf linecode {
                  tailf:info "BITS linecode options for E1";
                  type enumeration {
                    enum ami {
                      tailf:info "AMI encoding";
                    }
                    enum hdb3 {
                      tailf:info "HDB3 encoding";
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // controller Cellular *
    list Cellular {
      tailf:info "3G/4G WWAN Cellular controller";
      tailf:cli-mode-name "config-controller";
      key id;
      leaf id {
        type string {
          tailf:info "WORD;;Controller slot/subslot or port number";
          pattern '[0-9]+.*';
        }
      }

      // controller Cellular * / description
      leaf description {
        tailf:info "Controller specific description";
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE;;Up to 240 characters describing this interface";
          length "1..240";
        }
      }

      // controller Cellular * / lte gps nmea
      container lte {
        tailf:info "LTE type carrier";

        // controller Cellular * / lte gps
        container gps {
          tailf:info "GPS configuration";

          // controller Cellular * / lte gps enable
          leaf enable {
            tailf:info "enable GPS feature";
            type empty;
          }

          // controller Cellular * / lte gps mode
          container mode {
            tailf:info "select GPS mode";
            leaf standalone {
              tailf:info "select Standalone mode";
              type empty;
            }
          }

          // controller Cellular * / lte gps nmea
          container nmea {
            tailf:info "enable NMEA data";
            choice nmea-choice {
              container ip {
                tailf:info "NMEA over IP interface";
                presence true;
              }
              container serial {
                tailf:info "NMEA over serial interface";
                presence true;
                leaf streaming {
                  tailf:cli-drop-node-name;
                  type enumeration {
                    enum "38400" {
                      tailf:info "38400 bps, 8 databits, No parity, 1 stopbit";
                    }
                    enum "4800" {
                      tailf:info "4800 bps, 8 databits, No parity, 1 stopbit (default)";
                    }
                    enum line-config {
                      tailf:info "Use tty line configuration";
                    }
                  }
                }
              }
            }
          }
        }

        // controller Cellular * / lte modem
        container modem {
          tailf:info "Modem logging configuration";
          container link-recovery {
            tailf:info "Cellular Link Recovery";
            leaf enable {
              type empty;
            }
            container rssi {
              tailf:info "RSSI Onset Threshold value";
              leaf onset-threshold {
                tailf:info "RSSI Onset Threshold";
                type int8 {
                  tailf:info "<-125 - -90>;;RSSI value in -dbm";
                  range "-125..-90";
                }
              }
            }
            leaf monitor-timer {
              tailf:info "Monitor Timer";
              type uint8 {
                tailf:info "<20 - 60>;;Monitor Timer value in seconds";
                range "20..60";
              }
            }
            leaf wait-timer {
              tailf:info "Wait Timer";
              type uint8 {
                tailf:info "<5 - 60>;;Wait Timer value in seconds";
                range "5..60";
              }
            }
            leaf debounce-count {
              tailf:info "Debounce Count";
              type uint8 {
                tailf:info "<6 - 20>;;Debounce Count value";
                range "6..20";
              }
            }
          }
        }
      }
    }

    // controller VDSL *
    list VDSL {
      tailf:info "VDSL2 controller";
      tailf:cli-mode-name "config-controller";
      key id;
      leaf id {
        type string {
          tailf:info "WORD;;Controller slot/subslot or port number";
          pattern '[0-9]+.*';
        }
      }

      // controller VDSL * / description
      leaf description {
        tailf:info "Controller specific description";
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE;;Up to 80 characters describing this interface";
          length "1..80";
        }
      }

      // controller VDSL * / shutdown
      leaf shutdown {
        tailf:info "Shut down link";
        type empty;
      }

      // controller VDSL * / firmware filename
      container firmware {
        tailf:info "Active firmware file name";
        leaf filename {
          tailf:info "file name to read firmware";
          type string {
            tailf:info "WORD;;Download fw file name";
          }
        }
      }
    }

    // controller Upstream-Cable *
    list Upstream-Cable {
      tailf:info "Upstream-Cable controller";
      tailf:cli-mode-name "config-controller";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Controller slot/subslot/unit";
        }
      }

      // controller Upstream-Cable * / description
      uses description-grouping;

      // controller Upstream-Cable * / cable spectrum-group
      container cable {
        tailf:info "Upstream Controller Level cable feature configuration";
        leaf spectrum-group {
          tailf:info "Set spectrum group";
          type uint8 {
            tailf:info "<1-40>;;Spectrum group number";
          }
        }
      }

      // controller Upstream-Cable * / us-channel *
      uses us-channel-grouping;
    }

    // controller Downstream-Cable *
    list Downstream-Cable {
      tailf:info "Downstream-Cable controller";
      tailf:cli-mode-name "config-controller";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Controller slot/subslot/unit";
        }
      }

      // controller Downstream-Cable * / description
      uses description-grouping;
    }

    // controller Modular-Cable *
    list Modular-Cable {
      tailf:info "Modular-Cable controller";
      tailf:cli-mode-name "config-controller";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Controller slot/subslot/unit";
        }
      }

      // controller Modular-Cable * / description
      uses description-grouping;

      // controller Modular-Cable * / ip-address
      leaf ip-address {
        tailf:info "Configure IP address";
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;IP address of Blaze";
        }
      }

      // controller Modular-Cable * / modular-host subslot
      container modular-host {
        tailf:info "Configure modular host";
        leaf subslot {
          tailf:info "Configure slot";
          tailf:cli-remove-before-change;
          type string {
            tailf:info "WORD;;slot/subslot";
          }
        }
      }

      // controller Modular-Cable * / rf-channel *
      uses controller-modular-cable-rf-channel-grouping;
    }

    // controller Integrated-Cable *
    list Integrated-Cable {
      tailf:info "Integrated-Cable controller";
      tailf:cli-mode-name "config-controller";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Controller slot/subslot/unit";
        }
      }

      // controller Integrated-Cable * / description
      uses description-grouping;

      // controller Integrated-Cable * / max-ofdm-spectrum
      leaf max-ofdm-spectrum {
        tailf:info "Maximum spectrum used by all OFDM channels on port";
        type uint32 {
          tailf:info "<24000000-1170000000>;;Maximum OFDM spectrum value (Hz), in 1 MHz increments";
          range "24000000..1170000000";
        }
      }

      // controller Integrated-Cable * / max-carrier
      leaf max-carrier {
        tailf:info "Max Carrier of a RF Port";
        type uint8 {
          tailf:info "<1-128>;;RF Port Max Carrier Value";
          range "1..128";
        }
      }

      // controller Integrated-Cable * / base-channel-power
      leaf base-channel-power {
        tailf:info "set base channel power level";
        type uint8 {
          tailf:info "<28-39>;;Base Channel Power Value in dBmV";
        }
      }

      // controller Integrated-Cable * / power-tilt linear
      container power-tilt {
        tailf:info "Apply power tilt adjust to controller port";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf mode {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type enumeration {
            enum cable-loss-approx {
              tailf:info "Apply CCAP power tilt adjust";
            }
            enum linear {
              tailf:info "Apply linear power tilt adjust";
            }
          }
        }
        leaf loss {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type string {
            tailf:info "WORD;;Tilt correction at max-frequency, valid range: 0.0 to +8.0 dB";
          }
        }
        leaf max-frequency {
          tailf:info "Max DS frequency of the power tilt";
          type uint32 {
            tailf:info "<51000000-1218000000>;;Frequency in Hz";
            range "51000000..1218000000";
          }
        }
      }

      // controller Integrated-Cable * / shutdown
      leaf shutdown {
        tailf:info "Shutdown RF Port";
        type empty;
      }

      // controller Integrated-Cable * / freq-profile
      leaf freq-profile {
        tailf:info "Frequency Profile of a RF Port";
        type uint8 {
          tailf:info "<0-15>;;RF Port Frequency Profile Number";
          range "0..15";
        }
      }

      // controller Integrated-Cable * / rf-chan
      container rf-chan {
        tailf:info "Configure RF Channel";
        cli:ned-diff-move-first {
          cli:arguments "when-delete";
        }

        // controller Integrated-Cable * / rf-chan *
        list rf-chan {
          tailf:cli-drop-node-name;
          tailf:cli-mode-name "config-rf-chan";
          tailf:cli-diff-dependency "/ios:cable/downstream/ofdm-chan-profile";
          ios:shutdown-before-modify "shutdown" {
            cli:arguments "exit-and-enter";
          }
          key start;
          leaf start {
            type uint8 {
              tailf:info "<0-162>;;Starting Qam ID";
            }
          }
          uses controller-integrated-cable-rf-chan-grouping;
        }

        // controller Integrated-Cable * / rf-chan * *
        list rf-chan-range {
          tailf:cli-drop-node-name;
          tailf:cli-mode-name "config-rf-chan";
          tailf:cli-diff-dependency "/ios:cable/downstream/ofdm-chan-profile";
          ios:shutdown-before-modify "shutdown" {
            cli:arguments "exit-and-enter";
          }
          key "start end";
          leaf start {
            type uint8 {
              tailf:info "<0-126>;;Starting Qam ID";
            }
          }
          leaf end {
            type uint8 {
              tailf:info "<0-126>;;Ending Qam ID";
            }
          }
          uses controller-integrated-cable-rf-chan-grouping;
        }
      }
    }

    // controller upstream-oob *
    list upstream-oob {
      tailf:info "Cable OOB upstream controller commands";
      tailf:cli-mode-name "config-profile";
      key "name id";
      leaf name {
        type string {
          tailf:info "55d1-profile;;Cable OOB upstream profile config commands";
        }
      }
      leaf id {
        type uint32 {
          tailf:info "<1-4294967295>;;OOB upstream profile index";
        }
      }

      // controller upstream-oob * / us-channel *
      list us-channel {
        tailf:info "OOB upstream channel configuration";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key id;
        leaf id {
          type uint8 {
            tailf:info "<0-255>;;OOB upstream channel index";
          }
        }

        // controller upstream-oob * / us-channel * shutdown
        leaf shutdown {
          tailf:info "OOB upstream shutdown";
          tailf:cli-show-no;
          type empty;
        }

        // controller upstream-oob * / us-channel * frequency
        leaf frequency {
          tailf:info "OOB upstream frequency";
          type uint32 {
            tailf:info "<5216000-64736000>;;OOB upstream channel frequency value";
            range "5216000..64736000";
          }
        }

        // controller upstream-oob * / us-channel * varpd-portid
        container varpd {
          tailf:cli-drop-node-name;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf varpd-portid {
            tailf:info "OOB upstream varpd-portid";
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-5>;;OOB upstream channel varpd portid value";
              range "0..5";
            }
          }
          leaf varpd-demodid {
            tailf:info "OOB upstream varpd-demodid";
            type uint8 {
              tailf:info "<0-2>;;OOB upstream channel varpd demodid value";
              range "0..2";
            }
          }
        }
      }
    }

    // controller upstream-oob * id *
    container upstream-oob-id {
      tailf:cli-drop-node-name;
      list upstream-oob {
        tailf:info "Cable OOB upstream controller commands";
        tailf:cli-mode-name "config-profile";
        key "name id";
        leaf name {
          type string {
            tailf:info "55d1-profile;;Cable OOB upstream profile config commands";
          }
        }
        leaf id {
          tailf:info "Upstream NDR profile identifier";
          tailf:cli-expose-key-name;
          type uint32 {
            tailf:info "<1-4294967295>;;OOB upstream profile index";
          }
        }

        // controller upstream-oob * id * / us-channel *
        list us-channel {
          tailf:info "OOB upstream channel configuration";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key id;
          leaf id {
            type uint8 {
              tailf:info "<0-255>;;OOB upstream channel index";
            }
          }

          // controller upstream-oob * id * / us-channel * shutdown
          leaf shutdown {
            tailf:info "OOB upstream shutdown";
            type empty;
          }

          // controller upstream-oob * id * / us-channel * width
          leaf width {
            tailf:info "OOB upstream NDR channel width";
            type uint32 {
              tailf:info "<80000-5120000>;;Channel width MH";
            }
          }

          // controller upstream-oob * id * / us-channel * frequency
          leaf frequency {
            tailf:info "OOB upstream frequency";
            type uint32 {
              tailf:info "<5000000-26500000>;;OOB upstream channel frequency value";
            }
          }
        }
      }
    }

    // controller downstream-oob *
    list downstream-oob {
      tailf:info "Cable OOB downstream controller commands";
      tailf:cli-mode-name "config-profile";
      key "name id";
      leaf name {
        type string {
          tailf:info "55d1-profile;;Cable OOB upstream profile config commands";
        }
      }
      leaf id {
        type uint32 {
          tailf:info "<1-4294967295>;;OOB downstream profile index";
        }
      }

      // controller downstream-oob * / ds-channel *
      list ds-channel {
        tailf:info "OOB downstream channel configuration";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key id;
        leaf id {
          type uint8 {
            tailf:info "<0-255>;;OOB downstream channel index";
          }
        }

        // controller downstream-oob * / ds-channel * rf-mute
        leaf rf-mute {
          tailf:info "OOB downstream rf-mute";
          tailf:cli-show-no;
          type empty;
        }

        // controller downstream-oob * / ds-channel * shutdown
        leaf shutdown {
          tailf:info "OOB downstream shutdown";
          tailf:cli-show-no;
          type empty;
        }

        // controller downstream-oob * / ds-channel * frequency
        leaf frequency {
          tailf:info "OOB downstream frequency";
          type uint32 {
            tailf:info "<70000000-130000000>;;OOB downstream channel frequency value";
            range "70000000..130000000";
          }
        }

        // controller downstream-oob * / ds-channel * poweradjust
        leaf poweradjust {
          tailf:info "OOB downstream poweradjust";
          type uint8 {
            tailf:info "<0-10>;;OOB downstream channel poweradjust value";
            range "0..10";
          }
        }

        // controller downstream-oob * / ds-channel * sf-mute
        leaf sf-mute {
          tailf:info "OOB downstream chanel second frequency mute";
          tailf:cli-show-no;
          type empty;
        }

        // controller downstream-oob * / ds-channel * sf-shutdown
        leaf sf-shutdown {
          tailf:info "OOB downstream channel second frequency shutdown";
          tailf:cli-show-no;
          type empty;
        }

        // controller downstream-oob * / ds-channel * second-frequency
        leaf second-frequency {
          tailf:info "OOB downstream channel second frequency";
          type uint32 {
            tailf:info "<70000000-130000000>;;OOB downstream channel second frequency value";
            range "70000000..130000000";
          }
        }

        // controller downstream-oob * / ds-channel * sf-poweradjust
        leaf sf-poweradjust {
          tailf:info "OOB downstream channel second frequency poweradjust";
          type uint8 {
            tailf:info "<0-10>;;OOB downstream channel second frequency poweradjust value";
            range "0..10";
          }
        }
      }
    }

    // controller downstream-oob * id *
    container downstream-oob-id {
      tailf:cli-drop-node-name;
      list downstream-oob {
        tailf:info "Cable OOB downstream controller commands";
        tailf:cli-mode-name "config-profile";
        key "name id";
        leaf name {
          type string {
            tailf:info "55d1-profile;;Cable OOB upstream profile config commands";
          }
        }
        leaf id {
          tailf:info "Downstream NDF profile identifier";
          tailf:cli-expose-key-name;
          type uint32 {
            tailf:info "<1-4294967295>;;OOB downstream profile index";
          }
        }

        // controller downstream-oob * id * / ds-channel *
        list ds-channel {
          tailf:info "OOB downstream channel configuration";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key id;
          leaf id {
            type uint8 {
              tailf:info "<0-255>;;OOB downstream channel index";
            }
          }

          // controller downstream-oob * id * / ds-channel * shutdown
          leaf shutdown {
            tailf:info "OOB downstream shutdown";
            type empty;
          }

          // controller downstream-oob * id * / ds-channel * width
          leaf width {
            tailf:info "OOB downstream NDF channel width";
            type uint32 {
              tailf:info "80000-25600000;;Channel width MH";
            }
          }

          // controller downstream-oob * id * / ds-channel * frequency
          leaf frequency {
            tailf:info "OOB downstream frequency";
            type uint32 {
              tailf:info "<70000000-130000000>;;OOB downstream channel frequency value";
            }
          }
        }
      }
    }

    // controller wanphy *
    list wanphy {
      tailf:info "WANPHY controller";
      tailf:cli-mode-name "config-controller";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Controller slot/subslot/unit";
        }
      }
    }

    // controller dwdm *
    list dwdm {
      tailf:info "DWDM controller";
      tailf:cli-mode-name "config-controller";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Controller slot/subslot";
        }
      }

      // controller dwdm * / shutdown
      leaf shutdown {
        tailf:info "Shut down the controller";
        type empty;
      }

      // controller dwdm * / g709
      container g709 {
        tailf:info "Configure G709 parameters";

        // controller dwdm * / g709 fec
        leaf fec {
          tailf:info "Configure FEC mode";
          type enumeration {
            enum enhanced {
              tailf:info "Enhanced FEC mode";
            }
            enum standard {
              tailf:info "Standard FEC mode";
            }
          }
          default enhanced;
        }
      }

      // controller dwdm * / transport-mode
      container transport-mode {
        tailf:info "Configure 10/40/100GE  PHY transport mode";
        choice mode-choice {
          default lanwan;
          leaf lanwan {
            tailf:cli-drop-node-name;
            type enumeration {
              enum lan {
                tailf:info "10/40/100GBASE-R LAN pass-through mode";
              }
              enum  wan {
                tailf:info "10GBASE-W WAN SONET/SDH (9.95328Gb/s)";
              }
            }
            default lan;
          }
          leaf otn {
            tailf:info "10/40/100GE over Optical Transport Network (G.709)";
            type enumeration {
              enum otu3 {
                tailf:info "40G over OTU3";
              }
              enum otu4 {
                tailf:info "40G over OTU4";
              }
            }
          }
        }
      }
    }

    // controller SONET *
    list SONET {
      tailf:info "Channelized SONET/SDH controller";
      tailf:cli-mode-name "config-controller";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Controller slot/subslot/unit";
        }
      }
      uses controller-SONET-grouping;
    }

    // controller SONET-ACR *
    list SONET-ACR {
      tailf:info "Channelized SONET/SDH Virtual controller";
      tailf:cli-mode-name "config-controller";
      key name;
      leaf name {
        tailf:non-strict-leafref {
          path "../../../acr/id";
        }
        type uint8 {
          tailf:info "<0-255>;;Controller unit number";
          range "0..255";
        }
      }
      uses controller-SONET-grouping;
    }

    // controller SDH *
    list SDH {
      tailf:info "Channelized SDH controller";
      tailf:cli-mode-name "config-controller";
      key name;
      leaf name {
        ios:delete-syntax "!";
        type string {
          tailf:info "WORD;;Controller slot/subslot[/unit]";
        }
      }

      // controller SDH * / no snmp trap link-status
      container snmp {
        tailf:info "Modify SNMP controller parameters";
        container trap {
          tailf:info "Allow a specific SNMP trap";
          leaf link-status {
            tailf:info "Allow SNMP LINKUP and LINKDOWN traps";
            tailf:cli-boolean-no;
            type boolean;
            default true;
          }
        }
      }

      // controller SDH * / rate
      leaf rate {
        tailf:info "Set the SONET/SDH rates";
        tailf:cli-remove-before-change;
        type enumeration {
          enum STM1 {
            tailf:info "Set the controller to STM1 rate";
          }
          enum STM4 {
            tailf:info "Set the controller to stm4 rate";
          }
          enum STM16 {
            tailf:info "Set the controller to STM16 rate";
          }
        }
      }

      // controller SDH * / no ais-shut
      leaf ais-shut {
        tailf:info "Send LAIS when shutdown";
        tailf:cli-boolean-no;
        type boolean;
        default true;
      }

      // controller SDH * / alarm-report
      leaf alarm-report {
        tailf:info "Enable reporting of selected alarms";
        type enumeration {
          enum all {
            tailf:info "All alarm reports";
          }
        }
      }

      // controller SDH * / shutdown
      leaf shutdown {
        tailf:info "Shut down the Sonet/SDH controller";
        type empty;
      }

      // controller SDH * / clock source
      container clock {
        tailf:info "Specify the clock source for Sonet/SDH port";
        leaf source {
          tailf:info "Specify the clock source for Sonet/SDH port";
          tailf:cli-full-command;
          type enumeration {
            enum line {
              tailf:info "Recovered Clock";
            }
            enum internal {
              tailf:info "Internal Clock";
            }
          }
        }
      }

      // controller SDH * / overhead
      container overhead {
        tailf:info "Specify overhead settings";

        // controller SDH * / overhead s1s0
        leaf s1s0 {
          tailf:info "Set the s1s0 bits of H1";
          type uint8 {
            tailf:info "<0-3>;;s1 & s0 bits";
          }
        }
      }

      // controller SDH * / aug mapping
      container aug {
        tailf:info "Specify AU-3 or AU-4 mapping";
        leaf mapping {
          tailf:info "Specify AU-3 or AU-4 mapping";
          type enumeration {
            enum au-3 {
              tailf:info "AU-3";
            }
            enum au-4 {
              tailf:info "AU-4 (default)";
            }
          }
        }
      }

      // controller SDH * / au-4 *
      list au-4 {
        tailf:info "Specify AU-4 number";
        tailf:cli-mode-name "config-ctrlr-au4";
        tailf:cli-recursive-delete;
        key id;
        leaf id {
          type uint8 {
            tailf:info "<1-4>;;au-4 number";
            range "1..4";
          }
        }

        // controller SDH * / au-4 * / clock source
        container clock {
          tailf:info "Specify the clock source for a PATH";
          leaf source {
            tailf:info "Specify the clock source for a PATH";
            tailf:cli-full-command;
            type enumeration {
              enum line {
                tailf:info "Line Recovered Clock";
              }
              enum internal {
                tailf:info "Internal Clock";
              }
            }
          }
        }

        // controller SDH * / au-4 * / mode
        leaf mode {
          tailf:info "Specify the operational mode for au-4";
          type enumeration {
            enum tug-3 {
              tailf:info "mode 3xTug3";
            }
            enum vc4 {
              tailf:info "Mode VC4";
            }
          }
        }

        // controller SDH * / au-4 * / tug-3 *
        list tug-3 {
          tailf:info "TUG-3 number";
          tailf:cli-mode-name "config-ctrlr-tug3";
          tailf:cli-recursive-delete;
          tailf:cli-diff-delete-before "../../../SDH";
          key id;
          leaf id {
            type uint8 {
              tailf:info "<1-3>;;tug-3 number <1..3>";
              range "1..3";
            }
          }

          // controller SDH * / au-4 * / tug-3 * / mode
          leaf mode {
            tailf:info "Specify the payload type for the tug-3";
            tailf:cli-case-insensitive;
            cli:ned-diff-move-last {
              cli:arguments "when-delete";
            }
            type enumeration {
              enum ce3 {
                tailf:info "mode CE3";
              }
              enum ct3 {
                tailf:info "mode CT3";
              }
              enum ct3-e1 {
                tailf:info "mode CT3-E1";
              }
              enum e3 {
                tailf:info "Configure E3 in TUG3";
              }
              enum t3 {
                tailf:info "Configure T3 in TUG3";
              }
              enum vc1x {
                tailf:info "mode VC1x";
              }
              enum vc3 {
                tailf:info "mode VC3";
              }
            }
          }

          // controller SDH * / au-4 * / tug-3 * / tug-2 * payload
          list tug-2 {
            tailf:info "Tug-2 option to configure payload type";
            tailf:cli-mode-name "config-ctrlr-tug2-vcx";
            tailf:cli-recursive-delete;
            tailf:cli-diff-delete-before "../../tug-3";
            key id;
            leaf id {
              type uint8 {
                tailf:info "<1-7>;;Tug-2 number <1-7>";
                range "1..7";
              }
            }
            leaf payload {
              tailf:info "specify payload type for this tug-2";
              tailf:cli-hide-in-submode;
              tailf:cli-case-insensitive;
              ios:delete-syntax "!";
              type enumeration {
                enum vc11 {
                  tailf:info "payload vc11";
                }
                enum vc12 {
                  tailf:info "payload vc12";
                }
              }
            }

            // controller SDH * / au-4 * / tug-3 * / tug-2 * payload / e1 *
            list e1 {
              tailf:info "E1 line configuration";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-incomplete-command;
              key id;
              leaf id {
                type uint8 {
                  tailf:info "<1-3>;;Choose VC number";
                }
              }

              // controller SDH * / au-4 * / tug-3 * / tug-2 * payload / e1 * cem-group
              container cem-group {
                tailf:info "Specify the timeslots to cem-group mapping";
                tailf:cli-flatten-container;
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                leaf id {
                  tailf:cli-drop-node-name;
                  tailf:cli-remove-before-change;
                  tailf:cli-incomplete-command;
                  type uint16 {
                    tailf:info "<0-65535>;;Channel number";
                  }
                }
                leaf unframed {
                  tailf:info "Unframed in the cem group";
                  type empty;
                }
              }

              // controller SDH * / au-4 * / tug-3 * / tug-2 * payload / e1 * description
              uses description-grouping;

              // controller SDH * / au-4 * / tug-3 * / tug-2 * payload / e1 * framing
              leaf framing {
                tailf:info "Specify the type of Framing on a T1/E1 link";
                type enumeration {
                  enum crc4 {
                    tailf:info "E1 with CRC";
                  }
                  enum no-crc4 {
                    tailf:info "E1";
                  }
                  enum unframed {
                    tailf:info "Clear E1";
                  }
                }
              }
            }

            // controller SDH * / au-4 * / tug-3 * / tug-2 * payload / vc *
            list vc {
              tailf:info "VC configurations";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-incomplete-command;
              key id;
              leaf id {
                type uint8 {
                  tailf:info "<1-4>;;Choose VC number";
                }
              }

              // controller SDH * / au-4 * / tug-3 * / tug-2 * payload / vc * overhead v5
              container overhead {
                tailf:info "Configure VT Line path overhead flag";
                leaf v5 {
                  tailf:info "Path signal label <0..7>";
                  type uint8 {
                    tailf:info "<0-7>;;v5 path signal label <0..7>";
                  }
                }
              }
            }
          }

          // controller SDH * / au-4 * / tug-3 * / t3
          container t3 {
            tailf:info "t3 configuration";

            // controller SDH * / au-4 * / tug-3 * / t3 framing
            leaf framing {
              tailf:info "Specify the type of Framing on a T3/E3 link";
              ios:delete-syntax "!";
              tailf:ned-ignore-compare-config;
              type enumeration {
                enum g751 {
                  tailf:info "G751 Framing Format";
                }
                enum g832 {
                  tailf:info "G832 Framing Format";
                }
                enum c-bit {
                }
              }
            }

            // controller SDH * / au-4 * / tug-3 * / t3 clock source
            container clock {
              tailf:info "Specify the clock source for a T3/E3 link";
              leaf source {
              tailf:info "Specify the clock source for a T3/E3 link";
                type enumeration {
                  enum line {
                    tailf:info "Line Recovered Clock";
                  }
                  enum internal {
                    tailf:info "Internal Clock";
                  }
                }
              }
            }
          }

          // controller SDH * / au-4 * / tug-3 * / e1 *
          list e1 {
            tailf:info "e1 configuration";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key id;
            leaf id {
              type uint8 {
                tailf:info "e1 number";
              }
            }

            // controller SDH * / au-4 * / tug-3 * / e1 * cem-group
            container cem-group {
              tailf:info "Specify the timeslots to cem-group mapping";
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf id {
                tailf:cli-drop-node-name;
                tailf:cli-remove-before-change;
                tailf:cli-incomplete-command;
                type uint16 {
                  tailf:info "<0-65535>;;Channel number";
                }
              }
              leaf unframed {
                tailf:info "Unframed in the cem group";
                type empty;
              }
            }

            // controller SDH * / au-4 * / tug-3 * / e1 * framing unframed
            leaf framing {
              tailf:info "Specify the type of Framing on a E1";
              type enumeration {
                enum crc4 {
                  tailf:info "E1 with CRC";
                }
                enum no-crc4 {
                  tailf:info "E1 with no CRC";
                }
                enum unframed {
                  tailf:info "No Framing Format";
                }
              }
            }
          }
        }
      }
    }

    // controller ISA *
    list ISA {
      tailf:info "ISA controller";
      tailf:cli-mode-name "config-controller";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Controller slot/subslot[/unit]";
        }
      }
    }

    // controller nid *
    list nid {
      tailf:info "NID controller";
      tailf:cli-mode-name "config-controller";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Controller slot/subslot[/unit]";
        }
      }
    }

    // controller MediaType *
    list MediaType {
      tailf:info "Generic MediaType Controller";
      tailf:cli-mode-name "config-controller";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Controller slot/subslot[/unit]";
        }
      }

      // controller MediaType * / description
      uses description-grouping;

      // controller MediaType * / mode
      leaf mode {
        tailf:info "MediaType mode";
        cli:ned-diff-move-before ">controller " {
          cli:arguments "when-set|parent";
        }
        type enumeration {
          enum ethernet {
            tailf:info "Ethernet";
          }
          enum sonet {
            tailf:info "Sonet / SDH";
          }
          enum t3 {
            tailf:info "T3";
          }
          enum e1 {
            tailf:info "e1";
          }
          enum t1 {
            tailf:info "t1";
          }
          enum sdh {
            tailf:info "SDH";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// vc-class
  /// ========================================================================

  container vc-class {
    tailf:info "Configure per VC parameters";

    // vc-class atm *
    list atm {
      tailf:info "Asynchronous transfer mode";
      tailf:cli-mode-name "config-vc-class";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;VC-Class name";
        }
      }

      // vc-class atm * / vbr-nrt
      container vbr-nrt {
        tailf:info "Enter Variable Bit Rate (pcr)(scr)(bcs)";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf pcr {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<16-4608>;;Peak Cell Rate(PCR) in Kbps";
            range "16..4608";
          }
        }
        leaf scr {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<16-PCR>;;Sustainable Cell Rate(SCR) in Kbps";
            range "16..4608";
          }
        }
        leaf mbs {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-64000>;;Maximum Burst Size(MBS) in Cells";
            range "1..64000";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// fhrp
  /// ========================================================================

  container fhrp {
    tailf:info "Configure First Hop Redundancy Protocols";

    // fhrp version vrrp
    container version {
      tailf:info "Configure which FHRP version is allowed to run";
      leaf vrrp {
        tailf:info "Configure Virtual Router Rendundancy Protocol";
        type enumeration {
          enum v2 {
            tailf:info "Legacy VRRP - VRRPv2 for IPv4";
          }
          enum v3 {
            tailf:info "Unified VRRP - VRRPv3 for IPv4 and IPv6";
          }
        }
        default v2;
      }
    }
  }


  /// ========================================================================
  /// coap
  /// ========================================================================

  container coap {
    tailf:info "CoAP Global Configuration Commands";

    // coap http enable
    container http {
      tailf:info "CoAP http server";
      leaf enable {
        tailf:info "CoAP http server enable";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// iox
  /// ========================================================================

  // iox
  container iox {
    tailf:info "Configure IOx services";
    presence true;
  }


  /// ========================================================================
  /// ip
  /// ========================================================================

  container ip {
    tailf:info "Global IP configuration subcommands";

    // no ip subnet-zero
    leaf subnet-zero {
      tailf:info "Allow 'subnet zero' subnets";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
      default true;
    }

    // ip source-route
    // no ip source-route
    leaf source-route {
      tailf:info "Process packets with source routing header options";
      tailf:cli-boolean-no;
      tailf:cli-show-with-default;
      tailf:cli-full-command;
      type boolean;
      default true;
    }

    // ip host-routing
    leaf host-routing {
      tailf:info "Enable host-based routing (proxy ARP and redirect)";
      type empty;
    }

    // no ip routing
    leaf routing {
      tailf:info "Enable IP routing";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      // dep: before this is created, change router
      tailf:cli-diff-dependency "../../router" {
        tailf:cli-trigger-on-set;
      }
      type boolean;
      default true;
    }

    // no ip routing protocol purge interface
    container routing-conf {
      tailf:cli-drop-node-name;
      container routing {
        tailf:info "Enable IP routing";
        container protocol {
          tailf:info "IP routing protocol";
          container purge {
            tailf:info "routes purge";
            leaf interface {
              tailf:info "Perform IP routing protocol routes purge on link failures";
              tailf:cli-boolean-no;
              type boolean;
              default true;
            }
          }
        }
      }
    }

    // ip reflexive-list timeout
    container reflexive-list {
      tailf:info "Reflexive access list";
      leaf timeout {
        tailf:info "Timeout value for reflexive ACL entries";
        type uint32 {
          tailf:info "<30-2147483>;;timeout in seconds";
          range "30..2147483";
        }
      }
    }

    // ip options
    container options {
      tailf:info "IP Options treatment";
      choice options-choice {
        leaf drop {
          tailf:info "Drop all IP options packets";
          type empty;
        }
        leaf ignore {
          tailf:info "Ignore options in IP options packets";
          type empty;
        }
      }
    }

    // ip identd
    leaf identd {
      tailf:info "Ident server";
      type empty;
    }

    // ip audit
    container audit {
      tailf:info "Intrusion Detection System";

      // ip audit notify
      container notify {
        tailf:info "Specify the notification mechanisms (nr-director or log) for the alarms";
        leaf log {
          tailf:info "Send events as syslog messages";
          type empty;
        }
      }

      // ip audit po
      container po {
        tailf:info "Specify nr-director's PostOffice information (for sending events to the nr-directors";

        // ip audit po max-events
        leaf max-events {
          tailf:info "Specify number of Post Office event structures";
          type uint16 {
            tailf:info "<1-65535>;;Number of Post Office event structures";
            range "1..65535";
          }
        }
      }
    }

    // ip auth-proxy
    container auth-proxy {
      tailf:info "Authentication Proxy";

      // ip auth-proxy max-login-attempts
      leaf max-login-attempts {
        tailf:info "Max Login failures per user";
        type uint32 {
          tailf:info "<1-2147483647>;;Number of login failures (retries)";
          range "1..2147483647";
        }
      }

      // ip auth-proxy max-nodata-conns
      leaf max-nodata-conns {
        tailf:info "Max TCP NODATA Connections";
        type uint16 {
          tailf:info "<1-1000>;;Number of TCP NODATA";
          range "1..1000";
        }
        default 3;
      }
    }

    // ip admission
    container admission {
      tailf:info "Network Admission Control (NAC)";

      // ip admission max-login-attempts
      leaf max-login-attempts {
        tailf:info "Max Login failures per user";
        type uint32 {
          tailf:info "<1-2147483647>;;Number of login failures (retries). Default 5";
          range "1..2147483647";
        }
        default 5;
      }

      // ip admission max-nodata-conns
      leaf max-nodata-conns {
        tailf:info "Max TCP NODATA Connections";
        type uint16 {
          tailf:info "<1-1000>;;Number of TCP NODATA";
          range "1..1000";
        }
      }

      // ip admission watch-list
      container watch-list {
        tailf:info "Watch-list";

        // ip admission watch-list expiry-time
        leaf expiry-time {
          tailf:info "Configure expiry time for watch-list entries";
          type uint32 {
            tailf:info "<0-35791>;;Expiry time in minutes (0 for forever)";
            range "0..35791";
          }
          default 10;
        }
      }
    }

    // ip arp
    container arp {
      tailf:info "IP ARP global configuration";

      // ip arp proxy disable
      container proxy {
        tailf:info "Global proxy ARP configuration";
        leaf disable {
          tailf:info "Disable proxy ARP on all interfaces";
          tailf:cli-full-command;
          type empty;
        }
      }

      // ip arp inspection
      container inspection {
        tailf:info "Arp Inspection configuration";

        // ip arp inspection bridge-domain
        leaf-list bridge-domain {
          tailf:info "Enable/Disable ARP Inspection on bridge-domains";
          tailf:cli-range-list-syntax;
          type uint16 {
            tailf:info "WORD;;bridge-domain range, example: 1,3-5,7,9-11";
            range "1..4094";
          }
        }

        // ip arp inspection bridge-domain * logging
        container bridge-domain-list {
          tailf:cli-drop-node-name;
          list bridge-domain {
            tailf:info "Enable/Disable ARP Inspection on bridge-domains";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-incomplete-command;
            key id;
            leaf id {
              type uint16 {
                tailf:info "WORD;;bridge-domain range, example: 1,3-5,7,9-11";
                range "1..4094";
              }
            }
            container logging {
              tailf:cli-flatten-container;
              choice logging-choice {
                // ip arp inspection bridge-domain * logging acl-match
                leaf acl-match {
                  tailf:info "Logging of packets that match ACLs";
                  type enumeration {
                    enum matchlog {
                      tailf:info "Log packets on ACE logging configuration";
                    }
                    enum none {
                      tailf:info "Do not log packets that match ACLs";
                    }
                  }
                }
                // ip arp inspection bridge-domain * logging dhcp-bindings
                leaf dhcp-bindings {
                  tailf:info "Logging of packet that match DHCP bindings";
                  type enumeration {
                    enum all {
                      tailf:info "Log all packets that match DHCP bindings";
                    }
                    enum none {
                      tailf:info "Do not log packets that match DHCP bindings";
                    }
                    enum permit {
                      tailf:info "Log DHCP Binding Permitted packets";
                    }
                  }
                }
              }
            }
          }
        }

        // ip arp inspection validate
        leaf-list validate {
          tailf:info "Validate addresses";
          tailf:cli-flat-list-syntax {
            tailf:cli-replace-all;
          }
          type enumeration {
            enum src-mac {
              tailf:info "Validate source MAC address";
            }
            enum dst-mac {
              tailf:info "Validate destination MAC address";
            }
            enum ip {
              tailf:info "Validate IP addresses";
            }
          }
        }

        // ip arp inspection log-buffer
        container log-buffer {
          tailf:info "Log Buffer Configuration";
          // ip arp inspection log-buffer entries
          leaf entries {
            tailf:info "Number of entries for log buffer";
            type uint16 {
              tailf:info "<0-1024>;;Number of entries for log buffer";
              range "0..1024";
            }
          }
          // ip arp inspection log-buffer logs interval
          container logs {
            tailf:info "Number of logs per interval";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf number {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint16 {
                tailf:info "<0-1024>;;Number of entries";
                range "0..1024";
              }
            }
            leaf interval {
              tailf:info "Interval for controlling logging rate";
              type uint32 {
                tailf:info "<0-86400>;;Interval (seconds)";
              }
            }
          }
        }

        // ip arp inspection vlan
        leaf-list vlan {
          tailf:info "Enable/Disable ARP Inspection on vlans";
          tailf:cli-range-list-syntax;
          type uint16 {
            tailf:info "WORD;;vlan range, example: 1,3-5,7,9-11";
          }
        }

        // ip arp inspection filter *
        list filter {
          tailf:info "Specify ARP acl to be applied";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-incomplete-command;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;ARP acl name";
            }
          }
          leaf-list vlan {
            tailf:info "Vlans to apply the filter";
            tailf:cli-range-list-syntax;
            type uint16 {
              tailf:info "WORD;;vlan range, example: 1,3-5,7,9-11";
              range "1..4094";
            }
          }
        }
      }
    }

    // ip gratuitous-arps
    choice gratuitous-arps-choice {
      // ip gratuitous-arps
      // no ip gratuitous-arps
      container gratuitous-arps-conf {
        tailf:cli-drop-node-name;
        leaf gratuitous-arps {
          tailf:info "Generate gratuitous ARPs for PPP/SLIP peer addresses";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
        }
      }
      container gratuitous-arps {
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        // no ip gratuitous-arps non-local
        leaf non-local {
          tailf:info "Send only non-local PPP/SLIP gratuitous ARPs (default)";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }
      }
      default gratuitous-arps;
    }

    // ip cef
    // no ip cef
    container cef-conf {
      tailf:cli-drop-node-name;
      leaf cef {
        tailf:info "Cisco Express Forwarding";
        tailf:cli-show-no;
        type empty;
      }
    }

    // ip cef X
    container cef {
      tailf:info "Cisco Express Forwarding";
      tailf:cli-incomplete-no;
      tailf:cli-incomplete-command;
      tailf:cli-diff-dependency "../cef-conf/cef";

      // ip cef distributed
      leaf distributed {
        tailf:info "Distributed Cisco Express Forwarding";
        tailf:cli-full-command;
        type empty;
      }

      // no ip cef optimize neighbor resolution
      container optimize {
        tailf:info "Optimizations";
        container neighbor {
          tailf:info "Optimizations for directly connected neighbors";
          leaf resolution {
            tailf:info "Trigger layer 2 address resolution directly from CEF";
            tailf:cli-boolean-no;
            tailf:cli-full-command;
            type boolean;
            default true;
          }
        }
      }

      // ip cef load-sharing algorithm
      container load-sharing {
        tailf:info "Load sharing";
        container algorithm {
          tailf:info "Per-destination load sharing algorithm selection";
          choice algorithm-choice {
            default universal;

            // ip cef load-sharing algorithm original
            leaf original {
              tailf:info "Original algorithm";
              type empty;
            }

            // ip cef load-sharing algorithm universal
            container universal {
              tailf:info "Algorithm for use in most environments";
              tailf:cli-delete-when-empty;
              presence true;
              leaf id {
                tailf:cli-drop-node-name;
                type string {
                  tailf:info "<1-FFFFFFFF>;;Fixed ID";
                }
              }
            }

            // ip cef load-sharing algorithm include-ports
            container include-ports {
              tailf:info "Algorithm that includes layer 4 ports";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf source {
                tailf:info "Use source port in hash function";
                tailf:cli-optional-in-sequence;
                type empty;
              }
              leaf destination {
                tailf:info "Use destination port in hash function";
                type empty;
              }
              leaf destination-id {
                tailf:cli-drop-node-name;
                tailf:cli-optional-in-sequence;
                when "../destination" {
                  tailf:dependency "../destination";
                }
                type string {
                  tailf:info "<1-FFFFFFFF>;;Fixed ID";
                }
              }
            }
          }
        }
      }
    }

    // ip vrf *
    list vrf {
      tailf:info "Configure an IP VPN Routing/Forwarding instance";
      tailf:cli-mode-name "config-vrf";
      tailf:cli-explicit-exit;
      key name;
      leaf name {
        tailf:cli-diff-dependency "../../../vrf/definition";
        type string {
          tailf:info "WORD;;VPN Routing/Forwarding instance name";
        }
      }

      // ip vrf * / description
      leaf description {
        tailf:info "VRF specific description";
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE;;Up to 244 characters describing this VRF";
          length "1..244";
        }
      }

      // ip vrf * / rd
      leaf rd {
        tailf:info "Specify Route Distinguisher";
        tailf:cli-full-command;
        tailf:cli-remove-before-change;
        ios:ip-vrf-rd-restore;
        type rd-type;
      }

      // ip vrf * / vpn id
      container vpn {
        tailf:info "Configure VPN ID as specified in rfc2685";
        leaf id {
          tailf:info "Configure VPN ID in rfc2685 format";
          type vpn-id-type;
        }
      }

      // ip vrf * / context
      leaf context {
        tailf:info "Associate SNMP context with this vrf";
        type string {
          tailf:info "WORD;;SNMP Context Name";
        }
      }

      // ip vrf * / import
      container import {
        tailf:info "VRF import";
        tailf:cli-diff-dependency "../rd";

        // ip vrf * / import map
        leaf map {
          tailf:info "Route-map based VRF import";
          tailf:cli-full-command;
          tailf:cli-diff-dependency "../ipv4" {
            tailf:cli-trigger-on-set;
          }
          type string {
            tailf:info "WORD;;VRF import route-map name";
          }
        }

        // ip vrf * / import ipv4
        container ipv4 {
          tailf:info "Address family based VRF import";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-diff-dependency "../map" {
            tailf:cli-trigger-on-set;
          }
          leaf ipv4-type {
            tailf:cli-drop-node-name;
            tailf:cli-remove-before-change;
            tailf:cli-incomplete-command;
            type enumeration {
              enum unicast {
                tailf:info "Import prefixes from IPv4 Unicast table";
              }
              enum multicast {
                tailf:info "Import prefixes from IPv4 Multicast table";
              }
            }
          }
          leaf upper-limit {
            tailf:cli-break-sequence-commands;
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-2147483647>;;Upper limit on import prefixes without hogging memory";
              range "1..2147483647";
            }
          }
          leaf map {
            tailf:info "Route-map based VRF import";
            type string {
              tailf:info "WORD;;VRF import route-map name";
            }
          }
        }
      }

      // ip vrf * / export
      container export {
        tailf:info "VRF export";
        tailf:cli-diff-dependency "../rd";

        // ip vrf * / export map
        leaf map {
          tailf:info "Route-map based VRF export";
          type string {
            tailf:info "WORD;;VRF export route-map name";
          }
        }

        // ip vrf * / export ipv4
        container ipv4 {
          tailf:info "Address family based VRF export";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-diff-dependency "../map" {
            tailf:cli-trigger-on-set;
          }
          leaf ipv4-type {
            tailf:cli-drop-node-name;
            tailf:cli-remove-before-change;
            tailf:cli-incomplete-command;
            type enumeration {
              enum unicast {
                tailf:info "Export prefixes from IPv4 Unicast table";
              }
              enum multicast {
                tailf:info "Export prefixes from IPv4 Multicast table";
              }
            }
          }
          leaf upper-limit {
            tailf:cli-break-sequence-commands;
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-2147483647>;;Upper limit on export prefixes without hogging memory";
              range "1..2147483647";
            }
          }
          leaf map {
            tailf:info "Route-map based VRF export";
            type string {
              tailf:info "WORD;;VRF export route-map name";
            }
          }
        }
      }

      // ip vrf * / maximum
      container maximum {
        tailf:info "Set a limit";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        presence true;
        leaf routes {
          tailf:info "Maximum number of routes allowed in this routing table";
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<1-4294967295>;;Maximum number of routes allowed";
            range "1..4294967295";
          }
        }
        choice maximum-choice {
          case threshold-case {
            leaf threshold {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<1-100>;;Threshold value (%) at which to generate a warning msg";
                range "1..100";
              }
            }
            leaf reinstall {
              tailf:info "Reinstall previous rejected route due to over maximum route limit";
              type uint16 {
                tailf:info "<1-100>;;Threshold value (%) at which to reinstall routes back to VRF";
                range "1..100";
              }
            }
          }
          case warning-case {
            leaf warning-only {
              tailf:info "Only give a warning message if is limit exceeded";
              type empty;
            }
          }
        }
      }

      // ip vrf * / bgp next-hop Loopback
      container bgp {
        tailf:info "Commands pertaining to BGP";
        container next-hop {
          tailf:info "Next-hop for the routes of a VRF in the backbone";
          leaf Loopback {
            tailf:info "Loopback interface number";
            tailf:cli-allow-join-with-value {
              tailf:cli-display-joined;
            }
            type uint32 {
              tailf:info "<0-2147483647>;;Loopback interface number";
              range "0..2147483647";
            }
          }
        }
      }

      // ip vrf * / mdt
      container mdt {
        tailf:info "Backbone Multicast Distribution Tree";
        tailf:cli-incomplete-command;
        presence true;

        // ip vrf * / mdt default
        leaf default {
          tailf:info "The default group";
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP multicast group address";
          }
        }

        // ip vrf * / mdt data
        container data {
          tailf:info "MDT data group range";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-incomplete-command;
          leaf mulicast-address {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP multicast group address";
            }
          }
          leaf wildcard-bits {
            tailf:cli-drop-node-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Wildcard bits";
            }
          }
          choice mdt-data-choice {
            case mdt-data-threshold {
              leaf threshold {
                tailf:info "MDT switching threshold";
                type uint32 {
                  tailf:info "<1-4294967>;;Traffic rate in kilobits per second";
                  range "1..4294967";
                }
              }
              leaf threshold-list {
                tailf:info "Access-list";
                tailf:alt-name "list";
                type ext-acl-type;
              }
            }
            case mdt-data-list {
              leaf list {
                tailf:info "Access-list";
                type ext-acl-type;
              }
            }
          }
        }

        // ip vrf * / mdt log-reuse
        leaf log-reuse {
          tailf:info "Event logging for data MDT reuse";
          type empty;
        }

        // ip vrf * / mdt mtu
        leaf mtu {
          type uint16;
        }
      }

      // ip vrf * / route-target
      container route-target {
        tailf:info "Specify Target VPN Extended Communities";
        tailf:cli-diff-dependency "../rd";
        uses route-target-grouping;
      }
    }

    // ip dhcp-server
    container dhcp-server {
      tailf:info "Specify target DHCP server parameters";

      // ip dhcp-server *
      list dhcp-server-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key server;
        leaf server {
          tailf:cli-disallow-value "query";
          type inet:host {
            tailf:info "Hostname or A.B.C.D;;IP address or Name of DHCP server";
          }
        }
      }

      // ip dhcp-server query lease
      container query {
        tailf:info "Configure query parameters";
        container lease {
          tailf:info "Set global lease query parameters";

          // ip dhcp-server query lease timeout
          leaf timeout {
            tailf:info "Set timeout between retry (in seconds)";
            type uint8 {
              tailf:info "<1-60>;;Time out for each query in seconds";
              range "1..60";
            }
            default 10;
          }
        }
      }
    }

    // ip ddns
    container ddns {
      tailf:info "Configure dynamic DNS";

      // ip ddns update
      container update {
    	tailf:info "Configure dynamic DNS update";

    	// ip ddns update method *
    	list method {
    	  tailf:info "Configure dynamic DNS update method";
    	  tailf:cli-mode-name "DDNS-update-method";
    	  key name;
    	  leaf name {
    		type string {
    		  tailf:info "WORD;;Dynamic DNS update method name";
    		}
    	  }

    	  // ip ddns update method * / DDNS
    	  container DDNS {
    		tailf:info "IETF standardized Dynamic DNS update";
    		presence true;
    		tailf:cli-delete-when-empty;
    		tailf:cli-reset-container;

    		// ip ddns update method * / DDNS both
    		leaf both {
    		  tailf:info "Update both DNS A and PTR records";
    		  type empty;
    		}
    	  }

    	  // ip ddns update method * / interval
    	  container interval {
    		tailf:info "Specify interval between DNS updates";

    		// ip ddns update method * / interval maximum
    		container maximum {
    		  tailf:info "Specify maximum interval between DNS updates";
    		  tailf:cli-sequence-commands;
    		  tailf:cli-compact-syntax;
    		  leaf days {
    			tailf:cli-drop-node-name;
    			tailf:cli-incomplete-command;
    			tailf:cli-no-value-on-delete;
    			cli:shutdown-before-edit "../../minimum/days";
    		    type uint16 {
    			  tailf:info "<0-365>;;Days";
    			  range 0..365;
    		    }
    		  }
    		  leaf hours {
      			tailf:cli-drop-node-name;
      			tailf:cli-incomplete-command;
      			tailf:cli-no-value-on-delete;
      		    type uint8 {
      			  tailf:info "<0-23>;;Hours";
      			  range 0..23;
      		    }
      		  }
    		  leaf minutes {
        		tailf:cli-drop-node-name;
        		tailf:cli-incomplete-command;
        		tailf:cli-no-value-on-delete;
        		type uint8 {
        		  tailf:info "<0-59>;;Minutes";
        		  range 0..59;
        		}
        	  }
    		  leaf seconds {
        		tailf:cli-drop-node-name;
        		tailf:cli-no-value-on-delete;
        		type uint8 {
        		  tailf:info "<0-59>;;Seconds";
        		  range 0..59;
        		}
        	  }
    		}

    		// ip ddns update method * / interval minimum
    		container minimum {
    		  tailf:info "Specify maximum interval between DNS updates";
    		  tailf:cli-sequence-commands;
    		  tailf:cli-compact-syntax;
    		  leaf days {
    			tailf:cli-drop-node-name;
    			tailf:cli-incomplete-command;
    			tailf:cli-no-value-on-delete;
    		    type uint16 {
    			  tailf:info "<0-365>;;Days";
    			  range 0..365;
    		    }
    		  }
    		  leaf hours {
      			tailf:cli-drop-node-name;
      			tailf:cli-incomplete-command;
      			tailf:cli-no-value-on-delete;
      		    type uint8 {
      			  tailf:info "<0-23>;;Hours";
      			  range 0..23;
      		    }
      		  }
    		  leaf minutes {
        		tailf:cli-drop-node-name;
        		tailf:cli-incomplete-command;
        		tailf:cli-no-value-on-delete;
        		type uint8 {
        		  tailf:info "<0-59>;;Minutes";
        		  range 0..59;
        		}
        	  }
    		  leaf seconds {
        		tailf:cli-drop-node-name;
        		tailf:cli-no-value-on-delete;
        		type uint8 {
        		  tailf:info "<0-59>;;Seconds";
        		  range 0..59;
        		}
        	  }
    		}
    	  }
    	}
      }
    }

    // ip host-list *
    list host-list {
      tailf:info "Configure a host list";
      tailf:cli-mode-name "host-list";
      key name;
      leaf name {
    	type string {
    	  tailf:info "WORD;;Name of host list";
    	}
      }

      // ip host-list * / host *
      leaf-list host {
    	tailf:info "Add names and/or addresses to the host list";
    	tailf:cli-flat-list-syntax;
    	tailf:cli-remove-before-change;
    	ordered-by user;
    	type inet:ipv4-address {
    	  tailf:info "A.B.C.D;;Host IP address";
    	}
      }
    }

    // ip dhcp
    container dhcp {
      tailf:info "Configure DHCP server and relay parameters";
      tailf:cli-explicit-exit;

      // ip dhcp smart-relay
      leaf smart-relay {
        tailf:info "Enable Smart Relay feature";
        type empty;
      }

      // ip dhcp use
      container use {
        tailf:info "Configure use of certain parameters during allocation";

        // ip dhcp use vrf
        container vrf {
          tailf:info "Ignore or use receiving interface VRF";

          // no ip dhcp use vrf connected
          leaf connected {
            tailf:info "Use input interface VRF when servicing connected clients";
            tailf:cli-boolean-no;
            tailf:cli-full-command;
            type boolean;
            default true;
          }

          // ip dhcp use vrf remote
          leaf remote {
            tailf:info "Use input interface VRF when servicing remote clients";
            type empty;
          }
        }
      }

      // ip dhcp binding cleanup interval
      container binding {
        tailf:info "DHCP address bindings";
        container cleanup {
          tailf:info "Remove expired bindings";
          leaf interval {
            tailf:info "Time in seconds";
            type uint16 {
              tailf:info "<10-600>;;Seconds. Default 120";
              range "10..600";
            }
            default 120;
          }
        }
      }

      // no ip dhcp conflict logging
      container conflict {
        tailf:info "DHCP address conflict parameters";
        leaf logging {
          tailf:info "Record address conflicts in a log file";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }
      }

      // ip dhcp excluded-address *
      container excluded-address {
        tailf:info "Prevent DHCP from assigning certain addresses";
        uses ip-dhcp-excluded-address-grouping;
        list vrf {
          tailf:info "VRF name for excluded address range";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-incomplete-command;
          key name;
          leaf name {
            tailf:cli-diff-dependency "../../../../vrf";
            tailf:cli-diff-dependency "../../../../../vrf/definition";
            type string {
              tailf:info "WORD;;VPN Routing/Forwarding instance name";
            }
          }
          uses ip-dhcp-excluded-address-grouping;
        }
      }

      // ip dhcp pool *
      list pool {
        tailf:info "Configure DHCP address pools";
        tailf:cli-mode-name "dhcp-config";
        tailf:cli-full-command;
        key id;
        leaf id {
          tailf:cli-multi-word-key;
          type string {
            tailf:info "WORD;;Pool name";
          }
        }

        // ip dhcp pool * / vrf
        leaf vrf {
          tailf:info "Associate this pool with a VRF";
          tailf:cli-diff-dependency "../../../../ip/vrf";
          tailf:cli-diff-dependency "../../../../vrf/definition";
          type string {
            tailf:info "WORD;;VRF name";
          }
        }

        // ip dhcp pool * / import all
        container import {
          tailf:info "Programatically importing DHCP option parameters";
          leaf all {
            tailf:info "all DHCP options";
            type empty;
          }
        }

        // ip dhcp pool * / bootfile
        leaf bootfile {
          tailf:info "Boot file name";
          type string {
            tailf:info "WORD;;Boot file name";
          }
        }

        // ip dhcp pool * / host
        container host {
          tailf:info "Client IP address and mask";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf address {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP address in dotted-decimal notation";
            }
          }
          leaf mask {
            tailf:cli-drop-node-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Network mask or prefix length";
            }
          }
        }

        // ip dhcp pool * / hardware-address
        // ip dhcp pool * / client-identifier
        choice hardware-or-client {
          leaf hardware-address {
            tailf:info "Client hardware address";
            tailf:cli-full-command;
            type string {
              tailf:info "WORD;;Dotted-hexadecimal string (aabb.ccdd.eeff ...)";
            }
          }
          leaf client-identifier {
            tailf:info "Client identifier";
            tailf:cli-full-command;
            type string {
              tailf:info "WORD;;Dotted-hexadecimal string (aabb.ccdd.eeff ...)";
            }
          }
        }

        // ip dhcp pool * / client-name
        leaf client-name {
          tailf:info "Client name";
          type string {
            tailf:info "WORD;;Client name (domain should not be included)";
          }
        }

        // ip dhcp pool * / network
        container network {
          tailf:info "Network number and mask";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf network-number {
            tailf:cli-drop-node-name;
            tailf:cli-remove-before-change;
            type inet:ipv4-address {
              tailf:info "Network number in dotted-decimal notation";
            }
          }
          leaf mask {
            tailf:cli-drop-node-name;
            tailf:cli-remove-before-change;
            tailf:cli-full-command;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Network mask";
            }
          }
        }

        // ip dhcp pool * / network * secondary
        container network-secondary {
          tailf:cli-drop-node-name;
          list network {
            tailf:cli-mode-name "config-dhcp-subnet-secondary";
            tailf:cli-sequence-commands;
            tailf:cli-incomplete-command;
            tailf:cli-diff-dependency "../../network/network-number";
            key network-number;
            leaf network-number {
              type inet:ipv4-address {
                tailf:info "Network number in dotted-decimal notation";
              }
            }
            leaf mask {
              tailf:cli-drop-node-name;
              tailf:cli-hide-in-submode;
              tailf:cli-incomplete-command;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Network mask";
              }
            }
            leaf secondary {
              tailf:info "Configure as secondary subnet";
              tailf:cli-hide-in-submode;
              tailf:cli-full-command;
              type empty;
            }

            // ip dhcp pool * / network * secondary / override default-router
            container override {
              tailf:info "Override the default router option";
              leaf default-router {
                tailf:info "Default routers for this subnet ";
                type inet:host {
                  tailf:info "Hostname or A.B.C.D;;Router IP address";
                }
              }
            }
          }
        }

        // ip dhcp pool * / next-server *
        leaf-list next-server {
          tailf:info "Next server in boot process";
          tailf:cli-flat-list-syntax;
          tailf:cli-replace-all;
          ordered-by user;
          max-elements 8;
          type inet:host {
            tailf:info "Hostname or A.B.C.D;;Server's name or IP address";
          }
        }

        // ip dhcp pool * / netbios-name-server *
        leaf-list netbios-name-server {
          tailf:info "NetBIOS (WINS) name servers";
          tailf:cli-flat-list-syntax;
          tailf:cli-replace-all;
          ordered-by user;
          max-elements 8;
          type inet:host {
            tailf:info "Hostname or A.B.C.D;;Server's name or IP address";
          }
        }

        // ip dhcp pool * / dns-server *
        leaf-list dns-server {
          tailf:info "DNS servers";
          tailf:cli-flat-list-syntax;
          tailf:cli-replace-all;
          ordered-by user;
          max-elements 8;
          type inet:host {
            tailf:info "Hostname or A.B.C.D;;Server's name or IP address";
          }
        }

        // ip dhcp pool * / default-router *
        leaf-list default-router {
          tailf:info "Default routers";
          tailf:cli-flat-list-syntax;
          tailf:cli-replace-all;
          ordered-by user;
          max-elements 8;
          type inet:host {
            tailf:info "Hostname or A.B.C.D;;Router's name or IP address";
          }
        }

        // ip dhcp pool * / domain-name
        leaf domain-name {
          tailf:info "Domain name";
          tailf:cli-full-command;
          type string {
            tailf:info "NAME;;Domain name";
          }
        }

        // ip dhcp pool * / option
        list option {
          tailf:info "Raw DHCP options";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          key code;
          leaf code {
            type uint8 {
              tailf:info "<0-254>;;DHCP option code";
              range "0..254";
            }
          }
          choice option-config {
            leaf ascii {
              tailf:info "Data is an NVT ASCII string";
              tailf:cli-multi-value;
              tailf:cli-suppress-no;
              tailf:cli-no-name-on-delete;
              tailf:cli-no-value-on-delete;
              type string {
                tailf:info "LINE;;NVT ASCII string";
              }
            }
            leaf hex {
              tailf:info "Data is a hexadecimal string";
              tailf:cli-suppress-no;
              tailf:cli-no-name-on-delete;
              tailf:cli-no-value-on-delete;
              type union {
                type string {
                  tailf:info "LINE;;Hexadecimal string";
                }
                type enumeration {
                  enum none {
                    tailf:info "No data";
                  }
                }
              }
            }
            leaf-list ip {
              tailf:info "Data is one or more IP addresses";
              tailf:cli-flat-list-syntax;
              tailf:cli-replace-all;
              tailf:cli-suppress-no;
              tailf:cli-no-name-on-delete;
              tailf:cli-no-value-on-delete;
              type inet:host {
                tailf:info "Hostname or A.B.C.D;;Server's name or IP address";
              }
            }
          }

          // ip dhcp pool * / option * / instance *
          list instance {
            tailf:info "Specify the option instance";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key option-instance;
            leaf option-instance {
              tailf:info "Specify the option instance";
              type uint8 {
                tailf:info "<0-255>;;DHCP option instance";
              }
            }
            choice option-config {
              leaf ascii {
                tailf:info "Data is an NVT ASCII string";
                tailf:cli-multi-value;
                tailf:cli-suppress-no;
                tailf:cli-no-name-on-delete;
                tailf:cli-no-value-on-delete;
                type string {
                  tailf:info "LINE;;NVT ASCII string";
                }
              }
              leaf hex {
                tailf:info "Data is a hexadecimal string";
                tailf:cli-suppress-no;
                tailf:cli-no-name-on-delete;
                tailf:cli-no-value-on-delete;
                type union {
                  type string {
                    tailf:info "LINE;;Hexadecimal string";
                  }
                  type enumeration {
                    enum none {
                      tailf:info "No data";
                    }
                  }
                }
              }
              leaf-list ip {
                tailf:info "Data is one or more IP addresses";
                tailf:cli-flat-list-syntax;
                tailf:cli-replace-all;
                tailf:cli-suppress-no;
                tailf:cli-no-name-on-delete;
                tailf:cli-no-value-on-delete;
                type inet:host {
                  tailf:info "Hostname or A.B.C.D;;Server's name or IP address";
                }
              }
            }
          }
        }

        // ip dhcp pool * / lease
        container lease {
          tailf:info "Address lease time";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-all-siblings;
          }
          choice lease-choice {
            case a {
              leaf infinite {
                tailf:info "Infinite lease";
                type empty;
              }
            }
            case b {
              leaf days {
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<0-365>;;Days";
                  range "0..365";
                }
              }
              leaf hours {
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<0-23>;;Hours";
                  range "0..23";
                }
              }
              leaf minutes {
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<0-59>;;Minutes";
                  range "0..59";
                }
              }
            }
          }
        }

        // ip dhcp pool * / update arp
        container update {
          tailf:info "Dynamic updates";
          leaf arp {
            tailf:info "Add secure ARP entries";
            type empty;
          }
        }

        // ip dhcp pool * / accounting
        leaf accounting {
          tailf:info "Send Accounting Start/Stop messages";
          type string {
            tailf:info "WORD;;Named Accounting list";
          }
        }

        // ip dhcp pool * / class *
        list class {
          tailf:info "Specify a DHCP class";
          tailf:cli-mode-name "config-dhcp-pool-class";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;DHCP class name";
            }
          }

          // ip dhcp pool * / class * / address range
          container address {
            tailf:info "Specify an address range for this class";
            container range {
              tailf:info "Specify an address range for this class";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf start-ip {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Start IP address";
                }
              }
              leaf end-ip {
                tailf:cli-drop-node-name;
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;End IP address";
                }
              }
            }
          }
        }
        // ip dhcp pool * / netbios-node-type
        leaf netbios-node-type {
          tailf:info "NetBIOS node type";
          type union {
            type enumeration {
              enum "b-node" {
                tailf:info "Broadcast node";
              }
              enum "h-node" {
                tailf:info "Hybrid node";
              }
              enum "m-node" {
                tailf:info "Mixed node";
              }
              enum "p-node" {
                tailf:info "Peer-to-peer node";
              }
            }
            type string {
              tailf:info "<0-FF>;;Hexadecimal number";
            }
          }
        }
      }

      // ip dhcp class *
      list class {
        tailf:info "Configure DHCP classes";
        tailf:cli-mode-name "config-dhcp-class";
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;Class name";
          }
        }

        // ip dhcp class * / remark
        leaf remark {
          tailf:info "Specify a remark for this class";
          tailf:cli-multi-value;
          type string {
            tailf:info "LINE;;Up to 240 characters describing this class";
            length "1..240";
          }
        }

        // ip dhcp class * / relay agent information /
        container relay {
          tailf:info "Enter relay agent information option configuration submode";
          container agent {
            tailf:info "Enter relay agent information option configuration submode";
            container information {
              tailf:info "Enter relay agent information option configuration submode";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-dhcp-class-relayinfo";
              presence true;
            }
          }
        }
      }

      // ip dhcp snooping
      container snooping {
        tailf:info "DHCP Snooping";
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;

        // ip dhcp snooping bridge-domain *
        leaf-list bridge-domain {
          tailf:info "DHCP Snooping bridge-domain";
          tailf:cli-range-list-syntax;
          tailf:cli-suppress-list-no;
          tailf:cli-full-command;
          tailf:cli-diff-dependency "../../snooping";
          type uint16 {
            tailf:info "WORD;;bridge-domain range, example: 1,3-5,7,9-11";
            range "1..4094";
          }
        }

        // ip dhcp snooping information
        container information {
          tailf:info "DHCP Snooping information";
          container option {
            tailf:info "DHCP Snooping information option";
            presence true;
            leaf allow-untrusted {
              tailf:info "DHCP Snooping information option allow-untrusted";
              type empty;
            }
            container format {
              tailf:info "Option 82 information format";
              container remote-id {
                tailf:info "Remote id option 82 format";
                choice remote-id-choice {
                  leaf hostname {
                    tailf:info "Use configured hostname for remote id";
                    type empty;
                  }
                  leaf string {
                    tailf:info "User defined string for remote id";
                    type string {
                      tailf:info "WORD;;Use string for remote id (max length 63)";
                    }
                  }
                }
              }
            }
          }
        }

        // ip dhcp snooping database
        container database {
          tailf:info "DHCP snooping database agent";

          // ip dhcp snooping database <url>
          leaf url {
            tailf:cli-drop-node-name;
            tailf:cli-disallow-value "write-delay";
            type string {
              tailf:info "WORD;;Database agent URL";
            }
          }

          // ip dhcp snooping database write-delay
          leaf write-delay {
            tailf:info "Configure delay timer for writes to URL";
            type uint32 {
              tailf:info "<15-86400>;;Write delay timer";
              range "15..86400";
            }
            default 300;
          }
        }

        // ip dhcp snooping track
        container track {
          tailf:info "DHCP snooping track";
          leaf host {
            tailf:info "DHCP snooping track host";
            type empty;
          }
        }

        // ip dhcp snooping verify
        container verify {
          tailf:info "DHCP snooping verify";
          leaf mac-address {
            tailf:info "DHCP snooping verify mac-address";
            type empty;
          }
          leaf no-relay-agent-address {
            tailf:info "DHCP snooping verify giaddr";
            type empty;
          }
        }

        // ip dhcp snooping vlan
        leaf-list vlan {
          tailf:info "DHCP Snooping vlan";
          tailf:cli-range-list-syntax;
          type uint16 {
            tailf:info "WORD;;DHCP Snooping vlan fist number or vlan range, example: 1,3-5,7,9-11";
          }
        }
      }

      // ip dhcp snooping
      container snooping-conf {
        tailf:cli-drop-node-name;
        leaf snooping {
          tailf:info "DHCP Snooping ";
          type empty;
        }
      }

      // ip dhcp relay
      container relay {
        tailf:info "DHCP relay agent parameters";

        // ip dhcp relay information
        container information {
          tailf:info "Relay agent information option";

          // ip dhcp relay information option
          container option {
            tailf:info "Insert relay information in BOOTREQUEST";
            presence true;
          }

          // no ip dhcp relay information check
          leaf check {
            tailf:info "Validate relay information in BOOTREPLY";
            tailf:cli-boolean-no;
            tailf:cli-full-command;
            type boolean;
            default true;
          }

          // ip dhcp relay information trust-all
          leaf trust-all {
            tailf:info "Received DHCP packets may contain relay info option with zero giaddr";
            type empty;
          }
        }

        // ip dhcp relay override giaddr link-selection
        container override {
          tailf:info "Override DHCP packet fields";
          container giaddr {
            tailf:info "Override giaddr field";
            leaf link-selection {
              tailf:info "Override giaddr field with link-selection suboption";
              type empty;
            }
          }
        }

        // ip dhcp relay prefer known-good-server
        container prefer {
          tailf:info "Relay agent server selection approach";
          leaf known-good-server {
            tailf:info "For unnumbered interfaces, prefer to send client requests to the server which handled the last one";
            type empty;
          }
        }
      }

      // ip dhcp bootp ignore
      container bootp {
        tailf:info "BOOTP specific configuration";
        leaf ignore {
          tailf:info "Configure this DHCP server to ignore to BOOTP requests.";
          type empty;
        }
      }
    }

    // no ip bootp server
    container bootp {
      tailf:info "Config BOOTP services";
      leaf server {
        tailf:info "Enable BOOTP server";
        tailf:cli-boolean-no;
        type boolean;
        default true;
      }
    }

    // ip domain
    container domain {
      tailf:info "IP DNS Resolver";

      // ip domain round-robin
      leaf round-robin {
        tailf:info "Round-robin multiple IP addresses in cache";
        tailf:cli-full-command;
        type empty;
      }

      // ip domain list vrf *
      container list-vrf {
        tailf:cli-drop-node-name;
        container list {
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          list vrf {
            tailf:info "Specify VRF";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key "name domain-name";
            leaf name {
              tailf:cli-diff-dependency "../../../../../../ip/vrf";
              tailf:cli-diff-dependency "../../../../../../vrf/definition";
              type string {
                tailf:info "WORD;;VRF name";
              }
            }
            leaf domain-name {
              type string {
                tailf:info "WORD;;A domain name";
              }
            }
          }
        }
      }

      // ip domain list *
      // ip domain-list *
      list list {
        tailf:info "Domain name to complete unqualified host names";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;A domain name";
          }
        }
      }

      // ip domain retry
      leaf retry {
        tailf:info "Specify times to retry sending a DNS query";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<0-100>;;Number of retries. Default 2";
          range "0..100";
        }
        default 2;
      }

      // ip domain timeout
      leaf timeout {
        tailf:info "Specify timeout waiting for response to a DNS query";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<1-3600>;;Timeout value in seconds. Default 3";
          range "1..3600";
        }
        default 3;
      }

      // no ip domain lookup
      container lookup-conf {
        tailf:cli-drop-node-name;
        leaf lookup {
          tailf:info "Enable IP Domain Name System hostname translation";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }
      }

      // ip domain lookup
      container lookup {
        tailf:info "Enable IP Domain Name System hostname translation";
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;

        // no ip domain lookup nsap
        leaf nsap {
          tailf:info "Enable IP DNS queries for CLNS NSAP addresses";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }

        // ip domain lookup recursive
        leaf recursive {
          tailf:info "Enable IP DNS recursive lookup";
          tailf:cli-full-command;
          type empty;
        }

        // ip domain lookup source-interface
        container source-interface {
          tailf:info "Specify source interface for DNS resolver";
          uses interface-name-grouping;
        }

        // ip domain lookup vrf
        leaf vrf {
          tailf:info "Specify VRF";
          tailf:cli-diff-dependency "../../../../ip/vrf";
          tailf:cli-diff-dependency "../../../../vrf/definition";
          type string {
            tailf:info "WORD;;VRF name";
          }
        }
      }

      // ip domain name vrf *
      container name-vrf {
        tailf:cli-drop-node-name;
        container name {
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          list vrf {
            tailf:info "Specify VRF";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-incomplete-command;
            key name;
            leaf name {
              tailf:cli-diff-dependency "../../../../../../ip/vrf";
              tailf:cli-diff-dependency "../../../../../../vrf/definition";
              type string {
                tailf:info "WORD;;VRF name";
              }
            }
            leaf domain-name {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "WORD;;Default domain name";
              }
            }
          }
        }
      }

      // ip domain name
      // (ip domain-name)
      leaf name {
        tailf:info "Define the default domain name";
        type string {
          tailf:info "WORD;;Default domain name";
        }
      }

      // ip domain multicast
      leaf multicast {
        tailf:info "Define the domain name for multicast address lookups";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;Multicast domain name";
        }
      }

      // ip domain recursive
      container recursive {
        tailf:info "Configure recursive DNS lookup";

        // ip domain recursive retry
        leaf retry {
          tailf:info "Configure maximum no. referrals to be allowed";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<0-100>;;Maximum no. of referrals allowed - default 10";
            range "0..100";
          }
          default 10;
        }

        leaf allow-soa {
          tailf:info "Treat response containing SOA RR in AUTHORITY as a referral";
          tailf:cli-full-command;
          type empty;
        }
      }
    }

    // ip host *
    container host {
      tailf:info "Add an entry to the ip hostname table";
      uses ip-host-grouping;
      // ip host vrf *
      list vrf {
        tailf:info "Specify VRF";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          tailf:cli-diff-dependency "../../../../ip/vrf";
          tailf:cli-diff-dependency "../../../../vrf/definition";
          type string {
            tailf:info "WORD;;VRF name";
          }
        }
        // ip host vrf * *
        uses ip-host-grouping;
      }
    }

    // ip name-server *
    container name-server {
      tailf:info "Specify address of name server to use";
      uses ip-name-server-grouping;
      list vrf {
        tailf:info "Specify VRF";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          tailf:cli-diff-dependency "../../../../ip/vrf";
          tailf:cli-diff-dependency "../../../../vrf/definition";
          type string {
            tailf:info "WORD;;VRF name";
          }
        }
        // ip name-server vrf * *
        uses ip-name-server-grouping;
      }
    }

    // ip multicast-routing
    container mcr-conf {
      tailf:cli-drop-node-name;
      leaf multicast-routing {
        tailf:info "Enable IP multicast forwarding";
        type empty;
      }
    }

    // ip multicast-routing
    container multicast-routing {
      tailf:info "Enable IP multicast forwarding";
      tailf:cli-incomplete-no;
      tailf:cli-incomplete-command;
      tailf:cli-diff-dependency "../mcr-conf/multicast-routing";

      // ip multicast-routing vrf *
      list vrf {
        tailf:info "Select VPN Routing/Forwarding instance";
        tailf:cli-suppress-list-no;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-diff-dependency "../../mcr-conf/multicast-routing";
        key name;
        leaf name {
          tailf:cli-diff-dependency "../../../../ip/vrf";
          tailf:cli-diff-dependency "../../../../vrf/definition";
          type string {
            tailf:info "WORD;;VPN Routing/Forwarding instance name";
          }
        }
        leaf distributed {
          tailf:info "Distributed multicast switching";
          type empty;
        }
      }

      // ip multicast-routing distributed
      leaf distributed {
        tailf:info "Distributed multicast switching";
        tailf:cli-full-command;
        type empty;
      }
    }

    // ip multicast
    container multicast {
      tailf:info "Global IP Multicast Commands";

      // ip multicast route-limit
      container route-limit {
        tailf:info "Maximum number of multicast routes";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-reset-container;
        leaf limit {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-2147483647>;;number of routes";
            range "1..2147483647";
          }
          default 2147483647;
        }
        leaf threshold {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-2147483647>;;Threshold at which to generate warning message";
            range "1..2147483647";
          }
        }
      }

      // ip multicast multipath
      container multipath {
        tailf:info "RPF across equal-cost paths";
        tailf:cli-delete-when-empty;
        tailf:cli-reset-container;
        presence true;
        leaf s-g-hash {
          tailf:info "Per-(source, group) load sharing algorithm selection";
          type enumeration {
            enum basic {
              tailf:info "Basic hash on (source, group)";
            }
            enum next-hop-based {
              tailf:info "Advanced hash on (source, group) and next-hop";
            }
          }
        }
      }

      // ip multicast mpls
      container mpls {
        tailf:info "IP multicast mpls commands";

        // ip multicast mpls mldp
        leaf mldp {
          tailf:info "MLDP commands";
          type empty;
        }
      }

      // ip multicast vrf *
      list vrf {
        tailf:info "Select VPN Routing/Forwarding instance";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-no;
        tailf:cli-diff-set-after "../../../ip/access-list";
        key name;
        leaf name {
          tailf:cli-diff-dependency "../../../../ip/vrf";
          tailf:cli-diff-dependency "../../../../vrf/definition";
          type string {
            tailf:info "WORD;;VPN Routing/Forwarding instance name";
          }
        }

        // ip multicast vrf * route-limit
        container route-limit {
          tailf:info "Maximum number of multicast routes";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-reset-container;
          leaf limit {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-2147483647>;;number of routes";
              range "1..2147483647";
            }
            default 2147483647;
          }
          leaf threshold {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-2147483647>;;Threshold at which to generate warning message";
              range "1..2147483647";
            }
          }
        }

        // ip multicast vrf * multipath
        container multipath {
          tailf:info "RPF across equal-cost paths";
          presence true;
        }

        // ip multicast vrf * rpf select global group-list *
        container rpf {
          tailf:info "RPF check configuration";
          container select {
            tailf:info "Select table for RPF check";
            container global {
              tailf:info "Global routing table for RPF lookup";
              list group-list {
                tailf:info "Group access-list";
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                key id;
                leaf id {
                  type union {
                    type uint16 {
                      tailf:info "<1-99>;;Standard access list";
                      range "1..99";
                    }
                    type string {
                      tailf:info "WORD;;IP Named Standard access list";
                    }
                  }
                }
              }
            }
          }
        }
      }

      // ip multicast hardware-switching
      container hardware-switching {
        tailf:info "IPv4 Multicast hardware-switching";

        // ip multicast hardware-switching replication-mode
        leaf replication-mode {
          tailf:info "HW multicast replication mode";
          type enumeration {
            enum egress {
              tailf:info "Egress mode of replication";
            }
            enum ingress {
              tailf:info "Ingress mode of replication";
            }
          }
        }
      }
    }

    // ip icmp
    container icmp {
      tailf:info "ICMP options";

      // ip icmp rate-limit unreachable
      container rate-limit {
        tailf:info "rate limit ICMP messages generated";
        container unreachable {
          tailf:info "ICMP type 3, Destination Unreachable";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf DF {
            tailf:info "code 4, fragmentation needed and DF set";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          leaf ms {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-4294967295>;;Once per milliseconds. Default 500";
            }
            default 500;
          }
          leaf log {
            tailf:info "log message if rate limiting is excessive";
            type empty;
          }
          leaf packets {
            when "../log" {
              tailf:dependency "../log";
            }
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-4294967295>;;number of unreachables within interval to trigger a message";
              range "1..4294967295";
            }
          }
          leaf interval-ms {
            when "../log" {
              tailf:dependency "../log";
            }
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<10000-4294967295>;;log message once per milliseconds";
              range "10000..4294967295";
            }
          }
        }
      }

      // ip icmp redirect
      leaf redirect {
        tailf:info "Redirect type";
        tailf:cli-full-command;
        type enumeration {
          enum subnet {
            tailf:info "Send ICMP subnet redirects";
          }
          enum host {
            tailf:info "Send ICMP host redirects";
          }
        }
        default subnet;
      }
    }

    // ip igmp
    container igmp {
      tailf:info "IGMP global configuration";

      // ip igmp limit
      // ip igmp ssm-map
      uses ip-igmp-grouping;

      // ip igmp snooping X
      container snooping-conf {
        tailf:cli-drop-node-name;
        container snooping {
          tailf:info "Global IGMP Snooping enable for Catalyst Vlans";
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;

          // ip igmp snooping l2-entry-limit
          leaf l2-entry-limit {
            tailf:info "limit on the l2 entry that can be installed by IGMP snooping";
            type uint32 {
              tailf:info "<1-100000>;;maximum number of l2 entries";
              range "1..100000";
            }
          }

          // ip igmp snooping last-member-query-interval
          leaf last-member-query-interval {
            tailf:info "Last member query interval";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<100-32767>;;Interval (milliseconds). Default 1000";
              range "100..32767";
            }
            default 1000;
          }

          // ip igmp snooping source-only-learning age-timer
          container source-only-learning {
            tailf:info "source-only gce entries";
            leaf age-timer {
              tailf:info "configure age-timer for source-only entries";
              type uint32 {
                tailf:info "<0-86400>;;source-only entries age timer in secs";
                range "0..86400";
              }
              default 600;
            }
          }

          // no ip igmp snooping report-suppression
          leaf report-suppression {
            tailf:info "Report suppression";
            tailf:cli-boolean-no;
            tailf:cli-full-command;
            type boolean;
            default true;
          }

          // ip igmp snooping querier X
          container querier-conf {
            tailf:cli-drop-node-name;
            container querier {
              tailf:cli-incomplete-command;
              tailf:cli-incomplete-no;

              // ip igmp snooping querier version
              leaf version {
                tailf:info "IGMP version";
                type uint8 {
                  tailf:info "<1-2>;;IGMP version";
                  range "1..2";
                }
                default 2;
              }

              // ip igmp snooping querier timer expiry
              container timer {
                tailf:info "IGMP other querier timer";
                leaf expiry {
                  tailf:info "IGMP querier other querier time out (sec)";
                  type uint16 {
                    tailf:info "<60-300>;;IGMP querier other querier time out (sec)";
                    range "60..300";
                  }
                  default 120;
                }
              }
            }
          }

          // ip igmp snooping querier
          leaf querier {
            tailf:info "IGMP querier configuration";
            tailf:cli-full-command;
            tailf:cli-full-no;
            type empty;
          }
        }
      }

      // no ip igmp snooping
      leaf snooping {
        tailf:info "Global IGMP Snooping enable for Catalyst Vlans";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // ip igmp snooping vlan
      container snooping-vlan {
        tailf:cli-drop-node-name;
        container snooping {
          tailf:info "Global IGMP Snooping enable for Catalyst Vlans";
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          container vlan {
            tailf:info "IGMP Snooping enable for Catalyst VLAN";

            // no ip igmp snooping vlan *
            // = ip igmp snooping vlan no-list *
            list no-list {
              tailf:info "'no ip igmp snooping vlan' entry";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              when "not(../../../../snooping = 'false')" {
                tailf:dependency "../../../../snooping";
              }
              key id;
              leaf id {
                type uint16 {
                  tailf:info "<1-4094>;;VLAN ID";
                  range "1..4094";
                }
              }
              leaf querier {
                tailf:info "Enable IGMP querier for this Vlan";
                type empty;
              }
              container check {
                tailf:info "enforce TTL or Rtr-Alert Option checking";
                leaf ttl {
                  tailf:info "Only accept IGMP packets with TTL=1";
                  type empty;
                }
                leaf rtr-alert-option {
                  tailf:info "Only accept IGMP packets with router-alert option";
                  type empty;
                }
              }
            }

            // ip igmp snooping vlan *
            list list {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key id;
              leaf id {
                tailf:cli-suppress-range;
                type uint16 {
                  tailf:info "<1-1001,1006-4094>;;Vlan number";
                  range "1..1001|1006..4094";
                }
              }

              // ip igmp snooping vlan * mrouter
              container mrouter {
                tailf:info "Configure an L2 port as a multicast router port";

                // ip igmp snooping vlan * mrouter interface *
                list interface {
                  tailf:info "Specify an interface statically configured";
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  tailf:cli-diff-dependency "/ios:interface";
                  key name;
                  leaf name {
                    type string {
                      tailf:info "WORD;;Interface name";
                    }
                  }
                }
              }

              // ip igmp snooping vlan * immediate-leave
              leaf immediate-leave {
                tailf:info "Enable IGMPv2 immediate leave processing";
                type empty;
              }
            }

            // ip igmp snooping vlan * static * interface *
            list static-list {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key "id static interface";
              leaf id {
                type uint16 {
                  tailf:info "<1-4094>;;VLAN ID";
                  range "1..4094";
                }
              }
              leaf static {
                tailf:cli-expose-key-name;
                tailf:info "Configure an L2 port as a member of a group";
                type string {
                  tailf:info "H.H.H|A.B.C.D;;Mac|IP address of the group";
                }
              }
              leaf interface {
                tailf:cli-expose-key-name;
                tailf:info "Specify an interface statically configured";
                tailf:cli-diff-dependency "../../../../../../../interface";
                type string {
                  tailf:info "WORD;;Interface name";
                }
              }
            }
          }
        }
      }

      // ip igmp profile *
      list profile {
        tailf:info "IGMP Filter Profile";
        tailf:cli-mode-name "config-igmp-profile";
        key id;
        leaf id {
          type uint32 {
            tailf:info "<1-4294967295>;;Profile number";
            range "1..4294967295";
          }
        }
      }

      // no ip igmp filter
      leaf filter {
        tailf:info "IGMP Filter Enable";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // ip igmp vrf *
      list vrf {
        tailf:info "Select VPN Routing/Forwarding instance";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          tailf:cli-diff-dependency "../../../../ip/vrf";
          tailf:cli-diff-dependency "../../../../vrf/definition";
          type string {
            tailf:info "WORD;;VPN Routing/Forwarding instance name";
          }
        }
        uses ip-igmp-grouping;
      }
    }

    // ip msdp
    container msdp {
      tailf:info "MSDP global commands";
      uses ip-msdp-grouping;

      // ip msdp vrf *
      list vrf {
        tailf:info "Select VPN Routing/Forwarding instance";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          tailf:cli-diff-dependency "../../../../ip/vrf";
          tailf:cli-diff-dependency "../../../../vrf/definition";
          type string {
            tailf:info "WORD;;VPN Routing/Forwarding instance name";
          }
        }
        uses ip-msdp-grouping;
      }
    }

    // ip device tracking
    container device {
      tailf:info "Device tracking";
      container tracking {
        tailf:info "Device tracking";
        tailf:cli-delete-when-empty;
        presence true;
        container probe {
          tailf:info "Probe";

          // ip device tracking probe count
          leaf count {
            tailf:info "IP device tracking Probe count";
            type uint8 {
              tailf:info "<1-5>;;Probe count";
              range "1..5";
            }
          }

          // ip device tracking probe auto-source
          container auto-source {
            tailf:info "Probe source selection algorithm";
            tailf:cli-compact-syntax;
            tailf:cli-reset-container;
            tailf:cli-delete-when-empty;
            presence true;
            container fallback {
              tailf:info "Specify IP and MASK to use as last resort";
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf address {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IP of fallback source";
                }
              }
              leaf mask {
                tailf:cli-drop-node-name;
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IP prefix mask";
                }
              }
            }
            leaf override {
              tailf:info "Do not select source address from device track table";
              type empty;
            }
          }

          // ip device tracking probe delay
          leaf delay {
            tailf:info "Probe delay";
            type uint8 {
              tailf:info "<1-120>;;delay";
              range "1..120";
            }
          }

          // ip device tracking probe interval
          leaf interval {
            tailf:info "Probe interval";
            type uint32 {
              tailf:info "<30-1814400>;;interval";
              range "30..1814400";
            }
          }
        }
      }
    }

    // ip slb
    container slb {
      tailf:info "Server Load Balancing (DEPRECATED)";

      // ip slb probe *
      list probe {
        tailf:info "configure an SLB probe";
        tailf:cli-mode-name "config-slb-probe";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;probe name";
          }
        }
        choice probe-choice {
          leaf tcp {
            tailf:info "Transmission Control Protocol";
            tailf:cli-hide-in-submode;
            type empty;
          }
          leaf dns {
            tailf:info "Domain Name System";
            tailf:cli-hide-in-submode;
            type empty;
          }
          leaf ping {
            tailf:info "ICMP echo";
            tailf:cli-hide-in-submode;
            type empty;
          }
          leaf custom {
            tailf:info "Customized probe";
            tailf:cli-hide-in-submode;
            type enumeration {
              enum udp {
               tailf:info "Customized UDP probe";
              }
            }
          }
        }

        // ip slb probe * / lookup
        leaf lookup {
          tailf:info "DNS probe lookup";
          type string {
            tailf:info "WORD;;name or address to resolve";
          }
        }

        // ip slb probe * / port
        leaf port {
          tailf:info "probe port";
          type uint16 {
            tailf:info "<1-65535>;;probe port";
            range "1..65535";
          }
        }

        // ip slb probe * / interval
        leaf interval {
          tailf:info "probe interval";
          type uint16 {
            tailf:info "<1-65535>;;probe interval";
            range "1..65535";
          }
        }
      }

      // ip slb serverfarm *
      list serverfarm {
        tailf:info "configure an SLB server farm";
        tailf:cli-mode-name "config-slb-sfarm";
        tailf:cli-diff-dependency "../probe";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;SLB server farm identifier string";
          }
        }

        // ip slb serverfarm * / nat
        container nat {
          tailf:info "address translation for SLB";
          choice nat-choice {
            leaf server {
              tailf:info "server address translation";
              type empty;
            }
            leaf client {
              tailf:info "client address translation";
              type string {
                tailf:info "WORD;;client address pool name";
              }
            }
          }
        }

        // ip slb serverfarm * / predictor
        container predictor {
          tailf:info "load balancing prediction algorithm";

          // ip slb serverfarm * / predictor leastconns
          leaf leastconns {
            tailf:info "least connections algorithm";
            type empty;
          }
        }

        // ip slb serverfarm * / probe *
        list probe {
          tailf:info "use a probe";
          key name;
          leaf name {
            //tailf:non-strict-leafref {
            //path "/ios:ip/slb/probe/name";
            //}
            type string {
              tailf:info "WORD;;probe name";
            }
          }
        }

        // ip slb serverfarm * / real *
        list real {
          tailf:info "configure a real server";
          tailf:cli-mode-name "config-slb-real";
          key address;
          leaf address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;real server IP address";
            }
          }

          // ip slb serverfarm * / real * / weight
          leaf weight {
            tailf:info "real server weighting factor";
            type uint8 {
              tailf:info "<0-255>;;weighting value (default is 8)";
            }
            default 8;
          }

          // ip slb serverfarm * / real * / inservice
          leaf inservice {
            tailf:info "enable real server";
            type empty;
          }
        }
      }

      // ip slb vserver *
      list vserver {
        tailf:info "configure an SLB virtual server";
        tailf:cli-mode-name "config-slb-vserver";
        tailf:cli-diff-dependency "../serverfarm";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;identifier string";
          }
        }

        // ip slb vserver * / virtual
        container virtual {
          tailf:info "configure a virtual server";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf address {
            tailf:cli-drop-node-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;virtual server IP address";
            }
          }
          leaf-list protocols {
            tailf:cli-drop-node-name;
            tailf:cli-flat-list-syntax {
              tailf:cli-replace-all;
            }
            ordered-by user;
            type string {
              tailf:info "WORD;;protocol(s)";
            }
          }
        }

        // ip slb vserver * / serverfarm
        leaf serverfarm {
          tailf:info "Real server farm";
          tailf:non-strict-leafref {
            path "/ios:ip/slb/serverfarm/name";
          }
          type string {
            tailf:info "WORD;;Server farm name";
          }
        }

        // ip slb vserver * / no advertise
        // ip slb vserver * / advertise active
        choice advertise-choice {
          container advertise-enable {
            tailf:cli-drop-node-name;
            leaf advertise {
              tailf:cli-full-command;
              tailf:cli-full-no;
              tailf:cli-boolean-no;
              type boolean;
              default true;
            }
          }
          container advertise {
            tailf:info "advertise the virtual IP address";
            tailf:cli-incomplete-command;
            tailf:cli-incomplete-no;
            leaf active {
              tailf:info "only advertise when one or more reals in the serverfarm are available";
              type empty;
            }
          }
        }

        // ip slb vserver * / delay
        container delay {
          tailf:info "delay timer";
          leaf value {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<1-600>;;delay timer value (default is 10)";
              range "1..600";
            }
            default 10;
          }
        }

        // ip slb vserver * / replicate
        container replicate {
          tailf:info "replicate connection decisions to a remote fail-over SLB";

          // ip slb vserver * / replicate casa
          container casa {
            tailf:info "use CASA protocol to exchange connection replication info";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf listen-ip {
              tailf:cli-drop-node-name;
              tailf:cli-remove-before-change;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;local listen IP address";
              }
            }
            leaf remote-ip {
              tailf:cli-drop-node-name;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IP address of remote SLB device";
              }
            }
            leaf port {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<1-65535>;,communication port for replication messages";
                range "1..65535";
              }
            }
            //[ interval ] [password [ encrypt ] secret-string [ timeout ]]
          }
        }

        // ip slb vserver * / inservice
        container inservice {
          tailf:info "enable service for this virtual server";
          tailf:cli-delete-when-empty;
          tailf:cli-reset-container;
          presence true;
          leaf standby {
            tailf:info "SLB configuring HSRP standby";
            tailf:cli-remove-before-change;
            type string {
              tailf:info "WORD;;SLB HSRP standby group name";
            }
          }
        }
      }
    }

    // ip finger
    // ip finger rfc-compliant
    container finger {
      tailf:info "finger server";
      presence true;
      leaf rfc-compliant {
        tailf:info "Comply with RFC 1288";
        type empty;
      }
    }

    // ip tcp
    container tcp {
      tailf:info "Global TCP parameters";

      // ip tcp selective-ack
      leaf selective-ack {
        tailf:info "Enable TCP selective-ACK";
        type empty;
      }

      // ip tcp timestamp
      leaf timestamp {
        tailf:info "Enable TCP timestamp option";
        type empty;
      }

      // ip tcp mss
      leaf mss {
        tailf:info "TCP initial maximum segment size ";
        type uint16 {
          tailf:info "<68-10000>;;MSS";
          range "68..10000";
        }
      }

      // ip tcp path-mtu-discovery
      container path-mtu-discovery {
        tailf:info "Enable path-MTU discovery on new TCP connections";
        presence true;
        leaf age-timer {
          tailf:info "Set PMTU aging timer";
          type union {
            type enumeration {
              enum "infinite" {
                tailf:info "Disable pathmtu aging timer";
              }
            }
            type uint8 {
              tailf:info "<10-30>;;Aging time";
              range "10..30";
            }
          }
        }
      }

      // ip tcp window-size
      leaf window-size {
        tailf:info "TCP window size";
        type uint32 {
          tailf:info "<68-1073741823>;;Window size. Default 4128";
          range "68..1073741823";
        }
        default 4128;
      }

      // ip tcp chunk-size
      leaf chunk-size {
        tailf:info "TCP chunk size";
        type uint16 {
          tailf:info "<0-65535>;;Chunk size";
        }
        default 0;
      }

      // ip tcp queuemax
      leaf queuemax {
        tailf:info "Maximum queue of outgoing TCP packets";
        type uint8 {
          tailf:info "<5-50>;;Number of packets";
          range "5..50";
        }
        default 20;
      }

      // ip tcp synwait-time
      leaf synwait-time {
        tailf:info "Set time to wait on new TCP connections";
        type uint16 {
          tailf:info "<5-300>;;Wait time. Default 30";
          range "5..300";
        }
        default 30;
      }

      // ip tcp intercept
      container intercept {
        tailf:info "Enable TCP intercepting";

        // ip tcp intercept connection-timeout
        leaf connection-timeout {
          tailf:info "Specify timeout for connection info";
          type uint32 {
            tailf:info "<1-2147483>;;Timeout in seconds. Default 86400";
            range "1..2147483";
          }
          default 86400;
        }
      }
    }

    // ip telnet
    container telnet {
      tailf:info "Specify telnet options";

      // ip telnet tos
      leaf tos {
        tailf:info "Specify type of service";
        type string {
          tailf:info "<0-FF>;;TOS value";
        }
        default C0;
      }

      // ip telnet source-interface
      container source-interface {
        tailf:info "Specify source interface";
        uses interface-name-grouping;
      }

      // ip telnet quiet
      leaf quiet {
        tailf:info "Don't display non-error telnet messages";
        type empty;
      }
    }

    // ip ftp
    container ftp {
      tailf:info "FTP configuration commands";

      // no ip ftp passive
      leaf passive {
        tailf:info "Connect using passive mode";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // ip ftp source-interface
      container source-interface {
        tailf:info "Specify interface for source address in FTP connections";
        uses interface-name-grouping;
      }

      // ip ftp username
      leaf username {
        tailf:info "Specify username for FTP connections";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;Username";
        }
      }

      // ip ftp password
      container password {
        tailf:info "Specify password for FTP connections;";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        uses password-grouping {
          refine "secret" {
            cli:secret " ftp password ((?:[0-9] )?\\S+)";
          }
        }
      }
    }

    // ip tftp
    container tftp {
      tailf:info "tftp configuration commands";

      // ip tftp source-interface
      container source-interface {
        tailf:info "Specify interface for source address in TFTP connections";
        tailf:cli-compact-syntax;
        uses interface-name-grouping;
      }

      // ip tftp boot-interface
      container boot-interface {
        tailf:info "Force interface to use for TFTP booting";
        uses interface-name-grouping;
      }

      // ip tftp blocksize
      leaf blocksize {
        tailf:info "Specify TFTP client blocksize";
        type uint16 {
          tailf:info "<512-8192>;;blocksize value. Default 512";
          range "512..8192";
        }
        default 512;
      }
    }

    // ip ssh
    container ssh {
      tailf:info "Configure ssh options";

      // ip ssh time-out
      leaf time-out {
        tailf:info "Specify SSH time-out interval";
        type uint8 {
          tailf:info "<1-120>;;SSH time-out interval (secs)";
          range "1..120";
        }
        default 120; // NOTE: And default 30
      }

      // ip ssh port *
      list port {
        tailf:info "Starting (or only) Port number to listen on";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        key port;
        leaf port {
          type uint16 {
            tailf:info "<2000-10000>;;Starting Port number";
            range "2000..10000";
          }
        }
        leaf rotary {
          tailf:info "Starting (or only) rotary group number";
          type uint8 {
            tailf:info "<1-127>;;Low (or only) Rotary group numbe";
            range "1..127";
          }
        }
        leaf rotary-high {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<1-127>;;High Rotary group numbe";
            range "1..127";
          }
        }
      }

      // ip ssh break-string
      leaf break-string {
        tailf:info "break-string";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;Break string";
        }
        default "~break";
      }

      // ip ssh authentication-retries
      leaf authentication-retries {
        tailf:info "Specify number of authentication retries";
        type uint8 {
          tailf:info "<0-5>;;Number of authentication retries";
          range "0..5";
        }
        default 3; // NOTE: And default 4
      }

      // ip ssh dscp
      leaf dscp {
        tailf:info "IP DSCP value for SSH traffic";
        type uint8 {
          tailf:info "<0-63>;;ip dscp value (default value 0)";
          range "0..63";
        }
      }

      // ip ssh logging
      container logging {
        tailf:info "Configure logging for SSH";
        leaf events {
          tailf:info "Log SSH events";
          type empty;
        }
      }

      // ip ssh version
      leaf version {
        tailf:info "Specify protocol version supported";
        type uint8 {
          tailf:info "<1-2>;;Protocol version";
          range "1..2";
        }
      }

      // ip ssh precedence
      leaf precedence {
        tailf:info "IP Precedence value for SSH traffic";
        type uint8 {
          tailf:info "<0-7>;;ip precedence value (default value 0)";
          range "0..7";
        }
      }

      // ip ssh stricthostkeycheck
      leaf stricthostkeycheck {
        tailf:info "Enable SSH Server Authentication";
        type empty;
      }

      // ip ssh maxstartups
      leaf maxstartups {
        tailf:info "Maximum concurrent sessions allowed";
        type uint8 {
          tailf:info "<2-128>;;Number of connections to be accepted concurrently";
          range "2..128";
        }
      }

      // ip ssh source-interface
      container source-interface {
        tailf:info "Specify interface for source address in SSH connections";
        uses interface-name-grouping;
      }

      // ip ssh dh min size
      container dh {
        tailf:info "Diffie-Hellman";
        container min {
          tailf:info "minimum";
          leaf size {
            tailf:info "key size";
            type enumeration {
              enum 1024 {
                tailf:info "Diffie Group 1 1024-bit key";
              }
              enum 2048 {
                tailf:info "Diffie Group 14 2048-bit key";
              }
              enum 4096 {
                tailf:info "Diffie Group 16 4096-bit key";
              }
            }
            default 1024; // Note: ISR4331 (newer?) has default 2048
          }
        }
      }

      // ip ssh window-size
      leaf window-size {
        tailf:info "Specify SSH window-size";
        type uint32 {
          tailf:info "<8192-131072>;;SSH window-size in bits for SSH Client performance improvement";
          range "8192..131072";
        }
        default 8192;
      }

      // ip ssh server
      container server {
        tailf:info "Configuration for server";

        // no ip ssh server authenticate user publickey
        // no ip ssh server authenticate user keyboard
        // no ip ssh server authenticate user password
        container authenticate {
          tailf:info "Authentication configuration parameter";
          container user {
            tailf:info "User configuration";
            leaf publickey {
              tailf:info "Public key based authentication";
              tailf:cli-boolean-no;
              tailf:cli-full-command;
              type boolean;
              default true;
            }
            leaf keyboard {
              tailf:info "keyboard-interactive based authentication";
              tailf:cli-boolean-no;
              tailf:cli-full-command;
              type boolean;
              default true;
            }
            leaf password {
              tailf:info "Password based authentication";
              tailf:cli-boolean-no;
              tailf:cli-full-command;
              type boolean;
              default true;
            }
          }
        }

        // ip ssh server algorithm
        uses ip-ssh-algorithm-grouping;
      }

      // ip ssh client algorithm
      container client {
        tailf:info "Configuration for client";
        uses ip-ssh-algorithm-grouping;
      }

      // ip ssh rsa keypair-name
      container rsa {
        tailf:info "Configure RSA keypair name for SSH";
        leaf keypair-name {
          tailf:info "keypair-name";
          type string {
            tailf:info "WORD;;keypair name";
          }
        }
      }

      // ip ssh pubkey-chain
      container pubkey-chain {
        tailf:info "pubkey-chain";
        tailf:cli-add-mode;
        tailf:cli-mode-name "conf-ssh-pubkey";
        tailf:cli-full-command;

        // ip ssh pubkey-chain / username *
        list username {
          tailf:cli-mode-name "conf-ssh-pubkey-user";
          tailf:cli-exit-command "quit";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Name of the user";
            }
          }

          // ip ssh pubkey-chain / username * / key-hash *
          list key-hash {
            tailf:info "Key hash data";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key key-type;
            leaf key-type {
              type enumeration {
                enum ssh-rsa {
                  tailf:info "WORD;;key type ssh-rsa";
                }
              }
            }
            leaf key-name {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "WORD;;key hash data";
              }
            }
          }
        }
      }
    }

    // ip scp
    container scp {
      tailf:info "Scp commands";

      // ip scp server enable
      container server {
        tailf:info "Configure SCP server-side functionality";
        leaf enable {
          tailf:info "Enable server side of SCP";
          type empty;
        }
      }

      // ip scp remote-username
      leaf remote-username {
        tailf:info "Set system's username for scp";
        type string {
          tailf:info "WORD;;This system's username for remote commands";
        }
      }
    }

    // ip local pool *
    container local {
      tailf:info "Specify local options";

      // ip local policy route-map
      container policy {
        tailf:info "Enable policy routing";
        leaf route-map {
          tailf:info "Policy route map";
          type string {
            tailf:info "WORD;;Route map name";
          }
        }
      }

      // ip local pool *
      list pool {
        tailf:info "IP Local address pool lists";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-remove-before-change;
        key "id start";
        leaf id {
          type union {
            type string {
              tailf:info "WORD;;Create named local address pool";
            }
            type enumeration {
              enum "default" {
                tailf:info "Create default local address pool";
              }
            }
          }
        }
        leaf start {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;First IP address of range";
          }
        }
        leaf last {
          tailf:cli-drop-node-name;
          tailf:cli-optional-in-sequence;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Last IP address of range";
          }
        }
        leaf group {
          tailf:info "Create ip local pool group";
          tailf:cli-optional-in-sequence;
          type string {
            tailf:info "WORD;;Group name for this named local address pool";
          }
        }
        leaf cache-size {
          type uint8 {
            range "0..100";
          }
        }
      }
    }

    // ip default-gateway
    leaf default-gateway {
      tailf:info "Specify default gateway (if not routing IP)";
      type inet:ipv4-address {
        tailf:info "A.B.C.D;;IP address of default gateway";
      }
    }

    // ip default-network *
    leaf-list default-network {
      tailf:info "Flags networks as candidates for default routes";
      tailf:cli-list-syntax;
      type inet:ipv4-address {
        tailf:info "A.B.C.D;;IP address of default network";
      }
    }

    // no ip classless
    leaf classless {
      tailf:info "Follow classless routing forwarding rules";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
      default true;
    }

    // ip forward-protocol
    container forward-protocol {
      tailf:info "Controls forwarding of physical and directed IP broadcasts";

      // ip forward-protocol nd
      // no ip forward-protocol nd
      leaf nd {
        tailf:info "Sun's Network Disk protocol";
        tailf:cli-show-no;
        type empty;
      }

      // ip forward-protocol sdns
      leaf sdns {
        tailf:info "Network Security Protocol";
        tailf:cli-boolean-no;
        type boolean;
      }

      // ip forward-protocol turbo-flood
      leaf turbo-flood {
        tailf:info "Fast flooding of UDP broadcasts";
        tailf:cli-boolean-no;
        type boolean;
      }

      // ip forward-protocol spanning-tree
      container spanning-tree {
        tailf:info "Use transparent bridging to flood UDP broadcasts";
        presence true;
        leaf any-local-broadcast {
          tailf:info "Accept any local broadcast when flooding";
          type empty;
        }
      }

      // ip forward-protocol udp
      choice udp-choice {

        // no ip forward-protocol udp
        leaf udp {
          tailf:info "Packets to a specific UDP port";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }

        // OR:
        // ip forward-protocol udp X    = ip forward-protocol udp X
        // no ip forward-protocol udp Y = ip forward-protocol udp Y disabled
        container udp-conf {
          tailf:cli-drop-node-name;
          container udp {
            tailf:info "Packets to a specific UDP port";
            tailf:cli-incomplete-command;
            tailf:cli-incomplete-no;
            list service {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-suppress-list-no;
              key name;
              leaf name {
                type string {
                  tailf:info "WORD;;Port or UDP service name";
                }
              }
              leaf disabled {
                tailf:info "service disabled";
                type empty;
              }
            }
          }
        }
      }
    }

    // ip rcmd
    container rcmd {
      tailf:info "Rcmd commands";

      // no ip rcmd domain-lookup
      leaf domain-lookup {
        tailf:info "Enable IP DNS queries for Rcmd";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // ip rcmd rcp-enable
      leaf rcp-enable {
        tailf:info "Enable server side of RCP";
        type empty;
      }

      // ip rcmd rsh-enable
      leaf rsh-enable {
        tailf:info "Enable server side of RSH";
        type empty;
      }

      // ip rcmd remote-host *
      list remote-host {
        tailf:info "Set host+user equivalence";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "local-username host remote-username";
        leaf local-username {
          type string {
            tailf:info "WORD;;Local username";
          }
        }
        leaf host {
          type inet:host {
            tailf:info "Hostname or A.B.C.D;;Remote hostname or IP address";
          }
        }
        leaf remote-username {
          type string {
            tailf:info "WORD;;Remote username";
          }
        }
        leaf enable {
          tailf:info "Allow enable-mode commands";
          type empty;
        }
      }

      // ip rcmd source-interface
      container source-interface {
        tailf:info "Specify interface for source address in rcmd connections";
        uses interface-name-grouping;
      }
    }

    // ip http
    container http {
      tailf:info "HTTP server configuration";

      // ip http port
      leaf port {
        tailf:info "Set http server port";
        type uint16 {
          tailf:info "<80|1024-65535>;;Port number range. Default 80";
          range "80|1024..65535";
        }
      }

      // ip http server
      leaf server {
        tailf:info "Enable http server";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
      }

      // ip http access-class
      leaf access-class {
        tailf:info "Restrict http server access by access-class";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<1-99>;;Access list number";
          range "1..99";
        }
      }

      // ip http authentication
      container authentication {
        tailf:info "Set http server authentication method";
        choice authentication-choice {

          // ip http authentication aaa
          container aaa {
            tailf:info "Use AAA access control methods";
            presence true;

            // ip http authentication aaa login-authentication
            leaf login-authentication {
              tailf:info "Set method list for login authentication";
              tailf:cli-diff-dependency "../../../../../aaa/authentication/login";
              type string {
                tailf:info "WORD;;Use an authentication list with this name.";
              }
            }

            // ip http authentication aaa exec-authorization
            leaf exec-authorization {
              tailf:info "Set method list for exec authorization";
              tailf:cli-diff-dependency "../../../../../aaa/authorization/exec";
              type string {
                tailf:info "WORD;;Use an authorization list with this name.";
              }
            }
          }

          // ip http authentication local
          leaf local {
            tailf:info "Use local username and passwords";
            tailf:cli-full-command;
            type empty;
          }
        }
      }

      // no ip http ctc authentication
      container ctc {
        tailf:info "ctc configuration";
        leaf authentication {
          tailf:info "Enable ctc authentication";
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }
      }

      // ip http secure-server
      leaf secure-server {
        tailf:info "Enable HTTP secure server";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
      }

      // ip http secure-ciphersuite *
      leaf-list secure-ciphersuite {
        tailf:info "Set http secure server ciphersuite";
        tailf:cli-flat-list-syntax;
        tailf:cli-replace-all;
        ordered-by user;
        type enumeration {
          enum 3des-ede-cbc-sha {
            tailf:info "Encryption type tls_rsa_with_3des_ede_cbc_sha ciphersuite";
          }
          enum aes-128-cbc-sha {
            tailf:info "Encryption type tls_rsa_with_aes_cbc_128_sha ciphersuite";
          }
          enum aes-256-cbc-sha {
            tailf:info "Encryption type tls_rsa_with_aes_cbc_256_sha ciphersuite";
          }
          enum dhe-aes-128-cbc-sha {
            tailf:info "Encryption type tls_dhe_rsa_with_aes_128_cbc_sha ciphersuite";
          }
          enum dhe-aes-cbc-sha2 {
            tailf:info "Encryption type tls_dhe_rsa_with_aes_cbc_sha2(TLS1.2 & above) ciphersuite";
          }
          enum dhe-aes-gcm-sha2 {
            tailf:info "Encryption type tls_dhe_rsa_with_aes_gcm_sha2(TLS1.2 & above) ciphersuite";
          }
          enum ecdhe-rsa-3des-ede-cbc-sha {
            tailf:info "Encryption type tls_ecdhe_rsa_3des_ede_cbc_sha ciphersuite";
          }
          enum ecdhe-rsa-aes-cbc-sha2 {
            tailf:info "Encryption type tls_ecdhe_rsa_aes_cbc_sha2(TLS1.2 & above) ciphersuite";
          }
          enum ecdhe-rsa-aes-gcm-sha2 {
            tailf:info "Encryption type tls_ecdhe_rsa_aes_gcm_sha2(TLS1.2 & above) ciphersuite";
          }
          enum rsa-aes-cbc-sha2 {
            tailf:info "Encryption type tls_rsa_with_aes_cbc_sha2(TLS1.2 & above) ciphersuite";
          }
          enum rsa-aes-gcm-sha2 {
            tailf:info "Encryption type tls_rsa_with_aes_gcm_sha2(TLS1.2 & above) ciphersuite";
          }
        }
      }

      // ip http secure-active-session-modules
      container secure-active-session-modules {
        tailf:info "Set up active http secure server session modules";
        choice modules-choice {
          leaf name {
            tailf:cli-drop-node-name;
            tailf:cli-disallow-value "all|none";
            type string {
              tailf:info "WORD;;Session module list name to activate";
            }
          }
          leaf all {
            tailf:info "Activate all session modules";
            type empty;
          }
          leaf none {
            tailf:info "Deactivate all session modules";
            type empty;
          }
          default all;
        }
      }

      // ip http active-session-modules
      container active-session-modules {
        tailf:info "Set up active http server session modules";
        choice modules-choice {
          leaf name {
            tailf:cli-drop-node-name;
            tailf:cli-disallow-value "all|none";
            type string {
              tailf:info "WORD;;Session module list name to activate";
            }
          }
          leaf all {
            tailf:info "Activate all session modules";
            type empty;
          }
          leaf none {
            tailf:info "Deactivate all session modules";
            type empty;
          }
          default all;
        }
      }

      // ip http max-connections
      leaf max-connections {
        tailf:info "Set maximum number of concurrent http server connections";
        type uint8 {
          tailf:info "<1-32>;;Maximum number of concurrent http server connections (default 5)";
          range "1..32";
        }
        default 5;
      }

      // ip http timeout-policy idle
      container timeout-policy {
        tailf:info "Set http server time-out policy parameters";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf idle {
          tailf:info "Idle time-out of a http server connection in seconds";
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<1-600>;;Connection idle time-out value in seconds";
            range "1..600";
          }
        }
        leaf life {
          tailf:info "Life time of a http server connection in seconds";
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<1-86400>;;Connection life time value in seconds";
            range "1..86400";
          }
        }
        leaf requests {
          tailf:info "Maximum number of requests allowed on a http server connection";
          type uint32 {
            tailf:info "<1-86400>;;Maximum number of requests allowed on a http server connection";
            range "1..86400";
          }
        }
      }

      // ip http timeout-policy linger
      container timeout-policy-linger {
        tailf:cli-drop-node-name;
        container timeout-policy {
          tailf:info "Set http server time-out policy parameters";
          leaf linger {
            tailf:info "Linger time of a http server connection in seconds";
            type uint16 {
              tailf:info "<1-300>;;HTTP server connection linger time value (1-60) in seconds";
              range "1..300";
            }
          }
        }
      }

      // ip http client
      container client {
        tailf:info "Set http client parameters";

        // ip http client source-interface
        container source-interface {
          tailf:info "Specify interface for source address in all HTTP(S) client connections";
          uses interface-name-grouping;
        }

        // ip http client username
        leaf username {
          tailf:info "Specify username for HTTP(S) file system client connections";
          tailf:cli-no-value-on-delete;
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;username";
          }
        }

        // ip http client password
        container password {
          tailf:info "Specify the password for the user";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf type {
            tailf:cli-drop-node-name;
            tailf:cli-no-value-on-delete;
            tailf:cli-optional-in-sequence;
            tailf:cli-incomplete-command;
            type enumeration {
              enum "0" {
                tailf:info "Specifies an UNENCRYPTED password will follow";
              }
              enum "7" {
                tailf:info "Specifies a HIDDEN password will follow";
              }
            }
          }
          leaf secret {
            tailf:cli-drop-node-name;
            tailf:cli-reset-container;
            tailf:cli-no-value-on-delete;
            tailf:cli-full-command;
            tailf:cli-disallow-value "0|7";
            cli:secret " password <SECRET>";
            type NEDCOM_SECRET_TYPE {
              tailf:info "LINE;;The UNENCRYPTED (cleartext) client password";
            }
          }
        }

        // ip http client proxy-server
        container proxy-server {
          tailf:info "Specify proxy server name for HTTP file system client connections";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf address {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type inet:host {
              tailf:info "WORD;;Proxy server name";
            }
          }
          leaf proxy-port {
            tailf:info "Specify proxy port number for HTTP file system client connections";
            type uint16 {
              tailf:info "<1-65535>;;Proxy port number";
              range "1..65535";
            }
          }
        }
      }

      // ip http path
      leaf path {
        tailf:info "Set base path for HTML";
        type string {
          tailf:info "WORD;;path name for HTML";
        }
      }

      // ip http help-path
      leaf help-path {
        tailf:info "HTTP help root URL";
        type string {
          tailf:info "WORD;;root URL for help pages";
        }
      }
    }

    // ip ospf name-lookup
    container ospf {
      tailf:info "OSPF";
      leaf name-lookup {
        tailf:info "Display OSPF router ids as DNS names";
        type empty;
      }
    }

    // ip bgp-community new-format
    container bgp-community {
      tailf:info "format for BGP community";
      leaf new-format {
        tailf:info "select aa:nn format for BGP community";
        type empty;
      }
    }

    // ip community-list
    container community-list {
      tailf:info "Add a community list entry";

      // ip community-list *
      list number {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key no;
        leaf no {
          type union {
            type uint16 {
              tailf:info "<1-99>;;Community list number (standard)";
              range "1..99";
            }
            type uint16 {
              tailf:info "<100-500>;;Community list number (expanded)";
              range "100..500";
            }
          }
        }
        uses ip-community-list-grouping;
      }

      // ip community-list standard *
      list standard {
        tailf:info "Add a standard community-list entry";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        ios:redeploy-with-change "no  :: (ip community-list standard \\S+)";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Community list name";
          }
        }
        uses ip-community-list-grouping;
      }

      // ip community-list expanded *
      list expanded {
        tailf:info "Add an expanded community-list entry";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        ios:redeploy-with-change "no  :: (ip community-list expanded \\S+)";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Community list name";
          }
        }
        uses ip-community-list-grouping;
      }
    }

    // ip extcommunity-list
    container extcommunity-list {
      tailf:info "Add a extended community list entry";

      // ip extcommunity-list *
      list number {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key no;
        leaf no {
          type union {
            type uint16 {
              tailf:info "<1-99>;;Extended Community list number (standard)";
              range "1..99";
            }
            type uint16 {
              tailf:info "<100-500>;;Extended Community list number (expanded)";
              range "100..500";
            }
          }
        }
        uses ip-extcommunity-list-grouping;
      }

      // ip extcommunity-list standard
      container standard {
        tailf:info "Add a standard community-list entry";

        // ip extcommunity-list standard *
        list no-mode-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Extended community-list name";
            }
          }
          uses ip-extcommunity-list-grouping;
        }

        // ip extcommunity-list standard * /
        list mode-list {
          tailf:cli-drop-node-name;
          tailf:cli-mode-name "config-extcomm-list";
          tailf:cli-full-command;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Extended community-list name";
            }
          }
          list entry {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key id;
            leaf id {
              type uint32 {
                tailf:info "<1-2147483647>;;Sequence Number";
                range "1..2147483647";
              }
            }
            leaf expr {
              tailf:cli-drop-node-name;
              tailf:cli-multi-value;
              type string {
                tailf:info "<RULE>;;deny <LINE> | permit <LINE>";
                pattern "(permit.*)|(deny.*)";
              }
            }
          }
        }
      }

      // ip extcommunity-list expanded
      container expanded {
        tailf:info "Add an expanded community-list entry";

        // ip extcommunity-list expanded *
        list no-mode-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Extended community-list name";
            }
          }
          uses ip-extcommunity-list-grouping;
        }

        // ip extcommunity-list expanded * /
        list mode-list {
          tailf:cli-drop-node-name;
          tailf:cli-mode-name "config-extcomm-list";
          tailf:cli-full-command;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Extended community-list name";
            }
          }
          list entry {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key id;
            leaf id {
              type uint32 {
                tailf:info "<1-2147483647>;;Sequence Number";
                range "1..2147483647";
              }
            }
            leaf expr {
              tailf:cli-drop-node-name;
              tailf:cli-multi-value;
              type string {
                tailf:info "<RULE>;;deny <LINE> | permit <LINE>";
                pattern "(permit.*)|(deny.*)";
              }
            }
          }
        }
      }
    }

    // ip policy-list *
    list policy-list {
      tailf:info "Match IP policy list";
      tailf:cli-mode-name "config-policy-list";
      key "name operation";
      leaf name {
        type string {
          tailf:info "IP Policy list name";
        }
      }
      leaf operation {
        type enumeration {
          enum deny {
            tailf:info "IP Policy list deny";
          }
          enum permit {
            tailf:info "IP Policy list permit";
          }
        }
      }

      // ip policy-list * / match
      container match {
        tailf:info "Match values from routing table";

        // ip policy-list * / match as-path *
        leaf-list as-path {
          tailf:info "Match BGP AS path list";
          tailf:cli-flat-list-syntax;
          ordered-by user;
          type string {
            tailf:info "WORD;;Access-list number or name";
          }
        }

        // ip policy-list * / match community *
        leaf-list community {
          tailf:info "Match BGP community list";
          tailf:cli-flat-list-syntax;
          ordered-by user;
          type string {
            tailf:info "WORD;;Community-list number or name";
          }
        }

        // ip policy-list * / match route-type *
        leaf-list route-type {
          tailf:info "Match route-type of route";
          tailf:cli-flat-list-syntax;
          type enumeration {
            enum local {
              tailf:info "locally generated route";
            }
            enum internal {
              tailf:info "internal route (including OSPF intra/inter area)";
            }
            enum level-1 {
              tailf:info "IS-IS level-1 route";
            }
            enum level-2 {
              tailf:info "IS-IS level-2 route";
            }
            enum external {
              tailf:info "external route (BGP, EIGRP and OSPF type 1/2)";
            }
            enum nssa-external {
              tailf:info "nssa-external route (OSPF type 1/2)";
            }
          }
        }

        // ip policy-list * / match ip
        container ip {
          tailf:info "IP specific information";

          // ip policy-list * / match ip address
          container address {
            tailf:info "Match address of route or match packet";

            // ip policy-list * / match ip address prefix-list *
            leaf-list prefix-list {
              tailf:info "Match entries of prefix-lists";
              tailf:cli-flat-list-syntax;
              tailf:non-strict-leafref {
                path "../../../../../../ip/prefix-list/prefixes/name";
              }
              type string {
                tailf:info "WORD;;IP prefix-list name";
              }
            }
          }
        }
      }
    }

    // ip as-path
    container as-path {
      tailf:info "BGP autonomous system path filter";

      // ip as-path access-list *
      list access-list {
        tailf:info "Specify an access list number";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Access-list number or name";
          }
        }
        list as-path-rule {
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-drop-node-name;
          tailf:cli-compact-syntax;
          tailf:cli-show-long-obu-diffs;
          ordered-by user;
          key "operation rule";
          leaf operation {
            type enumeration {
              enum deny {
                tailf:code-name "operation_deny";
                tailf:info "Specify packets to reject";
              }
              enum permit {
                tailf:code-name "operation_permit";
                tailf:info "Specify packets to forward";
              }
            }
          }
          leaf rule {
            tailf:cli-multi-word-key;
            tailf:cli-full-command;
            type string {
              tailf:info "LINE;;A regular-expression to match BGP AS paths.";
            }
          }
        }
      }
    }

    // ip flow-capture
    container flow-capture {
      tailf:info "Capture additional netflow information";

      // ip flow-capture icmp
      leaf icmp {
        tailf:info "Capture the ICMP type and code";
        type empty;
      }

      // ip flow-capture ip-id
      leaf ip-id {
        tailf:info "Capture the IP id";
        type empty;
      }
    }

    // ip flow-egress input-interface
    container flow-egress {
      tailf:info "Configure netflow egress";
      leaf input-interface {
        tailf:info "Use input interface as part of flow key";
        type empty;
      }
    }

    // ip flow-cache
    container flow-cache {
      tailf:info "Configure netflow cache parameters";
      // ip flow-cache entries
      leaf entries {
        tailf:info "Specify the number of entries in the flow cache";
        type uint32 {
          tailf:info "<1024-524288>;;Entries";
          range "1024..524288";
        }
      }
      // ip flow-cache timeout
      container timeout {
        tailf:info "Specify flow cache timeout parameters";
        leaf inactive {
          tailf:info "Specify the inactive flow timeout";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<10-600>;;Timeout in seconds";
            range "10..600";
          }
        }
        leaf active {
          tailf:info "Specify the active flow timeout";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<1-60>;;Timeout in minutes";
            range "1..60";
          }
        }
      }
    }

    // ip flow-export
    container flow-export {
      tailf:info "Specify host/port to send flow statistics";

      // ip flow-export source
      container source {
        tailf:info "Specify the interface for source address";
        uses interface-name-grouping;
      }

      // ip flow-export version
      container version {
        tailf:info "Specify the version number";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf version {
          tailf:cli-drop-node-name;
          tailf:ned-ignore-compare-config;
          type enumeration {
            enum "1";
            enum "5";
            enum "9";
          }
        }
        choice as-choice {
          leaf origin-as {
            tailf:info "record origin AS";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          leaf peer-as {
            tailf:info "record peer AS";
            tailf:cli-optional-in-sequence;
            type empty;
          }
        }
        leaf bgp-nexthop {
          tailf:info "record BGP NextHop";
          type empty;
        }
      }

      // ip flow-export template
      container template {
        tailf:info "Specify the template specific configurations";
        tailf:cli-diff-dependency "../version";

        // ip flow-export template options
        container options {
          tailf:info "Specify the template option";

          // ip flow-export template options export-stats
          leaf export-stats {
            tailf:info "Specify the template option export statistics";
            type empty;
          }

          // ip flow-export template options timeout-rate
          leaf timeout-rate {
            tailf:info "Specify the time before the options are resent";
            type uint16 {
              tailf:info "<1-3600>;;Timeout in minutes (default 30 minutes)";
              range "1..3600";
            }
            default 30;
          }

          // ip flow-export template options refresh-rate
          leaf refresh-rate {
            tailf:info "Specify the number of export packets before the options are resent";
            type uint16 {
              tailf:info "<1-600>;;refresh rate in export packets (default 20 packets)";
              range "1..600";
            }
            default 20;
          }
        }

        // ip flow-export template timeout-rate
        leaf timeout-rate {
          tailf:info "Specify the time before template is resent";
          type uint16 {
            tailf:info "<1-3600>;;Timeout in minutes (default 30 minutes)";
            range "1..3600";
          }
          default 30;
        }

        // ip flow-export template refresh-rate
        leaf refresh-rate {
          tailf:info "Specify the number of export packets before template is resent";
          type uint16 {
            tailf:info "<1-600>;;refresh rate in export packets (default 20 packets)";
            range "1..600";
          }
          default 20;
        }
      }

      // ip flow-export destination *
      list destination {
        tailf:info "Specify the Destination IP address";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        max-elements 2;
        key "ip port";
        leaf ip {
          type inet:host {
            tailf:info "Hostname or A.B.C.D;;Destination IP address";
          }
        }
        leaf port {
          type uint16 {
            tailf:info "<1-65535>;;UDP port number";
            range "1..65535";
          }
        }
      }

      // ip flow-export destination * * vrf *
      container destination-vrf {
        tailf:cli-drop-node-name;
        list destination {
          tailf:info "Specify the Destination IP address";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          max-elements 2;
          key "ip port vrf";
          leaf ip {
            type inet:host {
              tailf:info "Hostname or A.B.C.D;;Destination IP address";
            }
          }
          leaf port {
            type uint16 {
              tailf:info "<1-65535>;;UDP port number";
              range "1..65535";
            }
          }
          leaf vrf {
            tailf:info "Set VRF option";
            tailf:cli-expose-key-name;
            tailf:cli-diff-dependency "../../../../vrf";
            tailf:cli-diff-dependency "../../../../../vrf/definition";
            type string {
              tailf:info "WORD;;VPN Routing/Forwarding instance name";
            }
          }
        }
      }
    }

    // ip flow-aggregation
    container flow-aggregation {
      tailf:info "Configure flow aggregation";

      // ip flow-aggregation cache *
      list cache {
        tailf:info "Create flow aggregation cache or enter flow-cache command mode";
        tailf:cli-mode-name "config-flow-cache";
        key name;
        leaf name {
          type string;
        }
        // ip flow-aggregation cache * / cache
        container cache {
          tailf:info "Configure netflow cache parameters";
          container timeout {
            tailf:info "Specify flow cache timeout parameters";
            leaf active {
              tailf:info "Specify the active flow timeout";
              type uint8 {
                tailf:info "<1-60>;;Timeout in minutes";
                range "1..60";
              }
            }
          }
        }
        // ip flow-aggregation cache * / export
        container export {
          tailf:info "Specify host/port to send flow statistics";
          list destination {
            tailf:info "Specify the Destination IP address";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-incomplete-command;
            key address;
            leaf address {
              type inet:host {
                tailf:info "Hostname or A.B.C.D;;Destination IP addres";
              }
            }
            leaf port {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<1-65535>;;UDP/SCTP port number";
                range "1..65535";
              }
            }
          }
        }
      }
    }

    // ip dns
    container dns {
      tailf:info "Configure DNS server for a zone";

      // ip dns view *
      list view {
        tailf:info "Configure a DNS view";
        tailf:cli-mode-name "cfg-dns-view";
        tailf:cli-recursive-delete;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;View name";
          }
        }
        uses ip-dns-view-grouping;
      }

      // ip dns view vrf * *
      container view-vrf {
        tailf:cli-drop-node-name;
        list view {
          tailf:info "Configure a DNS view";
          tailf:cli-mode-name "cfg-dns-view";
          tailf:cli-recursive-delete;
          key "vrf name";
          leaf vrf {
            tailf:info "Specify a VRF";
            tailf:cli-expose-key-name;
            tailf:cli-diff-dependency "../../../../../ip/vrf";
            tailf:cli-diff-dependency "../../../../../vrf/definition";
            type string {
              tailf:info "WORD;;VRF name";
            }
          }
          leaf name {
            type string {
              tailf:info "WORD;;View name";
            }
          }
          uses ip-dns-view-grouping;
        }
      }

      // ip dns view-list *
      list view-list {
        tailf:info "Configure a DNS view-list";
        tailf:cli-mode-name "cfg-dns-view-list";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;View-list name";
          }
        }

        // ip dns view-list * / view *
        list view {
          tailf:cli-mode-name "cfg-dns-view-list-member";
          tailf:cli-incomplete-command;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;View name";
            }
          }
          leaf order {
            tailf:cli-drop-node-name;
            tailf:cli-hide-in-submode;
            type uint32 {
              tailf:info "<1-2147483647>;;Evaluation order";
              range "1..2147483647";
            }
          }

          // ip dns view-list * / view * / restrict
          container restrict {
            tailf:info "Configure view usage restrictions";

            // ip dns view-list * / view * / restrict name-group
            leaf name-group {
              tailf:info "Restrict to users matching an ip dns name-list";
              type uint32 {
                tailf:info "<1-2147483647>;;IP DNS access-list number";
                range "1..2147483647";
              }
            }

            // ip dns view-list * / view * / restrict authenticate
            leaf authenticate {
              tailf:info "Restrict to authenticated users";
              type empty;
            }
          }
        }

        // ip dns view-list * / view vrf * *
        container view-vrf {
          tailf:cli-drop-node-name;
          list view {
            tailf:cli-mode-name "cfg-dns-view-list-member";
            tailf:cli-incomplete-command;
            key "vrf name";
            leaf vrf {
              tailf:info "Specify vrf";
              tailf:cli-expose-key-name;
              tailf:cli-diff-dependency "../../../../../../ip/vrf";
              tailf:cli-diff-dependency "../../../../../../vrf/definition";
              type string {
                tailf:info "WORD;;vrf name";
              }
            }
            leaf name {
              type string {
                tailf:info "WORD;;View name";
              }
            }
            leaf order {
              tailf:cli-drop-node-name;
              tailf:cli-hide-in-submode;
              type uint32 {
                tailf:info "<1-2147483647>;;Evaluation order";
                range "1..2147483647";
              }
            }

            // ip dns view-list * / view vrf * * / restrict
            container restrict {
              tailf:info "Configure view usage restrictions";

              // ip dns view-list * / view vrf * * / restrict name-group
              leaf name-group {
                tailf:info "Restrict to users matching an ip dns name-list";
                type uint32 {
                  tailf:info "<1-2147483647>;;IP DNS access-list number";
                  range "1..2147483647";
                }
              }

              // ip dns view-list * / view vrf * * / restrict authenticate
              leaf authenticate {
                tailf:info "Restrict to authenticated users";
                type empty;
              }
            }
          }
        }
      }

      // ip dns name-list *
      list name-list {
        tailf:info "Regular expression name-list";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          type uint16 {
            tailf:info "<1-500>;;Regular expression name-list number";
            range "1..500";
          }
        }
        list regexp-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-show-long-obu-diffs;
          ordered-by user;
          key regexp;
          leaf regexp {
            tailf:cli-multi-word-key;
            type string {
              tailf:info "LINE;;deny|permit <regular-expression to match hostnames>";
              pattern '(permit .*)|(deny .*)';
            }
          }
        }
      }

      // ip dns server
      container server {
        tailf:info "Enable DNS server";
        tailf:cli-display-separated;
        presence true;

        // ip dns server view-group
        leaf view-group {
          tailf:info "Configure a DNS view-list for global use on this system";
          tailf:non-strict-leafref {
            path "../../../../ip/dns/view-list/name";
          }
          type string {
            tailf:info "WORD;;View-list name";
          }
        }
      }

      // ip dns spoofing
      container spoofing {
        tailf:info "Configure DNS spoofing";
        presence true;
      }
    }

    // ip mobile
    container mobile {
      tailf:info "Enable Mobile IP services";

      // ip mobile secure
      container secure {
        tailf:info "Security association";

        // ip mobile secure home-agent *
        list home-agent {
          tailf:info "Home agent security association";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-all-siblings;
          }
          key lower-address;
          leaf lower-address {
            tailf:cli-diff-dependency "../../../../../router/mobile";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP address (lower range)";
            }
          }
          leaf upper-address {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Upper range IP address for security";
            }
          }
          choice spi-choice {
            // ip mobile secure home-agent * spi
            case single-spi {
              container spi {
                tailf:info "Security parameter index - bidirectional";
                tailf:cli-flatten-container;
                tailf:cli-compact-syntax;
                uses mobile-ip-spi-grouping;
              }
            }
            // ip mobile secure home-agent * lower-spi
            case range-spi {
              container inbound-spi {
                tailf:info "Security parameter index - inbound";
                tailf:cli-flatten-container;
                tailf:cli-compact-syntax;
                uses mobile-ip-spi-grouping;
              }
              container outbound-spi {
                tailf:info "Security parameter index - outbound";
                tailf:cli-flatten-container;
                tailf:cli-compact-syntax;
                uses mobile-ip-spi-grouping;
              }
            }
          }
          // ip mobile secure home-agent * key
          container key {
            tailf:info "Security key";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            choice key-choice {
              leaf ascii {
                tailf:info "Key entered in ASCII string";
                type string {
                  tailf:info "WORD;;Key entered in ASCII";
                }
              }
              leaf hex {
                tailf:info "Key entered in hex string";
                type string {
                  tailf:info "Hex-string;;Hex string";
                }
              }
            }
          }
          // ip mobile secure home-agent * algorithm
          container algorithm {
            tailf:cli-break-sequence-commands;
            tailf:info "Authentication algorithm";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            choice algorithm-choice {
              leaf hmac-md5 {
                tailf:info "HMAC MD5 authentication";
                type empty;
              }
              container md5 {
                tailf:info "Keyed MD5 authentication";
                tailf:cli-flatten-container;
                tailf:cli-compact-syntax;
                container mode {
                  tailf:info "Authentication mode";
                  tailf:cli-flatten-container;
                  tailf:cli-compact-syntax;
                  leaf prefix-suffix {
                    tailf:info "Prefix-suffix mode";
                    type empty;
                  }
                }
              }
            }
          }
          // ip mobile secure home-agent * ignore-spi
          leaf ignore-spi {
            tailf:info "Ignore SPI for Authentication";
            type empty;
          }
        }
      }

      // ip mobile router
      container router {
        tailf:info "Mobile Router commands";
        tailf:cli-add-mode;
        tailf:cli-mode-name "mobile-router";
        tailf:cli-diff-dependency "../../../router/mobile";
        //when "../../../router/mobile";
        presence true;

        // ip mobile router / address
        container address {
          tailf:info "Mobile router's home address";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf ipv4-address {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            tailf:cli-diff-dependency "../../../../../router/mobile";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP address";
            }
          }
          leaf ipv4-mask {
            tailf:cli-drop-node-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Home network mask";
            }
          }
        }

        // ip mobile router / collocated single-tunnel
        container collocated {
          tailf:info "Collocated CoA parameters";
          leaf single-tunnel {
            tailf:info "Optimized tunneling between MR and HA";
            tailf:cli-diff-dependency "../../../../../router/mobile";
            type empty;
          }
        }

        // ip mobile router / home-agent *
        list home-agent {
          tailf:info "Mobile router's home agent";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-diff-dependency "../../../../router/mobile";
          key address;
          leaf address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP address";
            }
          }
          // ip mobile router / home-agent * priority
          leaf priority {
            tailf:info "Priority level";
            type uint8 {
              tailf:info "<0-255>;;Priority value (default is 100)";
            }
            default 100;
          }
        }

        // ip mobile router / mobile-network *
        list mobile-network {
          tailf:info "Mobile router's mobile network";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            tailf:cli-diff-dependency "../../../../../interface";
            type string {
              tailf:info "WORD;;Interface Name";
            }
          }
          // ip mobile router / mobile-network * policy mobile-map
          container policy {
            tailf:info "Enable MIP policy routing";
            leaf mobile-map {
              tailf:info "Apply mobile-map dyn route-map";
              type string {
                tailf:info "WORD;;mobile-map tag";
              }
            }
          }
        }

        // ip mobile router / register
        container register {
          tailf:info "Registration settings";

          // ip mobile router / register extend
          container extend {
            tailf:info "Extend registration lifetime";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf expire {
              tailf:info "Reregister before expiration";
              tailf:cli-incomplete-command;
              tailf:cli-diff-dependency "../../../../../../router/mobile";
              type uint16 {
                tailf:info "<1-3600>;;Number of seconds before expiration";
                range "1..3600";
              }
            }
            leaf retry {
              tailf:info "Number of attempts to extend registration";
              tailf:cli-incomplete-command;
              type uint8 {
                tailf:info "<0-10>;;Stop after number of retries attempted";
                range "0..10";
              }
            }
            leaf interval {
              tailf:info "Interval between retries";
              type uint16 {
                tailf:info "<1-3600>;;Number of seconds between attempts";
                range "1..3600";
              }
            }
            leaf reverse-tunnel {
              type empty;
            }
          }
        }

        // ip mobile router / reverse-tunnel
        leaf reverse-tunnel {
          tailf:info "Reverse Tunnel requested";
          type empty;
        }

        // ip mobile router / tunnel mode gre
        container tunnel {
          tailf:info "Tunnel parameters";
          container mode {
            tailf:info "Tunnel mode";
            leaf gre {
              tailf:info "GRE encapsulation";
              type empty;
            }
          }
        }

        // ip mobile router / template tunnel
        container template {
          tailf:info "Configure a tunnel template for tunnels to the Home Agent";
          leaf Tunnel {
            tailf:info "Tunnel interface";
            tailf:cli-allow-join-with-value {
              tailf:cli-display-joined;
            }
            type uint32 {
              tailf:info "<0-2147483647>;;Tunnel interface number";
            }
          }
        }
      }
    }

    // ip pim
    container pim {
      tailf:info "PIM global commands";
      tailf:cli-diff-dependency "../../interface";

      uses ip-pim-grouping;

      // ip pim vrf *
      list vrf {
        tailf:info "Select VPN Routing/Forwarding instance";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key id;
        leaf id {
          tailf:cli-diff-dependency "../../../../ip/vrf";
          tailf:cli-diff-dependency "../../../../vrf/definition";
          type string {
            tailf:info "WORD;;VPN Routing/Forwarding instance name";
          }
        }
        uses ip-pim-grouping;
      }
    }

    // ip rsvp
    container rsvp {
      tailf:info "Configure static RSVP information";

      // ip rsvp signalling
      container signalling {
        tailf:info "RSVP Signalling";

        // ip rsvp signalling refresh
        container refresh {
          tailf:info "Configure RSVP refresh behavior";

          // ip rsvp signalling refresh reduction ack-delay
          container reduction-conf {
            tailf:cli-drop-node-name;
            container reduction {
              tailf:info "Configure refresh reduction";
              tailf:cli-incomplete-command;
              tailf:cli-incomplete-no;
              leaf ack-delay {
                tailf:info "Time to wait to accumulate ACKs (msecs). Default 250";
                type uint16 {
                  tailf:info "<100-10000>;;ACK delay (msecs)";
                  range "100..10000";
                }
                default 250;
              }
            }
          }

          // ip rsvp signalling refresh reduction
          leaf reduction {
            tailf:info "Configure refresh reduction";
            tailf:cli-full-command;
            type empty;
          }
        }

        // ip rsvp signalling hello
        container hello-enable {
          tailf:cli-drop-node-name;
          leaf hello {
            tailf:info "Enable neighbor-down detection";
            type empty;
          }
        }

        // ip rsvp signalling hello bfd
        container hello-bfd {
          tailf:cli-drop-node-name;
          container hello {
            tailf:info "Enable neighbor-down detection";
            tailf:cli-incomplete-command;
            tailf:cli-incomplete-no;
            leaf bfd {
              tailf:info "Enable BFD detection for fast-reroute";
              type empty;
            }
          }
        }

        // ip rsvp signalling hello graceful-restart
        container hello {
          tailf:info "Enable neighbor-down detection";
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          container graceful-restart {
            tailf:info "Configure RSVP Graceful Restart";

            // ip rsvp signalling hello graceful-restart mode
            leaf mode {
              tailf:info "Select Graceful Restart capabilities";
              type enumeration {
                enum full {
                  tailf:info "Capable of recovering self, and helping neighbor recover";
                }
                enum help-neighbor {
                  tailf:info "Capable of helping neighbor recover";
                }
              }
            }

            // ip rsvp signalling hello graceful-restart refresh
            container refresh {
              tailf:info "Configure RSVP Hello refresh behavior for Graceful Restart";

              // ip rsvp signalling hello graceful-restart refresh interval
              leaf interval {
                tailf:info "Time between sending Hello Requests for Graceful Restart";
                type uint16 {
                  tailf:info "<1000-30000>;;Hello interval in msec";
                  range "1000..30000";
                }
              }

              // ip rsvp signalling hello graceful-restart refresh misses
              leaf misses {
                tailf:info "Number of missed Hello Acks which triggers neighbor down";
                type uint8 {
                  tailf:info "<4-10>;;Number of Hello misses for Graceful Restart";
                  range "4..10";
                }
              }
            }
          }
        }

        // no ip rsvp signalling rate-limit
        // ip rsvp signalling rate-limit X
        choice rate-limit-choice {
          leaf rate-limit {
            tailf:info "Limit rate at which RSVP msgs are sent to neighbors";
            tailf:cli-boolean-no;
            tailf:cli-full-command;
            type boolean;
            default true;
          }
          container rate-limit-conf {
            tailf:cli-drop-node-name;
            container rate-limit {
              tailf:cli-incomplete-command;
              tailf:cli-incomplete-no;
              tailf:cli-compact-syntax;
              ios:delete-syntax "default ip rsvp signalling rate-limit";
              leaf period {
                tailf:info "Every interval (msec) send burst number of messages";
                type uint16 {
                  tailf:info "<10-5000>;;interval length (msecs)";
                  range "10..5000";
                }
              }
              leaf burst {
                tailf:info "Number of messages sent each period from the queue, normally";
                type uint16 {
                  tailf:info "<1-5000>;;Number of messages sent each period from the queue, normally";
                  range "1..5000";
                }
              }
              leaf maxsize {
                tailf:info "Maximum queue depth";
                type uint16 {
                  tailf:info "<1-5000>;;Maximum queue depth";
                  range "1..5000";
                }
              }
              leaf limit {
                tailf:info "Max number of msgs sent each period from the queue, when behind";
                type uint16 {
                  tailf:info "<1-5000>;;Max number of msgs sent each period from the queue, when behind";
                  range "1..5000";
                }
              }
            }
          }
        }
      }
    }

    // ip nat
    container nat {
      tailf:info "NAT configuration commands";

      // ip nat settings
      container settings {
        tailf:info "NAT general settings";

        // ip nat settings mode
        leaf mode {
          tailf:info "NAT operating mode";
          type enumeration {
            enum cgn {
              tailf:info "The carrier grade NAT (CGN) operating mode";
            }
            enum "default" {
              tailf:info "The default NAT operating mode";
            }
          }
          default "default";
        }

        // ip nat settings gatekeeper-size
        leaf gatekeeper-size {
          tailf:info "Gatekeeper cache size";
          type uint32 {
            tailf:info "<512-262144>;;Number of entries - truncated to power of 2";
            range "512..262144";
          }
        }
      }

      // ip nat translation
      container translation {
        tailf:info "NAT translation entry configuration";
        tailf:cli-diff-delete-after "../inside";
        tailf:cli-diff-delete-after "../outside";

        // ip nat translation timeout
        leaf timeout {
          tailf:info "Specify timeout for dynamic NAT translations";
          type ip-nat-timeout-type;
        }

        // ip nat translation dns-timeout
        leaf dns-timeout {
          tailf:info "Specify timeout for NAT DNS flows";
          type ip-nat-timeout-type;
        }

        // ip nat translation syn-timeout
        leaf syn-timeout {
          tailf:info "Specify timeout for NAT TCP flows after a SYN and no further data";
          type ip-nat-timeout-type;
        }

        // ip nat translation finrst-timeout
        leaf finrst-timeout {
          tailf:info "Specify timeout for NAT TCP flows after a FIN or RST";
          type ip-nat-timeout-type;
        }

        // ip nat translation icmp-timeout
        leaf icmp-timeout {
          tailf:info "Specify timeout for NAT ICMP flows";
          type ip-nat-timeout-type;
        }

        // ip nat translation udp-timeout
        leaf udp-timeout {
          tailf:info "Specify timeout for NAT UDP flows";
          type ip-nat-timeout-type;
        }

        // ip nat translation tcp-timeout
        leaf tcp-timeout {
          tailf:info "Specify timeout for NAT TCP flows";
          type ip-nat-timeout-type;
        }

        // ip nat translation routemap-entry-timeout
        leaf routemap-entry-timeout {
          tailf:info "Specify timeout for routemap created half entry";
          type ip-nat-timeout-type;
        }

        // ip nat translation max-entries
        container max-entries {
          tailf:info "Specify maximum number of NAT entries";

          // ip nat translation max-entries all-host
          leaf all-host {
            tailf:info "Specify maximum number of NAT entries for each host";
            type uint32 {
              tailf:info "<1-2147483647>;;Number of entries";
              range "1..2147483647";
            }
          }

          // ip nat translation max-entries vrf *
          list vrf {
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            tailf:cli-diff-dependency "../../../../../ip/vrf";
            tailf:cli-diff-dependency "../../../../../vrf/definition";
            key name;
            leaf name {
              type string {
                tailf:info "Specify per-VRF NAT entry limit";
              }
            }
            leaf number {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<1-2147483647>;;Number of entries";
                range "1..2147483647";
              }
            }
          }

          // ip nat translation max-entries list
          container list {
            tailf:info "Specify access list based NAT entry limit";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf access-list {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type exp-ip-acl-type;
            }
            leaf number {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<1-2147483647>;;Number of entries";
                range "1..2147483647";
              }
            }
          }
        }
      }

      // ip nat service
      container service {
        tailf:info "Special translation for application using non-standard port";

        // no ip nat service dns-reset-ttl
        leaf dns-reset-ttl {
          tailf:info "Reset dns cname ttl value";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }

        // no ip nat service H225
        leaf H225 {
          tailf:info "H323-H225  protocoldns-reset-ttl";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }

        // ip nat service list *
        container list-ftp-tcp {
          tailf:cli-drop-node-name;
          list list {
            tailf:info "Specify access list describing global addresses";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            key "access-list port";
            leaf access-list {
              type union {
                type uint16 {
                  tailf:info "<1-2699>;;Access list number for global addresses";
                }
                type string {
                  tailf:info "WORD;;Access list name for server local address";
                }
              }
            }
            leaf ftp {
              tailf:info "ftp protocol";
              tailf:cli-prefix-key {
                tailf:cli-before-key 2;
              }
              type empty;
            }
            leaf tcp {
              tailf:info "TCP protocol";
              tailf:cli-prefix-key {
                tailf:cli-before-key 2;
              }
              type empty;
            }
            leaf port {
              tailf:info "Special non-standard port";
              tailf:cli-expose-key-name;
              type uint16 {
                tailf:info "<1-65535>;;Port number";
                range "1..65535";
              }
            }
          }
        }

        // ip nat service sip
        container sip {
          tailf:info "SIP protocol";

          // ip nat service sip tcp
          container tcp {
            tailf:info "TCP protocol";

            // ip nat service sip tcp port *
            list port {
              tailf:info "Special non-standard port";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key id;
              leaf id {
                type uint16 {
                  tailf:info "<1-5059|5061-65535>;;Port number";
                  range "1..5059|5061..65535";
                }
              }
            }

            // no ip nat service sip tcp port 5060
            container default {
              tailf:cli-drop-node-name;
              container port {
                tailf:info "Special non-standard port";
                leaf fiftysixty {
                  tailf:alt-name "5060";
                  tailf:cli-boolean-no;
                  type boolean;
                  default true;
                }
              }
            }
          }

          // ip nat service sip udp
          container udp {
            tailf:info "UDP protocol";

            // ip nat service sip udp port *
            list port {
              tailf:info "Special non-standard port";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key id;
              leaf id {
                type uint16 {
                  tailf:info "<1-5059|5061-65535>;;Port number";
                  range "1..5059|5061..65535";
                }
              }
            }

            // no ip nat service sip udp port 5060
            container default {
              tailf:cli-drop-node-name;
              container port {
                tailf:info "Special non-standard port";
                leaf fiftysixty {
                  tailf:alt-name "5060";
                  tailf:cli-boolean-no;
                  type boolean;
                  default true;
                }
              }
            }
          }
        }
      }

      // ip nat pool *
      list pool {
        tailf:info "Define pool of addresses";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;Pool name";
          }
        }
        leaf start-address {
          tailf:cli-drop-node-name;
          tailf:cli-optional-in-sequence;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Start IP address";
          }
        }
        leaf end-address {
          tailf:cli-drop-node-name;
          when "../start-address" {
            tailf:dependency "../start-address";
          }
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;End IP address";
          }
        }
        choice prefix-choice {
          leaf netmask {
            tailf:info "Specify the network mask";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Network mask";
            }
          }
          leaf prefix-length {
            tailf:info "Specify the prefix length";
            type uint8 {
              tailf:info "<1-32>;;Prefix length";
              range "1..32";
            }
          }
        }
        leaf accounting {
          tailf:cli-optional-in-sequence;
          tailf:info "Specify the accounting";
          type string {
            tailf:info "WORD;;Accounting method-list name";
          }
        }
        choice nat-choice {
          leaf arp-ping {
            tailf:info "WLAN ARP Ping";
            type empty;
          }
          leaf type {
            tailf:info "Specify the pool type";
            type enumeration {
              enum match-host {
                tailf:info "Keep host numbers the same after translation";
              }
              enum rotary {
                tailf:info "Rotary address pool";
              }
            }
          }
          leaf add-route {
            tailf:info "Add special route to Virtual Interface";
            type empty;
          }
        }
      }

      // ip nat inside
      container inside {
        tailf:info "Inside address translation";

        // ip nat inside source
        container source {
          tailf:info "Source address translation";

          // ip nat inside source static
          container static {
            tailf:info "Specify static local->global mapping";
            tailf:cli-diff-set-after "../list" {
              tailf:cli-when-target-delete;
            }
            tailf:cli-diff-set-after "../list-vrf/list" {
              tailf:cli-when-target-delete;
            }

            // ip nat inside source static <local-ip> interface *
            list nat-static-interface-list {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              key interface;
              leaf local-ip {
                tailf:cli-drop-node-name;
                tailf:cli-prefix-key;
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Inside local IP address";
                }
              }
              leaf interface {
                tailf:info "Specify interface for global address";
                tailf:cli-expose-key-name;
                tailf:cli-diff-dependency "/ios:interface";
                type string {
                  tailf:info "WORD;;Interface Name";
                }
              }
            }

            // ip nat inside source static a.b.c.d a.b.c.d
            list nat-static-address-list {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              key "local-ip global-ip";
              leaf local-ip {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Inside local IP address";
                }
              }
              leaf global-ip {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Inside global IP address";
                }
              }
              uses ip-nat-source-static-grouping;
            }

            // ip nat inside source static a.b.c.d a.b.c.d vrf z
            list nat-static-address-list-vrf {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              tailf:cli-diff-dependency "../nat-static-address-list-vrf";
              tailf:cli-diff-create-after "../nat-static-address-list-vrf" {
                tailf:cli-when-target-delete;
              }
              key "local-ip global-ip vrf";
              leaf local-ip {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Inside local IP address";
                }
              }
              leaf global-ip {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Inside global IP address";
                }
              }
              leaf vrf {
                tailf:info "Specify vrf";
                tailf:cli-expose-key-name;
                tailf:cli-diff-dependency "../../../../../../../ip/vrf";
                tailf:cli-diff-dependency "../../../../../../../vrf/definition";
                type string {
                  tailf:info "WORD;;vrf name";
                }
              }
              uses ip-nat-source-static-grouping;
            }

            // ip nat inside source static tcp|udp a.b.c.d x a.b.c.d y
            list nat-static-transport-list {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              key "proto local-ip local-port global-ip global-port";
              leaf proto {
                type enumeration {
                  enum tcp {
                    tailf:info "Transmission Control Protocol";
                  }
                  enum udp {
                    tailf:info "User Datagram Protocol";
                  }
                }
              }
              leaf local-ip {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Inside local IP address";
                }
              }
              leaf local-port {
                type uint16 {
                  tailf:info "<1-65535>;;Local UDP/TCP port";
                  range "1..65535";
                }
              }
              leaf global-ip {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Inside global IP address";
                }
              }
              leaf global-port {
                type uint16 {
                  tailf:info "<1-65535>;;Global UDP/TCP port";
                  range "1..65535";
                }
              }
              uses ip-nat-source-static-grouping;
            }

            // ip nat inside source static tcp|udp a.b.c.d x a.b.c.d y vrf z
            list nat-static-transport-list-vrf {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              tailf:cli-diff-create-after "../nat-static-transport-list-vrf" {
                tailf:cli-when-target-delete;
              }
              tailf:cli-diff-dependency "../nat-static-transport-list-vrf";
              key "proto local-ip local-port global-ip global-port vrf";
              leaf proto {
                type enumeration {
                  enum tcp {
                    tailf:info "Transmission Control Protocol";
                  }
                  enum udp {
                    tailf:info "User Datagram Protocol";
                  }
                }
              }
              leaf local-ip {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Inside local IP address";
                }
              }
              leaf local-port {
                type uint16 {
                  tailf:info "<1-65535>;;Local UDP/TCP port";
                  range "1..65535";
                }
              }
              leaf global-ip {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Inside global IP address";
                }
              }
              leaf global-port {
                type uint16 {
                  tailf:info "<1-65535>;;Global UDP/TCP port";
                  range "1..65535";
                }
              }
              leaf vrf {
                tailf:info "Specify vrf";
                tailf:cli-expose-key-name;
                tailf:cli-diff-dependency "../../../../../../../ip/vrf";
                tailf:cli-diff-dependency "../../../../../../../vrf/definition";
                type string {
                  tailf:info "WORD;;vrf name";
                }
              }
              uses ip-nat-source-static-grouping;
            }

            // ip nat inside source static tcp|udp a.b.c.d x
            list nat-static-transport-interface-list {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              tailf:cli-incomplete-command;
              key "proto local-ip local-port";
              leaf proto {
                type enumeration {
                  enum tcp {
                    tailf:info "Transmission Control Protocol";
                  }
                  enum udp {
                    tailf:info "User Datagram Protocol";
                  }
                }
              }
              leaf local-ip {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Inside local IP address";
                }
              }
              leaf local-port {
                type uint16 {
                  tailf:info "<1-65535>;;Local UDP/TCP port";
                  range "1..65535";
                }
              }
              container interface {
                tailf:info "Specify interface for global address";
                tailf:cli-flatten-container;
                tailf:cli-compact-syntax;
                uses interface-name-grouping;
              }
              leaf global-port {
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<1-65535>;;Global UDP/TCP port";
                  range "1..65535";
                }
              }
            }
          }

          // ip nat inside source list *
          list list {
            tailf:info "Specify access list describing local addresses";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-all-siblings;
            }
            tailf:cli-incomplete-command;
            tailf:cli-remove-before-change;
            tailf:cli-diff-dependency "../static";
            key id;
            leaf id {
              type union {
                type uint16 {
                  tailf:info "<1-2699>;;Access list number for global addresses";
                  range "1..2699";
                }
                type string {
                  tailf:info "WORD;;Access list name for global addresses";
                }
              }
            }
            uses ip-nat-inside-grouping;
            uses ip-nat-inside-options-grouping;
          }

          // ip nat inside source list * vrf *
          container list-vrf {
            tailf:cli-drop-node-name;
            tailf:cli-diff-dependency "../static";
            list list {
              tailf:info "Specify access list describing local addresses";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-all-siblings;
              }
              tailf:cli-diff-dependency "../../../../../../ip/vrf";
              tailf:cli-diff-dependency "../../../../../../vrf/definition";
              key "id vrf";
              leaf id {
                type union {
                  type uint16 {
                    tailf:info "<1-2699>;;Access list number for global addresses";
                    range "1..2699";
                  }
                  type string {
                    tailf:info "WORD;;Access list name for global addresses";
                  }
                }
              }
              uses ip-nat-inside-vrf-grouping;
              uses ip-nat-inside-options-grouping;
            }
          }

          // ip nat inside source route-map *
          list route-map {
            tailf:info "Specify route-map";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-all-siblings;
            }
            tailf:cli-incomplete-command;
            key id;
            leaf id {
              type string {
                tailf:info "WORD;;Route-map name";
              }
            }
            uses ip-nat-inside-grouping;
            uses ip-nat-inside-options-grouping;
          }

          // ip nat inside source route-map * vrf *
          container route-map-vrf {
            tailf:cli-drop-node-name;
            list route-map {
              tailf:info "Specify route-map";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-all-siblings;
              }
              tailf:cli-incomplete-command;
              tailf:cli-diff-dependency "../../../../../../ip/vrf";
              tailf:cli-diff-dependency "../../../../../../vrf/definition";
              key "id vrf";
              leaf id {
                type string {
                  tailf:info "WORD;;Route-map name";
                }
              }
              uses ip-nat-inside-vrf-grouping;
              uses ip-nat-inside-options-grouping;
            }
          }
        }

        // ip nat inside destination
        container destination {
          tailf:info "Destination address translation";

          // ip nat inside destination list *
          list list {
            tailf:info "Specify access list describing global addresses";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            tailf:cli-incomplete-command;
            key id;
            leaf id {
              type union {
                type uint16 {
                  tailf:info "<1-2699>;;Access list number for global addresses";
                  range "1..2699";
                }
                type string {
                  tailf:info "WORD;;Access list name for global addresses";
                }
              }
            }
            // ip nat inside destination list * pool *
            leaf pool {
              tailf:info "Name pool of local addresses";
              tailf:non-strict-leafref {
                path "../../../../../../ip/nat/pool/id";
              }
              type string {
                tailf:info "WORD;;Pool name for local addresses ";
              }
            }
            // [ redundancy redundancy-id ]
            leaf redundancy {
              tailf:info "NAT redundancy operation";
              tailf:cli-optional-in-sequence;
              type uint8 {
                tailf:info "<1-2>;;IP redundancy ID";
                range "1..2";
              }
            }
            // [ mapping-id map-id ]
            leaf mapping-id {
              tailf:info "Associate a mapping id to this mapping";
              type uint32 {
                tailf:info "<1-2147483647>;;Stateful NAT mapping id";
                range "1..2147483647";
              }
            }
          }
        }
      }

      // ip nat outside
      container outside {
        tailf:info "Outside address translation";

        // ip nat outside source
        container source {
          tailf:info "Source address translation";

          // ip nat outside source list *
          list list {
            tailf:info "Specify access list describing global addresses";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            key id;
            leaf id {
              type union {
                type uint16 {
                  tailf:info "<1-2699>;;Access list number for global addresses";
                  range "1..2699";
                }
                type string {
                  tailf:info "WORD;;Access list name for global addresses";
                }
              }
            }
            leaf pool {
              tailf:info "Name pool of local addresses";
              tailf:non-strict-leafref {
                path "../../../../../../ip/nat/pool/id";
              }
              type string {
                tailf:info "WORD;;Pool name for local addresses ";
              }
            }
            uses ip-nat-outside-source-grouping;
          }

          // ip nat outside source list * pool * vrf *
          container list-vrf {
            tailf:cli-drop-node-name;
            list list {
              tailf:info "Specify access list describing local addresses";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-all-siblings;
              }
              key "id vrf";
              leaf id {
                type union {
                  type uint16 {
                    tailf:info "<1-2699>;;Access list number for global addresses";
                    range "1..2699";
                  }
                  type string {
                    tailf:info "WORD;;Access list name for global addresses";
                  }
                }
              }
              leaf pool {
                tailf:info "Name pool of local addresses";
                tailf:cli-prefix-key {
                  tailf:cli-before-key 2;
                }
                tailf:non-strict-leafref {
                  path "../../../../../../../ip/nat/pool/id";
                }
                type string {
                  tailf:info "WORD;;Pool name for local addresses ";
                }
              }
              leaf vrf {
                tailf:info "Specify vrf";
                tailf:cli-expose-key-name;
                tailf:cli-diff-dependency "../../../../../../../ip/vrf";
                tailf:cli-diff-dependency "../../../../../../../vrf/definition";
                type string {
                  tailf:info "WORD;;vrf name";
                }
              }
              uses ip-nat-outside-source-grouping;
            }
          }

          // ip nat outside source route-map *
          list route-map {
            tailf:info "Specify route-map";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            key id;
            leaf id {
              type string {
                tailf:info "WORD;;Route-map name";
              }
            }
            leaf pool {
              tailf:info "Name pool of local addresses";
              tailf:non-strict-leafref {
                path "../../../../pool/id";
              }
              type string {
                tailf:info "WORD;;Pool Name";
              }
            }
            uses ip-nat-outside-source-grouping;
          }

          // ip nat outside source route-map * pool * vrf *
          container route-map-vrf {
            tailf:cli-drop-node-name;
            list route-map {
              tailf:info "Specify route-map";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              key "id vrf";
              leaf id {
                type string {
                  tailf:info "WORD;;Route-map name";
                }
              }
              leaf pool {
                tailf:info "Name pool of local addresses";
                tailf:cli-prefix-key {
                  tailf:cli-before-key 2;
                }
                tailf:non-strict-leafref {
                  path "../../../../../pool/id";
                }
                type string {
                  tailf:info "WORD;;Pool Name";
                }
              }
              leaf vrf {
                tailf:info "Specify vrf";
                tailf:cli-expose-key-name;
                tailf:cli-diff-dependency "../../../../../../vrf";
                tailf:cli-diff-dependency "../../../../../../../vrf/definition";
                type string {
                  tailf:info "WORD;;vrf name";
                }
              }
              uses ip-nat-outside-source-grouping;
            }
          }

          // ip nat outside source static
          container static {
            tailf:info "Specify static global->local mapping";

            // ip nat outside source static a.b.c.d a.b.c.d
            list nat-static-address-list {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              key "global-ip local-ip";
              leaf global-ip {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Outside global IP address";
                }
              }
              leaf local-ip {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Outside local IP address";
                }
              }
              uses ip-nat-source-static-grouping;
            }

            // ip nat outside source static a.b.c.d a.b.c.d vrf z
            list nat-static-address-list-vrf {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              key "global-ip local-ip vrf";
              leaf global-ip {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Outside global IP address";
                }
              }
              leaf local-ip {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Outside local IP address";
                }
              }
              leaf vrf {
                tailf:info "Specify vrf";
                tailf:cli-expose-key-name;
                tailf:cli-diff-dependency "../../../../../../vrf";
                tailf:cli-diff-dependency "../../../../../../../vrf/definition";
                type string {
                  tailf:info "WORD;;vrf name";
                }
              }
              uses ip-nat-source-static-grouping;
            }

            // ip nat outside source static tcp|udp a.b.c.d x a.b.c.d y
            list nat-static-transport-list {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              key "proto global-ip global-port local-ip local-port";
              leaf proto {
                type enumeration {
                  enum tcp {
                    tailf:info "Transmission Control Protocol";
                  }
                  enum udp {
                    tailf:info "User Datagram Protocol";
                  }
                }
              }
              leaf global-ip {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Outside global IP address";
                }
              }
              leaf global-port {
                type uint16 {
                  tailf:info "<1-65535>;;Global UDP/TCP port";
                  range "1..65535";
                }
              }
              leaf local-ip {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Outside local IP address";
                }
              }
              leaf local-port {
                type uint16 {
                  tailf:info "<1-65535>;;Local UDP/TCP port";
                  range "1..65535";
                }
              }
              uses ip-nat-source-static-grouping;
            }

            // ip nat outside source static tcp|udp a.b.c.d x a.b.c.d y vrf z
            list nat-static-transport-list-vrf {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              key "proto global-ip global-port local-ip local-port vrf";
              leaf proto {
                type enumeration {
                  enum tcp {
                    tailf:info "Transmission Control Protocol";
                  }
                  enum udp {
                    tailf:info "User Datagram Protocol";
                  }
                }
              }
              leaf global-ip {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Outside global IP address";
                }
              }
              leaf global-port {
                type uint16 {
                  tailf:info "<1-65535>;;Global UDP/TCP port";
                  range "1..65535";
                }
              }
              leaf local-ip {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Outside local IP address";
                }
              }
              leaf local-port {
                type uint16 {
                  tailf:info "<1-65535>;;Local UDP/TCP port";
                  range "1..65535";
                }
              }
              leaf vrf {
                tailf:info "Specify vrf";
                tailf:cli-expose-key-name;
                tailf:cli-diff-dependency "../../../../../../vrf";
                tailf:cli-diff-dependency "../../../../../../../vrf/definition";
                type string {
                  tailf:info "WORD;;vrf name";
                }
              }
              uses ip-nat-source-static-grouping;
            }
          }
        }
      }
    }

    // ip mroute
    container mroute {
      tailf:info "Configure static multicast routes";

      // ip mroute *
      container global {
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        uses ip-mroute-grouping;
      }

      // ip mroute vrf * *
      list vrf {
        tailf:info "Select VPN Routing/Forwarding instance";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;VRF name";
          }
        }
        uses ip-mroute-grouping;
      }
    }

    // ip route
    container route {
      tailf:info "Establish static routes";

      // ip route static
      container static {
        tailf:info "Allow static routes";

        // ip route static adjust-time
        leaf adjust-time {
          tailf:info "Time period for adjusting static routes";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<1-60>;;Adjustment time in seconds. Default 60";
            range "1..60";
          }
          default 60;
        }

        // no ip route static inter-vrf
        leaf inter-vrf {
          tailf:info "Across VRF interfaces";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }

        // ip route static bfd *
        container bfd {
          tailf:info "BFD tracked";
          list ip-route-bfd-forwarding-list {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-reset-container;
            tailf:cli-remove-before-change;
            key "interface ip-address";
            leaf interface {
              ///tailf:cli-diff-dependency "../../../../../../interface";
              type string {
                tailf:info "WORD;;Interface name";
              }
            }
            leaf ip-address {
              type union {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Gateway IP address";
                }
                type enumeration {
                  enum multicast {
                    tailf:info "multicast route";
                  }
                }
              }
            }
            leaf group {
              tailf:info "assign a bfd group";
              type string {
                tailf:info "WORD;;bfd group name";
              }
            }
            leaf log {
              tailf:info "Log changes in BFD Up/Down events";
              type empty;
            }
          }
        }

        // ip route static install-routes-recurse-via-nexthop
        leaf install-routes-recurse-via-nexthop {
          tailf:info "installing recursive route next hop";
          type empty;
        }

        // ip route static install-routes-recurse-via-nexthop vrf *
        container install-routes-recurse-via-nexthop-vrf {
          tailf:cli-drop-node-name;
          container install-routes-recurse-via-nexthop {
            tailf:info "installing recursive route next hop";
            tailf:cli-incomplete-no;
            tailf:cli-incomplete-command;
            list vrf {
              tailf:info "Configure static route for a VPN Routing/Forwarding instance";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key name;
              leaf name {
                tailf:cli-diff-dependency "../../../../../../vrf";
                tailf:cli-diff-dependency "../../../../../../../vrf/definition";
                type string {
                  tailf:info "WORD;;VPN Routing/Forwarding instance name";
                }
              }
            }
          }
        }
      }

      // ip route profile
      leaf profile {
        tailf:info "Enable IP routing table profile";
        tailf:cli-full-command;
        type empty;
      }

      // ip route *
      uses ip-route-grouping;

      // ip route vrf *
      list vrf {
        tailf:info "Configure static route for a VPN Routing/Forwarding instance";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-incomplete-command;
        ///tailf:cli-diff-set-after "../../../interface";
        key name;
        leaf name {
          tailf:cli-diff-dependency "../../../vrf";
          tailf:cli-diff-dependency "../../../../vrf/definition";
          type string {
            tailf:info "WORD;;VPN Routing/Forwarding instance name";
          }
        }
        uses ip-route-grouping;
      }
    }

    // ip explicit-path
    container explicit-path {
      tailf:info "Configure explicit-path";

      // ip explicit-path identifier *
      list identifier {
        tailf:info "Specify explicit path by number";
        tailf:cli-mode-name "cfg-ip-expl-path";
        key number;
        leaf number {
          tailf:cli-suppress-range;
          type uint16 {
            tailf:info "<1-65535>;;Enter number";
            range "1..65535";
          }
        }
        leaf mode {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum enable {
              tailf:info "enable the explicit path";
            }
            enum disable {
              tailf:info "disable the explicit path";
            }
          }
        }
        uses ip-explicit-path-grouping;
      }

      // ip explicit-path name *
      list name {
        tailf:info "Specify explicit path by name";
        tailf:cli-mode-name "cfg-ip-expl-path";
        key name;
        leaf name {
          tailf:cli-suppress-range;
          type string {
            tailf:info "WORD;;Enter name";
          }
        }
        leaf mode {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum enable {
              tailf:info "enable the explicit path";
            }
            enum disable {
              tailf:info "disable the explicit path";
            }
          }
        }
        uses ip-explicit-path-grouping;
      }
    }

    // ip tacacs source-interface
    container tacacs {
      tailf:info "TACACS configuration commands";
      container source-interface {
        tailf:info "Specify interface for source address in TACACS packets";
        uses interface-name-grouping;
      }

      // ip tacacs source-interface <name> vrf *
      container source-interface-vrf {
        tailf:cli-drop-node-name;
        list source-interface {
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-diff-dependency "../../../../interface";
          key vrf;
          leaf name {
            tailf:cli-drop-node-name;
            tailf:cli-prefix-key;
            type string {
              tailf:info "WORD;;Interface Name";
            }
          }
          leaf vrf {
            tailf:info "VPN Routing/Forwarding parameters";
            tailf:cli-expose-key-name;
            tailf:cli-diff-dependency "../../../../../ip/vrf";
            tailf:cli-diff-dependency "../../../../../vrf/definition";
            type string {
              tailf:info "WORD;;Table name";
            }
          }
        }
      }
    }

    // ip access-list
    container access-list {
      tailf:info "Named access list";
      tailf:cli-compact-syntax;
      tailf:cli-incomplete-command;
      tailf:cli-diff-dependency "../../object-group";
      tailf:cli-diff-delete-after "../../crypto";

      // ip access-list logging
      container logging {
        tailf:info "Control access list logging";

        // ip access-list logging interval
        leaf interval {
          tailf:info "Set access list logging interval";
          type uint32 {
            tailf:info "<0-2147483647>;;Access list logging interval (milliseconds)";
            range "0..2147483647";
          }
        }

        // ip access-list logging hash-generation
        leaf hash-generation {
          tailf:info "Enable syslog hash code generation";
          type empty;
        }
      }

      // ip access-list persistent
      leaf persistent {
        tailf:info "enable persistency across reload";
        tailf:cli-full-command;
        type empty;
      }

      // METHOD 1 (default)
      // ip access-list standard *
      container standard {
        tailf:info "Standard Access List";
        when "not(../../../tailfned/api/new-ip-access-list)"
          + "or (../../../tailfned/api/resequence-access-list)" {
          tailf:dependency "../../../tailfned/api/new-ip-access-list";
          tailf:dependency "../../../tailfned/api/resequence-access-list";
        }
        list std-named-acl {
          tailf:cli-drop-node-name;
          tailf:cli-full-command;
          tailf:cli-no-key-completion;
          tailf:cli-mode-name "config-std-nacl";
          key name;
          leaf name {
            tailf:cli-suppress-range;
            // dep: before this created, must change extended
            tailf:cli-diff-dependency "../../../extended/ext-named-acl" {
              tailf:cli-trigger-on-set;
            }
            tailf:cli-diff-dependency "../../../resequence/extended" {
              tailf:cli-trigger-on-set;
            }
            type std-ip-acl-type;
          }
          list std-access-list-rule {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-show-long-obu-diffs;
            ordered-by user;
            key rule;
            leaf rule {
              tailf:cli-suppress-range;
              tailf:cli-multi-word-key;
              tailf:cli-diff-dependency "../../../../../../object-group";
              type string {
                tailf:info "WORD;;permit <line> | deny <line> | remark <line> | <seqno> <rule>";
                pattern "(permit .*)|(deny .*)|(remark.*)|([0-9]+.*)|(dynamic .*)|(evaluate .*)";
              }
            }
          }
        }
      }

      // METHOD 1 (default)
      // ip access-list extended *
      container extended {
        tailf:info "Extended Access List";
        when "not(../../../tailfned/api/new-ip-access-list)"
          +" and not(../../../tailfned/api/resequence-access-list)" {
          tailf:dependency "../../../tailfned/api/new-ip-access-list";
          tailf:dependency "../../../tailfned/api/resequence-access-list";
        }
        list ext-named-acl {
          tailf:cli-drop-node-name;
          tailf:cli-mode-name "config-ext-nacl";
          tailf:cli-full-command;
          tailf:cli-explicit-exit;
          key name;
          leaf name {
            tailf:cli-suppress-range;
            type ext-acl-type;
          }
          list ext-access-list-rule {
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-drop-node-name;
            tailf:cli-compact-syntax;
            tailf:cli-show-long-obu-diffs;
            ordered-by user;
            key rule;
            leaf rule {
              tailf:cli-suppress-range;
              tailf:cli-multi-word-key;
              tailf:cli-diff-dependency "../../../../../../object-group";
              type string {
                tailf:info "WORD;;permit <line> | deny <line> | remark <line> | <seqno> <rule>";
                pattern "(permit .*)|(deny .*)|(remark.*)|([0-9]+.*)|(dynamic .*)|(evaluate .*)";
              }
            }
          }
        }
      }

      // METHOD 4
      // ip access-list unordered standard|extended *
      list unordered {
        tailf:info "Unordered Standard|Extended Access List (WARNING: non-standard)";
        tailf:cli-mode-name "config-unordered-nacl";
        tailf:cli-explicit-exit;
        tailf:cli-no-key-completion;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-full-command;
        tailf:cli-diff-dependency "../persistent";
        key name;
        leaf name {
          tailf:cli-suppress-range;
          type string {
            tailf:info "WORD;;Access-list name or number";
          }
        }
        leaf type {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type enumeration {
            enum standard {
              tailf:info "Standard Access List";
            }
            enum extended {
              tailf:info "Extended Access List";
            }
          }
        }
        list rule-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key rule;
          leaf rule {
            tailf:cli-suppress-range;
            tailf:cli-multi-word-key;
            tailf:cli-diff-dependency "../../../../../object-group";
            type string {
              tailf:info "WORD;;permit <line> | deny <line> | remark <line> | <seqno> <rule>";
              pattern "(permit .*)|(deny .*)|(remark.*)|([0-9]+.*)|(dynamic .*)|(evaluate .*)";
            }
          }
        }
      }

      // METHOD 3 - 'ned-settings cisco-ios api access-list-resequence true'
      // ip access-list extended *
      // Note: use METHOD 1 for standard-list
      container resequence {
        when "../../../tailfned/api/resequence-access-list" {
          tailf:dependency "../../../tailfned/api/resequence-access-list";
        }
        tailf:cli-drop-node-name;
        list extended {
          tailf:info "Extended Access List";
          tailf:cli-mode-name "config-ext-nacl";
          tailf:cli-full-command;
          tailf:cli-explicit-exit;
          tailf:cli-no-key-completion;
          tailf:cli-diff-dependency "../../persistent";
          key name;
          leaf name {
            tailf:cli-suppress-range;
            type string {
              tailf:info "WORD;;Access-list name or number";
            }
          }
          list rule-list {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-show-obu-comments;
            ordered-by user;
            key rule;
            leaf rule {
              tailf:cli-suppress-range;
              tailf:cli-multi-word-key;
              tailf:cli-diff-dependency "../../../../../../object-group";
              type string {
                tailf:info "WORD;;deny | permit - evaluate ACL entry";
                pattern "(permit .*)|(deny .*)";
              }
            }
          }
        }
      }

      // METHOD 2 - 'ned-settings cisco-ios api new-ip-access-list true'
      // ip access-list standard *
      // ip access-list extended *
      list filter-list {
        when "(../../../tailfned/api/new-ip-access-list)"
          + "and not(../../../tailfned/api/resequence-access-list)" {
          tailf:dependency "../../../tailfned/api/new-ip-access-list";
          tailf:dependency "../../../tailfned/api/resequence-access-list";
        }
        tailf:cli-drop-node-name;
        tailf:cli-mode-name "config-nacl";
        tailf:cli-explicit-exit;
        tailf:cli-no-key-completion;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-full-command;
        tailf:cli-diff-dependency "../persistent";
        key name;
        leaf name {
          tailf:cli-suppress-range;
          type string {
            tailf:info "WORD;;Access-list name or number";
          }
        }
        leaf type {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          ios:new-ip-acl-type-change;
          type enumeration {
            enum standard {
              tailf:info "Standard Access List";
            }
            enum extended {
              tailf:info "Extended Access List";
            }
          }
        }
        list entry-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-remove-before-change;
          tailf:cli-incomplete-command;
          key seq;
          leaf seq {
            tailf:cli-suppress-range;
            type uint32 {
              tailf:info "<1-2147483647>;;Sequence Number";
              range "1..2147483647";
            }
          }
          leaf entry {
            tailf:cli-drop-node-name;
            tailf:cli-multi-value;
            tailf:cli-diff-dependency "../../../../../object-group";
            type string {
              tailf:info "WORD;;deny | permit | remark | dynamic | evaluate ACL entry";
              pattern "(permit .*)|(deny .*)|(remark.*)|(dynamic .*)|(evaluate .*)";
            }
          }
        }
      }
    }

    // ip prefix-list
    container prefix-list {
      tailf:info "Build a prefix list";

      // no ip prefix-list sequence-number
      leaf sequence-number {
        tailf:info "Include/exclude sequence numbers in NVGEN";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        cli:ned-diff-stay-after ">no ip prefix-list ";
        type boolean;
        default true;
      }

      // ip prefix-list * seq *
      list prefixes {
        cli:parse-global-when;
        when "not(../sequence-number) or (../sequence-number = 'true')" {
          tailf:dependency "../sequence-number";
        }
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          tailf:cli-disallow-value "sequence-number";
          type string {
            tailf:info "WORD;;Name of a prefix list";
          }
        }

        // ip prefix-list * description
        leaf description {
          tailf:info "Prefix-list specific description";
          tailf:cli-multi-value;
          tailf:cli-preformatted;
          tailf:cli-full-command;
          type string {
            tailf:info "LINE;;Up to 80 characters describing this prefix-list";
            length "1..80";
          }
        }

        // ip prefix-list * seq *
        list seq {
          tailf:info "sequence number of an entry";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          cli:ned-diff-move-before ">ip prefix-list $1 seq " {
            cli:arguments "when-delete :: regex=ip prefix-list (\\S+) seq ";
          }
          key no;
          leaf no {
            type uint32 {
              tailf:info "<1-4294967294>;;Sequence number";
              range "1..4294967294";
            }
          }

          // ip prefix-list * seq * deny
          container deny {
            tailf:info "Specify packets to reject";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf ip {
              tailf:cli-drop-node-name;
              tailf:cli-remove-before-change;
              type ios:ipv4-prefix {
                tailf:info "A.B.C.D;;IP prefix <network>/<length>, e.g., 35.0.0.0/8";
              }
            }
            leaf ge {
              tailf:info "Minimum prefix length to be matched";
              tailf:cli-optional-in-sequence;
              type uint8 {
                tailf:info "<1-32>;;Minimum prefix length";
                range "1..32";
              }
            }
            leaf le {
              tailf:info "Maximum prefix length to be matched";
              type uint8 {
                tailf:info "<1-32>;;Maximum prefix length";
                range "1..32";
              }
            }
          }

          // ip prefix-list * seq * permit
          container permit {
            tailf:info "Specify packets to forward";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf ip {
              tailf:cli-drop-node-name;
              tailf:cli-remove-before-change;
              type ios:ipv4-prefix {
                tailf:info "A.B.C.D;;IP prefix <network>/<length>, e.g., 35.0.0.0/8";
              }
            }
            leaf ge {
              tailf:info "Minimum prefix length to be matched";
              tailf:cli-optional-in-sequence;
              type uint8 {
                tailf:info "<1-32>;;Minimum prefix length";
                range "1..32";
              }
            }
            leaf le {
              tailf:info "Maximum prefix length to be matched";
              type uint8 {
                tailf:info "<1-32>;;Maximum prefix length";
                range "1..32";
              }
            }
          }
        }
      }

      // ip prefix-list *
      list prefixes-no-seq {
        cli:parse-global-when;
        when "../sequence-number = 'false'" {
          tailf:dependency "../sequence-number";
        }
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          tailf:cli-disallow-value "sequence-number";
          type string {
            tailf:info "WORD;;Name of a prefix list";
          }
        }

        // ip prefix-list * description
        leaf description {
          tailf:info "Prefix-list specific description";
          tailf:cli-multi-value;
          tailf:cli-preformatted;
          tailf:cli-full-command;
          type string {
            tailf:info "LINE;;Up to 80 characters describing this prefix-list";
            length "1..80";
          }
        }

        // ip prefix-list *
        list entry {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-show-long-obu-diffs;
          ordered-by user;
          cli:ned-diff-move-before ">ip prefix-list $1" {
            cli:arguments "when-delete :: regex=ip prefix-list (\\S+)";
          }
          key rule;
          leaf rule {
            tailf:cli-multi-word-key;
            type string {
              tailf:info "WORD;;permit <entry> | deny <entry>";
              pattern "(deny .*)|(permit .*)";
            }
          }
        }
      }
    }

    // ip radius
    container radius {
      tailf:info "RADIUS configuration commands";

      // ip radius source-interface
      container source-interface {
        tailf:info "Specify interface for source address in RADIUS packets";
        uses interface-name-grouping;
      }

      // ip radius source-interface * vrf *
      container source-interface-vrf {
        tailf:cli-drop-node-name;
        list source-interface {
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-diff-dependency "../../../../interface";
          key vrf;
          leaf name {
            tailf:cli-drop-node-name;
            tailf:cli-prefix-key;
            type string {
              tailf:info "WORD;;Interface Name";
            }
          }
          leaf vrf {
            tailf:info "VPN Routing/Forwarding parameters";
            tailf:cli-expose-key-name;
            tailf:cli-diff-dependency "../../../../../ip/vrf";
            tailf:cli-diff-dependency "../../../../../vrf/definition";
            type string {
              tailf:info "WORD;;Table name";
            }
          }
        }
      }
    }

    // ip sla
    container sla {
      tailf:info "IP Service Level Agreement";
      tailf:cli-diff-dependency "/ios:ipv6/unicast-routing";
      tailf:cli-diff-dependency "../../ethernet/evc";
      tailf:cli-diff-dependency "../../ethernet/cfm/domain";

      // ip sla auto discovery
      container auto {
        tailf:info "IP SLAs Auto Configuration";
        leaf discovery {
          tailf:info "Enable auto-discovery";
          type empty;
        }
      }

      // ip sla responder twamp
      container responder-twamp {
        tailf:cli-drop-node-name;
        container responder {
          tailf:info "Enable IP SLAs Responder";
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          container twamp {
            tailf:info "Setup TWAMP responder";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-twamp-ref";
            presence true;

            // ip sla responder twamp / timeout
            leaf timeout {
              tailf:info "Inactivity timeout period";
              type uint32 {
                tailf:info "<1-604800>;;Inactivity timeout value in seconds";
                range "1..604800";
              }
            }
          }
        }
      }

      // ip sla responder
      container responder-enable {
        tailf:cli-drop-node-name;
        leaf responder {
          tailf:info "Enable IP SLAs Responder";
          tailf:cli-full-command;
          tailf:cli-full-no;
          type empty;
        }
      }

      // ip sla responder udp-echo
      container responder-udp-echo {
        tailf:cli-drop-node-name;
        container responder {
          tailf:info "Enable IP SLAs Responder";
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          container udp-echo {
            tailf:info "Setup udp-echo responder";
            tailf:cli-compact-syntax;
            leaf ipaddress {
              tailf:info "Permanent address";
              type inet:host {
                tailf:info "WORD;;IP Address or IP HostName";
              }
            }
            leaf port {
              tailf:info "Permanent port";
              type uint16 {
                tailf:info "<1-65535>;;Port Number (Recommended ports greater than 1023)";
                range "1..65535";
              }
            }
          }
        }
      }

      // ip sla server twamp
      container server {
        tailf:info "IPPM server configuration";
        container twamp {
          tailf:info "IPPM TWAMP server configuration";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-twamp-srvr";
          presence true;

          // ip sla server twamp / port
          leaf port {
            tailf:info "Port on which to listen";
            type uint16 {
              tailf:info "<1-65535>;;Max port value";
              range "1..65535";
            }
            default 862;
          }

          // ip sla server twamp / timer inactivity
          container timer {
            tailf:info "Timer configurations";
            leaf inactivity {
              tailf:info "Inactivity timer";
              type uint16 {
                tailf:info "<1-6000>;;Max number of inactive seconds. Default 900";
                range "1..6000";
              }
              default 900;
            }
          }
        }
      }

      // ip sla logging traps
      container logging {
        tailf:info "Enable Syslog";
        leaf traps {
          tailf:info "Enable syslog traps";
          type empty;
        }
      }

      // ip sla key-chain
      leaf key-chain {
        tailf:info "Use MD5 Authentication for IP SLAs Control Messages";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;Name of key-chain";
        }
      }

      // ip sla *
      list ip-sla-list {
        tailf:cli-drop-node-name;
        tailf:cli-mode-name "config-ip-sla";
        tailf:cli-full-command;
        tailf:cli-diff-dependency "../../../ip/vrf";
        tailf:cli-diff-dependency "../../../vrf/definition";
        key id;
        leaf id {
          tailf:cli-diff-set-after "../../../../interface";
          tailf:cli-diff-delete-before "../../../../interface";
          type uint32 {
            tailf:info "<1-2147483647>;;Entry Number";
            range "1..2147483647";
          }
        }

        // ip sla * / tcp-connect
        list tcp-connect {
          tailf:info "TCP Connect Operation";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          max-elements 1;
          key "destination destination-port";
          leaf destination {
            type inet:host {
              tailf:info "Hostname or A.B.C.D;;Destination IP address or hostname, broadcast disallowed";
            }
          }
          leaf destination-port {
            type uint16 {
              tailf:info "<0-65535>;;Port Number (Recommended ports greater than 1023)";
            }
          }

          // ip sla * / tcp-connect * source-ip
          leaf source-ip {
            tailf:info "Source address";
            type inet:host {
              tailf:info "WORD;;Hostname or X:X:X:X::X or A.B.C.D address";
            }
          }

          // ip sla * / tcp-connect * source-port
          leaf source-port {
            tailf:info "Source Port";
            type uint16 {
              tailf:info "<1-65535>;;Port Number";
              range "1..65535";
            }
          }

          // ip sla * / tcp-connect * control
          leaf control {
            tailf:info "Enable or disable control packets";
            type enumeration {
              enum disable {
                tailf:info "Disable control packets exchange";
              }
              enum enable {
                tailf:info "Enable control packets exchange (default)";
              }
            }
            default enable;
          }
        }

        // ip sla * / udp-jitter *
        list udp-jitter {
          tailf:info "UDP Jitter Operation";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          max-elements 1;
          key "destination destination-port";
          leaf destination {
            type inet:host {
              tailf:info "WORD;;Hostname or X:X:X:X::X or A.B.C.D address";
            }
          }
          leaf destination-port {
            type uint16 {
              tailf:info "<0-65535>;;Port Number.";
            }
          }

          // ip sla * / udp-jitter * source-ip
          leaf source-ip {
            tailf:info "Source address";
            type inet:host {
              tailf:info "WORD;;Hostname or X:X:X:X::X or A.B.C.D address";
            }
          }

          // ip sla * / udp-jitter * source-port
          leaf source-port {
            tailf:info "Source Port";
            type uint16 {
              tailf:info "<1-65535>;;Port Number";
              range "1..65535";
            }
          }

          // ip sla * / udp-jitter * num-packets
          leaf num-packets {
            tailf:info "Number of Packets to be transmitted";
            type uint16 {
              tailf:info "<1-60000>;;Number of Packets (default 10)";
              range "1..60000";
            }
            default 10;
          }

          // ip sla * / udp-jitter * codec
          leaf codec {
            tailf:info "codec type to be configured";
            type enumeration {
              enum g711alaw {
                tailf:info "G.711 A Law 64000 bps";
              }
              enum g711ulaw {
                tailf:info "G.711 U Law 64000 bps";
              }
              enum g729a {
                tailf:info "G.729 8000 bps";
              }
            }
          }

          // ip sla * / udp-jitter * codec-numpackets
          leaf codec-numpackets {
            tailf:info "Number of Packets to be transmitted";
            when "../codec" {
              tailf:dependency "../codec";
            }
            type uint32 {
              tailf:info "<1-60000>;;Number of Packets";
              range "1..60000";
            }
          }

          // ip sla * / udp-jitter * interval
          leaf interval {
            tailf:info "Inter Packet Interval";
            type uint32 {
              tailf:info "<4-60000>;;Delay (default 20)";
            }
            default 20;
          }

          // ip sla * / udp-jitter * control
          leaf control {
            tailf:info "Enable or disable control packets";
            type enumeration {
              enum disable {
                tailf:info "Disable control packets exchange";
              }
              enum enable {
                tailf:info "Enable control packets exchange (default)";
              }
            }
            default enable;
          }
        }

        // ip sla * / icmp-echo *
        list icmp-echo {
          tailf:info "ICMP Echo Operation";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          max-elements 1;
          key host;
          leaf host {
            type inet:host {
              tailf:info "Hostname or A.B.C.D;;Destination IP address or hostname, broadcast disallowed";
            }
          }
          choice source-choice {
            // ip sla * / icmp-echo * source-interface
            container source-interface {
              tailf:info "Source Interface (ingress icmp packet interface)";
              tailf:cli-flatten-container;
              uses interface-nodiff-name-grouping;
            }
            // ip sla * / icmp-echo * source-ip
            leaf source-ip {
              tailf:info "Source Address";
              type inet:host {
                tailf:info "Hostname or A.B.C.D;;IP address or hostname, broadcast disallowed";
              }
            }
          }
        }

        // ip sla * / icmp-jitter *
        list icmp-jitter {
          tailf:info "ICMP Jitter Operation";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          max-elements 1;
          key host;
          leaf host {
            type inet:host {
              tailf:info "Hostname or A.B.C.D;;Destination IP address or hostname, broadcast disallowed";
            }
          }

          // ip sla * / icmp-jitter * source-ip
          leaf source-ip {
            tailf:info "Source address";
            type inet:host {
              tailf:info "WORD;;Hostname or X:X:X:X::X or A.B.C.D address";
            }
          }

          // ip sla * / icmp-jitter * num-packets
          leaf num-packets {
            tailf:info "Number of Packets to be transmitted";
            type uint16 {
              tailf:info "<1-60000>;;Number of Packets (default 10)";
              range "1..60000";
            }
            default 10;
          }

          // ip sla * / icmp-jitter * interval
          leaf interval {
            tailf:info "Inter Packet Interval";
            type uint32 {
              tailf:info "<4-60000>;;Delay (default 20)";
            }
            default 20;
          }
        }

        // ip sla * / udp-echo *
        list udp-echo {
          tailf:info "UDP Echo Operation";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          max-elements 1;
          key "host port";
          leaf host {
            type inet:host {
              tailf:info "Hostname or A.B.C.D;;Destination IP address or hostname, broadcast disallowed";
            }
          }
          leaf port {
            type uint16 {
              tailf:info "<0-65535>;;Port Number";
            }
          }
          // ip sla * / udp-echo * control
          leaf control {
            tailf:info "Enable or disable control packets";
            type enumeration {
              enum disable {
                tailf:info "Disable control packets exchange";
              }
              enum enable {
                tailf:info "Enable control packets exchange (default)";
              }
            }
          }
          // ip sla * / udp-echo * source-ip
          leaf source-ip {
            tailf:info "Source Address";
            type inet:host {
              tailf:info "Hostname or A.B.C.D;;IP address or hostname, broadcast disallowed";
            }
          }
          // ip sla * / udp-echo * source-port
          leaf source-port {
            tailf:info "source-port;;Source Port";
            type uint16 {
              tailf:info "<1-65535>;;Port Number";
              range "1..65535";
            }
          }
        }

        // ip sla * / ethernet
        container ethernet {
          tailf:info "Ethernet Operations";

          // ip sla * / ethernet echo * mpid * domain *
          // ip sla * / ethernet jitter * mpid * domain *
          list ethernet-list {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-incomplete-command;
            key "type mpid domain";
            leaf type {
              type enumeration {
                enum jitter {
                  tailf:info "Ethernet Jitter Operation";
                }
                enum echo {
                  tailf:info "Ethernet Echo Operation (802.1ag Loopback)";
                }
              }
            }
            leaf mpid {
              tailf:info "Maintenance Point ID";
              tailf:cli-expose-key-name;
              type uint16 {
                tailf:info "<1-8191>;;MPID Value";
                range "1..8191";
              }
            }
            leaf domain {
              tailf:info "Domain Name";
              tailf:cli-expose-key-name;
              type string {
                tailf:info "WORD;;Domain Name Value";
              }
            }
            choice vlan-or-port {
              leaf port {
                tailf:info "DOWN service direction with no vlan association";
                type empty;
              }
              leaf vlan {
                tailf:info "VLAN ID";
                type uint16 {
                  tailf:info "<1-65535>;;VLAN ID";
                  range "1..65535";
                }
              }
              leaf evc {
                tailf:info "EVC ID";
                tailf:non-strict-leafref {
                  path "/ios:ethernet/evc/name";
                }
                type string {
                  tailf:info "WORD;;EVC ID Value";
                }
              }
            }
            leaf num-frames {
              tailf:info "Number of Frames to be transmitted";
              type uint16 {
                tailf:info "<1-60000>;;Number of frames";
              }
            }
            leaf interval {
              tailf:info "Inter Packet Interval";
              type uint16 {
                tailf:info "<4-60000>;;Delay";
                range "4..60000";
              }
            }
          }

          // ip sla * / ethernet y1731
          container y1731 {
            tailf:info "Y1731 Ethernet OAM Performance Measurement Operations";
            tailf:cli-diff-set-after "../../../../../ethernet/cfm/global";
            tailf:cli-diff-dependency "/ios:interface/GigabitEthernet/service/instance";

            // ip sla * / ethernet y1731 delay *
            list delay {
              tailf:info "Y1731 Delay and Delay Variation Operation";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              key name;
              leaf name {
                type enumeration {
                  enum "1DM" {
                    tailf:info "1DM frames";
                  }
                  enum DMM {
                    tailf:info "DMM/DMR frames";
                  }
                  enum DMMv1 {
                    tailf:info "DMMv1 frames";
                  }
                }
              }
              // ip sla * / ethernet y1731 delay * burst
              leaf burst {
                tailf:info "enable bursting of delay frames";
                tailf:cli-optional-in-sequence;
                type empty;
              }
              // ip sla * / ethernet y1731 delay * domain
              leaf domain {
                tailf:info "Specify Domain name";
                type string {
                  tailf:info "WORD;;Specify the Ethernet OAM domain";
                }
              }
              choice evc-or-vlan {
                // ip sla * / ethernet y1731 delay * evc
                leaf evc {
                  tailf:info "Specify the Ethernet Virtual Circuit Identifier";
                  type string {
                    tailf:info "WORD;;Specify the EVC Identifier value";
                  }
                }
                // ip sla * / ethernet y1731 delay * vlan
                leaf vlan {
                  tailf:info "Specify the VLAN";
                  type uint16 {
                    tailf:info "<1-4096>;;Specify Vlan value";
                    range "1..4096";
                  }
                }
              }
              // ip sla * / ethernet y1731 delay * mac-address
              // ip sla * / ethernet y1731 delay * mpid
              choice mpid-or-mac {
                leaf mac-address {
                  tailf:info "Specify the remote mac-address";
                  type string {
                    tailf:info "H.H.H;;Destination mac-address value";
                  }
                }
                leaf mpid {
                  tailf:info "Specify the remote MPID";
                  type uint16 {
                    tailf:info "<1-8191>;;Specify MPID value";
                    range "1..8191";
                  }
                }
              }
              // ip sla * / ethernet y1731 delay * cos
              leaf cos {
                tailf:info "Specify the Class of Service";
                type uint8 {
                  tailf:info "<0-7>;;Specify CoS value";
                  range "0..7";
                }
              }
              // ip sla * / ethernet y1731 delay * source
              container source {
                tailf:info "Specify the local MPID or MAC-Address";
                tailf:cli-flatten-container;
                choice mpid-or-mac {
                  // ip sla * / ethernet y1731 delay * source mac-address
                  leaf mac-address {
                    tailf:info "Specify the remote mac-address";
                    type string {
                      tailf:info "H.H.H;;Destination mac-address value";
                    }
                  }
                  // ip sla * / ethernet y1731 delay * source mpid
                  leaf mpid {
                    tailf:info "Specify the remote MPID";
                    type uint16 {
                      tailf:info "<1-8191>;;Specify MPID value";
                      range "1..8191";
                    }
                  }
                }
              }
            }

            // ip sla * / ethernet y1731 delay receive *
            container delay-receive {
              tailf:cli-drop-node-name;
              container delay {
                tailf:info "Y1731 Delay and Delay Variation Operation";
                list receive {
                  tailf:info "Receive only operation";
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  tailf:cli-compact-syntax;
                  tailf:cli-sequence-commands;
                  key name;
                  leaf name {
                    type enumeration {
                      enum "1DM" {
                        tailf:info "1DM frames";
                      }
                    }
                  }
                  // ip sla * / ethernet y1731 delay receive * domain
                  leaf domain {
                    tailf:info "Specify Domain name";
                    type string {
                      tailf:info "WORD;;Specify the Ethernet OAM domain";
                    }
                  }
                  choice evc-or-vlan {
                    // ip sla * / ethernet y1731 delay receive * evc
                    leaf evc {
                      tailf:info "Specify the Ethernet Virtual Circuit Identifier";
                      type string {
                        tailf:info "WORD;;Specify the EVC Identifier value";
                      }
                    }
                    // ip sla * / ethernet y1731 delay receive * vlan
                    leaf vlan {
                      tailf:info "Specify the VLAN";
                      type uint16 {
                        tailf:info "<1-4096>;;Specify Vlan value";
                        range "1..4096";
                      }
                    }
                  }
                  // ip sla * / ethernet y1731 delay receive * cos
                  leaf cos {
                    tailf:info "Specify the Class of Service";
                    type uint8 {
                      tailf:info "<0-7>;;Specify CoS value";
                      range "0..7";
                    }
                  }
                  // ip sla * / ethernet y1731 delay receive * mac-address
                  // ip sla * / ethernet y1731 delay receive * mpid
                  choice mpid-or-mac {
                    leaf mac-address {
                      tailf:info "Specify the remote mac-address";
                      type string {
                        tailf:info "H.H.H;;Destination mac-address value";
                      }
                    }
                    leaf mpid {
                      tailf:info "Specify the remote MPID";
                      type uint16 {
                        tailf:info "<1-8191>;;Specify MPID value";
                        range "1..8191";
                      }
                    }
                  }
                }
              }
            }

            // ip sla * / ethernet y1731 loss *
            list loss {
              tailf:info "Y1731 Loss Operation";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              key name;
              leaf name {
                type enumeration {
                  enum LMM {
                    tailf:info "LMM/LMR frames";
                  }
                  enum SLM {
                    tailf:info "SLM/SLR frames";
                  }
                }
              }
              // ip sla * / ethernet y1731 loss * burst
              leaf burst {
                tailf:info "enable bursting of SLM frames";
                tailf:cli-optional-in-sequence;
                type empty;
              }
              // ip sla * / ethernet y1731 loss * domain
              leaf domain {
                tailf:info "Specify Domain name";
                type string {
                  tailf:info "WORD;;Specify the Ethernet OAM domain";
                }
              }
              // ip sla * / ethernet y1731 loss * evc
              // ip sla * / ethernet y1731 loss * vlan
              choice evc-or-vlan {
                leaf evc {
                  tailf:info "Specify the Ethernet Virtual Circuit Identifier";
                  type string {
                    tailf:info "WORD;;Specify the EVC Identifier value";
                  }
                }
                leaf vlan {
                  tailf:info "Specify the VLAN";
                  type uint16 {
                    tailf:info "<1-4096>;;Specify Vlan value";
                    range "1..4096";
                  }
                }
              }
              // ip sla * / ethernet y1731 loss * mac-address
              // ip sla * / ethernet y1731 loss * mpid
              choice mpid-or-mac {
                leaf mac-address {
                  tailf:info "Specify the remote mac-address";
                  type string {
                    tailf:info "H.H.H;;Destination mac-address value";
                  }
                }
                leaf mpid {
                  tailf:info "Specify the remote MPID";
                  type uint16 {
                    tailf:info "<1-8191>;;Specify MPID value";
                    range "1..8191";
                  }
                }
              }
              // ip sla * / ethernet y1731 loss * cos
              leaf cos {
                tailf:info "Specify the Class of Service";
                type uint8 {
                  tailf:info "<0-7>;;Specify CoS value";
                  range "0..7";
                }
              }
              // ip sla * / ethernet y1731 loss * source
              container source {
                tailf:info "Specify the local MPID or MAC-Address";
                tailf:cli-flatten-container;
                choice mpid-or-mac {
                  // ip sla * / ethernet y1731 loss * source mac-address
                  leaf mac-address {
                    tailf:info "Specify the remote mac-address";
                    type string {
                      tailf:info "H.H.H;;Destination mac-address value";
                    }
                  }
                  // ip sla * / ethernet y1731 loss * source mpid
                  leaf mpid {
                    tailf:info "Specify the remote MPID";
                    type uint16 {
                      tailf:info "<1-8191>;;Specify MPID value";
                      range "1..8191";
                    }
                  }
                }
              }
            }
          }
        }

        // ip sla * / http get
        container http {
          tailf:info "HTTP Operation";
          leaf get {
            tailf:info "HTTP get operation";
            type string {
              tailf:info "WORD;;URL";
            }
          }
        }

        // ip sla * / service-performance * type ethernet
        // ip sla * / service-performance * type ip
        list service-performance {
          tailf:info "Service Performance Operation";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-incomplete-command;
          key type;
          leaf type {
            tailf:info "Server Performance identifer";
            tailf:cli-expose-key-name;
            type enumeration {
              enum ethernet {
                tailf:info "Service Performance Ethernet";
              }
              enum ip {
                tailf:info "Service Performance IP";
              }
            }
          }
          leaf dest-mac-addr {
            when "../type = 'ethernet'" {
              tailf:dependency "../type";
            }
            tailf:info "Specify the remote mac-address";
            type string {
              tailf:info "H.H.H;;Remote mac-address value";
            }
          }
          leaf dest-ip-addr {
            when "../type = 'ip'" {
              tailf:dependency "../type";
            }
            tailf:info "Specify the target ip";
            type inet:host {
              tailf:info "Hostname or A.B.C.D/X:X:X:X::X;;Destination IPv6/IP address or hostname";
            }
          }
          leaf vrf {
            when "../type = 'ip'" {
              tailf:dependency "../type";
            }
            tailf:info "Configure an VRF";
            tailf:cli-optional-in-sequence;
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<1-4096>;;VRF Id";
              range "1..4096";
            }
          }
          container interface {
            tailf:info "Interface Name";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            uses interface-nodiff-name-grouping;
          }
          container service {
            tailf:info "Specify the Service Instance";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            leaf instance {
              tailf:info "Specify the Service Instance";
              type uint16 {
                tailf:info "<1-4096>;;Service-Instance value";
                range "1..4096";
              }
            }
          }
          leaf ethernet {
            tailf:info "Configure an Ethernet Instance";
            type string {
              tailf:info "WORD;;EVC name";
            }
          }
        }

        // ip sla * / dns
        container dns {
          tailf:info "DNS Query Operation";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf name {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type string {
              tailf:info "WORD;;Target IP Address or Hostname";
            }
          }
          leaf name-server {
            tailf:info "Name Server";
            type inet:host {
              tailf:info "Hostname or A.B.C.D;;IP Address or hostname, broadcast disallowed";
            }
          }
        }

        // ip sla * / description
        uses description-grouping;

        // ip sla * / tos
        leaf tos {
          tailf:info "Type Of Service";
          type uint8 {
            tailf:info "<0-255>;;Type of Service Value";
          }
        }

        // ip sla * / precision
        leaf precision {
          tailf:info "Set precision of measurement";
          type enumeration {
            enum microseconds {
              tailf:info "Precision microseconds";
            }
            enum milliseconds {
              tailf:info "Precision milliseconds";
            }
          }
          default milliseconds;
        }

        // ip sla * / traffic-class
        leaf traffic-class {
          tailf:info "Traffic Class";
          type uint8 {
            tailf:info "<0-255>;;Traffic Class";
          }
        }

        // ip sla * / verify-data
        leaf verify-data {
          tailf:info "Verify data";
          type empty;
        }

        // ip sla * / data-pattern
        leaf data-pattern {
          tailf:info "Data Pattern";
          type string {
            tailf:info "WORD;;Data Pattern in Hex";
            pattern "[a-fA-F0-9].*";
          }
        }

        // ip sla * / vrf
        leaf vrf {
          tailf:info "Configure IP SLAs for a VPN Routing/Forwarding instance";
          type string {
            tailf:info "WORD;;VRF name";
          }
        }

        // ip sla * / control
        container control {
          tailf:info "Set control protocol parameters";

          // ip sla * / control timeout
          leaf timeout {
            tailf:info "How long to wait for control message timeout (default 5 seconds)";
            type uint16 {
              tailf:info "<1-10000>;;control timeout in milliseconds";
              range "1..10000";
            }
            default 5000;
          }

          // ip sla * / control retry
          leaf retry {
            tailf:info "How often the control message should do a retry (default 3 times)";
            type uint8 {
              tailf:info "<1-5>;;Retry count";
              range "1..5";
            }
            default 3;
          }
        }

        // ip sla * / owner
        leaf owner {
          tailf:info "Owner of Entry";
          tailf:cli-multi-value;
          tailf:cli-full-command;
          type string {
            tailf:info "LINE;;Owner String";
          }
        }

        // ip sla * / tag
        leaf tag {
          tailf:info "User defined tag";
          tailf:cli-multi-value;
          tailf:cli-full-command;
          type string {
            tailf:info "LINE;;Tag string";
          }
        }

        // ip sla * / frequency
        container frequency {
          tailf:info "Frequency of an operation";
          leaf seconds {
            tailf:cli-drop-node-name;
            // dep: before this created, must change timeout
            tailf:cli-diff-dependency "../../timeout" {
              tailf:cli-trigger-on-set;
            }
            // dep: before this created, must change threshold
            tailf:cli-diff-dependency "../../threshold" {
              tailf:cli-trigger-on-set;
            }
            type uint32 {
              tailf:info "<1-604800>;;Frequency in seconds (default 60)";
              range "1..604800";
            }
            default 60;
          }

          // ip sla * / frequency time
          // ip sla * / frequency iteration
          choice frequency-choice {
            leaf time {
              tailf:info "Frequency period";
              type uint32 {
                tailf:info "<20-604800>;;Specify time duration (seconds)";
                range "20..604800";
              }
            }
            container iteration {
              tailf:info "Iteration number";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf number {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type uint8 {
                  tailf:info "<1-100>;;Specify number of iteration";
                  range "1..100";
                }
              }
              leaf delay {
                tailf:info "Delay between interations";
                type uint8 {
                  tailf:info "<0-10>;;Specify delay (seconds)";
                  range "0..10";
                }
              }
            }
          }
        }

        // ip sla * / threshold
        leaf threshold {
          tailf:info "Operation threshold in milliseconds";
          type uint16 {
            tailf:info "<0-60000>;;Millisecond threshold value";
            range "0..60000";
          }
          default 5000;
        }

        // ip sla * / timeout
        leaf timeout {
          tailf:info "Timeout of an operation";
          tailf:cli-diff-dependency "../threshold";
          type uint32 {
            tailf:info "<0-604800000>;;Timeout in milliseconds";
            range "0..604800000";
          }
          default 5000;
        }

        // ip sla * / loopback direction internal
        container loopback {
          tailf:info "loopback";
          container direction {
            tailf:info "loopback direction";
            leaf internal {
              tailf:info "internal direction";
              type empty;
            }
          }
        }

        // ip sla * / frame
        container frame {
          tailf:info "Specify frame parameters";

          // ip sla * / frame size
          leaf size {
            tailf:info "Specify payload size in 4 octet increments";
            type uint16 {
              tailf:info "<64-1400>;;Number of bytes in payload";
              range "64..1400";
            }
          }

          // ip sla * / frame interval
          leaf interval {
            tailf:info "Specify inter-frame period";
            type enumeration {
              enum 10 {
                tailf:info "Frame interval 10 ms";
              }
              enum 20 {
                tailf:info "Frame interval 20 ms";
              }
              enum 25 {
                tailf:info "Frame interval 25 ms";
              }
              enum 50 {
                tailf:info "Frame interval 50 ms";
              }
              enum 100 {
                tailf:info "Frame interval 100 ms";
              }
              enum 1000 {
                tailf:info "Frame interval 1 sec";
              }
            }
          }
        }

        // ip sla * / history
        container history {
          tailf:info "History and Distribution Data";

          // ip sla * / history hours-of-statistics-kept
          leaf hours-of-statistics-kept {
            tailf:info "Maximum number of statistics hour groups to capture";
            type uint8 {
              tailf:info "<0-25>;;Hour groups size value (default 2)";
              range "0..25";
            }
            default 2;
          }

          // ip sla * / history distributions-of-statistics-kept
          leaf distributions-of-statistics-kept {
            tailf:info "Maximum number of statistics distribution buckets to capture";
            type uint8 {
              tailf:info "<1-20>;;Distribution bucket size value (default 1)";
              range "1..20";
            }
            default 1;
          }

          // ip sla * / history statistics-distribution-interval
          leaf statistics-distribution-interval {
            tailf:info "Statistics distribution interval size";
            when "not(../../precision) or (../../precision = 'milliseconds')" {
              tailf:dependency "../../precision";
            }
            type uint8 {
              tailf:info "<1-100>;;Distribution interval value (default 20)";
              range "1..100";
            }
            default 20;
          }
          leaf statistics-distribution-interval-microseconds {
            tailf:info "Statistics distribution interval size (usec)";
            tailf:alt-name "statistics-distribution-interval";
            when "../../precision = 'microseconds'" {
              tailf:dependency "../../precision";
            }
            type uint32 {
              tailf:info "<1-100000>;;Distribution interval value in usec (default 20000)";
              range "1..100000";
            }
            default 20000;
          }

          // ip sla * / history lives-kept
          leaf lives-kept {
            tailf:info "Maximum number of history lives to collect";
            type uint8 {
              tailf:info "<0-2>;;Life size value (default 0)";
              range "0..2";
            }
            default 0;
          }

          // ip sla * / history buckets-kept
          leaf buckets-kept {
            tailf:info "Maximum number of history buckets to collect";
            type uint8 {
              tailf:info "<1-60>;;Bucket size value (default 15)";
              range "1..60";
            }
            default 15;
          }

          // ip sla * / history filter
          leaf filter {
            tailf:info "Add operation to History when...";
            type enumeration {
              enum all {
                tailf:info "Collect every operation in History";
              }
              enum failures {
                tailf:info "Collect operations that fail in History";
              }
              enum none {
                tailf:info "Shutoff History collection";
              }
              enum overThreshold {
                tailf:info "Collect operations that are over threshold in History";
              }
            }
          }

          // ip sla * / history enhanced
          container enhanced {
            tailf:info "Enable enhanced history collection";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf interval {
              tailf:info "Aggregation interval";
              tailf:cli-incomplete-command;
              type uint16 {
                tailf:info "<1-3600>;;Interval in seconds";
                range "1..3600";
              }
            }
            leaf buckets {
              tailf:info "Number of buckets to collect data";
              type uint8 {
                tailf:info "<1-100>;;Number of buckets";
                range "1..100";
              }
            }
          }

          // ip sla * / history interval
          leaf interval {
            tailf:info "Specify number of intervals";
            type uint8 {
              tailf:info "<1-10>;;Number of intervals to store";
              range "1..10";
            }
          }
        }

        // ip sla * / duration
        container duration {
          tailf:info "Service Performance duration configuration";
          leaf time {
            tailf:info "Time based duration";
            type uint32 {
              tailf:info "<1-86400>;;Specify time duration in seconds";
              range "1..86400";
            }
          }
        }

        // ip sla * / measurement-type
        list measurement-type {
          tailf:info "Measurement";
          tailf:cli-mode-name "config-sla-service-performance-measurement";
          key direction;
          leaf direction {
            tailf:cli-expose-key-name;
            tailf:info "Measurement direction";
            type enumeration {
              enum internal {
                tailf:info "internal direction";
              }
              enum external {
                tailf:info "external direction";
              }
            }
          }

          // ip sla * / service-performance * type ethernet / measurement-type / delay
          leaf delay {
            tailf:info "Delay measurement";
            type empty;
          }

          // ip sla * / service-performance * type ethernet / measurement-type / jitter
          leaf jitter {
            tailf:info "Jitter measurement";
            type empty;
          }

          // ip sla * / service-performance * type ethernet / measurement-type / loss
          leaf loss {
            tailf:info "loss measurement";
            type empty;
          }

          // ip sla * / service-performance * type ethernet / measurement-type / receive
          leaf receive {
            tailf:info "Received bytes/packets measurement";
            type empty;
          }

          // ip sla * / service-performance * type ethernet / measurement-type / throughput
          leaf throughput {
            tailf:info "Througput measurement";
            type empty;
          }
        }

        // ip sla * / profile
        container profile {
          tailf:info "Service Performance Profile";

          // ip sla * / profile packet
          container packet {
            tailf:info "Packet Profiles";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-sla-service-performance-packet";

            // ip sla * / profile packet / inner-cos
            leaf inner-cos {
              tailf:info "Inner COS";
              type uint8 {
                tailf:info "<0-7>;;COS value";
                range "0..7";
              }
            }

            // ip sla * / profile packet / outer-cos
            leaf outer-cos {
              tailf:info "Outer COS";
              type uint8 {
                tailf:info "<0-7>;;COS value";
                range "0..7";
              }
            }

            // ip sla * / profile packet / inner-vlan
            leaf inner-vlan {
              tailf:info "Specify the Inner VLAN";
              type uint16 {
                tailf:info "<1-4094>;;Specify Vlan value";
                range "1..4094";
              }
            }

            // ip sla * / profile packet / outer-vlan
            leaf outer-vlan {
              tailf:info "Specify the Outer VLAN";
              type uint16 {
                tailf:info "<1-4094>;;Specify Vlan value";
                range "1..4094";
              }
            }

            // ip sla * / profile packet / source-ip-addr
            leaf source-ip-addr {
              tailf:info "ip address";
              tailf:cli-full-command;
              type inet:host {
                tailf:info "Hostname or A.B.C.D/X:X:X:X::X;;Source IPv6/IP address or hostname";
              }
            }

            // ip sla * / profile packet / packet-size
            leaf packet-size {
              tailf:info "Packet Size";
              type enumeration {
                enum 1024 {
                  tailf:info "1024 byte";
                }
                enum 128 {
                  tailf:info "128 byte";
                }
                enum 1280 {
                  tailf:info "1280 byte";
                }
                enum 1518 {
                  tailf:info "1518 byte";
                }
                enum 256 {
                  tailf:info "256 byte";
                }
                enum 512 {
                  tailf:info "512 byte";
                }
                enum 64 {
                  tailf:info "64 byte";
                }
                enum 9216 {
                  tailf:info "9216 byte";
                }
                enum imix {
                  tailf:info "Imix packet size";
                }
              }
            }

            // ip sla * / profile packet / src-mac-addr
            leaf src-mac-addr {
              tailf:info "The source mac-address";
              type string {
                tailf:info "H.H.H;;Source mac-address value";
              }
            }
          }

          // ip sla * / profile traffic *
          list traffic {
            tailf:info "Service Performance traffic profile";
            tailf:cli-mode-name "config-sla-service-performance-traffic";
            key direction;
            leaf direction {
              tailf:info "Traffic direction";
              tailf:cli-expose-key-name;
              type enumeration {
                enum internal {
                  tailf:info "internal direction";
                }
                enum external {
                  tailf:info "external direction";
                }
              }
            }

            // ip sla * / profile traffic / rate-step
            container rate-step {
              tailf:info "Rate Step";
              container kbps {
                tailf:info "Kilobits per second rate";
                tailf:cli-compact-syntax;
                leaf-list step {
                  tailf:cli-drop-node-name;
                  tailf:cli-replace-all;
                  tailf:cli-flat-list-syntax;
                  ordered-by user;
                  type uint32 {
                    tailf:info "<1-1000000>;;Step X (1-10) (Kbps/pps)";
                    range "1..1000000";
                  }
                }
              }
            }
          }
        }

        // ip sla * / cos
        leaf cos {
          tailf:info "Class Of Service";
          type uint8 {
            tailf:info "<0-7>;;Class of Service Value";
            range "0..7";
          }
        }

        // ip sla * / request-data-size
        leaf request-data-size {
          tailf:info "Request data size";
          type uint16 {
            tailf:info "<0-17512>;;Padding size (bytes) in payload";
            range "0..17512";
          }
        }

        // ip sla * / aggregate interval
        container aggregate {
          tailf:info "Aggregate parameters";
          leaf interval {
            tailf:info "Specify interval period";
            type uint16 {
              tailf:info "<1-65535>;;Aggregation period in seconds";
              range "1..65535";
            }
          }
        }

        // ip sla * / distribution
        container distribution {
          tailf:info "Specify the distribution statistics parameters";

          // ip sla * / distribution delay
          container delay {
            tailf:info "Specify delay distribution parameters";
            uses ip-sla-distribution-delay-grouping;
          }

          // ip sla * / distribution delay-variation
          container delay-variation {
            tailf:info "Specify delay-variation distribution parameters";
            uses ip-sla-distribution-delay-grouping;
          }
        }

        // ip sla * / availability algorithm
        container availability {
          tailf:info "Specify the availability parameters";
          leaf algorithm {
            tailf:info "Specify the algorithm to use";
            type enumeration {
              enum sliding-window {
                tailf:info "Use a sliding window";
              }
              enum static-window {
                tailf:info "Use a static window";
              }
            }
          }
        }
      }

      // ip sla schedule *
      list schedule {
        tailf:info "IP SLAs Entry Scheduling";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        cli:ned-diff-move-before ">>ip sla " {
          cli:arguments "when-delete|prio=+1";
        }
        cli:ned-diff-move-after ">ip sla " {
          cli:arguments "when-set|prio=+1";
        }
        key operation-number;
        leaf operation-number {
          tailf:non-strict-leafref {
            path "../../ip-sla-list/id";
          }
          type uint32 {
            tailf:info "<1-2147483647>;;Entry number";
          }
        }

        // ip sla schedule * life
        leaf life {
          tailf:info "Length of time to execute in seconds";
          type union {
            type enumeration {
              enum forever {
                tailf:info "continue running forever";
              }
            }
            type uint32 {
              tailf:info "<0-2147483647>;;Life seconds";
            }
          }
        }

        // ip sla schedule * start-time
        container start-time {
          tailf:info "When to start this entry";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          choice start-time-choice {
            leaf after {
              tailf:info "Start after a certain amount of time from now";
              type string {
                tailf:info "hh:mm:ss;;Start after (hh:mm:ss) has elapsed";
              }
            }
            leaf now {
              tailf:info "Start now";
              type empty;
            }
            leaf pending {
              tailf:info "Start pending";
              type empty;
            }
            leaf time {
              tailf:cli-drop-node-name;
              tailf:cli-disallow-value "pending|now|after";
              type string {
                tailf:info "hh:mm[:ss];;Start time (hh:mm:[ss])";
              }
            }
          }
        }

        // ip sla schedule * ageout
        leaf ageout {
          tailf:info "How long to keep this Entry when inactive";
          type uint32 {
            tailf:info "<0-2073600>;;Ageout Seconds";
          }
        }

        // ip sla schedule * recurring
        leaf recurring {
          tailf:info "Probe to be scheduled automatically every day";
          type empty;
        }
      }

      // ip sla group schedule *
      container group {
        tailf:info "Group Configuration or Group Scheduling";
        list schedule {
          tailf:info "Group scheduling";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-all-siblings;
          }
          tailf:cli-incomplete-command;
          key id;
          leaf id {
            tailf:cli-diff-dependency "../../../ip-sla-list";
            type uint32 {
              tailf:info "<1-2147483647>;;Group schedule entry number";
              range "1..2147483647";
            }
          }
          leaf-list operation-ids {
            tailf:cli-drop-node-name;
            tailf:cli-range-list-syntax;
            tailf:cli-remove-before-change;
            tailf:cli-incomplete-command;
            ios:leaf-list-modify-remove ".*(ip sla group schedule \\d+) (\\S+) :: add :: delete";
            type uint32 {
              tailf:info "<1-2147483647>;;Leaf-list of ip sla entry Number(s)";
              range "1..2147483647";
            }
          }

          // ip sla group schedule * schedule-together
          // ip sla group schedule * schedule-period
          choice schedule-choice {
            leaf schedule-together {
              tailf:info "Group schedule together";
              type empty;
            }
            leaf schedule-period {
              tailf:info "Group schedule period range";
              type uint32 {
                tailf:info "<1-604800>;;second";
                range "1..604800";
              }
            }
          }

          // ip sla group schedule * life
          leaf life {
            tailf:cli-break-sequence-commands;
            tailf:info "Length of time to execute in seconds";
            type union {
              type enumeration {
                enum forever {
                  tailf:info "continue running forever";
                }
              }
              type uint32 {
                tailf:info "<0-2147483647>;;Life seconds";
              }
            }
          }

          // ip sla group schedule * start-time
          container start-time {
            tailf:info "When to start this entry";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            choice start-time-choice {
              leaf after {
                tailf:info "Start after a certain amount of time from now";
                type string {
                  tailf:info "hh:mm:ss;;Start after (hh:mm:ss) has elapsed";
                }
              }
              leaf now {
                tailf:info "Start now";
                type empty;
              }
              leaf pending {
                tailf:info "Start pending";
                type empty;
              }
              leaf time {
                tailf:cli-drop-node-name;
                tailf:cli-disallow-value "pending|now|after";
                type string {
                  tailf:info "hh:mm[:ss];;Start time (hh:mm:[ss])";
                }
              }
            }
          }

          // ip sla group schedule * ageout
          leaf ageout {
            tailf:info "How long to keep this Entry when inactive";
            type uint32 {
              tailf:info "<0-2073600>;;Ageout Seconds";
            }
          }
        }
      }

      // ip sla profile packet type ip *
      // ip sla profile packet type ethernet *
      container profile {
        tailf:info "IP SLA Profile configuration";
        list packet {
          tailf:info "Create/Modify Packet Profiles ";
          tailf:cli-mode-name "config-sla-profile-packet";
          tailf:cli-sequence-commands;
          key name;
          leaf type {
            tailf:info "Specify Packet Profile type";
            tailf:cli-prefix-key;
            type enumeration {
              enum ethernet {
                tailf:info "Ethernet Profile";
              }
              enum ip {
                tailf:info "IP Profile";
              }
            }
          }
          leaf name {
            type string {
              tailf:info "WORD;;Name of Packet Profile";
            }
          }

          // ip sla profile packet type ip * / source-ip-addr
          leaf source-ip-addr {
            tailf:info "source ip address";
            tailf:cli-break-sequence-commands;
            type inet:host {
              tailf:info "Hostname or A.B.C.D/X:X:X:X::X;;Source IPv6/IP address or hostname";
            }
          }

          // ip sla profile packet type ip * / dest-ip-addr
          leaf dest-ip-addr {
            tailf:info "destination ip address";
            type inet:host {
              tailf:info "Hostname or A.B.C.D/X:X:X:X::X;;Source IPv6/IP address or hostname";
            }
          }
        }
      }

      // ip sla endpoint-list type ip *
      list endpoint-list {
        tailf:info "Endpoint list configuration";
        tailf:cli-mode-name "config-epl";
        tailf:cli-sequence-commands;
        key name;
        leaf type {
          tailf:info "Endpoint list type";
          tailf:cli-prefix-key;
          type enumeration {
            enum ip {
              tailf:info "type IP";
            }
          }
        }
        leaf name {
          type string {
            tailf:info "WORD;;Endpoint list name";
          }
        }

        // ip sla endpoint-list type ip * / description
        leaf description {
          tailf:info "Description text";
          tailf:cli-break-sequence-commands;
          tailf:cli-multi-value;
          tailf:cli-preformatted;
          tailf:cli-full-command;
          type string {
            tailf:info "LINE;;customer specific description of endpoint list";
          }
        }

        // ip sla endpoint-list type ip * / ip-address
        container ip-address {
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf address {
            tailf:cli-drop-node-name;
            tailf:cli-remove-before-change;
            tailf:cli-incomplete-command;
            type string {
              tailf:info "WORD;;Destination IP Address string";
            }
          }
          leaf port {
            tailf:info "Port";
            type uint16 {
              tailf:info "<1-65535>;;Port number (Recommended ports greater than 1023)";
            }
          }
        }
      }

      // ip sla ethernet-monitor
      container ethernet-monitor {
        tailf:info "IP SLAs Auto Ethernet configuration";

        // ip sla ethernet-monitor *
        list ip-sla-ethernet-monitor-list {
          tailf:cli-drop-node-name;
          tailf:cli-mode-name "config-ip-sla-ethernet-monitor";
          tailf:cli-full-command;
          ios:redeploy-with-change " no type " {
            cli:arguments "ip/sla/ethernet-monitor/reaction-configuration :: monitor (\\d+) :: monitor reaction-configuration $1";
          }
          key id;
          leaf id {
            type uint32 {
              tailf:info "<1-2147483647>;;Entry number";
            }
          }

          // ip sla ethernet-monitor * / type echo *
          // ip sla ethernet-monitor * / type jitter *
          list type {
            tailf:info "Type of entry";
            tailf:cli-mode-name "config-ip-sla-ethernet-params";
            ios:ignore-re-enter-mode;
            max-elements 1;
            key "type domain vlan";
            leaf type {
              type enumeration {
                enum echo {
                           tailf:info "Perform Ethernet Echo operation";
                }
                enum jitter {
                             tailf:info "Perform Ethernet Jitter operation";
                }
              }
            }
            leaf domain {
              tailf:info "Domain Name";
              tailf:cli-expose-key-name;
              type string {
                tailf:info "WORD;;Domain Name Value";
              }
            }
            leaf vlan {
              tailf:info "VLAN ID";
              tailf:cli-expose-key-name;
              type uint16 {
                tailf:info "<1-4095>;;VLAN ID";
                range "1..4095";
              }
            }

            // ip sla ethernet-monitor * / type echo * / cos
            leaf cos {
              tailf:info "Class of Service";
              type uint8 {
                tailf:info "<0-7>;;Class of Service Value";
                range "0..7";
              }
              default 0;
            }

            // ip sla ethernet-monitor * / type echo * / request-data-size
            leaf request-data-size {
              tailf:info "Request data size";
              type uint16 {
                tailf:info "<0-1400>;;Padding size (bytes) in payload";
                range "0..1400";
              }
            }
          }
        }

        // ip sla ethernet-monitor schedule * schedule-period
        list schedule {
          tailf:info "IP SLAs Auto ethernet Scheduling";
          tailf:cli-delete-when-empty;
          tailf:cli-suppress-mode;
          tailf:cli-compact-syntax;
          tailf:cli-remove-before-change;
          tailf:cli-incomplete-command;
          key operation-number;
          leaf operation-number {
            ios:config-lock "ip sla ethernet-monitor schedule (\\d+) .+ :: ip sla ethernet-monitor $1";
            cli:ned-diff-move-before ">>ip sla ethernet-monitor $1" {
              cli:arguments "when-delete :: regex=ip sla ethernet-monitor schedule (\\d+)";
            }
            type uint32 {
              tailf:info "<1-2147483647>;;Entry number";
            }
            tailf:non-strict-leafref {
              path "../../ip-sla-ethernet-monitor-list/id";
            }
          }
          leaf schedule-period {
            tailf:info "Group schedule period range";
            type uint32 {
              tailf:info "<1-604800>;;seconds";
            }
          }
          container start-time {
            tailf:info "When to start this entry";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            choice start-time-choice {
              leaf after {
                tailf:info "Start after a certain amount of time from now";
                type string {
                  tailf:info "hh:mm:ss;;Start after (hh:mm:ss) has elapsed";
                }
              }
              leaf now {
                tailf:info "Start now";
                type empty;
              }
              leaf pending {
                tailf:info "Start pending";
                type empty;
              }
              leaf time {
                tailf:cli-drop-node-name;
                type string {
                  tailf:info "hh:mm[:ss];;Start time (hh:mm:[ss])";
                }
              }
            }
          }
        }

        // ip sla ethernet-monitor reaction-configuration * react *
        list reaction-configuration {
          tailf:info "IP SLAs Ethernet CFM Reaction Configuration";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-all-siblings;
          }
          key "operation-number react";
          leaf operation-number {
            type uint32 {
              tailf:info "<1-2147483647>;;Entry number";
            }
            tailf:non-strict-leafref {
              path "../../ip-sla-ethernet-monitor-list/id";
            }
          }
          leaf react {
            tailf:info "Reaction variable to be configured";
            tailf:cli-expose-key-name;
            type string {
              tailf:info "monitored-element";
            }
          }
          uses ip-sla-reaction-grouping;
        }
      }

      // ip sla reaction-configuration *
      list reaction-configuration {
        tailf:info "IP SLAs Reaction-Configuration";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        key "operation-number react";
        leaf operation-number {
          type uint32 {
            tailf:info "<1-2147483647>;;Entry number";
          }
          tailf:non-strict-leafref {
            path "../../ip-sla-list/id";
          }
        }
        leaf react {
          tailf:info "Reaction variable to be configured";
          tailf:cli-expose-key-name;
          type string {
            tailf:info "monitored-element";
          }
        }
        uses ip-sla-reaction-grouping;
      }

      // ip sla reaction-trigger *
      list reaction-trigger {
        tailf:info "IP SLAs Trigger Assignment";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key operation-number;
        leaf operation-number {
          type uint32 {
            tailf:info "<1-2147483647>;;Entry number";
          }
          tailf:non-strict-leafref {
            path "../../ip-sla-list/id";
          }
        }
        leaf target-operation {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-2147483647>;;Target entry num";
          }
        }
      }

      // ip sla enable
      container enable {
        tailf:info "Enable Event Notifications";

        // ip sla enable timestamp
        leaf timestamp {
          tailf:info "Enable timestamping";
          type empty;
        }

        // ip sla enable reaction-alerts
        leaf reaction-alerts {
          tailf:info "Enable Reaction Alert Notifications";
          type empty;
        }
      }
    }

    // ip wccp
    container wccp {
      tailf:info "Web-Cache Coordination Protocol Commands";
      uses ip-wccp-grouping;

      // ip wccp vrf *
      list vrf {
        tailf:info "Configure WCCP for a VRF";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          tailf:cli-diff-dependency "../../../../vrf/definition";
          tailf:cli-diff-dependency "../../../../ip/vrf";
          type string {
            tailf:info "WORD;;VRF name";
          }
        }
        uses ip-wccp-grouping;
      }
    }

    // ip nbar
    container nbar {
      tailf:info "NBAR - Network Based Application Recognition";

      // ip nbar attribute-map *
      list attribute-map {
        tailf:cli-mode-name "config-attribute-map";
        key name;
        leaf name {
          type string {
            tailf:info "WORD: Attribute Profile Name";
          }
        }

        // ip nbar attribute-map * / attribute
        container attribute {
          tailf:info "Attribute Name";

          // ip nbar attribute-map * / attribute business-relevance
          leaf business-relevance {
            tailf:info "Application business-relevance";
            type enumeration {
              enum business-relevant {
                tailf:info "Business critical applications";
              }
              enum business-irrelevant {
                tailf:info "Undesirable business traffic";
              }
              enum "default" {
                tailf:info "Related business applications";
              }
            }
          }

          // ip nbar attribute-map * / attribute traffic-class
          leaf traffic-class {
            tailf:info "SRND class";
            type enumeration {
              enum transactional-data {
                tailf:info "Interactive data applications";
              }
              enum voip-telephony {
                tailf:info "VoIP telephony (bearer-only) traffic";
              }
              enum signaling {
                              tailf:info "Signaling traffic that supports IP voice and video telephony";
              }
              enum real-time-interactive {
                tailf:info "High-definition interactive video applications";
              }
              enum ops-admin-mgmt {
                tailf:info "Network operations, administration, and management traffic";
              }
              enum network-control {
                tailf:info "Network control plane traffic";
              }
              enum multimedia-streaming {
                tailf:info "Video-on-Demand (VoD) streaming video";
              }
              enum multimedia-conferencing {
                tailf:info "Desktop software multimedia collaboration applications";
              }
              enum bulk-data {
                tailf:info "Non-interactive data applications";
              }
              enum broadcast-video {
                tailf:info "Broadcast TV, live events, video surveillance";
              }
            }
          }

          // ip nbar attribute-map * / attribute application-group
          leaf application-group {
            tailf:info "Application-group attribute";
            type string {
              tailf:info "WORD;;Related applications group";
            }
          }
        }
      }

      // ip nbar custom *
      list custom {
        tailf:info "Custom PDL (protocol description language) Module";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of the User defined Protocol";
          }
        }

        // ip nbar custom * udp *
        // ip nbar custom * tcp *
        list ports {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-incomplete-command;
          tailf:cli-remove-before-change;
          key name;
          leaf name {
            type enumeration {
              enum udp {
                tailf:info "UDP ports";
              }
              enum tcp {
                tailf:info "TCP ports";
              }
            }
          }
          choice ports-choice {
            container range {
              tailf:info "Range of maximum 1000 Ports";
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf start {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type uint16 {
                  tailf:info "<1-65535>;;Enter Start port number for Range";
                }
              }
              leaf end {
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<1-65535>;;Enter End port number for Range";
                }
              }
            }
            leaf-list ports {
              tailf:cli-drop-node-name;
              tailf:cli-range-list-syntax;
              ios:space-flat-list-syntax "ip nbar custom \\S+ (?:udp|tcp) (\\S+)";
              max-elements 16;
              type uint16 {
                tailf:info "<1-65535>;;Up to 16 port numbers, NSO range-list-syntax (transformed to spaces)";
                range "1..65535";
              }
            }
          }
          leaf id {
            tailf:info "Selector ID";
            type uint16 {
              tailf:info "<1-65535>;;Enter Selector ID";
              range "1..65535";
            }
          }
        }

        // ip nbar custom * composite
        container composite {
          tailf:info "Custom protocols based on multiple underlying protocols";
          tailf:cli-compact-syntax;
          leaf server-name {
            tailf:info "Match the server name based on various protocols";
            type string {
              tailf:info "WORD  Enter String Format - cannot exceed 30 characters";
            }
          }
          leaf id {
            tailf:info "Selector ID";
            type uint16 {
              tailf:info "<1-65535>;;Enter Selector ID";
              range "1..65535";
            }
          }
        }
      }

      // ip nbar attribute-set *
      list attribute-set {
        tailf:info "Set attribute-set";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key protocol-name;
        leaf protocol-name {
          type string {
            tailf:info "WORD;;Name of protocol";
          }
        }
        leaf profile-name {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "Attribute Profile Name";
          }
          tailf:non-strict-leafref {
            path "../../attribute-map/name";
          }
        }
      }

      // ip nbar pdlm *
      list pdlm {
        tailf:info "PDL (protocol description language) Module - DEPRECATED!";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Load PDLM from <file> - DEPRECATED!";
          }
        }
      }

      // ip nbar port-map * udp *
      // ip nbar port-map * tcp *
      list port-map {
        tailf:info "Map well-known port of a protocol to a new port";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Protocol name";
          }
        }
        leaf-list udp {
          tailf:info "UDP ports";
          tailf:cli-flat-list-syntax;
          tailf:cli-replace-all;
          ordered-by user;
          max-elements 16;
          type uint16 {
            tailf:info "<1-65535>;;Up to 16 port numbers separated by white-spaces";
            range "1..65535";
          }
        }
        leaf-list tcp {
          tailf:info "TCP ports";
          tailf:cli-flat-list-syntax;
          tailf:cli-replace-all;
          ordered-by user;
          max-elements 16;
          type uint16 {
            tailf:info "<1-65535>;;Up to 16 port numbers separated by white-spaces";
            range "1..65535";
          }
        }
      }

      // ip nbar protocol-discovery
      container protocol-discovery {
        tailf:info "Enable protocol discovery for both ipv4 and ipv6";
        presence true;
      }

      // ip nbar protocol-pack
      container protocol-pack {
        tailf:info "Protocol Pack";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf path {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;Load protocol pack from <path>";
          }
        }
        leaf force {
          tailf:info "Force";
          type empty;
        }
      }
    }

    // ip inspect
    container inspect {
      tailf:info "Context-based Access Control Engine";

      // ip inspect name *
      list name {
        tailf:info "Specify an inspection rule";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of inspection defined (16 characters max)";
          }
        }
        list rule {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-show-long-obu-diffs;
          ordered-by user;
          key rule;
          leaf rule {
            tailf:cli-multi-word-key;
            type string {
              tailf:info "WORD;;Rule";
            }
          }
        }
      }
    }

    // no ip spd enable
    container spd {
      tailf:info "Selective Packet Discard parameters";
      leaf enable {
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }
    }

    // ip spd X
    container spd-conf {
      tailf:cli-drop-node-name;
      container spd {
        tailf:info "Selective Packet Discard parameters";
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;

        // ip spd queue
        container queue {
          tailf:info "SPD IP queuing thresholds";
          leaf max-threshold {
            tailf:info "Sets SPD max threshold";
            type uint16 {
              tailf:info "<0-65535>;;Max queue threshold";
            }
            default 74;
          }
          leaf min-threshold {
            tailf:info "Sets SPD min threshold";
            type uint16 {
              tailf:info "<0-65535>;;Min queue threshold";
            }
            default 73;
          }
        }
      }
    }

    // ip source binding *
    container source {
      tailf:info "static IP binding";
      list binding {
        tailf:info "static IP binding";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-incomplete-command;
        key "mac-address vlan";
        leaf mac-address {
          tailf:cli-diff-dependency "../../../../interface/Ethernet/switchport";
          tailf:cli-diff-dependency "../../../../interface/FastEthernet/switchport";
          tailf:cli-diff-dependency "../../../../interface/GigabitEthernet/switchport";
          tailf:cli-diff-dependency "../../../../interface/TenGigabitEthernet/switchport";
          tailf:cli-diff-dependency "../../../../interface/FortyGigabitEthernet/switchport";
          tailf:cli-diff-dependency "../../../../interface/HundredGigE/switchport";
          tailf:cli-diff-dependency "../../../../interface/Port-channel/switchport";
          type string {
            tailf:info "H.H.H;;binding MAC address";
          }
        }
        leaf vlan {
          tailf:info "binding VLAN learned";
          tailf:cli-expose-key-name;
          type uint16 {
            tailf:info "<1-4094>;;binding VLAN number";
            range "1..4094";
          }
        }
        leaf ip-address {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;binding IP address";
          }
        }
        container interface {
          tailf:info "binding interface";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          uses interface-name-grouping;
        }
      }
    }

    // ip ips
    container ips {
      tailf:info "Intrusion Prevention System";

      // ip ips po max-events
      container po {
        tailf:info "Specify nr-director's PostOffice information (for sending events to the nr-directors";
        leaf max-events {
          tailf:info "Specify number of Post Office event structures";
          type uint16 {
            tailf:info "<1-65535>;;Number of Post Office event structures";
            range "1..65535";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// isdn
  /// ========================================================================

  container isdn {
    tailf:info "ISDN configuration commands";

    // isdn switch-type
    leaf switch-type {
      tailf:info "Select the ISDN switch type";
      tailf:cli-full-command;
      type string {
        tailf:info "WORD;;switch type";
      }
    }

    // isdn leased-line
    container leased-line {
      tailf:info "Sets a BRI interface to support leased lines on B & D channels";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      cli:ned-diff-move-before ">interface" {
        cli:arguments "when-set";
      }
      leaf BRI {
        tailf:info "ISDN Basic Rate Interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "../../../interface/BRI/name";
        }
        type string {
          tailf:info "<slot>/<port>;;BRI interface number";
          pattern '[0-9]+.*';
        }
      }
      leaf hundredtwentyeight {
        tailf:alt-name "128";
        tailf:info "combined B1+B2 channels leased line";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// vmps
  /// ========================================================================

  container vmps {
    tailf:info "VMPS settings";

    // vmps reconfirm
    leaf reconfirm {
      tailf:info "Set VMPS reconfirm interval";
      type uint8 {
        tailf:info "Number of minutes between reconfirmations";
        range "0..120";
      }
    }

    // vmps retry
    leaf retry {
      tailf:info "Set VMPS retry count";
      type uint8 {
        tailf:info "<1-10>;;Retry count per server";
        range "1..10";
      }
    }

    // vmps server *
    list server {
      tailf:info "Configure server IP address";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key name;
      leaf name {
        type inet:host {
          tailf:info "Hostname or A.B.C.D;;IP address";
        }
      }
      // vmps server * primary
      leaf primary {
        tailf:info "Specify primary server";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// ipv6
  /// ========================================================================

  container ipv6 {
    tailf:info "Global IPv6 configuration commands";

    // ipv6 unicast-routing
    leaf unicast-routing {
      tailf:info "Enable unicast routing";
      type empty;
    }

    // ipv6 source-route
    // no ipv6 source-route
    leaf source-route {
      tailf:info "Process packets with source routing header options";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
    }

    // ipv6 hop-limit
    leaf hop-limit {
      tailf:info "Configure hop count limit";
      type uint16 {
        tailf:info "<1-255>;;Hop Limit value";
        range "1..255";
      }
      default 64;
    }

    // ipv6 cef
    // no ipv6 cef
    leaf cef {
      tailf:info "Cisco Express Forwarding";
      tailf:cli-show-no;
      tailf:cli-diff-dependency "../unicast-routing";
      type empty;
    }

    // ipv6 cef X
    container cef-conf {
      tailf:cli-drop-node-name;
      container cef {
        tailf:info "Cisco Express Forwarding";
        tailf:cli-incomplete-no;
        tailf:cli-incomplete-command;
        tailf:cli-diff-dependency "../../cef";

        // ipv6 cef accounting
        container accounting {
          tailf:info "Enable CEF accounting";
          tailf:cli-compact-syntax;
          leaf per-prefix {
            tailf:info "Enable per prefix accounting";
            type empty;
          }
          leaf prefix-length {
            tailf:info "Enable prefix length accounting";
            type empty;
          }
        }

        // ipv6 cef distributed
        leaf distributed {
          tailf:info "Distributed Cisco Express Forwarding";
          tailf:cli-full-command;
          type empty;
        }

        // ipv6 cef load-sharing algorithm
        container load-sharing {
          tailf:info "Load sharing";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf algorithm {
            tailf:info "Per-destination load sharing algorithm selection";
            type enumeration {
              enum original {
                             tailf:info "Original algorithm";
              }
              enum universal {
                              tailf:info "Algorithm for use in most environments";
              }
              enum include-ports {
                tailf:info "Algorithm that includes layer 4 ports";
              }
            }
            default universal;
          }
          leaf source {
            tailf:info "Use source port in hash function";
            tailf:cli-optional-in-sequence;
            when "../algorithm = 'include-ports'" {
              tailf:dependency "../algorithm";
            }
            type empty;
          }
          leaf destination {
            tailf:info "Use destination port in hash function";
            tailf:cli-optional-in-sequence;
            when "../algorithm = 'include-ports'" {
              tailf:dependency "../algorithm";
            }
            type empty;
          }
          leaf id {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "<1-FFFFFFFF>;;Fixed ID";
            }
          }
        }
      }
    }

    // ipv6 flowset
    leaf flowset {
      tailf:info "Set flow label random for originated packets";
      tailf:cli-full-command;
      type empty;
    }

    // ipv6 icmp error-interval
    container icmp {
      tailf:info "Configure ICMP parameters";
      container error-interval {
        tailf:info "Interval between ICMP error messages";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf milliseconds {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<0-2147483647>;;Interval between tokens in milliseconds";
            range "0..2147483647";
          }
        }
        leaf bucketsize {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<1-200>;;Bucket size";
            range "1..200";
          }
        }
      }
    }

    // ipv6 wccp
    container wccp {
      tailf:info "Web-Cache Coordination Protocol IPv6 Commands";
      uses ip-wccp-grouping;

      // ipv6 wccp vrf *
      list vrf {
        tailf:info "Configure WCCP for a VRF";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          tailf:cli-diff-dependency "../../../../vrf/definition";
          type string {
            tailf:info "WORD;;VRF name";
          }
        }
        uses ip-wccp-grouping;
      }
    }

    // ipv6 mld
    container mld {
      tailf:info "Global mld commands";

      // no ipv6 mld snooping
      container snooping-enable {
        tailf:cli-drop-node-name;
        leaf snooping {
          tailf:info "Global MLD Snooping enable for Catalyst Vlans";
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }
      }

      // ipv6 mld state-limit
      leaf state-limit {
        tailf:info "State Limit";
        type uint16 {
          tailf:info "<1-64000>;;Max Allowed State";
          range "1..64000";
        }
      }
    }

    // ipv6 multicast-routing
    leaf multicast-routing {
      tailf:info "Enable IPv6 multicast";
      type empty;
    }

    // ipv6 multicast
    container multicast {
      tailf:info "Configure multicast related commands";

      // ipv6 multicast rpf backoff
      container rpf {
        tailf:info "Configure multicast RPF related commands";
        container backoff {
          tailf:info "Backoff delay after unicast routing change";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf initial-delay {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<200-65535>;;Initial RPF backoff delay in milliseconds";
              range "200..65535";
            }
          }
          leaf max-delay {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<200-65535>;;Maximum RPF backoff delay in milliseconds";
              range "200..65535";
            }
          }
        }
        leaf use-bgp {
          tailf:info "Use BGP routes for multicast RPF lookup";
          type empty;
        }
      }

      // ipv6 multicast hardware-switching
      container hardware-switching {
        tailf:info "Hardware switching for IPv6 multicast packets";

        // ipv6 multicast hardware-switching replication-mode
        leaf replication-mode {
          tailf:info "Set HW replication mode";
          type enumeration {
            enum ingress {
                          tailf:info "Set HW Ingress replication mode";
            }
          }
        }
      }
    }

    // no ipv6 mfib
    container mfib-enable {
      tailf:cli-drop-node-name;
      leaf mfib {
        tailf:info "Multicast Forwarding";
        tailf:cli-boolean-no;
        type boolean;
        default true;
      }
    }

    // ipv6 mfib hardware-switching
    container mfib {
      tailf:info "Multicast Forwarding";
      tailf:cli-incomplete-command;
      tailf:cli-incomplete-no;
      container hardware-switching {
        tailf:info "hardware switching for IPv6 multicast packets";

        // ipv6 mfib hardware-switching replication-mode ingress
        container replication-mode {
          tailf:info "Set HW replication mode";
          leaf ingress {
            tailf:info "Set HW Ingress replication mode";
            type empty;
          }
        }
      }
    }

    // ipv6 spd queue
    container spd {
      tailf:info "Selective Packet Discard (SPD)";
      container queue {
        tailf:info "SPD queue";

        // ipv6 spd queue min-threshold
        leaf min-threshold {
          tailf:info "SPD minimum threshold";
          type uint16 {
            tailf:info "<1-65535>;;spd value. Default 73";
            range "1..65535";
          }
          default 73;
        }

        // ipv6 spd queue max-threshold
        leaf max-threshold {
          tailf:info "SPD maximum threshold";
          tailf:cli-diff-dependency "../min-threshold";
          type uint16 {
            tailf:info "<1-65535>;;spd value. Default 74";
            range "1..65535";
          }
          default 74;
        }
      }
    }

    // ipv6 route
    container route {
      tailf:info "Configure static routes";

      // ipv6 route static
      container static {
        tailf:info "Configure static route attributes";

        // ipv6 route static bfd *
        list bfd {
          tailf:info "Configure a Static Route BFD neighbor";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key "interface ipv6-address";
          leaf interface {
            type string {
              tailf:info "WORD;;Interface name";
            }
          }
          leaf ipv6-address {
            type inet:ipv6-address {
              tailf:info "X:X:X:X::X;;IPv6 address of BFD neighbor";
            }
          }
          leaf unassociated {
            tailf:info "Unassociated Neighbor";
            type empty;
          }
        }

        // ipv6 route static bfd vrf *
        container bfd-list-vrf {
          tailf:cli-drop-node-name;
          container bfd {
            tailf:info "Configure a Static Route BFD neighbor";
            list vrf {
              tailf:info "IPv6 Routing table";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              key "name interface ipv6-address";
              leaf name {
                type string {
                  tailf:info "WORD;;VRF name";
                }
              }
              leaf interface {
                type string {
                  tailf:info "WORD;;Interface name";
                }
              }
              leaf ipv6-address {
                type inet:ipv6-address {
                  tailf:info "X:X:X:X::X;;IPv6 address of BFD neighbor";
                }
              }
              leaf unassociated {
                tailf:info "Unassociated Neighbor";
                type empty;
              }
            }
          }
        }
      }

      // ipv6 route vrf *
      list vrf {
        tailf:info "Configure static route for a VPN Routing/Forwarding instance";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;VRF name";
          }
        }
        uses ipv6-route-grouping;
      }

      // ipv6 route *
      container no-vrf {
        tailf:cli-drop-node-name;
        uses ipv6-route-grouping;
      }
    }

    // ipv6 general-prefix *
    list general-prefix {
      tailf:info "Configure a general IPv6 prefix";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-incomplete-command;
      tailf:cli-remove-before-change;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;General prefix name";
        }
      }
      choice prefix-choice {
        leaf prefix {
          tailf:cli-drop-node-name;
          type ipv6-prefix {
            tailf:info "X:X:X:X::X/<0-128>;;IPv6 prefix";
          }
        }
        case interface {
          leaf type {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type enumeration {
              enum 6rd {
                tailf:info "6rd";
              }
              enum 6to4 {
                tailf:info "6to4";
              }
            }
          }
          container interface {
            tailf:cli-drop-node-name;
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            uses interface-name-grouping;
          }
        }
      }
    }

    // ipv6 prefix-list *
    container prefix-list {
      tailf:info "Build a prefix list";

      // no ipv6 prefix-list sequence-number
      leaf sequence-number {
        tailf:info "Include/exclude sequence numbers in NVGEN";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        cli:ned-diff-stay-after ">no ipv6 prefix-list ";
        type boolean;
        default true;
      }

      // ipv6 prefix-list * seq *
      list prefixes {
        when "not(../sequence-number) or (../sequence-number = 'true')" {
          tailf:dependency "../sequence-number";
        }
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          tailf:cli-disallow-value "sequence-number";
          type string {
            tailf:info "WORD;;Name of a prefix list";
          }
        }

        // ipv6 prefix-list * description
        leaf description {
          tailf:info "Prefix-list specific description";
          tailf:cli-multi-value;
          tailf:cli-preformatted;
          tailf:cli-full-command;
          type string {
            tailf:info "LINE;;Up to 80 characters describing this prefix-list";
            length "1..80";
          }
        }

        // ipv6 prefix-list * seq *
        list seq {
          tailf:info "sequence number of an entry";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-remove-before-change;
          cli:ned-diff-move-before ">ipv6 prefix-list $1 seq " {
            cli:arguments "when-delete :: regex=ipv6 prefix-list (\\S+) seq ";
          }
          key no;
          leaf no {
            type uint32 {
              tailf:info "<1-4294967294>;;Sequence number";
              range "1..4294967294";
            }
          }

          // ipv6 prefix-list * seq * deny
          container deny {
            tailf:info "Specify packets to reject";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-all-siblings;
            }
            leaf ip {
              tailf:cli-drop-node-name;
              type ios:ipv6-prefix {
                tailf:info "X:X:X:X::X/<0-128>;;IPv6 prefix";
              }
            }
            leaf ge {
              tailf:info "Minimum prefix length to be matched";
              tailf:cli-break-sequence-commands;
              type uint16 {
                tailf:info "<1-128>;;Minimum prefix length";
                range "1..128";
              }
            }
            leaf le {
              tailf:info "Maximum prefix length to be matched";
              tailf:cli-full-command;
              type uint16 {
                tailf:info "<1-128>;;Maximum prefix length";
                range "1..128";
              }
            }
          }

          // ipv6 prefix-list * seq * permit
          container permit {
            tailf:info "Specify packets to forward";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-all-siblings;
            }
            leaf ip {
              tailf:cli-drop-node-name;
              tailf:cli-remove-before-change;
              type ios:ipv6-prefix {
                tailf:info "X:X:X:X::X/<0-128>;;IPv6 prefix";
              }
            }
            leaf ge {
              tailf:info "Minimum prefix length to be matched";
              tailf:cli-break-sequence-commands;
              type uint16 {
                tailf:info "<1-128>;;Minimum prefix length";
                range "1..128";
              }
            }
            leaf le {
              tailf:info "Maximum prefix length to be matched";
              tailf:cli-full-command;
              type uint16 {
                tailf:info "<1-128>;;Maximum prefix length";
                range "1..128";
              }
            }
          }
        }
      }

      // ipv6 prefix-list *
      list prefixes-no-seq {
        when "../sequence-number = 'false'" {
          tailf:dependency "../sequence-number";
        }
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          tailf:cli-disallow-value "sequence-number";
          type string {
            tailf:info "WORD;;Name of a prefix list";
          }
        }

        // ipv6 prefix-list * description
        leaf description {
          tailf:info "Prefix-list specific description";
          tailf:cli-multi-value;
          tailf:cli-preformatted;
          tailf:cli-full-command;
          type string {
            tailf:info "LINE;;Up to 80 characters describing this prefix-list";
            length "1..80";
          }
        }

        // ipv6 prefix-list *
        list entry {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-show-long-obu-diffs;
          ordered-by user;
          cli:ned-diff-add ">no ipv6 prefix-list <STAY> :: before :: >ipv6 prefix-list <STAY>" {
            cli:arguments "when-delete";
          }
          key rule;
          leaf rule {
            tailf:cli-multi-word-key;
            type string {
              tailf:info "WORD;;permit <entry> | deny <entry>";
              pattern "(deny .*)|(permit .*)";
            }
          }
        }
      }
    }

    // ipv6 access-list *
    container access-list {
      tailf:info "Configure access lists";

      // ipv6 access-list *
      list named-acl {
        when "not(../../../tailfned/api/new-ip-access-list)" {
          tailf:dependency "../../../tailfned/api/new-ip-access-list";
        }
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        tailf:cli-no-key-completion;
        tailf:cli-mode-name "config-ipv6-acl";
        key name;
        leaf name {
          tailf:cli-suppress-range;
          type string {
            tailf:info "User selected string identifying this access list";
          }
        }
        list access-list-rule {
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-drop-node-name;
          tailf:cli-compact-syntax;
          tailf:cli-show-long-obu-diffs;
          tailf:cli-case-sensitive;
          ordered-by user;
          key rule;
          leaf rule {
            tailf:cli-suppress-range;
            tailf:cli-drop-node-name;
            tailf:cli-multi-word-key;
            type string {
              tailf:info "WORD;;permit <line> | deny <line> | remark <line> | sequence <num> <rule>";
              pattern "(deny .*)|(permit .*)|(remark.*)|(sequence .*)|(dynamic .*)|(evaluate .*)";
            }
          }
        }
      }

      // METHOD 2 - 'ned-settings cisco-ios api new-ip-access-list true'
      // ipv6 access-list *
      list filter-list {
        when "../../../tailfned/api/new-ip-access-list" {
          tailf:dependency "../../../tailfned/api/new-ip-access-list";
        }
        tailf:cli-drop-node-name;
        tailf:cli-no-key-completion;
        tailf:cli-full-command;
        tailf:cli-diff-dependency "../../../ip/access-list/persistent";
        tailf:cli-mode-name "config-ipv6-acl";
        key name;
        leaf name {
          tailf:cli-suppress-range;
          type string {
            tailf:info "WORD;;User selected string identifying this access list";
          }
        }
        list sequence {
          tailf:info "Sequence number for this entry";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-remove-before-change;
          tailf:cli-incomplete-command;
          key seq;
          leaf seq {
            tailf:cli-suppress-range;
            type uint32 {
              tailf:info "<1-4294967294>;;Sequence number for this entry";
              range "1..4294967294";
            }
          }
          leaf entry {
            tailf:cli-drop-node-name;
            tailf:cli-multi-value;
            tailf:cli-diff-dependency "../../../../../object-group";
            type string {
              tailf:info "WORD;;deny | permit | remark ACL entry";
              pattern "(permit .*)|(deny .*)|(remark.*)";
            }
          }
        }
      }
    }

    // ipv6 router
    container router {
      tailf:info "Enable an IPV6 routing process";

      // ipv6 router rip *
      list rip {
        tailf:info "IPv6 Routing Information Protocol (RIPv6)";
        tailf:cli-mode-name "config-rtr";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;User selected string identifying this process";
          }
        }

        // ipv6 router rip * / address-family ipv6 vrf *
        container address-family {
          tailf:info "Enter Address Family command mode";
          container ipv6 {
            tailf:info "Address family";
            list vrf {
              tailf:cli-mode-name "config-ipv6-rtr-af";
              tailf:cli-exit-command "exit-address-family" {
                tailf:info "Exit Address Family command mode";
              }
              key name;
              leaf name {
                tailf:cli-diff-dependency "../../../../../../../ipv6/rip/vrf-mode/enable";
                tailf:cli-diff-dependency "../../../../../../../vrf/definition";
                type string {
                  tailf:info "WORD;;VPN Routing/Forwarding instance name";
                }
              }
            }
          }
        }

        // ipv6 router rip * / distribute-list prefix-list * in
        // ipv6 router rip * / distribute-list prefix-list * out
        container distribute-list {
          tailf:info "Filter networks in routing updates";
          list prefix-list {
            tailf:info "Filter connections based on an IPv6 prefix-list";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            key direction;
            leaf direction {
              type enumeration {
                enum "in" {
                  tailf:info "Filter incoming routing updates";
                }
                enum "out" {
                  tailf:info "Filter outgoing routing updates";
                }
              }
            }
            leaf prefix-list-name {
              tailf:cli-drop-node-name;
              tailf:cli-prefix-key;
              tailf:non-strict-leafref {
                path "/ios:ip/prefix-list/prefixes/name";
              }
              type string {
                tailf:info "WORD;;Prefix-list name";
              }
            }
            container interface {
              tailf:cli-drop-node-name;
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              uses interface-name-grouping;
            }
          }
        }
      }

      // ipv6 router eigrp *
      list eigrp {
        tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
        tailf:cli-mode-name "config-rtr";
        key as-no;
        leaf as-no {
          type uint16 {
            tailf:info "<1-65535>;;Autonomous System";
            range "1..65535";
          }
        }

        // ipv6 router eigrp * / eigrp router-id
        container eigrp {
          tailf:info "EIGRP specific commands";
          leaf router-id {
            tailf:info "router id for this EIGRP process";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;EIGRP Router-ID in IP address format";
            }
          }
        }

        // ipv6 router eigrp * / shutdown
        leaf shutdown {
          tailf:info "Shutdown this instance of EIGRP";
          type empty;
        }

        // ipv6 router eigrp * / passive-interface
        uses passive-interface-grouping;
      }

      // ipv6 router ospf *
      list ospf {
        tailf:info "Open Shortest Path First (OSPF)";
        tailf:cli-mode-name "config-rtr";
        key id;
        leaf id {
          tailf:cli-suppress-range;
          type uint16 {
            tailf:info "<1-65535>;;Process ID";
            range "1..65535";
          }
        }
        uses router-ospf-common-grouping;
        uses router-ospf-common-af-grouping;
        uses router-ospf-grouping;
      }
    }

    // ipv6 ospf name-lookup
    container ospf {
      tailf:info "OSPF";
      leaf name-lookup {
        tailf:info "Display OSPF router ids as DNS names";
        type empty;
      }
    }

    // ipv6 nd
    container nd {
      tailf:info "Configure IPv6 ND";

      // ipv6 nd raguard policy *
      container raguard {
        tailf:info "Configure RA guard";
        list policy {
          tailf:info "Configure a policy for feature RA guard";
          tailf:cli-mode-name "config-nd-raguard";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Name of the raguard policy";
            }
          }

          // ipv6 nd raguard policy * / trusted-port
          leaf trusted-port {
            tailf:info "Setup trusted port";
            type empty;
          }
        }
      }

      // ipv6 nd reachable-time
      leaf reachable-time {
        tailf:info "Set advertised reachability time";
        type uint32 {
          tailf:info "<0-3600000>;;Reachability time in milliseconds";
          range "0..3600000";
        }
        default 0;
      }
    }

    // ipv6 neighbor
    container neighbor {
      tailf:info "Neighbor";

      // ipv6 neighbor *
      list neighbor-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key "address interface";
        leaf address {
          type inet:ipv6-address {
            tailf:info "X:X:X:X::X;;IPv6 address";
          }
        }
        leaf interface {
          tailf:cli-diff-dependency "../../../../interface";
          type string {
            tailf:info "WORD;;Interface name";
          }
        }
        leaf hardware-address {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "H.H.H;;48-bit hardware address";
          }
        }
      }
    }

    // ipv6 local
    container local {
      tailf:info "Specify local options";

      // ipv6 local policy route-map
      container policy {
        tailf:info "Enable IPv6 policy routing";
        leaf route-map {
          tailf:info "IPv6 policy-based-routing routemap";
          tailf:non-strict-leafref {
            path "../../../../route-map/name";
          }
          type string {
            tailf:info "WORD;;Route-map name";
          }
        }
      }

      // ipv6 local pool *
      list pool {
        tailf:info "IPv6 Local prefix pool lists";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          tailf:cli-suppress-range;
          type string {
            tailf:info "WORD;;Create named local prefix pool";
          }
        }
        leaf prefix {
          tailf:cli-drop-node-name;
          tailf:cli-remove-before-change;
          tailf:cli-incomplete-command;
          type ipv6-prefix {
            tailf:info "X:X:X:X::X/<0-128>;;IPv6 pool prefix x:x::y/<z>";
          }
        }
        leaf assigned-length {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<0-128>;;Prefix length to assign from pool";
          }
        }
        leaf shared {
          tailf:info "Advertise the same prefix";
          tailf:cli-optional-in-sequence;
          type empty;
        }
        leaf cache-size {
          tailf:info "Number of free entries to search";
          type uint16;
        }
      }
    }

    // ipv6 dhcp
    container dhcp {
      tailf:info "Configure IPv6 DHCP";
      tailf:cli-diff-dependency "../local";

      // ipv6 dhcp pool *
      list pool {
        tailf:info "Configure IPv6 DHCP pool";
        tailf:cli-mode-name "config-dhcpv6";
        tailf:cli-full-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;DHCP pool name";
          }
        }

        // ipv6 dhcp pool * / vrf
        leaf vrf {
          tailf:info "Associate pool with a VRF";
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;VRF name";
          }
        }

        // ipv6 dhcp pool * / address prefix *
        list address {
          tailf:info "IPv6 address allocation";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-show-long-obu-diffs;
          ordered-by user;
          key prefix;
          leaf prefix {
            tailf:info "IPv6 address allocation prefix";
            tailf:cli-expose-key-name;
            type ios:ipv6-prefix {
              tailf:info "X:X:X:X::X/<0-128>;;IPv6  x:x::y/<z>";
            }
          }
        }

        // ipv6 dhcp pool * / dns-server *
        list dns-server {
          tailf:info "DNS servers";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-show-long-obu-diffs;
          ordered-by user;
          key address;
          leaf address {
            type inet:host {
              tailf:info "Hostname or X:X:X:X::X;;Server's name or IPv6 address";
            }
          }
        }

        // ipv6 dhcp pool * / domain-name *
        list domain-name {
          tailf:info "Domain name to complete unqualified host names";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-show-long-obu-diffs;
          ordered-by user;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;A domain name";
            }
          }
        }

        // ipv6 dhcp pool * / prefix-delegation
        container prefix-delegation {
          tailf:info "IPv6 prefix delegation";

          // ipv6 dhcp pool * / prefix-delegation pool
          container pool {
            tailf:info "IPv6 prefix pool";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf poolname {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "WORD;;IPv6 prefix pool";
              }
            }
            container lifetime {
              tailf:info "Configure prefix lifetimes";
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf valid-lifetime-seconds {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type uint32 {
                  tailf:info "<60-4294967295>;;Valid lifetime (seconds)";
                }
              }
              leaf preferred-lifetime-seconds {
                tailf:cli-drop-node-name;
                type uint32 {
                  tailf:info "<60-4294967295>;;Preferred lifetime (seconds)";
                }
              }
            }
          }
        }
      }

      // ipv6 dhcp guard policy *
      container guard {
        tailf:info "Configure IPv6 DHCP guard";
        list policy {
          tailf:info "Configure a policy for feature dhcp guard";
          tailf:cli-mode-name "config-dhcp-guard";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Name of the dhcp guard policy";
            }
          }
          choice port-choice {
            case a {
              // ipv6 dhcp guard policy * / device-role
              leaf device-role {
                tailf:info "Sets the role of the device attached to the port";
                type enumeration {
                  enum client {
                               tailf:info "Attached device is a client (default)";
                  }
                  enum server {
                               tailf:info "Attached device is a dhcp server";
                  }
                }
                default client;
              }

              // ipv6 dhcp guard policy * / match
              container match {
                tailf:info "dhcp filtering";
                tailf:cli-diff-dependency "../device-role";

                // ipv6 dhcp guard policy * / match server access-list
                container server {
                  tailf:info "permitted server source addresses";
                  leaf access-list {
                    tailf:info "specify access-list for match";
                    tailf:non-strict-leafref {
                      path "../../../../../../access-list/named-acl/name";
                    }
                    type string {
                      tailf:info "WORD;;access-list";
                    }
                  }
                }

                // ipv6 dhcp guard policy * / match reply prefix-list
                container reply {
                  tailf:info "premitted server reply prefixes";
                  leaf prefix-list {
                    tailf:info "specify prefix-list for match";
                    tailf:non-strict-leafref {
                      path "../../../../../../prefix-list/prefixes/name";
                    }
                    type string {
                      tailf:info "WORD;;prefix-list";
                    }
                  }
                }
              }
            }

            case b {
              // ipv6 dhcp guard policy * / trusted-port
              leaf trusted-port {
                tailf:info "This is a trusted port (no policing)";
                type empty;
              }
            }
          }
        }
      }
    }

    // ipv6 dhcp-relay
    container dhcp-relay {
      tailf:info "Configure IPv6 DHCP relay agent";

      // ipv6 dhcp-relay bulk-lease
      container bulk-lease {
        tailf:info "Configure IPv6 DHCP Bulk Lease Query";

        // ipv6 dhcp-relay bulk-lease disable
        leaf disable {
          tailf:info "Disable bulk lease query";
          type empty;
        }
      }
    }

    // ipv6 rip vrf-mode enable
    container rip {
      tailf:info "Configure ipv6 RIP settings";
      container vrf-mode {
        tailf:info "Enable RIPng VRF support";
        leaf enable {
          tailf:info "Enable RIPng VRF support";
          type empty;
        }
      }
    }
  }


  /// ========================================================================
  /// subscriber
  /// ========================================================================

  container subscriber {
    tailf:info "Subscriber configuration";

    // subscriber templating
    // no subscriber templating
    leaf templating {
      tailf:info "Configure subscriber templating";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
    }
  }


  /// ========================================================================
  /// avc
  /// ========================================================================

  container avc {
    tailf:info "Application visibility and control";

    // avc sd-service
    container sd-service {
      tailf:info "SD-AVC service";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-sd-service";
      presence true;

      // avc sd-service / segment
      leaf segment {
        tailf:info "Segment name identifying a group of devices sharing the same application services";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;Enter a segment name. Max - 31 chars";
        }
      }

      // avc sd-service / controller
      container controller {
        tailf:info "Controller connectivity parameters";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-sd-service-controller";

        // avc sd-service / controller / address
        leaf address {
          tailf:info "Export destination configuration";
          tailf:cli-multi-value;
          tailf:cli-full-command;
          type string {
            tailf:info "Hostname or A.B.C.D;;Secondary controller's IPv4 address or hostname";
          }
        }

        // avc sd-service / controller / source-interface
        container source-interface {
          tailf:info "Interface of source address used for communication with controller";
          uses interface-name-grouping;
        }

        // avc sd-service / controller / vrf
        leaf vrf {
          tailf:info "VRF Label";
          tailf:cli-diff-dependency "../../../../vrf/definition";
          type string {
            tailf:info "WORD;;VRF name";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// multilink
  /// ========================================================================

  container multilink {
    tailf:info "PPP multilink global configuration";

    // multilink virtual-template
    leaf virtual-template {
      tailf:info "virtual-template interface";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<1-4095>;;virtual template number";
        range "1..4095";
      }
    }

    // multilink bundle-name
    leaf bundle-name {
      tailf:info "Select method for naming multilink bundles";
      tailf:cli-full-command;
      type enumeration {
        enum authenticated {
                            tailf:info "Use peer's authenticated name";
        }
        enum both {
                   tailf:info "Use peer's authenticated name and endpoint discriminator";
        }
        enum endpoint {
                       tailf:info "Use peer's endpoint discriminator";
        }
        enum rfc {
                  tailf:info "Use peer and local authenticated name and endpoint discriminator";
        }
      }
    }

  }


  /// ========================================================================
  /// flow
  /// ========================================================================

  container flow {
    tailf:info "Global Flow configuration subcommands";

    // flow exporter *
    list exporter {
      tailf:info "Define a Flow Exporter";
      tailf:cli-mode-name "config-flow-exporter";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Flow Exporter name";
        }
      }

      // flow exporter * / description
      leaf description {
        tailf:info "Provide a description for this Flow Exporter";
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE;;Flow Exporter description";
        }
      }

      // flow exporter * / destination
      container destination {
        tailf:info "Export destination configuration";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-case-insensitive;
        leaf address {
          tailf:cli-drop-node-name;
          type inet:host {
            tailf:info "Hostname, A.B.C.D or X:X:X:X::X;;Destination IPv4 address or hostname";
          }
        }
        leaf vrf {
          tailf:info "Optional VRF label";
          tailf:cli-diff-dependency "../../../../ip/vrf";
          tailf:cli-diff-dependency "../../../../vrf/definition";
          type string {
            tailf:info "WORD;;VRF Label";
          }
        }
      }

      // flow exporter * / source
      container source {
        tailf:info "Originating interface";
        uses interface-name-grouping;
      }

      // flow exporter * / mtu
      leaf mtu {
        tailf:info "Optional MTU";
        type uint16 {
          tailf:info "<1-65535>;;MTU value";
          range "1..65535";
        }
      }

      // flow exporter * / ttl
      leaf ttl {
        tailf:info "Optional TTL or hop limit";
        type uint8 {
          tailf:info "<1-255>;;TTL value";
          range "1..255";
        }
      }

      // flow exporter * / dscp
      leaf dscp {
        tailf:info "Optional DSCP";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<0-63>;;Differentiated services codepoint value";
          range "0..63";
        }
      }

      // flow exporter * / transport udp
      container transport {
        tailf:info "Transport protocol";
        leaf udp {
          tailf:info "UDP transport protocol";
          type uint16 {
            tailf:info "<1-65535>;;Port value";
            range "1..65535";
          }
          default 9995;
        }
      }

      // flow exporter * / export-protocol
      leaf export-protocol {
        tailf:info "Export protocol version";
        tailf:cli-full-command;
        type enumeration {
          enum ipfix {
                      tailf:info "IPFIX (Version 10)";
          }
          enum netflow-v5 {
            tailf:info "NetFlow Version 5";
          }
          enum netflow-v9 {
            tailf:info "NetFlow Version 9";
          }
        }
      }

      // flow exporter * / template data timeout
      container template {
        tailf:info "Flow Exporter template configuration";
        container data {
          tailf:info "Flow Exporter data configuration";
          leaf timeout {
            tailf:info "Resend data based on a timeout";
            type uint32 {
              tailf:info "<1-86400>;;Value given in seconds";
              range "1..86400";
            }
          }
        }
      }

      // flow exporter * / option
      container option {
        tailf:info "Select an option for exporting";

        // flow exporter * / option interface-table
        container interface-table {
          tailf:info "Interface SNMP-index-to-name Table Option";
          tailf:cli-reset-container;
          presence true;
          leaf timeout {
            tailf:info "Option resend time";
            type uint32 {
              tailf:info "<1-86400>;;Time in seconds";
              range "1..86400";
            }
            default 600;
          }
        }

        // flow exporter * / option exporter-stats
        container exporter-stats {
          tailf:info "Exporter Statistics Option";
          tailf:cli-reset-container;
          presence true;
          leaf timeout {
            tailf:info "Option resend time";
            type uint32 {
              tailf:info "<1-86400>;;Time in seconds";
              range "1..86400";
            }
            default 600;
          }
        }

        // flow exporter * / option vrf-table
        container vrf-table {
          tailf:info "VRF ID-to-name Table Option";
          tailf:cli-reset-container;
          presence true;
          leaf timeout {
            tailf:info "Option resend time";
            type uint32 {
              tailf:info "<1-86400>;;Time in seconds";
              range "1..86400";
            }
            default 600;
          }
        }

        // flow exporter * / option sampler-table
        container sampler-table {
          tailf:info "Export Sampler Option";
          tailf:cli-reset-container;
          presence true;
          leaf timeout {
            tailf:info "Option resend time";
            type uint32 {
              tailf:info "<1-86400>;;Time in seconds";
              range "1..86400";
            }
            default 600;
          }
        }

        // flow exporter * / option c3pl-class-table
        container c3pl-class-table {
          tailf:info "C3PL class cce-id table";
          tailf:cli-reset-container;
          presence true;
          leaf timeout {
            tailf:info "Option resend time";
            type uint32 {
              tailf:info "<1-86400>;;Value given in seconds";
              range "1..86400";
            }
            default 600;
          }
        }

        // flow exporter * / option c3pl-policy-table
        container c3pl-policy-table {
          tailf:info "C3PL policy cce-id table";
          tailf:cli-reset-container;
          presence true;
          leaf timeout {
            tailf:info "Option resend time";
            type uint32 {
              tailf:info "<1-86400>;;Value given in seconds";
              range "1..86400";
            }
            default 600;
          }
        }

        // flow exporter * / option application-attributes
        container application-attributes {
          tailf:info "Application Attributes Table Option";
          tailf:cli-reset-container;
          presence true;
          leaf timeout {
            tailf:info "Option resend time";
            type uint32 {
              tailf:info "<1-86400>;;Time in seconds";
              range "1..86400";
            }
            default 600;
          }
        }

        // flow exporter * / option application-table
        container application-table {
          tailf:info "Application Table Option";
          tailf:cli-reset-container;
          presence true;
          leaf timeout {
            tailf:info "Option resend time";
            type uint32 {
              tailf:info "<1-86400>;;Time in seconds";
              range "1..86400";
            }
            default 600;
          }
        }
      }
    }

    // flow record *
    list record {
      tailf:cli-mode-name "config-flow-record";
      tailf:cli-full-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Flow Record name";
        }
      }
      leaf type {
        tailf:info "Type of the Flow Record";
        tailf:cli-prefix-key;
        type enumeration {
          enum mace {
                     tailf:info "Measurements Aggregation and Correlation Engine Metrics";
          }
          enum performance-monitor {
            tailf:info "Config media monitor flow record type";
          }
        }
      }

      // flow record * / description
      leaf description {
        tailf:info "Provide a description for this Flow Record";
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE;;Flow Record description";
        }
      }

      // flow record * / match
      container match {
        tailf:info "Specify a key field";

        // flow record * / match routing
        container routing {
          tailf:info "Routing attributes";

          // flow record * / match routing source
          container source {
            tailf:info "Source routing attributes";

            // flow record * / match routing source as peer
            container as-peer {
              tailf:cli-drop-node-name;
              container as {
                tailf:info "AS number of the origin network";
                tailf:cli-incomplete-command;
                tailf:cli-incomplete-no;
                leaf peer {
                  tailf:info "AS number of the peer network where the packet came from";
                  type empty;
                }
              }
            }

            // flow record * / match routing source as
            container as {
              tailf:info "AS number of the origin network";
              tailf:cli-delete-when-empty;
              tailf:cli-reset-container;
              presence true;
              leaf four-octet {
                tailf:info "4 octet AS number of the origin network";
                tailf:alt-name "4-octet";
                type empty;
              }
            }
          }

          // flow record * / match routing destination
          container destination {
            tailf:info "Destination routing attributes";

            // flow record * / match routing destination as peer
            container as-peer {
              tailf:cli-drop-node-name;
              container as {
                tailf:info "AS number of the origin network";
                tailf:cli-incomplete-command;
                tailf:cli-incomplete-no;
                leaf peer {
                  tailf:info "AS number of the peer network where the packet came from";
                  type empty;
                }
              }
            }

            // flow record * / match routing destination as
            container as {
              tailf:info "AS number of the origin network";
              tailf:cli-delete-when-empty;
              tailf:cli-reset-container;
              presence true;
              leaf four-octet {
                tailf:info "4 octet AS number of the origin network";
                tailf:alt-name "4-octet";
                type empty;
              }
            }
          }

          // flow record * / match routing vrf
          container vrf {
            tailf:info "VRF routing attributes";

            // flow record * / match routing vrf input
            leaf input {
              tailf:info "VRF ID for incoming packet";
              type empty;
            }

            // flow record * / match routing output
            leaf output {
              tailf:info "VRF ID for outgoing packet";
              type empty;
            }
          }

          // flow record * / match routing next-hop address ipv4
          container next-hop {
            tailf:info "Information regarding the next hop";
            container address {
              tailf:info "IP address of the next hop";
              leaf ipv4 {
                tailf:info "IPv4 address of the next hop";
                type empty;
              }
            }
          }
        }

        // flow record * / match ipv4
        container ipv4 {
          tailf:info "IPv4 fields";

          // flow record * / match ipv4 tos
          leaf tos {
            tailf:info "IPv4 type of service";
            type empty;
          }

          // flow record * / match ipv4 ttl
          leaf ttl {
            tailf:info "IPv4 TTL";
            type empty;
          }

          // flow record * / match ipv4 protocol
          leaf protocol {
            tailf:info "IPv4 protocol";
            type empty;
          }

          // flow record * / match ipv4 source
          container source {
            tailf:info "IPv4 source address based fields";

            // flow record * / match ipv4 source address
            leaf address {
              tailf:info "IPv4 source address";
              type empty;
            }

            // flow record * / match ipv4 source prefix
            container prefix {
              tailf:info "IPv4 address prefix for the IPv4 source address";
              tailf:cli-reset-container;
              presence true;
              // flow record * / match ipv4 source prefix minimum-mask
              leaf minimum-mask {
                tailf:info "Provide a minimum mask for this field";
                type uint8 {
                  tailf:info "<1-32>;;Specify optional minimum mask";
                  range "1..32";
                }
              }
            }

            // flow record * / match ipv4 source mask
            container mask {
              tailf:info "IPv4 address mask for the IPv4 source address";
              tailf:cli-reset-container;
              presence true;
              // flow record * / match ipv4 source prefix minimum-mask
              leaf minimum-mask {
                tailf:info "Provide a minimum mask for this field";
                type uint8 {
                  tailf:info "<1-32>;;Specify optional minimum mask";
                  range "1..32";
                }
              }
            }
          }

          // flow record * / match ipv4 destination
          container destination {
            tailf:info "IPv4 destination address based fields";

            // flow record * / match ipv4 destination address
            leaf address {
              tailf:info "IPv4 destination address";
              type empty;
            }

            // flow record * / match ipv4 destination mask
            leaf mask {
              tailf:info "IPv4 address mask for the IPv4 destination address";
              type empty;
            }
          }

          // flow record * / match ipv4 precedence
          leaf precedence {
            tailf:info "IPv4 precedence (part of TOS)";
            type empty;
          }

          // flow record * / match ipv4 dscp
          leaf dscp {
            tailf:info "IPv4 DSCP (part of TOS)";
            type empty;
          }
        }

        // flow record * / match ipv6
        container ipv6 {
          tailf:info "IPv6 fields";

          // flow record * / match ipv6 traffic-class
          leaf traffic-class {
            tailf:info "IPv6 traffic class";
            type empty;
          }

          // flow record * / match ipv6 precedence
          leaf precedence {
            tailf:info "IPv6 precedence (part of Traffic Class)";
            type empty;
          }

          // flow record * / match ipv6 protocol
          leaf protocol {
            tailf:info "IPv6 payload protocol";
            type empty;
          }

          // flow record * / match ipv6 source
          container source {
            tailf:info "IPv6 source address based fields";
            // flow record * / match ipv6 source address
            leaf address {
              tailf:info "IPv6 source address";
              type empty;
            }
          }

          // flow record * / match ipv6 destination address
          container destination {
            tailf:info "IPv6 destination address based fields";
            // flow record * / match ipv6 destination address
            leaf address {
              tailf:info "IPv6 destination address";
              type empty;
            }
          }
        }

        // flow record * / match connection
        container connection {
          tailf:info "Connection fields";

          // flow record * / match connection transaction-id
          leaf transaction-id {
            tailf:info "An identifier for a transaction between client and server";
            type empty;
          }

          // flow record * / match connection client
          container client {
            tailf:info "Client side (flow initiator) related metrics";

            // flow record * / match connection client ipv4 address
            container ipv4 {
              tailf:info "Client side IPv4 metrics";
              leaf address {
                tailf:info "IPv4 address of the flow initiator";
                type empty;
              }
            }

            // flow record * / match connection client ipv6 address
            container ipv6 {
              tailf:info "Client side IPv6 metrics";
              leaf address {
                tailf:info "IPv6 address of the flow initiator";
                type empty;
              }
            }
          }

          // flow record * / match connection server
          container server {
            tailf:info "Server side (flow responder) related metrics";

            // flow record * / match connection server ipv4 address
            container ipv4 {
              tailf:info "Server side IPv4 metrics";
              leaf address {
                tailf:info "IPv4 address of the flow responder";
                type empty;
              }
            }

            // flow record * / match connection server ipv6 address
            container ipv6 {
              tailf:info "Server side IPv6 metrics";
              leaf address {
                tailf:info "IPv6 address of the flow responder";
                type empty;
              }
            }

            // flow record * / match connection server transport port
            container transport {
              tailf:info "Server side transport metrics";
              leaf port {
                tailf:info "Transport port of the flow responder";
                type empty;
              }
            }
          }
        }

        // flow record * / match policy
        container policy {
          tailf:info "policy fields";

          // flow record * / match policy qos
          container qos {
            tailf:info "QoS policy related metrics";

            // flow record * / match policy qos classification hierarchy
            container classification {
              tailf:info "Classification metrics";
              leaf hierarchy {
                tailf:info "QoS class hierarchy";
                type empty;
              }
            }

            // flow record * / match policy qos queue
            container queue {
              tailf:info "Queue metrics";

              // flow record * / match policy qos queue drops
              leaf drops {
                tailf:info "QoS queue drops";
                type empty;
              }

              // flow record * / match policy qos queue index
              leaf index {
                tailf:info "QoS queue index";
                type empty;
              }
            }
          }
        }

        // flow record * / match datalink
        container datalink {
          tailf:info "Datalink (layer2) fields";

          // flow record * / match datalink mac
          container mac {
            tailf:info "MAC fields";

            // flow record * / match datalink mac source
            container source {
              tailf:info "source MAC fields";
              container address {
                tailf:info "Source MAC address from packet";
                leaf input {
                  tailf:info "Source MAC address from packet at input";
                  type empty;
                }
                leaf output {
                  tailf:info "Source MAC address from packet at output";
                  type empty;
                }
              }
            }

            // flow record * / match datalink mac destination
            container destination {
              tailf:info "destination MAC fields";
              container address {
                tailf:info "Destination MAC address from packet";
                leaf input {
                  tailf:info "Destination MAC address from packet at input";
                  type empty;
                }
                leaf output {
                  tailf:info "Destination MAC address from packet at output";
                  type empty;
                }
              }
            }
          }

          // flow record * / match datalink vlan
          container vlan {
            tailf:info "The VLAN the packet is on";
            leaf input {
              tailf:info "The VLAN the packet is on at input";
              type empty;
            }
            leaf output {
              tailf:info "The VLAN the packet is on at output";
              type empty;
            }
          }
        }

        // flow record * / match transport
        container transport {
          tailf:info "Transport layer fields";

          // flow record * / match transport source-port
          leaf source-port {
            tailf:info "Transport source port";
            type empty;
          }

          // flow record * / match transport destination-port
          leaf destination-port {
            tailf:info "Transport destination port";
            type empty;
          }

          // flow record * / match transport rtp ssrc
          container rtp {
            tailf:info "RTP fields";
            leaf ssrc {
              tailf:info "RTP SSRC";
              type empty;
            }
          }

          // flow record * / match transport tcp
          container tcp {
            tailf:info "TCP fields";

            // flow record * / match transport tcp flags
            leaf flags {
              tailf:info "TCP flags";
              type empty;
            }
          }

          // flow record * / match transport icmp
          container icmp {
            tailf:info "ICMP fields";

            // flow record * / match transport icmp ipv4
            container ipv4 {
              tailf:info "IPv4 ICMP fields";
              leaf type {
                tailf:info "IPv4 ICMP type";
                type empty;
              }
              leaf code {
                tailf:info "IPv4 ICMP code";
                type empty;
              }
            }
          }
        }

        // flow record * / match interface
        container interface {
          tailf:info "Interface fields";

          // flow record * / match interface input
          container input {
            tailf:info "The input interface";
            presence true;
            // flow record * / match interface input snmp
            leaf snmp {
              tailf:info "SNMP Index of the input interface";
              type empty;
            }
          }

          // flow record * / match interface output
          container output {
            tailf:info "The output interface";
            presence true;
            // flow record * / match interface output snmp
            leaf snmp {
              tailf:info "SNMP Index of the output interface";
              type empty;
            }
          }
        }

        // flow record * / match flow
        container flow {
          tailf:info "Flow identifying fields";

          // flow record * / match flow direction
          leaf direction {
            tailf:info "Direction the flow was monitored in";
            type empty;
          }

          // flow record * / match flow sampler
          container sampler {
            tailf:info "ID of the sampler";
            presence true;
            // flow record * / match flow sampler hash digest-value
            container hash {
              tailf:info "Flow sampler hash related fields";
              leaf digest-value {
                tailf:info "Result of the hash for hash-based sampling algorithm";
                type empty;
              }
            }
          }
        }

        // flow record * / match application name
        container application {
          tailf:info "Application fields";
          container name {
            tailf:info "Application name";
            tailf:cli-delete-when-empty;
            presence true;
            // flow record * / match application name account-on-resolution
            leaf account-on-resolution {
              tailf:info "Account on resolution";
              type empty;
            }
          }
        }
      }

      // flow record * / collect
      container collect {
        tailf:info "Specify a non-key field";

        // flow record * / collect routing
        container routing {
          tailf:info "Routing attributes";

          // flow record * / collect routing source as
          container source {
            tailf:info "Source routing attributes";
            container as {
              tailf:info "AS number of the origin network";
              tailf:cli-compact-syntax;
              tailf:cli-reset-container;
              tailf:cli-delete-when-empty;
              presence true;
              leaf peer {
                tailf:info "AS number of the peer network where the packet came from";
                type empty;
              }
              leaf four-octet {
                tailf:info "4 octet AS number of the origin network";
                tailf:alt-name "4-octet";
                type empty;
              }
            }
          }

          // flow record * / collect routing destination as
          container destination {
            tailf:info "Destination routing attributes";
            container as {
              tailf:info "AS number of the destination network";
              tailf:cli-compact-syntax;
              tailf:cli-reset-container;
              tailf:cli-delete-when-empty;
              presence true;
              leaf peer {
                tailf:info "AS number of the peer network where the packet came from";
                type empty;
              }
              leaf four-octet {
                tailf:info "4 octet AS number of the origin network";
                tailf:alt-name "4-octet";
                type empty;
              }
            }
          }

          // flow record * / collect routing vrf
          container vrf {
            tailf:info "VRF routing attributes";

            // flow record * / collect routing vrf input
            leaf input {
              tailf:info "VRF ID for incoming packet";
              type empty;
            }

            // flow record * / collect routing vrf output
            leaf output {
              tailf:info "VRF ID for outgoing packet";
              type empty;
            }
          }

          // flow record * / collect routing next-hop address
          container next-hop {
            tailf:info "Information regarding the next hop";
            container address {
              tailf:info "IP address of the next hop";

              // flow record * / collect routing next-hop address ipv4
              container ipv4 {
                tailf:info "IPv4 address of the next hop";
                presence true;
                leaf bgp {
                  tailf:info "IPv4 address of the BGP next hop";
                  type empty;
                }
              }

              // flow record * / collect routing next-hop address ipv6
              container ipv6 {
                tailf:info "Ipv6 address of the next hop";
                presence true;
                leaf bgp {
                  tailf:info "Ipv6 address of the BGP next hop";
                  type empty;
                }
              }
            }
          }

          // flow record * / collect routing forwarding-status
          container forwarding-status {
            tailf:info "Forwarding status of the packet";
            presence true;
          }

          // flow record * / collect routing is-multicast
          leaf is-multicast {
            tailf:info "Indicates if this is multicast";
            type empty;
          }
        }

        // flow record * / collect ipv4
        container ipv4 {
          tailf:info "IPv4 fields";

          // flow record * / collect ipv4 dscp
          leaf dscp {
            tailf:info "IPv4 DSCP (part of TOS)";
            type empty;
          }

          // flow record * / collect ipv4 tos
          leaf tos {
            tailf:info "IPv4 type of service";
            type empty;
          }

          // flow record * / collect ipv4 id
          leaf id {
            tailf:info "IPv4 ID";
            type empty;
          }

          // flow record * / total-length
          leaf total-length {
            tailf:info "IPv4 total length";
            tailf:cli-full-command;
            type empty;
          }

          // flow record * / total-length minimum
          // flow record * / total-length maximum
          container total-length-min-max {
            tailf:cli-drop-node-name;
            container total-length {
              tailf:info "IPv4 total length";
              tailf:cli-incomplete-command;
              tailf:cli-incomplete-no;
              leaf minimum {
                tailf:info "Smallest value for IPv4 length seen in the flow";
                type empty;
              }
              leaf maximum {
                tailf:info "Largest value for IPv4 length seen in the flow";
                type empty;
              }
            }
          }

          // flow record * / collect ipv4 ttl
          container ttl {
            tailf:info "IPv4 TTL";
            presence true;
          }

          // flow record * / collect ipv4 ttl minimum
          // flow record * / collect ipv4 ttl maximum
          container ttl-min-max {
            tailf:cli-drop-node-name;
            container ttl {
              tailf:info "IPv4 TTL";
              tailf:cli-incomplete-command;
              tailf:cli-incomplete-no;
              leaf minimum {
                tailf:info "Smallest value seen for TTL in the flow";
                type empty;
              }
              leaf maximum {
                tailf:info "Largest value seen for TTL in the flow";
                type empty;
              }
            }
          }

          // flow record * / collect ipv4 source
          container source {
            tailf:info "IPv4 source address based fields";

            // flow record * / collect ipv4 source mask
            container mask {
              tailf:info "IPv4 address mask for the IPv4 source address";
              presence true;
            }

            // flow record * / collect ipv4 source prefix
            container prefix {
              tailf:info "IPv4 address prefix for the IPv4 source address";
              presence true;
            }
          }

          // flow record * / collect ipv4 destination mask
          container destination {
            tailf:info "IPv4 destination address based fields";
            container mask {
              tailf:info "IPv4 address mask for the IPv4 destination address";
              presence true;
            }
          }

          // flow record * / collect ipv4 fragmentation flags
          container fragmentation {
            tailf:info "IPv4 fragmentation fields";
            leaf flags {
              tailf:info "IPv4 fragmentation flags";
              type empty;
            }
            leaf offset {
              tailf:info "IPv4 fragmentation offset";
              type empty;
            }
          }
        }

        // flow record * / collect ipv6
        container ipv6 {
          tailf:info "IPv6 fields";

          // flow record * / collect ipv6 dscp
          leaf dscp {
            tailf:info "IPv6 DSCP (part of Traffic Class)";
            type empty;
          }

          // flow record * / collect ipv6 source
          container source {
            tailf:info "IPv6 source address based fields";

            // flow record * / collect ipv6 source address
            leaf address {
              tailf:info "IPv6 source address";
              type empty;
            }

            // flow record * / collect ipv6 source mask
            container mask {
              tailf:info "IPv6 address mask for the IPv6 source address";
              presence true;
            }

            // flow record * / collect ipv6 source prefix
            container prefix {
              tailf:info "IPv6 address prefix for the IPv6 source address";
              presence true;
            }
          }

          // flow record * / collect ipv6 destination
          container destination {
            tailf:info "Ipv6 destination address based fields";

            // flow record * / collect ipv6 destination address
            leaf address {
              tailf:info "IPv6 destination address";
              type empty;
            }

            // flow record * / collect ipv6 destination mask
            container mask {
              tailf:info "Ipv6 address mask for the Ipv6 destination address";
              presence true;
            }

            // flow record * / collect ipv6 destination prefix
            container prefix {
              tailf:info "IPv6 address prefix for the IPv6 destination address";
              presence true;
            }
          }

          // flow record * / collect ipv6 fragmentation flags
          container fragmentation {
            tailf:info "Ipv6 fragmentation fields";
            leaf flags {
              tailf:info "Ipv6 fragmentation flags";
              type empty;
            }
            leaf id {
              tailf:info "IPv6 fragmentation ID";
              type empty;
            }
            leaf offset {
              tailf:info "Ipv6 fragmentation offset";
              type empty;
            }
          }
        }

        // flow record * / collect transport
        container transport {
          tailf:info "Transport layer fields";

          // flow record * / collect transport packets
          container packets {
            tailf:info "Transport packet fields";
            container expected {
              tailf:info "Transport packets expected fields";
              // collect transport packets expected counter
              leaf counter {
                tailf:info "Expected number of packets from sequencing information";
                type empty;
              }
            }
            container lost {
              tailf:info "Transport packets lost fields";
              // collect transport packets lost counter
              container counter {
                tailf:info "A count of the number of lost packets from sequencing information";
                presence true;
              }
              // collect transport packets lost rate
              container rate {
                tailf:info "Packet loss rate from sequencing information";
                presence true;
              }
            }
          }

          // flow record * / collect transport round-trip-time
          container round-trip-time {
            tailf:info "RTT calculation for flow";
            presence true;
          }

          // flow record * / collect transport event
          container event {
            tailf:info "Transport event fields";
            // flow record * / collect transport event packet-loss
            container packet-loss {
              tailf:info "Transport event packet-loss fields";
              container counter {
                tailf:info "Count of sets of packets that were lost";
                presence true;
              }
            }
          }

          // flow record * / collect transport icmp
          container icmp {
            tailf:info "ICMP fields";

            // flow record * / collect transport icmp ipv4
            container ipv4 {
              tailf:info "IPv4 ICMP fields";

              // flow record * / collect transport icmp ipv4 type
              leaf type {
                tailf:info "IPv4 ICMP type";
                type empty;
              }

              // flow record * / collect transport icmp ipv4 code
              leaf code {
                tailf:info "IPv4 ICMP code";
                type empty;
              }
            }
          }

          // flow record * / collect transport tcp
          container tcp {
            tailf:info "TCP fields";

            // flow record * / collect transport tcp flags
            container flags {
              tailf:info "TCP flags";
              presence true;
            }
          }

          // flow record * / collect transport rtp
          container rtp {
            tailf:info "RTP fields";

            // flow record * / collect transport rtp jitter
            container jitter {
              tailf:info "RTP jitter fields";
              container mean {
                tailf:info "Mean jitter for the RTP stream";
                presence true;
              }
              container minimum {
                tailf:info "Minimum jitter for the RTP stream";
                presence true;
              }
              container maximum {
                tailf:info "Maximum jitter for the RTP stream";
                presence true;
              }
            }
          }
        }

        // flow record * / collect interface
        container interface {
          tailf:info "Interface fields";

          // flow record * / collect interface input
          leaf input {
            tailf:info "The input interface";
            type empty;
          }

          // flow record * / collect interface output
          leaf output {
            tailf:info "The output interface";
            tailf:cli-full-command;
            tailf:cli-full-no;
            type empty;
          }

          // flow record * / collect interface output snmp
          container output-snmp {
            tailf:cli-drop-node-name;
            container output {
              tailf:info "The output interface";
              tailf:cli-incomplete-command;
              tailf:cli-incomplete-no;
              leaf snmp {
                tailf:info "SNMP Index of the output interface";
                type empty;
              }
            }
          }

          // flow record * / collect interface output physical snmp
          container output-physical-snmp {
            tailf:cli-drop-node-name;
            container output {
              tailf:info "The output interface";
              tailf:cli-incomplete-command;
              tailf:cli-incomplete-no;
              container physical {
                tailf:info "The physical output interface";
                leaf snmp {
                  tailf:info "SNMP Index of the output interface";
                  type empty;
                }
              }
            }
          }
        }

        // flow record * / collect flow
        container flow {
          tailf:info "Flow identifying fields";

          // flow record * / collect flow sampler
          leaf sampler {
            tailf:info "ID of the sampler";
            type empty;
          }

          // flow record * / collect flow direction
          leaf direction {
            tailf:info "Direction the flow was monitored in";
            type empty;
          }
        }

        // flow record * / collect counter
        container counter {
          tailf:info "Counter fields";

          // flow record * / collect counter bytes
          container bytes {
            tailf:info "Total number of bytes";
            tailf:cli-delete-when-empty;
            presence true;

            // flow record * / collect counter bytes layer2 long
            container layer2 {
              tailf:info "Total number of layer 2 bytes";
              leaf long {
                tailf:info "Total number of layer 2 bytes (64 bit counter)";
                type empty;
              }
            }
            leaf long {
              tailf:info "Total number of bytes (64 bit counter)";
              type empty;
            }
            container rate {
              tailf:info "Byte rate for the flow";
              presence true;
            }
          }

          // flow record * / collect counter packets
          container packets {
            tailf:info "Total number of packets";
            tailf:cli-delete-when-empty;
            presence true;
            // flow record * / collect counter packets long
            leaf long {
              tailf:info "Total number of packets (64 bit counter)";
              type empty;
            }
            container dropped {
              presence true;
            }
          }

          // flow record * / collect counter flows
          leaf flows {
            tailf:info "Total number of flows";
            type empty;
          }
        }

        // flow record * / collect timestamp
        container timestamp {
          tailf:info "Timestamp fields";

          // flow record * / collect timestamp interval
          container interval {
            tailf:info "Epoch of a monitoring interval";
            presence true;
          }

          // flow record * / collect timestamp sys-uptime
          container sys-uptime {
            tailf:info "Timestamps based on the sys-uptime";
            // flow record * / collect timestamp sys-uptime first
            leaf first {
              tailf:info "Time the first packet was seen";
              type empty;
            }
            // flow record * / collect timestamp sys-uptime last
            leaf last {
              tailf:info "Time the most recent packet was seen";
              type empty;
            }
          }

          // flow record * / collect timestamp absolute
          container absolute {
            tailf:info "Timestamps based on the epoch of 00:00 UTC 1st Jan 1970";

            // flow record * / collect timestamp absolute first
            leaf first {
              tailf:info "Absolute time the first packet was seen (milliseconds)";
              type empty;
            }

            // flow record * / collect timestamp absolute last
            leaf last {
              tailf:info "Absolute time the most recent packet was seen (milliseconds)";
              type empty;
            }
          }
        }

        // flow record * / collect datalink
        container datalink {
          tailf:info "Datalink (layer2) fields";

          // flow record * / collect datalink mac
          container mac {
            tailf:info "MAC fields";
            container source {
              tailf:info "source MAC fields";
              container address {
                tailf:info "Source MAC address from packet";
                leaf input {
                  tailf:info "Source MAC address from packet at input";
                  type empty;
                }
                leaf output {
                  tailf:info "Source MAC address from packet at output";
                  type empty;
                }
              }
            }
            container destination {
              tailf:info "destination MAC fields";
              container address {
                tailf:info "Destination MAC address from packet";
                leaf input {
                  tailf:info "Destination MAC address from packet at input";
                  type empty;
                }
                leaf output {
                  tailf:info "Destination MAC address from packet at output";
                  type empty;
                }
              }
            }
          }
        }

        // flow record * / collect application
        container application {
          tailf:info "Application fields";

          // flow record * / collect application media
          container media {
            tailf:info "Media fields";
            // flow record * / collect application media bytes
            container bytes {
              tailf:info "Media fields";
              container counter {
                tailf:info "A count of the number of bytes of media payload (64 bit counter)";
                presence true;
              }
              container rate {
                tailf:info "Byte rate for the media stream";
                presence true;
              }
            }
            // flow record * /  collect application media packets
            container packets {
              tailf:info "Media fields";
              container counter {
                presence true;
              }
              container rate {
                presence true;
              }
            }
            container event {
              tailf:info "Flags indicating media events";
              presence true;
            }
          }

          // flow record * / collect application name
          container name {
            tailf:info "Application name";
            presence true;
          }

          // flow record * / collect application http
          container http {
            tailf:info "World Wide Web traffic";
            // flow record * / collect application http host
            leaf host {
              tailf:info "Host name of Origin Server containing resource";
              type empty;
            }
          }
        }

        // flow record * / collect monitor event
        container monitor {
          tailf:info "monitor fields";
          container event {
            tailf:info "Flags indicating monitor events";
            presence true;
          }
        }

        // flow record * / collect connection
        container connection {
          tailf:info "Connection fields";

          // flow record * / collect connection initiator
          leaf initiator {
            tailf:info "The direction of the flow";
            type empty;
          }

          // flow record * / collect connection new-connections
          leaf new-connections {
            tailf:info "The number of connection initiations observed";
            type empty;
          }

          // flow record * / collect connection server
          container server {
            tailf:info "Server side (flow responder) related metrics";

            // flow record * / collect / connection server counter
            container counter {
              tailf:info "Server side counter metrics";

              // flow record * / collect connection server counter responses
              leaf responses {
                tailf:info "Number of responses sent by the server";
                type empty;
              }

              // flow record * / collect connection server counter packets
              container packets {
                tailf:info "Number of packets sent by the server";
                // flow record * / collect connection server counter packets long
                leaf long {
                  tailf:info "64 bits counter";
                  type empty;
                }
              }

              // flow record * / collect connection server counter bytes
              container bytes {
                tailf:info "Number of bytes sent by the server";
                // flow record * / collect connection server counter bytes network
                container network {
                  tailf:info "Number of bytes sent by the server";
                  // flow record * / collect connection server counter bytes network long
                  leaf long {
                    tailf:info "Total number of bytes transmitted by the server";
                    type empty;
                  }
                }
              }
            }
          }

          // flow record * / collect connection delay
          container delay {
            tailf:info "Connection delay metrics";

            // flow record * / collect connection delay response
            container response {
              tailf:info "Response time metrics";

              // flow record * / collect connection delay response to-server
              container to-server {
                tailf:info "Response time as seen from observation point";

                // flow record * / collect connection delay response to-server histogram
                container histogram {
                  tailf:info "Histogram for response time";

                  // flow record * / collect connection delay response to-server histogram bucket1
                  leaf bucket1 {
                    tailf:info "Histogram bucket1 for response time";
                    type empty;
                  }

                  // flow record * / collect connection delay response to-server histogram bucket2
                  leaf bucket2 {
                    tailf:info "Histogram bucket2 for response time";
                    type empty;
                  }

                  // flow record * / collect connection delay response to-server histogram bucket3
                  leaf bucket3 {
                    tailf:info "Histogram bucket3 for response time";
                    type empty;
                  }

                  // flow record * / collect connection delay response to-server histogram bucket4
                  leaf bucket4 {
                    tailf:info "Histogram bucket4 for response time";
                    type empty;
                  }

                  // flow record * / collect connection delay response to-server histogram bucket5
                  leaf bucket5 {
                    tailf:info "Histogram bucket5 for response time";
                    type empty;
                  }

                  // flow record * / collect connection delay response to-server histogram bucket6
                  leaf bucket6 {
                    tailf:info "Histogram bucket6 for response time";
                    type empty;
                  }

                  // flow record * / collect connection delay response to-server histogram bucket7
                  leaf bucket7 {
                    tailf:info "Histogram bucket8 for response time";
                    type empty;
                  }

                  // flow record * / collect connection delay response to-server histogram late
                  leaf late {
                    tailf:info "Number of late responses";
                    type empty;
                  }
                }
              }

              // flow record * / collect connection delay response client-to-server
              container client-to-server {
                tailf:info "Response time as seen by the client";
                // flow record * / collect connection delay response client-to-server sum
                leaf sum {
                  tailf:info "Total response time";
                  type empty;
                }
              }
            }

            // flow record * / collect connection delay network
            container network {
              tailf:info "Network time metrics";

              // flow record * / collect connection delay network to-server
              container to-server {
                tailf:info "RTT from observation point to the server";
                // flow record * / collect connection delay network to-server sum
                leaf sum {
                  tailf:info "Total application response time";
                  type empty;
                }
              }

              // flow record * / collect connection delay network to-client
              container to-client {
                tailf:info "RTT from observation point to the client";
                // flow record * / collect connection delay network to-client sum
                leaf sum {
                  tailf:info "Total network time";
                  type empty;
                }
              }
            }

            // flow record * / collect connection delay application
            container application {
              tailf:info "Application time metrics";
              // flow record * / collect connection delay application sum
              leaf sum {
                tailf:info "Total application response time";
                type empty;
              }
            }
          }

          // flow record * / collect connection transaction
          container transaction {
            tailf:info "Transaction related metrics";
            // flow record * / collect connection transaction counter complete
            container counter {
              tailf:info "Transaction counter metrics";
              leaf complete {
                tailf:info "Number of completed transactions";
                type empty;
              }
            }
          }

          // flow record * / collect connection client
          container client {
            tailf:info "Client side (flow initiator) related metrics";

            // flow record * / collect connection client counter
            container counter {
              tailf:info "Client side counter metrics";

              // flow record * / collect connection client counter packets
              container packets {
                tailf:info "Number of packets sent by the client";

                // flow record * / collect connection client counter packets retransmitted
                leaf retransmitted {
                  tailf:info "Number of packets retransmitted by the client";
                  type empty;
                }

                // flow record * / collect connection client counter packets long
                leaf long {
                  tailf:info "64 bits counter";
                  type empty;
                }
              }

              // flow record * / collect connection client counter bytes network long
              container bytes {
                tailf:info "Number of bytes sent by the client";
                container network {
                  tailf:info "Number of bytes sent by the client";
                  leaf long {
                    tailf:info "Total number of bytes transmitted by the client";
                    type empty;
                  }
                }
              }
            }
          }
        }

        // flow record * / collect policy
        container policy {
          tailf:info "policy fields";

          // flow record * / collect policy qos
          container qos {
            tailf:info "QoS policy related metrics";

            // flow record * / collect policy qos queue
            container queue {
              tailf:info "Queue metrics";

              // flow record * / collect policy qos queue drops
              leaf drops {
                tailf:info "QoS queue drops";
                type empty;
              }

              // flow record * / collect policy qos queue index
              leaf index {
                tailf:info "QoS queue index";
                type empty;
              }
            }

            // flow record * / collect policy qos classification hierarchy
            container classification {
              tailf:info "Classification metrics";
              leaf hierarchy {
                tailf:info "QoS class hierarchy";
                type empty;
              }
            }
          }
        }
      }
    }

    // flow monitor *
    list monitor {
      tailf:info "Define a Flow Monitor";
      tailf:cli-mode-name "config-flow-monitor";
      tailf:cli-full-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Flow Monitor name";
        }
      }
      leaf type {
        tailf:info "Type of the Flow Monitor";
        tailf:cli-prefix-key;
        type enumeration {
          enum mace {
                     tailf:info "Config mace flow monitor type";
          }
          enum performance-monitor {
            tailf:info "Config media monitor flow monitor type";
          }
        }
      }

      // flow monitor * / description
      leaf description {
        tailf:info "Provide a description for this Flow Monitor";
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE;;Flow Monitor description";
        }
      }

      // flow monitor * / statistics packet
      container statistics {
        tailf:info "Collect statistics";
        container packet {
          tailf:info "Collect packet statistics";

          // flow monitor * / statistics packet protocol
          leaf protocol {
            tailf:info "Collect packet protocol distribution statistics";
            type empty;
          }

          // flow monitor * / statistics packet size
          leaf size {
            tailf:info "Collect packet size distribution statistics";
            type empty;
          }
        }
      }

      // flow monitor * / record
      leaf record {
        tailf:info "Specify Flow Record";
        tailf:cli-full-command;
        tailf:cli-disallow-value "netflow";
        tailf:cli-remove-before-change;
        tailf:cli-diff-dependency "../../../flow/record/match/transport/rtp/ssrc";
        tailf:non-strict-leafref {
          path "../../../flow/record/name";
        }
        ios:config-lock " record (\\S+) :: flow record $1";
        type string {
          tailf:info "WORD;;record name";
        }
      }

      // flow monitor * / record netflow
      container record-netflow {
        tailf:cli-drop-node-name;
        container record {
          tailf:info "Specify Flow Record";
          container netflow {
            tailf:info "Traditional NetFlow collection schemes";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf protocol {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type enumeration {
                enum ipv4 {
                           tailf:info "Traditional IPv4 NetFlow collection schemes";
                }
                enum ipv6 {
                           tailf:info "Traditional IPv6 NetFlow collection schemes";
                }
              }
            }
            choice original-choice {
              // flow monitor * / record netflow * original-input
              leaf original-input {
                tailf:info "Traditional IPv6 input NetFlow with ASs";
                tailf:cli-optional-in-sequence;
                type empty;
              }
              // flow monitor * / record netflow * original-output
              leaf original-output {
                tailf:info "Traditional IPv4 output NetFlow with ASs";
                type empty;
              }
            }
            leaf peer {
              tailf:info "Traditional IPv6 input NetFlow with peer ASs";
              type empty;
            }
          }
        }
      }

      // flow monitor * / exporter *
      list exporter {
        tailf:info "Add an Exporter to use to export records";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          ios:config-lock " exporter (\\S+) :: flow exporter $1";
          tailf:non-strict-leafref {
            path "../../../../flow/exporter/name";
          }
          type string {
            tailf:info "WORD;;Flow exporter name";
          }
        }
      }

      // flow monitor * / cache
      container cache {
        tailf:info "Configure MACE Flow Cache parameters";

        // flow monitor * / cache timeout
        container timeout {
          tailf:info "Cache timeout";

          // flow monitor * / cache timeout inactive
          leaf inactive {
            tailf:info "Specify the active flow timeout";
            tailf:cli-full-command;
            type uint32 {
              tailf:info "<1-604800>;;Active timeout in seconds";
              range "1..604800";
            }
            default 15;
          }

          // flow monitor * / cache timeout active
          leaf active {
            tailf:info "Specify the active flow timeout";
            tailf:cli-full-command;
            type uint32 {
              tailf:info "<1-604800>;;Active timeout in seconds";
              range "1..604800";
            }
            default 1800;
          }

          // flow monitor * / cache timeout update
          leaf update {
            tailf:info "Specify the update timeout for a permanent Flow Cache";
            type uint32 {
              tailf:info "<1-604800>;;Permanent cache update timeout in seconds";
              range "1..604800";
            }
            default 1800;
          }

          // flow monitor * / cache timeout synchronized
          leaf synchronized {
            tailf:info "Synchronized timeout";
            type uint32 {
              tailf:info "<1-86400>;;Synchronized cache timeout in seconds";
              range "1..86400";
            }
            default 600;
          }
        }

        // flow monitor * / cache type
        leaf type {
          tailf:info "Cache type";
          tailf:cli-full-command;
          type enumeration {
            enum immediate {
                            tailf:info "Immediate cache type";
            }
            enum normal {
                         tailf:info "Normal cache type";
            }
            enum permanent {
                            tailf:info "Permanent cache type";
            }
            enum synchronized {
              tailf:info "synchronized cache type";
            }
          }
          default synchronized;
        }

        // flow monitor * / cache entries
        leaf entries {
          tailf:info "Number of cache entries";
          type uint32 {
            tailf:info "<16-2000000>;;Number of cache entries";
            range "16..2000000";
          }
        }
      }

      // flow monitor * / history size
      container history {
        tailf:info "Monitor history intervals";
        leaf size {
          tailf:info "History size";
          type uint8 {
            tailf:info "<0-60>;;Number of intervals monitored";
            range "0..60";
          }
          default 0;
        }
      }
    }
  }


  /// ========================================================================
  /// sampler
  /// ========================================================================

  // sampler *
  list sampler {
    tailf:info "Define a Sampler";
    tailf:cli-mode-name "config-sampler";
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;Sampler name";
      }
    }

    // sampler * / mode
    container mode {
      tailf:info "Sampling mode";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf value {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type enumeration {
          enum deterministic {
                              tailf:info "Deterministic mode of sampling";
          }
          enum random {
                       tailf:info "Random mode of sampling";
          }
        }
      }
      leaf packets {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint8 {
          tailf:info "<1-1>;;number of packets to select per window";
          range "1";
        }
      }
      leaf out-of {
        tailf:info "Select M packets out of an N packet window";
        type uint16 {
          tailf:info "<2-32768>;;window size to select packets from";
          range "2..32768";
        }
      }
    }
  }


  /// ========================================================================
  /// domain
  /// ========================================================================

  // domain *
  list domain {
    tailf:info "Domain Configuration Commands";
    tailf:cli-mode-name "config-domain";
    //max-elements 1;
    tailf:cli-explicit-exit;
    key name;
    leaf name {
      tailf:cli-diff-dependency "../../interface/Loopback";
      type string {
        tailf:info "WORD;;Domain Name";
      }
    }

    // domain * / vrf *
    list vrf {
      tailf:info "Specify vrf for domain";
      tailf:cli-mode-name "config-domain-vrf";
      key name;
      leaf name {
        tailf:cli-diff-dependency "../../../ip/vrf";
        tailf:cli-diff-dependency "../../../vrf/definition";
        type string {
          tailf:info "WORD;;VRF name";
        }
      }

      // domain * / vrf * / master branch
      // domain * / vrf * / master hub
      // domain * / vrf * / master regional-hub
      // domain * / vrf * / master transit
      uses domain-master-grouping;

      // domain * / vrf * / border
      uses domain-border-grouping {

        // domain * / vrf * / border / advanced
        augment border {
          container advanced {
            tailf:info "Enter border router advanced configuration submode";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-domain-vrf-br-advanced";

            // domain * / vrf * / border / advanced / monitor-cache-percent
            leaf monitor-cache-percent {
              tailf:info "Set cache usage (%) for this border, the total cache usage among all VRFs shoudn't exceed 100%";
              type uint8 {
                tailf:info "<1-100>;;cache usage (%), border instance will AUTOMATICALLY "
                  +"go through SHUT/NO SHUT any ACTIVE traffic on this border will be affected";
                range "1..100";
              }
            }
          }
        }
      }
    }

    // domain * / master branch
    // domain * / master hub
    // domain * / master regional-hub
    // domain * / master transit
    uses domain-master-grouping {
      refine master {
        tailf:cli-diff-dependency "../vrf";
        //TEST: tailf:meta-data "suppress-delete-error-invalid";
      }
    }

    // domain * / border
    uses domain-border-grouping {
      refine border {
        tailf:cli-diff-dependency "../vrf";
        //TEST: tailf:meta-data "suppress-delete-error-invalid";
      }
      refine "border/password/secret" {
        cli:secret;
      }
      // domain * / border / advanced
      augment border {
        container advanced {
          tailf:info "Advanced configuration submode";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-domain-br-advanced";
          presence true;
          uses domain-advanced-smart-probes-grouping;
        }
      }
    }
  }


  /// ========================================================================
  /// archive
  /// ========================================================================

  container archive {
    tailf:info "Archive the configuration";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-archive";

    // archive / log config
    container log {
      tailf:info "Logging commands";
      container config {
        tailf:info "Logging changes to the running configuration";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-archive-log-cfg";
        tailf:cli-full-command;

        // archive / log config / logging
        container logging {
          tailf:info "Modify config logging parameters";

          // archive / log config / logging enable
          leaf enable {
            tailf:info "Enable the config logger";
            tailf:cli-full-command;
            type empty;
          }

          // archive / log config / logging size
          leaf size {
            tailf:info "Maximum number of logged commands that will be kept by the config log";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<1-1000>;;Queue length (default 100)";
              range "1..1000";
            }
            default 100;
          }
        }

        // archive / log config / hidekeys
        leaf hidekeys {
          tailf:info "suppress output (e.g. passwords) when displaying logged commands";
          tailf:cli-full-command;
          type empty;
        }

        // archive / log config / notify
        container notify {
          tailf:info "Send logged commands to target applications";
          container syslog {
            tailf:info "Send logged commands as syslog messages";
            tailf:cli-delete-when-empty;
            presence true;
            leaf contenttype {
              tailf:info "Type of the syslog message content";
              type enumeration {
                enum plaintext {
                                tailf:info "Plain text content";
                }
                enum xml {
                          tailf:info "XML content";
                }
              }
            }
          }
        }
        // archive / log config / record rc
        container record {
          tailf:info "What to record in the config logger";
          leaf rc {
            tailf:info "Record the PRC result";
            type empty;
          }
        }
      }
    }

    // archive / path
    leaf path {
      tailf:info "path for backups";
      tailf:cli-full-command;
      type string {
        tailf:info "WORD;;Write archive path";
      }
    }

    // archive / maximum
    leaf maximum {
      tailf:info "maximum number of backup copies";
      type uint8 {
        tailf:info "<1-14>;;maximum number of backup copies";
        range "1..14";
      }
    }

    // archive / write-memory
    leaf write-memory {
      tailf:info "Enable automatic backup generation during write memory";
      type empty;
    }

    // archive / time-period
    leaf time-period {
      tailf:info "Period of time in minutes to automatically archive the running-config";
      type uint32 {
        tailf:info "<1-525600>;;Number of minutes to wait between archive creation";
        range "1..525600";
      }
    }
  }


  /// ========================================================================
  /// file
  /// ========================================================================

  container file {
    tailf:info "Adjust file system parameters";

    // file privilege
    leaf privilege {
      tailf:info "Privilege level required for file operations";
      type uint8 {
        tailf:info "<0-15>;;Privilege level. Default 15";
        range "0..15";
      }
      default 15;
    }

    // file prompt
    leaf prompt {
      tailf:info "Prompt level for file operations";
      type enumeration {
        enum alert {
          tailf:info "Prompt only for destructive file operations";
        }
        enum noisy {
          tailf:info "Confirm all file operation parameters";
        }
        enum quiet {
          tailf:info "Seldom prompt for file operations";
        }
      }
      default alert;
    }

    // file verify
    leaf verify {
      tailf:info "Verify compressed IOS image checksum";
      type enumeration {
        enum "auto" {
          tailf:info "Enable automatic checksum verification";
        }
      }
    }
  }


  /// ========================================================================
  /// object-group
  /// ========================================================================

  container object-group {
    tailf:info "Configure ACL Object Group";

    // object-group network *
    list network {
      tailf:info "network group";
      tailf:cli-mode-name "config-network-group";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;object-group name";
        }
      }

      // object-group network * / description
      leaf description {
        tailf:info "Network object group description";
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE;;Description of this Object group";
        }
      }

      // object-group network * / host *
      list host {
        tailf:info "Host address of the object-group member";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type inet:host {
            tailf:info "Hostname or A.B.C.D;;Host address";
          }
        }
      }

      // object-group network * / subnet *
      list subnet {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "network-address network-mask";
        leaf network-address {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Network address of the group members";
          }
        }
        leaf network-mask {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Network mask";
          }
        }
      }
    }

    // object-group service *
    list service {
      tailf:info "service group";
      tailf:cli-mode-name "config-service-group";
      tailf:cli-full-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;object-group name";
        }
      }

      // object-group service * / description
      leaf description {
        tailf:info "Service object group description";
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE;;Description of this Object group";
        }
      }

      // object-group service * / icmp
      // object-group service * / tcp
      // object-group service * / udp
      // object-group service * / esp
      leaf-list protocol {
        tailf:cli-drop-node-name;
        tailf:cli-list-syntax;
        tailf:cli-full-command;
        type union {
          type uint8 {
            tailf:info "<0-255>;;An IP protocol number";
          }
          type enumeration {
            enum icmp {
              tailf:info "Internet Control Message Protocol";
              value 1;
            }
            enum tcp {
              tailf:info "Transmission Control Protocol";
              value 6;
            }
            enum udp {
              tailf:info "User Datagram Protocol";
              value 17;
            }
            enum esp {
              tailf:info "Encapsulation Security Payload";
              value 50;
            }
          }
        }
      }

      // object-group service * / icmp *
      container icmp-options {
        tailf:cli-drop-node-name;
        container icmp {
          tailf:info "Internet Control Message Protocol";
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          list match {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key port;
            leaf port {
              type object-group-service-icmp-type;
            }
            uses object-group-service-protocol-match;
          }

          // object-group service * / icmp range *
          list range {
            tailf:info "Match only packets in the range of port numbers";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key "begin end";
            leaf begin {
              type object-group-service-icmp-type;
            }
            leaf end {
              type object-group-service-icmp-type;
            }
          }
        }
      }

      // object-group service * / udp *
      container udp-options {
        tailf:cli-drop-node-name;
        container udp {
          tailf:info "User Datagram Protocol";
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          list match {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key port;
            leaf port {
              type object-group-service-udp-type;
            }
            uses object-group-service-protocol-match;
          }

          // object-group service * / udp range *
          list range {
            tailf:info "Match only packets in the range of port numbers";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key "begin end";
            leaf begin {
              type object-group-service-udp-type;
            }
            leaf end {
              type object-group-service-udp-type;
            }
          }
        }
      }

      // object-group service * / tcp *
      container tcp-options {
        tailf:cli-drop-node-name;
        container tcp {
          tailf:info "Transmission Control Protocol";
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          list match {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key port;
            leaf port {
              type object-group-service-tcp-type;
            }
            uses object-group-service-protocol-match;
          }

          // object-group service * / tcp range *
          list range {
            tailf:info "Match only packets in the range of port numbers";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key "begin end";
            leaf begin {
              type object-group-service-tcp-type;
            }
            leaf end {
              type object-group-service-tcp-type;
            }
          }
        }
      }

      // object-group service * / tcp-udp *
      container tcp-udp {
        tailf:info "TCP or UDP protocol";
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        list match {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key port;
          leaf port {
            type object-group-service-tcp-udp-type;
          }
          uses object-group-service-protocol-match;
        }

        // object-group service * / tcp-udp range *
        list range {
          tailf:info "Match only packets in the range of port numbers";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key "begin end";
          leaf begin {
            type object-group-service-tcp-udp-type;
          }
          leaf end {
            type object-group-service-tcp-udp-type;
          }
        }
      }
    }

    // object-group security *
    list security {
      tailf:info "security group";
      tailf:cli-mode-name "config-security-group";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;object-group name";
        }
      }

      // object-group security * / description
      leaf description {
        tailf:info "Security object group description";
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE;;Description of this Object group";
        }
      }
    }

    // object-group ip
    container ip {
      tailf:info "IP object-group";

      // object-group ip address *
      list address {
        tailf:info "IP address object-group";
        tailf:cli-mode-name "config-ipaddr-ogroup";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;object-group name";
          }
        }

        // object-group ip address * / host-info *
        list host-info {
          tailf:info "Host address of the object-group member";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type inet:host {
              tailf:info "Hostname or A.B.C.D;;Host address";
            }
          }
        }

        // object-group ip address * / *
        list subnet {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key "network-address network-mask";
          leaf network-address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Network address of the group members";
            }
          }
          leaf network-mask {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Network mask";
            }
          }
        }
      }

      // object-group ip port *
      list port {
        tailf:info "IP port object-group";
        tailf:cli-mode-name "config-port-ogroup";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;object-group name";
          }
        }

        // object-group ip port * / *
        list entry {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key match;
          leaf match {
            tailf:cli-multi-word-key;
            tailf:cli-suppress-range;
            type string {
              tailf:info "eq|gt|lt|neq <port> | range <min> <max>";
              pattern "((eq|gt|lt|neq) \\d+)|(range \\d+ \\d+)";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// key
  /// ========================================================================

  container key {
    tailf:info "Key management";

    // key config-key password-encrypt
    container config-key {
      tailf:info "Set a private configuration key for general use [cached EXEC 'config']";
      leaf password-encrypt {
        tailf:info "Set a private configuration key for password encryption";
        tailf:cli-no-value-on-delete;
        ios:password-dequote-output "password-encrypt (\\S+)";
        type tailf:aes-cfb-128-encrypted-string {
          tailf:info "LINE;;The config-key, minimum 8 characters not beginning with IOS special character(! # ;)";
        }
      }
    }

    // key chain *
    list chain {
      tailf:info "Key-chain management";
      tailf:cli-mode-name "config-keychain";
      tailf:cli-full-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Key-chain name";
        }
      }

      // key chain * / description
      uses description-grouping;

      // key chain * / key *
      list key {
        tailf:info "Configure a key";
        tailf:cli-mode-name "config-keychain-key";
        tailf:cli-explicit-exit;
        key id;
        leaf id {
          type uint32 {
            tailf:info "<0-2147483647>;;Key identifier";
            range "0..2147483647";
          }
        }

        // key chain * / key * / key-string
        container key-string {
          tailf:info "Set key string";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            // Note: required to not send 'no key-string..', which leaves sub-mode on device
            tailf:cli-reset-siblings;
          }
          uses password-grouping {
            refine "secret" {
              cli:secret " key-string <SECRET>" {
                cli:arguments "always-encrypted";
              }
            }
          }
        }

        // key chain * / key * / cryptographic-algorithm
        leaf cryptographic-algorithm {
          tailf:info "Set cryptographic authentication algorithm";
          type enumeration {
            enum hmac-sha-1 {
              tailf:info "HMAC-SHA-1 authentication algorithm";
            }
            enum hmac-sha-256 {
              tailf:info "HMAC-SHA-256 authentication algorithm";
            }
            enum hmac-sha-384 {
              tailf:info "HMAC-SHA-384 authentication algorithm";
            }
            enum hmac-sha-512 {
              tailf:info "HMAC-SHA-512 authentication algorithm";
            }
            enum md5 {
              tailf:info "MD5 authentication algorithm";
            }
          }
        }

        // key chain * / key * / accept-lifetime
        container accept-lifetime {
          tailf:info "Set accept lifetime of key";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          choice accept-lifetime-choice {
            case global {
              uses lifetime-grouping;
            }
            // key chain * / key * / accept-lifetime local
            container local {
              tailf:info "Specify time in local timezone";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              uses lifetime-grouping;
            }
          }
        }

        // key chain * / key * / send-lifetime
        container send-lifetime {
          tailf:info "Set send lifetime of key";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          choice send-lifetime-choice {
            case global {
              uses lifetime-grouping;
            }
            // key chain * / key * / send-lifetime local
            container local {
              tailf:info "Specify time in local timezone";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              uses lifetime-grouping;
            }
          }
        }
      }
    }

    // key chain * tcp
    container tcp {
      tailf:cli-drop-node-name;
      list chain {
        tailf:info "Key-chain management";
        tailf:cli-mode-name "config-keychain-tcp";
        tailf:cli-incomplete-command;
        tailf:cli-explicit-exit;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Key-chain name";
          }
        }
        leaf tcp {
          tailf:info "This is a tcp key chain";
          tailf:cli-hide-in-submode;
          type empty;
        }

        // key chain * tcp / description
        uses description-grouping;

        // key chain * tcp / key *
        list key {
          tailf:info "Configure a key";
          tailf:cli-mode-name "config-keychain-key";
          tailf:cli-explicit-exit;
          key id;
          leaf id {
            type uint32 {
              tailf:info "<0-2147483647>;;Key identifier";
              range "0..2147483647";
            }
          }

          // key chain * tcp / key * / key-string
          container key-string {
            tailf:info "Set key string";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              // Note: required to not send 'no key-string..', which leaves sub-mode on device
              tailf:cli-reset-siblings;
            }
            uses password-grouping {
              refine "secret" {
                cli:secret " key-string <SECRET>";
              }
            }
          }

          // key chain * tcp / key * / send-id
          leaf send-id {
            tailf:info "Configure a send id";
            type uint8 {
              tailf:info "<0-255>;;Send identifier";
              range "0..255";
            }
          }

          // key chain * tcp / key * / receive-id
          leaf recv-id {
            tailf:info "Configure a receive id";
            type uint8 {
              tailf:info "<0-255>;;Send identifier";
              range "0..255";
            }
          }

          // key chain tcp * / key * / cryptographic-algorithm
          leaf cryptographic-algorithm {
            tailf:info "Set cryptographic authentication algorithm";
            type enumeration {
              enum hmac-sha-1 {
                tailf:info "HMAC-SHA-1 authentication algorithm";
              }
              enum hmac-sha-256 {
                tailf:info "HMAC-SHA-256 authentication algorithm";
              }
              enum aes-128-cmac {
                tailf:info "AES-128-CMAC authentication algorithm";
              }
            }
          }

          // key chain tcp * / key * / accept-lifetime
          container accept-lifetime {
            tailf:info "Set accept lifetime of key";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            choice accept-lifetime-choice {
              case global {
                uses lifetime-grouping;
              }
              // key chain tcp * / key * / accept-lifetime local
              container local {
                tailf:info "Specify time in local timezone";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                uses lifetime-grouping;
              }
            }
          }

          // key chain tcp * / key * / send-lifetime
          container send-lifetime {
            tailf:info "Set send lifetime of key";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            choice send-lifetime-choice {
              case global {
                uses lifetime-grouping;
              }
              // key chain tcp * / key * / send-lifetime local
              container local {
                tailf:info "Specify time in local timezone";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                uses lifetime-grouping;
              }
            }
          }
        }
      }
    }

    // key chain * macsec
    container macsec {
      tailf:cli-drop-node-name;
      list chain {
        tailf:info "Key-chain management";
        tailf:cli-mode-name "config-keychain-macsec";
        tailf:cli-incomplete-command;
        tailf:cli-explicit-exit;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Key-chain name";
          }
        }
        leaf macsec {
          tailf:info "This is a MacSEC key chain";
          tailf:cli-hide-in-submode;
          type empty;
        }

        // key chain * macsec / description
        uses description-grouping;

        // key chain * macsec / key *
        list key {
          tailf:info "Configure a key";
          tailf:cli-mode-name "config-keychain-key";
          tailf:cli-full-command;
          key id;
          leaf id {
            type string {
              tailf:info "Hex-string;;Key identifier as a hex string with even number of digits";
            }
          }

          // key chain * macsec / key * / cryptographic-algorithm
          leaf cryptographic-algorithm {
            tailf:info "Set cryptographic authentication algorithm";
            type enumeration {
              enum aes-128-cmac {
                tailf:info "AES-128-CMAC authentication algorithm";
              }
              enum aes-256-cmac {
                tailf:info "AES-256-CMAC authentication algorithm";
              }
            }
          }

          // key chain * macsec / key * / key-string
          container key-string {
            tailf:info "Set key string";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            tailf:cli-diff-dependency "../cryptographic-algorithm";
            uses password-grouping {
              refine "secret" {
                cli:secret " key-string <SECRET>" {
                  cli:arguments "always-encrypted";
                }
              }
            }
          }

          // key chain * macsec / key * / lifetime
          container lifetime {
            tailf:info "Set accept lifetime of key";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            choice accept-lifetime-choice {
              case global {
                uses lifetime-grouping;
              }
              // key chain * macsec / key * / lifetime local
              container local {
                tailf:info "Specify time in local timezone";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                uses lifetime-grouping;
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// fips
  /// ========================================================================

  container fips {
    tailf:info "FIPS config";

    // fips authorization-key
    leaf authorization-key {
      tailf:info "Authorization Key for FIPS";
      tailf:cli-no-value-on-delete;
      type string {
        tailf:info "WORD;;128-bits (16 octet) key to be used";
      }
    }
  }


  /// ========================================================================
  /// modemcap
  /// ========================================================================

  container modemcap {
    tailf:info "Modem Capabilities database";

    // modemcap entry *
    list entry {
      tailf:info "Give a full modemcap entry";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key line;
      leaf line {
        tailf:cli-multi-word-key;
        type string {
          tailf:info "LINE;;Modemcap entry for this modem";
        }
      }
    }
  }


  /// ========================================================================
  /// flowspec
  /// ========================================================================

  container flowspec {
    tailf:info "FlowSpec configuration";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-flowspec";
    presence true;

    // flowspec / local-install interface-all
    container local-install {
      tailf:info "Local installation of flowspec policy";
      leaf interface-all {
        tailf:info "Install flowspec policy on all interfaces";
        type empty;
      }
    }

    // flowspec / address-family
    container address-family {
      tailf:info "Address Family Identifier Type (IPv4/IPv6)";

      // flowspec / address-family ipv4
      container ipv4 {
        tailf:info "IPv4 flow";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-flowspec-afi";

        // flowspec / addres-family ipv4 / local-install interface-all
        container local-install {
          tailf:info "Local installation of flowspec policy";
          leaf interface-all {
            tailf:info "Install flowspec policy on all interfaces";
            type empty;
          }
        }
      }

      // flowspec / address-family ipv6
      container ipv6 {
        tailf:info "IPv4 flow";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-flowspec-afi";

        // flowspec / addres-family ipv6 / local-install interface-all
        container local-install {
          tailf:info "Local installation of flowspec policy";
          leaf interface-all {
            tailf:info "Install flowspec policy on all interfaces";
            type empty;
          }
        }
      }
    }

    // flowspec / vrf *
    list vrf {
      tailf:info "VRF configuration";
      tailf:cli-mode-name "config-flowspec-vrf";
      key name;
      leaf name {
        tailf:cli-diff-dependency "../../../ip/vrf";
        tailf:cli-diff-dependency "../../../vrf/definition";
        type string {
          tailf:info "WORD;;VRF Name.";
        }
      }

      // flowspec / vrf * / address-family
      container address-family {
        tailf:info "Address Family Identifier Type (IPv4/IPv6)";

        // flowspec / vrf * / address-family ipv4
        container ipv4 {
          tailf:info "IPv4 flow";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-flowspec-vrf-afi";

          // flowspec / vrf * / addres-family ipv4 / local-install interface-all
          container local-install {
            tailf:info "Local installation of flowspec policy";
            leaf interface-all {
              tailf:info "Install flowspec policy on all interfaces";
              type empty;
            }
          }
        }

        // flowspec / vrf * / address-family ipv6
        container ipv6 {
          tailf:info "IPv4 flow";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-flowspec-vrf-afi";

          // flowspec / vrf * / addres-family ipv6 / local-install interface-all
          container local-install {
            tailf:info "Local installation of flowspec policy";
            leaf interface-all {
              tailf:info "Install flowspec policy on all interfaces";
              type empty;
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// acr
  /// ========================================================================

  // acr *
  list acr {
    tailf:info "Configure ACR type";
    tailf:cli-suppress-mode;
    tailf:cli-delete-when-empty;
    tailf:cli-compact-syntax;
    tailf:cli-incomplete-command;
    key id;
    leaf id {
      type uint8 {
        tailf:info "<0-255>;;ACR group number";
        range "0..255";
      }
    }
    leaf type {
      tailf:info "ACR controller type";
      type enumeration {
        enum ATM {
          tailf:info "ATM OC3";
        }
        enum CH-OC3 {
          tailf:info "Channelized OC3";
        }
        enum CHOCX-OC3 {
          tailf:info "Channelized OC3 Enhanced";
        }
        enum CHOCX-OC12 {
          tailf:info "Channelized OC12 Enhanced";
        }
        enum CHOCX-OC48 {
          tailf:info "Channelized OC48 Enhanced";
        }
        enum CHOCX-OC192 {
          tailf:info "Channelized OC192 Enhanced";
        }
        enum STM1 {
          tailf:info "STM1 Enhanced";
        }
        enum STM4 {
          tailf:info "STM4 Enhanced";
        }
        enum STM16 {
          tailf:info "STM16 Enhanced";
        }
        enum STM64 {
          tailf:info "STM64 Enhanced";
        }
      }
    }
  }


  /// ========================================================================
  /// service-template
  /// ========================================================================

  // service-template *
  list service-template {
    tailf:info "Configure a service-template/identity policy";
    tailf:cli-mode-name "config-service-template";
    tailf:cli-explicit-exit;
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;Specify a template name (maximum 48 characters)";
      }
    }

    // service-template * / inactivity-timer
    leaf inactivity-timer {
      tailf:info "Inactivity timeout value in seconds";
      type uint16 {
        tailf:info "<0-65535>;;Enter a value between 1 and 65535";
      }
      default 0;
    }

    // service-template * / linksec policy
    container linksec {
      tailf:info "Configure link security parameters";
      leaf policy {
        tailf:info "Set the link security policy";
        type enumeration {
          enum must-not-secure {
            tailf:info "Never secure sessions";
          }
          enum should-secure {
            tailf:info "OPTIONALLY secure sessions";
          }
          enum must-secure {
            tailf:info "Always secure sessions";
          }
        }
      }
    }

    // service-template * / voice vlan
    container voice {
      tailf:info "Voice feature";
      leaf vlan {
        tailf:info "Critical voice vlan";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// issu
  /// ========================================================================

  // issu set rollback-timer
  container issu {
    tailf:info "ISSU config commands";
    container set {
      tailf:info "set rollback timer";
      leaf rollback-timer {
        tailf:info "rollback timer";
        type union {
          type uint16 {
            tailf:info "<0-7200>;;Rollback timer in <seconds> format";
            range "0..7200";
          }
          type string {
            tailf:info "hh:mm:ss;;Rollback timer in hh:mm:ss format";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// username
  /// ========================================================================

  list username {
    tailf:info "Establish User Name Authentication";
    tailf:cli-suppress-mode;
    tailf:cli-delete-when-empty;
    tailf:cli-compact-syntax;
    key name;
    leaf name {
      tailf:cli-suppress-range;
      tailf:cli-full-no;
      type string {
        tailf:info "WORD;;User name";
      }
    }

    // username * privilege
    leaf privilege {
      tailf:info "Set user privilege level";
      tailf:cli-no-name-on-delete;
      tailf:cli-no-value-on-delete;
      type uint8 {
        tailf:info "<0-15>;;User privilege level";
        range "0..15";
      }
      default 1;
    }

    // username * common-criteria-policy
    leaf common-criteria-policy {
      tailf:info "Enter the common-criteria policy name";
      tailf:non-strict-leafref {
        path "../../aaa/common-criteria/policy/name";
      }
      type string {
        tailf:info "WORD;;Name of policy";
      }
    }

    // username * view
    leaf view {
      tailf:info "Set view name";
      tailf:cli-no-name-on-delete;
      tailf:cli-no-value-on-delete;
      tailf:non-strict-leafref {
        path "../../parser/view/name";
      }
      type string {
        tailf:info "WORD;;View name";
      }
    }

    // username * algorithm-type
    leaf algorithm-type {
      tailf:info "Algorithm to use for hashing the plaintext secret for the user";
      tailf:ned-ignore-compare-config;
      tailf:cli-no-name-on-delete;
      tailf:cli-no-value-on-delete;
      tailf:cli-incomplete-command;
      default sha256;
      type enumeration {
        enum md5 {
          tailf:info "Encode the password using the MD5 algorithm";
        }
        enum scrypt {
          tailf:info "Encode the password using the SCRYPT hashing algorithm";
        }
        enum sha256 {
          tailf:info "Encode the password using the PBKDF2 hashing algorithm";
        }
      }
    }

    // username * password
    container password {
      tailf:info "Specify the password for the user";
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-no-name-on-delete;
      tailf:cli-diff-set-after "../secret" {
        tailf:cli-when-target-delete;
      }
      leaf type {
        tailf:cli-drop-node-name;
        tailf:cli-no-value-on-delete;
        tailf:cli-optional-in-sequence;
        tailf:cli-incomplete-command;
        type enumeration {
          enum "0" {
            tailf:info "Specifies an UNENCRYPTED password/key will follow";
          }
          enum "5" {
            tailf:info "Specifies a HIDDEN key will follow";
          }
          enum "6" {
            tailf:info "Specifies ENCRYPTED key will follow";
          }
          enum "7" {
            tailf:info "Specifies a HIDDEN password/key will follow";
          }
        }
      }
      leaf secret {
        tailf:cli-drop-node-name;
        tailf:cli-reset-container;
        tailf:cli-no-value-on-delete;
        tailf:cli-full-command;
        tailf:cli-disallow-value "0|5|6|7";
        cli:secret " password <SECRET>" {
          cli:arguments "replace-line";
        }
        type NEDCOM_SECRET_TYPE {
          tailf:info "LINE;;The UNENCRYPTED (cleartext) password/key";
        }
      }
    }

    // username * secret
    container secret {
      tailf:info "Specify the secret for the user";
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-no-name-on-delete;
      tailf:cli-diff-set-after "../password" {
        tailf:cli-when-target-delete;
      }
      leaf type {
        tailf:cli-optional-in-sequence;
        tailf:cli-drop-node-name;
        tailf:cli-no-value-on-delete;
        tailf:cli-incomplete-command;
        type enumeration {
          enum "0" {
            tailf:info "Specifies an UNENCRYPTED secret will follow";
          }
          enum "4" {
            tailf:info "Specifies a HIDDEN secret will follow";
          }
          enum "5" {
            tailf:info "Specifies a HIDDEN secret will follow";
          }
          enum "8" {
            tailf:info "Specifies a PBKDF2 HASHED secret will follow";
          }
          enum "9" {
            tailf:info "Specifies a SCRYPT HASHED secret will follow";
          }
        }
      }
      leaf secret {
        tailf:cli-drop-node-name;
        tailf:cli-reset-container;
        tailf:cli-no-value-on-delete;
        tailf:cli-full-command;
        tailf:cli-disallow-value "0|4|5|8|9";
        cli:secret " secret <SECRET>" {
          cli:arguments "replace-line";
        }
        type NEDCOM_SECRET_TYPE {
          tailf:info "WORD;;The HIDDEN user secret string";
        }
      }
    }
  }


  /// ========================================================================
  /// table-map
  /// ========================================================================
  // Note: Must come before policer aggregate

  list table-map {
    tailf:info "Configure Table Map";
    tailf:cli-mode-name "config-tablemap";
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;table-map name";
      }
    }

    // table-map * / map from * to
    container map {
      tailf:info "map to_value from from_value";
      list from {
        tailf:info "map from value";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          type uint8 {
            tailf:info "<0-99>;;tablemap from value";
            range "0..99";
          }
        }
        leaf to {
          tailf:info "map to value";
          type uint8 {
            tailf:info "<0-99>;;tablemap to value";
            range "0..99";
          }
        }
      }
    }

    // table-map * / default
    leaf default {
      tailf:info "the default behavior for setting value not found in the table map";
      type union {
        type uint8 {
          tailf:info "<0-99>;;tablemap default value";
          range "0..99";
        }
        type enumeration {
          enum copy {
            tailf:info "set the default behavior for value not found in the table map to copy";
          }
          enum ignore {
            tailf:info "set the default behavior for value not found in the table map to ignore";
          }
        }
      }
    }

  }


  /// ========================================================================
  /// sdm
  /// ========================================================================

  container sdm {
    tailf:info "Switch database management";

    // sdm prefer
    container prefer {
      tailf:info "Config TCAM and ASIC RAM size. Warning: need to reset switch for configuration to take effect";
      tailf:cli-delete-when-empty;
      presence true;

      // sdm prefer disable_8k_efp
      leaf disable_8k_efp {
        tailf:info "Disable 8k efp";
        type empty;
      }

      // disable_tdm_to_ip_iw
      leaf disable_tdm_to_ip_iw {
        tailf:info "DISABLE TDM TO IP IW";
        type empty;
      }

      // sdm prefer disable_l2pt_fwd_all
      leaf disable_l2pt_fwd_all {
        tailf:info "DISABLE L2PT FORWARD ALL";
        type empty;
      }

      // sdm prefer disable_multicast_stats
      leaf disable_multicast_stats {
        tailf:info "DISABLE MULTICAST STATS";
        type empty;
      }

      // sdm prefer disable_bdi_mtu
      leaf disable_bdi_mtu {
        tailf:info "Disable BDI MTU";
        type empty;
      }

      // sdm prefer disable_portchannel_qos_multiple_active
      leaf disable_portchannel_qos_multiple_active {
        tailf:info "Disable portchannel QoS multiple active";
        type empty;
      }

      // sdm prefer no_efp_feat_ext
      leaf no_efp_feat_ext {
        tailf:info "NO EFP FEAT EXT";
        type empty;
      }

      // sdm prefer disable_egr_l3vpn_cm
      choice egr_l3vpn_cm-choice {
        leaf disable_egr_l3vpn_cm {
          tailf:info "DISABLE EGRESS L3VPN CM";
          type empty;
        }
        leaf enable_egr_l3vpn_cm {
          tailf:info "ENABLE EGRESS L3VPN CM";
          type empty;
        }
      }

      // sdm prefer disable_l3vpn_cm
      leaf disable_l3vpn_cm {
        tailf:info "DISABLE L3VPN CM";
        type empty;
      }

      // sdm prefer enable_copp
      choice copp-choice {
        leaf disable_copp {
          tailf:info "DISABLE COPP";
          type empty;
        }
        leaf enable_copp {
          tailf:info "ENABLE COPP";
          type empty;
        }
      }

      // sdm prefer disable_match_inner_dscp
      leaf disable_match_inner_dscp {
        tailf:info "DISABLE MATCH INNER DSCP";
        type empty;
      }

      // sdm prefer sr_pfp_disable
      leaf sr_pfp_disable {
        tailf:info "Disable SR PFP";
        type empty;
      }

      // sdm prefer sr_5_label_push_disable
      leaf sr_5_label_push_disable {
        tailf:info "Disable SR 5 labels push";
        type empty;
      }

      // sdm prefer access
      leaf access {
        tailf:info "Access bias";
        type empty;
      }

      // sdm prefer default
      leaf default {
        tailf:info "default template";
        type empty;
      }

      // sdm prefer dual-ipv4-and-ipv6
      leaf dual-ipv4-and-ipv6 {
        tailf:info "Support both IPv4 and IPv6";
        type enumeration {
          enum "default" {
            tailf:info "Default bias";
          }
          enum routing {
            tailf:info "Unicast bias";
          }
          enum vlan {
            tailf:info "VLAN bias";
          }
        }
      }

      // sdm prefer routing
      leaf routing {
        tailf:info "Unicast bias";
        type empty;
      }

      // sdm prefer qos
      leaf qos {
        type empty;
      }

      // sdm prefer ip
      leaf ip {
        tailf:info "ip template";
        type empty;
      }

      // sdm prefer advanced
      leaf advanced {
        tailf:info "Advanced Template";
        type empty;
      }

      // sdm prefer vlan
      leaf vlan {
        tailf:info "VLAN bias";
        type empty;
      }

      // sdm prefer video
      leaf video {
        tailf:info "video template";
        type empty;
      }

      // sdm prefer vpls_stats_disable
      choice vpls_stats-choice {
        leaf vpls_stats_disable {
          tailf:info "Disable VPLS Pseudowire statistics";
          type empty;
        }
        leaf vpls_stats_enable {
          tailf:info "Enable VPLS Pseudowire statistics";
          type empty;
        }
      }
    }
  }


  /// ========================================================================
  /// mls
  /// ========================================================================
  // Note: must come before class-map and policy-map.

  container mls {
    tailf:info "mls global commands";
    tailf:cli-incomplete-no;

    // mls acl
    container acl {
      tailf:info "MLS ACL operation";

      // mls acl tcam
      container tcam {
        tailf:info "ACL TCAM";
        leaf default-result {
          tailf:info "Default result to be used during tcam programming";
          type enumeration {
            enum bridge {
              tailf:info "Bridge result";
            }
            enum deny {
              tailf:info "Deny result";
            }
            enum permit {
              tailf:info "Permit result";
            }
          }
        }

        container log-update {
          tailf:info "Log TCAM updates";
          presence true;
          leaf rate-limit-msg {
            tailf:info "Enable/Disable syslog ratelimiting";
            type enumeration {
              enum disable {
                tailf:info "Disable ratelimiting syslog";
              }
              enum enable {
                tailf:info "Enable syslog ratelimiting at 1 per second";
              }
            }
          }
        }

        // no mls acl tcam share-global
        leaf share-global {
          tailf:info "share global deny or permit any entries";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }
      }
    }

    // mls cef
    container cef {
      tailf:info "cef keyword";

      // mls cef adjacency-mcast
      container adjacency-mcast {
        tailf:info "Configure adjacency entries for mcast";
        tailf:cli-incomplete-no;

        // mls cef adjacency-mcast region *
        list region {
          tailf:info "Configure per region adjacency entries for mcast";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          key id;
          leaf id {
            type uint8 {
              tailf:info "<1-31>;;Mcast region number";
              range "1..31";
            }
          }
          leaf value {
            tailf:cli-drop-node-name;
            tailf:cli-no-value-on-delete;
            type uint8 {
              tailf:info "<1-16>;;number of 1K entries";
              range "1..16";
            }
          }
        }

        // mls cef adjacency-mcast
        leaf value {
          tailf:cli-drop-node-name;
          tailf:cli-no-value-on-delete;
          type uint8 {
            tailf:info "<1-16>;;number of 1K entries";
            range "1..16";
          }
        }
      }

      // mls cef error
      container error {
        leaf action {
          type enumeration {
            enum reset;
            enum freeze;
          }
        }
      }

      // mls cef maximum-routes
      container maximum-routes {
        tailf:info "Configure route allocation for protocols";
        leaf ip {
          tailf:info "number of ip routes";
          type uint16 {
            tailf:info "<1-720>;;number of 1K entries";
          }
        }
        leaf ipv6 {
          tailf:info "number of ipv6 routes";
          type uint16 {
            tailf:info "<1-172>;;number of 1K entries";
          }
        }
        leaf mpls {
          tailf:info "number of MPLS labels";
          type uint16 {
            tailf:info "<1-88>;;number of 1K entries";
          }
        }
        leaf ip-multicast {
          tailf:info "number of multicast routes";
          type uint16 {
            tailf:info "<1-40>;;number of 1K entries";
          }
        }
      }
    }

    // mls rp
    container rp {
      tailf:info "rp";

      // mls rp ip X
      container ip {
        tailf:info "Enable IP shortcuts";
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;

        // mls rp ip input-acl
        leaf input-acl {
          tailf:info "Enable IP input access list";
          type empty;
        }

        // mls rp ip route-map
        leaf route-map {
          tailf:info "Enable IP route map";
          type empty;
        }
      }

      // mls rp ip
      container ip-enable {
        tailf:cli-drop-node-name;
        leaf ip {
          tailf:cli-full-command;
          type empty;
        }
      }
    }

    // mls nde
    container nde {
      tailf:info "netflow data export (nde) keyword";

      // mls nde sender version
      container sender {
        tailf:info "enable mls nde export";
        tailf:cli-delete-when-empty;
        tailf:cli-reset-container;
        presence true;
        leaf version {
          tailf:info "version keyword";
          type enumeration {
            enum 5;
            enum 7;
          }
        }
      }
    }

    // mls ip
    container ip {
      tailf:info "ip keyword";

      // no mls ip slb purge global
      container slb {
        tailf:info "Server Load Balancing";
        container purge {
          tailf:info "purge options";
          leaf global {
            tailf:info "Purge mls on protocol level if purge requests throttled";
            tailf:cli-boolean-no;
            type boolean;
            default true;
          }
        }
      }

      // mls ip cef
      container cef {
        tailf:info "cef keyword";

        // mls ip cef load-sharing
        container load-sharing {
          tailf:info "load balancing";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf full {
            tailf:info "load balancing algorithm to include L4 ports";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          leaf exclude-port {
            tailf:info "Exclude source or destination port for load balancing algorithm";
            tailf:cli-optional-in-sequence;
            type enumeration {
              enum destination {
                tailf:info "Exclude destination port in hash function";
              }
              enum source {
                tailf:info "Exclude source port in hash function";
              }
            }
          }
          leaf simple {
            tailf:info "load balancing algorithm recommended for a single-stage CEF router";
            type empty;
          }
        }
      }

      // mls ip multicast
      container multicast {
        tailf:info "multicast keyword";
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;

        // mls ip multicast consistency-check
        container consistency-check {
          tailf:info "Set consistency checking characteristics";
          tailf:cli-delete-when-empty;
          presence true;

          // mls ip multicast consistency-check type
          container type {
            tailf:info "Set consistency checker type";
            container rp-sp {
              tailf:info "Scan mlsm for Route, Switch Processor consistency";
              presence true;
            }
            container met {
              presence true;
            }
          }

          // mls ip multicast consistency-check settle-time
          leaf settle-time {
            tailf:info "Settle time for entry/oif for consistancy-checker";
            type uint16 {
              tailf:info "<2-3600>;;Settle time for entry/oif in seconds";
              range "2..3600";
            }
          }
        }

        // mls ip multicast flow-stat-timer
        leaf flow-stat-timer {
          tailf:info "timer for flow statistic used by mls-msc and mlsm";
          type uint8 {
            tailf:info "<1-100>;;#seconds between one batch and another";
            range "1..100";
          }
        }

        // mls ip multicast replication-mode
        leaf replication-mode {
          tailf:info "Disable auto-detection mode for egress";
          type enumeration {
            enum ingress {
              tailf:info "Enable ingress mode of replication";
            }
            enum egress {
              tailf:info "Enable egress mode of replication";
            }
          }
        }

        // mls ip multicast egress local
        container egress {
          tailf:info "Set egress replication options";
          leaf local {
            tailf:info "Populate METs with local L3 routed interfaces";
            type empty;
          }
        }

        // mls ip multicast met-optimization enable
        container met-optimization {
          leaf enable {
            type empty;
          }
        }

        // mls ip multicast bidir gm-scan-interval
        container bidir {
          tailf:info "Bidir commands";
          leaf gm-scan-interval {
            tailf:info "Bidir RP RPF scan interval";
            type uint16 {
              tailf:info "<1-1000>;;Bidir RP RPF Scan interval in secs";
              range "1..1000";
            }
          }
        }

        // mls ip multicast threshold
        leaf threshold {
          tailf:info "Threshold rate for installing h/w shortcuts";
          type uint16 {
            tailf:info "<10-10000>;;threshold in pkts per sec";
            range "10..10000";
          }
        }
      }

      // no mls ip multicast
      container multicast-enable {
        tailf:cli-drop-node-name;
        leaf multicast {
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }
      }
    }

    // mls ipv6
    container ipv6 {
      tailf:info "Enable global ipv6 commands";

      // mls ipv6 vrf
      // NOTE: no mls ipv6 vrf requires device reboot
      leaf vrf {
        tailf:info "Enable IPv6 VRF";
        tailf:cli-full-command;
        type empty;
      }
    }

    // mls aging
    container aging {
      tailf:info "L3 aging";

      // mls aging fast
      container fast {
        tailf:info "L3 fast aging";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence true;
        leaf time {
          tailf:info "fast aging timeout value";
          type uint8 {
            tailf:info "<1-128>;;L3 fast aging time in seconds";
            range "1..128";
          }
        }
        leaf threshold {
          tailf:info "fast aging threshold";
          type uint8 {
            tailf:info "<1-128>;;L3 fast aging theshold packet count";
            range "1..128";
          }
        }
      }

      // mls aging normal
      container normal {
        tailf:info "normal aging keyword";
        leaf seconds {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<32-4092>;;L3 aging timeout in second";
            range "32..4092";
          }
        }
      }

      // mls aging long
      container long {
        tailf:info "long aging keyword";
        leaf timeout {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<64-1920>;;long aging timeout";
            range "64..1920";
          }
        }
      }
    }

    // mls netflow
    container netflow {
      tailf:info "netflow keyword";
      tailf:cli-delete-when-empty;
      presence true;

      // mls netflow interface
      leaf interface {
        type empty;
      }

      // mls netflow usage notify
      container usage {
        container notify {
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf percentage {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<20-100>;;threshold percentage";
              range "20..100";
            }
          }
          leaf seconds {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<120-1000000>;;time interval in seconds";
              range "120..1000000";
            }
          }
        }
      }
    }

    // mls flow
    container flow {
      tailf:info "flowmask keyword";

      // mls flow ip
      leaf ip {
        tailf:info "flowmask ip keyword";
        type enumeration {
          enum interface-destination {
            tailf:info "interface-destination flow keyword";
          }
          enum interface-destination-source {
            tailf:info "interface-destination-source flow keyword";
          }
          enum interface-full {
            tailf:info "interface-full flow keyword";
          }
          enum interface-source {
            tailf:info "interface-source only flow keyword";
          }
          enum full {
          }
        }
      }

      // mls flow ipv6
      choice ipv6-choice {
        container no-ipv6 {
          tailf:cli-drop-node-name;
          // no mls flow ipv6
          leaf ipv6 {
            tailf:cli-boolean-no;
            tailf:cli-full-no;
            type boolean;
            default true;
          }
        }
        container ipv6 {
          tailf:info "flowmask ipv6 keyword";
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          choice ipv6-choice2 {
            leaf interface-destination {
              tailf:info "interface-destination flow keyword";
              type empty;
            }
            leaf interface-destination-source {
              tailf:info "interface-destination-source flow keyword";
              type empty;
            }
            leaf interface-full {
              tailf:info "interface-full flow keyword";
              type empty;
            }
            leaf interface-source {
              tailf:info "interface-source only flow keyword";
              type empty;
            }
          }
        }
      }
    }

    // mls sampling
    container sampling {
      tailf:info "sampling keyword";
      choice sampling-choice {
        // mls sampling time-based
        leaf time-based {
          type uint16;
        }
        // mls sampling packet-based
        container packet-based {
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf rate {
            tailf:cli-drop-node-name;
            type uint16;
          }
          leaf interval {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<8000-16000>;;sampling interval in millisec";
              range "8000..16000";
            }
          }
        }
      }
    }

    // mls qos
    container mls-qos-conf {
      tailf:cli-drop-node-name;
      leaf qos {
        tailf:info "QoS parameters";
        type empty;
      }
    }

    // mls qos X
    container qos {
      tailf:info "QoS parameters";
      tailf:cli-incomplete-command;
      tailf:cli-incomplete-no;

      // mls qos protocol *
      list protocol {
        tailf:info "protocol keyword";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;protocol name";
          }
        }

        // mls qos protocol * precedence
        leaf precedence {
          tailf:info "change ip-precedence(used to map the dscp to cos value)";
          tailf:cli-optional-in-sequence;
          type uint8 {
            tailf:info "<0-7>;;new cos value";
            range "0..7";
          }
        }

        // mls qos protocol * police
        container police {
          tailf:info "police keyword";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf target-bit-rate {
            tailf:cli-drop-node-name;
            type uint64 {
              tailf:info "<32000-60000000000>;;Target Bit Rate (bits per second) (postfix k, m, g optional; decimal point allo";
            }
          }
          leaf burst {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1000-512000000>;;Normal burst bytes";
              range "1000..512000000";
            }
          }
        }
      }

      // mls qos aggregate-policer *
      list aggregate-policer {
        tailf:info "Assign aggregate policer";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;aggregate policer name";
          }
        }
        leaf target-bit-rate {
          tailf:cli-drop-node-name;
          type uint64 {
            tailf:info "<32000-60000000000>;;Target Bit Rate (bits per "
              +"second) (postfix k, m, g optional; decimal point allowed)";
            range "32000..60000000000";
          }
        }
        leaf burst-normal {
          tailf:cli-drop-node-name;
          tailf:cli-optional-in-sequence;
          type uint32 {
            tailf:info "<1000-31250000>;;Normal burst bytes";
            range "1000..31250000";
          }
        }
        leaf burst-max {
          tailf:cli-drop-node-name;
          tailf:cli-optional-in-sequence;
          when "../burst-normal" {
            tailf:dependency "../burst-normal";
          }
          type uint32 {
            tailf:info "<1000-31250000>;;Maximum burst bytes";
            range "1000..31250000";
          }
        }
        leaf pir {
          tailf:info "PIR";
          tailf:cli-optional-in-sequence;
          type uint64 {
            tailf:info "<32000-60000000000>;;Target Bit Rate (bits per "
              +"second) (postfix k, m, g optional; decimal point allowed)";
            range "32000..60000000000";
          }
        }
        container conform-action {
          tailf:info "action when rate is not exceeded";
          tailf:cli-optional-in-sequence;
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          choice action-choice {
            leaf drop {
              tailf:info "drop packet";
              type empty;
            }
            leaf set-dscp-transmit {
              tailf:info "set dscp and send it";
              type dscp-type;
            }
            leaf set-mpls-exp-imposition-transmit {
              tailf:info "set exp at tag imposition and send it";
              type uint8 {
                tailf:info "<0-7>;;new exp";
                range "0..7";
              }
            }
            leaf set-prec-transmit {
              tailf:info "rewrite packet precedence and send it";
              type uint8 {
                tailf:info "<0-7>;;new precedence";
                range "0..7";
              }
            }
            leaf transmit {
              tailf:info "transmit packet";
              type empty;
            }
          }
        }
        leaf exceed-action {
          tailf:info "action when rate is exceeded";
          tailf:cli-optional-in-sequence;
          type enumeration {
            enum drop {
              tailf:info "drop packet";
            }
            enum policed-dscp-transmit {
              tailf:info "change dscp per policed-dscp map and send it";
            }
            enum transmit {
              tailf:info "transmit packet";
            }
          }
        }
        leaf violate-action {
          tailf:info "action when rate violated";
          type enumeration {
            enum drop {
              tailf:info "drop packet";
            }
            enum policed-dscp-transmit {
              tailf:info "change dscp per policed-dscp map and send it";
            }
            enum transmit {
              tailf:info "transmit packet";
            }
          }
        }
      }

      // mls qos cos policy-map
      container cos {
        tailf:info "Configure CoS setting";
        leaf policy-map {
          tailf:info "Set by Policy-Map";
          type empty;
        }
      }

      // mls qos rewrite
      container rewrite {
        tailf:info "packet qos rewrite enable/disable";
        container ip {
          tailf:info "ip packet qos rewrite enable/disable";
          container dscp {
            tailf:info "packet ip dscp rewrite enable/disable";
            presence true;
            leaf slot {
              tailf:info "slot number";
              type string {
                tailf:info "WORD;;Slots seperated by commas. Valid slots: 1,2,3,4,5,6,7,8,9";
              }
            }
          }
        }
      }

      // mls qos map
      container map {
        tailf:info "Define QoS mapping";

        // mls qos map dscp-mutation *
        list dscp-mutation {
          tailf:info "Configure dscp-mutation map";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-incomplete-command;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;DSCP mutation map name";
            }
          }
          leaf mutated-dscp1 {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-63>;;dscp values separated by spaces (8 values total)";
              range "0..63";
            }
          }
          leaf mutated-dscp2 {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-63>;;dscp values separated by spaces (8 values total)";
              range "0..63";
            }
          }
          leaf mutated-dscp3 {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-63>;;dscp values separated by spaces (8 values total)";
              range "0..63";
            }
          }
          leaf mutated-dscp4 {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-63>;;dscp values separated by spaces (8 values total)";
              range "0..63";
            }
          }
          leaf mutated-dscp5 {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-63>;;dscp values separated by spaces (8 values total)";
              range "0..63";
            }
          }
          leaf mutated-dscp6 {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-63>;;dscp values separated by spaces (8 values total)";
              range "0..63";
            }
          }
          leaf mutated-dscp7 {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-63>;;dscp values separated by spaces (8 values total)";
              range "0..63";
            }
          }
          leaf mutated-dscp8 {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-63>;;dscp values separated by spaces (8 values total)";
              range "0..63";
            }
          }
          // mls qos map dscp-mutation * to
          leaf to {
            tailf:info "Specify egress DSCPs";
            type uint16 {
              tailf:info "<0-63>;;dscp value";
              range "0..63";
            }
          }
        }

        // mls qos map cos-dscp *
        leaf-list cos-dscp {
          when "not(../../../../tailfned/api/new-mls-qos)" {
            tailf:dependency "../../../../tailfned/api/new-mls-qos";
          }
          tailf:info "cos-dscp map: eight dscp values for cos 0-7";
          tailf:cli-flat-list-syntax;
          tailf:cli-no-value-on-delete;
          tailf:cli-replace-all;
          type uint8 {
            tailf:info "<0-63>;;CoS values separated by spaces (up to 8 values total)";
            range "0..63";
          }
        }
        container cos-dscp-new {
            tailf:cli-drop-node-name;
            when "../../../../tailfned/api/new-mls-qos" {
              tailf:dependency "../../../../tailfned/api/new-mls-qos";
            }
            container cos-dscp {
              tailf:info "cos-dscp map: eight dscp values for cos 0-7";
              uses cos-value-0-7-grouping;
            }
          }

          // mls qos map ip-prec-dscp *
          leaf-list ip-prec-dscp {
          tailf:info "dscp values for ip precedences 0 - 7";
          tailf:cli-flat-list-syntax;
          tailf:cli-no-value-on-delete;
          tailf:cli-replace-all;
          type uint8 {
            tailf:info "<0-63>;;8 dscp values separated by spaces";
            range "0..63";
          }
        }

        // mls qos map policed-dscp *
        list policed-dscp {
          tailf:info "Map DSCP to policed DSCP";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-incomplete-command;
          ios:delete-syntax "no mls qos map policed-dscp";
          key dscp;
          leaf dscp {
            type uint8 {
              tailf:info "<0-63>;;dscp values separated by spaces (up to 8 values total";
              range "0..63";
            }
          }
          leaf to {
            tailf:info "Specify policed DSCP";
            type uint8 {
              tailf:info "<0-63>;;policed dscp value";
              range "0..63";
            }
          }
        }

        // mls qos map exp-mutation *
        list exp-mutation {
          tailf:info "exp-mutation map keyword";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-incomplete-command;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;exp-mutation map name";
            }
          }
          leaf mutated-exp1 {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-7>;;exp values separated by spaces (8 values total)";
              range "0..7";
            }
          }
          leaf mutated-exp2 {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-7>;;exp values separated by spaces (8 values total)";
              range "0..7";
            }
          }
          leaf mutated-exp3 {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-7>;;exp values separated by spaces (8 values total)";
              range "0..7";
            }
          }
          leaf mutated-exp4 {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-7>;;exp values separated by spaces (8 values total)";
              range "0..7";
            }
          }
          leaf mutated-exp5 {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-7>;;exp values separated by spaces (8 values total)";
              range "0..7";
            }
          }
          leaf mutated-exp6 {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-7>;;exp values separated by spaces (8 values total)";
              range "0..7";
            }
          }
          leaf mutated-exp7 {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-7>;;exp values separated by spaces (8 values total)";
              range "0..7";
            }
          }
          leaf mutated-exp8 {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<0-7>;;exp values separated by spaces (8 values total)";
              range "0..7";
            }
          }
        }

        // mls qos map exp-dscp
        container exp-dscp {
          tailf:info "exp-dscp map: eight dscp values for exp 0-7";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf dscp1 {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-63>;;dscp value 1 out of total 8";
              range "0..63";
            }
          }
          leaf dscp2 {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-63>;;dscp value 2 out of total 8";
              range "0..63";
            }
          }
          leaf dscp3 {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-63>;;dscp value 3 out of total 8";
              range "0..63";
            }
          }
          leaf dscp4 {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-63>;;dscp value 4 out of total 8";
              range "0..63";
            }
          }
          leaf dscp5 {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-63>;;dscp value 5 out of total 8";
              range "0..63";
            }
          }
          leaf dscp6 {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-63>;;dscp value 6 out of total 8";
              range "0..63";
            }
          }
          leaf dscp7 {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-63>;;dscp value 7 out of total 8";
              range "0..63";
            }
          }
          leaf dscp8 {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<0-63>;;dscp value 8 out of total 8";
              range "0..63";
            }
          }
        }
      }

      // mls qos srr-queue
      container srr-queue {
        tailf:info "Configure SRR receive queues";

        // mls qos srr-queue input cos-map *
        // mls qos srr-queue output cos-map *
        // mls qos srr-queue input dscp-map *
        // mls qos srr-queue output dscp-map *
        // mls qos srr-queue *
        list cos-dscp-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          ios:redeploy-with-change "no  :: (mls qos srr-queue \\S+ \\S+)";
          ios:max-values-output "9 :: 8";
          key "direction maptype";
          leaf direction {
            type enumeration {
              enum "input" {
                tailf:info "input keyword";
              }
              enum "output" {
                tailf:info "output keyword";
              }
            }
          }
          leaf maptype {
            type enumeration {
              enum cos-map {
                tailf:info "Configure cos-map for a queue id";
              }
              enum dscp-map {
                tailf:info "Configure dscp-map for a queue id";
              }
              enum cpu {
              }
            }
          }
          list queue-threshold-list {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            key "queue threshold";
            leaf queue {
              tailf:info "Assign COS|DSCP values to a queue";
              tailf:cli-expose-key-name;
              type uint8 {
                tailf:info "<num>;;enter <cos|dscp>-map queue id";
              }
            }
            leaf threshold {
              tailf:info "Assign COS|DSCP values to a queue threshold";
              tailf:cli-expose-key-name;
              type uint8 {
                tailf:info "<num>;;enter <cos|dscp>-map threshold id";
              }
            }
            leaf-list values {
              tailf:cli-drop-node-name;
              tailf:cli-flat-list-syntax;
              type uint8 {
                tailf:info "cos|dscp values separated by spaces";
              }
            }
          }
        }

        // mls qos srr-queue input
        container input {
          tailf:cli-incomplete-no;

          // mls qos srr-queue input priority-queue *
          list priority-queue {
            tailf:info "Configure priority scheduling";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            key queue;
            leaf queue {
              type uint8 {
                tailf:info "<1-2>;;enter priority queue number [1-2]";
              }
            }
            leaf bandwidth {
              tailf:info "ingress priority queue bandwidth % of stack ring";
              tailf:cli-no-name-on-delete;
              tailf:cli-no-value-on-delete;
              type uint8 {
                tailf:info "<0-40>;;enter bandwidth number [0-40]";
              }
            }
          }

          // mls qos srr-queue input bandwidth
          container bandwidth {
            tailf:info "Configure SRR bandwidth";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf weight1 {
              tailf:cli-drop-node-name;
              tailf:cli-no-value-on-delete;
              type uint8 {
                tailf:info "<1-100>;;enter bandwidth weight for queue id 1";
              }
            }
            leaf weight2 {
              tailf:cli-drop-node-name;
              tailf:cli-no-value-on-delete;
              type uint8 {
                tailf:info "<1-100>;;enter bandwidth weight for queue id 2";
              }
            }
          }

          // mls qos srr-queue input threshold *
          list threshold {
            tailf:info "Configure queue tail-drop thresholds";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            key queue;
            leaf queue {
              type uint8 {
                tailf:info "<1-2>;;enter threshold queue id (1-2)";
              }
            }
            leaf threshold-percentage1 {
              tailf:cli-drop-node-name;
              tailf:cli-no-value-on-delete;
              type uint8 {
                tailf:info "<1-100>;;enter percent of queue size for threshold 1";
              }
            }
            leaf threshold-percentage2 {
              tailf:cli-drop-node-name;
              tailf:cli-no-value-on-delete;
              type uint8 {
                tailf:info "<1-100>;;enter percent of queue size for threshold 2";
              }
            }
          }

          // mls qos srr-queue input buffers
          container buffers {
            tailf:info "Configure buffer allocation";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf percentage1 {
              tailf:cli-drop-node-name;
              tailf:cli-no-value-on-delete;
              type uint8 {
                tailf:info "<0-100>;;enter percent of buffers for queue 1";
              }
            }
            leaf percentage2 {
              tailf:cli-drop-node-name;
              tailf:cli-no-value-on-delete;
              type uint8 {
                tailf:info "<0-100>;;enter percent of buffers for queue 2";
              }
            }
          }
        }
      }

      // mls qos queue-set output
      container queue-set {
        tailf:info "Choose a queue set for this queue";
        container output {
          tailf:info "Direction the command applies for this command";

          // mls qos queue-set output threshold
          list threshold-list {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            key "queue threshold";
            leaf queue {
              type uint8 {
                tailf:info "<1-2>;;queue-set id";
              }
            }
            leaf threshold {
              tailf:info "Assign threshold values to a queue";
              tailf:cli-expose-key-name;
              type uint8 {
                tailf:info "<1-4>;;enter queue id in this queue set";
              }
            }
            leaf drop-threshold1 {
              tailf:cli-drop-node-name;
              tailf:cli-no-value-on-delete;
              type uint16 {
                tailf:info "<1-3200>;;enter drop threshold1 1-3200";
              }
            }
            leaf drop-threshold2 {
              tailf:cli-drop-node-name;
              tailf:cli-no-value-on-delete;
              type uint16 {
                tailf:info "<1-3200>;;enter drop threshold2 1-3200";
              }
            }
            leaf reserved-threshold {
              tailf:cli-drop-node-name;
              tailf:cli-no-value-on-delete;
              type uint16 {
                tailf:info "<1-100>;;enter reserved threshold 1-100";
              }
            }
            leaf maximum-threshold {
              tailf:cli-drop-node-name;
              tailf:cli-no-value-on-delete;
              type uint16 {
                tailf:info "<1-3200>;;enter maximum threshold 1-3200";
              }
            }
          }

          // mls qos queue-set output buffers
          list buffers-list {

            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            key queue;
            leaf queue {
              type uint8 {
                tailf:info "<1-2>;;queue-set id";
              }
            }
            container buffers {
              tailf:info "mls qos queue-set output buffers";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf allocation1 {
                tailf:cli-drop-node-name;
                tailf:cli-no-value-on-delete;
                type uint8 {
                  tailf:info "<0-99>;;enter buffer percentage for queue 1 0-";
                }
              }
              leaf allocation2 {
                tailf:cli-drop-node-name;
                tailf:cli-no-value-on-delete;
                type uint8 {
                  tailf:info "<1-100>;;enter buffer percentage for queue 2 1-100 (includes CPU buffer)";
                }
              }
              leaf allocation3 {
                tailf:cli-drop-node-name;
                tailf:cli-no-value-on-delete;
                type uint8 {
                  tailf:info "<0-99>;;enter buffer percentage for queue 3 0-99";
                }
              }
              leaf allocation4 {
                tailf:cli-drop-node-name;
                tailf:cli-no-value-on-delete;
                type uint8 {
                  tailf:info "<0-99>;;enter buffer percentage for queue 4 0-99";
                }
              }
            }
          }
        }
      }

      // mls qos min-reserve *
      list min-reserve {
        tailf:info "Configure min-reserve buffers";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key level;
        leaf level {
          type uint8 {
            tailf:info "<1-8>;;Configure min-reserve level";
            range "1..8";
          }
        }
        leaf buffersize {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<10-170>;;Configure min-reserve buffers";
            range "10..170";
          }
        }
      }
    }

    // mls rate-limit
    container rate-limit {
      tailf:info "Rate limit different behaviors";

      // mls rate-limit multicast ipv4
      container multicast {
        tailf:info "Rate limiting for Multicast packets";

        // mls rate-limit multicast ipv4 *
        list ipv4 {
          tailf:info "Rate limiters for IPv4 traffic";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          key name;
          leaf name {
            type enumeration {
              enum fib-miss {
                tailf:info "Rate limiting of fib-missed multicast packets";
              }
              enum connected {
                tailf:info "Rate limiting of multicast packets from directly connected source";
              }
              enum ip-options {
                tailf:info "rate limiting of multicast packets with ip options";
              }
              enum igmp {
                tailf:info "Rate limiting of the IGMP protocol packets";
              }
              enum partial {
                tailf:info "rate limiting of multicast packets during partial-SC state";
              }
              enum pim {
                tailf:info "Rate limiting of the PIM protocol packets";
              }
              enum tiny-fragment {
                tailf:info "packets with fragment offset equal to 1";
              }
              enum non-rpf {
                tailf:info "Rate limiting of non-rpf multicast packets";
              }
            }
          }
          uses mls-rate-limit-grouping;
        }
      }

      // mls rate-limit unicast
      container unicast {
        tailf:info "Rate limiting for Unicast packets";

        // mls rate-limit unicast cef
        container cef {
          tailf:info "CEF cases";

          // mls rate-limit unicast cef glean
          container glean {
            tailf:info "Packets requiring ARP resolution";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            uses mls-rate-limit-grouping;
          }

          // mls rate-limit unicast cef receive
          container receive {
            tailf:info "Packets falling in the Receive case";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            uses mls-rate-limit-grouping;
          }
        }

        // mls rate-limit unicast acl
        container acl {
          tailf:info "ACL BRIDGE results";

          // mls rate-limit unicast acl input
          container input {
            tailf:info "Input ACL lookups requiring punt to RP";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            uses mls-rate-limit-grouping;
          }

          // mls rate-limit unicast acl output
          container output {
            tailf:info "Output ACL lookups requiring punt to RP";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            uses mls-rate-limit-grouping;
          }

          // mls rate-limit unicast acl vacl-log
          leaf vacl-log {
            tailf:info "Vlan ACL logging requiring punt to RP";
            tailf:code-name "mls-rate-limit-vacl-log";
            type uint32 {
              tailf:info "<10-1000000>;;packets per second";
              range "10..1000000";
            }
          }
        }

        // mls rate-limit unicast ip
        container ip {
          tailf:info "IP packets";

          // mls rate-limit unicast ip rpf-failure
          container rpf-failure {
            tailf:info "packets failing the RPF check";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            uses mls-rate-limit-grouping;
          }

          // mls rate-limit unicast ip icmp
          container icmp {
            tailf:info "packets requiring ICMP messages from the RP";

            // mls rate-limit unicast ip icmp redirect
            container redirect {
              tailf:info "packets requiring ICMP redirect (same VLAN)";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              uses mls-rate-limit-grouping;
            }

            // mls rate-limit unicast ip icmp unreachable
            container unreachable {
              tailf:info "packets requiring ICMP unreachable message";

              // mls rate-limit unicast ip icmp unreachable no-route
              container no-route {
                tailf:info "dropped via FIB Miss case";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                uses mls-rate-limit-grouping;
              }

              // mls rate-limit unicast ip icmp unreachable acl-drop
              container acl-drop {
                tailf:info "dropped via ACLs";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                uses mls-rate-limit-grouping;
              }
            }
          }

          // mls rate-limit unicast ip options
          container options {
            tailf:info "ipv4 packets with Options";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            uses mls-rate-limit-grouping;
          }

          // mls rate-limit unicast ip errors
          container errors {
            tailf:info "packets with IP Checksum and length errors";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            uses mls-rate-limit-grouping;
          }
        }
      }

      // mls rate-limit all
      container all {
        tailf:info "Rate Limiting for both Unicast and Multicast packets";

        // mls rate-limit all mtu-failure
        container mtu-failure {
          tailf:info "MTU failure cases";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          uses mls-rate-limit-grouping;
        }

        // mls rate-limit all ttl-failure
        container ttl-failure {
          tailf:info "TTL failure cases";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          uses mls-rate-limit-grouping;
        }
      }

      // mls rate-limit layer2
      container layer2 {
        tailf:info "layer2 protocol cases";

        // mls rate-limit layer2 l2pt
        container l2pt {
          tailf:info "layer2 protocol tunnelling packets";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          uses mls-rate-limit-grouping;
        }

        // mls rate-limit layer2 pdu
        container pdu {
          tailf:info "layer2 protocol data unit packets";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          uses mls-rate-limit-grouping;
        }

        // mls rate-limit layer2 mac-security
        container mac-security {
          tailf:info "Mac security traffics";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          uses mls-rate-limit-grouping;
        }
      }
    }

    // mls verify
    container verify {
      tailf:info "enable hardware packet parsing error checks";
      container ip {
        tailf:info "check on IP packets";

        // no mls verify ip checksum
        leaf checksum {
          tailf:info "check for packet checksum errors";
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }

        container length {
          tailf:info "check for packet length errors";

          // no mls verify ip length consistent
          leaf consistent {
            tailf:info "check length in header against physical frame length";
            tailf:cli-boolean-no;
            tailf:cli-full-command;
            type boolean;
            default true;
          }
          // no mls verify ip length minimum
          leaf minimum {
            tailf:info "check for minimum packet length";
            tailf:cli-boolean-no;
            type boolean;
            default true;
          }
        }
        leaf same-address {
          tailf:info "check for packet having equal source and destination IP addresses";
          type empty;
        }
        leaf syslog {
          tailf:info "syslog packet parse errors";
          type empty;
        }
      }
    }

    // mls mpls
    container mpls {
      tailf:info "configure global MPLS params";

      // mls mpls recir-agg
      leaf recir-agg {
        tailf:info "Recirculate MPLS aggregated label (only impact new aggregated labels)";
        type empty;
      }

      // mls mpls tunnel-recir
      leaf tunnel-recir {
        tailf:info "Recirculate Tunnel packets";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// policer
  /// ========================================================================
  // Note: must come before class-map and policy-map.

  container policer {
    tailf:info "Switch policer";

    // policer aggregate *
    list aggregate {
      tailf:info "Named aggregate policer";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;aggregate policer Name";
        }
      }
      // cir <cir-bps>
      leaf cir {
        tailf:info "Committed information rate";
        type uint32 {
          tailf:info "<8000-1000000000>;;Bits per second";
          range "8000..1000000000";
        }
      }
      // bc <burst>
      leaf bc {
        tailf:info "Conform burst";
        tailf:cli-optional-in-sequence;
        type uint32 {
          tailf:info "<8000-1000000000>;;Burst bytes";
          range "8000..1000000000";
        }
      }
      // conform-action
      leaf conform-action {
        tailf:info "action when rate is within conform and conform exceed burst";
        tailf:cli-optional-in-sequence;
        type empty;
      }
      leaf set-qos-transmit {
        tailf:info "set qos-group and send it";
        when "../conform-action" {
          tailf:dependency "../conform-action";
        }
        tailf:cli-optional-in-sequence;
        type uint8 {
          tailf:info "<0-99>;;new qos-group";
          range "0..99";
        }
      }
      leaf set-dot1ad-dei-transmit {
        tailf:info "set dei and send it";
        when "../conform-action" {
          tailf:dependency "../conform-action";
        }
        tailf:cli-optional-in-sequence;
        type uint8 {
          tailf:info "<0-1>;;new dei value";
          range "0..1";
        }
      }
      leaf set-prec-transmit {
        tailf:info "rewrite packet precedence and send it";
        when "../conform-action" {
          tailf:dependency "../conform-action";
        }
        tailf:cli-optional-in-sequence;
        type prec_value-type;
      }
      container set-prec-transmit-table {
        when "../set-prec-transmit" {
          tailf:dependency "../set-prec-transmit";
        }
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        tailf:cli-flatten-container;
        leaf table {
          tailf:info "Set packet cos from cos based on table map";
          tailf:cli-optional-in-sequence;
          tailf:non-strict-leafref {
            path "../../../../table-map/name";
          }
          type string {
            tailf:info "WORD;;table-map name";
          }
        }
      }
      leaf set-dscp-transmit {
        tailf:info "set dscp and send it";
        when "../conform-action" {
          tailf:dependency "../conform-action";
        }
        tailf:cli-optional-in-sequence;
        type dscp-type;
      }
      container set-dscp-transmit-table {
        when "../set-dscp-transmit" {
          tailf:dependency "../set-dscp-transmit";
        }
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        tailf:cli-flatten-container;
        leaf table {
          tailf:info "Set packet cos from cos based on table map";
          tailf:cli-optional-in-sequence;
          tailf:non-strict-leafref {
            path "../../../../table-map/name";
          }
          type string {
            tailf:info "WORD;;table-map name";
          }
        }
      }
      leaf set-cos-transmit {
        tailf:info "set cos and send it";
        when "../conform-action" {
          tailf:dependency "../conform-action";
        }
        tailf:cli-optional-in-sequence;
        type cos_value-type;
      }
      container set-cos-transmit-table {
        when "../set-cos-transmit" {
          tailf:dependency "../set-cos-transmit";
        }
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        tailf:cli-flatten-container;
        leaf table {
          tailf:info "Set packet cos from cos based on table map";
          tailf:cli-optional-in-sequence;
          tailf:non-strict-leafref {
            path "../../../../table-map/name";
          }
          type string {
            tailf:info "WORD;;table-map name";
          }
        }
      }
      leaf transmit {
        tailf:info "transmit packet";
        when "../conform-action" {
          tailf:dependency "../conform-action";
        }
        tailf:cli-optional-in-sequence;
        type empty;
      }
      // exceed-action
      leaf exceed-action {
        tailf:info "action when rate is within conform and conform exceed burst";
        type empty;
      }
      leaf drop {
        tailf:info "drop packet";
        when "../exceed-action" {
          tailf:dependency "../exceed-action";
        }
        tailf:cli-optional-in-sequence;
        tailf:cli-full-command;
        type empty;
      }
      container exceed-transmit {
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        tailf:cli-flatten-container;
        leaf transmit {
          tailf:info "transmit packet";
          when "../../exceed-action" {
            tailf:dependency "../../exceed-action";
          }
          tailf:cli-optional-in-sequence;
          type empty;
        }
      }
    }
  }


  /// ========================================================================
  /// hw-switch
  /// ========================================================================

  container hw-switch {
    tailf:info "Control of individual components in the switch";

    // hw-switch switch * logging onboard *
    list switch {
      tailf:info "Switch number";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-incomplete-command;
      key id;
      leaf id {
        type uint8 {
          tailf:info "<1-9>;;Switch number";
        }
      }
      container logging {
        tailf:info "Logging";
        list onboard {
          tailf:info "Onboard Logging";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type enumeration {
              enum counter {
                tailf:info "Configure logging onboard counter";
              }
              enum environment {
                tailf:info "Configure logging onboard environment";
              }
              enum message {
                tailf:info "Configure logging onboard message";
              }
              enum poe {
                tailf:info "Configure logging onboard poe";
              }
              enum temperature {
                tailf:info "Configure logging onboard temperature";
              }
              enum voltage {
                tailf:info "Configure logging onboard voltage";
              }
            }
          }
          leaf level {
            tailf:info "Specify Message the Level";
            type uint8 {
              tailf:info "<1 - 7>;;Specify the Level";
              range "1..7";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// redundancy
  /// ========================================================================

  container redundancy {
    tailf:info "Enter redundancy mode";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-red";
    tailf:cli-explicit-exit;
    presence true;

    // redundancy / maintenance-mode
    leaf maintenance-mode {
      tailf:info "Enable/Disable maintenance mode ";
      type empty;
    }

    // redundancy / mode
    leaf mode {
      tailf:info "redundancy mode for this chassis";
      type enumeration {
        enum rpr {
          tailf:info "Route Processor Redundancy";
        }
        enum rpr-plus {
          tailf:info "Route Processor Redundancy Plus";
        }
        enum sso {
          tailf:info "Stateful Switchover";
        }
        enum none {
          tailf:info "None";
        }
      }
    }

    // redundancy / notification-timer
    leaf notification-timer {
      tailf:info "Specify Redundancy notification timer (milliseconds)";
      type uint32 {
        tailf:info "<8000-120000>;;milliseconds";
      }
    }

    // redundancy / application redundancy
    container application {
      tailf:info "Enter application redundancy group mode";
      container redundancy {
        tailf:info "Enter application redundancy group mode";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-red-app";

        // redundancy / application redundancy / group *
        list group {
          tailf:info "Enter rg group mode";
          tailf:cli-mode-name "config-red-app-grp";
          tailf:cli-recursive-delete;
          key id;
          leaf id {
            type uint8 {
              tailf:info "<1-2>;;RG Group Id";
              range "1..2";
            }
          }

          // redundancy / application redundancy / group * / name
          leaf name {
            tailf:info "RG group name string";
            type string {
              tailf:info "WORD;;name string (25 chars. max)";
            }
          }

          // redundancy / application redundancy / group * / preempt
          leaf preempt {
            tailf:info "RG group preempte";
            type empty;
          }

          // redundancy / application redundancy / group * / priority
          container priority {
            tailf:info "RG group Priority";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf value {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<1-255>;;Priority value";
                range "1..255";
              }
            }
            container failover {
              tailf:info "threshold  Specify failover threshold";
              tailf:cli-flatten-container;
              leaf threshold {
                type uint8 {
                  tailf:info "<1-255>;;Failover threshold value";
                  range "1..255";
                }
              }
            }
          }

          // redundancy / application redundancy / group * / timers
          container timers {
            tailf:info "RG group timers";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf delay {
              tailf:info "RG group delay timer";
              type uint16 {
                tailf:info "<0-10000>;;Delay value in seconds";
              }
            }
            leaf reload {
              tailf:info "RG group reload timer";
              type uint16 {
                tailf:info "<0-10000>;;Reload value in seconds";
              }
            }
          }

          // redundancy / application redundancy / group * / control
          container control {
            tailf:info "RG group control interface";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            uses interface-name-grouping;
            leaf protocol {
              tailf:info "RG group protocol media";
              type uint8 {
                tailf:info "<1-8>;;RG protocol instance";
                range "1..8";
              }
            }
          }

          // redundancy / application redundancy / group * / data
          container data {
            tailf:info "RG group data interface";
            uses interface-name-grouping;
          }

          // redundancy / application redundancy / group * / assymetric-routing
          container asymmetric-routing {
            tailf:info "RG asymmetric routing";

            // redundancy / application redundancy / group * / assymetric-routing interface
            container interface {
              tailf:info "RG asymmetric routing interface";
              uses interface-name-grouping;
            }
          }

          // redundancy / application redundancy / group * / track
          container track {
            tailf:info "RG group tracking";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf id {
              tailf:cli-drop-node-name;
              tailf:non-strict-leafref {
                path "../../../../../../track/track-object/object-number";
              }
              type uint16 {
                tailf:info "<1-1000>;;Tracked object number";
                range "1..1000";
              }
            }
            choice action-choice {
              leaf decrement {
                tailf:info "Specify decrement value";
                type uint8 {
                  tailf:info "<1-255>;;decrement value";
                  range "1..255";
                }
              }
              leaf shutdown {
                tailf:info "Shutdown group";
                type empty;
              }
            }
          }
        }
      }
    }

    // redundancy / linecard-group *
    list linecard-group {
      tailf:info "Enter linecard redundancy submode";
      tailf:cli-mode-name "config-red-lc";
      tailf:cli-incomplete-command;
      tailf:cli-recursive-delete;
      key id;
      leaf id {
        type uint32 {
          tailf:info "ID;;linecard-group identifier";
        }
      }
      leaf cable {
        tailf:info "CMTS LC Redundancy type";
        tailf:cli-hide-in-submode;
        tailf:cli-full-command;
        type empty;
      }
      leaf internal-switch {
        tailf:info "Internal Switch Redundancy type";
        tailf:cli-hide-in-submode;
        tailf:cli-full-command;
        type empty;
      }

      // redundancy / linecard-group * / description
      leaf description {
        tailf:info "Assign linecard group description";
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE;;Linecard group description";
        }
      }

      // redundancy / linecard-group * / class
      leaf class {
        tailf:info "assign a class (1:N, 1:1) to this group";
        tailf:cli-full-command;
        type enumeration {
          enum "1:1" {
            tailf:info "One to One Class";
          }
          enum "1:N" {
            tailf:info "One to N Class";
          }
        }
      }

      // redundancy / linecard-group * / reserve cardtype
      container reserve {
        tailf:info "Reserve card type for redundancy group";
        leaf cardtype {
          tailf:info "Reserve card type for redundancy group";
          type string {
            tailf:info "<0-4294967295>;;Enter reserve cardtype in Hex or Decimal";
          }
        }
      }

      // redundancy / linecard-group * / rf-switch
      container rf-switch {
        tailf:info "Specify/Change RF-switch parameters (Optional Command)";
        // redundancy / linecard-group * / rf-switch snmp-community
        leaf snmp-community {
          tailf:info "SNMP community name";
          type string {
            tailf:info "WORD;;snmp community name";
          }
        }
      }

      // redundancy / linecard-group * / member
      container member {
        tailf:info "Add or remove a member from this LC redundancy";

        // redundancy / linecard-group * / member slot *
        list slot {
          tailf:info "slot number to be added or removed from this linecard group";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-incomplete-command;
          key id;
          leaf id {
            tailf:cli-diff-dependency "../../../class";
            type uint8 {
              tailf:info "<0-12>;;primary/secondary slot number";
              range "0..12";
            }
          }
          choice primary-secondary-choice {
            leaf primary {
              tailf:info "primary slot of the linecard group";
              type empty;
            }
            leaf secondary {
              tailf:info "secondary slot of the linecard group";
              tailf:cli-diff-dependency "../../slot/primary";
              type empty;
            }
          }
        }

        // redundancy / linecard-group * / member subslot *
        list subslot {
          tailf:info "subslot number to be added or removed from this linecard group";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          tailf:cli-compact-syntax;
          tailf:cli-suppress-list-no;
          key id;
          leaf id {
            type string {
              tailf:info "<5-8>/<0-1>";
            }
          }
          // redundancy / linecard-group * / member subslot * working
          leaf working {
            tailf:info "working slot in this linecard group";
            type empty;
          }

          // redundancy / linecard-group * / member subslot * protect
          container protect {
            tailf:info "protect slot of this linecard group";
            tailf:cli-display-separated;
            presence true;
            choice config-choice {

              // .. member subslot * protect config ?
              leaf config {
                tailf:info "Specifiy the subslot for cable upstream config";
                tailf:cli-incomplete-no;
                type string {
                  tailf:info "<5-8>/<0-1>;;Slot/Subslot";
                }
              }

              // .. no member subslot * protect config
              container no-config {
                tailf:cli-drop-node-name;
                leaf config {
                  tailf:cli-boolean-no;
                  tailf:cli-full-command;
                  type boolean;
                  default true;
                }
              }
            }
          }
        }
      }

      // redundancy / linecard-group * / revertive
      // redundancy / linecard-group * / no revertive
      leaf revertive {
        tailf:info "Make redundancy relationship revertive";
        tailf:cli-show-no;
        type uint32 {
          tailf:info "<10-86400>;;Seconds to revert.";
        }
      }

      // redundancy / linecard-group * / main-cpu
      container main-cpu {
        tailf:info "Enter main-cpu mode";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-r-lc-mc";
        presence true;
      }

      // redundancy / linecard-group * / standby
      container standby {
        tailf:info "Standby";

        // redundancy / linecard-group * / standby console
        container console {
          tailf:info "Console";
          // redundancy / linecard-group * / standby console enable
          leaf enable {
            tailf:info "Enable";
            type empty;
          }
          // redundancy / linecard-group * / standby console lock
          leaf lock {
            tailf:info "Lock";
            type empty;
          }
        }

        // redundancy / linecard-group * / standby initialization delay
        container initialization {
          tailf:info "Initialization";
          leaf delay {
            tailf:info "Delay";
            type uint16 {
              tailf:info "<30-1800>;;Delay value in seconds";
              range "30..1800";
            }
          }
        }
      }
    }

    // redundancy / main-cpu
    container main-cpu {
      tailf:info "Enter main-cpu mode";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-r-mc";
      presence true;

      // redundancy / main-cpu / auto-sync
      container auto-sync {
        tailf:info "Sync elements";
        leaf running-config {
          type empty;
        }
        leaf config-register {
          type empty;
        }
        leaf bootvar {
          type empty;
        }
        leaf startup-config {
          type empty;
        }
        leaf standard {
          type empty;
        }
      }

      // redundancy / main-cpu / switchover
      container switchover {
        tailf:info "Configuration of switchover";

        // redundancy / main-cpu / switchover pxf restart
        container pxf {
          tailf:info "PXF switchover options";
          container restart {
            tailf:info "PXF restarts";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf number-of-crashes {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint8 {
                tailf:info "<1-25>;;Number of PXF restarts before a switchover";
                range "1..25";
              }
            }
            leaf time-period {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<0-120>;;Interval (in hours) over which restart count is accumulated";
                range "0..120";
              }
            }
          }
        }
      }

      // redundancy / main-cpu / standby
      container standby {
        tailf:info "Standby";

        // redundancy / main-cpu / standby initialization
        container initialization {
          tailf:info "Initialization";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf delay {
            tailf:info "Delay";
            type uint16 {
              tailf:info "<30-1800>;;Delay value in seconds";
              range "30..1800";
            }
          }
          leaf boot-only {
            tailf:info "Delay effective only on system boot";
            type empty;
          }
        }

        // redundancy / main-cpu / standby console
        container console {
          tailf:info "Console";
          // redundancy / main-cpu / standby console enable
          leaf enable {
            tailf:info "Enable";
            type empty;
          }
          // redundancy / main-cpu / standby console lock
          leaf lock {
            tailf:info "Lock";
            type empty;
          }
        }
      }
    }

    // redundancy / interchassis group *
    container interchassis {
      tailf:info "Enter interchassis mode";
      list group {
        tailf:info "Enter the redundancy group number";
        tailf:cli-mode-name "conppfig-r-ic";
        key id;
        leaf id {
          type uint32 {
            tailf:info "<1-4294967295>;;The redundancy group number";
            range "1..4294967295";
          }
        }

        // redundancy / interchassis group * / member ip
        container member {
          tailf:info "specify a redundancy group member";
          leaf ip {
            tailf:info "specify the redundancy group member using an ip address";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;the ip address of the remote redundancy group member";
            }
          }
        }

        // redundancy / interchassis group * / mlacp
        container mlacp {
          tailf:info "mLACP interchassis redundancy group subcommands";
          // redundancy / interchassis group * / mlacp system-mac
          leaf system-mac {
            tailf:info "mLACP redundancy group mac address";
            type string {
              tailf:info "H.H.H;;mLACP redundancy group mac address";
            }
          }
          // redundancy / interchassis group * / mlacp system-priority
          leaf system-priority {
            tailf:info "mLACP system priority";
            type uint16 {
              tailf:info "<0-65535>;;Priority value";
            }
          }
          // redundancy / interchassis group * / mlacp node-id
          leaf node-id {
            tailf:info "mLACP node-id, appended to LACP port ids";
            type uint8 {
              tailf:info "<0-7>;;mLACP node-id";
              range "0..7";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// mdns-sd
  /// ========================================================================

  container mdns-sd {
    tailf:info "mDNS Service Discovery Gateway Configuration";

    // mdns-sd service-list *
    list service-list {
      tailf:info "mDNS Service List";
      tailf:cli-mode-name "config-mdns-sl";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;mDNS Service List Name";
        }
      }
      leaf direction {
        tailf:cli-drop-node-name;
        tailf:cli-hide-in-submode;
        type enumeration {
          enum IN {
            tailf:info "IN Bound Filtering";
          }
          enum OUT {
            tailf:info "Out Bound Filtering";
          }
        }
      }

      // mdns-sd service-list * / match *
      list match {
        tailf:info "Specify service to match";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;service name";
          }
        }
      }
    }

    // mdns-sd service-policy *
    list service-policy {
      tailf:info "mDNS Service Policy";
      tailf:cli-mode-name "config-mdns-ser-pol";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;mDNS Service Policy Name";
        }
      }

      // mdns-sd service-policy * / service-list * IN|OUT
      list service-list {
        tailf:info "mDNS Service List";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-diff-dependency "../../service-list";
        key direction;
        leaf direction {
          type enumeration {
            enum IN {
               tailf:info "Apply Service List in IN Bound Direction";
            }
            enum OUT {
               tailf:info "Apply Service List in Out Bound Direction";
            }
          }
        }
        leaf name {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          tailf:cli-remove-before-change;
          type string {
            tailf:info "WORD;;mDNS Service List Name";
          }
        }
      }
    }

    // mdns-sd service-definition *
    list service-definition {
      tailf:info "mDNS Service Definition";
      tailf:cli-mode-name "config-mdns-ser-def";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;mDNS Service Definition Name";
        }
      }

      // mdns-sd service-definition * / description
      uses description-grouping;

      // mdns-sd service-definition * / service-type
      leaf service-type {
        tailf:info "Specify Service-Type String";
        type string {
          tailf:info "LINE;;Service Type String";
        }
      }
    }
  }


  /// ========================================================================
  /// bfd
  /// ========================================================================

  container bfd {
    tailf:info "BFD configuration commands";

    // bfd map
    container map {
      tailf:info "configure bfd map entry for multi-hop sessions";

      // bfd map ipv4
      container ipv4 {
        tailf:info "IPv4 Address Family";

        // bfd map ipv4 *
        list list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key "destination source";
          leaf destination {
            type ios:ipv4-prefix {
              tailf:info "A.B.C.D/nn;;Destination IP prefix/len";
            }
          }
          leaf source {
            type ios:ipv4-prefix {
              tailf:info "A.B.C.D/nn;;Source IP prefix/len";
            }
          }
          leaf bfd-template {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;bfd template name";
            }
          }
        }

        // bfd map ipv4 vrf *
        list vrf {
          tailf:info "Destination VRF name";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key "name destination source";
          leaf name {
            type string {
              tailf:info "WORD;;Destination VRF instance name";
            }
          }
          leaf destination {
            type ios:ipv4-prefix {
              tailf:info "A.B.C.D/nn;;Destination IP prefix/len";
            }
          }
          leaf source {
            type ios:ipv4-prefix {
              tailf:info "A.B.C.D/nn;;Source IP prefix/len";
            }
          }
          leaf bfd-template {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;bfd template name";
            }
          }
        }
      }
    }

    // bfd snmp traps more
    container snmp {
      tailf:info "Provides snmp ralated information that are specific to BFD";
      container traps {
        tailf:info "Provides traps related information";
        leaf more {
          tailf:info "Provides additional varbind along with the traps";
          type empty;
        }
      }
    }

    // bfd fast-timers-on-slow-interface
    leaf fast-timers-on-slow-interface {
      tailf:info "Allow fast timers on slow interfaces";
      type empty;
    }

    // bfd slow-timers
    leaf slow-timers {
      tailf:info "Change slow timers used by BFD";
      type uint16 {
        tailf:info "<1000-30000>;;Value in ms to use for slow timers";
        range "1000..30000";
      }
    }
  }


  /// ========================================================================
  /// bfd-template
  /// ========================================================================

  container bfd-template {
    tailf:info "BFD template configuration";
    tailf:cli-diff-delete-before "../bfd/map";

    // bfd-template single-hop *
    list single-hop {
      tailf:info "Single-hop template";
      tailf:cli-mode-name "config-bfd";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;BFD template name";
        }
      }
      uses bfd-template-grouping;
    }

    // bfd-template multi-hop *
    list multi-hop {
      tailf:info "Multi-hop template";
      tailf:cli-mode-name "config-bfd";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;BFD template name";
        }
      }
      uses bfd-template-grouping;
    }
  }


  /// ========================================================================
  /// process-max-time
  /// ========================================================================

  leaf process-max-time {
    tailf:info "Maximum time for process to run before voluntarily relinquishing processor";
    type uint8 {
      tailf:info "<20-200>;;The number of millisecs before voluntary suspend. Default 50";
      range "20..200";
    }
    default 50;
  }

  /// ========================================================================
  /// map-class
  /// ========================================================================

  container map-class {
    tailf:info "Configure static map class";

    // map-class frame-relay *
    list frame-relay {
      tailf:info "Frame Relay";
      tailf:cli-mode-name "config-map-class";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Static map class name";
        }
      }

      // map-class frame-relay * / frame-relay
      container frame-relay {
        tailf:info "Configure Map parameters";

        // map-class frame-relay * / frame-relay min-cir
        leaf cir {
          tailf:info "Committed Information Rate (CIR), Default = 56000bps";
          type uint32 {
            tailf:info "<1-45000000>;;Applied to both Incoming/Outgoing CIR, Bits per second";
            range "1..45000000";
          }
        }

        // map-class frame-relay * / frame-relay min-cir
        leaf mincir {
          tailf:info "Minimum acceptable CIR, Default = CIR/2 bps";
          type uint32 {
            tailf:info "<1000-45000000>;;Applied to both Incoming/Outgoing CIR, Bits per second";
            range "1000..45000000";
          }
        }

        // map-class frame-relay * / frame-relay fragment
        leaf fragment {
          tailf:info "Requires Frame Relay traffic-shaping to be configured at the interface level";
          type uint16 {
            tailf:info "<16-1600>;;Define fragment size, Bytes";
            range "16..1600";
          }
        }

        // map-class frame-relay * / frame-relay bc
        container bc {
          tailf:info "Committed burst size (Bc), Default = 56000 bits";
          leaf value {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<300-16000000>;;Applied to both Incoming/Outgoing Bc, Bits";
              range "300..16000000";
            }
          }
        }

        // map-class frame-relay * / frame-relay be
        container be {
          tailf:info "Excess burst size (Be), Default = 0 bits";
          leaf value {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<0-16000000>;;Applied to both Incoming/Outgoing Be, Bits";
              range "0..16000000";
            }
          }
        }

        // map-class frame-relay * / fair-queue
        container fair-queue {
          presence true;
        }
      }

      // map-class frame-relay * / service-policy
      container service-policy {
        tailf:info "class-based service policy";
        uses service-policy-grouping;
      }
    }
  }


  /// ========================================================================
  /// class
  /// ========================================================================

  container class {
    tailf:info "Configure cem class parameters";

    // class cem *
    list cem {
      tailf:info "Circuit emulation template";
      tailf:cli-mode-name "config-cem-class";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;cem class name";
        }
      }

      // class cem * / payload-size
      leaf payload-size {
        tailf:info "IP payload size in bytes";
        type uint16 {
          tailf:info "<32-1312>;;IP payload size";
          range "32..1312";
        }
      }

      // class cem * / dejitter-buffer
      leaf dejitter-buffer {
        tailf:info "dejitter in ms";
        type uint16 {
          tailf:info "<1-500>;;1-500ms";
          range "1..500";
        }
      }

      // class cem * / idle-pattern
      leaf idle-pattern {
        tailf:info "Set 8 bit idle pattern";
        type string {
          tailf:info "<0x0-0xFF>;;8 bit hex number";
        }
      }
    }
  }


  /// ========================================================================
  /// redirect
  /// ========================================================================

  container redirect {
    tailf:info "Configure L4 redirect parameters";

    /// redirect server-group *
    list server-group {
      tailf:info "Server group information";
      tailf:cli-mode-name "config-sg-l4redirect-group";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Name of the group to configure";
        }
      }

      /// redirect server-group * / server ip * port *
      list server {
        tailf:info "Add a server to the group";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "ip port";
        leaf ip {
          tailf:cli-expose-key-name;
          tailf:info "Server IP address";
          type union {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IPv4 address";
            }
            type inet:ipv6-address {
              tailf:info "X:X:X:X::X;;IPv6 address";
            }
          }
        }
        leaf port {
          tailf:cli-expose-key-name;
          tailf:info "Port on which the server listens. NOTE: Set to 0 for no port";
          type uint16 {
            tailf:info "<0|1-65535>;;Port of the new server, 0 = no port specified";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// class-map
  /// ========================================================================

  list class-map {
    tailf:info "Configure QoS Class Map";
    tailf:cli-mode-name "config-cmap";
    tailf:cli-no-key-completion;
    tailf:cli-compact-syntax;
    tailf:cli-sequence-commands;
    tailf:cli-full-command;
    tailf:cli-diff-dependency "../mls";

    // class-map *
    key name;
    leaf name {
      tailf:cli-disallow-value "type|match-any|match-all";
      type string {
        tailf:info "WORD;;class-map name";
      }
    }

    // class-map type *
    leaf type {
      tailf:info "type of the class-map";
      tailf:cli-optional-in-sequence;
      tailf:cli-prefix-key;
      tailf:cli-incomplete-command;
      type enumeration {
        enum access-control {
          tailf:info "access-control specific class-map";
        }
        enum inspect {
          tailf:info "Configure Firewall Class Map";
        }
        enum logging {
          tailf:info "Class map for control-plane packet logging";
        }
        enum port-filter {
          tailf:info "Class map for port filter";
        }
        enum queue-threshold {
          tailf:info "Class map for queue threshold";
        }
        enum stack {
          tailf:info "class-map for protocol header stack specification";
        }
        enum appnav {
          tailf:info "Configure a APPNAV Class Map";
        }
        enum multicast-flows {
          tailf:info "multicast class-maps";
        }
      }
    }

    // class-map <protocol>
    leaf protocol {
      when "(../type) and (../type = 'inspect')" {
        tailf:dependency "../type";
      }
      tailf:cli-drop-node-name;
      tailf:cli-prefix-key;
      tailf:cli-optional-in-sequence;
      tailf:cli-incomplete-command;
      type enumeration {
        enum aol {
          tailf:info "Configure CBAC class-map for IM-AOL protocol";
        }
        enum edonkey {
          tailf:info "eDonkey";
        }
        enum fasttrack {
          tailf:info "FastTrack Traffic - KaZaA, Morpheus, Grokster...";
        }
        enum gnutella {
          tailf:info "Gnutella Version2 Traffic - BearShare, Shareeza, Morpheus ...";
        }
        enum http {
          tailf:info "Configure CBAC class-map for HTTP protocol";
        }
        enum imap {
          tailf:info "Configure CBAC class-map for IMAP protocol";
        }
        enum kazaa2 {
          tailf:info "Kazaa Version 2";
        }
        enum msnmsgr {
          tailf:info "Configure CBAC class-map for IM-MSN protocol";
        }
        enum pop3 {
          tailf:info "Configure CBAC class-map for POP3 protocol";
        }
        enum smtp {
          tailf:info "Configure CBAC class-map for SMTP protocol";
        }
        enum sunrpc {
          tailf:info "Configure CBAC class-map for RPC protocol";
        }
        enum ymsgr {
          tailf:info "Configure CBAC class-map for IM-YAHOO protocol";
        }
      }
    }

    // class-map * <match-any|match-all>
    leaf prematch {
      tailf:cli-drop-node-name;
      tailf:cli-no-keyword;
      tailf:cli-prefix-key;
      type enumeration {
        enum match-all {
          tailf:info "Logical-AND all matching statements under this classmap";
        }
        enum match-any {
          tailf:info "Logical-OR all matching statements under this classmap";
        }
      }
    }

    // class-map * / description
    leaf description {
      tailf:info "Class-Map description";
      tailf:cli-break-sequence-commands;
      tailf:cli-multi-value;
      tailf:cli-preformatted;
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;Description of this class-map (up to 200 characters)";
      }
    }

    // class-map * / match
    container match {
      tailf:info "classification criteria";
      uses class-map-match-grouping;
      container not {
        tailf:info "Negate this match result";
        uses class-map-match-grouping;
      }
    }
  }


  /// ========================================================================
  /// class-map type multicast-flows
  /// ========================================================================

  // class-map type multicast-flows *
  container class-map-multicast-flows {
    tailf:cli-drop-node-name;
    list class-map {
      tailf:info "Configure QoS Class Map";
      tailf:cli-mode-name "config-mcast-flows-cmap";
      tailf:cli-suppress-list-no;
      tailf:cli-no-key-completion;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-full-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;class-map name";
        }
      }
      // class-map type multicast-flows *
      leaf type {
        tailf:info "type of the policy-map";
        tailf:cli-prefix-key;
        type enumeration {
          enum multicast-flows {
            tailf:info "multicast class-maps";
          }
        }
      }

      // class-map type multicast-flows * / group
      container group {
        tailf:info "Multicast group range begin";

        // class-map type multicast-flows * / group * source *
        list list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key "address source";
          leaf address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Multicast group address";
            }
          }
          leaf source {
            tailf:info "channel-source";
            tailf:cli-expose-key-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;channel-source address";
            }
          }
        }

        // class-map type multicast-flows * / group * to * source *
        list list-range {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key "address to source";
          leaf address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Multicast group address";
            }
          }
          leaf to {
            tailf:info "Multicast group range end";
            tailf:cli-expose-key-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Multicast group address";
            }
          }
          leaf source {
            tailf:info "channel-source";
            tailf:cli-expose-key-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;channel-source address";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// class-map type control
  /// ========================================================================

  // class-map type control *
  container class-map-control {
    tailf:cli-drop-node-name;
    list class-map {
      tailf:info "Configure QoS Class Map";
      tailf:cli-mode-name "config-control-classmap";
      tailf:cli-suppress-list-no;
      tailf:cli-no-key-completion;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-full-command;
      key name;
      leaf name {
        tailf:cli-disallow-value "subscriber";
        type string {
          tailf:info "WORD;;class-map name";
        }
      }
      // class-map type control *
      leaf type {
        tailf:info "type of the policy-map";
        tailf:cli-prefix-key;
        type enumeration {
          enum control {
            tailf:info "Configure control policies";
          }
        }
      }
      leaf prematch {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        type enumeration {
          enum match-all {
            tailf:info "TRUE if everything matches in the class-map";
          }
          enum match-any {
            tailf:info "TRUE if anything matches in the class-map";
          }
          enum match-none {
            tailf:info "TRUE if nothing matches in the class-map";
          }
        }
      }

      // class-map type control * / match
      container match {
        tailf:info "match filter";

        // class-map type control * / match authen-status
        leaf authen-status {
          tailf:info "Subscriber authentication status";
          type enumeration {
            enum authenticated {
              tailf:info "Authenticated";
            }
            enum unauthenticated {
              tailf:info "Unauthenticated";
            }
          }
        }

        // class-map type control * / match timer
        leaf timer {
          tailf:info "Timer name";
          type string {
            tailf:info "WORD;;string";
          }
        }

        // class-map type control * / match service-name
        leaf service-name {
          tailf:info "Service name currently associated with user";
          type string {
            tailf:info "WORD;;string";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// class-map type control subscriber
  /// ========================================================================

  // class-map type control subscriber *
  container class-map-filter-control {
    tailf:cli-drop-node-name;
    list class-map {
      tailf:info "Configure QoS Class Map";
      tailf:cli-mode-name "config-filter-control-classmap";
      tailf:cli-suppress-list-no;
      tailf:cli-no-key-completion;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-full-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;class-map name";
        }
      }
      // class-map type control subscriber *
      leaf type {
        tailf:info "type of the policy-map";
        tailf:cli-prefix-key;
        type enumeration {
          enum control {
            tailf:info "Configure control policies";
          }
        }
      }
      leaf domain {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        type enumeration {
          enum subscriber {
            tailf:info "Domain name of the class map";
          }
        }
      }
      leaf prematch {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        type enumeration {
          enum match-all {
            tailf:info "TRUE if everything matches in the class-map";
          }
          enum match-any {
            tailf:info "TRUE if anything matches in the class-map";
          }
          enum match-none {
            tailf:info "TRUE if nothing matches in the class-map";
          }
        }
      }

      // class-map type control subscriber * / match
      container match {
        tailf:info "match filter";

        // class-map type control subscriber * / match method
        container method {
          tailf:info "match the type of authentication method from an event";
          // class-map type control subscriber * / match method webauth
          leaf webauth {
            tailf:info "webauth";
            type empty;
          }
          // class-map type control subscriber * / match method mab
          leaf mab {
            tailf:info "mab";
            type empty;
          }
          // class-map type control subscriber * match method dot1x
          leaf dot1x {
            tailf:info "dot1x";
            type empty;
          }
        }

        // class-map type control subscriber * / match result-type
        container result-type {
          tailf:info "match the result type, optionally for a specific method";

          // class-map type control subscriber * / match result-type method
          container method {
            tailf:info "match the result of a particular method";

            // class-map type control subscriber * / match result-type method mab
            container dot1x {
              tailf:info "dot1x result";
              uses result-type-method-grouping;
            }

            // class-map type control subscriber * / match result-type method mab
            container mab {
              tailf:info "mab result";
              uses result-type-method-grouping;
            }

            // class-map type control subscriber * / match result-type method webauth
            container webauth {
              tailf:info "webauth result";
              uses result-type-method-grouping;
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// class-map type traffic
  /// ========================================================================

  // class-map type traffic *
  container class-map-traffic {
    tailf:cli-drop-node-name;
    list class-map {
      tailf:info "Configure QoS Class Map";
      tailf:cli-mode-name "config-traffic-classmap";
      tailf:cli-suppress-list-no;
      tailf:cli-no-key-completion;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-full-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;class-map name";
        }
      }
      leaf type {
        tailf:info "type of the policy-map";
        tailf:cli-prefix-key;
        type enumeration {
          enum traffic {
            tailf:info "Configure a subscriber policy traffic classmap";
          }
        }
      }
      leaf prematch {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        type enumeration {
          enum match-any {
            tailf:info "TRUE if anything matches in the traffic class-map";
          }
        }
      }

      // class-map type traffic * / match access-group
      container match {
        tailf:info "Configure traffic class parameters";
        container access-group {
          tailf:info "Access List specifying the traffic class";

          // class-map type traffic * / match access-group input
          container input {
            tailf:info "Configure input traffic class parameters";
            choice access-list-choice {
              leaf name {
                tailf:info "Access List name";
                type string {
                  tailf:info "WORD;;Access List name";
                }
              }
              leaf index {
                tailf:cli-drop-node-name;
                type uint32 {
                  tailf:info "<1-2799>;;Access List number";
                  range "1..2799";
                }
              }
            }
          }

          // class-map type traffic * / match access-group output
          container output {
            tailf:info "Configure ouput traffic class parameters";
            choice access-list-choice {
              leaf name {
                tailf:info "Access List name";
                type string {
                  tailf:info "WORD;;Access List name";
                }
              }
              leaf index {
                tailf:cli-drop-node-name;
                type uint32 {
                  tailf:info "<1-2799>;;Access List number";
                  range "1..2799";
                }
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// policy-map
  /// ========================================================================

  list policy-map {
    tailf:info "Configure QoS Policy Map";
    tailf:cli-mode-name "config-pmap";

    // When deleting policy-map, delete before this:
    tailf:cli-diff-dependency "../mls/qos/aggregate-policer";
    tailf:cli-diff-dependency "../policer/aggregate";
    tailf:cli-diff-dependency "../table-map";
    tailf:cli-diff-dependency "../tailfned/police";

    // When deleting policy-map, delete after this:
    tailf:cli-diff-delete-after "../interface/GigabitEthernet/service-policy" {
      tailf:cli-when-target-delete;
    }

    key name;
    leaf name {
      tailf:cli-disallow-value "(type)|(http)|(im)|(imap)|(p2p)|(pop3)|(smtp)|(sunrpc)";
      type string {
        tailf:info "WORD;;policy-map name";
      }
    }

    // policy-map type *
    leaf type {
      tailf:info "type of the policy-map";
      tailf:cli-prefix-key;
      type enumeration {
        enum inspect {
          tailf:info "Configure Firewall Policy Map";
        }
        enum performance-monitor {
          tailf:info "Performance monitoring policy-map type";
        }
        enum mace {
          tailf:info "Configure MACE Policy Map";
        }
        enum packet-service {
          tailf:info "Configure Packet Service Policy Map";
        }
        enum appnav {
          tailf:info "Configure a APPNAV Policy Map";
        }
      }
    }

    leaf protocol {
      tailf:cli-drop-node-name;
      tailf:cli-prefix-key;
      type enumeration {
        enum http {
          tailf:info "Configure CBAC policy-map for HTTP protocol";
        }
        enum im {
          tailf:info "Configure CBAC policy-map for IM protocol";
        }
        enum imap {
          tailf:info "Configure CBAC policy-map for IMAP protocol";
        }
        enum p2p {
          tailf:info "Configure CBAC policy-map for P2P protocols";
        }
        enum pop3 {
          tailf:info "Configure CBAC policy-map for POP3 protocol";
        }
        enum smtp {
          tailf:info "Configure CBAC policy-map for SMTP protocol";
        }
        enum sunrpc {
          tailf:info "Configure CBAC policy-map for RPC protocol";
        }
      }
    }

    // policy-map * / description
    leaf description {
      tailf:info "Policy-Map description";
      tailf:cli-multi-value;
      tailf:cli-preformatted;
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;Description of this policy-map (up to 200 characters)";
        length "1..200";
      }
    }

    // policy-map * / class *
    list class {
      tailf:info "policy criteria";
      tailf:cli-mode-name "config-pmap-c";
      tailf:cli-show-long-obu-diffs;
      tailf:cli-diff-dependency "../../class-map";
      tailf:cli-diff-dependency "../../class-map-filter-control/class-map";
      tailf:cli-diff-dependency "../../class-map-traffic/class-map";
      tailf:cli-diff-delete-after "../../interface/GigabitEthernet/service-policy" {
        tailf:cli-when-target-delete;
      }

      ordered-by user;
      key name;

      // policy-map * / class type inspect *
      leaf type {
        tailf:info "type of the class-map";
        tailf:cli-prefix-key;
        type enumeration {
          enum inspect {
            tailf:info "Configure CBAC Class Map";
          }
        }
      }
      // policy-map * / class *
      leaf name {
        tailf:cli-disallow-value "type|class-default";
        tailf:non-strict-leafref {
          path "../../../class-map/name";
        }
        type string {
          tailf:info "WORD;;class-map name";
        }
      }
      uses policy-map-class-grouping {
        refine "bandwidth/bits" {
          tailf:cli-diff-dependency "../../../class-default/class/bandwidth/bits" {
            tailf:cli-trigger-on-set;
          }
        }
      }
    }

    // policy-map * / class class-default
    container class-default {
      tailf:cli-drop-node-name;
      list class {
        tailf:info "policy criteria";
        tailf:cli-mode-name "config-pmap-c";
        key name;
        leaf name {
          type enumeration {
            enum class-default {
              tailf:info "System default class matching otherwise unclassified packets";
            }
          }
        }
        uses policy-map-class-grouping;
      }
    }
  }


  /// ========================================================================
  /// policy-map type service
  /// ========================================================================

  // policy-map type service *
  container policy-map-service {
    tailf:cli-drop-node-name;
    list policy-map {
      tailf:info "Configure QoS Policy Map";
      tailf:cli-mode-name "config-service-policymap";
      tailf:cli-sequence-commands;
      key name;
      leaf name {
        tailf:cli-disallow-value "type";
        tailf:cli-diff-dependency "../../../class-map";
        type string {
          tailf:info "WORD;;policy-map name";
        }
      }
      leaf type {
        tailf:info "type of the policy-map";
        tailf:cli-prefix-key;
        type enumeration {
          enum service {
            tailf:info "policymap service configuration";
          }
        }
      }

      // policy-map type service * / keepalive
      container keepalive {
        tailf:cli-break-sequence-commands;
        tailf:info "keepalive for IP subscriber session";
        tailf:cli-compact-syntax;
        leaf idle {
          tailf:info "idle period before checking subscriber (in sec, default = 35 seconds)";
          type uint32 {
            tailf:info "<31-2147483647>;;idle period before checking subscriber (in sec, default = 35 seconds)";
            range "31..2147483647";
          }
          default 35;
        }
        leaf attempts {
          tailf:info "maximum attempts of keepalive before failing (default = 5)";
          type uint8 {
            tailf:info "<3-10>;;maximum attempts of keepalive before failing (default = 5)";
            range "3..10";
          }
          default 5;
        }
        leaf interval {
          tailf:info "duration for successive keepalive requests (in sec, default = 1 seconds)";
          type uint8 {
            tailf:info "<1-60>;;duration for successive keepalive requests (in sec, default = 1 seconds)";
            range "1..60";
          }
          default 1;
        }
        leaf protocol {
          tailf:info "configure the protocol for keepalive request/response";
          type enumeration {
            enum ARP {
              tailf:info "use ARP for keepalive request/response";
            }
            enum ICMP {
              tailf:info "use ICMP for keepalive request/response";
            }
          }
        }
      }

      // policy-map type service * / * class type traffic
      list class-list {
        tailf:cli-drop-node-name;
        tailf:cli-mode-name "config-service-policymap-class-traffic";
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          type uint16 {
            tailf:info "<0-1000>;;priority number";
            range "0..1000";
          }
        }
        leaf class {
          tailf:info "Specify a class-map to match against for this policy-map";
          tailf:cli-hide-in-submode;
          tailf:cli-incomplete-command;
          type empty;
        }
        leaf type {
          tailf:info "Specify a typed class-map";
          tailf:cli-hide-in-submode;
          tailf:cli-incomplete-command;
          type enumeration {
            enum traffic {
              tailf:info "Specify a traffic class-map";
            }
          }
        }
        leaf name {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          tailf:cli-diff-dependency "../../../../class-map-traffic/class-map";
          type string {
            tailf:info "WORD;;name of class-map to reference";
          }
        }

        // policy-map type service * / * class type traffic / redirect to
        container redirect {
          tailf:cli-break-sequence-commands;
          tailf:info "Redirect rules";
          container to {
            tailf:info "Group or server to redirect to";
            leaf group {
              tailf:info "Group name for redirection";
              tailf:non-strict-leafref {
                path "/ios:redirect/server-group/name";
              }
              type string {
                tailf:info "WORD;;Server group name";
              }
            }
          }
        }
      }

      // policy-map type service * / class type traffic *
      container class-name {
        tailf:cli-drop-node-name;
        list class {
          tailf:info "Specify a class-map to match against for this policy-map";
          tailf:cli-mode-name "config-service-policymap-class-traffic";
          tailf:cli-show-long-obu-diffs;
          tailf:cli-diff-dependency "../../../../class-map-traffic/class-map";
          ordered-by user;
          key name;
          leaf type {
            tailf:info "Specify a typed class-map";
            tailf:cli-prefix-key;
            type enumeration {
              enum traffic {
                tailf:info "Specify a traffic class-map";
              }
            }
          }
          leaf name {
            tailf:cli-disallow-value "type|default";
            tailf:non-strict-leafref {
              path "../../../../../class-map-traffic/class-map/name";
            }
            type string {
              tailf:info "WORD;;class-map name";
            }
          }

          // policy-map type service * / class type traffic * / timeout
          container timeout {
            tailf:info "Timeout parameters";

            // policy-map * / class type traffic * / timeout idle
            leaf idle {
              tailf:info "Idle timeout for the session";
              type uint32 {
                tailf:info "<30-15552000>;;Idle timeout value in seconds";
                range "30..15552000";
              }
            }

            // policy-map * / class type traffic * / timeout absolute
            leaf absolute {
              tailf:info "Absolute timeout for the session";
              type uint32 {
                tailf:info "<0-31104000>;;Absolute timeout value in seconds";
                range "0..31104000";
              }
            }
          }

          // policy-map type service * / class type traffic * / accounting aaa list
          container accounting {
            tailf:info "Configure accounting parameters";
            container aaa {
              tailf:info "Configure accounting aaa parameters";
              leaf list {
                tailf:info "Configure accounting method-list";
                tailf:cli-diff-dependency "/ios:aaa/accounting/network/name";
                type string {
                  tailf:info "WORD;;AAA method-list name";
                }
              }
            }
          }
        }
      }

      // policy-map type service * / class type traffic default
      container class-default {
        tailf:cli-drop-node-name;
        list class {
          tailf:info "Specify a class-map to match against for this policy-map";
          tailf:cli-mode-name "config-service-policymap-class-traffic";
          tailf:cli-incomplete-command;
          key name;
          leaf type {
            tailf:info "Specify a typed class-map";
            tailf:cli-prefix-key;
            type enumeration {
              enum traffic {
                tailf:info "Specify a traffic class-map";
              }
            }
          }
          leaf name {
            tailf:cli-disallow-value "type";
            type enumeration {
              enum default {
                tailf:info "Default actions";
              }
            }
          }
          leaf direction {
            tailf:cli-drop-node-name;
            tailf:cli-hide-in-submode;
            type enumeration {
              enum in-out {
                tailf:info "Specify both input and output directions for drop";
              }
              enum input {
                tailf:info "Specify input direction for drop";
              }
              enum output {
                tailf:info "Specify output direction for drop";
              }
            }
          }

          // policy-map type service * / class type traffic default / drop
          leaf drop {
            tailf:info "action drop";
            type empty;
          }
        }
      }
    }
  }


  /// ========================================================================
  /// policy-map type control
  /// ========================================================================

  // policy-map type control *
  container policy-map-control {
    tailf:cli-drop-node-name;
    list policy-map {
      tailf:info "Configure QoS Policy Map";
      tailf:cli-mode-name "config-control-policymap";
      tailf:cli-sequence-commands;
      key name;
      leaf name {
        tailf:cli-disallow-value "type|subscriber";
        tailf:cli-diff-dependency "../../../class-map";
        tailf:cli-diff-dependency "../../../class-map-filter-control/class-map";
        type string {
          tailf:info "WORD;;policy-map name";
        }
      }
      leaf type {
        tailf:info "type of the policy-map";
        tailf:cli-prefix-key;
        type enumeration {
          enum control {
            tailf:info "Configure control policies";
          }
        }
      }

      // policy-map type control * / class type control *
      container class-name {
        tailf:cli-break-sequence-commands;
        tailf:cli-drop-node-name;
        list class {
          tailf:info "Specify a control class-map to match against for this policy-map";
          tailf:cli-mode-name "config-control-policymap-class-control";
          tailf:cli-sequence-commands;
          key name;
          leaf type {
            tailf:info "Specify a class-map type";
            tailf:cli-prefix-key;
            type enumeration {
              enum control {
                tailf:info "Specify a control class-map";
              }
            }
          }
          leaf name {
            tailf:cli-disallow-value "always";
            tailf:non-strict-leafref {
              path "/ios:class-map-control/class-map/name";
            }
            type string {
              tailf:info "WORD;;name of control class-map to reference";
            }
          }

          leaf event {
            tailf:info "The event type this control class-map triggers upon";
            tailf:cli-hide-in-submode;
            type pm-class-type-control-event-type;
          }

          uses policy-map-type-control-class-grouping;
        }
      }

      // policy-map type control * / class type control always
      container class-always {
        tailf:cli-drop-node-name;
        list class {
          tailf:info "Specify a control class-map to match against for this policy-map";
          tailf:cli-mode-name "config-control-policymap-class-control";
          tailf:cli-sequence-commands;
          key "name event";
          leaf type {
            tailf:info "Specify a class-map type";
            tailf:cli-prefix-key;
            type enumeration {
              enum control {
                tailf:info "Specify a control class-map";
              }
            }
          }
          leaf name {
            type enumeration {
              enum always {
                tailf:info "This control class-map always matches";
              }
            }
          }
          leaf event {
            tailf:info "The event type this control class-map triggers upon";
            tailf:cli-expose-key-name;
            type pm-class-type-control-event-type;
          }

          uses policy-map-type-control-class-grouping;
        }
      }
    }
  }


  /// ========================================================================
  /// policy-map type control subscriber
  /// ========================================================================

  // policy-map type control subscriber *
  container policy-map-event-control {
    tailf:cli-drop-node-name;
    list policy-map {
      tailf:info "Configure QoS Policy Map";
      tailf:cli-mode-name "config-event-control-policymap";
      tailf:cli-sequence-commands;
      key name;
      leaf name {
        tailf:cli-disallow-value "type";
        tailf:cli-diff-dependency "../../../class-map";
        tailf:cli-diff-dependency "../../../class-map-filter-control/class-map";
        type string {
          tailf:info "WORD;;policy-map name";
        }
      }
      /// policy-map type control subscriber *
      leaf type {
        tailf:info "type of the policy-map";
        tailf:cli-prefix-key;
        type enumeration {
          enum control {
            tailf:info "Configure control policies";
          }
        }
      }
      leaf domain {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        type enumeration {
          enum subscriber {
            tailf:info "subscriber control policy domain";
          }
        }
      }

      // policy-map * / event *
      list event {
        tailf:info "The event type this control class-map triggers upon";
        tailf:cli-mode-name "config-class-control-policymap";
        tailf:cli-show-long-obu-diffs;
        ordered-by user;
        key "name match";
        leaf name {
          tailf:cli-suppress-range;
          type enumeration {
            enum aaa-available {
              tailf:info "aaa-available event";
            }
            enum absolute-timeout {
              tailf:info "absolute timeout event";
            }
            enum agent-found {
              tailf:info "agent found event";
            }
            enum authentication-failure {
              tailf:info "authentication failure event";
            }
            enum authentication-success {
              tailf:info "authentication success event";
            }
            enum authorization-failure {
              tailf:info "authorization failure event";
            }
            enum authorization-success {
              tailf:info "authorization success event";
            }
            enum identity-update {
              tailf:info "identity update event";
            }
            enum inactivity-timeout {
              tailf:info "inactivity timeout event";
            }
            enum remote-authentication-failure {
              tailf:info "authentication failure event";
            }
            enum remote-authentication-success {
              tailf:info "authentication remote success event";
            }
            enum session-disconnected {
              tailf:info "session disconnected event";
            }
            enum session-started {
              tailf:info "session started event";
            }
            enum tag-added {
              tailf:info "tag to apply event";
            }
            enum tag-removed {
              tailf:info "tag to remove event";
            }
            enum template-activated {
              tailf:info "template activated event";
            }
            enum template-activation-failed {
              tailf:info "template activation failed event";
            }
            enum template-deactivated {
              tailf:info "template deactivated event";
            }
            enum template-deactivation-failed {
              tailf:info "template deactivation failed event";
            }
            enum timer-expiry {
              tailf:info "timer-expiry event";
            }
            enum violation {
              tailf:info "session violation event";
            }
          }
        }
        leaf match {
          tailf:key-default "match-all";
          type enumeration {
            enum match-all {
              tailf:info "Evaluate all the classes";
            }
            enum match-first {
              tailf:info "Evaluate the first class";
            }
          }
        }

        // policy-map * / event * / * class
        list class-list {
          tailf:cli-drop-node-name;
          tailf:cli-mode-name "config-class-control-policymap";
          tailf:cli-incomplete-command;
          key id;
          leaf id {
            type uint8 {
              tailf:info "<1-254>;;class number, 1 for 1st class, 2 for 2nd...";
            }
          }
          leaf class {
            tailf:info "The class type this control policy-map triggers upon";
            tailf:cli-hide-in-submode;
            type union {
              type string {
                tailf:info "WORD;;Name of control class-map to reference";
              }
              type enumeration {
                enum always {
                  tailf:info "This control class-map always matches";
                }
              }
            }
          }
          leaf execute {
            tailf:cli-drop-node-name;
            tailf:cli-hide-in-submode;
            type enumeration {
              enum do-all {
                tailf:info "Execute all the actions";
              }
              enum do-until-failure {
                tailf:info "Execute actions until one of them fails";
              }
              enum do-until-success {
                tailf:info "Execute actions until one of them is successful";
              }
            }
          }

          // policy-map * / event * / * class / *
          list action-list {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            tailf:cli-incomplete-command;
            key id;
            leaf id {
              type uint8 {
                tailf:info "<1-254>;;action number, 1 for 1st action, 2 for 2nd...";
              }
            }
            leaf action {
              tailf:cli-drop-node-name;
              type enumeration {
                enum activate {
                  tailf:info "activate template or policy ";
                }
                enum authenticate {
                  tailf:info "authenticate a session";
                }
                enum authentication-restart {
                }
                enum authorize {
                  tailf:info "authorize session";
                }
                enum notify {
                  tailf:info "notifies the session attributes";
                }
                enum set-domain {
                  tailf:info "set domain";
                }
                enum set-timer {
                  tailf:info "set abs timer to pop N seconds from now";
                }
                enum unauthorize {
                  tailf:info "unauthorize session";
                }
                enum terminate {
                }
              }
            }
            leaf action-string {
              tailf:cli-drop-node-name;
              tailf:cli-multi-value;
              type string {
                tailf:info "WORD;;action string";
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// dot11
  /// ========================================================================

  container dot11 {
    tailf:info "IEEE 802.11 config commands";

    // dot11 syslog
    // no dot11 syslog
    leaf syslog {
      tailf:info "Enable syslog";
      tailf:cli-show-no;
      tailf:cli-full-command;
      type empty;
    }

    // dot11 ssid *
    list ssid {
      tailf:info "Configure radio service set parameters";
      tailf:cli-mode-name "config-ssid";
      key id;
      leaf id {
        type string {
          tailf:info "LINE;;radio Service Set ID (Up to 32 characters";
          length "0..32";
        }
      }

      // dot11 ssid * / vlan
      leaf vlan {
        tailf:info "bind ssid to vlan";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;vlan ID number or name string";
        }
      }

      // dot11 ssid * / authentication
      container authentication {
        tailf:info "authentication method";

        // dot11 ssid * / authentication open
        container open {
          tailf:info "open method";
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-reset-container;
          presence true;

          choice open-choice {
            // dot11 ssid * / authentication open mac-address
            leaf mac-address {
              tailf:info "mac-address authentication method";
              type string {
                tailf:info "WORD;;mac address list-name (1 -- 31 characters)";
              }
            }

            // dot11 ssid * / authentication open eap
            leaf eap {
              tailf:info "eap method";
              type string {
                tailf:info "WORD;;eap list name (1 -- 31 characters)";
              }
            }
          }
        }

        // dot11 ssid * / authentication network-eap
        leaf network-eap {
          tailf:info "leap method";
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;leap list name (1 -- 31 characters)";
          }
        }

        // dot11 ssid * / authentication key-management
        container key-management {
          tailf:info "key management";

          // dot11 ssid * / authentication key-management wpa
          container wpa {
            tailf:info "allow WPA clients";
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-reset-container;
            presence true;
            // dot11 ssid * / authentication key-management wpa version
            leaf version {
              tailf:info "Specify WPA version";
              type enumeration {
                enum "1" {
                  tailf:info "WPA version 1";
                }
                enum "2" {
                  tailf:info "WPA version 2";
                }
              }
            }
            // dot11 ssid * / authentication key-management wpa optional
            leaf optional {
              tailf:info "allow legacy clients";
              type empty;
            }
          }
        }
      }

      // dot11 ssid * / guest-mode
      leaf guest-mode {
        tailf:info "guest ssid";
        tailf:cli-full-command;
        type empty;
      }

      // dot11 ssid * / mbssid
      container mbssid {
        tailf:info "Multiple BSSID";

        // dot11 ssid * / mbssid guest-mode
        leaf guest-mode {
          tailf:info "guest ssid";
          type empty;
        }
      }

      // dot11 ssid * / wpa-psk ascii
      // dot11 ssid * / wpa-psk hex
      container wpa-psk {
        tailf:info "Configure Wi-Fi Protected Access pre-shared key";
        choice wpa-psk-choice {
          container ascii {
            tailf:info "Key entered as ascii chars";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            uses password-grouping {
              refine "secret" {
                cli:secret " ascii <SECRET>";
              }
            }
          }
          container hex {
            tailf:info "Key entered as hex chars";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            uses password-grouping {
              refine "secret" {
                cli:secret " hex <SECRET>";
              }
            }
          }
        }
      }
    }

    // dot11 arp-cache
    container arp-cache {
      tailf:info "Enable DOT11 ARP cache";
      tailf:cli-delete-when-empty;
      presence true;

      // dot11 arp-cache optional
      leaf optional {
        tailf:info "Disable ARP Cache until all associated client IP addresses are learned";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// bridge
  /// ========================================================================

  container bridge {
    tailf:info "Bridge Group.";

    // bridge irb
    leaf irb {
      tailf:info "Integrated routing and bridging";
      tailf:cli-full-command;
      type empty;
    }

    // bridge *
    list bridge-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      key id;
      leaf id {
        type uint8 {
          tailf:info "<1-255>;;Bridge Group number for Bridging.";
          range "1..255";
        }
      }

      // bridge * protocol
      leaf protocol {
        tailf:info "Specify spanning tree protocol";
        type enumeration {
          enum dec {
            tailf:info "DEC protocol";
          }
          enum ibm {
            tailf:info "IBM protocol";
          }
          enum ieee {
            tailf:info "IEEE 802.1 protocol";
          }
          enum vlan-bridge {
            tailf:info "vlan-bridge protocol";
          }
        }
      }

      // bridge * bridge
      container bridge {
        tailf:info "Specify a protocol to be bridged in this bridge group";

        // no bridge * bridge clns
        leaf clns {
          tailf:info "ISO CLNS";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }

        // no bridge * bridge ip
        leaf ip {
          tailf:info "IP";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }
      }

      // bridge * route ip
      container route {
        tailf:info "Specify a protocol to be routed in this bridge group";
        leaf ip {
          tailf:info "IP";
          type empty;
        }
      }
    }
  }


  /// ========================================================================
  /// bridge-domain
  /// ========================================================================

  container bridge-domain {
    tailf:info "Bridge-domain global configuration commands";

    // bridge-domain *
    list bridge-domain-list {
      tailf:cli-drop-node-name;
      tailf:cli-mode-name "config-bdomain";
      tailf:cli-full-command;
      tailf:cli-recursive-delete;
      tailf:cli-diff-dependency "../../vlan/vlan-list";
      cli:ned-diff-move-after ">>interface" {
        cli:arguments "when-delete|prio=+1";
      }
      key id;
      leaf id {
        type uint16 {
          tailf:info "<1-16384>;;bridge-domain ID";
          range "1..16384";
        }
      }

      // bridge-domain * / ip
      container ip {
        tailf:info "IP related commands";
        container igmp {
          tailf:info "IP igmp commands";
          container snooping {
            tailf:info "IP igmp snooping commands";
            tailf:cli-incomplete-command;
            tailf:cli-incomplete-no;

            // bridge-domain * / ip igmp snooping immediate-leave
            leaf immediate-leave {
              tailf:info "Enable IGMPv2 immediate leave processing";
              type empty;
            }
          }

          // bridge-domain * / no ip igmp snooping
          container snooping-enable {
            tailf:cli-drop-node-name;
            leaf snooping {
              tailf:info "Global IGMP Snooping enable for Catalyst Vlans";
              tailf:cli-boolean-no;
              type boolean;
              default true;
            }
          }
        }
      }

      // bridge-domain * / member *
      container member {
        tailf:info "bridge-domain member";

        // bridge-domain * / member vni
        leaf vni {
          tailf:info "VxLan vni";
          tailf:cli-remove-before-change;
          type uint32 {
            tailf:info "<4096-16777215>;;VNI ID/number";
            range "4096..16777215";
          }
        }

        // bridge-domain * / member vfi
        leaf vfi {
          tailf:info "Configure the Virtual Forwarding Instance (VFI) member";
          tailf:non-strict-leafref {
            path "../../../../l2vpn-vfi/l2vpn/vfi/context/name";
          }
          type string {
            tailf:info "WORD;;Enter VFI name (Max Size 31)";
          }
        }

        // bridge-domain * / member * service-instance *
        list interface-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-diff-dependency "../vfi";
          key "name service-instance";
          leaf name {
            tailf:cli-disallow-value "vfi";
            tailf:cli-diff-dependency "../../../../../interface";
            type string {
              tailf:info "WORD;;Interface name";
            }
          }
          leaf service-instance {
            tailf:info "ethernet service instance";
            tailf:cli-expose-key-name;
            type uint16 {
              tailf:info "<1-8000>;;Service Instance Identifier";
              range "1..8000";
            }
          }

          // bridge-domain * / member * service-instance * split-horizon group
          container split-horizon {
            tailf:info "Configure this port as a member of a split horizon group";
            leaf group {
              tailf:info "Split-horizon group";
              type uint8 {
                tailf:info "<0-2>;;Split-horizon group number";
                range "0..2";
              }
              default 0;
            }
          }
        }

        // bridge-domain * / member * * encapsulation
        // bridge-domain * / member * * template
        list ip-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-diff-dependency "../vfi";
          key "address vcid";
          leaf address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP address of the peer";
            }
          }
          leaf vcid {
            type uint32 {
              tailf:info "<1-4294967295>;;Enter VC ID value";
              range "1..4294967295";
            }
          }
          choice encapsulation-template-choice {
            container encapsulation {
              tailf:info "Data encapsulation method";
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              leaf mpls {
                tailf:info "Use MPLS encapsulation";
                type empty;
              }
            }
            leaf template {
              tailf:info "Template to use for encapsulation and protocol configuration";
              tailf:non-strict-leafref {
                path "../../../../../template/name";
              }
              type string {
                tailf:info "WORD;;template name (Max size 32)";
              }
            }
          }
        }

        // bridge-domain * / member * evpn-instance
        leaf evpn-instance {
          tailf:info "Ethernet Virtual Private Network (EVPN) Instance";
          tailf:cli-remove-before-change;
          tailf:non-strict-leafref {
            path "/ios:l2vpn-evpn/l2vpn/evpn/instance/id";
          }
          type uint16 {
            tailf:info "<1-65535>;;EVPN instance identifier value";
            range "1..65535";
          }
        }
      }

      // bridge-domain * / mac
      container mac {
        tailf:info "MAC Address related commands";

        // bridge-domain * / no mac learning
        leaf learning {
          tailf:info "Disable mac learning on bridge domain";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }

        // bridge-domain * / mac aging-time
        leaf aging-time {
          tailf:info "Set age time of mac addresses per bridge domain";
          type uint16 {
            tailf:info "<10-3600>;;Aging time in seconds, default 300 seconds (or 1800 seconds for overlay bridge domains)";
          }
          default 300;
        }

        // bridge-domain * / mac limit maximum addresses
        container limit {
          tailf:info "Limit the MAC Addresses learnt";

          // bridge-domain * / mac limit maximum addresses
          container maximum {
            tailf:info "Maximum";
            leaf addresses {
              tailf:info "Addresses";
              type uint32 {
                tailf:info "<1-65536>;;Number of addresses that can be learnt";
                range "1..65536";
              }
            }
          }

          // bridge-domain * / mac limit action flooding disable
          container action {
            tailf:info "action when exceeding the limit";
            container flooding {
              tailf:info "Mac flooding";
              leaf disable {
                tailf:info "disable";
                type empty;
              }
            }
          }
        }
      }

      // bridge-domain * / snmp context
      uses snmp-context-grouping;

      // bridge-domain * / shutdown
      leaf shutdown {
        tailf:info "Take the bridge domain admin down";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// service-group
  /// ========================================================================

  list service-group {
    tailf:info "service-group global command";
    key id;
    leaf id {
      type uint32 {
        tailf:info "<1-32768>;;Service Group ID Number";
        range "1..32768";
      }
    }

    // service-group * / description
    leaf description {
      tailf:cli-multi-value;
      tailf:cli-preformatted;
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;Description string";
      }
    }

    // service-group * / service-policy
    container service-policy {
      tailf:info "Configure Service Policy";
      uses service-policy-grouping;
    }
  }


  /// ========================================================================
  /// service-instance
  /// ========================================================================

  container service-instance {
    tailf:info "Configure service-instance";

    // service-instance mdns-sd service *
    container mdns-sd {
      tailf:info "Static Service MDNS configuration";
      list service {
        tailf:info "Provide only Service Instance Name";
        tailf:cli-mode-name "config-mdns-sd-si";
        key "name regtype domain";
        leaf name {
          type string {
            tailf:info "WORD;;Specify Service instance name";
          }
        }
        leaf regtype {
          tailf:cli-expose-key-name;
          type string {
            tailf:info "Service Type: Specify in the form or _xxx._yyy";
            pattern "_[a-z]{3}._[a-z]{3}";
          }
        }
        leaf domain {
          tailf:info "Domain: Specify domain";
          tailf:cli-expose-key-name;
          type string {
            tailf:info "WORD;;Domain";
          }
        }

        // service-instance mdns-sd service * / target-hostname
        leaf target-hostname {
          tailf:info "Enter FQDN of target host";
          type string {
            tailf:info "WORD;;Enter FQDN of target host";
          }
        }

        // service-instance mdns-sd service * / priority
        leaf priority {
          tailf:info "Specify Priority";
          type uint16 {
            tailf:info "<0-360>;;Specify Priority for this service";
            range "0..360";
          }
        }

        // service-instance mdns-sd service * / weight
        leaf weight {
          tailf:info "Specify Weight";
          type uint16 {
            tailf:info "<0-360>;;Specify Weight for the service";
            range "0..360";
          }
        }

        // service-instance mdns-sd service * / port
        leaf port {
          tailf:info "Specify Port on which service is running";
          type uint32 {
            tailf:info "<0-65535>;;Specify Port for the service";
            range "0..65535";
          }
        }

        // service-instance mdns-sd service * / txt
        leaf txt {
          tailf:info "Text record string with type=name pairs separated using <\\>";
          type string {
            tailf:info "WORD;;TEXT Record for the Service. Maximum 1024 characters";
            length "0..1024";
          }
        }

        // service-instance mdns-sd service * / ipv4addr
        leaf ipv4addr {
          tailf:info "IPV4 address";
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IPV4 address of service";
          }
        }

        // service-instance mdns-sd service * / ipv6addr
        leaf ipv6addr {
          tailf:info "IPV6 address";
          type inet:ipv6-address {
            tailf:info "X:X:X:X::X;;IPV6 address of service";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// service-insertion
  /// ========================================================================

  container service-insertion {
    tailf:info "Service Insertion mode";
    //cli:ned-diff-move-last ">service-insertion " {
    cli:ned-diff-move-last {
      cli:arguments "when-set";
    }
    cli:ned-diff-move-after ">no interface AppNav" {
      cli:arguments "when-delete";
    }
    //cli:ned-diff-move-first ">no service-insertion " {
    cli:ned-diff-move-first {
      cli:arguments "when-delete";
    }

    // service-insertion service-node-group *
    list service-node-group {
      tailf:info "service node Group";
      tailf:cli-mode-name "config-service-insertion-sng";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;service node Group Name";
        }
      }

      // service-insertion service-node-group * / description
      leaf description {
        tailf:info "Group Description";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;Group Description";
        }
      }

      // service-insertion service-node-group * / service-node *
      list service-node {
        tailf:info "service node";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key ip-address;
        leaf ip-address {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;service node IP ADDRESS";
          }
        }
      }

      // service-insertion service-node-group * / node-discovery
      leaf node-discovery {
        tailf:cli-full-command;
        type enumeration {
          enum enable;
        }
      }
    }

    // service-insertion appnav-controller-group *
    list appnav-controller-group {
      tailf:info "AppNav Controller Group";
      tailf:cli-mode-name "config-service-insertion-acg";
      cli:ned-diff-move-before "^service-insertion service-context \\S+<LF> enable" {
        cli:arguments "when-modify";
      }
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;AppNav Controller Group Name";
        }
      }

      // service-insertion appnav-controller-group * / description
      leaf description {
        tailf:info "Group Description";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;Group Description";
        }
      }

      // service-insertion appnav-controller-group * / appnav-controller *
      list appnav-controller {
        tailf:info "AppNav controller";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        ios:appnav-controller-change;
        key ip-address;
        leaf ip-address {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;AppNav controller IP address";
          }
        }
      }
    }

    // service-insertion service-context *
    list service-context {
      tailf:info "Service Context";
      tailf:cli-mode-name "config-service-insertion-context";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;service controller, e.g. waas/1";
        }
      }

      // service-insertion service-context * /  appnav-controller-group
      leaf appnav-controller-group {
        tailf:info "AppNav Controller Group";
        tailf:cli-full-command;
        tailf:non-strict-leafref {
          path "../../appnav-controller-group/name";
        }
        type string {
          tailf:info "WORD;;AppNav Controller Group";
        }
      }

      // service-insertion service-context * / service-node-group
      leaf service-node-group {
        tailf:info "Service node Group";
        tailf:cli-full-command;
        tailf:non-strict-leafref {
          path "../../service-node-group/name";
        }
        type string {
          tailf:info "WORD;;service node Group";
        }
      }

      // service-insertion service-context * / service-policy
      leaf service-policy {
        tailf:info "Specify a service policy for the service context";
        tailf:cli-remove-before-change;
        tailf:cli-full-command;
        tailf:non-strict-leafref {
          path "../../../policy-map/name";
        }
        type string {
          tailf:info "WORD;;Name of the preconfigured service policy";
        }
      }

      // service-insertion service-context * / vrf
      container vrf {
        tailf:info "Configure forwarding table";
        choice c-type {
          leaf name {
            tailf:info "vrf name";
            type string {
              tailf:info "WORD;;vrf name";
            }
          }
          leaf default {
            tailf:info "default";
            type empty;
          }
          leaf global {
            tailf:info "global";
            type empty;
          }
        }
      }

      // service-insertion service-context * / enable
      leaf enable {
        tailf:info "service context enable";
        tailf:cli-diff-dependency "../vrf";
        tailf:cli-diff-dependency "../../appnav-controller-group/appnav-controller";
        cli:ned-diff-move-before ">service-insertion appnav-controller-group" {
          cli:arguments "when-delete|parent";
        }
        type empty;
      }
    }
  }


  /// ========================================================================
  /// vtp
  /// ========================================================================

  container vtp {
    tailf:info "Configure global VTP state";

    // vtp file
    leaf file {
      tailf:info "Configure IFS filesystem file where VTP configuration is stored.";
      type string {
        tailf:info "WORD;;The ascii name of the IFS filesystem file where VTP configuration is stored";
      }
    }

    // vtp interface
    leaf interface {
      tailf:info "Configure interface as the preferred source for the VTP IP updater address.";
      tailf:cli-diff-dependency "../../interface";
      type string {
        tailf:info "WORD;;The name of the interface providing the VTP updater ID for this device.";
      }
    }

    // vtp password
    leaf password {
      tailf:info "Set the password for the VTP administrative domain";
      ios:password-dequote-output "password (\\S+)";
      type NEDCOM_SECRET_TYPE {
        tailf:info "WORD;;The ascii password for the VTP administrative domain.";
      }
    }

    // vtp pruning
    leaf pruning {
      tailf:info "Set the adminstrative domain to permit pruning";
      tailf:cli-diff-after "../mode" {
        tailf:cli-when-target-set;
      }
      type empty;
    }

    // vtp version
    leaf version {
      tailf:info "Set the adminstrative domain to VTP version";
      type uint8 {
        tailf:info "<1-3>;;Set the adminstrative domain VTP version number. Default 1";
        range "1..3";
      }
      default 1;
    }

    // vtp domain
    leaf domain {
      tailf:info "Set the name of the VTP administrative domain.";
      ios:delete-syntax "!no vtp domain";
      type string {
        tailf:info "WORD;;The ascii name for the VTP administrative domain.";
      }
    }

    // vtp mode
    leaf mode {
      tailf:info "Configure VTP device mode";
      cli:ned-diff-move-before "^interface .+<LF> switchport private-vlan";
      type enumeration {
        enum client {
          tailf:info "Set the device to client mode.";
        }
        enum off {
          tailf:info "Set the device to off mode.";
        }
        enum server {
          tailf:info "Set the device to server mode.";
        }
        enum transparent {
          tailf:info "Set the device to transparent mode.";
        }
      }
    }
  }


  /// ========================================================================
  /// cluster
  /// ========================================================================

  container cluster {
    tailf:info "Cluster configuration commands";

    // cluster run
    leaf run {
      tailf:info "This will enable clustering on the device";
      type empty;
    }

    // cluster commander-address
    container commander-address {
      tailf:info "configures cluster commander address ";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf address {
        tailf:cli-drop-node-name;
        tailf:cli-remove-before-change;
        type string {
          tailf:info "H.H.H;;MAC address of the cluster commander";
        }
      }
      leaf member {
        tailf:info "configured cluster member";
        tailf:cli-optional-in-sequence;
        tailf:cli-incomplete-command;
        type uint16 {
          tailf:info "<0-15>;;member number";
          range "0..15";
        }
      }
      leaf name {
        tailf:info "configured cluster name";
        when "../member";
        type string {
          tailf:info "WORD;;cluster name";
        }
      }
      leaf vlan {
        tailf:info "VLAN to communicate with commander";
        type uint16 {
          tailf:info "<1-4094>;;VLAN number to communicate with commander";
          range "1..4094";
        }
      }
    }
  }


  /// ========================================================================
  /// link
  /// ========================================================================

  container link {
    tailf:info "Enable Link State Tracking feature";
    container state {
      tailf:info "Enable link state tracking feature";

      // link state track *
      leaf-list track {
        tailf:info "Enable link state tracking for the group";
        tailf:cli-list-syntax;
        type uint8 {
          tailf:info "<1-10>;;Link state group number to trac";
          range "1..8";
        }
      }
    }
  }

  /// ========================================================================
  /// vlan
  /// ========================================================================

  container vlan {
    tailf:info "VLAN commands";

    choice vlan-accounting-choice {

      // no vlan accounting
      leaf accounting {
        tailf:info "VLAN accounting configuration";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // no vlan accounting input
      container accounting-input {
        tailf:cli-drop-node-name;
        container accounting {
          leaf input {
            tailf:cli-boolean-no;
            tailf:cli-full-command;
            type boolean;
            default true;
          }
        }
      }

      // no vlan accounting output
      container accounting-output {
        tailf:cli-drop-node-name;
        container accounting {
          leaf output {
            tailf:cli-boolean-no;
            tailf:cli-full-command;
            type boolean;
            default true;
          }
        }
      }
    }

    // vlan group * vlan-list *
    list group {
      tailf:info "Create a vlan group";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      key name;
      leaf name {
        tailf:cli-suppress-range;
        type string {
          tailf:info "WORD;;vlan Group name ";
        }
      }
      leaf-list vlan-list {
        tailf:info "List of vlans in this group";
        tailf:cli-range-list-syntax;
        type uint16 {
          tailf:info "<1-4094>;;VLAN id";
        }
      }
    }

    // vlan internal
    container internal {
      tailf:info "internal VLAN";

      // vlan internal reserved met vlan
      container reserved {
        tailf:info "Reserve VLAN(s) for platform internal usage";
        container met {
          tailf:info "Reserve VLAN(s) for Multicast Expansion Table";
          leaf vlan {
            tailf:info "First of 64 contigious VLANs reserved for MET";
            type uint16 {
              tailf:info "<1024-3968>;;First Vlan id needs to be Multiples of 64";
              range "1024..3968" {
                tailf:step 64;
              }
            }
          }
        }
      }

      // vlan internal allocation policy
      container allocation {
        tailf:info "internal VLAN allocation";
        leaf policy {
          tailf:info "internal VLAN allocation policy";
          type enumeration {
            enum ascending {
              tailf:info "Allocates internal VLANs from 1006 to 4094";
            }
            enum descending {
              tailf:info "Allocates internal VLANs from 4094 to 1006.";
            }
          }
        }
      }
    }

    // vlan ifdescr detail
    container ifdescr {
      tailf:info "VLAN subinterface ifDescr";
      leaf detail {
        tailf:info "VLAN subinterface ifDescr in detail";
        type empty;
      }
    }

    // vlan dot1q
    container dot1q {
      tailf:info "dot1q parameters";
      container tag {
        tailf:info "tag parameters";
        leaf native {
          tailf:info "tag native vlan";
          type empty;
        }
      }
    }

    // vlan access-log
    container access-log {
      tailf:info "Configure VACL logging";
      leaf maxflow {
        tailf:info "Set vacl logging maximum flow number";
        type uint16 {
          tailf:info "<0-2048>;;Maximum flow number";
          range "0..2048";
        }
      }
      leaf ratelimit {
        tailf:info "Set vacl logging rate limiter";
        type uint16 {
          tailf:info "<10-5000>;;Maximum number of packets logged per second";
          range "10..5000";
        }
      }
      leaf threshold {
        tailf:info "Set vacl log-update threshold";
        type uint32 {
          tailf:info "<0-2147483647>;;log-update threshold (number of hits)";
          range "0..2147483647";
        }
      }
    }

    // vlan filter *
    list filter {
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-incomplete-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;VLAN map name";
        }
      }
      leaf-list vlan-list {
        tailf:info "VLANs to apply filter to";
        tailf:cli-replace-all;
        tailf:cli-range-list-syntax;
        type uint16 {
          tailf:info "<1-4094>;;VLAN id";
          range "1..4094";
        }
      }
      //note: did not implement 'all' because replaced with 1-4094 by device.
    }

    // vlan *
    list vlan-list {
      tailf:cli-drop-node-name;
      tailf:cli-mode-name "config-vlan";
      tailf:cli-range-list-syntax;
      tailf:cli-diff-dependency "/ios:vtp/mode";
      //ios:range-list-syntax "vlan (\\d+)$";
      key id;
      leaf id {
        type uint16 {
          tailf:info "<1-3967,4048-4094>;;VLAN ID 1-4094 or range(s): 1-5, 10 or 2-5,7-19";
          range "1..4094";
        }
      }

      // vlan * / name
      leaf name {
        tailf:info "Ascii name of the VLAN";
        tailf:cli-multi-value;
        tailf:cli-full-command;
        tailf:cli-diff-set-after "../../vlan-list/name" {
          tailf:cli-when-target-delete;
        }
        // Also slow for RC51:
        // tailf:cli-diff-delete-before "../../vlan-list/name";
        // ENG-20504 eats up CPU, taking hours:
        //tailf:cli-diff-dependency "../../vlan-list/name" {
        //tailf:cli-trigger-on-set;
        //}
        type string {
          tailf:info "The ascii name for the VLAN (Max Size 32)";
          length "1..32";
        }
      }

      // vlan * / state
      leaf state {
        tailf:info "Operational state of the VLAN";
        type enumeration {
          enum active {
            tailf:info "VLAN Active State";
          }
          enum suspend {
            tailf:info "VLAN Suspended State";
          }
        }
      }

      // vlan * / shutdown
      leaf shutdown {
        tailf:info "Shutdown VLAN switching (only on VLAN 2..1001)";
        type empty;
      }

      // vlan * / media
      leaf media {
        tailf:info "Media type of the VLAN";
        type enumeration {
          enum ethernet {
            tailf:info "VLAN type Ethernet";
          }
          enum fd-net {
            tailf:info "VLAN type FDDI Net";
          }
          enum fddi {
            tailf:info "VLAN type FDDI";
          }
          enum tokenring {
            tailf:info "VLAN type Token Ring";
          }
          enum tr-net {
            tailf:info "VLAN type Token Ring Net";
          }
        }
      }

      // vlan * / mtu
      leaf mtu {
        tailf:info "VLAN Maximum Transmission Unit";
        type uint16 {
          tailf:info "<576-18190>;;Value of VLAN Maximum Tranmission Unit";
          range "576..18190";
        }
      }

      // vlan * / remote-span
      leaf remote-span {
        tailf:info "Configure as Remote SPAN VLAN";
        tailf:cli-full-command;
        type empty;
      }

      // vlan * / uni-vlan
      leaf uni-vlan {
        tailf:info "Configure a UNI VLAN";
        tailf:cli-full-command;
        type enumeration {
          enum community {
            tailf:info "UNI/ENI community VLAN";
          }
          enum isolated {
            tailf:info "UNI/ENI isolated VLAN";
          }
        }
      }

      // vlan * / private-vlan
      container private-vlan {
        tailf:info "Configure a private VLAN";
        tailf:cli-diff-dependency "/ios:vtp/mode";

        // vlan * / private-vlan primary
        // vlan * / private-vlan community
        // vlan * / private-vlan isolated
        choice type-choice {
          leaf primary {
            tailf:info "Configure the VLAN as a primary private VLAN";
            type empty;
          }
          leaf community {
            tailf:info "Configure the VLAN as a community private VLAN";
            type empty;
          }
          leaf isolated {
            tailf:info "Configure the VLAN as an isolated private VLAN";
            type empty;
          }
        }

        // vlan * / private-vlan association *
        container association {
          tailf:info "Configure association between private VLANs";
          leaf-list vlans {
            tailf:cli-drop-node-name;
            tailf:cli-range-list-syntax;
            cli:ned-diff-add ">no vlan :: after :: ^vlan \\d+<LF> no private-vlan association" {
              cli:arguments "when-delete";
            }
            cli:ned-diff-add ">no vlan :: after :: ^vlan \\d+<LF> private-vlan association remove" {
              cli:arguments "when-delete";
            }
            tailf:non-strict-leafref {
              path "../../../../vlan-list/id";
            }
            ios:leaf-list-modify "( private-vlan association)(.+)";
            type uint16 {
              tailf:info "WORD;;VLAN IDs of the private VLANs to be configured";
              range "1..4094";
            }
          }
        }
      }

      // vlan * / said
      leaf said {
        tailf:info "IEEE 802.10 SAID";
        type uint32 {
          tailf:info "<1-4294967294>;;IEEE 802.10 SAID";
          range "1..4294967294";
        }
      }

      // vlan * / bridge
      container bridge {
        tailf:info "Bridging characteristics of the VLAN";
        leaf value {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<0-15>;;Value of the bridge number for FDDI Net or Token Ring Net type VLANs";
            range "0..15";
          }
        }
      }

      // vlan * / stp type
      container stp {
        tailf:info "Spanning tree characteristics of the VLAN";
        container type {
          tailf:info "Spanning tree type of the VLAN";
          tailf:cli-delete-when-empty;
          tailf:cli-reset-container;
          presence true;
          leaf value {
            tailf:cli-drop-node-name;
            type enumeration {
              enum auto {
                tailf:info "VLAN STP Type Auto for FDDI Net or Token Ring Net type VLANs";
              }
              enum ibm {
                tailf:info "VLAN STP Type IBM for FDDI Net or Token Ring Net type VLANs";
              }
              enum ieee {
                tailf:info "VLAN STP Type IEEE for FDDI Net or Token Ring Net type VLANs";
              }
            }
            default ieee;
          }
        }
      }

      // vlan * / tb-vlan1
      leaf tb-vlan1 {
        tailf:info "ID number of the first translational VLAN for this VLAN (or zero if none)";
        type uint16 {
          tailf:info "<0-1005>;;ID number of the first translational VLAN for this VLAN (or zero if none)";
        }
      }

      // vlan * / tb-vlan2
      leaf tb-vlan2 {
        tailf:info "ID number of the second translational VLAN for this VLAN (or zero if none)";
        type uint16 {
          tailf:info "<0-1005>;;ID number of the second translational VLAN for this VLAN (or zero if none)";
        }
      }

      // vlan * / parent
      leaf parent {
        tailf:info "ID number of the Parent VLAN of FDDI or Token Ring type VLANs";
        type uint16 {
          tailf:info "<0-1005>;;Value of the ID of the Parent VLAN for FDDI or Token Ring type VLANs";
        }
      }

      // vlan * / backupcrf
      leaf backupcrf {
        tailf:info "Backup CRF mode of the VLAN";
        type enumeration {
          enum disable {
            tailf:info "Disable backup CRF mode for this VLAN";
          }
          enum enable {
            tailf:info "Enable backup CRF mode for this VLAN";
          }
        }
      }
    }

    // vlan configuration *
    list configuration {
      tailf:info "Apply service policy to VLANs";
      tailf:cli-range-list-syntax;
      tailf:cli-mode-name "config-vlan-config";
      key id;
      leaf id {
        type uint16 {
          tailf:info "<1-3967,4048-4094>;;VLAN ID 1-4094 or range(s): 1-5, 10 or 2-5,7-19";
          range "1..4094";
        }
      }

      // vlan configuration * / ip
      container ip {
        tailf:info "ip root chain";
        container igmp {
          tailf:info "igmp root chain";

          // vlan configuration * / no ip igmp snooping
          leaf snooping {
            tailf:info "snooping CLIs";
            tailf:cli-boolean-no;
            type boolean;
            default true;
          }
        }
      }

      // vlan configuration * / ipv6
      container ipv6 {
        tailf:info "ipv6 root chain";

        // vlan configuration * / no ipv6 mld snooping
        container mld {
          tailf:info "mld root chain";
          leaf snooping {
            tailf:info "snooping CLIs";
            tailf:cli-boolean-no;
            type boolean;
            default true;
          }
        }
      }

      // vlan configuration * / service policy
      container service-policy {
        tailf:info "Configure Service Policy";
        tailf:cli-compact-syntax;
        uses service-policy-grouping;
      }

      // vlan configuration * / device-tracking
      container device-tracking {
        tailf:info "Configure device-tracking on the vlan";
        tailf:cli-delete-when-empty;
        tailf:cli-reset-container;
        presence true;
        leaf attach-policy {
          tailf:info "Apply a policy for feature device-tracking";
          tailf:non-strict-leafref {
            path "/ios:device-tracking/policy/name";
          }
          type string {
            tailf:info "WORD;;policy name for device-tracking";
          }
        }
      }
    }

    // vlan access-map *
    list access-map {
      tailf:info "Create vlan access-map or enter vlan access-map command mode";
      tailf:cli-mode-name "config-access-map";
      key "name number";
      leaf name {
        type string {
          tailf:info "WORD;;Vlan access map tag";
        }
      }
      leaf number {
        type uint16 {
          tailf:info "<0-65535>;;Sequence to insert to/delete from existing vlan access-map entry";
        }
      }

      // vlan access-map * / action
      container action {
        tailf:info "Take the action";
        choice action-choice {

          // vlan access-map * / action drop
          container drop {
            tailf:info "Drop packets";
            presence true;
          }

          // vlan access-map * / action forward
          container forward {
            tailf:info "Forward packets";
            tailf:cli-delete-when-empty;
            tailf:cli-reset-container;
            presence true;
            leaf capture {
              tailf:info "Capture packets";
              type empty;
            }
          }
        }
      }

      // vlan access-map * / match
      container match {
        tailf:info "Match values.";

        // vlan access-map * / match mac address *
        container mac {
          tailf:info "MAC based match";
          leaf-list address {
            tailf:info "Match MAC address to access control.";
            tailf:cli-flat-list-syntax;
            tailf:non-strict-leafref {
              path "../../../../../mac/access-list/extended/id";
            }
            type string {
              tailf:info "WORD;;Access-list name";
            }
          }
        }

        // vlan access-map * / match ip address *
        container ip {
          tailf:info "IP based match";
          leaf-list address {
            tailf:info "Match IP address to access control.";
            tailf:cli-flat-list-syntax;
            type exp-ip-acl-type;
          }
        }
      }
    }
  }


  /// ========================================================================
  /// lldp
  /// ========================================================================

  container lldp {
    tailf:info "Global LLDP configuration subcommands";

    // lldp run
    leaf run {
      tailf:info "Enable LLDP";
      type empty;
    }

    // lldp timer
    leaf timer {
      tailf:info "Specify the rate at which LLDP packets are sent (in sec)";
      type uint16 {
        tailf:info "<5-65534>;;Rate at which LLDP packets are sent (in sec)";
        range "5..65534";
      }
    }

    // lldp holdtime
    leaf holdtime {
      tailf:info "Specify the holdtime (in sec) to be sent in packets";
      type uint16 {
        tailf:info "<0-65535>;;Length  of time  (in sec) that receiver must keep this packet";
      }
    }

    // lldp reinit
    leaf reinit {
      tailf:info "Delay (in sec) for LLDP initialization on any interface";
      type uint8 {
        tailf:info "<2-5>;;Specify the delay (in secs) for LLDP to initialize";
        range "2..5";
      }
    }
  }


  /// ========================================================================
  /// EXEC (exec commands executed in config mode)
  /// ========================================================================

  container EXEC {
    tailf:cli-drop-node-name;

    // default
    tailf:action "default" {
      tailf:info "Set a command to its defaults";
      tailf:actionpoint ncsinternal {
        tailf:internal;
      }
      input {
        list auto-prompts {
          tailf:cli-suppress-mode;
          key question;
          leaf question {
            type string;
          }
          leaf answer {
            type string;
          }
        }
        leaf-list args {
          tailf:cli-drop-node-name;
          tailf:cli-flat-list-syntax;
          type string {
            tailf:info "ACTION:;;default <argument(s)>";
          }
        }
      }
      output {
        leaf result {
          type string;
        }
      }
    }

    // execute (run config exec ommands, e,g,; 'crypto key generate')
    tailf:action "exec" {
      tailf:info "Execute config exec-commands, e.g. 'crypto key generate'";
      tailf:actionpoint ncsinternal {
        tailf:internal;
      }
      input {
        list auto-prompts {
          tailf:cli-suppress-mode;
          key question;
          leaf question {
            type string;
          }
          leaf answer {
            type string;
          }
        }
        leaf-list args {
          tailf:cli-drop-node-name;
          tailf:cli-flat-list-syntax;
          type string {
            tailf:info "ACTION:;;exec \"<command> <argument(s)> [options]\"";
          }
        }
      }
      output {
        leaf result {
          type string;
        }
      }
    }
  }


  /// ========================================================================
  /// pm-agent
  /// ========================================================================

  container pm-agent {
    tailf:info "pm-agent Configuration Commands";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-pm-agent";
    ios:shutdown-before-modify "shutdown";
    presence true;

    // pm-agent / tenant
    container tenant {
      tailf:info "enter the tenant configuration";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf id {
        tailf:info "specify the tenant id";
        tailf:cli-incomplete-command;
        type uint32 {
          tailf:info "<1-4294967295>;;specify the tenant-id value";
          range "1..4294967295";
        }
      }
      leaf name {
        tailf:info "specify the tenant name";
        type string {
          tailf:info "WORD;;tenant Name";
        }
      }
    }

    // pm-agent / region
    container region {
      tailf:info "Enter the region ID";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf id {
        tailf:info "Specify the region ID";
        type uint32 {
          tailf:info "<1-4294967295>;;Specify the region-id value";
          range "1..4294967295";
        }
      }
      leaf name {
        tailf:info "Specify the region name";
        type string {
          tailf:info "WORD;;region Name";
        }
      }
    }

    // pm-agent / site
    container site {
      tailf:info "Enter the site configuration";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf id {
        tailf:info "Specify the site ID";
        type uint32 {
          tailf:info "<1-4294967295>;;Specify the site-id value";
          range "1..4294967295";
        }
      }
      leaf name {
        tailf:info "Specify the site name";
        type string {
          tailf:info "WORD;;Site Name";
        }
      }
    }

    // pm-agent / device
    container device {
      tailf:info "Enter the device ID";

      // pm-agent / device id
      container id {
        tailf:info "Specify the device ID";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf id {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-4294967295>;;Specify the device-id value";
            range "1..4294967295";
          }
        }
        leaf name {
          tailf:info "Specify the device name";
          type string {
            tailf:info "WORD;;device name";
          }
        }
      }

      // pm-agent / device type
      leaf type {
        tailf:info "Enter the device type";
        tailf:cli-full-command;
        type enumeration {
          enum ntr {
            tailf:info "ntr device type";
          }
          enum pxtr {
            tailf:info "pxtr device type";
          }
          enum rtr {
            tailf:info "rtr device type";
          }
          enum xtr {
            tailf:info "xtr device type";
          }
        }
      }
    }

    // pm-agent / pmcs
    container pmcs {
      tailf:info "Enter the pmcs configuration";

      // pm-agent / pmcs ipv4 *
      list ipv4 {
        tailf:info "Enter the IPv4 address";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key address;
        leaf address {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IPv4 pmcs address e.g 10.10.0.0";
          }
        }
      }

      // pm-agent / pmcs ipv6 *
      list ipv6 {
        tailf:info "Enter the IPv6 address";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key address;
        leaf address {
          type inet:ipv6-address {
            tailf:info "X:X:X:X::X;;IPv6 pmcs Addr, e.g abcd:1234";
          }
        }
      }
    }

    // pm-agent / instance-id *
    list instance-id {
      tailf:info "Enter the instance ID";
      tailf:cli-mode-name "config-pm-agent-instance";
      key id;
      leaf id {
        type uint32 {
          tailf:info "<0-4294967295>;;Specify the instance-id value";
        }
      }

      // pm-agent / instance-id * / enterprise-prefix
      container enterprise-prefix {
        tailf:info "Enterprise prefix configuration";

        // pm-agent / instance-id * / enterprise-prefix ipv4 prefix-list
        leaf prefix-list {
          tailf:cli-remove-before-change;
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;prefix-list containing list of site targets";
          }
        }

        // pm-agent / instance-id * / enterprise-prefix ipv4 prefix-list
        // Note: IWAN3
        container ipv4 {
          tailf:info "IPv4 enterprise prefix-list";
          leaf prefix-list {
            tailf:cli-remove-before-change;
            type string {
              tailf:info "WORD;;prefix-list containing list of site targets";
            }
          }
        }

        // pm-agent / instance-id * / enterprise-prefix ipv6 prefix-list
        container ipv6 {
          tailf:info "IPv6 enterprise prefix-list";
          leaf prefix-list {
            tailf:cli-remove-before-change;
            type string {
              tailf:info "WORD;;prefix-list containing list of site targets";
            }
          }
        }
      }
    }

    // pm-agent / shutdown
    leaf shutdown {
      tailf:info "shut the device";
      type empty;
    }
  }


  /// ========================================================================
  /// mka
  /// ========================================================================

  // mka policy *
  container mka {
    tailf:info "MACsec Key Agreement (MKA) configuration";
    list policy {
      tailf:info "Configure MKA Policy";
      tailf:cli-mode-name "config-mka-policy";
      tailf:cli-explicit-exit;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;MKA Policy NAME";
        }
      }

      // mka policy * / key-server priority
      container key-server {
        tailf:info "Configure MKA key-server options";
        leaf priority {
          tailf:info "Set MKA key-server priority";
          type uint8 {
            tailf:info "<0-255>;;Key Server Priority (255 = never act as Key Server)";
          }
          default 0;
        }
      }

      // mka policy * / macsec-cipher-suite *
      leaf-list macsec-cipher-suite {
        tailf:info "Cipher Suite for SAK derivation";
        tailf:cli-flat-list-syntax;
        tailf:cli-replace-all;
        ordered-by user;
        type enumeration {
          enum gcm-aes-128 {
            tailf:info "GCM-AES-128 Cipher Suite";
          }
          enum gcm-aes-256 {
            tailf:info "GCM-AES-256 Cipher Suite";
          }
          enum gcm-aes-xpn-256 {
            tailf:info "GCM-AES-XPN-256 Cipher Suite";
          }
        }
      }

      // mka policy * / confidentiality-offset
      leaf confidentiality-offset {
        tailf:info "Set the confidentiality offset for MACsec operation";
        type enumeration {
          enum 0 {
            tailf:info "MACsec Confidentiality Offset value of 0 octets (bytes)";
          }
          enum 30 {
            tailf:info "MACsec Confidentiality Offset value of 30 octets (bytes)";
          }
          enum 50 {
            tailf:info "MACsec Confidentiality Offset value of 50 octets (bytes)";
          }
        }
        default 0;
      }

      // mka policy * / sak-rekey
      container sak-rekey {
        tailf:info "Enable SAK-rekey during";

        // mka policy * / sak-rekey interval
        leaf interval {
          tailf:info "SAK Rekey Interval";
          type uint16 {
            tailf:info "<30-65535>;;SAK Rekey Interval in seconds (default is 0)";
            range "30..65535";
          }
        }

        // mka policy * / sak-rekey on-live-peer-loss
        leaf on-live-peer-loss {
          tailf:info "peer loss from the live membership";
          type empty;
        }
      }

      // mka policy * / send-secure-announcements
      leaf send-secure-announcements {
        tailf:info "Configure MKA to send secure announcements in sending MKPDUs";
        type empty;
      }

      // mka policy * / ssci-based-on-sci
      leaf ssci-based-on-sci {
        tailf:info "Compute SSCI based on SCI,higher the SCI lower the SSCI value(default is disabled)";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// crypto
  /// ========================================================================

  container crypto {
    tailf:info "Encryption module";

    // crypto keyring *
    list keyring {
      tailf:info "Key ring commands";
      tailf:cli-mode-name "conf-keyring";
      tailf:cli-explicit-exit;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;name of the key ring";
        }
      }
      leaf vrf {
        tailf:info "Mention a vrf it belongs to";
        tailf:cli-hide-in-submode;
        tailf:cli-diff-dependency "../../../ip/vrf";
        tailf:cli-diff-dependency "../../../vrf/definition";
        type string {
          tailf:info "WORD;;the VRF name";
        }
      }

      // crypto keyring * / description
      uses description-grouping;

      // crypto keyring * / local-address
      container local-address {
        tailf:info "Limit the keyring usage to a local address";
        uses interface-name-grouping;
      }

      // crypto keyring * / pre-shared-key
      container pre-shared-key {
        tailf:info "Pre-Shared Key";
        tailf:cli-diff-dependency "../local-address";

        // crypto keyring * / pre-shared-key address *
        // crypto keyring * / pre-shared-key address ipv6 *
        list address {
          tailf:info "pre shared key by address";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-remove-before-change;
          tailf:cli-incomplete-command;
          key address;
          leaf ipv6 {
            tailf:info "define shared key with IPv6 address";
            tailf:cli-prefix-key;
            type empty;
          }
          leaf address {
            tailf:cli-suppress-range;
            type union {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IPv4 address prefix";
              }
              type inet:ipv6-address {
                tailf:info "X:X:X:X::X;;IPv6 address";
              }
              type ipv6-prefix {
                tailf:info "X:X:X:X::X/<0-128>;;IPv6 address/prefix";
              }
            }
          }
          leaf mask {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IPv4 address prefix mask";
            }
          }
          container key {
            tailf:info "specify the key";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            uses crypto-key-grouping {
              refine "secret" {
                cli:secret " key <SECRET>";
              }
            }
          }
        }

        // crypto keyring * / pre-shared-key hostname *
        list hostname {
          tailf:info "pre shared key by hostname";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-remove-before-change;
          tailf:cli-incomplete-command;
          key name;
          leaf name {
            tailf:cli-suppress-range;
            type string {
              tailf:info "WORD;;host with which this key is shared";
            }
          }
          container key {
            tailf:info "specify the key";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            uses crypto-key-grouping {
              refine "secret" {
                cli:secret " key <SECRET>";
              }
            }
          }
        }
      }

      // crypto keyring * / rsa-pubkey
      container rsa-pubkey {
        tailf:info "Peer RSA public key chain management";

        // crypto keyring * / rsa-pubkey address *
        list address {
          tailf:info "Public key associated with an address";
          tailf:cli-mode-name "config-pubkey-key";
          key "ip-address type";
          leaf ip-address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;ip address";
            }
          }
          leaf type {
            type enumeration {
              enum signature {
                 tailf:info "Key is to be used for verifying signatures only (default)";
              }
              enum encryption {
                 tailf:info "Key is to be used for encryption only";
              }
            }
          }

          // crypto keyring * / rsa-pubkey address * / address
          leaf address {
            tailf:info "Assign an address to the key";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP address";
            }
          }

          // crypto keyring * / rsa-pubkey address * / key-string
          container key-string {
            tailf:info "Key data";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-pubkey";
            tailf:cli-exit-command "quit";
            leaf hex-data {
              tailf:cli-drop-node-name;
              tailf:cli-disallow-value "quit";
              type string {
                tailf:info "LINE;;Quoted Hex-data string. Use \\r\\n for newline";
              }
            }
          }
        }
      }
    }

    // crypto key pubkey-chain rsa
    container key {
      tailf:info "Long term key operations";
      container pubkey-chain {
        tailf:info "Peer public key chain management";
        container rsa {
          tailf:info "Peer RSA public key chain management";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-pubkey-chain";

          // crypto key pubkey-chain rsa / addressed-key *
          list addressed-key {
            tailf:info "Public key associated with an address";
            tailf:cli-mode-name "config-pubkey-key";
            key address;
            leaf address {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IP address";
              }
            }

            // crypto key pubkey-chain rsa / addressed-key * / key-string
            container key-string {
              tailf:info "Key data";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-pubkey";
              tailf:cli-exit-command "quit";
              leaf hex-data {
                tailf:cli-drop-node-name;
                tailf:cli-disallow-value "quit";
                type string {
                  tailf:info "LINE;;Quoted Hex-data string. Use \\r\\n for newline";
                }
              }
            }
          }
        }
      }
    }

    // crypto logging
    container logging {
      tailf:info "logging messages";

      // crypto logging session
      leaf session {
        tailf:info "logging up/down session";
        type empty;
      }

      // crypto logging ikev2
      leaf ikev2 {
        tailf:info "logging IKEv2 sessions";
        type empty;
      }
    }

    // crypto ikev2
    container ikev2 {
      tailf:info "Configure IKEv2 Options";

      // crypto ikev2 name-mangler *
      list name-mangler {
        tailf:info "Name mangler";
        tailf:cli-mode-name "config-ikev2-name-mangler";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of the mangler";
          }
        }

        // crypto ikev2 name-mangler * / eap
        container eap {
          tailf:info "Derive name from EAP identity";
          choice eap-choice {
            // crypto ikev2 name-mangler * / eap all
            leaf all {
              tailf:info "entire portion of the identity";
              tailf:cli-full-command;
              type empty;
            }

            // crypto ikev2 name-mangler * / eap suffix delimiter
            container suffix {
              tailf:info "suffix portion of eap identity";
              leaf delimiter {
                tailf:info "Specify the delimiter";
                type enumeration {
                  enum '.' {
                    tailf:info "Use . as delimiter";
                  }
                  enum '@' {
                    tailf:info "Use @ as delimiter";
                  }
                }
              }
            }
          }
        }

        // crypto ikev2 name-mangler * / fqdn
        leaf fqdn {
          tailf:info "Derive name from FQDN identity";
          type enumeration {
            enum all {
              tailf:info "entire portion of fqdn identity";
            }
            enum domain {
              tailf:info "domain portion of fqdn identity";
            }
            enum hostname {
              tailf:info "hostname portion of fqdn identity";
            }
          }
        }

        // crypto ikev2 name-mangler * / dn
        leaf dn {
          tailf:info "Derive name from DN identity";
          type enumeration {
            enum common-name {
              tailf:info "common-name portion of DN identity";
            }
            enum country {
              tailf:info "country portion of DN identity";
            }
            enum domain {
              tailf:info "domain portion of DN identity";
            }
            enum locality {
              tailf:info "locality portion of DN identity";
            }
            enum "organization" {
              tailf:info "organization portion of DN identity";
            }
            enum organization-unit {
              tailf:info "organization-unit portion of DN identity";
            }
            enum state {
              tailf:info "state portion of DN identity";
            }
          }
        }

        // crypto ikev2 name-mangler * / email
        leaf email {
          tailf:info "Derive name from EMAIL identity";
          type enumeration {
            enum all {
              tailf:info "entire portion of email identity";
            }
            enum domain {
              tailf:info "domain portion of email identity";
            }
            enum username {
              tailf:info "username portion of email identity";
            }
          }
        }
      }

      // crypto ikev2 authorization policy *
      container authorization {
        tailf:info "IKEv2 authorization";
        list policy {
          tailf:info "IKEv2 authorization policy";
          tailf:cli-mode-name "config-ikev2-author-policy";
          tailf:cli-full-command;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Name of the policy";
            }
          }

          // crypto ikev2 authorization policy * / pool
          leaf pool {
            tailf:info "Specify local address pool";
            tailf:cli-full-command;
            type string {
              tailf:info "WORD;;address pool name";
            }
          }

          // crypto ikev2 authorization policy * / netmask
          leaf netmask {
            tailf:info "Specify netmask of the config address";
            tailf:cli-full-command;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;netmask";
            }
          }

          // crypto ikev2 authorization policy * / aaa
          container aaa {
            tailf:info "Specify aaa attribute list";
            container attribute {
              tailf:info "AAA attribute list";
              leaf list {
                tailf:info "AAA attribute list";
                type string {
                  tailf:info "WORD;;AAA attribute list name";
                }
              }
            }
          }

          // crypto ikev2 authorization policy * / ipv6
          container ipv6 {
            tailf:info "Specify the ipv6 attributes";

            // crypto ikev2 authorization policy * / ipv6 prefix
            leaf prefix {
              tailf:info "Specify ipv6 prefix length of the config address";
              type uint8 {
                tailf:info "<1-128>;;ipv6 prefix length";
                range "1..128";
              }
            }

            // crypto ikev2 authorization policy * / ipv6 pool
            leaf pool {
              tailf:info "Specify local address pool";
              type string {
                tailf:info "WORD;;address pool name";
              }
            }

            // crypto ikev2 authorization policy * / ipv6 dns
            leaf dns {
              tailf:info "Specify DNS Addresses";
              type inet:ipv6-address {
                tailf:info "X:X:X:X::X;;Primary DNS IPv6 address";
              }
            }
          }

          // crypto ikev2 authorization policy * / route
          container route {
            tailf:info "specify route parameters";

            // crypto ikev2 authorization policy * / route set
            container set {
              tailf:info "Specify route set parameters";

              // crypto ikev2 authorization policy * / route set remote
              container remote {
                tailf:info "Specify routes to be pushed to peer";

                // crypto ikev2 authorization policy * / route set remote ipv4 *
                list ipv4 {
                  tailf:info "ipv4 route";
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  key "prefix mask";
                  leaf prefix {
                    type inet:ipv4-address {
                      tailf:info "A.B.C.D;;IP address prefix";
                    }
                  }
                  leaf mask {
                    type inet:ipv4-address {
                      tailf:info "A.B.C.D;;specify mask";
                    }
                  }
                }

                // crypto ikev2 authorization policy * / route set remote ipv6 *
                list ipv6 {
                  tailf:info "ipv6 route";
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  key address;
                  leaf address {
                    type ipv6-prefix {
                      tailf:info "X:X:X:X::X/<0-128>;;IPv6 address/prefix-length";
                    }
                  }
                }
              }

              // crypto ikev2 authorization policy * / route set access-list
              container access-list {
                tailf:info "Specify the route access-list";
                leaf ipv4 {
                  tailf:cli-drop-node-name;
                  type std-ip-acl-type;
                }
                leaf ipv6 {
                  tailf:info "ipv6 access-list";
                  type string {
                    tailf:info "WORD;;access-list name";
                  }
                }
              }

              // crypto ikev2 authorization policy * / route set interface
              // crypto ikev2 authorization policy * / route set interface *
              container interface {
                tailf:info "Specify the route interface [interface-name]";
                tailf:cli-display-separated;
                presence true;
                list interface-list {
                  tailf:cli-drop-node-name;
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  key name;
                  leaf name {
                    type string {
                      tailf:info "WORD;;Interface name";
                    }
                  }
                }
              }
            }

            // crypto ikev2 authorization policy * / route accept any
            container accept {
              tailf:info "Route accept parameters";
              container any {
                tailf:info "Accept all subnets from peer";
                choice any-choice {
                  leaf distance {
                    tailf:info "Specify distance for routes to remote subnets";
                    type uint8 {
                      tailf:info "<1-255>;;Routing distance";
                      range "1..255";
                    }
                    default 1;
                  }
                  leaf tag {
                    tailf:info "Specify tag for routes to remote subnets";
                    type uint32 {
                      tailf:info "<1-497777>;;Routing tag ID";
                      range "1..497777";
                    }
                  }
                }
              }
            }
          }

          // crypto ikev2 authorization policy * / session-lifetime
          leaf session-lifetime {
            tailf:info "Specify maximum session lifetime";
            type uint32 {
              tailf:info "<120-25920000>;;maximum session lifetime in seconds";
              range "120..25920000";
            }
          }

          // crypto ikev2 authorization policy * / dns
          container dns {
            tailf:info "Specify DNS Addresses";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf primary {
              tailf:cli-drop-node-name;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Primary DNS IP address";
              }
            }
            leaf secondary {
              tailf:cli-drop-node-name;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Secondary DNS IP address";
              }
            }
          }
        }
      }

      // crypto ikev2 redirect client
      container redirect {
        tailf:info "IKEv2 Redirect Mechanism for load-balancing";
        container client {
          tailf:info "Enables Redirect Mechanism on Client";
          tailf:cli-delete-when-empty;
          presence true;
          leaf max-redirects {
            tailf:info "Redirect loop detection";
            type uint8 {
              tailf:info "<1-255>;;Max no. of Redirects per session, Default value is 5";
              range "1..255";
            }
            default 5;
          }
        }
      }

      // crypto ikev2 keyring *
      list keyring {
        tailf:info "Define IKEv2 Keyring";
        tailf:cli-mode-name "config-ikev2-keyring";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of IKEv2 Keyring";
          }
        }

        // crypto ikev2 keyring * / peer *
        list peer {
          tailf:info "Configure a Peer and associated keys";
          tailf:cli-mode-name "config-ikev2-keyring-peer";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Name of the peer block";
            }
          }

          // crypto ikev2 keyring * / peer * / description
          leaf description {
            tailf:info "Specify a description of this peer";
            tailf:cli-multi-value;
            tailf:cli-preformatted;
            tailf:cli-full-command;
            type string {
              tailf:info "LINE;;description of the peer";
            }
          }

          // crypto ikev2 keyring * / peer * / address
          container address {
            tailf:info "Specify IPv4/IPv6 address of peer";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            choice address-choice {
              case ipv4 {
                leaf ipv4-address {
                  tailf:cli-drop-node-name;
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;IPv4 Address";
                  }
                }
                leaf ipv4-mask {
                  tailf:cli-drop-node-name;
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;specify mask";
                  }
                  default "255.255.255.255";
                }
              }
              case ipv6 {
                leaf ipv6-address {
                  tailf:cli-drop-node-name;
                  type ipv6-prefix {
                    tailf:info "X:X:X:X::X/<0-128>;;IPv6 address/prefix";
                  }
                }
              }
            }
          }

          // crypto ikev2 keyring * / peer * / identity
          container identity {
            tailf:info "Specify IKE identity to use";
            choice identity-choice {

              // crypto ikev2 keyring * / peer * / identity key-id
              leaf key-id {
                tailf:info "proprietary types of identification (ID KEY ID)";
                type string {
                  tailf:info "WORD;;ID_KEY_ID <string>";
                }
              }

              // crypto ikev2 keyring * / peer * / identity fqdn
              container fqdn {
                tailf:info "Use FQDN";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands;
                tailf:cli-reset-container;
                leaf domain {
                  tailf:info "email Domain Name";
                  tailf:cli-optional-in-sequence;
                  tailf:cli-incomplete-command;
                  type empty;
                }
                leaf name {
                  tailf:cli-drop-node-name;
                  type string {
                    tailf:info "WORD;;Specify the name string";
                  }
                }
              }

              // crypto ikev2 keyring * / peer * / identity email
              container email {
                tailf:info "Use email address";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands;
                tailf:cli-reset-container;
                leaf domain {
                  tailf:info "email Domain Name";
                  tailf:cli-optional-in-sequence;
                  tailf:cli-incomplete-command;
                  type empty;
                }
                leaf name {
                  tailf:cli-drop-node-name;
                  type string {
                    tailf:info "WORD;;Specify the name string";
                  }
                }
              }

              // crypto ikev2 keyring * / peer * / identity address
              leaf address {
                tailf:info "IP address";
                type union {
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;IPv4 address";
                  }
                  type inet:ipv6-address {
                    tailf:info "X:X:X:X::X;;IPv6 address";
                  }
                }
              }
            }
          }

          // crypto ikev2 keyring * / peer * / pre-shared-key
          container pre-shared-key {
            tailf:info "specify the pre-shared key";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;

            choice pre-shared-key-choice {
              case one-case {
                uses crypto-key-grouping {
                  refine "secret" {
                    cli:secret " pre-shared-key <SECRET>";
                  }
                }
              }
              case local-remote-case {
                // crypto ikev2 keyring * / peer * / pre-shared-key local
                container local {
                  tailf:cli-optional-in-sequence;
                  tailf:cli-compact-syntax;
                  tailf:cli-sequence-commands;
                  uses crypto-key-grouping {
                    refine "secret" {
                      cli:secret " pre-shared-key local <SECRET>";
                    }
                  }
                }
                // crypto ikev2 keyring * / peer * / pre-shared-key remote
                container remote {
                  tailf:cli-compact-syntax;
                  tailf:cli-sequence-commands;
                  uses crypto-key-grouping {
                    refine "secret" {
                      cli:secret " pre-shared-key remote <SECRET>";
                    }
                  }
                }
              }
            }
          }
        }
      }

      // crypto ikev2 proposal *
      list proposal {
        tailf:info "Define IKEV2 proposals";
        tailf:cli-mode-name "config-ikev2-proposal";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of IKEv2 proposal";
          }
        }

        // crypto ikev2 proposal * / encryption
        leaf-list encryption {
          tailf:info "Set encryption algorithm(s) for proposal";
          tailf:cli-replace-all;
          tailf:cli-flat-list-syntax;
          type enumeration {
            enum aes-cbc-128 {
              tailf:info "AES-CBC-128";
            }
            enum "3des" {
              tailf:info "3DES";
            }
            enum aes-cbc-192 {
              tailf:info "AES-CBC-192";
            }
            enum aes-cbc-256 {
              tailf:info "AES-CBC-256";
            }
            enum des {
              tailf:info "DES";
            }
            enum aes-gcm-128 {
              tailf:info "Combined-mode,128 bit key,16 byte ICV(Authentication Tag)";
            }
            enum aes-gcm-256 {
              tailf:info "Combined-mode,256 bit key,16 byte ICV(Authentication Tag)";
            }
          }
        }

        // crypto ikev2 proposal * / prf
        leaf-list prf {
          tailf:info "Set prf algorithm(s) for proposal";
          tailf:cli-replace-all;
          tailf:cli-flat-list-syntax;
          type enumeration {
            enum md5 {
              tailf:info "Message Digest 5";
            }
            enum sha1 {
              tailf:info "Secure Hash Standard";
            }
            enum sha256 {
              tailf:info "Secure Hash Standard 2 (256 bit)";
            }
            enum sha384 {
              tailf:info "Secure Hash Standard 2 (384 bit)";
            }
            enum sha512 {
              tailf:info "Secure Hash Standard 2 (512 bit)";
            }
          }
        }

        // crypto ikev2 proposal * / integrity
        leaf-list integrity {
          tailf:info "Set integrity hash algorithm(s) for proposal";
          tailf:cli-replace-all;
          tailf:cli-flat-list-syntax;
          type enumeration {
            enum md5 {
              tailf:info "Message Digest 5";
            }
            enum sha1 {
              tailf:info "Secure Hash Standard";
            }
            enum sha256 {
              tailf:info "Secure Hash Standard 2 (256 bit)";
            }
            enum sha384 {
              tailf:info "Secure Hash Standard 2 (384 bit)";
            }
            enum sha512 {
              tailf:info "Secure Hash Standard 2 (512 bit)";
            }
          }
        }

        // crypto ikev2 proposal * / group
        leaf-list group {
          tailf:info "Set the Diffie-Hellman group(s)";
          tailf:cli-replace-all;
          tailf:cli-flat-list-syntax;
          ordered-by user;
          type enumeration {
            enum "1" {
              tailf:info "DH 768 MODP";
            }
            enum "14" {
              tailf:info "DH 2048 MODP";
            }
            enum "15" {
              tailf:info "DH 3072 MODP";
            }
            enum "16" {
              tailf:info "DH 4096 MODP";
            }
            enum "19" {
              tailf:info "DH 256 ECP";
            }
            enum "2" {
              tailf:info "DH 1024 MODP";
            }
            enum "20" {
              tailf:info "DH 384 ECP";
            }
            enum "21" {
              tailf:info "DH 521 ECP";
            }
            enum "24" {
              tailf:info "DH 2048 (256 subgroup) MODP";
            }
            enum "5" {
              tailf:info "DH 1536 MODP";
            }
          }
        }
      }

      // crypto ikev2 policy-default-disabled
      // => no crypto ikev2 policy default
      leaf policy-default-disabled {
        tailf:info "Set for 'no crypto ikev2 policy default' on device";
        type empty;
      }

      // crypto ikev2 policy *
      list policy {
        tailf:info "Define IKEV2 policies";
        tailf:cli-mode-name "config-ikev2-policy";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of IKEv2 policy";
          }
        }

        // crypto ikev2 policy * / proposal *
        leaf-list proposal {
          tailf:info "Specify Proposal";
          tailf:cli-list-syntax;
          tailf:cli-remove-before-change;
          tailf:non-strict-leafref {
            path "../../../../crypto/ikev2/proposal/name";
          }
          ordered-by user;
          type string {
            tailf:info "WORD;;Specify the name of proposal to be attached";
          }
        }

        // crypto ikev2 policy * / match
        container match {
          tailf:info "Match values of local fields";

          // crypto ikev2 policy * / match fvrf
          leaf fvrf {
            tailf:info "fvrf of the profile";
            tailf:cli-diff-dependency "../../../../../vrf/definition";
            type union {
              type string {
                tailf:info "WORD;;fvrf name (default: global)";
              }
              type enumeration {
                enum any {
                  tailf:info "any fvrf";
                }
              }
            }
          }

          // crypto ikev2 policy * / match address local *
          container address {
            tailf:info "Specify the address to match";
            list local {
              tailf:info "Local address";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key address;
              leaf address {
                type union {
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;IPv4 address";
                  }
                  type inet:ipv6-address {
                    tailf:info "X:X:X:X::X;;IPv6 address";
                  }
                }
              }
            }
          }
        }
      }

      // crypto ikev2 profile *
      list profile {
        tailf:info "Define IKEv2 Profiles";
        tailf:cli-mode-name "config-ikev2-profile";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of IKEv2 Profile";
          }
        }

        // crypto ikev2 profile * / description
        leaf description {
          tailf:info "Specify a description of this profile";
          tailf:cli-multi-value;
          tailf:cli-preformatted;
          tailf:cli-full-command;
          type string {
            tailf:info "LINE;;a 1 line description of the profile";
          }
        }

        // crypto ikev2 profile * / ivrf
        leaf ivrf {
          tailf:info "I-VRF of the profile";
          tailf:cli-diff-dependency "../../../../ip/vrf";
          tailf:cli-diff-dependency "../../../../vrf/definition";
          type string {
            tailf:info "WORD;;VRF Name";
          }
        }

        // crypto ikev2 profile * / match
        container match {
          tailf:info "Match values of peer";

          // crypto ikev2 profile * / match certificate *
          list certificate {
            tailf:info "Peer certificate attributes";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key name;
            leaf name {
              tailf:non-strict-leafref {
                path "../../../../../pki/certificate/map/name";
              }
              type string {
                tailf:info "WORD;;Specify the certificate map";
              }
            }
          }

          // crypto ikev2 profile * / match address local
          container address {
            tailf:info "IP address";

            // crypto ikev2 profile * / match address local interface *
            container local-interface {
              tailf:cli-drop-node-name;
              container local {
                tailf:info "Local address";
                tailf:cli-incomplete-command;
                tailf:cli-incomplete-no;
                list interface {
                  tailf:info "Specify an interface";
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  key name;
                  leaf name {
                    tailf:cli-diff-dependency "../../../../../../../../../interface";
                    type string {
                      tailf:info "WORD;;Interface name";
                    }
                  }
                }
              }
            }

            // crypto ikev2 profile * / match address local *
            list local {
              tailf:info "Local address";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key address;
              leaf address {
                tailf:cli-disallow-value "interface";
                type inet:host {
                  tailf:info "Hostname, A.B.C.D or X:X:X:X::X;;Address";
                }
              }
            }
          }

          // crypto ikev2 profile * / match fvrf
          leaf fvrf {
            tailf:info "fvrf of the profile";
            tailf:cli-diff-dependency "../../../../../vrf/definition";
            type union {
              type string {
                tailf:info "WORD;;fvrf name (default: global)";
              }
              type enumeration {
                enum any {
                  tailf:info "any fvrf";
                }
              }
            }
          }

          // crypto ikev2 profile * / match identify remote
          container identity {
            tailf:info "IKE identity";

            // crypto ikev2 profile * / match identity remote
            container remote {
              tailf:info "Remote identity";

              // crypto ikev2 profile * / match identity remote any
              leaf any {
                tailf:info "match any peer identity";
                tailf:cli-full-command;
                type empty;
              }

              // crypto ikev2 profile * / match identity remote key-id *
              list key-id {
                tailf:info "key-id opaque string ";
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                key name;
                leaf name {
                  type string {
                    tailf:info "WORD;;Specify the key-id string";
                  }
                }
              }

              // crypto ikev2 profile * / match identity remote fqdn
              container fqdn {
                tailf:info "Fully qualified domain name string";

                // crypto ikev2 profile * / match identity remote fqdn *
                list fqdn-list {
                  tailf:cli-drop-node-name;
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  key name;
                  leaf name {
                    type string {
                      tailf:info "WORD;;Specify the name string";
                    }
                  }
                }

                // crypto ikev2 profile * / match identity remote fqdn domain *
                list domain {
                  tailf:info "match domain instead of exact";
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  key name;
                  leaf name {
                    type string {
                      tailf:info "WORD;;Specify the name string";
                    }
                  }
                }
              }

              // crypto ikev2 profile * / match identity remote address *
              list address {
                tailf:info "match address";
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                tailf:cli-compact-syntax;
                key name;
                leaf name {
                  type union {
                    type inet:ipv4-address {
                      tailf:info "A.B.C.D;;IP address";
                    }
                    type ipv6-prefix {
                      tailf:info "X:X:X:X::X/<0-128>;;IPv6 prefix x:x::y/<z>";
                    }
                  }
                }
                leaf mask {
                  tailf:cli-drop-node-name;
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;IP mask";
                  }
                }
              }

              // crypto ikev2 profile * / match identity remote email
              container email {
                tailf:info "Fully qualified email string [Max. 255 char(s)]";

                // crypto ikev2 profile * / match identity remote email domain *
                list domain {
                  tailf:info "match domain instead of exact";
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  key name;
                  leaf name {
                    type string {
                      tailf:info "WORD;;Specify the name string";
                    }
                  }
                }
              }
            }
          }
        }

        // crypto ikev2 profile * / identify
        container identity {
          tailf:info "Specify IKE identity to use";

          // crypto ikev2 profile * / identify local
          container local {
            tailf:info "Specify the local IKE identity to use for the negotiation";
            choice local-choice {
              leaf dn {
                tailf:info "Distinguished Name";
                type empty;
              }
              leaf email {
                tailf:info "Fully qualified email string";
                type string {
                  tailf:info "WORD;;email <user@domain>";
                }
              }
              leaf fqdn {
                tailf:info "Fully qualified domain name string";
                type string {
                  tailf:info "WORD;;FQDN <host.domain>";
                }
              }
              leaf address {
                tailf:info "address";
                type union {
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;IPv4 address";
                  }
                  type inet:ipv6-address {
                    tailf:info "X:X:X:X::X;;IPv6 address";
                  }
                }
              }
            }
          }
        }

        // crypto ikev2 profile * / authentication
        container authentication {
          tailf:info "Set authentication method";

          // crypto ikev2 profile * / authentication local
          container local {
            tailf:info "Set local authentication method";
            choice method-choice {
              container eap {
                tailf:info "Extended Authentication Protocol";
                presence true;
              }
              leaf ecdsa-sig {
                tailf:info "ECDSA Signature";
                type empty;
              }
              container pre-share {
                tailf:info "Pre-Shared Key";
                tailf:cli-flatten-container;
                tailf:cli-compact-syntax;
                tailf:cli-delete-when-empty;
                presence true;
                container key {
                  tailf:cli-flatten-container;
                  tailf:cli-compact-syntax;
                  tailf:cli-sequence-commands;
                  uses crypto-key-grouping {
                    refine "secret" {
                      cli:secret " key <SECRET>";
                    }
                  }
                }
              }
              leaf rsa-sig {
                tailf:info "Rivest-Shamir-Adleman Signature";
                type empty;
              }
            }
          }

          // crypto ikev2 profile * / authentication remote
          container remote {
            tailf:info "Set remote authentication method";
            tailf:cli-delete-when-empty;
            presence true;

            // crypto ikev2 profile * / authentication remote eap
            container eap {
              tailf:info "Extended Authentication Protocol";
              tailf:cli-delete-when-empty;
              presence true;
              leaf query-identity {
                tailf:info "query EAP identity from peer ";
                type empty;
              }
            }

            // crypto ikev2 profile * / authentication remote ecdsa-sig
            leaf ecdsa-sig {
              tailf:info "ECDSA Signature";
              type empty;
            }

            // crypto ikev2 profile * / authentication remote pre-share
            container pre-share {
              tailf:info "Pre-Shared Key";
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              tailf:cli-delete-when-empty;
              presence true;
              container key {
                tailf:cli-flatten-container;
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands;
                uses crypto-key-grouping {
                  refine "secret" {
                    cli:secret " key <SECRET>";
                  }
                }
              }
            }

            // crypto ikev2 profile * / authentication remote rsa-sig
            leaf rsa-sig {
              tailf:info "Rivest-Shamir-Adleman Signature";
              type empty;
            }

            // crypto ikev2 profile * / authentication remote anyconnect-eap aggregate
            container anyconnect-eap {
              tailf:info "AnyConnect EAP";
              container aggregate {
                tailf:info "use aggregate auth for anyconnect eap";
                presence true;
              }
            }
          }
        }

        // crypto ikev2 profile * / pki trustpoint *
        container pki {
          tailf:info "Specify certificate authorities to trust";
          tailf:cli-diff-dependency "../../../../crypto/pki/trustpoint";
          leaf-list trustpoint {
            tailf:info "Cert authority trustpoint for RSA sig";
            tailf:cli-list-syntax;
            tailf:cli-suppress-leafref-in-diff;
            tailf:non-strict-leafref {
              path "../../../../../crypto/pki/trustpoint/id";
            }
            type string {
              tailf:info "WORD;;Specify the trustpoint label to use";
            }
          }
        }

        // crypto ikev2 profile * / keyring
        container keyring {
          tailf:info "Specify keyring to use";
          choice keyring-choice {
            container aaa {
              tailf:info "AAA based keyring";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf name {
                tailf:cli-drop-node-name;
                type string {
                  tailf:info "WORD;;AAA list name";
                }
              }
              leaf name-mangler {
                tailf:info "Specify the name-mangler to derive username";
                tailf:non-strict-leafref {
                  path "../../../../../../crypto/ikev2/name-mangler/name";
                }
                type string {
                  tailf:info "WORD;;mangler name";
                }
              }
            }
            leaf local {
              tailf:info "Local keyring";
              tailf:non-strict-leafref {
                path "../../../../../crypto/ikev2/keyring/name";
              }
              type string {
                tailf:info "WORD;;Keyring name";
              }
            }
          }
        }

        // crypto ikev2 profile * / nat keepalive
        container nat {
          tailf:info "NAT-transparency";
          leaf keepalive {
            tailf:info "NAT keepalive interval";
            type uint16 {
              tailf:info "<5-3600>;;NAT keepalive interval in seconds";
              range "5..3600";
            }
          }
        }

        // crypto ikev2 profile * / aaa
        container aaa {
          tailf:info "Specify AAA related configs";

          // crypto ikev2 profile * / aaa authentication
          container authentication {
            tailf:info "AAA authentication";

            // crypto ikev2 profile * / aaa authentication eap
            leaf eap {
              tailf:info "AAA EAP authentication";
              type string {
                tailf:info "WORD;;AAA list name";
              }
            }

            // crypto ikev2 profile * / aaa authentication anyconnect-eap
            leaf anyconnect-eap {
              tailf:info "AAA AnyConnect EAP authentication";
              type string {
                tailf:info "WORD;;AAA list name";
              }
            }
          }

          // crypto ikev2 profile * / aaa authorization
          container authorization {
            tailf:info "AAA authorization";

            // crypto ikev2 profile * / aaa authorization group
            container group {
              tailf:info "AAA group authorization";

              // crypto ikev2 profile * / aaa authorization group psk list
              container psk {
                tailf:info "AAA list to use when IKEv2 remote auth method is PSK";
                uses crypto-ikev2-profile-aaa-authorization-group-list;
              }

              // crypto ikev2 profile * / aaa authorization group eap list
              container eap {
                tailf:info "AAA list to use when IKEv2 remote auth method is EAP";
                uses crypto-ikev2-profile-aaa-authorization-group-list;
              }

              // crypto ikev2 profile * / aaa authorization group cert list
              container cert {
                tailf:info "AAA list to use when IKEv2 remote auth method is certificate based";
                uses crypto-ikev2-profile-aaa-authorization-group-list;
              }

              // crypto ikev2 profile * / aaa authorization group anyconnect-eap list
              container anyconnect-eap {
                tailf:info "AAA list to use when IKEv2 remote auth method is anyconnect eap based";
                uses crypto-ikev2-profile-aaa-authorization-group-list;
              }
            }

            // crypto ikev2 profile * / aaa authorization user
            container user {
              tailf:info "AAA user authorization";

              // crypto ikev2 profile * / aaa authorization user psk
              container psk {
                tailf:info "AAA list to use when IKEv2 remote auth method is PSK";
                leaf cached {
                  tailf:info "Use cached attributes from EAP authentication or AAA pre-shared key fetch";
                  type empty;
                }
                leaf list {
                  tailf:info "AAA method list";
                  type string {
                    tailf:info "WORD;;AAA list name";
                  }
                }
              }

              // crypto ikev2 profile * / aaa authorization user anyconnect-eap
              container anyconnect-eap {
                tailf:info "AAA list to use when IKEv2 remote auth method is anyconnect eap based";

                // crypto ikev2 profile * / aaa authorization user anyconnect-eap cached
                leaf cached {
                  tailf:info "Use cached attributes from EAP authentication or AAA pre-shared key fetch";
                  type empty;
                }

                // crypto ikev2 profile * / aaa authorization user anyconnect-eap list
                leaf list {
                  tailf:info "AAA method list";
                  type string {
                    tailf:info "WORD;;AAA list name";
                  }
                }
              }
            }
          }

          // crypto ikev2 profile * / aaa accounting
          container accounting {
            tailf:info "AAA accounting";

            // crypto ikev2 profile * / aaa accounting cert
            leaf cert {
              tailf:info "AAA list to use when IKEv2 remote auth method is certificate based";
              type string {
                tailf:info "WORD;;AAA list name";
              }
            }

            // crypto ikev2 profile * / aaa accounting anyconnect-eap
            leaf anyconnect-eap {
              tailf:info "AAA list to use when IKEv2 remote auth method is AnyConnect EAP";
              type string {
                tailf:info "WORD;;AAA list name";
              }
            }
          }
        }

        // crypto ikev2 profile * / virtual-template
        container virtual-template {
          tailf:info "Specify the virtual-template for dynamic interface creation";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf number {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<1-4095>;;Virtual-template number";
              range "1..4095";
            }
          }
          leaf mode {
            tailf:info "Enabling Tunnel Auto Mode";
            type enumeration {
              enum auto {
                tailf:info "Auto - Enable Auto feature on the ike profile";
              }
            }
          }
        }

        // crypto ikev2 profile * / lifetime
        leaf lifetime {
          tailf:info "Set lifetime for ISAKMP security association";
          type uint32 {
            tailf:info "<120-86400>;;lifetime in seconds";
            range "120..86400";
          }
          default 86400;
        }

        // crypto ikev2 profile * / dpd
        container dpd {
          tailf:info "Enable IKE liveness check for peers";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf interval {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<10-3600>;;DPD R-U-THERE interval";
              range "10..3600";
            }
          }
          leaf retry-interval {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<2-60>;;DPD Retry Interval";
            }
          }
          leaf queries {
            tailf:cli-drop-node-name;
            type enumeration {
              enum  on-demand {
                tailf:info "Send DPD queries only as needed";
              }
              enum periodic {
                tailf:info "Send DPD queries at regular intervals";
              }
            }
          }
        }
      }

      // crypto ikev2 fragmentation
      container fragmentation {
        tailf:info "Enable fragmentation of ikev2 packets";
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        leaf mtu {
          tailf:info "MTU size for fragmentation";
          type uint16 {
            tailf:info "<68-1500>;;ikev2 MTU including IP and UDP header size";
            range "68..1500";
          }
        }
      }

      // no crypto ikev2 http-url cert
      container http-url {
        tailf:info "Enable http URL lookup";
        leaf cert {
          tailf:info "Enable certificate lookup based on HTTP-based URL";
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }
      }

      // crypto ikev2 client flexvpn *
      container client {
        tailf:info "IKEv2 client configuration";
        list flexvpn {
          tailf:info "Configure an IKEv2 FlexVPN client";
          tailf:cli-mode-name "config-ikev2-flexvpn";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;IKEv2 FlexVPN name";
            }
          }

          // crypto ikev2 client flexvpn * / peer
          container peer {
            tailf:info "Allowed Encryption/Decryption Peer";

            // crypto ikev2 client flexvpn * / peer *
            list peer-list {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              key sequence;
              leaf sequence {
                type uint8 {
                  tailf:info "<1-255>;;peer sequence number";
                  range "1..255";
                }
              }
              choice address-choice {
                leaf ipv4-address {
                  tailf:cli-drop-node-name;
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;ip address";
                  }
                }
                leaf ipv6-address {
                  tailf:cli-drop-node-name;
                  type inet:ipv6-address {
                    tailf:info "X:X:X:X::X;;IPv6 address";
                  }
                }
                case fqdn {
                  leaf fqdn {
                    tailf:info "Peer host name";
                    type string {
                      tailf:info "WORD;;Peer Hostname";
                    }
                  }
                  leaf dynamic {
                    tailf:info "Dynamic host name";
                    tailf:cli-optional-in-sequence;
                    type empty;
                  }
                  leaf ipv6 {
                    tailf:info "IPv6 host name";
                    tailf:cli-optional-in-sequence;
                    type empty;
                  }
                }
              }

              // crypto ikev2 client flexvpn * / peer * track
              leaf track {
                tailf:info "Peer track object";
                type uint16 {
                  tailf:info "<1-1000>;;Track object number";
                  range "1..1000";
                }
              }
            }

            // crypto ikev2 client flexvpn * / peer reactivate
            leaf reactivate {
              tailf:info "Re-activate peer enabled";
              tailf:cli-full-command;
              type empty;
            }
          }

          // crypto ikev2 client flexvpn * / source *
          list source {
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            tailf:cli-remove-before-change;
            key seq;
            leaf seq {
              type uint8 {
                tailf:info "<1-255>;;source sequence number";
                range "1..255";
              }
            }
            container interface {
              tailf:cli-drop-node-name;
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              uses interface-name-grouping;
            }
            leaf track {
              tailf:info "source track object";
              tailf:non-strict-leafref {
                path "../../../../../../track/track-object/object-number";
              }
              type uint16 {
                tailf:info "<1-1000>;;track object number";
                range "1..1000";
              }
            }
          }

          // crypto ikev2 client flexvpn * / client
          container client {
            tailf:info "Client interface";
            container connect {
              tailf:info "tunnel interface";
              // crypto ikev2 client flexvpn * / client connect Tunnel
              leaf Tunnel {
                tailf:info "Tunnel interface";
                tailf:cli-allow-join-with-value {
                  tailf:cli-display-joined;
                }
                tailf:non-strict-leafref {
                  path "../../../../../../../interface/Tunnel/name";
                }
                type uint32 {
                  tailf:info "<0-2147483647>;;Tunnel interface number";
                  range "0..2147483647";
                }
              }
            }
          }
        }
      }

      // crypto ikev2 dpd
      container dpd {
        tailf:info "Enable IKE liveness check for peers";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf interval {
          tailf:cli-drop-node-name;
          type uint32;
        }
        leaf retry-interval {
          tailf:cli-drop-node-name;
          type uint32;
        }
        leaf mode {
          tailf:cli-drop-node-name;
          type enumeration {
            enum on-demand { }
            enum periodic { }
          }
        }
      }

      // crypto ikev2 limit queue sa-init
      container limit {
        tailf:info "Limit the number of maximum and negotiating sa";
        container queue {
          tailf:info "Limit size of queue";
          leaf sa-init {
            tailf:info "Limit size of LOW Q (incoming SA_INIT requests)";
            type uint32 {
              tailf:info "<100-100000>;;Set the limit";
              range "100..100000";
            }
            default 5000;
          }
        }
      }
    }

    // crypto ca certificate
    container ca {
      tailf:info "Certification authority";
      container certificate {
        tailf:info "Actions on certificates";

        // crypto ca certificate chain *
        list chain {
          tailf:info "Identify certificates";
          tailf:cli-mode-name "config-cert-chain";
          key name;
          leaf name {
            tailf:cli-diff-dependency "../../../../pki/trustpoint";
            type string {
              tailf:info "WORD;;CA Server Name";
            }
          }

          // crypto ca certificate chain * / certificate *
          list certificate {
            tailf:info "Certificate issued by the CA";
            tailf:cli-mode-name "config-pki-hexmode-quotedstring";
            tailf:cli-delete-when-empty;
            tailf:cli-exit-command "quit";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            tailf:cli-full-command;
            tailf:cli-reset-container;
            key serial;
            leaf serial {
              tailf:cli-disallow-value "rollover|ca|ra-encrypt|ra-general|ra-sign|self-signed";
              type string {
                tailf:info "WORD;;Certificate serial number";
              }
            }
            leaf cert-type {
              tailf:cli-optional-in-sequence;
              tailf:cli-drop-node-name;
              tailf:cli-prefix-key;
              type enumeration {
                enum ca {
                  tailf:info "A certificate";
                }
                enum ra-encrypt {
                  tailf:info "A encryption certificate";
                }
                enum ra-general {
                  tailf:info "A general purpose certificate";
                }
                enum ra-sign {
                  tailf:info "A signing certificate";
                }
                enum rollover {
                  tailf:info "Shadow rollover certificate";
                }
                enum self-signed {
                  tailf:info "Self-signed certificate";
                }
              }
            }
            leaf rollover {
              tailf:info "Shadow rollover certificate";
              tailf:cli-optional-in-sequence;
              tailf:cli-prefix-key;
              type empty;
            }
            leaf cert {
              tailf:cli-drop-node-name;
              tailf:cli-disallow-value "rollover|ca|ra-encrypt|ra-general|ra-sign|self-signed";
              type string {
                tailf:info "WORD;;file specification";
              }
            }
          }
        }
      }
    }

    // crypto pki
    container pki {
      tailf:info "Public Key components";

      // crypto pki server *
      // Note: See ///EXEC for rollover [cancel] sub command.
      list server {
        tailf:info "Enable IOS Certificate server";
        tailf:cli-mode-name "cs-server";
        ios:shutdown-before-modify "shutdown";
        max-elements 1;
        key cs-label;
        leaf cs-label {
          type string {
            tailf:info "WORD;;Certificate Server Name";
          }
        }

        // crypto pki server * / database archive
        container database {
          tailf:info "Certificate Server database config parameters";

          // crypto pki server * / database level
          leaf level {
            tailf:info "Level of data stored in database";
            type enumeration {
              enum minimum {
                tailf:info "Minimum certificate info is saved to the database";
              }
              enum names {
                tailf:info "Certificate serial-number & subject name is saved to the database";
              }
              enum complete {
                tailf:info "Each issued certificate is saved to the database";
              }
            }
            default minimum;
          }

          // crypto pki server * / database archive
          choice archive-choice {
            // crypto pki server * / no database archive
            container no-archice {
              tailf:cli-drop-node-name;
              leaf archive {
                tailf:info "Backup Certificate Server Signing Certificate and Keys";
                tailf:cli-boolean-no;
                type boolean;
                default true;
              }
            }
            // crypto pki server * / database archive pem
            // crypto pki server * / database archive pkcs12
            container archive {
              tailf:info "Backup Certificate Server Signing Certificate and Keys";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              tailf:cli-incomplete-command;
              tailf:cli-incomplete-no;
              leaf format {
                tailf:cli-drop-node-name;
                type enumeration {
                  enum pem {
                    tailf:info "PEM format";
                  }
                  enum pkcs12 {
                    tailf:info "PKCS12 format";
                  }
                }
              }
              container password {
                tailf:info "Passphrase to protect the private key archive";
                tailf:cli-flatten-container;
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                leaf type {
                  tailf:cli-drop-node-name;
                  tailf:cli-optional-in-sequence;
                  type uint8 {
                    tailf:info "<0-9>;;Encryption type";
                    range "0..9";
                  }
                }
                leaf secret {
                  tailf:cli-drop-node-name;
                  cli:secret " password <SECRET>";
                  type NEDCOM_SECRET_TYPE {
                    tailf:info "LINE;;Password";
                  }
                }
              }
            }
          }

          // crypto pki server * / database url
          container url {
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf file-type {
              tailf:cli-drop-node-name;
              tailf:cli-optional-in-sequence;
              type enumeration {
                enum cnm {
                  tailf:info "Storage location for name file (*.cnm)";
                }
                enum crl {
                  tailf:info "Storage location for certificate revocation list (*.crl)";
                }
                enum crt {
                  tailf:info "Storage location for issued certificates (*.crt)";
                }
                enum p12 {
                  tailf:info "Storage location for P12 archives (*.p12)";
                }
                enum pem {
                  tailf:info "Storage location for PEM archives (*.pem)";
                }
                enum ser {
                  tailf:info "Storage location for main database files (*.ser)";
                }
              }
            }
            leaf root-url {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "WORD;;URL of primary storage location";
              }
            }
          }
        }

        // crypto pki server * / issuer-name
        leaf issuer-name {
          tailf:info "Issuer name";
          tailf:cli-full-command;
          ios:string-remove-quotes "issuer-name <STRING>";
          type string {
            tailf:info "LINE;;Issuer name";
          }
        }

        // crypto pki server * / grant
        leaf grant {
          tailf:info "Certificate granting options";
          type enumeration {
            enum auto {
              tailf:info "Automatically grant incoming SCEP enrollment requests";
            }
            enum none {
              tailf:info "Automatically reject any incoming SCEP enrollment request";
            }
            enum ra-auto {
              tailf:info "Automatically grant RA-authorized incoming SCEP enrollment request";
            }
          }
        }

        // crypto pki server * / lifetime
        container lifetime {
          tailf:info "Lifetime parameters";

          // crypto pki server * / lifetime certificate
          container certificate {
            tailf:info "Lifetime of certificates issued by this Certificate Server";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            uses crypto-pki-server-lifetime-grouping {
              refine "days" {
                default 365;
              }
            }
          }

          // crypto pki server * / lifetime ca-certificate
          container ca-certificate {
            tailf:info "Lifetime of the Certificate Server signing certificate";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            uses crypto-pki-server-lifetime-grouping {
              refine "days" {
                default 1095;
              }
            }
          }
        }

        // crypto pki server * / hash
        leaf hash {
          tailf:info "Hash algorithm";
          type enumeration {
            enum md5 {
              tailf:info "use md5 hash algorithm";
            }
            enum sha1 {
              tailf:info "use sha1 hash algorithm";
            }
            enum sha256 {
              tailf:info "use sha256 hash algorithm";
            }
            enum sha384 {
              tailf:info "use sha384 hash algorithm";
            }
            enum sha512 {
              tailf:info "use sha512 hash algorithm";
            }
          }
        }

        // crypto pki server * / cdp-url
        leaf cdp-url {
          tailf:info "server crl";
          type string {
            tailf:info "WORD;;URL";
          }
        }

        // crypto pki server * / shutdown
        leaf shutdown {
          tailf:info "Shutdown the Certificate Server";
          type empty;
        }
      }

      // crypto pki trustpoint *
      list trustpoint {
        tailf:info "Define a CA trustpoint";
        tailf:cli-mode-name "ca-trustpoint";
        tailf:cli-explicit-exit;
        tailf:cli-diff-dependency "../../../interface";
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;CA Server Name";
          }
        }

        // crypto pki trustpoint * / serial-number
        container serial-number {
          tailf:info "include serial number";
          tailf:cli-reset-container;
          presence true;
          leaf none {
            tailf:info "do not include serial number";
            type empty;
          }
        }

        // crypto pki trustpoint * / ip-address
        leaf ip-address {
          tailf:info "include ip address";
          type union {
            type string {
              tailf:info "LINE;;interface name or ip address";
            }
            type enumeration {
              enum none {
                tailf:info "do not include ip address";
              }
            }
          }
        }

        // crypto pki trustpoint * / enrollment
        container enrollment {
          tailf:info "Enrollment parameters";

          // crypto pki trustpoint * / enrollment http-proxy
          leaf http-proxy {
            tailf:info "HTTP proxy server for enrollment";
            type string {
              tailf:info "WORD;;host-name";
            }
          }

          // crypto pki trustpoint * / enrollment retry
          container retry {
            tailf:info "Polling parameters";
            leaf count {
              tailf:info "How many times to poll CA for our certificate";
              type uint8 {
                tailf:info "<1-100>;;Number of times to poll a CA for a certificate";
                range "1..100";
              }
            }
            leaf period {
              tailf:info "How long to wait between requests to CA for our certificate";
              type uint8 {
                tailf:info "<1-60>;;Period in minutes between attempts to contact a CA";
                range "1..60";
              }
            }
          }

          // crypto pki trustpoint * / enrollment mode ra
          container mode {
            tailf:info "Mode supported by the Certificate Authority";
            leaf ra {
              tailf:info "Registration Authority mode";
              type empty;
            }
          }

          // crypto pki trustpoint * / enrollment pkcs12
          leaf pkcs12 {
            tailf:info "IOS self generated command for PKCS 12 import";
            type empty;
          }

          // crypto pki trustpoint * / enrollment profile
          leaf profile {
            tailf:info "Specify an profile for enrollment";
            type string {
              tailf:info "WORD;;Profile name";
            }
          }

          // crypto pki trustpoint * / enrollment selfsigned
          // crypto pki trustpoint * / enrollment terminal
          // crypto pki trustpoint * / enrollment url
          choice enrollment-choice {
            leaf selfsigned {
              tailf:info "Generate a Self Signed Certificate";
              type empty;
            }
            container terminal {
              tailf:info "Enroll via the terminal (cut-and-paste)";
              tailf:cli-delete-when-empty;
              presence true;
              leaf pem {
                tailf:info "Include PEM encapsulation boundaries";
                type empty;
              }
            }
            leaf url {
              tailf:info "CA server enrollment URL";
              tailf:cli-full-command;
              type string {
                tailf:info "WORD;;HTTP URL";
              }
            }
            container url-pem {
              tailf:cli-drop-node-name;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              leaf url {
                tailf:info "CA server enrollment URL";
                tailf:cli-incomplete-command;
                type string {
                  tailf:info "WORD;;HTTP URL";
                }
              }
              leaf pem {
                tailf:info "Include PEM encapsulation boundaries";
                type empty;
              }
            }
          }
        }

        // crypto pki trustpoint * / query certificate
        container query {
          tailf:info "Query parameters";
          leaf certificate {
            tailf:info "Get certificates from the CA after reboot";
            type empty;
          }
        }

        // crypto pki trustpoint * / crl cache
        container crl {
          tailf:info "CRL options";
          container cache {
            tailf:info "CRL cache options";
            choice cache-choice {
              leaf delete-after {
                tailf:info "Remove CRL from cache after a timeout";
                type uint16 {
                  tailf:info "<1-43200>;;Minutes to wait before deleting CRL from cache";
                  range "1..43200";
                }
              }
              leaf extend {
                tailf:info "Extend CRL cache time";
                type uint16 {
                  tailf:info "<1-1440>;;Minutes to extend CRL cache time";
                  range "1..1440";
                }
              }
              leaf none {
                tailf:info "Do not cache CRLs";
                type empty;
              }
            }
          }
        }

        // crypto pki trustpoint * / password
        container password {
          tailf:info "revocation password";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          uses password-grouping {
            refine "secret" {
              cli:secret " password <SECRET>";
            }
          }
        }

        // crypto pki trustpoint * / subject-name
        leaf subject-name {
          tailf:info "Subject Name";
          tailf:cli-full-command;
          type string {
            tailf:info "LINE;;Subject Name";
          }
        }

        // crypto pki trustpoint * / chain-validation
        container chain-validation {
          tailf:info "Validation parameters";
          choice validation-choice {
            leaf continue {
              tailf:info "Validate this trustpoint's (sub)CA certificate";
              type string {
                tailf:info "WORD;;Parent trustpoin";
              }
            }
            leaf validation {
              tailf:cli-drop-node-name;
              type enumeration {
                enum stop {
                  tailf:info "This trustpoint's (sub)CA certificate is already trusted. Halt chain validation";
                }
              }
            }
          }
        }

        // crypto pki trustpoint * / fqdn
        leaf fqdn {
          tailf:info "include fully-qualified domain name";
          tailf:cli-full-command;
          type union {
            type enumeration {
              enum none {
                tailf:info "do not include fully-qualified domain name";
              }
            }
            type string {
              tailf:info "LINE;;fully-qualified domain name";
            }
          }
        }

        // crypto pki trustpoint * / usage
        container usage {
          tailf:info "Certificate Usage";
          leaf ike {
            tailf:info "IKE certificate";
            type empty;
          }
          leaf ssl-server {
            tailf:info "SSL server certificate";
            type empty;
          }
          leaf ssl-client {
            tailf:info "SSL client certificate";
            type empty;
          }
        }

        // crypto pki trustpoint * / fingerprint
        leaf fingerprint {
          tailf:info "CA Certificate Fingerprint";
          type string {
            tailf:info "Hex-data;;Certificate Fingerprint";
          }
        }

        // crypto pki trustpoint * / vrf
        leaf vrf {
          tailf:info "vrf to use for enrollment and obtaining CRLs";
          tailf:cli-diff-dependency "../../../../vrf/definition";
          type string {
            tailf:info "WORD;;Name of VRF to use with trustpoint";
          }
        }

        // crypto pki trustpoint * / revocation-check *
        leaf-list revocation-check {
          tailf:info "Revocation checking options";
          tailf:cli-flat-list-syntax;
          tailf:cli-replace-all;
          ordered-by user;
          type enumeration {
            enum crl { // Note: DO NOT reorder, Enum(0) used in java code.
              tailf:info "Revocation check by CRL";
            }
            enum none {
              tailf:info "Ignore revocation check";
            }
            enum ocsp {
              tailf:info "Revocation check by OCSP";
            }
          }
        }

        // crypto pki trustpoint * / hash
        leaf hash {
          tailf:info "Hash algorithm";
          type enumeration {
            enum md5 {
              tailf:info "use md5 hash algorithm";
            }
            enum sha1 {
              tailf:info "use sha1 hash algorithm";
            }
            enum sha256 {
              tailf:info "use sha256 hash algorithm";
            }
            enum sha384 {
              tailf:info "use sha384 hash algorithm";
            }
            enum sha512 {
              tailf:info "use sha512 hash algorithm";
            }
          }
          default sha1;
        }

        // crypto pki trustpoint * / source interface
        container source {
          tailf:info "Specify source";
          container interface {
            tailf:info "Interface used as source address";
            uses interface-name-grouping;
          }
        }

        // crypto pki trustpoint * / rsakeypair
        container rsakeypair {
          tailf:info "Specify rsakeypair for this identity";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf key-label {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;RSA keypair label";
            }
          }
          leaf key-size {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<360-4096>;;General Purpose or Signature Key length";
              range "360..4096";
            }
          }
          leaf encryption-key-size {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<360-4096>;;Encryption Key length";
              range "360..4096";
            }
          }
        }

        // crypto pki trustpoint * / authorization
        container authorization {
          tailf:info "Authorization parameters.";

          // crypto pki trustpoint * / authorization list
          leaf list {
            tailf:info "AAA authorization list to use";
            tailf:cli-diff-dependency "../../../../../aaa/authorization/network/name";
            type string {
              tailf:info "WORD;;Named authorization list.";
            }
          }

          // crypto pki trustpoint * / authorization username
          container username {
            tailf:info "specify how AAA username is generated";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            choice username-choice {
              leaf alt-subjectname {
                tailf:info "aaa username generated from certificate alt-subjectname";
                type enumeration {
                  enum userprinciplename {
                    tailf:info "cert upn field as aaa username";
                  }
                }
              }
              leaf subjectname {
                tailf:info "aaa username generated from certificate subjectname";
                type subjectname-type;
              }
            }
          }

          // crypto pki trustpoint * / authorization username ? secondary
          container username-secondary {
            tailf:cli-drop-node-name;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            tailf:cli-diff-dependency "../username";
            container username {
              tailf:info "specify how AAA username is generated";
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              choice username-choice {
                leaf alt-subjectname {
                  tailf:info "aaa username generated from certificate alt-subjectname";
                  tailf:cli-incomplete-no;
                  tailf:cli-incomplete-command;
                  type enumeration {
                    enum userprinciplename {
                      tailf:info "cert upn field as aaa username";
                    }
                  }
                }
                leaf subjectname {
                  tailf:info "aaa username generated from certificate subjectname";
                  tailf:cli-incomplete-no;
                  tailf:cli-incomplete-command;
                  type subjectname-type;
                }
              }
            }
            leaf secondary {
              tailf:info "secondary username";
              type empty;
            }
          }
        }

        // crypto pki trustpoint * / auto-enroll
        container auto-enroll {
          tailf:info "Automatically enroll this router identity";
          tailf:cli-compact-syntax;
          tailf:cli-delete-when-empty;
          presence true;
          leaf percent {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<0-100>;;renewal percentage";
              range "0..100";
            }
          }
          leaf regenerate {
            tailf:info "Regenerate keys on re-enrollment";
            type empty;
          }
        }

        // crypto pki trustpoint * / match
        container match {
          tailf:info "Match a certificate attibutes/maps";
          // crypto pki trustpoint * / match certificate
          leaf certificate {
            tailf:info "Match a certificate map";
            tailf:non-strict-leafref {
              path "../../../certificate/map/name";
            }
            type string {
              tailf:info "WORD;;Certificate map name";
            }
          }
        }

        // crypto pki trustpoint * / eku request *
        container eku {
          tailf:info "Configure EKU parameters";
          leaf-list request {
            tailf:info "EKU requested attributes";
            tailf:cli-flat-list-syntax;
            tailf:cli-remove-before-change;
            type enumeration {
              enum client-auth {
                tailf:info "Client Auth";
              }
              enum code-signing {
                tailf:info "Code Signing";
              }
              enum email-protection {
                tailf:info "E-Mail Protection";
              }
              enum ipsec-end-system {
                tailf:info "IPSEC End System";
              }
              enum ipsec-tunnel {
                tailf:info "IPSEC Tunnel";
              }
              enum ipsec-user {
                tailf:info "IPSEC User";
              }
              enum ocsp-signing {
                tailf:info "OCSP Signing";
              }
              enum server-auth {
                tailf:info "Server Auth";
              }
              enum ssh-client {
                tailf:info "SSH Client";
              }
              enum ssh-server {
                tailf:info "SSH Server";
              }
              enum time-stamping {
                tailf:info "Time Stamping";
              }
            }
          }
        }
      }

      // crypto pki profile enrollment *
      container profile {
        tailf:info "Define a certificate profile";
        list enrollment {
          tailf:info "Define an enrollment profile";
          tailf:cli-mode-name "ca-profile-enroll";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Certificate enrollment profile tag";
            }
          }

          // crypto pki profile enrollment * / authentication
          container authentication {
            tailf:info "Retrieve CA certificate(s)";

            // crypto pki profile enrollment * / authentication url
            choice url-choice {
              leaf url {
                tailf:info "url to authenticate/enroll";
                type string {
                  tailf:info "WORD;;http or tftp url";
                }
              }
              // crypto pki profile enrollment * / authentication url ? vrf
              container url-vrf {
                tailf:cli-drop-node-name;
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands;
                leaf url {
                  tailf:info "url to authenticate/enroll";
                  tailf:cli-incomplete-command;
                  type string {
                    tailf:info "WORD;;http or tftp url";
                  }
                }
                leaf vrf {
                  tailf:info "VRF to use for certificate enrollment ";
                  tailf:cli-diff-dependency "../../../../../../../ip/vrf";
                  tailf:cli-diff-dependency "../../../../../../../vrf/definition";
                  type string {
                    tailf:info "WORD;;Name of VRF to use for enrollment ";
                  }
                }
              }
            }

            // crypto pki profile enrollment * / authentication command
            leaf command {
              tailf:info "command to authenticate or enroll";
              type string {
                tailf:info "LINE;;Text string (proceed any ? character with ^V)";
              }
            }
          }

          // crypto pki profile enrollment * / enrollment
          container enrollment {
            tailf:info "Enroll router with a CA";

            // crypto pki profile enrollment * / enrollment url
            container url {
              tailf:info "url to authenticate/enroll";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              leaf path {
                tailf:cli-drop-node-name;
                tailf:cli-reset-container;
                type string {
                  tailf:info "WORD;;http or tftp url";
                }
              }
              leaf vrf {
                tailf:info "VRF to use for certificate enrollment";
                type string {
                  tailf:info "WORD;;Name of VRF to use for enrollment";
                }
              }
            }
          }
        }
      }

      // crypto pki certificate
      container certificate {
        tailf:info "Actions on certificates";

        // crypto pki certificate map *
        list map {
          tailf:info "Define certificate attributes map";
          tailf:cli-mode-name "ca-certificate-map";
          key "name seq";
          leaf name {
            type string {
              tailf:info "WORD;;Certificate attribute map tag";
            }
          }
          leaf seq {
            type uint16 {
              tailf:info "<1-65535>;;Sequence to insert into certificate map entry";
              range "1..65535";
            }
          }

          // crypto pki certificate map * / alt-subject-name *
          list alt-subject-name {
            tailf:info "Alternate subject name";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-show-long-obu-diffs;
            ordered-by user;
            key "criteria value";
            leaf criteria {
              type enumeration {
                enum co {
                  tailf:info "Contains";
                }
                enum eq {
                  tailf:info "Equal";
                }
                enum nc {
                  tailf:info "Does not contain";
                }
                enum ne {
                  tailf:info "Not Equal";
                }
              }
            }
            leaf value {
              tailf:cli-multi-word-key;
              type string {
                tailf:info "LINE;;Compare string";
              }
            }
          }

          // crypto pki certificate map * / subject-name *
          list subject-name {
            tailf:info "Certificate subject name";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-show-long-obu-diffs;
            ordered-by user;
            key "criteria value";
            leaf criteria {
              type enumeration {
                enum co {
                  tailf:info "Contains";
                }
                enum eq {
                  tailf:info "Equal";
                }
                enum nc {
                  tailf:info "Does not contain";
                }
                enum ne {
                  tailf:info "Not Equal";
                }
              }
            }
            leaf value {
              tailf:cli-multi-word-key;
              type string {
                tailf:info "LINE;;Compare string";
              }
            }
          }
        }

        // crypto pki certificate chain *
        list chain {
          tailf:info "Identify certificates";
          tailf:cli-mode-name "config-cert-chain";
          key name;
          leaf name {
            tailf:cli-diff-dependency "../../../trustpoint";
            type string {
              tailf:info "WORD;;CA Server Name";
            }
          }

          // crypto pki certificate chain * / certificate *
          uses crypto-pki-certificate-grouping;
        }

        // crypto pki certificate pool
        container pool {
          tailf:info "Identify CA certificates in pool";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-cert-chain";

          // crypto pki certificate pool / cabundle
          leaf cabundle {
            tailf:info "save the bundle file";
            type string {
              tailf:info "WORD;;WORD";
            }
          }

          // crypto pki certificate pool / certificate *
          uses crypto-pki-certificate-grouping;
        }
      }

      // crypto pki token *
      container token {
        tailf:info "Configure cryptographic token";
        list token-name {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;token name";
            }
          }
          uses crypto-pki-token-grouping;
        }
      }

      // crypto pki default
      container default {
        tailf:info "set default values for tokens";
        uses crypto-pki-token-grouping;
      }
    }

    // crypto isakmp
    container isakmp {
      tailf:info "Configure ISAKMP policy";

      // no crypto isakmp default policy
      container default {
        tailf:info "ISAKMP default policy";
        leaf policy {
          tailf:info "Enable default policies for ISAKMP protection suite";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }
      }

      // no crypto isakmp enable
      leaf enable {
        tailf:info "Enable ISAKMP";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // crypto isakmp aggressive-mode disable
      container aggressive-mode {
        tailf:info "Disable ISAKMP aggressive mode";
        leaf disable {
          tailf:info "Disable ISAKMP aggressive mode";
          type empty;
        }
      }

      // crypto isakmp identity
      leaf identity {
        tailf:info "Set the identity which ISAKMP will use";
        type enumeration {
          enum address {
            tailf:info "Use the IP address of the interface for the identity";
          }
          enum dn {
            tailf:info "Use the distinguished name of the router cert for the identity";
          }
          enum hostname {
            tailf:info "Use the hostname of the router for the identity";
          }
        }
        default address;
      }

      // crypto isakmp fragmentation
      leaf fragmentation {
        tailf:info "IKE Fragmentation enabled if required";
        type empty;
      }

      // crypto isakmp invalid-spi-recovery
      leaf invalid-spi-recovery {
        tailf:info "Initiate IKE and send Invalid SPI Notify";
        type empty;
      }

      // crypto isakmp client configuration
      container client {
        tailf:info "Set client configuration policy";
        container configuration {
          tailf:info "Set client configuration policy";

          // crypto isakmp client configuration group *
          list group {
            tailf:info "Set group profile attributes for client";
            tailf:cli-mode-name "config-isakmp-group";
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;group name";
              }
            }

            // crypto isakmp client configuration group * / key
            container key {
              tailf:info "pre-shared key/IKE password";
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              uses crypto-key-grouping {
                refine "secret" {
                  tailf:cli-remove-before-change;
                  cli:secret " key <SECRET>";
                }
              }
            }

            // crypto isakmp client configuration group * / dns
            container dns {
              tailf:info "Specify DNS Addresses";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf primary {
                tailf:cli-drop-node-name;
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Primary DNS IP address";
                }
              }
              leaf secondary {
                tailf:cli-drop-node-name;
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Secondary DNS IP address";
                }
              }
            }

            // crypto isakmp client configuration group * / pool
            leaf pool {
              tailf:info "Set name of address pool";
              type string {
                tailf:info "WORD;;address pool name";
              }
            }

            // crypto isakmp client configuration group * / save-password
            leaf save-password {
              tailf:info "Allows remote client to save XAUTH password";
              type empty;
            }

            // crypto isakmp client configuration group * / max-users
            leaf max-users {
              tailf:info "Set maximum number of users for this group";
              type uint16 {
                tailf:info "<1-5000>;;Max connected users for this group";
                range "1..5000";
              }
            }

            // crypto isakmp client configuration group * / netmask
            leaf netmask {
              tailf:info "netmask used by the client for local connectivity";
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Subnet Mask to be issued for client use";
              }
            }
          }
        }
      }

      // crypto isakmp profile *
      list profile {
        tailf:info "Define ISAKMP Profiles";
        tailf:cli-mode-name "conf-isa-prof";
        tailf:cli-explicit-exit;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of ISAKMP Profile";
          }
        }

        // crypto isakmp profile * / description
        leaf description {
          tailf:info "Specify a description of this profile";
          tailf:cli-multi-value;
          tailf:cli-preformatted;
          tailf:cli-full-command;
          type string {
            tailf:info "LINE;;a 1 line description of the profile";
          }
        }

        // crypto isakmp profile * / vrf
        leaf vrf {
          tailf:info "Specify the VRF it is related to";
          tailf:cli-diff-dependency "../../../../ip/vrf";
          tailf:cli-diff-dependency "../../../../vrf/definition";
          type string {
            tailf:info "WORD;;VRF Name";
          }
        }

        // crypto isakmp profile * / ca trust-point *
        container ca {
          tailf:info "Specify certificate authorities to trust";
          leaf-list trust-point {
            tailf:info "Cert authority trustpoint for RSA sig";
            tailf:cli-list-syntax;
            tailf:cli-remove-before-change;
            tailf:non-strict-leafref {
              path "../../../../../crypto/pki/trustpoint/id";
            }
            ordered-by user;
            type string {
              tailf:info "WORD;;Specify the trust-point label to use";
            }
          }
        }

        // crypto isakmp profile * / keyring *
        list keyring {
          tailf:info "Specify keyring to use";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            tailf:cli-diff-dependency "../../../../keyring";
            type union {
              type enumeration {
                enum "default" {
                  tailf:info "Use global keyring";
                }
              }
              type string {
                tailf:info "WORD;;Name of the keyring to use";
              }
            }
          }
        }

        // crypto isakmp profile * / self-identify
        container self-identity {
          tailf:info "Specify Identity to use";
          choice self-identity-choice {
            // crypto isakmp profile * / self-identify address
            container address {
              tailf:info "Use IPv4 address";
              tailf:cli-full-command;
              tailf:cli-full-no;
              presence true;
            }
            // crypto isakmp profile * / self-identify address ipv6
            container address-ipv6 {
              tailf:cli-drop-node-name;
              leaf address {
                tailf:info "Use IPv4 address";
                type enumeration {
                  enum ipv6 {
                    tailf:info "Use IPv6 address";
                  }
                }
                default ipv6;
              }
            }
            // crypto isakmp profile * / self-identify fqdn
            container fqdn {
              tailf:info "Use FQDN";
              tailf:cli-delete-when-empty;
              presence true;
              leaf id {
                tailf:cli-drop-node-name;
                type string {
                  tailf:info "WORD;;FQDN ID";
                }
              }
            }
            // crypto isakmp profile * / self-identify user-fqdn
            leaf user-fqdn {
              tailf:info "Use user FQDN";
              type string {
                tailf:info "WORD;;User FQDN <user@full.domain.name>";
              }
            }
          }
        }

        // crypto isakmp profile * / match
        container match {
          tailf:info "Match values of peer";

          // crypto isakmp profile * / match fvrf
          leaf fvrf {
            tailf:info "fvrf of the profile";
            tailf:cli-diff-dependency "../../../../../vrf/definition";
            type union {
              type string {
                tailf:info "WORD;;fvrf name (default: global)";
              }
              type enumeration {
                enum any {
                  tailf:info "any fvrf";
                }
              }
            }
          }

          // crypto isakmp profile * / match identity
          container identity {
            tailf:info "Peer identity";

            // crypto isakmp profile * / match identity group *
            list group {
              tailf:info "Group name";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key name;
              leaf name {
                type string {
                  tailf:info "WORD;;Specify the group name";
                }
              }
            }

            // crypto isakmp profile * / match identity address *
            container address {
              tailf:info "IP Address(es)";
              list ipv4 {
                tailf:cli-drop-node-name;
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                key "address mask";
                leaf address {
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;IP address prefix";
                  }
                }
                leaf mask {
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;specify mask";
                  }
                }
                leaf vrf {
                  tailf:cli-drop-node-name;
                  tailf:cli-diff-dependency "../../../../../../../../ip/vrf";
                  tailf:cli-diff-dependency "../../../../../../../../vrf/definition";
                  type string {
                    tailf:info "WORD;;Specify the F VRF (default global)";
                  }
                }
              }
              container ipv4-host {
                tailf:cli-drop-node-name;
                list ipv4 {
                  tailf:cli-drop-node-name;
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  key address;
                  leaf address {
                    type inet:ipv4-address {
                      tailf:info "A.B.C.D;;IP address prefix";
                    }
                  }
                  leaf vrf {
                    tailf:cli-drop-node-name;
                    tailf:cli-diff-dependency "../../../../../../../../../ip/vrf";
                    tailf:cli-diff-dependency "../../../../../../../../../vrf/definition";
                    type string {
                      tailf:info "WORD;;Specify the F VRF (default global)";
                    }
                  }
                }
              }
              list ipv6 {
                tailf:info "IPv6 Address(es)";
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                key address;
                leaf address {
                  type ipv6-prefix {
                    tailf:info "X:X:X:X::X/<0-128>;;IPv6 address prefix";
                  }
                }
                leaf vrf {
                  tailf:cli-drop-node-name;
                  tailf:cli-diff-dependency "../../../../../../../../ip/vrf";
                  tailf:cli-diff-dependency "../../../../../../../../vrf/definition";
                  type string {
                    tailf:info "WORD;;Specify the F VRF (default global)";
                  }
                }
              }
            }

            // crypto isakmp profile * / match identity host
            container host {
              tailf:info "match a hostname/domain";

              // crypto isakmp profile * / match identity host * <vrf>
              list domain-name-vrf {
                tailf:cli-drop-node-name;
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                key "domain vrf";
                leaf domain {
                  tailf:cli-disallow-value "domain";
                  type string {
                    tailf:info "WORD;;Specify the domain name";
                  }
                }
                leaf vrf {
                  tailf:cli-diff-dependency "../../../../../../../../ip/vrf";
                  tailf:cli-diff-dependency "../../../../../../../../vrf/definition";
                  type string {
                    tailf:info "WORD;;Specify the F VRF (default global)";
                  }
                }
              }

              // crypto isakmp profile * / match identity host *
              leaf-list domain-name {
                tailf:cli-drop-node-name;
                tailf:cli-list-syntax;
                tailf:cli-full-command;
                type string {
                  tailf:info "WORD;Specify the domain name";
                }
              }

              // crypto isakmp profile * / match identity host domain *
              container domain {
                tailf:info "match domain instead of exact";

                // crypto isakmp profile * / match identity host domain * <vrf>
                list domain-name-vrf {
                  tailf:cli-drop-node-name;
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  key "domain vrf";
                  leaf domain {
                    type string {
                      tailf:info "WORD;;Specify the domain name";
                    }
                  }
                  leaf vrf {
                    tailf:cli-diff-dependency "../../../../../../../../../ip/vrf";
                    tailf:cli-diff-dependency "../../../../../../../../../vrf/definition";
                    type string {
                      tailf:info "WORD;;Specify the VRF (default global)";
                    }
                  }
                }

                // crypto isakmp profile * / match identity host domain *
                leaf-list domain-name {
                  tailf:cli-drop-node-name;
                  tailf:cli-list-syntax;
                  tailf:cli-full-command;
                  type string {
                    tailf:info "WORD;;Specify the domain name";
                  }
                }
              }
            }

            // crypto isakmp profile * / match identity user-fqdn
            container user-fqdn {
              tailf:info "Use user FQDN";

              // crypto isakmp profile * / match identity user-fqdn * <vrf>
              list domain-name-vrf {
                tailf:cli-drop-node-name;
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                key "domain vrf";
                leaf domain {
                  type string {
                    tailf:info "WORD;;Specify the domain name";
                  }
                }
                leaf vrf {
                  tailf:cli-diff-dependency "../../../../../../../../ip/vrf";
                  tailf:cli-diff-dependency "../../../../../../../../vrf/definition";
                  type string {
                    tailf:info "WORD;;Specify the F VRF (default global)";
                  }
                }
              }

              // crypto isakmp profile * / match identity user-fqdn *
              leaf-list domain-name {
                tailf:cli-drop-node-name;
                tailf:cli-list-syntax;
                tailf:cli-full-command;
                type string {
                  tailf:info "WORD;;Specify the domain name";
                }
              }
            }
          }

          // crypto isakmp profile * / match certificate
          leaf certificate {
            tailf:info "Peer certificate attributes";
            tailf:non-strict-leafref {
              path "../../../../pki/certificate/map/name";
            }
            type string {
              tailf:info "WORD;;Specify the certificate map";
            }
          }
        }

        // crypto isakmp profile * / client
        container client {
          tailf:info "Specify client configuration settings";

          // crypto isakmp profile * / client authentication
          container authentication {
            tailf:info "Use Extended Authentication";
            leaf list {
              tailf:info "AAA authentication list to use";
              type string {
                tailf:info "WORD;;Named authentication list.";
              }
            }
          }

          // crypto isakmp profile * / client configuration address
          container configuration {
            tailf:info "Specify client configuration settings";
            container address {
              tailf:info "Specify client network address configuration";

              // crypto isakmp profile * / client configuration address initiate
              leaf initiate {
                tailf:info "Push the network address to the client";
                type empty;
              }

              // crypto isakmp profile * / client configuration address respond
              leaf respond {
                tailf:info "Respond to network address requests from the client";
                type empty;
              }
            }
          }
        }

        // crypto isakmp profile * / isakmp authorization list
        container isakmp {
          tailf:info "ISAKMP Authorization command";
          container authorization {
            tailf:info "Authorization parameters.";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf list {
              tailf:info "AAA authorization list to use";
              type string {
                tailf:info "WORD;;Named authorization list.";
              }
            }
            container password {
              tailf:info "AAA password";
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              uses crypto-key-grouping {
                refine "secret" {
                  cli:secret " password <SECRET>";
                }
              }
            }
          }
        }

        // crypto isakmp profile * / no keepalive
        // crypto isakmp profile * / keepalive
        choice keepalive-choice {
          container keepalive {
            tailf:info "Set a keepalive interval for use with IOS peers";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            tailf:cli-incomplete-command;
            tailf:cli-incomplete-no;
            leaf seconds {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              tailf:cli-incomplete-no;
              type uint16 {
                tailf:info "<10-3600>;;Number of seconds between keep alives";
                range "10..3600";
              }
            }
            leaf retry {
              tailf:info "Retry interval if keepalive fails";
              type uint8 {
                tailf:info "<2-60>;;Number of seconds between retries if keepalive fails";
                range "2..60";
              }
            }
          }
          container keepalive-enable {
            tailf:cli-drop-node-name;
            leaf keepalive {
              tailf:info "Set a keepalive interval for use with IOS peers";
              tailf:cli-boolean-no;
              tailf:cli-full-command;
              tailf:cli-full-no;
              type boolean;
              default true;
            }
          }
        }

        // crypto isakmp profile * / local-address
        container local-address {
          tailf:info "Interface to use for local address for this isakmp profile";
          choice local-address-choice {
            leaf ipv4-address {
              tailf:cli-drop-node-name;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Specify an IPv4 address to bind to";
              }
            }
            leaf ipv6-address {
              tailf:cli-drop-node-name;
              type inet:ipv6-address {
                tailf:info "X:X:X:X::X;;Specify an IPv6 address to bind to";
              }
            }
            container interface {
              tailf:cli-drop-node-name;
              uses interface-name-grouping;
            }
          }
        }

        // crypto isakmp profile * / accounting
        leaf accounting {
          tailf:info "Enable AAA Accounting for IPSec Sessions";
          type string {
            tailf:info "WORD;;Name of accounting list";
          }
        }

        // crypto isakmp profile * / virtual-template
        leaf virtual-template {
          tailf:info "Specify the virtual-template for dynamic interface creation.";
          tailf:non-strict-leafref {
            path "../../../../interface/Virtual-Template/name";
          }
          type uint16 {
            tailf:info "<1-4095>;;Virtual-template Number to clone";
            range "1..4095";
          }
        }

        // crypto isakmp profile * / qos-group
        leaf qos-group {
          tailf:info "Apply a Qos policy class map for this profile";
          type uint16 {
            tailf:info "<1-1023>;;Qos Group value";
            range "1..1023";
          }
        }
      }

      // crypto isakmp policy *
      list policy {
        tailf:info "Set policy for an ISAKMP protection suite";
        tailf:cli-mode-name "config-isakmp";
        key priority;
        leaf priority {
          type uint16 {
            tailf:info "<1-10000>;;Priority of protection suite";
          }
        }

        // crypto isakmp policy * / encr
        container encr {
          tailf:info "Set encryption algorithm for protection suite";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf algorithm {
            tailf:cli-drop-node-name;
            type enumeration {
              enum des {
                tailf:info "DES - Data Encryption Standard (56 bit keys).";
              }
              enum "3des" {
                tailf:info "Three key triple DES";
              }
              enum aes {
                tailf:info "AES - Advanced Encryption Standard.";
              }
            }
            default des;
          }
          leaf bits {
            when "../algorithm = 'aes'" {
              tailf:dependency "../algorithm";
            }
            tailf:cli-drop-node-name;
            type enumeration {
              enum "128" {
                tailf:info "128 bit keys.";
              }
              enum "192" {
                tailf:info "192 bit keys.";
              }
              enum "256" {
                tailf:info "256 bit keys.";
              }
            }
            default 128;
          }
        }

        // crypto isakmp policy * / hash
        leaf hash {
          tailf:info "Set hash algorithm for protection suite";
          type enumeration {
            enum md5 {
              tailf:info "Message Digest 5";
            }
            enum sha {
              tailf:info "Secure Hash Standard";
            }
            enum sha256 {
              tailf:info "Secure Hash Standard";
            }
            enum sha384 {
              tailf:info "Secure Hash Standard 2 (384 bit)";
            }
            enum sha512 {
              tailf:info "Secure Hash Standard 2 (512 bit)";
            }
          }
          default sha;
        }

        // crypto isakmp policy * / authentication
        leaf authentication {
          tailf:info "Set authentication method for protection suite";
          type enumeration {
            enum pre-share {
              tailf:info "Pre-Shared Key";
            }
            enum rsa-encr {
              tailf:info "Rivest-Shamir-Adleman Encryption";
            }
            enum rsa-sig {
              tailf:info "Rivest-Shamir-Adleman Signature";
            }
          }
        }

        // crypto isakmp policy * / group
        leaf group {
          tailf:info "Set the Diffie-Hellman group";
          type enumeration {
            enum "1" {
              tailf:info "Diffie-Hellman group 1 (768 bit)";
            }
            enum "2" {
              tailf:info "Diffie-Hellman group 2 (1024 bit)";
            }
            enum "5" {
              tailf:info "Diffie-Hellman group 5 (1536 bit)";
            }
            enum "14" {
              tailf:info "Diffie-Hellman group 14 (2048 bit)";
            }
            enum "15" {
              tailf:info "Diffie-Hellman group 15 (3072 bit)";
            }
            enum "16" {
              tailf:info "Diffie-Hellman group 16 (4096 bit)";
            }
            enum "19" {
              tailf:info "Diffie-Hellman group 19 (256 bit ecp)";
            }
            enum "20" {
              tailf:info "Diffie-Hellman group 20 (384 bit ecp)";
            }
            enum "21" {
              tailf:info "Diffie-Hellman group 21 (521 bit ecp)";
            }
            enum "24" {
              tailf:info "Diffie-Hellman group 24 (2048 bit, 256 bit subgroup)";
            }
          }
        }

        // crypto isakmp policy * / lifetime
        leaf lifetime {
          tailf:info "Set lifetime for ISAKMP security association";
          type uint32 {
            tailf:info "<60-86400>;;lifetime in seconds";
            range "60..86400";
          }
          default 86400;
        }
      }

      // crypto isakmp keepalive
      container keepalive {
        tailf:info "Set a keepalive interval for use with IOS peers";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf seconds {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<10-3600>;;Number of seconds between keep alives";
            range "10..3600";
          }
        }
        leaf retry-seconds {
          tailf:cli-drop-node-name;
          tailf:cli-optional-in-sequence;
          type uint8 {
            tailf:info "<2-60>;;Number of seconds between retries if keepalive fails";
            range "2..60";
          }
        }
        leaf option {
          tailf:cli-drop-node-name;
          type enumeration {
            enum periodic {
              tailf:info "When using Dead Peer Detection (DPD), send periodic DPD messages";
            }
            enum on-demand {
              tailf:info "When using Dead Peer Detection (DPD), send DPD messages only as needed";
            }
          }
          default on-demand;
        }
      }

      // crypto isakmp nat
      container nat {
        tailf:info "Set a nat  keepalive interval for use with IOS peers";
        container keepalive {
          tailf:info "Set a keepalive interval for use with IOS peers";
          leaf seconds {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<5-3600>;;Number of seconds between keep alives";
              range "5..3600";
            }
          }
        }
      }

      // crypto isakmp key * address
      list key {
        tailf:info "Set pre-shared key for remote peer";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key address;
        leaf address {
          tailf:cli-expose-key-name;
          tailf:info "define shared key with IP address";
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Peer IP address";
          }
        }
        leaf encrypted {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          tailf:cli-optional-in-sequence;
          tailf:ned-ignore-compare-config;
          type enumeration {
            enum "6" {
              tailf:info "Specifies an ENCRYPTED password will follow";
            }
          }
        }
        leaf keystring {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          tailf:cli-disallow-value "0|6";
          cli:secret "crypto isakmp key <SECRET> address \\S+" {
            cli:arguments "remove-before-change=/..";
          }
          type NEDCOM_SECRET_TYPE {
            tailf:info "WORD;;The UNENCRYPTED (cleartext) user password";
          }
        }
        leaf mask {
          tailf:cli-drop-node-name;
          tailf:cli-optional-in-sequence;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Peer IP subnet mask";
          }
        }
        leaf no-xauth {
          tailf:info "Bypasses XAuth for this peer";
          type empty;
        }
      }

      // crypto isakmp key ? address ipv6 *
      container key-ipv6-list {
        tailf:cli-drop-node-name;
        list key {
          tailf:info "Set pre-shared key for remote peer";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          key ipv6;
          leaf ipv6 {
            tailf:info "define shared key with IPv6 address";
            tailf:cli-expose-key-name;
            type ipv6-prefix {
              tailf:info "X:X:X:X::X/<0-128>;;Peer IPv6 prefix";
            }
          }
          leaf encrypted {
            tailf:cli-drop-node-name;
            tailf:cli-prefix-key;
            tailf:cli-optional-in-sequence;
            type enumeration {
              enum "6" {
                tailf:info "Specifies an ENCRYPTED password will follow";
              }
            }
          }
          leaf keystring {
            tailf:cli-drop-node-name;
            tailf:cli-prefix-key;
            tailf:cli-disallow-value "0|6";
            cli:secret "crypto isakmp key <SECRET> address ipv6 \\S+" {
              cli:arguments "remove-before-change=/..";
            }
            type NEDCOM_SECRET_TYPE {
              tailf:info "WORD;;The UNENCRYPTED (cleartext) user password";
            }
          }
          leaf address {
            tailf:info "define shared key with IP address";
            tailf:cli-prefix-key;
            type empty;
          }
          leaf no-xauth {
            tailf:info "Bypasses XAuth for this peer";
            type empty;
          }
        }
      }

      // crypto isakmp key * hostname
      container key-hostname-list {
        tailf:cli-drop-node-name;
        list key {
          tailf:info "Set pre-shared key for remote peer";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          key hostname;
          leaf hostname {
            tailf:cli-expose-key-name;
            tailf:info "define shared key with hostname";
            type string {
              tailf:info "WORD;;hostname of peer with whom the key is shared";
            }
          }
          leaf encrypted {
            tailf:cli-drop-node-name;
            tailf:cli-prefix-key;
            tailf:cli-optional-in-sequence;
            type enumeration {
              enum "6" {
                tailf:info "Specifies an ENCRYPTED password will follow";
              }
            }
          }
          leaf keystring {
            tailf:cli-drop-node-name;
            tailf:cli-prefix-key;
            tailf:cli-disallow-value "0|6";
            cli:secret "crypto isakmp key <SECRET> hostname \\S+" {
              cli:arguments "remove-before-change=/..";
            }
            type NEDCOM_SECRET_TYPE {
              tailf:info "WORD;;The UNENCRYPTED (cleartext) user password";
            }
          }
          leaf no-xauth {
            tailf:info "Bypasses XAuth for this peer";
            type empty;
          }
        }
      }
    }

    // crypto ipsec
    container ipsec {
      tailf:info "Configure IPSEC policy";

      // crypto ipsec optional
      container optional {
        tailf:info "Enable optional encryption for IPSec";
        tailf:cli-delete-when-empty;
        presence true;
        leaf retry {
          tailf:info "Configure length of IPSec retry interval";
          type uint32 {
            tailf:info "<60-86400>;;Number of seconds between IPSec retries. Default 300";
            range "60..86400";
          }
          default 300;
        }
      }

      // crypto ipsec security-association
      container security-association {
        tailf:info "Security association parameters";

        // crypto ipsec security-association idle-time
        leaf idle-time {
          tailf:info "Automatically delete IPSec SAs after a given idle period.";
          type uint32 {
            tailf:info "<60-86400>;;Idle time at which IPSec SAs are deleted";
            range "60..86400";
          }
        }

        // crypto ipsec security-association lifetime
        container lifetime {
          tailf:info "security association lifetime";

          // crypto ipsec security-association lifetime kilobytes
          leaf kilobytes {
            tailf:info "Volume-based key duration";
            type union {
              type uint32 {
                tailf:info "<2560-4294967295>;;Security association duration in kilobytes encrypted";
              }
              type enumeration {
                enum disable {
                  tailf:info "Disable Volume-based Rekey";
                }
              }
            }
            default 4608000;

          }

          // crypto ipsec security-association lifetime seconds
          leaf seconds {
            tailf:info "Time-based key duration";
            type uint32 {
              tailf:info "<120-86400>;;Security association duration in seconds. Default 3600";
              range "120..86400";
            }
            default 3600;
          }
        }

        // crypto ipsec security-association replay
        container replay {
          tailf:info "Set replay checking.";

          // crypto ipsec security-association replay disable
          leaf disable {
            tailf:info "Disable replay checking";
            type empty;
          }

          // crypto ipsec security-association replay window-size
          leaf window-size {
            tailf:info "Set replay window size. Default 64";
            type ipsec-window-size-type;
            default 64;
          }
        }
      }

      // crypto ipsec transform-set *
      list transform-set {
        tailf:info "Define transform and settings";
        tailf:cli-mode-name "cfg-crypto-trans";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Transform set tag";
          }
        }
        leaf transform1 {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum ah-md5-hmac {
              tailf:info "AH-HMAC-MD5 transform";
            }
            enum ah-sha-hmac {
              tailf:info "AH-HMAC-SHA transform";
            }
            enum ah-sha256-hmac {
              tailf:info "AH-HMAC-SHA256 transform";
            }
            enum ah-sha384-hmac {
              tailf:info "AH-HMAC-SHA384 transform";
            }
            enum ah-sha512-hmac {
              tailf:info "AH-HMAC-SHA512 transform";
            }
          }
        }
        leaf transform2 {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum esp-3des {
              tailf:info "ESP transform using 3DES(EDE) cipher (168 bits)";
            }
            enum esp-aes {
              tailf:info "ESP transform using AES cipher";
            }
            enum esp-des {
              tailf:info "ESP transform using DES cipher (56 bits)";
            }
            enum esp-gcm {
              tailf:info "ESP transform using GCM";
            }
            enum esp-gmac {
              tailf:info "ESP transform using GMAC cipher";
            }
            enum esp-null {
              tailf:info "ESP transform w/o cipher";
            }
            enum esp-seal {
              tailf:info "ESP transform using SEAL cipher (160 bits)";
            }
          }
        }
        leaf transform2-bits {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum "128" {
              tailf:info "128 bit keys (with transform2)";
            }
            enum "192" {
              tailf:info "192 bit keys (with transform2)";
            }
            enum "256" {
              tailf:info "256 bit keys (with transform2)";
            }
          }
          default 128;
        }
        leaf transform3 {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum esp-md5-hmac {
              tailf:info "ESP transform using HMAC-MD5 auth";
            }
            enum esp-sha-hmac {
              tailf:info "ESP transform using HMAC-SHA auth";
            }
            enum esp-sha256-hmac {
              tailf:info "ESP transform using HMAC-SHA256 auth";
            }
            enum esp-sha384-hmac {
              tailf:info "ESP transform using HMAC-SHA384 auth";
            }
            enum esp-sha512-hmac {
              tailf:info "ESP transform using HMAC-SHA512 auth";
            }
          }
        }
        leaf transform4 {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum comp-lzs {
              tailf:info "IP Compression using the LZS compression algorithm";
            }
          }
        }

        // crypto ipsec transform-set * / mode
        container mode {
          tailf:info "encapsulation mode (transport/tunnel)";
          choice mode-choice {

            // crypto ipsec transform-set * / mode transport
            container transport {
              tailf:info "transport (payload encapsulation) mode";
              presence true;
              leaf require {
                tailf:info "Accept only the configured encapsulation mode.";
                type empty;
              }
            }

            // crypto ipsec transform-set * / mode tunnel
            leaf tunnel {
              tailf:info "tunnel (datagram encapsulation) mode";
              type empty;
            }
            default tunnel; // cat6500
          }
        }
      }

      // no crypto ipsec default transform-set
      container default {
        tailf:info "Default transform-set";
        leaf transform-set {
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }
      }

      // crypto ipsec fragmentation
      leaf fragmentation {
        tailf:info "Handling of fragmentation of near-MTU sized packets";
        type enumeration {
          enum after-encryption {
            tailf:info "Perform fragmentation of large packets after IPSec encapsulation.";
          }
          enum before-encryption {
            tailf:info "Perform fragmentation of large packets before IPSec encapsulation.";
          }
        }
      }

      // crypto ipsec df-bit
      leaf df-bit {
        tailf:info "Handling of encapsulated DF bit.";
        type enumeration {
          enum clear {
            tailf:info "Clear DF bit for encapsulated packets.";
          }
          enum copy {
            tailf:info "Copy DF bit from inner for encapsulated packets.";
          }
          enum set {
            tailf:info "Set DF bit for encapsulated packets.";
          }
        }
      }

      // crypto ipsec nat-transparency
      leaf nat-transparency {
        tailf:info "IPsec NAT transparency model";
        type enumeration {
          enum spi-matching {
            tailf:info "Match inbound SPI to outbound SPI for IPsec aware NAT";
          }
          enum udp-encapsulation {
            tailf:info "UDP encapsulation of IPsec protocols";
          }
        }
      }

      // crypto ipsec profile *
      list profile {
        tailf:info "Configure an ipsec policy profile";
        tailf:cli-mode-name "ipsec-profile";
        tailf:cli-recursive-delete;
        tailf:cli-diff-dependency "../../isakmp/profile";
        tailf:cli-diff-dependency "../../ikev2/profile";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Profile name";
          }
        }

        // crypto ipsec profile * / description
        leaf description {
          tailf:info "Description of the crypto map statement policy";
          tailf:cli-full-command;
          tailf:cli-preformatted;
          tailf:cli-multi-value;
          type string {
            tailf:info "LINE;;A Short description";
          }
        }

        // crypto ipsec profile * / set
        container set {
          tailf:info "Set values for encryption/decryption";

          // crypto ipsec profile * / set security-association
          container security-association {
            tailf:info "Security association parameters";

            // crypto ipsec profile * / set security-association dfbit
            leaf dfbit {
              tailf:info "Handling of encapsulated DF bit.";
              tailf:cli-full-command;
              type enumeration {
                enum clear {
                  tailf:info "Clear DF bit for encapsulated packets.";
                }
                enum copy {
                  tailf:info "Copy DF bit from inner for encapsulated packets.";
                }
                enum set {
                  tailf:info "Set DF bit for encapsulated packets.";
                }
              }
            }

            // crypto ipsec profile * / set security-association lifetime
            container lifetime {
              tailf:info "security association lifetime";
              leaf kilobytes {
                tailf:info "Volume-based key duration";
                type union {
                  type uint32 {
                    tailf:info "<2560-4294967295>;;Security association duration in kilobytes encrypted";
                  }
                  type enumeration {
                    enum disable {
                      tailf:info "Disable Volume-based Rekey";
                    }
                  }
                }
              }
              choice time-based-choice {
                default seconds;
                leaf seconds {
                  tailf:info "Time-based key duration";
                  type uint32 {
                    tailf:info "<120-86400>;;Security association duration in seconds";
                    range "120..86400";
                  }
                  default 3600;
                }
                leaf days {
                  tailf:info "Time-based key duration in days";
                  type uint8 {
                    tailf:info "<1-30>;;Security association duration in days";
                    range "1..30";
                  }
                }
              }
            }

            // crypto ipsec profile * / set security-association idle-time
            container idle-time {
              tailf:info "Automatically delete IPSec SAs after a given idle period.";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf seconds {
                tailf:cli-drop-node-name;
                type uint32 {
                  tailf:info "<60-86400>;;Idle time at which IPSec SAs are deleted";
                  range "60..86400";
                }
              }
              leaf default {
                tailf:info "All SAs idle-out reset to default peer";
                type empty;
              }
            }

            // crypto ipsec profile * / set security-association replay
            container replay {
              tailf:info "Set replay checking.";
              leaf disable {
                tailf:info "Disable replay checking";
                type empty;
              }
              leaf window-size {
                tailf:info "Set replay window size.";
                type ipsec-window-size-type;
              }
            }

            // crypto ipsec profile * / set security-association dummy
            container dummy {
              tailf:info "Enable transmitting dummy packets";
              choice dummy-choice {
                leaf pps {
                  tailf:info "Simulated traffic rate (in pps)";
                  type uint8 {
                    tailf:info "<0-25>;;Rate of simulated traffic (in PPS)";
                    range "0..25";
                  }
                }
                leaf seconds {
                  tailf:info "Simulated traffic rate (in seconds)";
                  type uint16 {
                    tailf:info "<1-3600>;;Rate of simulated traffic (seconds between packets)";
                    range "1..3600";
                  }
                }
              }
            }

            // crypto ipsec profile * / set security-association ecn
            leaf ecn {
              tailf:info "Handling of ECN bit";
              tailf:cli-full-command;
              type enumeration {
                enum discard {
                  tailf:info "Discard the Explicit Congestion Notification bits on decryption";
                }
                enum propagate {
                  tailf:info "Propagate the Explicit Congestion Notification bits on decryption (RFC4301)";
                }
              }
            }
          }

          // crypto ipsec profile * / set security-policy limit
          container security-policy {
            tailf:info "Maximum number of Security Policy entries that can be negotiated with the peer";
            leaf limit {
              tailf:info "limit;;0 - 50000";
              type uint16 {
                tailf:info "<0-50000>;;limit";
                range "0..50000";
              }
            }
          }

          // crypto ipsec profile * / set transform-set *
          leaf-list transform-set {
            tailf:info "Specify list of transform sets in priority order";
            tailf:cli-flat-list-syntax;
            tailf:cli-replace-all;
            tailf:non-strict-leafref {
              path "../../../../../crypto/ipsec/transform-set/name";
            }
            type string {
              tailf:info "WORD;;Proposal tag";
            }
          }

          // crypto ipsec profile * / set pfs
          leaf pfs {
            tailf:info "Specify pfs settings";
            tailf:cli-full-command;
            type isakmp-pfs-type;
          }

          // crypto ipsec profile * / set identity
          leaf identity {
            tailf:info "Identity restriction.";
            type string {
              tailf:info "WORD;;Identity name";
            }
          }

          // crypto ipsec profile * / set mixed-mode
          leaf mixed-mode {
            tailf:info "Turn on IPSec mixed-mode";
            tailf:cli-full-command;
            type empty;
          }

          // crypto ipsec profile * / set isakmp-profile
          // crypto ipsec profile * / set ikev2-profile
          choice ike-profile {
            leaf isakmp-profile {
              tailf:info "Specify isakmp Profile";
              tailf:non-strict-leafref {
                path "../../../../isakmp/profile/name";
              }
              type string {
                tailf:info "WORD;;Name the isakmp profile";
              }
            }
            leaf ikev2-profile {
              tailf:info "Specify ikev2 Profile";
              tailf:non-strict-leafref {
                path "../../../../ikev2/profile/name";
              }
              type string {
                tailf:info "WORD;;Profile name";
              }
            }
          }
        }

        // crypto ipsec profile * / redundancy
        container redundancy {
          tailf:info "Configure HA for this ipsec profile";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf name {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type string {
              tailf:info "WORD;;Redundancy group name";
            }
          }
          leaf stateful {
            tailf:info "enable stateful failover";
            type empty;
          }
        }

        // crypto ipsec profile * / responder-only
        leaf responder-only {
          tailf:info "Do not initiate SAs from this device";
          tailf:cli-full-command;
          type empty;
        }

        // crypto ipsec profile * / reverse-route
        container reverse-route {
          tailf:info "Reverse Route Injection.";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          presence true;
          leaf remote-peer {
            tailf:info "Create route in route table for remote tunnel endpoint";
            tailf:cli-optional-in-sequence;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IPv4 address overrides remote tunnel endpoint";
            }
          }
          leaf gateway {
            tailf:info "Force encrypted traffic via this preferred gateway";
            tailf:cli-optional-in-sequence;
            when "../remote-peer" {
              tailf:dependency "../remote-peer";
            }
            type empty;
          }
          leaf static {
            tailf:info "Create routes based on static ACLs permanently";
            type empty;
          }
        }
      }
    }

    // crypto call admission limit
    container call {
      tailf:info "Configure Crypto Call Admission Control";
      container admission {
        tailf:info "Configure Crypto Call Admission Control";
        container limit {
          tailf:info "Configure Crypto Call Admission Control limits";

          // crypto call admission limit ike
          container ike {
            tailf:info "Configure Crypto Call Admission Control active IKE SA limit";

            // crypto call admission limit ike in-negotiation-sa
            leaf in-negotiation-sa {
              tailf:info "Maximum number of in-negotiation IKE SAs allowed";
              type uint32 {
                tailf:info "<10-99999>;;maximum in-negotiation IKE SA limit. Default 1000";
                range "10..99999";
              }
              default 1000;
            }
          }
        }
      }
    }

    // crypto identity *
    list identity {
      tailf:info "Enter a crypto identity list";
      tailf:cli-mode-name "config-crypto-identity";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Crypto identity tag";
        }
      }

      // crypto identity * / description
      uses description-grouping;

      // crypto identity * / dn *
      list dn {
        tailf:info "Distinguished name identifier";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-show-long-obu-diffs;
        ordered-by user;
        key name;
        leaf name {
          type string {
            tailf:info "LINE;;Distinguished name qualifier";
          }
        }
      }
    }

    // crypto gdoi
    container gdoi {
      tailf:info "Configure GDOI policy";

      // crypto gdoi group *
      list group {
        tailf:info "Define a GDOI group";
        tailf:cli-mode-name "config-gdoi-group";
        key name;
        leaf name {
          tailf:cli-disallow-value "ipv6";
          type string {
            tailf:info "WORD;;Group Name";
          }
        }
        leaf ipv6 {
          tailf:cli-prefix-key;
          type empty;
        }

        // crypto gdoi group * / identify
        container identity {
          tailf:info "Set the identity of the group";
          choice identify-choice {
            leaf number {
              tailf:info "Set the identity of the group as a number";
              type uint32 {
                tailf:info "<0-2147483647>;;Set the group number";
              }
            }
            container address {
              tailf:info "Set the identity of the group as an address";
              leaf ipv4 {
                tailf:info "Set the identity of the group as an IPv4 address";
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Group IPv4 address";
                }
              }
            }
          }
        }

        // crypto gdoi group * / server
        container server {
          tailf:info "Set the group server for of the group";

          // crypto gdoi group * / server address ipv4 *
          container address {
            tailf:info "Identify the group server by address";
            list ipv4 {
              tailf:info "Set the IPv4 address of the group server";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key name;
              leaf name {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Group server IPv4 address";
                }
              }
            }
          }

          // crypto gdoi group * / server local
          container local {
            tailf:info "Identify a group server defined locally";
            tailf:cli-add-mode;
            tailf:cli-mode-name "gdoi-local-server";
            tailf:cli-diff-delete-before "../address";
            presence true;
            uses crypto-gdoi-local-server-grouping;
          }
        }

        // crypto gdoi group * / client
        container client {
          tailf:info "Set the group client management/register interface";

          // crypto gdoi group * / client status active-sa track
          container status {
            tailf:info "group-member status";
            container active-sa {
              tailf:info "TEK SA with positive remaining lifetime";
              leaf track {
                tailf:info "enable stub tracking object";
                tailf:non-strict-leafref {
                  path "../../../../../../../track/track-object/object-number";
                }
                type uint16 {
                  tailf:info "<1-1000>;;Tracking object number";
                  range "1..1000";
                }
              }
            }
          }

          // crypto gdoi group * / client recovery-check interval
          container recovery-check {
            tailf:info "Specify GM recovery check parameters";
            leaf interval {
              tailf:info "Waiting period(sec) between consecutive recovery registrations";
              type uint16 {
                tailf:info "<100-1000>;;Waiting period seconds";
                range "100..1000";
              }
            }
          }

          // crypto gdoi group * / client registration interface
          container registration {
            tailf:info "Set the group client management/register interface";
            container interface {
              tailf:info "Set the group client management/register interface";
              uses interface-name-grouping;
            }
          }

          // crypto gdoi group * / client fail-close revert
          container fail-close {
            tailf:info "Enable/Disable Fail Close Revert feature";
            leaf revert {
              tailf:info "Enable/Disable Fail Close revert on GM, By Default its disabled";
              type empty;
            }
          }
        }
      }
    }

    // crypto dynamic-map *
    list dynamic-map {
      tailf:info "Specify a dynamic crypto map template";
      tailf:cli-mode-name "config-crypto-map";
      key "name map-entry";
      leaf name {
        type string {
          tailf:info "WORD;;Dynamic crypto map template tag";
        }
      }
      leaf map-entry {
        type uint32 {
          tailf:info "<1-65535>;;Sequence to insert into dynamic-map entry";
        }
      }

      // crypto dynamic-map * / set
      container set {
        tailf:info "Set values for encryption/decryption";

        // crypto dynamic-map * / set security-association
        container security-association {
          tailf:info "Security association parameters";

          // crypto dynamic-map * / set security-association level per-host
          container level {
            tailf:info "specify a security association granularity level for identities";
            leaf per-host {
              tailf:info "granularity to host level";
              type empty;
            }
          }

          // crypto dynamic-map * / set security-association dfbit
          leaf dfbit {
            tailf:info "Handling of encapsulated DF bit.";
            tailf:cli-full-command;
            type enumeration {
              enum clear {
                 tailf:info "Clear DF bit for encapsulated packets.";
              }
              enum copy {
                 tailf:info "Copy DF bit from inner for encapsulated packets.";
              }
              enum set {
                 tailf:info "Set DF bit for encapsulated packets.";
              }
            }
          }

          // crypto dynamic-map * / set security-association lifetime
          container lifetime {
            tailf:info "security association lifetime";
            leaf kilobytes {
              tailf:info "Volume-based key duration";
              type union {
                type uint32 {
                  tailf:info "<2560-4294967295>;;Security association duration in kilobytes encrypted";
                  range "2560..4294967295";
                }
                type enumeration {
                  enum disable {
                                tailf:info "Disable Volume-based Rekey";
                  }
                }
              }
            }
            choice days-seconds-choice {
              leaf days {
                tailf:info "Time-based key duration in days";
                type uint8 {
                  tailf:info "<1-30>;;Security association duration in days";
                  range "1..30";
                }
              }
              leaf seconds {
                tailf:info "Time-based key duration in seconds";
                type uint32 {
                  tailf:info "<120-2592000>;;Security association duration in seconds";
                  range "120..2592000";
                }
                default 3600;
              }
            }
          }

          // crypto dynamic-map * / set security-association idle-time
          container idle-time {
            tailf:info "Automatically delete IPSec SAs after a given idle period.";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf seconds {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<60-86400>;;Idle time at which IPSec SAs are deleted";
                range "60..86400";
              }
            }
            leaf default {
              tailf:info "All SAs idle-out reset to default peer";
              type empty;
            }
          }

          // crypto dynamic-map * / set security-association replay
          container replay {
            tailf:info "Set replay checking.";
            leaf disable {
              tailf:info "Disable replay checking";
              type empty;
            }
            leaf window-size {
              tailf:info "Set replay window size.";
              type enumeration {
                enum "1024";
                enum "512";
                enum "256";
                enum "128";
                enum "64";
              }
              default "64";
            }
          }

          // crypto dynamic-map * / set security-association dummy
          container dummy {
            tailf:info "Enable transmitting dummy packets";
            choice dummy-choice {
              leaf pps {
                tailf:info "Simulated traffic rate (in pps)";
                type uint8 {
                  tailf:info "<0-25>;;Rate of simulated traffic (in PPS)";
                  range "0..25";
                }
              }
              leaf seconds {
                tailf:info "Simulated traffic rate (in seconds)";
                type uint16 {
                  tailf:info "<1-3600>;;Rate of simulated traffic (seconds between packets)";
                  range "1..3600";
                }
              }
            }
          }

          // crypto dynamic-map * / set security-association ecn
          leaf ecn {
            tailf:info "Handling of ECN bit";
            tailf:cli-full-command;
            type enumeration {
              enum discard {
                tailf:info "Discard the Explicit Congestion Notification bits on decryption";
              }
              enum propagate {
                tailf:info "Propagate the Explicit Congestion Notification bits on decryption (RFC4301)";
              }
            }
          }
        }

        // crypto dynamic-map * / set isakmp-profile
        leaf isakmp-profile {
          tailf:info "Specify isakmp Profile";
          tailf:non-strict-leafref {
            path "../../../../crypto/isakmp/profile/name";
          }
          type string {
            tailf:info "WORD;;Name the isakmp profile";
          }
        }

        // crypto dynamic-map * / set transform-set *
        leaf-list transform-set {
          tailf:info "Specify list of transform sets in priority order";
          tailf:cli-flat-list-syntax;
          tailf:cli-replace-all;
          tailf:non-strict-leafref {
            path "../../../../crypto/ipsec/transform-set/name";
          }
          type string {
            tailf:info "WORD;;Proposal tag";
          }
        }

        // crypto dynamic-map * / set pfs
        leaf pfs {
          tailf:info "Specify pfs settings";
          tailf:cli-full-command;
          type isakmp-pfs-type;
        }
      }

      // crypto dynamic-map * / match address
      container match {
        tailf:info "Match values.";
        leaf address {
          tailf:info "Match address of packets to encrypt";
          type ext-acl-type;
        }
      }

      // crypto dynamic-map * / reverse-route
      container reverse-route {
        tailf:info "Reverse Route Injection";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        leaf remote-peer {
          tailf:info "Create route in route table for remote tunnel endpoint";
          tailf:cli-optional-in-sequence;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IPv4 address overrides remote tunnel endpoint";
          }
        }
        leaf gateway {
          tailf:info "Force encrypted traffic via this preferred gateway";
          tailf:cli-optional-in-sequence;
          when "../remote-peer" {
            tailf:dependency "../remote-peer";
          }
          type empty;
        }
        leaf static {
          tailf:info "Create routes based on static ACLs permanently";
          type empty;
        }
      }
    }

    // crypto gkm group *
    // crypto gkm group ipv6 *
    container gkm {
      tailf:info "Configure GKM (Group Key Management, GDOI or G-IKEv2) Policy";
      list group {
        tailf:info "Configure a GKM (Group Key Management, GDOI or G-IKEv2) Group";
        tailf:cli-mode-name "config-gkm-group";
        key name;
        leaf name {
          tailf:cli-disallow-value "ipv6";
          type string {
            tailf:info "WORD;;Group Name";
          }
        }
        leaf ipv6 {
          tailf:info "IPv6 GKM (Group Key Management) Group";
          tailf:cli-prefix-key;
          type empty;
        }

        // crypto gkm group * / identify
        container identity {
          tailf:info "Set the identity of the group";
          choice identity-choice {
            // crypto gkm group * / identify number
            leaf number {
              tailf:info "Set the identity of the group as a number";
              type uint32 {
                tailf:info "<0-4294967295>;;Set the group number";
              }
            }
            // crypto gkm group * / identify address ipv4
            container address {
              tailf:info "Set the identity of the group as an address";
              leaf ipv4 {
                tailf:info "Set the identity of the group as an IPv4 address";
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Group IPv4 address";
                }
              }
            }
          }
        }

        // crypto gkm group * / server
        container server {
          tailf:info "Set the group server for of the group";

          // crypto gkm group * / server address *
          list address {
            tailf:info "Identify the group server by address";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-show-long-obu-diffs;
            ordered-by user;
            key "protocol address";
            leaf protocol {
              type enumeration {
                enum ipv4 {
                  tailf:info "Set the IPv4 address of the group server";
                }
                enum ipv6 {
                  tailf:info "Set the IPv6 address of the group server";
                }
              }
            }
            leaf address {
              type union {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Group server IPv4 address";
                }
                type inet:ipv6-address {
                  tailf:info "X:X:X:X::X;;Group server IPv6 address";
                }
              }
            }
          }

          // crypto gkm group * / server local
          container local {
            tailf:info "Configure GKM group server defined locally";
            tailf:cli-add-mode;
            tailf:cli-mode-name "gkm-local-server";
            tailf:cli-diff-delete-before "../address";
            presence true;
            uses crypto-gdoi-local-server-grouping;
          }
        }

        // crypto gkm group * / client
        container client {
          tailf:info "Set the group client parameters";

          // crypto gkm group * / client status active-sa track
          container status {
            tailf:info "group-member status";
            container active-sa {
              tailf:info "TEK SA with positive remaining lifetime";
              leaf track {
                tailf:info "enable stub tracking object";
                tailf:non-strict-leafref {
                  path "../../../../../../../track/track-object/object-number";
                }
                type uint16 {
                  tailf:info "<1-1000>;;Tracking object number";
                  range "1..1000";
                }
              }
            }
          }

          // crypto gkm group * / client recovery-check interval
          container recovery-check {
            tailf:info "Specify GM recovery check parameters";
            leaf interval {
              tailf:info "Waiting period(sec) between consecutive recovery registrations";
              type uint16 {
                tailf:info "<100-1000>;;Waiting period seconds";
                range "100..1000";
              }
            }
          }

          // crypto gkm group * / client protocol
          container protocol {
            tailf:info "Group Member Registration & Rekey Protocol";
            leaf gikev2 {
              tailf:info "Use G-IKEv2 Protocol for Registration & Rekey";
              tailf:non-strict-leafref {
                path "../../../../../ikev2/profile/name";
              }
              type string {
                tailf:info "WORD;;IKEv2 Profile Name for G-IKEv2 Registration";
              }
            }
          }

          // crypto gkm group * / client registration interface
          container registration {
            tailf:info "Set the group client management/register interface";
            container interface {
              tailf:info "Set the group client management/register interface";
              uses interface-name-grouping;
            }
          }
        }
      }
    }

    // crypto map *
    list map {
      tailf:info "Enter a crypto map";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-incomplete-command;
      key name;
      leaf name {
        tailf:cli-disallow-value "ipv6";
        tailf:cli-incomplete-command;
        type string {
          tailf:info "WORD;;Crypto map tag";
        }
      }
      leaf ipv6 {
        tailf:cli-prefix-key;
        tailf:cli-optional-in-sequence;
        tailf:cli-delete-container-on-delete;
        type empty;
      }

      // crypto map * local-address
      container local-address {
        tailf:info "Interface to use for local address for this crypto map";
        tailf:cli-optional-in-sequence;
        uses interface-name-grouping;
      }

      // crypto map * gdoi fail-close
      container gdoi {
        tailf:info "Configure crypto map gdoi features";
        tailf:cli-optional-in-sequence;
        container fail-close {
          tailf:info "Configure crypto map on Fail Close mode";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-crypto-map-fail-close";
          presence true;

          // crypto map * gdoi fail-close / match address
          container match {
            tailf:info "Match address of packets for fail-close";
            leaf address {
              tailf:info "Match address of packets for fail-close.";
              type ext-acl-type;
            }
          }

          // crypto map * gdoi fail-close / activate
          leaf activate {
            tailf:info "Activate the crypto map to work in fail-close mode";
            type empty;
          }
        }
      }

      // crypto map * *
      list seq-list {
        tailf:cli-drop-node-name;
        tailf:cli-mode-name "config-crypto-map";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          tailf:cli-suppress-range;
          type uint16 {
            tailf:info "<1-65535>;;Sequence to insert into crypto map entry";
          }
        }

        // crypto map * * gdoi
        // crypto map * * ipsec-manual
        // crypto map * * ipsec-isakmp
        // crypto map * * ckm
        leaf policy {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          tailf:cli-no-value-on-delete;
          tailf:cli-delete-container-on-delete;
          type enumeration {
            enum ipsec-isakmp {
              tailf:info "IPSEC w/ISAKMP";
            }
            enum ipsec-manual {
              tailf:info "IPSEC w/manual keying";
            }
            enum gdoi {
              tailf:info "GDOI";
            }
            enum ckm {
              tailf:info "configure kgs map";
            }
          }
        }

        // crypto map * * ipsec-isakmp dynamic
        leaf dynamic {
          tailf:info "Enable dynamic crypto map support";
          tailf:cli-hide-in-submode;
          tailf:cli-optional-in-sequence;
          tailf:cli-no-name-on-delete;
          tailf:cli-no-value-on-delete;
          tailf:cli-full-command;
          when "../policy = 'ipsec-isakmp'" {
            tailf:dependency "../policy";
          }
          tailf:non-strict-leafref {
            path "../../../../crypto/dynamic-map/name";
          }
          type string {
            tailf:info "WORD;;Name of dynamic-map template";
          }
        }

        // crypto map * * ipsec-isakmp profile
        leaf profile {
          tailf:info "Enable crypto map as a crypto-profile";
          tailf:cli-hide-in-submode;
          tailf:cli-optional-in-sequence;
          tailf:cli-no-name-on-delete;
          tailf:cli-no-value-on-delete;
          tailf:cli-full-command;
          when "../policy = 'ipsec-isakmp'" {
            tailf:dependency "../policy";
          }
          tailf:non-strict-leafref {
            path "../../../../crypto/isakmp/profile/name";
          }
          type string {
            tailf:info "WORD;;Name for this crypto profile";
          }
        }

        // crypto map * * ipsec-isakmp / description
        leaf description {
          tailf:cli-break-sequence-commands;
          tailf:info "Description of the crypto map statement policy";
          tailf:cli-full-command;
          tailf:cli-preformatted;
          tailf:cli-multi-value;
          type string {
            tailf:info "LINE;;A Short description";
          }
        }

        // crypto map * * ipsec-isakmp / set
        // crypto map * * ipsec-manual / set
        // crypto map * * ckm / set
        container set {
          tailf:info "Set values for encryption/decryption";
          when "../policy != 'gdoi'" {
            tailf:dependency "../policy";
          }

          // crypto map * ipsec-isakmp / set session-key
          container session-key {
            tailf:info "Security session key parameters";

            // crypto map * ipsec-isakmp / set session-key inbound
            container inbound {
              tailf:info "Inbound manual security association";

              // crypto map * ipsec-isakmp / set session-key inbound esp
              container esp {
                tailf:info "ESP key";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                leaf spi {
                  tailf:cli-drop-node-name;
                  tailf:cli-incomplete-command;
                  type uint32 {
                    tailf:info "<256-4294967295>;;SPI for security association";
                    range "256..4294967295";
                  }
                }
                leaf cipher {
                  tailf:info "Specify ESP cipher key";
                  tailf:cli-optional-in-sequence;
                  type string {
                    tailf:info "WORD;;security association key value (hex w/o leading 0x)";
                  }
                }
                leaf authenticator {
                  tailf:info "Specify ESP authenticator key";
                  type string {
                    tailf:info "WORD;;security association key value (hex w/o leading 0x)";
                  }
                }
              }

              // crypto map * ipsec-isakmp / set session-key inbound ah
              container ah {
                tailf:info "AH key";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                leaf spi {
                  tailf:cli-drop-node-name;
                  tailf:cli-incomplete-command;
                  type uint32 {
                    tailf:info "<256-4294967295>;;SPI for security association";
                    range "256..4294967295";
                  }
                }
                leaf key {
                  tailf:cli-drop-node-name;
                  type string {
                    tailf:info "WORD;;security association key value (hex w/o leading 0x)";
                  }
                }
              }
            }

            // crypto map * ipsec-isakmp / set session-key outbound
            container outbound {
              tailf:info "Outbound manual security association";

              // crypto map * ipsec-isakmp / set session-key outbound esp
              container esp {
                tailf:info "ESP key";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                leaf spi {
                  tailf:cli-drop-node-name;
                  tailf:cli-incomplete-command;
                  type uint32 {
                    tailf:info "<256-4294967295>;;SPI for security association";
                    range "256..4294967295";
                  }
                }
                leaf cipher {
                  tailf:info "Specify ESP cipher key";
                  tailf:cli-optional-in-sequence;
                  type string {
                    tailf:info "WORD;;security association key value (hex w/o leading 0x)";
                  }
                }
                leaf authenticator {
                  tailf:info "Specify ESP authenticator key";
                  type string {
                    tailf:info "WORD;;security association key value (hex w/o leading 0x)";
                  }
                }
              }

              // crypto map * ipsec-isakmp / set session-key outbound ah
              container ah {
                tailf:info "AH key";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                leaf spi {
                  tailf:cli-drop-node-name;
                  tailf:cli-incomplete-command;
                  type uint32 {
                    tailf:info "<256-4294967295>;;SPI for security association";
                    range "256..4294967295";
                  }
                }
                leaf key {
                  tailf:cli-drop-node-name;
                  type string {
                    tailf:info "WORD;;security association key value (hex w/o leading 0x)";
                  }
                }
              }
            }
          }


          // crypto map * ipsec-isakmp / set transform-set *
          leaf-list transform-set {
            tailf:info "Specify list of transform sets in priority order";
            tailf:cli-flat-list-syntax;
            tailf:cli-replace-all;
            tailf:cli-full-command;
            tailf:non-strict-leafref {
              path "../../../../../crypto/ipsec/transform-set/name";
            }
            max-elements 6;
            type string {
              tailf:info "WORD;;Proposal tag";
            }
          }

          // crypto map * ipsec-isakmp / set isakmp-profile
          leaf isakmp-profile {
            tailf:info "Specify isakmp Profile";
            tailf:non-strict-leafref {
              path "../../../../../crypto/isakmp/profile/name";
            }
            type string {
              tailf:info "WORD;;Name the isakmp profile";
            }
          }

          // crypto map * ipsec-isakmp / set ikev2-profile
          leaf ikev2-profile {
            tailf:info "Specify ikev2 Profile";
            tailf:non-strict-leafref {
              path "../../../../ikev2/profile/name";
            }
            type string {
              tailf:info "WORD;;Name the ikev2 profile";
            }
          }

          // crypto map * ipsec-isakmp / set peer-default *
          //   device: crypto map * ipsec-isakmp / set peer * default
          leaf peer-default {
            tailf:info "Allowed Encryption/Decryption peer default (device: set peer * default) ";
            type inet:host {
              tailf:info "Hostname, A.B.C.D or X:X:X:X::X;;Address of peer";
            }
          }

          // crypto map * ipsec-isakmp / set peer *
          leaf-list peer {
            tailf:info "Allowed Encryption/Decryption peer";
            tailf:cli-list-syntax;
            tailf:cli-full-command;
            type inet:host {
              tailf:info "Hostname, A.B.C.D or X:X:X:X::X;;Address of peer";
            }
          }

          // crypto map * ipsec-isakmp / set security-association
          container security-association {
            tailf:info "Security association parameters";

            // crypto map * ipsec-isakmp / set security-association level per-host
            container level {
              tailf:info "specify a security association granularity level for identities";
              leaf per-host {
                tailf:info "granularity to host level";
                type empty;
              }
            }

            // crypto map * ipsec-isakmp / set security-association dfbit
            leaf dfbit {
              tailf:info "Handling of encapsulated DF bit.";
              tailf:cli-full-command;
              type enumeration {
                enum clear {
                  tailf:info "Clear DF bit for encapsulated packets.";
                }
                enum copy {
                  tailf:info "Copy DF bit from inner for encapsulated packets.";
                }
                enum set {
                  tailf:info "Set DF bit for encapsulated packets.";
                }
              }
            }

            // crypto map * ipsec-isakmp / set security-association lifetime
            container lifetime {
              tailf:info "security association lifetime";
              leaf kilobytes {
                tailf:info "Volume-based key duration";
                type union {
                  type uint32 {
                    tailf:info "<2560-4294967295>;;Security association duration in kilobytes encrypted";
                    range "2560..4294967295";
                  }
                  type enumeration {
                    enum disable {
                      tailf:info "Disable Volume-based Rekey";
                    }
                  }
                }
              }
              choice days-seconds-choice {
                leaf days {
                  tailf:info "Time-based key duration in days";
                  type uint8 {
                    tailf:info "<1-30>;;Security association duration in days";
                    range "1..30";
                  }
                }
                leaf seconds {
                  tailf:info "Time-based key duration in seconds";
                  type uint32 {
                    tailf:info "<120-2592000>;;Security association duration in seconds";
                    range "120..2592000";
                  }
                  default 3600;
                }
              }
            }

            // crypto map * ipsec-isakmp / set security-association idle-time
            container idle-time {
              tailf:info "Automatically delete IPSec SAs after a given idle period.";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf seconds {
                tailf:cli-drop-node-name;
                type uint32 {
                  tailf:info "<60-86400>;;Idle time at which IPSec SAs are deleted";
                  range "60..86400";
                }
              }
              leaf default {
                tailf:info "All SAs idle-out reset to default peer";
                type empty;
              }
            }

            // crypto map * ipsec-isakmp / set security-association replay
            container replay {
              tailf:info "Set replay checking.";
              leaf disable {
                tailf:info "Disable replay checking";
                type empty;
              }
              leaf window-size {
                tailf:info "Set replay window size.";
                type enumeration {
                  enum "1024";
                  enum "512";
                  enum "256";
                  enum "128";
                  enum "64";
                }
                default "64";
              }
            }

            // crypto map * ipsec-isakmp / set security-association dummy
            container dummy {
              tailf:info "Enable transmitting dummy packets";
              choice dummy-choice {
                leaf pps {
                  tailf:info "Simulated traffic rate (in pps)";
                  type uint8 {
                    tailf:info "<0-25>;;Rate of simulated traffic (in PPS)";
                    range "0..25";
                  }
                }
                leaf seconds {
                  tailf:info "Simulated traffic rate (in seconds)";
                  type uint16 {
                    tailf:info "<1-3600>;;Rate of simulated traffic (seconds between packets)";
                    range "1..3600";
                  }
                }
              }
            }

            // crypto map * ipsec-isakmp / set security-association ecn
            leaf ecn {
              tailf:info "Handling of ECN bit";
              tailf:cli-full-command;
              type enumeration {
                enum discard {
                  tailf:info "Discard the Explicit Congestion Notification bits on decryption";
                }
                enum propagate {
                  tailf:info "Propagate the Explicit Congestion Notification bits on decryption (RFC4301)";
                }
              }
            }
          }

          // crypto map * ipsec-isakmp / set pfs
          leaf pfs {
            tailf:info "Specify pfs settings";
            tailf:cli-full-command;
            type isakmp-pfs-type;
          }

          // crypto map * * gdoi / set reverse-route
          container reverse-route {
            tailf:info "Reverse Route Injection.";

            // crypto map * * gdoi / set reverse-route tag distance
            leaf distance {
              tailf:info "Distance metric for this static route";
              type uint8 {
                tailf:info "<1-255>;;Routing distance";
                range "1..255";
              }
              default 1;
            }

            // crypto map * * gdoi / set reverse-route tag
            leaf tag {
              tailf:info "Create route and tag it";
              type uint32 {
                tailf:info "<1-4294967295>;;Routing Tag ID";
                range "1..4294967295";
              }
            }
          }

          // crypto map * * gdoi / set group
          leaf group {
            tailf:info "Set the san group parameters";
            tailf:non-strict-leafref {
              path "../../../../gkm/group/name";
            }
            type string {
              tailf:info "WORD;;Set GDOI san group name";
            }
          }
        }

        // crypto map * * gdoi / set
        container gdoi-set {
          tailf:cli-break-sequence-commands;
          tailf:cli-drop-node-name;
          when "../policy = 'gdoi'" {
            tailf:dependency "../policy";
          }
          container set {
            tailf:info "Set values for encryption/decryption";
            leaf group {
              tailf:info "Set the secure group parameters";
              tailf:non-strict-leafref {
                path "../../../../../../crypto/gdoi/group/name";
              }
              type string {
                tailf:info "WORD;;Set the group name";
              }
            }
          }
        }

        // crypto map * * gdoi / match
        container match {
          tailf:info "Match values.";
          leaf address {
            tailf:info "Match address of packets to encrypt";
            type ext-ip-acl-type;
          }
        }

        // crypto map * * ipsec-isakmp / reverse-route
        container reverse-route {
          tailf:info "Reverse Route Injection";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          presence true;
          leaf remote-peer {
            tailf:info "Create route in route table for remote tunnel endpoint";
            tailf:cli-optional-in-sequence;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IPv4 address overrides remote tunnel endpoint";
            }
          }
          leaf gateway {
            tailf:info "Force encrypted traffic via this preferred gateway";
            tailf:cli-optional-in-sequence;
            when "../remote-peer" {
              tailf:dependency "../remote-peer";
            }
            type empty;
          }
          leaf static {
            tailf:info "Create routes based on static ACLs permanently";
            type empty;
          }
        }

        // crypto map * * ipsec-isakmp / qos pre-classify
        container qos {
          tailf:info "Quality of Service related commands";
          leaf pre-classify {
            tailf:info "Enable QOS classification before packets are tunnel encapsulated";
            type empty;
          }
        }
      }
    }

    // crypto ssl
    container ssl {
      tailf:info "Configure Crypto SSL Options";

      // crypto ssl proposal *
      list proposal {
        tailf:info "Define ssl Proposal";
        tailf:cli-mode-name "config-crypto-ssl-proposal";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of ssl Proposal";
          }
        }

        // crypto ssl proposal * / protection
        leaf-list protection {
          tailf:info "Specify the protection algorithms";
          tailf:cli-flat-list-syntax;
          type enumeration {
            enum rsa-3des-ede-sha1 {
              tailf:info "RSA, 3DES and SHA1";
            }
            enum rsa-rc4128-md5 {
              tailf:info "RSA, RC4 and MD5";
            }
            enum rsa-aes128-sha1 {
              tailf:info "RSA, AES128 and SHA1";
            }
            enum rsa-aes256-sha1 {
              tailf:info "RSA, AES256 and SHA1";
            }
          }
        }
      }

      // crypto ssl authorization policy *
      container authorization {
        tailf:info "ssl authorization";
        list policy {
          tailf:info "Crypto SSL authorization policy";
          tailf:cli-mode-name "config-crypto-ssl-auth-policy";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Name of the policy";
            }
          }

          // crypto ssl authorization policy * / pool
          leaf pool {
            tailf:info "Specify pool";
            type string {
              tailf:info "WORD;;pool";  // ip local pool mypool
            }
          }

          // crypto ssl authorization policy * / dns
          container dns {
            tailf:info "Specify DNS Addresses";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf primary-server {
              tailf:cli-drop-node-name;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Primary DNS IP address";
              }
            }
            leaf secondary-server {
              tailf:cli-drop-node-name;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Secondary DNS IP address";
              }
            }
          }

          // crypto ssl authorization policy * / banner
          leaf banner {
            tailf:info "Specify banner";
            tailf:cli-multi-value;
            type string {
              tailf:info "LINE;;banner string";
            }
          }

          // crypto ssl authorization policy * / def-domain
          leaf def-domain {
            tailf:info "Specify def_domain";
            type string {
              tailf:info "WORD;;def_domain string";
            }
          }
        }
      }

      // crypto ssl policy *
      list policy {
        tailf:info "Define SSL policies";
        tailf:cli-mode-name "config-crypto-ssl-policy";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of ssl policy";
          }
        }

        // crypto ssl policy * / ssl proposal
        container ssl {
          tailf:info "Specify ssl proposal";
          leaf proposal {
            tailf:info "Specify Proposal";
            type string {
              tailf:info "WORD;;Specify the name of proposal to be attached";
            }
          }
        }

        // crypto ssl policy * / pki
        container pki {
          tailf:info "Trustpoint options";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf trustpoint {
            tailf:info "Certificate Trustpoint to authenticate clients";
            tailf:cli-incomplete-command;
            type string {
              tailf:info "WORD;;Trustpoint name";
            }
          }
          leaf sign {
            tailf:info "Sign";
            type empty;
          }
        }

        // crypto ssl policy * / ip address
        container ip {
          tailf:info "ip options";
          container address {
            tailf:info "ip address";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf local {
              tailf:info "ip address local";
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IP address";
              }
            }
            leaf port {
              tailf:info "port configuration";
              type union {
                type uint16 {
                  tailf:info "443;;Default secure port";
                  range "443";
                }
                type uint16 {
                  tailf:info "<1025-65535>;;Port number";
                  range "1025..65535";
                }
              }
            }
          }
        }

        // crypto ssl policy * / shutdown
        leaf shutdown {
          tailf:info "shutdown";
          type empty;
        }
      }

      // crypto ssl profile *
      list profile {
        tailf:info "Define ssl Profiles";
        tailf:cli-mode-name "config-crypto-ssl-profile";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of ssl profile";
          }
        }

        // crypto ssl profile * / match
        container match {
          tailf:info "Specify the type to match";

          // crypto ssl profile * / match policy
          leaf policy {
            tailf:info "Specify Policy";
            tailf:cli-remove-before-change;
            tailf:non-strict-leafref {
              path "../../../../../crypto/ssl/policy/name";
            }
            type string {
              tailf:info "WORD;;Specify the name of policy to be attached";
            }
          }

          // crypto ssl profile * / match url
          leaf url {
            tailf:info "Specify url";
            type string {
              tailf:info "WORD;;gateway[:port]/domain (specify port if not 443)";
            }
          }
        }

        // crypto ssl profile * / aaa
        container aaa {
          tailf:info "aaa";

          // crypto ssl profile * / aaa authentication
          container authentication {
            tailf:info "aaa authentication";
            leaf list {
              tailf:info "aaa authentication list";
              type string {
                tailf:info "WORD;;Specify the list name";
              }
            }
          }

          // crypto ssl profile * / aaa authorization
          container authorization {
            tailf:info "aaa authorization";
            container user {
              tailf:info "AAA user authorization";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf list {
                tailf:info "AAA method list";
                type string {
                  tailf:info "WORD;;AAA list name";
                }
              }
              leaf aaa-username {
                tailf:cli-drop-node-name;
                type string {
                  tailf:info "WORD;;AAA username";
                }
              }
            }
          }
        }

        // crypto ssl profile * / authentication remote user-credentials
        container authentication {
          tailf:info "Specify authentication mode";
          container remote {
            tailf:info "remote server";
            leaf user-credentials {
              tailf:info "User credential mode";
              type empty;
            }
          }
        }

        // crypto ssl profile * / shutdown
        leaf shutdown {
          tailf:info "shutdown";
          type empty;
        }
      }
    }

    // crypto tls-tunnel *
    list tls-tunnel {
      tailf:info "Configure Crypto TLS-Tunnel Options";
      tailf:cli-mode-name "config-crypto-tls-tunnel";
      ios:shutdown-before-modify "shutdown";
      key name;
      leaf name {
        tailf:cli-diff-dependency "../../../interface";
        type string {
          tailf:info "WORD;;Name of TLS-Tunnel";
        }
      }

      // crypto tls-tunnel * / server *
      list server {
        tailf:info "Specify the Server Address";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        max-elements 2;
        key "protocol address";
        leaf protocol {
          type enumeration {
            enum ipv4 {
              tailf:info "IPv4 address";
            }
            enum ipv6 {
              tailf:info "IPv6 address";
            }
          }
        }
        leaf address {
          type union {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IPv4 Address";
            }
            type inet:ipv6-address {
              tailf:info "X:X:X:X::X;;IPv6 Address";
            }
          }
        }
        leaf port {
          tailf:info "Port Configuration";
          type union {
            type uint16 {
              tailf:info "Default Secure Port";
              range "443";
            }
            type uint16 {
              tailf:info "<1025-65535>;;Port Number";
              range "1025..65535";
            }
          }
        }
      }

      // crypto tls-tunnel * / protection
      leaf protection {
        tailf:info "Cipher-Suite";
        tailf:cli-full-command;
        type enumeration {
          enum dhe-psk-aes128-cbc-sha1 {
            tailf:info "DHE, PSK, AES128-CBC and SHA1";
          }
          enum dhe-psk-aes256-cbc-sha1 {
            tailf:info "DHE, PSK, AES256-CBC and SHA1";
          }
          enum psk-aes128-cbc-sha1 {
            tailf:info "PSK, AES128-CBC and SHA1";
          }
          enum psk-aes256-cbc-sha1 {
            tailf:info "PSK, AES256-CBC and SHA1";
          }
        }
        default dhe-psk-aes256-cbc-sha1;
      }

      // crypto tls-tunnel * / local-interface *
      list local-interface {
        tailf:info "Specify the WAN interfaces";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          tailf:cli-diff-dependency "../../../../interface";
          type string {
            tailf:info "WORD;;Interface Name";
          }
        }
        leaf priority {
          tailf:info "Specify the Interface Priority (1 is highest)";
          type uint8 {
            tailf:info "<1-3>;;rank";
            range "1..3";
          }
        }
      }

      // crypto tls-tunnel * / psk id key
      container psk {
        tailf:info "Specify the Pre-Shared Key";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf id {
          tailf:info "Key Identity";
          tailf:cli-incomplete-command;
          type string {
            tailf:info "WORD;;identity";
          }
        }
        container key {
          tailf:info "Specify the Key";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          uses crypto-key-grouping {
            refine "secret" {
              cli:secret " key <SECRET>";
            }
          }
        }
      }

      // crypto tls-tunnel * / overlay-address
      container overlay-address {
        tailf:info "Specify the Overlay Address";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-diff-dependency "../../../ip/vrf";
        tailf:cli-diff-dependency "../../../vrf/definition";
        leaf address {
          tailf:cli-drop-node-name;
          tailf:cli-remove-before-change;
          type union {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP Address";
            }
            type inet:ipv6-address {
              tailf:info "X:X:X:X::X;;IPv6 Address";
            }
          }
        }
        leaf vrf {
          tailf:info "VRF name";
          type string {
            tailf:info "WORD;;VRF";
          }
        }
      }

      // crypto tls-tunnel * / shutdown
      leaf shutdown {
        tailf:info "Shutdown the TLS-Tunnel";
        tailf:cli-show-no; // entry created with 'shutdown' set, must send 'no shutdown'
        tailf:cli-full-command;
        type empty;
      }
    }
  }


  /// ========================================================================
  /// transport-map
  /// ========================================================================

  container transport-map {
    tailf:info "Configure transport map";
    container type {
      tailf:info "Specify transport map type";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;

      // transport-map type persistent *
      list persistent {
        tailf:info "Persistent transport types";
        tailf:cli-mode-name "config-tmap";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Transport map name";
          }
        }
        leaf type {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type enumeration {
            enum ssh {
              tailf:info "Persistent ssh transport type";
            }
            enum telnet {
              tailf:info "Persistent telnet transport type";
            }
            enum webui {
              tailf:info "Persistent webui transport type";
            }
          }
        }

        // transport-map type persistent * / authentication-retries
        leaf authentication-retries {
          tailf:info "Specify number of authentication retries";
          type uint8 {
            tailf:info "<0-5>;;Number of authentication retries";
            range "0..5";
          }
        }

        // transport-map type persistent * / rsa keypair-name
        container rsa {
          tailf:info "Configure RSA key-pair";
          leaf keypair-name {
            tailf:info "Configure RSA key-pair";
            type string {
              tailf:info "WORD;;RSA key-pair name";
            }
          }
        }

        // transport-map type persistent * / transport
        container transport {
          tailf:info "Configure interface(s) for the transport";
          container interface {
            tailf:info "Configure interface(s) for the transport";
            tailf:cli-compact-syntax;
            uses interface-name-grouping;
          }
        }
      }
    }
  }


  /// ========================================================================
  /// macro
  /// ========================================================================

  container macro {
    tailf:info "Create a command macro";

    // macro auto
    container auto {
      tailf:info "Macro autoexecution settings";

      // macro auto execute *
      list execute {
        tailf:info "Map event trigger to macro";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          tailf:cli-multi-word-key;
          type string {
            tailf:info "WORD;;event trigger macro line";
          }
        }
      }

      // macro auto global
      container global {
        tailf:info "Macro auto execution configuration";

        // macro auto global processing
        leaf processing {
          tailf:info "Enable auto smartports, all ports enabled by default";
          type empty;
        }
      }

      // no macro auto monitor
      leaf monitor {
        tailf:info "device classifier configuration";
        tailf:cli-boolean-no;
        type boolean;
        default true;
      }
    }

    // macro global description
    container global {
      tailf:info "Enter global macro apply";
      uses description-grouping;
    }

    // macro name *
    list name {
      tailf:info "Name of the macro";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-incomplete-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Name of the macro to apply";
        }
      }
      leaf commands {
        tailf:cli-drop-node-name;
        tailf:cli-no-value-on-delete;
        type string {
          tailf:info "LINE;;Quoted string. Use \\r\\n for newline. End delimeter @ is added automatically.";
        }
      }
    }
  }


  /// ========================================================================
  /// buffers
  /// ========================================================================

  container buffers {
    tailf:info "Adjust system buffer pool parameters";

    // buffers fastswitching permanent


    // buffers tune automatic
    container tune {
      tailf:info "Tune system buffer pool parameters";
      leaf automatic {
        tailf:info "Automatic tuning";
        type empty;
      }
    }

    // buffers *
    list pool-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        type enumeration {
          enum small {
            tailf:info "Small buffers";
          }
          enum middle {
            tailf:info "Middle buffers";
          }
          enum big {
            tailf:info "Big buffers";
          }
          enum verybig {
            tailf:info "Very Big buffers";
          }
          enum large {
            tailf:info "Large buffers";
          }
          enum huge {
            tailf:info "Huge buffers";
          }
          enum fastswitching {
            tailf:info "Fast switching particle pool";
          }
        }
      }

      // buffers * permanent
      leaf permanent {
        tailf:info "Number of permanent buffers";
        type uint16 {
          tailf:info "<0-65536>;;Number of buffers";
        }
      }

      // buffers * max-free
      leaf min-free {
        tailf:info "Minimum number of free buffers";
        type uint16 {
          tailf:info "<0-65536>;;Number of buffers";
        }
      }

      // buffers * max-free
      leaf max-free {
        tailf:info "Maximum number of free buffers";
        tailf:cli-diff-dependency "../min-free";
        type uint16 {
          tailf:info "<0-65536>;;Number of buffers";
        }
      }

      // buffers * size
      leaf size {
        tailf:info "Size of buffers";
        type uint32 {
          tailf:info "<NUM>;;Size of buffers";
        }
      }
    }
  }


  /// ========================================================================
  /// track
  /// ========================================================================

  container track {
    tailf:info "Object tracking configuration commands";

    // track timer
    container timer {
      tailf:info "Polling interval timers";

      // track timer interface
      container interface {
        tailf:info "Interface polling timer";
        uses track-timer-grouping;
      }

      // track timer ip
      container ip {
        tailf:info "IP protocol";
        // track timer ip route
        container route {
          tailf:info "IP route polling timer";
          uses track-timer-grouping;
        }
        // track timer ip sla
        container sla {
          tailf:info "IP SLA polling timer";
          uses track-timer-grouping;
        }
      }

      // track timer ipv6 route
      container ipv6 {
        tailf:info "IPv6 protocol";
        container route {
          tailf:info "IPv6 route polling timer";
          uses track-timer-grouping;
        }
      }

      // track timer list
      container list {
        tailf:info "Boolean list polling timer";
        uses track-timer-grouping;
      }

      // track timer stub-object
      container stub-object {
        tailf:info "EEM stub polling timer";
        uses track-timer-grouping;
      }
    }

    // track resolution
    container resolution {
      tailf:info "Tracking resolution parameters";

      // track resolution ip route
      container ip {
        tailf:info "IP protocol";
        container route {
          tailf:info "Route metric resolution";
          // track resolution ip route static
          leaf static {
            tailf:info "Static route metric resolution";
            type uint32 {
              tailf:info "<1-100000>;;Resolution value";
              range "1..100000";
            }
          }
          // track resolution ip route EIGRP
          leaf EIGRP {
            tailf:info "EIGRP route metric resolution";
            tailf:cli-case-insensitive;
            type uint32 {
              tailf:info "<256-40000000>;;Resolution value";
              range "256..40000000";
            }
          }
          // track resolution ip route OSPF
          leaf OSPF {
            tailf:info "OSPF route metric resolution";
            tailf:cli-case-insensitive;
            type uint16 {
              tailf:info "<1-1562>;;Resolution value";
              range "1..1562";
            }
          }
          // track resolution ip route ISIS
          leaf ISIS {
            tailf:info "ISIS route metric resolution";
            tailf:cli-case-insensitive;
            type uint16 {
              tailf:info "<1-1000>;;Resolution value";
              range "1..1000";
            }
          }
          // track resolution ip route BGP
          leaf BGP {
            tailf:info "BGP route metric resolution";
            tailf:cli-case-insensitive;
            type uint32 {
              tailf:info "<256-40000000>;;Resolution value";
              range "256..40000000";
            }
          }
        }
      }
    }

    // track *
    list track-object {
      tailf:cli-drop-node-name;
      tailf:cli-mode-name "config-track";
      tailf:cli-compact-syntax;
      tailf:cli-diff-dependency "../../ip/vrf";
      tailf:cli-diff-dependency "../../vrf/definition";
      ios:track-remove-before-change;
      key object-number;
      leaf object-number {
        type uint16 {
          tailf:info "<1-1000>;;Tracked object";
          range "1..1000";
        }
      }

      choice track-type {
        // track * rtr
        container rtr {
          tailf:info "Response Time Reporter (RTR) entr";
          tailf:cli-hide-in-submode;
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf operation-number {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-2147483647>;;Entry number";
              range "1..2147483647";
            }
          }
          leaf option {
            tailf:cli-drop-node-name;
            type enumeration {
              enum reachability {
                tailf:info "Reachability";
              }
              enum state {
                tailf:info "Return code state";
              }
            }
          }
        }

        // track * list boolean
        container list {
          tailf:info "Group objects in a list";
          tailf:cli-hide-in-submode;
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          leaf boolean {
            tailf:info "List state based on a boolean calculation on objects";
            type enumeration {
              enum and {
                tailf:info "Boolean AND operation on list";
              }
              enum or {
                tailf:info "Boolean OR operation on list";
              }
            }
          }
        }

        // track * list threshold
        container list-threshold {
          tailf:cli-drop-node-name;
          tailf:cli-flatten-container;
          tailf:cli-hide-in-submode;
          container list {
            tailf:info "Group objects in a list";
            leaf threshold {
              tailf:info "List state based on a threshold of UP and DOWN objects";
              type enumeration {
                enum percentage {
                  tailf:info "Thresholds described as a percentage of total";
                }
                enum weight {
                  tailf:info "Thresholds described by weight values";
                }
              }
            }
          }
        }

        // track * interface
        container interface {
          tailf:info "Select an interface to track";
          tailf:cli-hide-in-submode;
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          uses interface-name-grouping;
          container ip {
            tailf:info "IP parameters";
            tailf:cli-flatten-container;
            tailf:cli-optional-in-sequence;
            leaf routing {
              tailf:info "Track interface IP routing capability";
              type empty;
            }
          }
          container ipv6 {
            tailf:info "IPv6 parameters";
            tailf:cli-flatten-container;
            tailf:cli-optional-in-sequence;
            leaf routing {
              tailf:info "Track interface IPv6 routing capability";
              type empty;
            }
          }
          leaf line-protocol {
            tailf:info "Track interface line-protocol";
            tailf:cli-full-command;
            type empty;
          }
        }

        // track * ip
        container ip {
          tailf:info "IP protocol";
          tailf:cli-hide-in-submode;
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;

          // track * ip route
          container route {
            tailf:info "IP route";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf prefix {
              tailf:cli-drop-node-name;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Prefix";
              }
            }
            leaf mask {
              tailf:cli-drop-node-name;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;mask";
              }
            }
            choice option-choice {
              leaf reachability {
                tailf:info "Route reachability state";
                type empty;
              }
              container metric {
                tailf:info "Route metric";
                tailf:cli-flatten-container;
                leaf threshold {
                  tailf:info "Route metric threshold";
                  type empty;
                }
              }
            }
          }

          // track * ip sla
          container sla {
            tailf:info "IP Service Level Agreement";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf operation-number {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<1-2147483647>;;Entry number";
              }
            }
            choice option-choice {
              leaf reachability {
                tailf:info "Reachability";
                type empty;
              }
              leaf state {
                tailf:info "Return code state";
                type empty;
              }
              default state;
            }
          }
        }

        // track * ipv6
        container ipv6 {
          tailf:info "IPv6 protocol";
          tailf:cli-hide-in-submode;
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;

          // track * ipv6 route
          container route {
            tailf:info "IPv6 route";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf prefix {
              tailf:cli-drop-node-name;
              type ipv6-prefix {
                tailf:info "X:X:X:X::X/<0-128>;;IPv6 prefix";
              }
            }
            choice option-choice {
              leaf reachability {
                tailf:info "Route reachability state";
                type empty;
              }
              container metric {
                tailf:info "Route metric";
                tailf:cli-flatten-container;
                leaf threshold {
                  tailf:info "Route metric threshold";
                  type empty;
                }
              }
            }
          }
        }

        // track * stub-object
        leaf stub-object {
          tailf:info "Stub tracking object";
          tailf:cli-hide-in-submode;
          type empty;
        }
      }

      // track * / object *
      list object {
        tailf:info "Add a tracked object to list";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key id;
        leaf id {
          tailf:non-strict-leafref {
            path "../../../track-object/object-number";
          }
          type uint16 {
            tailf:info "<1-1000>;;Tracked object number";
            range "1..1000";
          }
        }
        choice object-choice {
          leaf not {
            tailf:info "Negate the state of object";
            type empty;
          }
          leaf weight {
            tailf:info "Assign a weight to object";
            type uint8 {
              tailf:info "<1-255>;;Object weight";
              range "1..255";
            }
          }
        }
      }

      // track * / ip vrf
      container ip-vrf {
        tailf:cli-drop-node-name;
        when "../ip" {
          tailf:dependency "../ip";
        }
        container ip {
          tailf:info "Tracking IP configuration subcommands";
          leaf vrf {
            tailf:info "Configure VPN Routing/Forwarding table";
            type string {
              tailf:info "WORD;;VPN Routing/Forwarding instance name";
            }
          }
        }
      }

      // track * / ipv6 vrf
      container ipv6-vrf {
        tailf:cli-drop-node-name;
        when "../ipv6" {
          tailf:dependency "../ipv6";
        }
        container ipv6 {
          tailf:info "Tracking IP configuration subcommands";
          leaf vrf {
            tailf:info "Configure VPN Routing/Forwarding table";
            type string {
              tailf:info "WORD;;VPN Routing/Forwarding instance name";
            }
          }
        }
      }

      // track * / threshold
      container threshold {
        tailf:info "Threshold parameters";

        // track * / threshold percentage
        container percentage {
          tailf:info "Percentage threshold";
          when "../../list-threshold" {
            tailf:dependency "../../list-threshold";
          }
          leaf down {
            tailf:info "Down threshold";
            type uint8 {
              tailf:info "<0-100>;;Threshold value";
              range "0..100";
            }
          }
          leaf up {
            tailf:info "Up threshold";
            type uint8 {
              tailf:info "<0-100>;;Threshold value";
            }
          }
        }

        // track * / threshold metric
        container metric {
          tailf:info "Scaled metric threshold";
          tailf:cli-compact-syntax;
          leaf up {
            tailf:info "Up threshold";
            type uint8 {
              tailf:info "<0-254>;;Threshold value";
            }
          }
          leaf down {
            tailf:info "Down threshold";
            type uint8 {
              tailf:info "<0-255>;;Threshold value";
            }
          }
        }

        // track * / threshold weight
        container weight {
          tailf:info "Weight threshold";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          when "../../list-threshold" {
            tailf:dependency "../../list-threshold";
          }
          leaf down {
            tailf:info "Down threshold";
            tailf:cli-optional-in-sequence;
            type uint8 {
              tailf:info "<0-255>;;Threshold value";
            }
          }
          leaf up {
            tailf:info "Up threshold";
            type uint8 {
              tailf:info "<0-255>;;Threshold value";
            }
          }
        }
      }

      // track * / carrier-delay
      leaf carrier-delay {
        tailf:info "Report state change only after interface carrier-delay timer expires";
        type empty;
      }

      // track * / delay
      container delay {
        tailf:info "Tracking delay";
        tailf:cli-compact-syntax;
        leaf down {
          tailf:info "Delay down change notification";
          type uint8 {
            tailf:info "<0-180>;;Seconds to delay";
            range "0..180";
          }
        }
        leaf up {
          tailf:info "Delay up change notification";
          type uint8 {
            tailf:info "<0-180>;;Seconds to delay";
            range "0..180";
          }
        }
      }

      // track * / default-state
      leaf default-state {
        tailf:info "Default object state";
        when "../stub-object" {
          tailf:dependency "../stub-object";
        }
        type enumeration {
          enum down {
            tailf:info "Track state DOWN";
          }
          enum up {
            tailf:info "Track state UP";
          }
        }
        default down;
      }
    }
  }


  /// ========================================================================
  /// csdb
  /// ========================================================================

  container csdb {
    tailf:info "Common Session Database";

    // csdb tcp
    container tcp {
      tailf:info "CSDB TCP protocol";

      // csdb tcp finwait-time
      leaf finwait-time {
        tailf:info "CSDB TCP protocol: FIN/RST timeout";
        type uint8 {
          tailf:info "<1-50>;;fin/rst timeout value (sec), default 5 sec";
          range "1..50";
        }
        default 5;
      }

      // csdb tcp idle-time
      leaf idle-time {
        tailf:info "CSDB TCP protocol: idle timeout";
        type uint16 {
          tailf:info "<1-36000>;;idle timeout value (sec), default 3600 sec";
          range "1..36000";
        }
        default 3600;
      }

      // csdb tcp reassembly
      container reassembly {
        tailf:info "CSDB Out-of-Order Module";
        leaf max-memory {
          tailf:info "CSDB Out-of-Order: Queue Memory";
          type uint32 {
            tailf:info "<1-102400>;;OoO memory (KB), default 1024 KB";
            range "1..102400";
          }
          default 1024;
        }
        leaf max-queue-length {
          tailf:info "CSDB Out-of-Order: Queue Length";
          type uint8 {
            tailf:info "<0-128>;;OoO queue length, default 16 packets, O means disable OoO";
            range "0..128";
          }
          default 16;
        }
      }

      // csdb tcp synwait-time
      leaf synwait-time {
        tailf:info "CSDB TCP protocol: 3-way handshake timeout";
        type uint16 {
          tailf:info "<0-300>;;syn timeout value (sec), default 30 sec";
          range "0..300";
        }
        default 30;
      }
    }

    // csdb udp idle-time
    container udp {
      tailf:info "CSDB UDP protocol";
      leaf idle-time {
        tailf:info "CSDB UDP Protocol: idle time";
        type uint16 {
          tailf:info "<1-1200>;;idle timeout value (sec), default 30 sec";
          range "1..1200";
        }
        default 30;
      }
    }

    // csdb icmp idle-time
    container icmp {
      tailf:info "CSDB ICMP protocol";
      leaf idle-time {
        tailf:info "CSDB ICMP Protocol: idle time";
        type uint16 {
          tailf:info "<1-1200>;;idle timeout value (sec), default 10 sec";
          range "1..1200";
        }
        default 10;
      }
    }

    // csdb session max-session
    container session {
      tailf:info "CSDB Session Management";
      leaf max-session {
        tailf:info "CSDB Session: maximum session";
        type uint32 {
          tailf:info "<1-655350>;;session, default 65535";
          range "1..655350";
        }
        default 65535;
      }
    }
  }


  /// ========================================================================
  /// performance
  /// ========================================================================

  container performance {
    tailf:info "Global Performance monitor configuration";

    // performance monitor context * profile
    container monitor {
      tailf:info "monitor";
      list context {
        tailf:info "Define ezPM context";
        tailf:cli-mode-name "config-perf-mon";
        tailf:cli-incomplete-command;
        tailf:cli-sequence-commands;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;ezPM context name";
          }
        }
        leaf profile {
          tailf:info "Select ezPM profile";
          tailf:cli-hide-in-submode;
          tailf:cli-full-command;
          type enumeration {
            enum application-experience {
              tailf:info "Application eXperience performance monitor profile";
            }
            enum application-performance {
              tailf:info "Application performance profile";
            }
            enum application-statistics {
              tailf:info "Application statistics profile";
            }
          }
        }

        // performance monitor context * profile / exporter destination *
        container exporter {
          tailf:cli-break-sequence-commands;
          tailf:info "Create exporter";
          list destination {
            tailf:info "Export destination configuration";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            key "address source";
            leaf address {
              type inet:host {
                tailf:info "Hostname or A.B.C.D or X:X::X;;Destination address";
              }
            }
            leaf source {
              tailf:info "Originating interface";
              tailf:cli-expose-key-name;
              tailf:cli-diff-dependency "../../../../../../interface";
              type string {
                tailf:info "WORD;;Interface Name";
              }
            }
            // performance monitor context * profile / exporter destination * vrf
            leaf vrf {
              tailf:info "vrf";
              // note: not dependent on vrf to exist
              type string {
                tailf:info "WORD;;VRF label";
              }
            }
            // performance monitor context * profile / exporter destination * transport
            leaf transport {
              tailf:info "transport";
              type enumeration {
                enum udp {
                  tailf:info "UDP transport protocol";
                }
              }
            }
            // performance monitor context * profile / exporter destination * port
            leaf port {
              tailf:info "port";
              type uint16 {
                tailf:info "<1-65535>;;Optional port value";
                range "1..65535";
              }
            }
          }
        }

        // performance monitor context * profile / traffic-monitor
        container traffic-monitor {
          tailf:info "Select traffic monitor ";

          // performance monitor context * profile / traffic-monitor all
          container all {
            tailf:info "All traffic monitors in this profile";
            presence true;

            // performance monitor context * profile / traffic-monitor all ipv4
            leaf ipv4 {
              tailf:info "Activate monitor for ipv4 traffic";
              type empty;
            }
            // performance monitor context * profile / traffic-monitor all ipv6
            leaf ipv6 {
              tailf:info "Activate monitor for ipv6 traffic";
              type empty;
            }
          }

          // performance monitor context * profile / traffic-monitor url
          container url {
            tailf:info "URL information, application response time (ART) metrics and counters";
            tailf:cli-compact-syntax;
            presence true;
            leaf ipv4 {
              tailf:info "Activate monitor for ipv4 traffic";
              type empty;
            }
            leaf class-replace {
              tailf:info "Replace traffic classification";
              type string {
                tailf:info "WORD;;User defined class name";
              }
            }
            leaf cache-size {
              tailf:info "Maximum flow entries in the Flow Cache";
              type uint32 {
                tailf:info "<64-1048576>;;Maximum number of entries";
                range "64..1048576";
              }
            }
          }

          // performance monitor context * profile /
          // .. traffic-monitor application-client-server-stats
          container application-client-server-stats {
            tailf:info "Per interface, client, server and application statistics";
            presence true;
          }

          // performance monitor context * profile /
          // .. traffic-monitor application-stats
          container application-stats {
            tailf:info "Per application and interface statistics";
            presence true;
          }

          // performance monitor context * profile /
          // .. traffic-monitor application-response-time
          container application-response-time {
            tailf:info "Application response time (ART) metrics and statistics for TCP traffic";
            presence true;
          }

          // performance monitor context * profile / traffic-monitor media
          container media {
            tailf:info "Media metrics and statistics for RTP traffic";
            presence true;
          }
        }
      }
    }
  }



  /// ========================================================================
  /// performance-measurement
  /// ========================================================================

  // performance-measurement
  container performance-measurement {
    tailf:info "Performance Measurement configuration";
    tailf:cli-add-mode;
    tailf:cli-explicit-exit;
    tailf:cli-mode-name "config-perf-meas";
    tailf:cli-diff-dependency "/ios:interface";
    presence true;

    // performance-measurement / protocol twamp-light
    container protocol {
      tailf:info "Supported Protocol";
      container twamp-light {
        tailf:info "Enter twamp-light protocol submode";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-pm-twamp";

        // performance-measurement / protocol twamp-light / measurement delay
        container measurement {
          tailf:info "Supported measurement types";
          container delay {
            tailf:info "Enter delay measurement submode";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-pm-twamp-delay";

            // performance-measurement / protocol twamp-light / measurement delay / unauthenticated
            container unauthenticated {
              tailf:info "Enter unauthenticated submodea";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-pm-twamp-delay-unauth";

              // performance-measurement / protocol twamp-light / measurement delay / unauthenticated / querier-dst-port
              leaf querier-dst-port {
                tailf:info "UDP prot opened to process destination queries";
                type uint16 {
                  tailf:info "<862|1024-14999>;;Port number (default 832)";
                  range "862|1024..14999";
                }
                default 862;
              }

              // performance-measurement / protocol twamp-light / measurement delay / unauthenticated / querier-src-port
              leaf querier-src-port {
                tailf:info "UDP prot opened to process source queries";
                type uint16 {
                  tailf:info "<1024-14999>;;Port number";
                  range "1024..14999";
                }
              }
            }
          }
        }
      }
    }

    // performance-measurement / delay-profile
    container delay-profile {
      tailf:info "Delay Profile";

      // performance-measurement / delay-profile interfaces
      container interfaces {
        tailf:info "Enter interface delay profile mode";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-pm-dm-intf";

        // performance-measurement / delay-profile interfaces / advertisement
        container advertisement {
          tailf:info "Advertisment";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-pm-dm-intf-adv";

          // performance-measurement / delay-profile interfaces / advertisement / accelerated
          container accelerated {
            tailf:info "Accelerated";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-pm-dm-intf-adv-acc";

            // performance-measurement / delay-profile interfaces / advertisement / accelerated / threshold
            leaf threshold {
              tailf:info "Accelerated advertisement threshold";
              type uint8 {
                tailf:info "<0-100>;;Accelerated advertisement threshold percentage change";
                range "0..100";
              }
            }
          }

          // performance-measurement / delay-profile interfaces / advertisement / periodic
          container periodic {
            tailf:info "periodic";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-pm-dm-intf-adv-per";

            // performance-measurement / delay-profile interfaces / advertisement / periodic / threshold
            leaf threshold {
              tailf:info "Periodic advertisement threshold";
              type uint8 {
                tailf:info "<0-100>;;Periodic advertisement threshold percentage change";
                range "0..100";
              }
              default 10;
            }
          }
        }

        // performance-measurement / delay-profile interfaces / probe
        container probe {
          tailf:info "Delay profile probe submode";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-pm-dm-intf-probe";

          // performance-measurement / delay-profile interfaces / probe / computation-interval
          leaf computation-interval {
            tailf:info "Interval for metric computation";
            type uint16 {
              tailf:info "<30-3600>;;Computation interval (seconds)";
            }
            default 30;
          }
        }
      }

      // performance-measurement / delay-profile sr-policy
      container sr-policy {
        tailf:info "Enter sr-policy delay profile mode";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-pm-dm-srpol";

        // performance-measurement / delay-profile sr-policy / probe
        container probe {
          tailf:info "Delay profile probe submode";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-pm-dm-srpol-probe";

          // performance-measurement / delay-profile sr-policy / probe / sweep
          container sweep {
            tailf:info "Enable ECMP hashing by sweeping a field in the probe packet";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-pm-dm-srpol-probe-sweep";

            // performance-measurement / delay-profile sr-policy / probe / sweep / destination ipv4
            container destination {
              tailf:info "Sweep a range of IP destination addresses";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf ipv4 {
                tailf:info "Start of the IPv4 address range";
                tailf:cli-incomplete-command;
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IPv4 address (Required to be a 127.0.0.0/8 address)";
                }
              }
              leaf range {
                tailf:info "Start of the IPv4 address range";
                type uint8 {
                  tailf:info "<0-128>;;Sweeping range (Should fully be in the 127.0.0.0/8 space)";
                  range "0..128";
                }
              }
            }
          }
        }
      }
    }

    // performance-measurement / interface *
    list interface {
      tailf:info "Enable Performance Measurement on an interface";
      tailf:cli-mode-name "config-pm-intf";
      tailf:cli-explicit-exit;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Interface Name";
        }
      }

      // performance-measurement / interface * / delay-measurement
      container delay-measurement {
        tailf:info "Enable delay-measurement on the interface";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-pm-intf-dm";
        tailf:cli-explicit-exit;
        presence true;

        // performance-measurement / interface * / delay-measurement / advertise-delay
        leaf advertise-delay {
          tailf:info "advertisement-delay";
          type uint32 {
            tailf:info "<0-16777215>;;advertisement delay (uSec)";
            range "0..16777215";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// l2
  /// ========================================================================

  container l2 {
    tailf:info "Layer 2 configuration";

    // l2 router-id
    leaf router-id {
      tailf:info "Configure a layer 2 identifier";
      type inet:ipv4-address {
        tailf:info "A.B.C.D;;Layer 2 router-id value";
      }
    }

    // l2 vfi *
    list vfi {
      tailf:info "Configure a virtual forwarding instance";
      tailf:cli-mode-name "config-vfi";
      key name;
      leaf name {
        tailf:cli-diff-dependency "../../../bridge-domain";
        type string {
          tailf:info "WORD;;VFI name";
        }
      }
      // l2 vfi * point-to-point
      leaf point-to-point {
        tailf:info "Point-to-point configuration mode";
        tailf:cli-hide-in-submode;
        tailf:cli-full-command;
        type empty;
      }
      // l2 vfi * manual
      leaf manual {
        tailf:info "Multipoint manual configuration mode";
        tailf:cli-hide-in-submode;
        type empty;
      }
      // l2 vfi * autodiscovery
      leaf autodiscovery {
        tailf:info "Multipoint autodiscovery configuration mode";
        tailf:cli-hide-in-submode;
        type empty;
      }
      leaf evc {
        tailf:cli-drop-node-name;
        tailf:cli-hide-in-submode;
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;EVC name";
        }
      }

      // l2 vfi * / vpn id
      container vpn {
        tailf:info "VPN configuration";
        leaf id {
          tailf:info "VPN id";
          type uint32 {
            tailf:info "<1-4294967295>;;VPN id value";
            range "1..4294967295";
          }
        }
      }

      // l2 vfi * / vpls-id
      leaf vpls-id {
        tailf:info "Specify VPLS-ID Extended Community";
        type string {
          tailf:info "ASN:nn or IP-address:nn;;VPLS-ID Extended Community value";
        }
      }

      // l2 vfi * / bridge-domain
      // NOTE: Setting this creates a sub-mode out of "neighbor * encapsulation mpls"
      leaf bridge-domain {
        tailf:info "Bridge Domain";
        tailf:cli-full-command;
        tailf:cli-full-no;
        type uint16 {
          tailf:info "<1-8000>;;Bridge Domain ID value";
          range "1..8000";
        }
      }

      // l2 vfi * / bridge-domain ? vlan
      container bridge-domain-vlan {
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf bridge-domain {
          tailf:info "Bridge Domain";
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          tailf:non-strict-leafref {
            path "../../../../vlan/vlan-list/id";
          }
          type uint16 {
            tailf:info "<1-8000>;;Bridge Domain ID value";
            range "1..8000";
          }
        }
        leaf vlan {
          tailf:info "Bridge Domain using Interface VLAN";
          type empty;
        }
      }

      // l2 vfi * / mtu
      leaf mtu {
        tailf:info "MTU size in bytes";
        type uint16 {
          tailf:info "<1500-9216>;;MTU size in bytes";
        }
      }

      // l2 vfi * / rd
      leaf rd {
        tailf:info "Specify Route Distinguisher";
        tailf:cli-remove-before-change;
        tailf:cli-full-command;
        type rd-type;
      }

      // l2 vfi * / route-target
      container route-target {
        tailf:info "Specify Target VPN Extended Communities";
        tailf:cli-diff-dependency "../rd";
        uses route-target-grouping;
      }

      // l2 vfi * / neighbor * * encapsulation|pw-class
      container neighbor-vfi {
        tailf:cli-drop-node-name;
        list neighbor {
          tailf:info "VFI neighbor configuration";
          tailf:cli-incomplete-command;
          key "id vcid";
          leaf id {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;VFI neighbor's router id";
            }
          }
          leaf vcid {
            type uint32 {
              tailf:info "<1-4294967295>;;Enter VC ID value";
              range "1..4294967295";
            }
          }
          uses l2-vfi-grouping;
        }
      }

      // l2 vfi * / neighbor * encapsulation|pw-class
      list neighbor {
        tailf:info "VFI neighbor configuration";
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;VFI neighbor's router id";
          }
        }
        uses l2-vfi-grouping;
      }
    }
  }


  /// ========================================================================
  /// pseudowire-class
  /// ========================================================================

  list pseudowire-class {
    tailf:info "Pseudowire-class configuration";
    tailf:cli-mode-name "config-pw-class";
    tailf:cli-full-command;
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;Pseudowire-class name";
      }
    }

    // pseudowire-class * / encapsulation
    leaf encapsulation {
      tailf:info "Data encapsulation method";
      type enumeration {
        enum l2tpv2 {
          tailf:info "Use L2TPv2 encapsulation";
        }
        enum l2tpv3 {
          tailf:info "Use L2TPv3 encapsulation";
        }
        enum mpls {
          tailf:info "Use MPLS encapsulation";
        }
      }
    }

    // pseudowire-class * / interworking
    leaf interworking {
      tailf:info "Interworking options for pseudowire";
      tailf:cli-full-command;
      type enumeration {
        enum ethernet {
          tailf:info "Ethernet interworking";
        }
        enum ip {
          tailf:info "IP interworking";
        }
        enum vlan {
          tailf:info "VLAN interworking";
        }
      }
    }

    // pseudowire-class * / control-word
    leaf control-word {
      tailf:info "Include control-word in pseudowire packets";
      type empty;
    }

    // pseudowire-class * / sequencing
    container sequencing {
      tailf:info "Sequencing options for pseudowire";
      choice sequencing-choice {
        leaf both {
          tailf:info "Transmit and receive sequence numbers";
          type empty;
        }
        leaf receive {
          tailf:info "Receive sequence numbers";
          type empty;
        }
        container resync {
          tailf:info "Enable Rx sequencing out-of-order detection/recovery";
          presence true;
        }
        leaf transmit {
          tailf:info "Transmit sequence numbers";
          type empty;
        }
      }
    }

    // pseudowire-class * / protocol
    container protocol {
      tailf:info "Signaling protocol to use";
      choice protocol-choice {
        leaf none {
          tailf:info "No signaling, use manually configured sessions";
          type empty;
        }
        leaf l2tpv2 {
          tailf:info "Use L2TPv2 signaling";
          tailf:non-strict-leafref {
            path "../../../l2tp-class/l2tp-class-name";
          }
          type string {
            tailf:info "WORD;;l2tp-class name";
          }
        }
        leaf l2tpv3 {
          tailf:info "Use L2TPv3 signaling";
          tailf:non-strict-leafref {
            path "../../../l2tp-class/l2tp-class-name";
          }
          type string {
            tailf:info "WORD;;l2tp-class name";
          }
        }
      }
    }

    // pseudowire-class * / status
    container status {
      tailf:info "Pseudowire status capabilities";
      tailf:cli-diff-dependency "../protocol";

      // pseudowire-class * / status peer topology dual-homed
      container peer {
        tailf:info "peer status configuration";
        container topology {
          tailf:info "change status behaviour based on peer topology";
          leaf dual-homed {
            tailf:info "Our peer(s) are participating in a redundant "+
              "solution with some form of redundancy protocol running between the peer routers";
            type empty;
          }
        }
      }

      // pseudowire-class * / status protocol notification static
      container protocol {
        tailf:info "Status protocol configuration";
        container notification {
          tailf:info "Status notification protocol";
          leaf static {
            tailf:info "Static PW OAM protocol";
            tailf:non-strict-leafref {
              path "../../../../../pseudowire-static-oam/class/name";
            }
            type string {
              tailf:info "WORD;;Static PW OAM class name";
            }
          }
        }
      }
    }

    // pseudowire-class * / ip
    container ip {
      tailf:info "Specify IP parameters";
      tailf:cli-diff-dependency "../encapsulation";

      // pseudowire-class * / ip protocol
      leaf protocol {
        tailf:info "Specific IP protocol number to use";
        type enumeration {
          enum l2tp {
            tailf:info "L2TP over IP (protocol 115)";
          }
          enum uti {
            tailf:info "Legacy UTI mode (protocol 120)";
          }
        }
        default l2tp;
      }

      // pseudowire-class * / ip local interface
      container local {
        tailf:info "Specify local information";
        container interface {
          tailf:info "Source interface for pseudowire";
          tailf:cli-compact-syntax;
          uses interface-name-grouping;
        }
      }

      // pseudowire-class * / ip pmtu
      container pmtu {
        tailf:info "Enable Path MTU for tunnel";
        tailf:cli-delete-when-empty;
        tailf:cli-reset-container;
        presence true;

        // pseudowire-class * / ip pmtu max
        leaf max {
          tailf:info "Maximum Path MTU for session";
          type uint16 {
            tailf:info "<68-65535>;;Maximum Path MTU";
            range "68..65535";
          }
        }
      }

      // pseudowire-class * / ip tos value
      container tos {
        tailf:info "Specify ToS options for IP tunnel header";
        leaf value {
          tailf:info "IP ToS value";
          type uint8 {
            tailf:info "<0-255>;;ToS byte value";
          }
        }
      }
    }

    // pseudowire-class * / preferred-path
    uses pseudowire-preferred-path-grouping;
  }


  /// ========================================================================
  /// device-tracking
  /// ========================================================================

  container device-tracking {
    tailf:info "Device tracking configuration commands";

    // device-tracking tracking
    container tracking {
      tailf:info "Configures device-tracking tracking behaviour";

      // device-tracking tracking auto-source
      container auto-source {
        tailf:info "Probe source selection algorithm";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        container fallback {
          tailf:info "Specify IP and MASK to use as last resort";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf address {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IPv4 of fallback source";
            }
          }
          leaf mask {
            tailf:cli-drop-node-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP prefix mask";
            }
          }
        }
        leaf override {
          tailf:info "Do not select source address from device track table";
          type empty;
        }
      }
    }

    // device-tracking logging theft
    // no device-tracking logging theft
    container logging {
      tailf:info "Configure snooping Security logging";
      leaf theft {
        tailf:info "IP or MAC theft events";
        tailf:cli-boolean-no;
        type boolean;
      }
    }

    // device-tracking policy *
    list policy {
      tailf:info "Configure a policy for feature device-tracking";
      tailf:cli-mode-name "config-device-tracking";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Name of the device-tracking policy";
        }
      }

      // device-tracking policy * / trusted-port
      leaf trusted-port {
        tailf:info "setup trusted port";
        type empty;
      }

      // device-tracking policy * / limit address-count
      container limit {
        tailf:info "Specifies a limit";
        leaf address-count {
          tailf:info "Configure maximum address per port";
          type uint16 {
            tailf:info "<1-32000>;;maximum value";
            range "1..32000";
          }
        }
      }

      // device-tracking policy * / device-role
      leaf device-role {
        tailf:info "Sets the role of the device attached to the port";
        type enumeration {
          enum node {
            tailf:info "Attached device is a node (default)";
          }
          enum switch {
            tailf:info "Attached device is a switch";
          }
        }
        default node;
      }

      // device-tracking policy * / protocol
      container protocol {
        tailf:info "Sets the protocol to glean (default all)";

        // device-tracking policy * / no protocol ndp
        leaf ndp {
          tailf:info "Glean addresses in NDP packets";
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }

        // device-tracking policy * / no protocol arp
        leaf arp {
          tailf:info "Glean addresses in ARP packets";
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }

        // device-tracking policy * / no protocol udp
        leaf udp {
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }
      }

      // device-tracking policy * / tracking
      container tracking {
        tailf:info "Override default tracking behavior";
        choice tracking-choice {
          leaf disable {
            tailf:info "Tracking off (default)";
            type empty;
          }
          container enable {
            tailf:info "Tracking on";
            tailf:cli-delete-when-empty;
            tailf:cli-reset-container;
            presence true;
            leaf reachable-lifetime {
              tailf:info "Time entry is kept REACHABLE";
              type union {
                type uint32 {
                  tailf:info "<1-86400>;;Seconds";
                }
                type enumeration {
                  enum infinite {
                    tailf:info "Keep in REACHABLE forever";
                  }
                }
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// interface
  /// ========================================================================

  container interface {
    tailf:info "Configure interfaces";
    tailf:cli-explicit-exit;
    tailf:cli-diff-before "/ios:vlan/vlan-list" {
      tailf:cli-when-target-delete;
    }
    cli:ned-diff-move-after ">router bgp" {
      cli:arguments "when-delete";
    }

    // interface Null0
    list Null {
      tailf:info "Null interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      tailf:cli-full-command;
      key name;
      leaf name {
        type uint8 {
          tailf:info "<0-0>;;Null interface number";
          range "0";
        }
      }

      // interface Null0 / ip
      container ip {
        tailf:info "Interface Internet Protocol config commands";
        // no ip unreachables
        leaf unreachables {
          tailf:info "Enable sending ICMP Unreachable messages";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }
      }

      // interface Null0 / ipv6
      container ipv6 {
        tailf:info "IPv6 interface subcommands";
        // no ipv6 unreachables
        leaf unreachables {
          tailf:info "Enable sending of ICMP Unreachable messages";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }
      }
    }

    // interface Loopback *
    list Loopback {
      tailf:info "Loopback interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      tailf:cli-full-command;
      ios:if-default;
      key name;
      leaf name {
        type string {
          tailf:info "<0-2147483647>;;Loopback interface number";
          pattern '([0-9\.])+';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;
    }

    // interface VirtualPortGroup
    list VirtualPortGroup {
      tailf:info "Virtual Port Group";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type uint8 {
          tailf:info "<0-31>;;VirtualPortGroup interface number";
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;
      uses interface-pointtopoint-grouping;
    }

    // interface Dot11Radio*
    list Dot11Radio {
      tailf:info "IEEE 802.11 WLAN";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          tailf:info "LINE;;Dot11Radio interface number";
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-ethernet-pre-grouping;
      uses interface-common-grouping;
      uses interface-ethernet-post-grouping;

      // interface Dot11Radio* / encryption
      container encryption {
        tailf:info "Configure dot11 encryption parameters";

        // interface Dot11Radio* / encryption mode
        uses interface-encryption-mode-grouping;

        // interface Dot11Radio* / encryption vlan *
        list vlan {
          tailf:info "vlan";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key id;
          leaf id {
            type string {
              tailf:info "WORD;;vlan ID number or vlan nam";
            }
          }

          // interface Dot11Radio* / encryption vlan * mode
          uses interface-encryption-mode-grouping;
        }
      }

      // interface Dot11Radio* / broadcast-key
      container broadcast-key {
        tailf:info "Configure broadcast key rotation period";

        // interface Dot11Radio* / broadcast-key vlan *
        list vlan {
          tailf:info "vlan";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-reset-container;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;vlan ID number or vlan name";
            }
          }
          leaf change {
            tailf:info "key rotation";
            type uint32 {
              tailf:info "<10-10000000>;;Key rotation period in seconds";
              range "10..10000000";
            }
          }
        }
      }

      // interface Dot11Radio* / ssid
      list ssid {
        tailf:info "Configure radio service set parameters";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "LINE;;radio Service Set ID (Up to 32 character";
            length "1..32";
          }
        }
      }

      // interface Dot11Radio* / antenna
      container antenna {
        tailf:info "dot11 radio antenna setting";

        // interface Dot11Radio* / antenna gain
        leaf gain {
          tailf:info "Configure Resultant Antenna Gain";
          type int16 {
            tailf:info "<-128 - 128>;;Resultant Antenna Gain in dB";
            range "-128..128";
          }
        }
      }

      // interface Dot11Radio* / peakdetect
      leaf peakdetect {
        type empty;
      }

      // interface Dot11Radio* / mbssid
      leaf mbssid {
        tailf:info "enable mbssid";
        tailf:cli-full-command;
        type empty;
      }

      // interface Dot11Radio* / speed
      leaf speed {
        tailf:info "Set allowed radio bit rates";
        tailf:cli-multi-value;
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;allowed radio bit rates";
        }
      }

      // interface Dot11Radio* / dfs band
      container dfs {
        tailf:info "Dynamic Frequency Selection commands";
        container band {
          tailf:info "Specify frequency bands";
          tailf:cli-incomplete-no;
          choice band-choice {

            // interface Dot11Radio* / no dfs band block
            leaf block {
              tailf:info "Block specified frequency bands from being selected by DFS";
              tailf:cli-boolean-no;
              tailf:cli-full-command;
              type boolean;
              default true;
            }

            // interface Dot11Radio* / dfs band * block
            container block-conf {
              tailf:cli-drop-node-name;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf one {
                tailf:info "5.150 to 5.250 GHz";
                tailf:alt-name "1";
                tailf:cli-optional-in-sequence;
                tailf:cli-incomplete-command;
                type empty;
              }
              leaf two {
                tailf:info "5.250 to 5.350 GHz";
                tailf:alt-name "2";
                tailf:cli-optional-in-sequence;
                tailf:cli-incomplete-command;
                type empty;
              }
              leaf three {
                tailf:info "5.470 to 5.725 GHz";
                tailf:alt-name "3";
                tailf:cli-optional-in-sequence;
                tailf:cli-incomplete-command;
                type empty;
              }
              leaf four {
                tailf:info "5.725 to 5.825 GHz";
                tailf:alt-name "4";
                tailf:cli-optional-in-sequence;
                tailf:cli-incomplete-command;
                type empty;
              }
              leaf block {
                tailf:info "Block specified frequency bands from being selected by DFS";
                type empty;
              }
            }
          }
        }
      }

      // interface Dot11Radio* / packet
      container packet {
        tailf:info "IEEE 802.11 packet";

        // interface Dot11Radio* / packet retries
        leaf retries {
          tailf:info "maximum best-effort data packet retries";
          type uint8 {
            tailf:info "<1-128>;;number of packet retries before giving up";
            range "1..128";
          }
        }
      }

      // interface Dot11Radio* / channel
      container channel {
        tailf:info "Set the radio frequency";

        // interface Dot11Radio* / channel dfs
        leaf dfs {
          tailf:info "Use Dynamic Frequency Selection";
          type empty;
        }
      }

      // interface Dot11Radio* / channel least-congested
      container channel-conf {
        tailf:cli-drop-node-name;
        container channel {
          tailf:info "Set the radio frequency";
          tailf:cli-compact-syntax;
          leaf least-congested {
            tailf:info "Scan for best frequency";
            type empty;
          }
          leaf-list frequency {
            tailf:cli-drop-node-name;
            tailf:cli-flat-list-syntax;
            tailf:cli-replace-all;
            ordered-by user;
            type uint16 {
              tailf:info "NUM;;frequency";
            }
          }
        }
      }

      // interface Dot11Radio* / station-role root
      container station-role {
        tailf:info "role of the radio";
        container root {
          tailf:info "Root access point or bridge";
          presence true;
        }
      }

      // interface Dot11Radio* / rts
      container rts {
        tailf:info "dot11 Request To Send";

        // interface Dot11Radio* / rts threshold
        leaf threshold {
          tailf:info "RTS threshold";
          type uint16 {
            tailf:info "<0-2347>;;threshold in bytes";
            range "0..2347";
          }
        }

        // interface Dot11Radio* / rts retries
        leaf retries {
          tailf:info "RTS max retries";
          type uint8 {
            tailf:info "<1-128>;;max retries";
            range "1..128";
          }
        }
      }

      // interface Dot11Radio* / world-mode
      container world-mode {
        tailf:info "Dot11 radio world mode";

        // interface Dot11Radio* / world-mode dot11d
        container dot11d {
          tailf:info "802.11d World Mode advertise country";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf country-code {
            tailf:info "ISO /IEC 3166-1 country code";
            tailf:cli-incomplete-command;
            type string {
              tailf:info "WORD;;two characters country code";
            }
          }
          leaf location {
            tailf:cli-drop-node-name;
            type enumeration {
              enum both {
                tailf:info "location indoor and outdoor";
              }
              enum indoor {
                tailf:info "location indoor";
              }
              enum outdoor {
                tailf:info "location outdoor";
              }
            }
          }
        }
      }

      // interface Dot11Radio* / infrastructure-client
      leaf infrastructure-client {
        tailf:info "Reserve a dot11 virtual interface for a WGB client";
        type empty;
      }
    }

    // interface Embedded-Service-Engine*
    list Embedded-Service-Engine {
      tailf:info "cisco embedded service engine module";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          tailf:info "<0-2>/<0-0>;;Embedded-Service-Engine interface number";
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;
    }

    // interface Service-Engine*
    list Service-Engine {
      tailf:info "Cisco service engine module";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;
    }

    // interface Tunnel*
    list Tunnel {
      tailf:info "Tunnel interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      tailf:cli-recursive-delete;
      tailf:cli-diff-dependency "../../crypto/isakmp/profile";
      ios:shutdown-before-delete;
      key name;
      leaf name {
        type uint32 {
          tailf:info "<0-2147483647>;;Tunnel interface number";
        }
      }
      uses interface-common-pre-grouping {
        refine "description" {
          tailf:cli-diff-dependency "../tunnel/mpls";
        }
      }
      uses interface-common-grouping;

      // interface Tunnel* / tunnel
      uses interface-tunnel-grouping;
    }

    // interface Port-channel*
    list Port-channel {
      tailf:info "Ethernet Channel of interfaces";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      tailf:cli-recursive-delete;
      key name;
      leaf name {
        type uint32 {
          tailf:info "<1-512>;;Port-channel interface number";
          range "1..512";
        }
      }
      uses interface-common-pre-grouping;
      uses interface-ethernet-pre-grouping;
      uses interface-switch-grouping;
      uses interface-ethernet-switch-grouping;
      uses interface-common-macsec-grouping;
      uses interface-ethernet-post-grouping;

      // interface Port-channel* / load-balancing
      leaf load-balancing {
        tailf:info "Etherchannel Load-Balancing";
        type enumeration {
          enum flow {
            tailf:info "Based on the traffic flows identified by the packet headers";
          }
          enum vlan {
            tailf:info "Based on the VLAN to member links manual configuration";
          }
        }
      }

      // interface Port-channel* / mlacp
      container mlacp {
        tailf:info "mLACP Port Channel interface subcommands";
        container interchassis {
          tailf:info "mLACP Interchassis commands";
          leaf group {
            tailf:info "Interchassis Group";
            type uint32 {
              tailf:info "<1-4294967295>;;Group ID";
            }
          }
        }
      }

      // interface Port-channel* / counter
      container counter {
        tailf:info "Enable IPv4 and IPv6 combined statistic counters";
        presence true;
      }

      // interface Port-channel* / port-channel
      container port-channel {
        tailf:info "Port Channel interface subcommands";

        // interface Port-channel* / port-channel load-balance
        container load-balance {
          tailf:info "Configure load-balancing for egress traffic";

          // interface Port-channel* / port-channel load-balance flow-based
          leaf flow-based {
            tailf:info "Flow based load-balancing on the port-channel";
            tailf:cli-full-command;
            tailf:cli-diff-dependency "../link" {
              tailf:cli-trigger-on-set;
            }
            tailf:cli-diff-dependency "../weighted" {
              tailf:cli-trigger-on-set;
            }
            //when "not(../link)" {
            //tailf:dependency "../link";
            //}
            type empty;
          }

          // interface Port-channel* / port-channel load-balance link
          leaf link {
            tailf:info "Manually configure a member link for load-balancing";
            tailf:cli-full-command;
            //when "not(../flow-based)";
            type uint8 {
              tailf:info "<1-16>;;The link ID of the member link to use for egress load-balancing";
              range "1..16";
            }
          }

          // interface Port-channel* / port-channel load-balance weighted
          container weighted {
            tailf:info "Configure weighted load-balancing on the port-channel";
            //when "not(../flow-based)";

            // interface Port-channel* / port-channel load-balance weighted default
            container default {
              tailf:info "Configure default parameters";
              leaf weight {
                tailf:info "Modify the default weight";
                type uint16 {
                  tailf:info "<1-10000>;;weight value";
                  range "1..10000";
                }
              }
            }

            // interface Port-channel* / port-channel load-balance weighted rebalance
            leaf rebalance {
              tailf:info "Configure or disable automatic rebalancing";
              type union {
                type uint16 {
                  tailf:info "<1-10000>;;The threshold weight used to trigger automatic rebalancing";
                  range "1..10000";
                }
                type enumeration {
                  enum "disable" {
                    tailf:info "Disable automatic rebalancing";
                  }
                }
              }
            }
          }
        }

        // interface Port-channel* / port-channel min-links
        leaf min-links {
          tailf:info "Minimum number of bundled ports needed to bring up this port channel";
          type uint8 {
            tailf:info "<2-8>;;The minimum number of bundled ports needed before this port channel can come up.";
            range "2..8";
          }
        }

        // interface Port-channel* / port-channel bfd destination
        container bfd {
          tailf:info "Enable BFD feature";
          container destination {
            tailf:info "Destination IP Address";
            container ipv4 {
              tailf:info "IPV4 Address";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf address {
                tailf:cli-drop-node-name;
                tailf:cli-remove-before-change;
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IP Address";
                }
              }
              leaf name {
                tailf:cli-drop-node-name;
                tailf:non-strict-leafref {
                  path "/ios:bfd-template/single-hop/name";
                }
                type string {
                  tailf:info "WORD;;name of the template";
                }
              }
            }
          }
        }
      }
    }

    // subinterface Port-channel #.#
    container Port-channel-subinterface {
      tailf:cli-drop-node-name;
      list Port-channel {
        tailf:info "Ethernet Channel of interfaces";
        tailf:cli-allow-join-with-key {
          tailf:cli-display-joined;
        }
        tailf:cli-mode-name "config-subif";
        tailf:cli-suppress-key-abbreviation;
        key name;
        leaf name {
          tailf:cli-diff-dependency "../../../Port-channel";
          type string {
            pattern '[0-9]+\.[0-9]+';
          }
        }
        uses interface-common-pre-grouping;
        uses interface-ethernet-pre-grouping;
        uses interface-switch-grouping;
        uses interface-ethernet-grouping;
        uses interface-common-macsec-grouping;
        uses interface-ethernet-post-grouping;
      }
    }

    // interface nve*
    list nve {
      tailf:info "Network virtualization endpoint interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      tailf:cli-full-command;
      key name;
      leaf name {
        type uint16 {
          tailf:info "<1-4096>;;nve interface number";
          range "1..4096";
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;

      // interface nve* / member vni *
      container member {
        tailf:info "Configure the Layer2 VPN member";
        list vni {
          tailf:cli-mode-name "config-if-nve-vni";
          key id;
          leaf id {
            type string {
              tailf:info "WORD;;VNI range or instance between 4096-16777215 example: 6010-6030 or 7115";
            }
          }

          // interface nve* / member vni * / ingress-replication
          leaf ingress-replication {
            tailf:info "Ingress Replication or Unicast mode for vni(s)";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Remote Peer IPV4 Address";
            }
          }
        }
      }
    }

    // interface Multilink*
    list Multilink {
      tailf:info "Multilink-group interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      ios:shutdown-before-delete;
      key name;
      leaf name {
        tailf:cli-diff-dependency "../../../controller/SONET/au-4/tug-3/tug-2/unframed";
        type uint32 {
          tailf:info "<1-2147483647>;;Multilink interface number";
          range "1..2147483647";
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-ptp-grouping {
        // Multilink bandwidth is too low until Serial interface references it with "multilink group"
        refine "service-policy/input" {
          tailf:cli-diff-dependency "/ios:interface/Serial";
        }
        refine "service-policy/output" {
          tailf:cli-diff-dependency "/ios:interface/Serial";
        }
      }
      uses interface-pointtopoint-grouping;
    }

    // interface MFR*
    list MFR {
      tailf:info "Multilink Frame Relay bundle interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type uint32 {
          tailf:info "<0-2147483647>;;MFR interface number";
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;
      uses interface-pointtopoint-grouping;
    }

    // subinterface MFR*.*
    container MFR-subinterface {
      tailf:cli-drop-node-name;
      list MFR {
        tailf:info "Multilink Frame Relay bundle interface";
        tailf:cli-allow-join-with-key {
          tailf:cli-display-joined;
        }
        tailf:cli-mode-name "config-subif";
        tailf:cli-suppress-key-abbreviation;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          tailf:cli-diff-dependency "../../../MFR";
          type string {
            pattern '[0-9]+\.[0-9]+';
          }
        }
        leaf type {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum multipoint {
              tailf:info "Treat as a multipoint link";
            }
            enum point-to-point {
              tailf:info "Treat as a point-to-point link";
            }
          }
        }
        uses interface-common-pre-grouping;
        uses interface-common-grouping;
        uses interface-pointtopoint-grouping;
      }
    }

    // interface BRI*
    list BRI {
      tailf:info "ISDN Basic Rate Interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          tailf:info "<slot>/<port>;;BRI interface number";
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;
      uses interface-pointtopoint-grouping;
    }

    // interface Ethernet-Internal*
    list Ethernet-Internal {
      tailf:info "Ethernet-Internal interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          tailf:info "<slot>/<port>;;Ethernet-internal interface number";
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-ethernet-pre-grouping;
      uses interface-switch-grouping;
      uses interface-ethernet-switch-grouping;
      uses interface-common-macsec-grouping;
      uses interface-ethernet-post-grouping;
    }

    // interface Ethernet*
    list Ethernet {
      tailf:info "Ethernet";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          tailf:info "<slot>/<port>;;Ethernet interface number";
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-ethernet-pre-grouping;
      uses interface-switch-grouping;
      uses interface-ethernet-switch-grouping;
      uses interface-common-macsec-grouping;
      uses interface-ethernet-post-grouping;
    }

    // interface FastEthernet*
    list FastEthernet {
      tailf:info "FastEthernet IEEE 802.3";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          tailf:info "<0-66>/<0-128>;;FastEthernet interface number";
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-ethernet-pre-grouping;
      uses interface-switch-grouping;
      uses interface-ethernet-switch-grouping;
      uses interface-common-macsec-grouping;
      uses interface-ethernet-post-grouping;
    }

    // interface GigabitEthernet *
    list GigabitEthernet {
      tailf:info "GigabitEthernet IEEE 802.3z";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          tailf:info "<0-66>/<0-128>;;GigabitEthernet interface number";
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-ethernet-pre-grouping;
      uses interface-switch-grouping {
        refine switchport {
          tailf:cli-diff-set-after "../../GigabitEthernet" {
            tailf:cli-when-target-delete;
          }
        }
      }
      uses interface-ethernet-switch-grouping;
      uses interface-common-macsec-grouping;
      uses interface-ethernet-post-grouping;
    }

    // interface TwoGigabitEthernet*
    list TwoGigabitEthernet {
      tailf:info "Two Gigabit Ethernet";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          tailf:info "<0-66>/<0-128>;;TwoGigabitEthernet interface number";
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-ethernet-pre-grouping;
      uses interface-switch-grouping {
        refine switchport {
          tailf:cli-diff-set-after "../../TwoGigabitEthernet" {
            tailf:cli-when-target-delete;
          }
        }
      }
      uses interface-ethernet-switch-grouping;
      uses interface-common-macsec-grouping;
      uses interface-ethernet-post-grouping;
    }

    // interface TenGigabitEthernet*
    list TenGigabitEthernet {
      tailf:info "Ten Gigabit Ethernet";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          tailf:info "<0-66>/<0-128>;;TenGigabitEthernet interface number";
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-ethernet-pre-grouping;
      uses interface-switch-grouping {
        refine switchport {
          tailf:cli-diff-set-after "../../TenGigabitEthernet" {
            tailf:cli-when-target-delete;
          }
        }
      }
      uses interface-ethernet-switch-grouping;
      uses interface-common-macsec-grouping;
      uses interface-ethernet-post-grouping;
    }

    // interface TwentyFiveGigE *
    list TwentyFiveGigE {
      tailf:info "Twenty Five Gigabit Ethernet";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          tailf:info "X/Y/Z;;TwentyFiveGigE interface id";
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-ethernet-pre-grouping;
      uses interface-switch-grouping {
        refine switchport {
          tailf:cli-diff-set-after "../../TwentyFiveGigE" {
            tailf:cli-when-target-delete;
          }
        }
      }
      uses interface-ethernet-switch-grouping;
      uses interface-common-macsec-grouping;
      uses interface-ethernet-post-grouping;
    }

    // interface FortyGigabitEthernet*
    list FortyGigabitEthernet {
      tailf:info "Forty Gigabit Ethernet";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          tailf:info "X/Y/Z;;FortyGigabitEthernet interface id";
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-ethernet-pre-grouping;
      uses interface-switch-grouping {
        refine switchport {
          tailf:cli-diff-set-after "../../FortyGigabitEthernet" {
            tailf:cli-when-target-delete;
          }
        }
      }
      uses interface-ethernet-switch-grouping;
      uses interface-common-macsec-grouping;
      uses interface-ethernet-post-grouping;
    }

    // interface HundredGigE*
    list HundredGigE {
      tailf:info "Hundred Gigabit Ethernet";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          tailf:info "<0-66>/<0-128>;;HundredGigE interface number";
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-ethernet-pre-grouping;
      uses interface-switch-grouping {
        refine switchport {
          tailf:cli-diff-set-after "../../HundredGigE" {
            tailf:cli-when-target-delete;
          }
        }
      }
      uses interface-ethernet-switch-grouping;
      uses interface-common-macsec-grouping;
      uses interface-ethernet-post-grouping;
    }

    // interface mgmt0
    list mgmt {
      tailf:info "Management Ethernet interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type uint8 {
          tailf:info "<0-0>;;mgmt interface number";
          range "0";
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;
    }

    // interface Wlan-GigabitEthernet*
    list Wlan-GigabitEthernet {
      tailf:info "Internal GigabitEthernet IEEE 802.3z connecting to embedded AP";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          tailf:info "<0-0>;;Wlan-GigabitEthernet interface number";
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-ethernet-pre-grouping;
      uses interface-switch-grouping;
      uses interface-ethernet-switch-grouping;
      uses interface-common-macsec-grouping;
      uses interface-ethernet-post-grouping;
    }

    // interface wlan-ap*
    list wlan-ap {
      tailf:info "Service module interface to embedded AP";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          tailf:info "<0-0>;;wlan-ap interface number";
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-ethernet-pre-grouping;
      uses interface-ethernet-grouping;
      uses interface-common-macsec-grouping;
      uses interface-ethernet-post-grouping;
    }

    // interface Dialer*
    list Dialer {
      tailf:info "Dialer interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      ios:shutdown-before-delete;
      key name;
      leaf name {
        type string {
          tailf:info "<0-255>;;Dialer interface number";
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;
      uses interface-pointtopoint-grouping;
    }

    // interface ISM*
    list ISM {
      tailf:info "Internal Services Module (ISM) with Services Ready Engine (SRE)";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;ISM interface number";
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;
      uses interface-pointtopoint-grouping;
    }

    // interface Analysis-Module*
    list Analysis-Module {
      tailf:info "cisco network analysis service module";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Analysis-Module interface number";
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;
      uses interface-pointtopoint-grouping;
    }

    // interface Integrated-Service-Engine*
    list Integrated-Service-Engine {
      tailf:info "cisco integrated service engine module";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Integrated-Service-Engine interface number";
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;
      uses interface-pointtopoint-grouping;
    }

    // interface ATM*
    list ATM {
      tailf:info "ATM interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          pattern '[0-9]+.*';
        }
      }
      leaf point-to-point {
        tailf:info "Point-to-point interface";
        tailf:cli-hide-in-submode;
        tailf:cli-full-command;
        type empty;
      }

      uses interface-common-pre-grouping;
      uses interface-common-grouping;

      // interface ATM* / ima
      container ima {
        tailf:info "IMA Interface commands";

        // interface ATM* / ima version
        leaf version {
          tailf:info "IMA version";
          tailf:cli-full-command;
          type enumeration {
            enum "1.0" {
              tailf:info "IMA version 1.0";
            }
            enum "1.1" {
              tailf:info "IMA version 1.1";
            }
          }
        }

        // interface ATM* / ima group-id
        leaf group-id {
          type uint8 {
          }
        }
      }

      // interface ATM* / atm
      container atm {
        tailf:info "Modify ATM parameters";

        // interface ATM* / atm bandwidth
        container bandwidth {
          tailf:info "Allow bandwidth change on ATM PVCs";
          // interface ATM* / atm bandwidth dynamic
          leaf dynamic {
            tailf:info "Allow dynamic bandwidth change on ATM PVCs";
            type empty;
          }
        }

        // interface ATM* / atm mcpt-timers
        container mcpt-timers {
          tailf:info "Configure Maximum cell Packing Timeout Values";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf timer-1 {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<500-10000>;;MCPT timer1 value in microsecond";
              range "500..10000";
            }
          }
          leaf timer-2 {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<500-10000>;;MCPT timer2 value in microsecond";
              range "500..10000";
            }
          }
          leaf timer-3 {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<1000-10000>;;MCPT timer3 value in microsecond";
              range "1000..10000";
            }
          }
        }

        // interface ATM* / atm oversubscribe
        container oversubscribe {
          tailf:info "Allow oversubscription of ATM link";
          tailf:cli-delete-when-empty;
          presence true;
          leaf factor {
            tailf:info "Oversubscription Factor of ATM link";
            type uint8 {
              tailf:info "<2-2>;;Oversubscription factor value";
              range "2";
            }
          }
        }

        // interface ATM* / no atm enable-ilmi-trap
        leaf enable-ilmi-trap {
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }

        // interface ATM* / atm ilmi-keepalive
        container ilmi-keepalive {
          tailf:info "Keepalive polling configuration";
          presence true;
        }

        // interface ATM* / atm route-bridged
        container route-bridged {
          tailf:info "Route 1483 Ethernet encapsulated packets";
          leaf ip {
            tailf:info "Route IP over RFC 1483 Ethernet";
            type empty;
          }
          leaf ipv6 {
            tailf:info "Route IPv6 over RFC 1483 Ethernet";
            type empty;
          }
        }
      }

      // interface ATM* / pvc * [l2transport]
      list pvc {
        tailf:info "Configure ATM PVC parameters";
        tailf:cli-mode-name "cfg-if-atm-pvc";
        tailf:cli-sequence-commands;
        key name;
        leaf handle {
          tailf:cli-prefix-key;
          tailf:cli-drop-node-name;
          tailf:cli-optional-in-sequence;
          type uint32 {
            tailf:info "uint32;;optional handle";
          }
        }
        leaf name {
          tailf:cli-suppress-range;
          type string {
            tailf:info "WORD;;VPI/VCI or VCI or handle";
            pattern "[0-9]+/[0-9]+";
          }
        }
        leaf l2transport {
          tailf:info "Set PVC to L2 transport VC, No L3 function";
          tailf:cli-hide-in-submode;
          tailf:cli-full-command;
          type empty;
        }

        // interface ATM* / pvc * / class-vc
        leaf class-vc {
          tailf:info "Configure default vc-class name";
          tailf:cli-break-sequence-commands;
          tailf:non-strict-leafref {
            path "../../../../vc-class/atm/name";
          }
          type string {
            tailf:info "WORD;;ATM vc-class name to use on this VC";
          }
        }

        // interface ATM* / pvc * / vbr-nrt
        container vbr-nrt {
          tailf:info "Enter Variable Bit Rate (pcr)(scr)(bcs)";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf pcr {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<32-4608>;;Peak Cell Rate(PCR) in Kbps";
              range "32..4608";
            }
          }
          leaf scr {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<32-4608>;;Sustainable Cell Rate(SCR) in Kbps";
              range "32..4608";
            }
          }
          leaf mbs {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<1-64000>;;Maximum Burst Size(MBS) in Cells";
              range "1..64000";
            }
          }
        }

        // interface ATM* / pvc * / tx-limit
        leaf tx-limit {
          tailf:info "Configure VC level tx buffer limit";
          type uint32 {
            tailf:info "<1-100000>;;Number of tx buffers for this VC";
            range "1..100000";
          }
        }

        // interface ATM* / pvc * / tx-ring-limit
        leaf tx-ring-limit {
          tailf:info "Configure PA level transmit ring limit";
          type uint8 {
            tailf:info "<2-128>;;Number (ring limit)";
            range "2..128";
          }
        }

        // interface ATM* / pvc * / vc-hold-queue
        leaf vc-hold-queue {
          tailf:info "Configure hold queue size";
          type uint16 {
            tailf:info "<5-2048>;;Value of the hold queue size";
            range "5..2048";
          }
        }

        // interface ATM* / pvc * / cell-packing
        container cell-packing {
          tailf:info "ATM Cell packing";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf maxcells {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<2-28>;;Maximum number of Cells in a packet";
              range "2..28";
            }
          }
          leaf mcpt-timer {
            tailf:info "Which MCPT timer to use";
            type uint8 {
              tailf:info "<1-3>;;Which MCPT timer to use";
              range "1..3";
            }
          }
        }

        // interface ATM* / pvc * / encapsulation
        choice encap-choice {
          leaf encapsulation {
            tailf:info "Select ATM Encapsulation for VC";
            tailf:cli-full-command;
            type enumeration {
              enum aal0 {
                         tailf:info "Raw Cell, No SAR processing(Like-Like)";
              }
              enum aal5 {
                         tailf:info "AAL5 Encapsulation(Like-Like)";
              }
              enum aal5snap {
                             tailf:info "AAL5+LLC/SNAP Encapsulation";
              }
              enum aal5nlpid {
                              tailf:info "AAL5+NLPID Encapsulation";
              }
            }
          }
          // interface ATM* / pvc * / encapsulation aal5mux
          container encapsulation-aal5mux {
            tailf:cli-drop-node-name;
            container encapsulation {
              tailf:info "Select ATM Encapsulation for VC";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              tailf:cli-incomplete-command;
              tailf:cli-incomplete-no;
              leaf aal5mux {
                tailf:info "AAL5+MUX Encapsulation";
                tailf:cli-incomplete-command;
                type empty;
              }
              container ppp {
                tailf:info "VC MUX PPP over AAL5 Encapsulation";
                tailf:cli-flatten-container;
                tailf:cli-compact-syntax;
                leaf dialer {
                  tailf:info "pvc is part of dialer profile";
                  type empty;
                }
              }
            }
          }
        }

        // interface ATM* / pvc * / dialer pool-member
        container dialer {
          tailf:info "set dialer pool this pvc belongs to";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          //tailf:cli-delete-when-empty;
          //tailf:cli-incomplete-command;
          presence true;
          leaf pool-member {
            tailf:info "Specify dialer pool membership";
            tailf:cli-remove-before-change;
            type uint8 {
              tailf:info "<1-255>;;Dialer pool number";
              range "1..255";
            }
          }
        }

        // interface ATM* / pvc * / service-policy
        container service-policy {
          tailf:info "Attach a policy-map to a VC";
          tailf:cli-diff-delete-before "/ios:interface/Dialer/service-policy";
          uses service-policy-grouping;
        }

        // interface ATM* / pvc * / pppoe-client
        uses pppoe-client-grouping;

        // interface ATM* / pvc * / xconnect
        uses xconnect-grouping;
      }
    }

    // interface CEM*
    list CEM {
      tailf:info "Circuit Emulation interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;
      uses interface-cem-grouping;
    }

    // interface CEM-ACR*
    list CEM-ACR {
      tailf:info "Circuit Emulation interface with ACR";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      tailf:cli-diff-dependency "../../acr";
      key name;
      leaf name {
        type string {
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;
      uses interface-cem-grouping;
    }

    // interface BDI*
    list BDI {
      tailf:info "Bridge-Domain interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        tailf:cli-diff-dependency "../../../bridge-domain/bridge-domain-list";
        type uint16 {
          tailf:info "<1-8191>;;BDI interface number";
          range "1..8191";
        }
      }
      uses interface-common-pre-grouping;
      uses interface-ethernet-pre-grouping;
      uses interface-ethernet-grouping;
      uses interface-common-macsec-grouping;
      uses interface-ethernet-post-grouping;
    }

    // interface BVI*
    list BVI {
      tailf:info "Bridge-Group Virtual Interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          tailf:info "<1-255>;;BVI interface number";
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;
    }

    // interface CMON-Tunnel*
    list CMON-Tunnel {
      tailf:info "Cable Monitor interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          tailf:info "<0-7>;;CMON-Tunnel interface number";
          pattern '[0-9]+.*';
        }
      }

      // interface CMON-Tunnel* / description
      uses description-grouping;

      // interface CMON-Tunnel* / ip subscriber
      container ip {
        tailf:info "Interface Internet Protocol config commands";
        container subscriber {
          tailf:info "IP session configuration options";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-subscriber";
          presence true;
        }
      }

      // interface CMON-Tunnel* / mode
      container mode {
        tailf:info "Monitor packet encapsulation method";
        choice mode-choice {
          // interface CMON-Tunnel* / mode buffer
          leaf buffer {
            tailf:info "Save monitor packet in local buffer";
            type empty;
          }

          // interface CMON-Tunnel* / mode tunnel
          leaf tunnel {
            tailf:info "Transmit the monitor packet through tunnel";
            type enumeration {
              enum gre {
                tailf:info "generic route encapsulation protocol";
              }
              enum erspan {
                tailf:info "Encapsulated RSPAN";
              }
            }
            default gre;
          }
          default tunnel;
        }
      }

      // interface CMON-Tunnel* / tunnel
      uses interface-tunnel-grouping;
    }

    // interface Cable*
    list Cable {
      tailf:info "CMTS interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;

      // interface Cable* / downstream
      container downstream {
        tailf:info "Associate a Cable/Modular-Cable/Integrated-Cable interface with this CGD host";

        // interface Cable* / downstream Cable * rf-channel *
        list Cable {
          tailf:info "Cable";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          ios:split-range-from "(.+rf-channel )(\\S+)( .*)?";
          key "name rf-channel";
          leaf name {
            type string {
              tailf:info "<slot>/<card>/<port>;;Enter slot/subslot/bay";
            }
          }
          leaf rf-channel {
            tailf:cli-expose-key-name;
            tailf:info "RF channel";
            type uint8 {
              tailf:info "<0-uint8>;;Port number";
            }
          }
          leaf-list upstream {
            tailf:info "Logical Identifier of upstreams serving these downstream rf-channels";
            tailf:cli-range-list-syntax;
            ios:device-range-list-last;
            type uint8 {
              tailf:info "<rangelist>;;List of Ranges for upstream channel";
            }
          }
        }

        // interface Cable* / downstream Modular-Cable * rf-channel *
        list Modular-Cable {
          tailf:info "Modular cable";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          ios:split-range-from "(.+rf-channel )(\\S+)( .*)?";
          key "name rf-channel";
          leaf name {
            type string {
              tailf:info "<slot>/<card>/<port>;;Enter slot/subslot/bay";
            }
          }
          leaf rf-channel {
            tailf:cli-expose-key-name;
            tailf:info "RF channel";
            type uint8 {
              tailf:info "<0-uint8>;;Port number";
            }
          }
          leaf-list upstream {
            tailf:info "Logical Identifier of upstreams serving these downstream rf-channels";
            tailf:cli-range-list-syntax;
            ios:device-range-list-last;
            type uint8 {
              tailf:info "<rangelist>;;List of Ranges for upstream channel";
            }
          }
        }

        // interface Cable* / downstream Integrated-Cable * rf-channel *
        list Integrated-Cable {
          tailf:info "Integrated cable";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          ios:split-range-from "(.+rf-channel )(\\S+)( .*)?";
          key "name rf-channel";
          leaf name {
            type string {
              tailf:info "<slot>/<card>/<port>;;Enter slot/subslot/bay";
            }
          }
          leaf rf-channel {
            tailf:cli-expose-key-name;
            tailf:info "RF channel";
            type uint8 {
              tailf:info "<0-uint8>;;Port number";
            }
          }
          leaf-list upstream {
            tailf:info "Logical Identifier of upstreams serving these downstream rf-channels";
            tailf:cli-range-list-syntax;
            ios:device-range-list-last;
            type uint8 {
              tailf:info "<rangelist>;;List of Ranges for upstream channel";
            }
          }
        }

        // interface Cable* / downstream Downstream-Cable * rf-channel *
        list Downstream-Cable {
          tailf:info "Downstream cable";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          ios:split-range-from "(.+rf-channel )(\\S+)( .*)?";
          key "name rf-channel";
          leaf name {
            type string {
              tailf:info "<slot>/<card>/<port>;;Enter slot/subslot/bay";
            }
          }
          leaf rf-channel {
            tailf:cli-expose-key-name;
            tailf:info "RF channel";
            type uint8 {
              tailf:info "<0-uint8>;;Port number";
            }
          }
          leaf-list upstream {
            tailf:info "Logical Identifier of upstreams serving these downstream rf-channels";
            tailf:cli-range-list-syntax;
            ios:device-range-list-last;
            type uint8 {
              tailf:info "<rangelist>;;List of Ranges for upstream channel";
            }
          }
        }
      }

      // interface Cable* / upstream *
      list upstream {
        tailf:info "Associate a Upstream channel with this CGD host";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          type uint8 {
            tailf:info "<0-15>;;US channel index in MD";
          }
        }
        leaf Upstream-Cable {
          tailf:info "Upstream Cable Controller";
          tailf:cli-incomplete-command;
          type string {
            tailf:info "<slot>/<card>/<port>;;slot/subslot/controller of upstream us-channels";
          }
        }
        leaf us-channel {
          tailf:info "Associate Upstream channels into this MD";
          type uint8 {
            tailf:info "<0-15>;;US channel index in the controller";
          }
        }
      }

      // interface Cable* / cable
      container cable {
        tailf:info "Cable interface subcommands";

        // interface Cable* / cable tftp-enforce
        container tftp-enforce {
          tailf:info "Only allow modems to register if they attempt tftp first";
          tailf:cli-delete-when-empty;
          presence true;
          leaf mark-only {
            tailf:info "Allow registration but mark violating modems with # symbol";
            type empty;
          }
        }

        // interface Cable* / cable ip-init
        leaf ip-init {
          tailf:info "IP Initialization Parameters";
          type enumeration {
            enum apm {
              tailf:info "Alternate Provisioning mode";
            }
            enum dual-stack {
              tailf:info "Dual-stack Provisioning mode";
            }
            enum ipv4 {
              tailf:info "IPv4 Provisioning mode";
            }
            enum ipv6 {
              tailf:info "IPv6 Provisioning mode";
            }
          }
          default ipv4;
        }

        // interface Cable* / cable managed fiber-node
        container managed {
          tailf:info "Manage the interface associated to fiber node";
          leaf fiber-node {
            tailf:info "Fiber node which interface associated";
            type uint16 {
              tailf:info "<1-512>;;Associated fiber-node id";
              range "1..512";
            }
          }
        }

        // interface Cable* / cable mtc-mode
        container mtc-mode {
          tailf:info "Enable/Disable Multiple Transmit Channel Mode";
          presence true;
        }

        // interface Cable* / cable rcc-template *
        list rcc-template {
          tailf:info "Bind RCC template to interface";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key index;
          leaf index {
            type uint8 {
              tailf:info "<1-255>;;cable rcc-template id";
              range "1..255";
            }
          }
        }

        // interface Cable* / cable rcp-control verbose
        container rcp-control {
          tailf:info "Receive Channel Profile control";
          leaf verbose {
            tailf:info "Enable verbose reporting";
            type empty;
          }
        }

        // interface Cable* / cable shared-secret
        container shared-secret {
          tailf:info "Shared Secret String";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          uses password-grouping {
            refine "secret" {
              cli:secret " shared-secret <SECRET>";
            }
          }
        }

        // interface Cable* / cable dynamic-secret
        container dynamic-secret {
          tailf:info "Enable dynamic secret for CM config files";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          choice dynamic-secret-choice {
            case reject {
              leaf reject {
                tailf:info "Reject registration request from modems violating dynamic secret";
                type empty;
              }
            }
            case mark {
              leaf mark {
                tailf:info "Mark modems violating dynamic secret";
                type empty;
              }
            }
            case lock {
              leaf lock {
                tailf:info "Lock modems violating dynamic secret";
                type empty;
              }
              leaf lock-qos {
                tailf:cli-drop-node-name;
                tailf:cli-optional-in-sequence;
                type uint16 {
                  tailf:info "<1-1023>;;Profile used to lock";
                  range "1..1023";
                }
              }
            }
          }
          leaf nocrypt {
            tailf:info "Do not encrypt modem config file name";
            type empty;
          }
        }

        // interface Cable* / no cable d31-mode
        leaf d31-mode {
          tailf:info "enable DOCSIS3.1 mode";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }

        // interface Cable* / cable udc-capability
        leaf udc-capability {
          tailf:info "Enable/Disable Upstream Drop Classifier Capability";
          type empty;
        }

        // interface Cable* / cable enable-trap
        container enable-trap {
          tailf:info "Enable an SNMP cable trap";
          leaf cmonoff-notification {
            tailf:info "Cable Modem Online/Offline notification";
            type empty;
          }
          leaf cmonoff-interval {
            tailf:info "Interval in Seconds";
            type uint32 {
              tailf:info "<0-86400>;;Interval in secs";
              range "0..86400";
            }
          }
        }

        // interface * / no cable packet-cache
        leaf packet-cache {
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }

        // interface Cable* / cable default-phy-burst
        leaf default-phy-burst {
          tailf:info "Max phy burst if max long data grant is 0";
          type uint16 {
            tailf:info "<0-4096>;;Maximal number of bytes allowed in a burst";
            range "0..4096";
          }
        }

        // interface Cable* / cable insertion-interval
        container insertion-interval {
          tailf:info "Period between initial ranging opportunities - msec";
          choice interval-choice {
            leaf fixed-intrvl {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<100-2000>;;Fixed period between initial ranging slots - msec";
              }
            }
            container automatic {
              tailf:info "Use automatic adjustment algorithm for initial ranging period";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf min-intrvl {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<20-120>;;Lower bound on period between initial ranging slots - msecs";
                  range "20..120";
                }
                default 60;
              }
              leaf max-intrvl {
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<240-1800>;;Upper bound on period between initial ranging slots - msecs";
                  range "240..1800";
                }
                default 480;
              }
            }
          }
        }

        // interface Cable* / cable map-advance
        uses cable-map-advance-grouping;

        // interface Cable* / cable sync-interval
        leaf sync-interval {
          tailf:info "Interval between CMTS transmission of successive SYNC";
          type uint16 {
            tailf:info "<1-200>;;sync interval - msec";
            range "1..200";
          }
        }

        // interface Cable* / cable bundle
        leaf bundle {
          tailf:info "Bundle number for bundling of cable interfaces";
          type uint8 {
            tailf:info "<1-255>;;Bundle number";
            range "1..255";
          }
        }

        // interface Cable* / cable downstream
        container downstream {
          tailf:info "Downstream parameter configuration";

          // interface Cable* / cable downstream description
          leaf description {
            tailf:info "Downstream name/description";
            tailf:cli-multi-value;
            tailf:cli-preformatted;
            tailf:cli-full-command;
            type string {
              tailf:info "LINE;;Up to 80 characters describing this DS port";
              length "0..80";
            }
          }

          // interface Cable* / cable downstream dsg
          container dsg {
            tailf:info "Downstream DSG settings";
            // interface Cable* / cable downstream dsg timer
            leaf timer {
              tailf:info "DSG Timer Setting";
              type uint16 {
                tailf:info "<1-65535>;;DSG timer index.";
              }
            }
            // interface Cable* / cable downstream dsg tg *
            list tg {
              tailf:info "DSG Tunnel group";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key tgid;
              leaf tgid {
                type uint16 {
                  tailf:info "<1-65535>;;DSG Tunnel Group ID";
                  range "1..65535";
                }
              }
              // interface Cable* / cable downstream dsg tg * channel *
              list channel {
                tailf:info "DSG Channel";
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                key channel-id;
                leaf channel-id {
                  type uint16 {
                    tailf:info "<1-65535>;;DSG Channel ID";
                    range "1..65535";
                  }
                }
              }
            }
          }
        }

        // interface Cable* / cable upstream
        container upstream {
          tailf:info "Upstream port configuration";

          // interface Cable* / cable upstream balance-scheduling
          leaf balance-scheduling {
            tailf:info "upstream channel balance scheduling on one mac-domain";
            type empty;
          }

          // interface Cable* / cable upstream max-ports
          leaf max-ports {
            tailf:info "Maximum number of upstream ports for this interface";
            type uint8 {
              tailf:info "<0-8>;;Number of upstreams";
              range "0..8";
            }
          }

          // interface Cable* / cable upstream bonding-group *
          list bonding-group {
            tailf:info "Configure upstream bonding group";
            tailf:cli-mode-name "config-upstream-bonding";
            key id;
            leaf id {
              type uint16 {
                tailf:info "<1-65535>;;bonding group id";
                range "1..65535";
              }
            }

            // interface Cable* / cable upstream bonding-group * / description
            uses description-grouping;

            // interface Cable* / cable upstream bonding-group * / upstream *
            list upstream {
              tailf:info "Add an upstream to this bonding group.";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key number;
              leaf number {
                type uint8 {
                  tailf:info "<0-4>;;upstream to add";
                }
              }
            }

            // interface Cable* / cable upstream bonding-group * / attributes
            leaf attributes {
              tailf:info "Configure attributes for this bonding group.";
              type string {
                tailf:info "<0-FFFFFFFF>;;UBG Attribute Value in hex";
              }
            }
          }

          // interface Cable* / cable upstream *
          list cable-upstream-list {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key port;
            leaf port {
              type uint8 {
                tailf:info "<0-uint8>;;Port number";
              }
            }

            // interface Cable* / cable upstream * connector
            leaf connector {
              tailf:info "Physical upstream connector";
              type uint8 {
                tailf:info "<0-19>;;Physical port number";
                range "0..19";
              }
            }

            // interface Cable* / cable upstream * frequency
            leaf frequency {
              tailf:info "Frequency";
              type uint32 {
                tailf:info "<5000000-85000000>;;Upstream Frequency in Hz";
                range "5000000..85000000";
              }
            }

            // interface Cable* / cable upstream * channel-width
            container channel-width {
              tailf:info "Channel width in HZ";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf first-choice-width {
                tailf:cli-drop-node-name;
                type uint32 {
                  tailf:info "Channel width Hz";
                }
              }
              leaf last-choice-width {
                tailf:cli-drop-node-name;
                type uint32 {
                  tailf:info "Channel width Hz";
                }
              }
            }

            // interface Cable* / cable upstream * description
            leaf description {
              tailf:info "Upstream name/description";
              tailf:cli-multi-value;
              tailf:cli-preformatted;
              tailf:cli-full-command;
              type string {
                tailf:info "LINE;;Up to 80 characters describing this US port";
              }
            }

            // interface Cable* / cable upstream * docsis-mode
            leaf docsis-mode {
              tailf:info "Upstream channel DOCSIS mode";
              type enumeration {
                enum atdma {
                  tailf:info "DOCSIS 2.0 ATDMA-only channel";
                }
                enum scdma {
                  tailf:info "DOCSIS 2.0 SCDMA-only channel";
                }
                enum tdma {
                  tailf:info "DOCSIS 1.x-only channel";
                }
                enum tdma-atdma {
                  tailf:info "DOCSIS 1.x and DOCSIS 2.0 mixed channel";
                }
              }
            }

            // interface Cable* / cable upstream * minislot-size
            leaf minislot-size {
              tailf:info "Minislot size";
              type uint8 {
                tailf:info "Minislot size in time ticks";
                range "1|2|4|8|16|32|64|128";
              }
            }

            // interface Cable* / cable upstream * power-adjust
            container power-adjust {
              tailf:info "Power adjustment";
              // interface Cable* / cable upstream * power-adjust continue
              leaf continue {
                tailf:info "Minimum power adjustment which set CONTINUEranging status";
                type uint8 {
                  tailf:info "<2-15>;;Power level in dB";
                  range "2..15";
                }
              }
            }

            // interface Cable* / cable upstream * range-backoff
            container range-backoff {
              tailf:info "Change Range Backoff Value";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              choice range-backoff-choice {
                case automatic {
                  leaf automatic {
                    tailf:info "Automatic Change Range Backoff Value";
                    type empty;
                  }
                }
                case numeric {
                  leaf start {
                    tailf:cli-drop-node-name;
                    tailf:cli-incomplete-command;
                    type uint8 {
                      tailf:info "<0-15>;;rangebackoff-start";
                    }
                  }
                  leaf end {
                    tailf:cli-drop-node-name;
                    type uint8 {
                      tailf:info "<0-15>;;rangebackoff-end";
                    }
                  }
                }
              }
            }

            // interface Cable* / cable upstream * modulation-profile
            container modulation-profile {
              tailf:info "Modulation Profile Number";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf primary-profile-number {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "VALUE;;modulation number";
                }
              }
              leaf secondary-profile-number {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "VALUE;;secondary modulation number";
                }
              }
              leaf tertiary-profile-number {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "VALUE;;tertiary modulation number";
                }
              }
            }

            // interface Cable* / cable upstream * rate-limit
            // interface Cable* / cable upstream * no rate-limit
            leaf rate-limit {
              tailf:info "Enable DOCSIS rate limiting on current upstream";
              tailf:cli-boolean-no;
              tailf:cli-full-command;
              type boolean;
            }

            // interface Cable* / cable upstream * equalization-coefficient
            leaf equalization-coefficient {
              tailf:info "Enable equalization coefficient";
              type empty;
            }

            // interface Cable* / no cable upstream * equalization-error-recovery
            leaf equalization-error-recovery {
              tailf:info "Enable equ coeff error recovery";
              tailf:cli-boolean-no;
              tailf:cli-full-command;
              type boolean;
              default true;
            }

            // interface Cable* / cable upstream * rate-adapt
            container rate-adapt {
              tailf:info "Configure upstream rate-adapt";
              presence true;
            }

            // interface Cable* / cable upstream * attribute-mask
            leaf attribute-mask {
              tailf:info "Upstream Channel Provisioned Attribute Mask";
              type string {
                tailf:info "<0-FFFFFFFF>;;Attribute mask in hex";
              }
            }

            // interface Cable* / cable upstream * chan-class-id
            leaf chan-class-id {
              tailf:info "Channel Class ID";
              type string {
                tailf:info "<0-FFFFFFFF>;;Class ID Extension";
              }
            }

            // interface Cable* / cable upstream * shutdown
            // interface Cable* / cable upstream * no shutdown
            leaf shutdown {
              tailf:info "Shutdown upstream port";
              tailf:cli-boolean-no;
              tailf:cli-full-command;
              type boolean;
            }
          }

          // interface Cable* / cable upstream ranging-poll
          container ranging-poll {
            tailf:info "Configure per mac upstream polling interval";
            tailf:cli-compact-syntax;
            tailf:cli-full-no;
            leaf interval {
              tailf:info "per mac ranging interval in seconds";
              type uint16 {
                tailf:info "<20000-30000>;;ranging timeout in milliseconds";
                range "20000..30000";
              }
            }
            leaf t4-multiplier {
              tailf:info "T4 multiplier ranged from 1 to 10, 0 as auto";
              type uint8 {
                tailf:info "<0-10>;;ranged from 1 to 10, 0 as auto";
                range "0..10";
              }
            }
          }

          // interface Cable* / cable upstream resiliency
          container resiliency {
            tailf:info "upstream resiliency configuration";

            // interface Cable* / cable upstream resiliency on-failure
            leaf on-failure {
              tailf:info "ranging retries exceeded error handling";
              type enumeration {
                enum disable-channel {
                  tailf:info "disable channel";
                }
                enum extended-ranging {
                  tailf:info "continue to range";
                }
                enum reset-modem {
                  tailf:info "take modem offline";
                }
              }
              default extended-ranging;
            }

            // interface Cable* / cable upstream resiliency sf-move *
            list sf-move {
              tailf:info "enable service flow move";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key name;
              leaf name {
                type enumeration {
                  enum RTPS {
                    tailf:info "move service flows of type RTPS";
                  }
                  enum NRTPS {
                    tailf:info "move service flows of type NRTPS";
                  }
                  enum UGS {
                    tailf:info "move service flows of type UGS";
                  }
                  enum UGS-AD {
                    tailf:info "move service flows of type UGS-AD";
                  }
                }
              }
            }
          }

          // interface Cable* / no cable upstream ext-power
          leaf ext-power {
            tailf:info "Extended Upstream Transmit Power";
            tailf:cli-boolean-no;
            tailf:cli-full-command;
            type boolean;
            default true;
          }

          // interface Cable* / cable upstream max-channel-power-offset
          leaf max-channel-power-offset {
            tailf:info "maximum trasmit channel power offset";
            type uint8 {
              tailf:info "<0-12>;;0 to 12 dB";
              range "0..12";
            }
          }
        }

        // interface Cable* / cable sid-cluster-group
        container sid-cluster-group {
          tailf:info "SID Cluster Group parameters for Upstream Channel Bonding";

          // interface Cable* / cable sid-cluster-group dynamic
          leaf dynamic {
            tailf:info "Dynamic algorithm";
            type empty;
          }

          // interface Cable* / cable sid-cluster-group num-of-cluster
          leaf num-of-cluster {
            tailf:info "Number of SID Cluster Group";
            type uint8 {
              tailf:info "<1-8>;;1, 2, 3, 4, 5, 6, 7, 8";
              range "1..8";
            }
          }

          // interface Cable* / cable sid-cluster-group req-multiplier
          leaf req-multiplier {
            tailf:info "Request Multiplier";
            type uint8 {
              tailf:info "<1-16>;;1, 2, 4, 8, 16";
              range "1|2|4|8|16";
            }
          }
        }

        // interface Cable* / cable sid-cluster-switching
        container sid-cluster-switching {
          tailf:info "SID Cluster Switching parameters for Upstream Channel Bonding";

          // interface Cable* / cable sid-cluster-switching max-request
          leaf max-request {
            tailf:info "Max request";
            type uint8 {
              tailf:info "<0-255>;;0 to 255";
            }
          }

          // interface Cable* / cable sid-cluster-switching max-time
          leaf max-time {
            tailf:info "Max time";
            type uint16 {
              tailf:info "<0-65535>;;0 to 65535";
            }
          }
        }

        // interface Cable* / cable divert-rate-limit
        container divert-rate-limit {
          tailf:info "Set divert-rate-limit parameters";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf rate {
            tailf:info "rate in packets/sec";
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<1-65535>;;rate in packets/second";
            }
          }
          leaf limit {
            tailf:info "limit in packets";
            type uint16 {
              tailf:info "<4-4194>;;limit in packets";
            }
          }
        }

        // interface Cable* / cable mac-domain-profile
        leaf mac-domain-profile {
          tailf:info "Mac Domain profile configuration";
          tailf:non-strict-leafref {
            path "/ios:cable/profile/mac-domain/name";
          }
          tailf:cli-diff-set-before "../map-advance";
          type string {
            tailf:info "WORD;;mac-domain common profile name";
          }
        }

        // interface Cable* / cable privacy
        container privacy {
          tailf:info "Cable Privacy";

          // interface Cable* / cable privacy mandatory
          leaf mandatory {
            tailf:info "force privacy be mandatory";
            type empty;
          }

          // interface Cable* / cable privacy bpi-plus-policy
          leaf bpi-plus-policy {
            tailf:info "Privacy requires BPI+";
            type enumeration {
              enum capable-enforcement {
                tailf:info "BPI+ required for all capable modems with BPI+ enabled (policy 1)";
              }
              enum d11-enabled-enforcement {
                tailf:info "BPI+ required for all D1.1 and later modems with BPI+ enabled (policy 2)";
              }
              enum d11-enforcement {
                tailf:info "BPI+ required for all D1.1 and later modems (policy 3)";
              }
              enum total-enforcement {
                tailf:info "BPI+ required for all modems (policy 4)";
              }
            }
          }

          // interface Cable* / cable privacy accept-self-signed-certificate
          leaf accept-self-signed-certificate {
            tailf:info "Accept Self signed Manufacturer certificate";
            type empty;
          }

          // interface Cable* / cable privacy eae-policy
          leaf eae-policy {
            tailf:info "Select EAE Policy";
            type enumeration {
              enum capability-enforcement {
                tailf:info "Enforce on EAE capable modems (policy 3)";
                value 3;
              }
              enum disable-enforcement {
                tailf:info "Disable EAE (policy 1)";
                value 1;
              }
              enum ranging-enforcement {
                tailf:info "Enforce on DOCSIS 3.0 modems (policy 2)";
                value 2;
              }
              enum total-enforcement {
                tailf:info "Enforce EAE on all modems (policy 4)";
                value 4;
              }
            }
          }

          // interface Cable* / cable privacy skip-validity-period
          leaf skip-validity-period {
            tailf:info "Skip certificate validity period";
            type empty;
          }
        }

        // interface Cable* / no cable diplexer-band-edge
        leaf diplexer-band-edge {
          tailf:info "Transmit Diplexer Band Edges in MDD";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }

        // interface Cable* / cable cm-status enable *
        container cm-status {
          tailf:info "CM-STATUS events";
          leaf-list enable {
            tailf:info "enable CM-STATUS events";
            tailf:cli-range-list-syntax;
            ios:device-range-list-last;
            type uint8 {
              tailf:info "<grouplist>;;CM-STATUS event list to enable: 3|6-11|16-18|20-27";
            }
          }
        }
      }
    }

    // interface Video*
    list Video {
      tailf:info "video service interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;
    }

    // interface Integrated-Cable*
    list Integrated-Cable {
      tailf:info "Integrated Cable interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      ios:shutdown-before-delete;
      key name;
      leaf name {
        type string {
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;

      // interface Integrated-Cable * / cable
      container cable {
        tailf:info "Integrated-Cable interface subcommands";

        // interface Integrated-Cable* / cable downstream
        container downstream {
          tailf:info "Downstream parameter configuration";

          // interface Integrated-Cable* / cable downstream qos wfq weights
          container qos {
            tailf:info "Configure downstream quality of service";
            container wfq {
              tailf:info "Weighted Fair Queuing";
              container weights {
                tailf:info "configure custom weights for 8 priorites";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                leaf pri0 {
                  tailf:cli-drop-node-name;
                  tailf:cli-incomplete-command;
                  type uint8 {
                    tailf:info "<1-100>;;weight pri0";
                    range "1..100";
                  }
                }
                leaf pri1 {
                  tailf:cli-drop-node-name;
                  tailf:cli-incomplete-command;
                  type uint8 {
                    tailf:info "<1-100>;;weight pri1";
                    range "1..100";
                  }
                }
                leaf pri2 {
                  tailf:cli-drop-node-name;
                  tailf:cli-incomplete-command;
                  type uint8 {
                    tailf:info "<1-100>;;weight pri2";
                    range "1..100";
                  }
                }
                leaf pri3 {
                  tailf:cli-drop-node-name;
                  tailf:cli-incomplete-command;
                  type uint8 {
                    tailf:info "<1-100>;;weight pri3";
                    range "1..100";
                  }
                }
                leaf pri4 {
                  tailf:cli-drop-node-name;
                  tailf:cli-incomplete-command;
                  type uint8 {
                    tailf:info "<1-100>;;weight pri4";
                    range "1..100";
                  }
                }
                leaf pri5 {
                  tailf:cli-drop-node-name;
                  tailf:cli-incomplete-command;
                  type uint8 {
                    tailf:info "<1-100>;;weight pri5";
                    range "1..100";
                  }
                }
                leaf pri6 {
                  tailf:cli-drop-node-name;
                  tailf:cli-incomplete-command;
                  type uint8 {
                    tailf:info "<1-100>;;weight pri6";
                    range "1..100";
                  }
                }
                leaf pri7 {
                  tailf:cli-drop-node-name;
                  type uint8 {
                    tailf:info "<1-100>;;weight pri7";
                    range "1..100";
                  }
                }
              }
            }
          }
        }

        // interface Integrated-Cable* / cable bundle [READ-ONLY]
        leaf bundle {
          tailf:info "Bundle number for bundling of IC cable interfaces";
          type uint8 {
            tailf:info "<1-255>;;Bundle number";
            range "1..255";
          }
        }

        // interface Integrated-Cable* / cable managed fiber-node
        container managed {
          tailf:info "Manage integrated-cable interface associated to fiber node";
          leaf fiber-node {
            tailf:info "Fiber node which interface associated";
            type uint16 {
              tailf:info "<1-512>;;Associated fiber-node id";
              range "1..512";
            }
          }
        }

        // interface Integrated-Cable* / cable rf-bandwidth-percent
        container rf-bandwidth-percent {
          tailf:info "% of reserved RF channel bandwidth";
          leaf percent-value {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-100>;;% bandwidth";
              range "1..100";
            }
          }
        }
      }
    }

    // interface Modular-Cable*
    list Modular-Cable {
      tailf:info "Modular Cable interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;

      // interface Modular-Cable* / cable
      container cable {
        tailf:info "MC Cable interface subcommands";

        // interface Modular-Cable* / cable bundle [READ-ONLY]
        leaf bundle {
          tailf:info "Bundle number for bundling of MC cable interfaces";
          type uint8 {
            tailf:info "<1-255>;;Bundle number";
            range "1..255";
          }
        }

        // interface Modular-Cable* / cable rf-bandwidth-percent
        container rf-bandwidth-percent {
          tailf:info "% of RF channel bandwidth reserved for this MC interface";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf percent-value {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-96>;;% bandwidth";
              range "1..96";
            }
          }
          container remaining {
            tailf:info "ratio of the remaining bandwidth";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            leaf ratio {
              tailf:info "ratio for sharing excess bandwidth";
              type uint8 {
                tailf:info "<1-100>;;Ratio";
              }
            }
          }
        }

        // interface Modular-Cable* / cable cm-status
        container cm-status {
          tailf:info "CM-STATUS events";

          // interface Modular-Cable* / no cable cm-status enable
          // interface Modular-Cable* / cable cm-status enable no-list
          container enable {
            tailf:info "enable CM-STATUS events";
            leaf no-list {
              tailf:info "'no cable cm-status enable' entry";
              tailf:cli-multi-value;
              tailf:cli-preformatted;
              tailf:cli-full-command;
              type string {
                tailf:info "<grouplist>;;CM-STATUS event list to disable";
              }
            }
          }
        }
      }
    }

    // interface Downstream-Cable*
    list Downstream-Cable {
      tailf:info "Downstream Cable interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;

      // interface Downstream-Cable* / cable
      container cable {
        tailf:info "Integrated-Cable interface subcommands";

        // interface Downstream-Cable* / cable bundle
        leaf bundle {
          tailf:info "Bundle number for bundling of IC cable interfaces";
          type uint8 {
            tailf:info "<1-255>;;Bundle number";
            range "1..255";
          }
        }

        // interface Downstream-Cable* / cable managed fiber-node
        container managed {
          tailf:info "Manage integrated-cable interface associated to fiber node";
          leaf fiber-node {
            tailf:info "Fiber node which interface associated";
            type uint16 {
              tailf:info "<1-512>;;Associated fiber-node id";
              range "1..512";
            }
          }
        }

        // interface Downstream-Cable* / cable rf-bandwidth-percent
        container rf-bandwidth-percent {
          tailf:info "% of reserved RF channel bandwidth";
          leaf percent-value {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-100>;;% bandwidth";
              range "1..100";
            }
          }
        }
      }
    }

    // interface Wideband-Cable*
    list Wideband-Cable {
      tailf:info "Wideband CMTS interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      ios:shutdown-before-delete;
      key name;
      leaf name {
        type string {
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;

      // interface Wideband-Cable* / cable
      container cable {
        tailf:info "Cable interface subcommands";

        // interface Wideband-Cable* / cable bundle
        leaf bundle {
          tailf:info "Bundle number for bundling of cable interfaces";
          tailf:cli-remove-before-change;
          type uint8 {
            tailf:info "<1-255>;;Bundle number";
            range "1..255";
          }
        }

        // interface Wideband-Cable* / cable managed fiber-node
        container managed {
          tailf:info "Manage the interface associated to fiber node";
          leaf fiber-node {
            tailf:info "Fiber node which interface associated";
            type uint16 {
              tailf:info "<1-512>;;Associated fiber-node id";
              range "1..512";
            }
          }
        }

        // interface Wideband-Cable* / cable wideband-profile
        leaf wideband-profile {
          tailf:info "Wideband interface profile";
          tailf:cli-diff-dependency "/ios:cable/profile";
          type string {
            tailf:info "WORD;;Wideband interface common profile name";
          }
        }

        // interface Wideband-Cable* / cable privacy
        container privacy {
          tailf:info "Cable Privacy";

          // interface Wideband-Cable* / cable privacy accept-self-signed-certificate
          leaf accept-self-signed-certificate {
            tailf:info "Accept Self signed Manufacturer certificate";
            type empty;
          }
        }

        // interface Wideband-Cable* / cable ds-resiliency
        leaf ds-resiliency {
          tailf:info "Downstream resiliency bonding group";
          type empty;
        }

        // interface  Wideband-Cable* / cable rf-channel *
        container rf-channel {
          tailf:info "RF channel associated with this Wideband interface";

          // interface Wideband-Cable* / cable rf-channel *
          list rf-channel-list {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            key rf-port;
            leaf rf-port {
              type uint8 {
                tailf:info "<0-23>;;RF channel number";
                range "0..23";
              }
            }

            // interface Cable* / cable rf-channel * bandwidth-percent
            leaf bandwidth-percent {
              tailf:info "% bandwidth of RF channel reserved for this Wideband interface";
              type uint8 {
                tailf:info "<1-100>;;% bandwidth";
                range "1..100";
              }
            }

            // interface Cable* / cable rf-channel * remaining ratio
            container remaining {
              tailf:info "ratio of the remaining bandwidth";
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              leaf ratio {
                tailf:info "ratio for sharing excess bandwidth";
                type uint8 {
                  tailf:info "<1-100>;;Ratio";
                }
              }
            }
          }
        }

        // interface Wideband-Cable* / cable rf-channels
        container rf-channels {
          tailf:info "rf-channels associated with this Wideband interface";

          // interface  Wideband-Cable* / cable rf-channels channel-list *
          list channel-list {
            tailf:info "Configure list of individual rf-channels and ranges of rf-channels";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            key bandwidth-percent;
            leaf bandwidth-percent {
              tailf:cli-expose-key-name;
              tailf:info "% bandwidth of RF channel reserved for this Wideband interface";
              type uint8 {
                tailf:info "<1-100>;;% bandwidth";
                range "1..100";
              }
            }
            leaf-list group-list {
              // Note: List separated by ',' in NCS, on device by ' '. Java converts.
              tailf:cli-drop-node-name;
              tailf:cli-prefix-key;
              tailf:cli-range-list-syntax;
              type uint8 {
                tailf:info "<grouplist>;;List of individual rf-channels and ranges of rf-channels";
              }
            }
          }

          // interface  Wideband-Cable* / cable rf-channels controller *
          list controller {
            tailf:info "Specify controller for rf-channels";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            tailf:cli-incomplete-command;
            key id;
            leaf id {
              type uint8 {
                tailf:info "<0-3>;;Enter controller number";
                range "0..3";
              }
            }
            leaf-list channel-list {
              tailf:info "Configure list of individual rf-channels and ranges of rf-channels";
              // Note: List separated by ',' in NCS, on device by ' '. Java converts.
              tailf:cli-range-list-syntax;
              tailf:cli-incomplete-command;
              tailf:cli-incomplete-no;
              type uint8 {
                tailf:info "<grouplist>;;List of individual rf-channels and ranges of rf-channels";
              }
            }
            leaf bandwidth-percent {
              tailf:info "% bandwidth of RF channel reserved for this Wideband interface";
              type uint8 {
                tailf:info "<1-100>;;% bandwidth";
                range "1..100";
              }
            }
          }
        }

        // interface Wideband-Cable* / cable downstream
        container downstream {
          tailf:info "Downstream parameter configuration";

          // interface Wideband-Cable* / cable downstream attribute-mask
          leaf attribute-mask {
            tailf:info "Downstream channel provisioned Attribute Mask";
            type string {
              tailf:info "<0-FFFFFFFF>;;The attribute bitmap in hex";
            }
          }
        }
      }
    }

    // interface Bundle*
    list Bundle {
      tailf:info "Virtual Bundle";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type uint8 {
          tailf:info "<1-255>;;Bundle interface number";
          range "1..255";
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;

      // interface Bundle* / cable
      container cable {
        tailf:info "Cable interface subcommands";

        uses bundle-interface-cable-common;

        // interface Bundle* / cable arp filter
        container arp {
          tailf:info "Enable arp request";
          container filter {
            tailf:info "Filter arp packets";
            container request-send {
              tailf:info "send x arp requests every y seconds or none";
              tailf:cli-show-no;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              tailf:cli-delete-when-empty;
              tailf:cli-incomplete-command;
              presence true;
              leaf number {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type uint8 {
                  tailf:info "<0-20>;;number of arp request packets";
                }
              }
              leaf window-size {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<1-5>;;size of time window in seconds";
                }
              }
            }
            container reply-accept {
              tailf:info "accept x arp replies every y seconds or none";
              tailf:cli-show-no;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              tailf:cli-delete-when-empty;
              tailf:cli-incomplete-command;
              presence true;
              leaf number {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type uint8 {
                  tailf:info "<0-20>;;number of arp reply packets";
                }
              }
              leaf window-size {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<1-5>;;size of time window in seconds";
                }
              }
            }
          }
        }

        // interface Bundle* / cable dhcp-parse
        container dhcp-parse {
          tailf:info "DHCP parse option";
          leaf option-43 {
            tailf:info "DHCP parse option 43";
            type empty;
          }
          leaf option-60 {
            tailf:info "DHCP parse option 60";
            type empty;
          }
        }
      }
    }

    // interface Bundle#.#
    container Bundle-subinterface {
      tailf:cli-drop-node-name;
      list Bundle {
        tailf:info "Virtual Bundle";
        tailf:cli-allow-join-with-key {
          tailf:cli-display-joined;
        }
        tailf:cli-mode-name "config-subif";
        tailf:cli-suppress-key-abbreviation;
        key name;
        leaf name {
          tailf:cli-diff-dependency "../../../Bundle";
          type string {
            pattern '[0-9]+\.[0-9]+';
          }
        }
        uses interface-common-pre-grouping;
        uses interface-common-grouping;

        // interface Bundle#.# / cable
        container cable {
          tailf:info "Cable interface subcommands";
          uses bundle-interface-cable-common;
        }
      }
    }

    // interface Cellular*
    list Cellular {
      tailf:info "Cellular WAN interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;
      uses interface-pointtopoint-grouping;
    }

    // interface Qam-red*
    list Qam-red {
      tailf:info "QAM red interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;

      // interface Qam-red* / cable
      container cable {
        tailf:info "cable config for qam subinterfaces";

        // interface Qam-red* / cable carrier-id
        leaf carrier-id {
          tailf:info "QAM carrier id. 1-192 ids are for QAM block 1, 193-384 for QAM block 2";
          type uint16 {
            tailf:info "<1-384>;;QAM Carrier id per line card";
            range "1..384";
          }
        }

        // interface Qam-red* / cable mode depi
        container mode {
          tailf:info "Setup qam channel mode to DEPI or Video";
          container depi {
            tailf:info "DEPI mode";
            choice depi-choice {
              container local {
                tailf:info "Sessions are configured locally";
              }

              // interface Qam-red* / cable mode depi remote
              container remote {
                tailf:info "Sessions are configured remotely";
                tailf:cli-delete-when-empty;
                presence true;
                // interface Qam-red* / cable mode depi remote learn
                leaf learn {
                  tailf:info "QAM can be configured remotely";
                  type empty;
                }
              }
            }
          }
        }

        // interface Qam-red* / cable downstream
        container downstream {
          tailf:info "downstream port of the line card";

          // interface Qam-red* / cable downstream max-carriers
          leaf max-carriers {
            tailf:info "max carriers per port";
            tailf:cli-full-command;
            type uint8 {
              tailf:info "<1-128>;;max carriers per port";
              range "1..128";
            }
          }

          // interface Qam-red* / cable downstream lqam-group
          leaf lqam-group {
            tailf:info "Logical QAM group";
            type uint8 {
              tailf:info "<1-48>;;QAM Logical group per line card";
              range "1..48";
            }
          }

          // interface Qam-red* / cable downstream tsid
          leaf tsid {
            tailf:info "set the downstream transport stream id";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<1-65535>;;transport stream id";
            }
          }
        }
      }

      // interface Qam-red* / depi depi-tunnel
      container depi {
        tailf:info "DEPI Session commands";
        leaf depi-tunnel {
          tailf:info "Name to use for DEPI Tunnel";
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;Enter DEPI Tunnel Name";
          }
        }
      }
    }

    // interface Asi *
    list Asi {
      tailf:info "ASI interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;
    }

    // interface Vlan*
    list Vlan {
      tailf:info "Vlan interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-diff-dependency "../../vlan/vlan-list";
      tailf:cli-recursive-delete; // deleted interface does not remove some config
      key name;
      leaf name {
        type uint16 {
          tailf:info "<1-4094>;;Vlan interface number";
          range "1..4094";
        }
      }
      uses interface-common-pre-grouping;
      uses interface-ethernet-pre-grouping;
      uses interface-ethernet-grouping;
      uses interface-common-macsec-grouping;
      uses interface-ethernet-post-grouping;

      // interface Vlan* / no autostate
      leaf autostate {
        tailf:info "Enable autostate determination for VLAN";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }
    }

    // interface Async*
    list Async {
      tailf:info "Async interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Async interface id";
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;
      uses interface-pointtopoint-grouping;

      // interface Async* / ignore
      container ignore {
        tailf:info "ignore signals or crc(if applicable)";
        leaf dcd {
          tailf:info "DTE ignore dcd";
          type empty;
        }
        leaf cts {
          tailf:info "DTE ignore cts";
          type empty;
        }
        leaf dsr {
          tailf:info "DTE ignore dsr";
          type empty;
        }
      }
    }

    // interface Group-Async*
    list Group-Async {
      tailf:info "Async Group interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type uint16 {
          tailf:info "<0-64>;;Group-Async interface number";
          range "0..64";
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;
      uses interface-pointtopoint-grouping;
    }

    // interface POS*
    list POS {
      tailf:info "POS interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;
      uses interface-pointtopoint-grouping;


      // interface POS* / aps
      container aps {
        tailf:info "Configure APS";

        // interface POS* / aps group
        leaf group {
          tailf:info "Group association";
          type uint8 {
            tailf:info "Number of the group. Range is from 1 through 255.";
            range "1..255";
          }
        }

        // interface POS* / aps protect *
        list protect {
          tailf:info "Protect specified circuit";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key "circuit-number ip-address";
          leaf circuit-number {
            type uint32 {
              tailf:info "Number of the circuit to enable as a protect interface.";
            }
          }
          leaf ip-address {
            type inet:ip-address {
              tailf:info "IP address of the router that has the working POS interface.";
            }
          }
        }

        // interface POS* / aps working
        leaf working {
          tailf:info "Working channel number";
          type uint32 {
            tailf:info "Circuit number associated with this working interface.";
          }
        }
      }

      // interface POS* / pos
      container pos {
        tailf:info "Modify POS parameters";

        // interface POS* / pos ais-shut
        leaf ais-shut {
          tailf:info "Enable sending SONET/SDH LAIS when shutdown";
          tailf:cli-full-command;
          type empty;
        }

        // interface POS* / pos framing
        leaf framing {
          tailf:info "specify framing";
          tailf:cli-full-command;
          type enumeration {
            enum sdh {
              tailf:info "Select sdh framing";
            }
            enum sonet {
              tailf:info "Select sonet framing(default)";
            }
          }
          default sonet;
        }

        // interface POS* / pos report
        container report {
          tailf:info "Configure SONET/SDH path alarm reporting";

          // interface POS* / pos report rdool
          leaf rdool {
            type empty;
          }

          // interface POS* / pos report lais
          leaf lais {
            tailf:info "Set Path Alarm Indication Signal reporting status";
            type empty;
          }

          // interface POS* / pos report lrdi
          leaf lrdi {
            type empty;
          }

          // interface POS* / pos report pais
          leaf pais {
            tailf:info "Set Path Alarm Indication Signal reporting status";
            type empty;
          }

          // controller SONET * / path report prdi
          leaf prdi {
            tailf:info "Set Path Remote Defect Indication reporting status";
            type empty;
          }

          // controller SONET * / path report sd-ber
          leaf sd-ber {
            type empty;
          }
        }

        // interface POS* / pos scramble-atm
        leaf scramble-atm {
          tailf:info "Enable ATM scrambling";
          tailf:cli-full-command;
          type empty;
        }

        // interface POS* / pos threshold
        container threshold {
          tailf:info "Configure SONET/SDH section/line BER threshold values";

          // interface POS* / pos threshold sf-ber
          leaf sf-ber {
            tailf:info "Set Signal Fail BER threshold";
            tailf:cli-full-command;
            type uint8 {
              tailf:info "<3-9>;;Bit error rate (10 to the minus n) (default 3)";
              range "3..9";
            }
            default 3;
          }
        }

        // interface POS* / pos flag
        container flag {
          tailf:info "Specify byte value";

          // interface POS* / pos flag c2
          leaf c2 {
            tailf:info "Path overhead byte";
            tailf:cli-full-command;
            type uint8 {
              tailf:info "<0-255>;;byte value";
            }
          }

          // interface POS* / pos flag j0
          leaf j0 {
            tailf:info "Section trace byte (default is 0x01)";
            tailf:cli-full-command;
            type uint8 {
              tailf:info "<0-255>;;byte value";
            }
          }

          // interface POS* / pos flag s1s0
          leaf s1s0 {
            tailf:info "Specify bit S1 and S0 of H1 (default is 0)";
            type uint8 {
              tailf:info "<0-3>;;S1 & S0 bits (default is 0)";
              range "0..3";
            }
            default 0;
          }
        }

        // interface POS* / pos delay triggers
        container delay {
          tailf:info "Delay POS alarm triggers";
          container triggers {
            tailf:info "Triggers line protocol to go down";

            // interface POS* / pos delay triggers line
            leaf line {
              tailf:info "Specify delay for SONET LINE level triggers (S-LOS, S-LOF, L-AIS)";
              type uint16 {
                tailf:info "<0-60000>;;Holdoff time, in msec";
                range "0..60000";
              }
            }

            // interface POS* / pos delay triggers line path
            leaf path {
              tailf:info "Enable SONET PATH level triggers (P-AIS, P-LOP, P-RDI), with optional delay";
              type uint16 {
                tailf:info "<0-60000>;;Holdoff time, in msec";
                range "0..60000";
              }
            }
          }
        }

      }
    }

    // interface SM*
    list SM {
      tailf:info "Services Module (SM) with Services Ready Engine (SRE)";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          pattern '[0-9]+/[0-9]+';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;
    }

    // interface Serial*
    list Serial {
      tailf:info "Serial interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      tailf:cli-recursive-delete;
      key name;
      leaf name {
        tailf:cli-diff-dependency "../../Multilink";
        type string {
          pattern '[0-9]+(/[\.0-9]+)*(:[0-9]+)?';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-ptp-grouping;
      uses interface-pointtopoint-grouping;
      uses xconnect-grouping;
    }

    // subinterface Serial*
    container Serial-subinterface {
      tailf:cli-drop-node-name;
      list Serial {
        tailf:info "Serial interface";
        tailf:cli-allow-join-with-key {
          tailf:cli-display-joined;
        }
        tailf:cli-mode-name "config-subif";
        tailf:cli-suppress-key-abbreviation;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          tailf:cli-diff-dependency "../../../Serial";
          tailf:cli-diff-dependency "../../../Multilink";
          type string {
            pattern '[0-9]+(/[\.0-9]+)*(:[0-9]+)?\.[0-9]+';
          }
        }
        leaf type {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum multipoint {
              tailf:info "Treat as a multipoint link";
            }
            enum point-to-point {
              tailf:info "Treat as a point-to-point link";
            }
          }
        }
        uses interface-common-pre-grouping;
        uses interface-common-ptp-grouping;
        uses interface-pointtopoint-grouping;
        uses xconnect-grouping;
      }
    }

    // interface Virtual-Template*
    list Virtual-Template {
      tailf:info "Virtual Template interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      tailf:cli-recursive-delete;
      tailf:cli-explicit-exit;
      key name;
      leaf name {
        type uint16 {
          tailf:info "<1-4095>;;Virtual-Template interface number";
          range "1..4095";
        }
      }

      // interface Virtual-Template* type
      leaf type {
        tailf:info "type of the virtual-template";
        tailf:cli-hide-in-submode;
        type enumeration {
          enum ethernet {
            tailf:info "Set VT type as ethernet";
          }
          enum serial {
            tailf:info "Set VT type as serial";
          }
          enum tunnel {
            tailf:info "Set VT type as tunnel";
          }
        }
      }

      uses interface-common-pre-grouping;
      uses interface-ethernet-pre-grouping;
      uses interface-ethernet-grouping;
      uses interface-common-macsec-grouping;
      uses interface-ethernet-post-grouping;
      uses interface-pointtopoint-grouping;
      uses interface-tunnel-grouping;
    }

    // interface Virtual-PPP*
    list Virtual-PPP {
      tailf:info "Virtual PPP interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      tailf:cli-explicit-exit;
      key name;
      leaf name {
        type uint32 {
          tailf:info "<1-2147483647>;;Virtual-PPP interface number";
          range "1..2147483647";
        }
      }
      uses interface-common-pre-grouping;
      uses interface-ethernet-pre-grouping;
      uses interface-ethernet-grouping;
      uses interface-common-macsec-grouping;
      uses interface-ethernet-post-grouping;
      uses interface-pointtopoint-grouping;
      uses interface-tunnel-grouping;
    }

    // interface pseudowire*
    list pseudowire {
      tailf:info "Pseudowire Interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      ios:redeploy-with-change " no encapsulation ";
      key name;
      leaf name {
        type uint32 {
          tailf:info "<1-231072>;;pseudowire interface number";
          range "1..231072";
        }
      }

      // interface pseudowire* / description
      leaf description {
        tailf:info "Interface specific description";
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;Description string";
          length "0..200";
        }
      }

      // interface pseudowire* / shutdown
      leaf shutdown {
        tailf:info "Shutdown the selected interface";
        tailf:cli-show-no;
        tailf:cli-full-command;
        type empty;
      }

      // interface pseudowire* / source
      container source {
        tailf:info "Get config from another source";
        container template {
          tailf:info "Get config from a template";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf type {
            tailf:info "Type of the template";
            type enumeration {
              enum pseudowire {
                tailf:info "Template customized interface pseudowire";
              }
            }
          }
          leaf name {
            tailf:cli-drop-node-name;
            tailf:non-strict-leafref {
              path "../../../../../template/name";
            }
            type string {
              tailf:info "WORD;;Template name";
            }
          }
        }
      }

      // interface pseudowire* / encapsulation
      leaf encapsulation {
        tailf:info "Data encapsulation method";
        tailf:cli-full-command;
        type enumeration {
          enum l2tpv3 {
            tailf:info "Use L2TPv3 encapsulation";
          }
          enum mpls {
            tailf:info "Use MPLS encapsulation";
          }
        }
      }

      // interface pseudowire* / signaling protocol
      container signaling {
        tailf:info "Signaling options";
        leaf protocol {
          tailf:info "Signaling protocol to use";
          type enumeration {
            enum ldp {
              tailf:info "Use LDP signaling";
            }
            enum none {
              tailf:info "No signaling, use manually configured pseudowires";
            }
          }
        }
      }

      // interface pseudowire* / neighbor
      container neighbor {
        tailf:info "Neighbor options";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf address {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          tailf:cli-delete-container-on-delete;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP address of the peer PE";
          }
        }
        leaf vcid {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-4294967295>;;Peer VC ID value";
            range "1..4294967295";
          }
        }
      }

      // interface pseudowire* / vc type
      container vc {
        tailf:info "Virtual Circuit options";
        leaf type {
          tailf:info "Virtual Circuit type to use";
          type enumeration {
            enum vlan {
              tailf:info "VLAN (type 4)";
            }
            enum ethernet {
              tailf:info "Ethernet (type 5)";
            }
          }
        }
      }

      // interface pseudowire* / mtu
      leaf mtu {
        tailf:info "set Maximum Transmission Unit";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<64-65535>;;Maximum Transmission Unit value";
          range "64..65535";
        }
      }

      // interface pseudowire* / control-word
      leaf control-word {
        tailf:info "Control-word options";
        type enumeration {
          enum exclude {
            tailf:info "Exclude control-word in pseudowire packets";
          }
          enum "include" {
            tailf:info "Include control-word in pseudowire packets";
          }
        }
      }

      // interface pseudowire* / label
      container label {
        tailf:info "MPLS local and remote pseudowire static labels";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-diff-dependency "../../../mpls/label/range";
        leaf local-pseudowire-label {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<0-4294967295>;;Local pseudowire label";
          }
        }
        leaf remote-pseudowire-label {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<16-1048575>;;Remote pseudowire label";
            range "16..1048575";
          }
        }
      }

      // interface pseudowire* / pseudowire type
      container pseudowire {
        tailf:info "Pseudowire parameters";
        tailf:cli-diff-dependency "../signaling/protocol";
        leaf type {
          tailf:info "Pseudowire type";
          type string {
            tailf:info "XY;;Pseudowire Type in hex format";
          }
        }
      }

      // interface pseudowire* / service-policy
      container service-policy {
        tailf:info "Configure Service Policy";
        uses service-policy-grouping;
      }

      // interface pseudowire* / preferred-path
      uses pseudowire-preferred-path-grouping;
    }

    // interface LISP*
    list LISP {
      tailf:info "Locator/ID Separation Protocol Virtual Interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type uint16 {
          tailf:info "<0-1999>;;LISP interface number";
          range "0..1999";
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;
    }

    // subinterface LISP*
    container LISP-subinterface {
      tailf:cli-drop-node-name;
      list LISP {
        tailf:cli-allow-join-with-key {
          tailf:cli-display-joined;
        }
        tailf:cli-mode-name "config-subif";
        tailf:cli-suppress-key-abbreviation;
        key name;
        leaf name {
          tailf:cli-diff-dependency "../../../LISP";
          type string {
            pattern '[0-9]+\.[0-9]+';
          }
        }
        uses interface-common-pre-grouping;
        uses interface-common-grouping;
      }
    }

    // interface vasileft*
    list vasileft {
      tailf:info "VasiLeft interface";
      tailf:cli-full-command;
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type uint16 {
          tailf:info "<1-1000>;;vasileft interface number";
          range "1..1000";
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;
    }

    // interface vasiright*
    list vasiright {
      tailf:info "VasiRight interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;

      key name;
      leaf name {
        type uint16 {
          tailf:info "<1-1000>;;vasiright interface number";
          range "1..1000";
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;
    }

    // interface AppNav-Compress*
    list AppNav-Compress {
      tailf:info "Service-Context Virtual Interface Compress";
      tailf:cli-full-command;
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      cli:ned-diff-move-first ">no interface AppNav" {
        cli:arguments "when-delete";
      }
      //tailf:cli-diff-dependency "../../service-insertion/service-context";
      cli:ned-diff-move-after ">service-insertion" {
        //TEST:: cli:arguments "when-set|prio=+1";
        cli:arguments "when-set";
      }
      key name;
      leaf name {
        type uint16 {
          tailf:info "<1-1000>;;AppNav-Compress interface number";
          range "1..1000";
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;
    }

    // interface AppNav-UnCompress*
    list AppNav-UnCompress {
      tailf:info "Service-Context Virtual interface UnCompress";
      tailf:cli-full-command;
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      cli:ned-diff-move-first ">no interface AppNav" {
        cli:arguments "when-delete";
      }
      //tailf:cli-diff-dependency "../../service-insertion/service-context";
      cli:ned-diff-move-after ">service-insertion" {
        //TEST:: cli:arguments "when-set|prio=+1";
        cli:arguments "when-set";
      }
      key name;
      leaf name {
        type uint16 {
          tailf:info "<1-1000>;;AppNav-UnCompress interface number";
          range "1..1000";
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;
    }

    // interface ucse*
    list ucse {
      tailf:info "Cisco ucse server";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        tailf:cli-suppress-range;
        type string {
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-ethernet-pre-grouping;
      uses interface-switch-grouping;
      uses interface-ethernet-switch-grouping;
      uses interface-common-macsec-grouping;
      uses interface-ethernet-post-grouping;
    }

    // interface GMPLS*
    list GMPLS {
      tailf:info "MPLS interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type uint16 {
          tailf:info "<0-1000>;;GMPLS interface number";
          range "0..1000";
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;
    }

    // interface GMPLS*.*
    container GMPLS-subinterface {
      tailf:cli-drop-node-name;
      list GMPLS {
        tailf:cli-allow-join-with-key {
          tailf:cli-display-joined;
        }
        tailf:cli-mode-name "config-subif";
        tailf:cli-suppress-key-abbreviation;
        key name;
        leaf name {
          tailf:cli-diff-dependency "../../../GMPLS";
          type string {
            pattern '[0-9]+\.[0-9]+';
          }
        }
        uses interface-common-pre-grouping;
        uses interface-common-grouping;
      }
    }
  }


  /// ========================================================================
  /// ethernet
  /// ========================================================================

  container ethernet {
    tailf:info "Ethernet configuration";

    // ethernet oam mib log size
    container oam {
      tailf:info "Operations Admin and Management";
      container mib {
        tailf:info "Ethernet OAM MIB commands";
        container log {
          tailf:info "Ethernet OAM MIB log table";
          leaf size {
            tailf:info "log table size";
            type uint8 {
              tailf:info "<0-200>;;Number of log entries";
              range "0..200";
            }
          }
        }
      }
    }

    // ethernet lmi
    container lmi {
      tailf:info "Local Management Interface";

      // ethernet lmi global
      leaf global {
        tailf:info "Ethernet LMI is enabled on all supported Interfaces";
        type empty;
      }

      // ethernet lmi ce
      leaf ce {
        tailf:info "Ethernet LMI Customer Edge";
        type empty;
      }
    }

    // ethernet evc *
    list evc {
      tailf:info "define an Ethernet virtual connection (EVC)";
      tailf:cli-mode-name "config-evc";
      tailf:cli-compact-syntax;
      tailf:cli-full-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;EVC identifier of length <1-100>";
          length "1..100";
        }
      }

      // ethernet evc * / uni count
      container uni {
        tailf:info "Configure Count UNI Under EVC";
        leaf count {
          tailf:info "Configure UNI Count Under EVC";
          type uint16 {
            tailf:info "<2-1024>;;UNI COUNT required, range 2 - 1024";
            range "2..1024";
          }
        }
      }

      // ethernet evc * / oam protocol
      container oam {
        tailf:info "OAM Protocol";
        container protocol {
          tailf:info "Protocol for EVC status reporting";
          choice protocol-choice {

            // ethernet evc * / oam protocol ldp
            leaf ldp {
              tailf:info "Protocol LDP";
              type empty;
            }

            // ethernet evc * / oam protocol cfm
            container cfm {
              tailf:info "Protocol CFM";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf svlan {
                tailf:info "Service Provider CFM";
                tailf:cli-optional-in-sequence;
                tailf:cli-incomplete-command;
                tailf:non-strict-leafref {
                  path "/ios:ethernet/cfm/domain/service/vlan";
                }
                type uint16 {
                  tailf:info "<1-4094>;;VLAN id";
                  range "1..4094";
                }
              }
              leaf domain {
                tailf:info "Protocol CFM Domain";
                tailf:non-strict-leafref {
                  path "/ios:ethernet/cfm/domain/name";
                }
                type string {
                  tailf:info "WORD;;domain name";
                }
              }
            }
          }
        }
      }
    }

    // ethernet cfm
    container cfm {
      tailf:info "Connectivity Fault Management";

      // ethernet cfm enable
      leaf enable {
        tailf:info "CFM global enable";
        tailf:cli-full-command;
        type empty;
      }

      // ethernet cfm ieee
      leaf ieee {
        tailf:info "CFM IEEE enable";
        tailf:cli-full-command;
        type empty;
      }

      // ethernet cfm alarm
      container alarm {
        tailf:info "CFM Alarm";
        tailf:cli-diff-dependency "../ieee";

        // ethernet cfm alarm notification
        leaf notification {
          tailf:info "CFM alarm notification";
          type enumeration {
            enum none {
              tailf:info "No defects to be reported";
            }
            enum xcon {
              tailf:info "Report only: DefXcon";
            }
            enum error-xcon {
              tailf:info "Report only: DefError and DefXcon";
            }
            enum remote-error-xcon {
              tailf:info "Report only: DefRemote, DefError and DefXcon";
            }
            enum mac-remote-error-xcon {
              tailf:info "Report only: DefMACStatus, DefRemote, DefError and DefXcon (default)";
            }
            enum all {
              tailf:info "Report all defects: DefRDI, DefMACStatus, DefRemote, DefError, DefXcon";
            }
          }
          default mac-remote-error-xcon;
        }
      }

      // ethernet cfm global
      leaf global {
        tailf:info "CFM global enable";
        tailf:cli-full-command;
        tailf:cli-diff-dependency "../ieee";
        type empty;
      }

      // ethernet cfm logging
      container logging {
        tailf:info "Enable CFM syslog messages";
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        tailf:cli-diff-dependency "../ieee";
        presence true;

        // ethernet cfm logging alarm
        container alarm {
          tailf:info "Alarm logging";
          leaf ieee {
            tailf:info "IEEE MIB syslogs";
            type empty;
          }
          leaf cisco {
            tailf:info "Cisco MIB syslogs";
            type empty;
          }
        }
      }

      // ethernet cfm traceroute cache
      container traceroute {
        tailf:info "CFM Traceroute";
        tailf:cli-diff-dependency "../ieee";
        container cache {
          tailf:info "CFM Traceroute Cache";
          tailf:cli-display-separated;
          presence true;

          // ethernet cfm traceroute cache size
          leaf size {
            tailf:info "Cache size";
            type uint16 {
              tailf:info "<1-4095>;;Number of cached lines (default 100)";
              range "1..4095";
            }
            default 100;
          }

          // ethernet cfm traceroute cache hold-time
          leaf hold-time {
            tailf:info "Hold Time";
            type uint16 {
              tailf:info "<1-65535>;;minutes (default 100)";
              range "1..65535";
            }
            default 100;
          }
        }
      }

      // ethernet cfm mip auto-create *
      container mip {
        tailf:info "CFM MIP commands";

        // ethernet cfm mip auto-create level ? evc *
        list auto-create {
          tailf:info "CFM MIP auto creation";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          key evc;
          leaf evc {
            tailf:info "auto create for CFM over EVC";
            tailf:cli-expose-key-name;
            tailf:non-strict-leafref {
              path "/ios:ethernet/evc/name";
            }
            type string {
              tailf:info "WORD;;EVC name";
            }
          }
          leaf level {
            tailf:info "Maintenance Level";
            tailf:cli-prefix-key;
            type uint8 {
              tailf:info "<0-7>;;maintenance level number";
              range "0..7";
            }
          }
        }
      }

      // ethernet cfm domain *
      list domain {
        tailf:info "Configure a domain";
        tailf:cli-mode-name "config-ecfm";
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          tailf:cli-diff-dependency "../../ieee";
          type string {
            tailf:info "WORD;;maintenance domain name";
          }
        }
        // ethernet cfm domain * level
        leaf level {
          tailf:info "Maintenance Level";
          tailf:cli-hide-in-submode;
          type uint8 {
            tailf:info "<0-7>;;maintenance level number";
          }
        }

        // ethernet cfm domain * level / mip autocreate
        container mip {
          tailf:info "MIP commands for Domain";
          container auto-create {
            tailf:info "Enable auto MIP creation at Domain Level";
            tailf:cli-reset-container;
            tailf:cli-delete-when-empty;
            presence true;
            leaf lower-mep-only {
              tailf:info "Only for lower MEPs";
              type empty;
            }
          }
        }

        // ethernet cfm domain * level / mep archive-hold-time
        container mep {
          tailf:info "Maintenance End Point commands";
          leaf archive-hold-time {
            tailf:info "Time in minutes for entry to be retained";
            type uint16 {
              tailf:info "<1-65535>;;minutes (default 100)";
              range "1..65535";
            }
            default 100;
          }
        }

        // ethernet cfm domain * level / id
        container id {
          tailf:info "Maintenance Domain Identifier";
          choice id-choice {
            leaf mac {
              tailf:cli-drop-node-name;
              tailf:cli-disallow-value "null";
              type string {
                tailf:info "H.H.H;;MAC address";
              }
            }
            leaf dns {
              tailf:info "DNS Name based string";
              type string {
                tailf:info "WORD;;DNS Name (max 43 chars)";
              }
            }
            leaf null {
              tailf:info "No Domain name";
              type empty;
            }
          }
        }

        // ethernet cfm domain * level / sender-id chassis
        leaf sender-id {
          tailf:info "Include Sender ID TLV";
          tailf:cli-full-command;
          type enumeration {
            enum chassis {
              tailf:info "Send Chassis ID";
            }
            enum none {
              tailf:info "Info not included in Sender Id";
            }
          }
        }

        // ethernet cfm domain * level / service *
        list service {
          tailf:info "Maintenance Association within Domain";
          tailf:cli-mode-name "config-ecfm-srv";
          tailf:cli-sequence-commands;
          tailf:cli-incomplete-command;
          tailf:cli-diff-create-after "../service" {
            tailf:cli-when-target-delete;
          }
          key csi-id;
          leaf csi-id {
            // dep: before this is created, change l2vpn xconnect context
            //tailf:cli-diff-dependency "/ios:l2vpn-xconnect/l2vpn/xconnect/context" {
            //tailf:cli-trigger-on-set;
            //}
            tailf:cli-disallow-value "vlan-id|icc";
            type string {
              tailf:info "WORD;;service instance id - short MA name";
            }
          }
          leaf icc {
            tailf:info "ITU-T Y.1731 ICC-based MEG ID";
            tailf:cli-prefix-key;
            tailf:cli-optional-in-sequence;
            type string {
              tailf:info "WORD;;ITU Carrier Code (ICC) (1-6 characters)";
            }
          }
          leaf vlan-id {
            tailf:info "primary VLAN id (value stored in key leaf csi-id)";
            tailf:cli-prefix-key;
            tailf:cli-optional-in-sequence;
            type empty;
          }

          // ethernet cfm domain * level / service * port
          leaf port {
            tailf:info "DOWN service direction with no vlan association";
            tailf:cli-hide-in-submode;
            tailf:cli-optional-in-sequence;
            tailf:cli-full-command;
            type empty;
          }

          // ethernet cfm domain * level / service * efc
          leaf evc {
            tailf:info "Specify EVC";
            tailf:cli-hide-in-submode;
            tailf:cli-optional-in-sequence;
            tailf:non-strict-leafref {
              path "/ios:ethernet/evc/name";
            }
            type string {
              tailf:info "WORD;;EVC name";
            }
          }
          // ethernet cfm domain * level / service * efc ? vlan
          leaf vlan {
            tailf:info "Specify vlan (range 1-4094)";
            tailf:cli-hide-in-submode;
            tailf:cli-optional-in-sequence;
            type uint16 {
              tailf:info "<1-4094>;;between 1 and 4094";
              range "1..4094";
            }
          }
          // ethernet cfm domain * level / service * efc inner-vlan
          leaf inner-vlan {
            tailf:info "Specify inner vlan (range 1-4094)";
            tailf:cli-hide-in-submode;
            tailf:cli-optional-in-sequence;
            type uint16 {
              tailf:info "<1-4094>;;between 1 and 4094";
              range "1..4094";
            }
          }
          // ethernet cfm domain * level / service * efc direction
          leaf direction {
            tailf:info "service direction";
            tailf:cli-hide-in-submode;
            tailf:cli-full-command;
            type enumeration {
              enum down {
                tailf:info "direction towards the LAN";
              }
            }
          }

          // ethernet cfm domain * level / service * / mep mpid *
          container mep {
            tailf:info "Static MEP within a Maintenance Association";
            tailf:cli-break-sequence-commands;
            list mpid {
              tailf:info "Maintenance End Point Identifier";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-show-long-obu-diffs;
              ordered-by user;
              key id;
              leaf id {
                tailf:cli-suppress-range;
                type uint16 {
                  tailf:info "<1-8191>;;Identifier value";
                  range "1..8191";
                }
              }
            }
          }

          // ethernet cfm domain * level / service * / continuity-check
          container continuity-check {
            tailf:info "Enable Continuity Check for Maintenance Association";
            tailf:cli-display-separated;
            presence true;

            // ethernet cfm domain * level / service * / continuity-check interval
            leaf interval {
              tailf:info "Interval Continuity Check messages transmitted";
              tailf:cli-full-command;
              type string {
                tailf:info "WORD;;interval string, 100ms|1s|10s|1m|10m (default 10s)";
              }
              default "10s";
            }

            // ethernet cfm domain * level / service * / continuity-check loss-threshold
            leaf loss-threshold {
              tailf:info "Specifies when a MEP is down or unreachable";
              type uint8 {
                tailf:info "<2-255>;;Continuity Check messages missed before MEP down (default 3)";
                range "2..255";
              }
              default 3;
            }

            // ethernet cfm domain * level / service * / continuity-check static rmep
            container static {
              tailf:info "Verify MEP in received CCM is valid";
              leaf rmep {
                tailf:info "MEP defined using mep mpid";
                type empty;
              }
            }
          }

          // ethernet cfm domain * level / service * / sender-id
          leaf sender-id {
            tailf:info "Include Sender ID TLV";
            tailf:cli-full-command;
            type enumeration {
              enum chassis {
                tailf:info "Send Chassis ID";
              }
              enum none {
                tailf:info "Info not included in Sender Id";
              }
            }
          }

          // ethernet cfm domain * level / service * / mip autocreate
          container mip {
            tailf:info "MIP commands for Domain";
            container auto-create {
              tailf:info "Enable auto MIP creation at Domain Level";
              tailf:cli-reset-container;
              tailf:cli-delete-when-empty;
              presence true;
              leaf lower-mep-only {
                tailf:info "Only for lower MEPs";
                type empty;
              }
            }
          }

          // ethernet cfm domain * level / service * / ais
          container ais {
            tailf:info "AIS Maintenance Condition";
            // ethernet cfm domain * level / service * / ais period
            leaf period {
              tailf:info "AIS Transmission period";
              type enumeration {
                enum "1" {
                  tailf:info "Seconds";
                }
                enum "60" {
                  tailf:info "Seconds";
                }
              }
              default "60";
            }
            // ethernet cfm domain * level / service * / ais level
            leaf level {
              tailf:info "Maintenance Level to send AIS";
              type uint8 {
                tailf:info "<0-7>;;Maintenance Level";
                range "0..7";
              }
            }
          }

          // ethernet cfm domain * level / service * / efd notify g8032
          container efd {
            tailf:info "Ethernet Fault Detection";
            container notify {
              tailf:info "EFD Notification Registration";
              leaf g8032 {
                tailf:info "Notify G.8032 Controller of EFD events";
                type empty;
              }
            }
          }
        }
      }

      // ethernet cfm ais link-status global
      container ais {
        tailf:info "AIS Maintenance Condition";
        tailf:cli-diff-dependency "../ieee";
        container link-status {
          tailf:info "8023ah SMEP or link state up/down";
          container global {
            tailf:info "8023ah SMEP or link state state up/down AIS global configuration";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-ais-link-cfm";
            presence true;

            // ethernet cfm ais link-status global / disable
            leaf disable {
              tailf:info "Disable AIS transmission";
              type empty;
            }
          }
        }
      }

      // ethernet cfm mep crosscheck start-delay
      container mep {
        tailf:info "Maintenance End Point";
        tailf:cli-diff-dependency "../ieee";
        container crosscheck {
          tailf:info "Cross Check remote MEPs";
          leaf start-delay {
            tailf:info "Wait time before cross check starts. Default 30";
            type uint16 {
              tailf:info "<1-65535>;;seconds (30 seconds default)";
              range "1..65535";
            }
            default 30;
          }
        }
      }
    }

    // ethernet ring g8032
    container ring {
      tailf:info "Ring";
      container g8032 {
        tailf:info "Specify the g.8032 ethernet ring";

        // ethernet ring g8032 profile *
        list profile {
          tailf:info "g.8032 ring profile configuration";
          tailf:cli-mode-name "config-erp-profile";
          key profile-name;
          leaf profile-name {
            type string {
              tailf:info "WORD;;ERP profile name string";
            }
          }
          // ethernet ring g8032 profile * / timer
          container timer {
            tailf:info "g.8032 timer";
            // ethernet ring g8032 profile * / timer wtr
            leaf wtr {
              tailf:info "Wait-to-Restore time";
              type uint8 {
                tailf:info "<1-12>;;minutes";
                range "1..12";
              }
            }
            // ethernet ring g8032 profile * / timer guard
            leaf guard {
              tailf:info "Guard timer";
              type uint16 {
                tailf:info "<10-2000>;;milliseconds";
                range "10..2000";
              }
            }
          }
        }

        // ethernet ring g8032 *
        list g8032-list {
          tailf:cli-drop-node-name;
          tailf:cli-mode-name "config-erp-ring";
          key ring-name;
          leaf ring-name {
            tailf:cli-disallow-value "profile";
            type string {
              tailf:info "WORD;;Name of the ethernet ring";
            }
          }

          // ethernet ring g8032 * / open-ring
          leaf open-ring {
            tailf:info "Specify the g.8032 ring as open ring";
            type empty;
          }

          // ethernet ring g8032 * / exclusion-list vlan-ids *
          container exclusion-list {
            tailf:info "Specifiy exclusion list not protected by ERP";
            leaf-list vlan-ids {
              tailf:info "Assign list of VLANs to the exclusion list";
              tailf:cli-range-list-syntax;
              tailf:cli-remove-before-change;
              ios:erps-inject-delete;
              type uint16 {
                tailf:info "<1-4094>;;VLAN id";
                range "1..4094";
              }
            }
          }

          // ethernet ring g8032 * / port0 interface
          container port0 {
            tailf:info "Port0 of the local node connected to G.8032 ring";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-erp-ring-port";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            presence true;
            container interface {
              tailf:info "Assign port interface";
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              tailf:cli-hide-in-submode;
              uses interface-name-grouping;
            }

            // ethernet ring g8032 * / port0 interface / monitor service
            container monitor {
              tailf:info "Assign the Ethernet Service Instance to monitor g.8032 ring port";
              container service {
                tailf:info "Specify an Ethernet Service Instance";
                leaf instance {
                  tailf:info "Specify an Ethernet Service Instance";
                  type uint16 {
                    tailf:info "Ethernet Service Instance ID";
                    range "1..8000";
                  }
                }
              }
            }
          }

          // ethernet ring g8032 * / port1
          choice port1-choice {
            // ethernet ring g8032 * / port1 interface
            container port1 {
              tailf:info "Port1 of the local node connected to G.8032 ring";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-erp-ring-port";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              tailf:cli-delete-when-empty;
              tailf:cli-incomplete-command;
              presence true;
              container interface {
                tailf:info "Assign port interface";
                tailf:cli-flatten-container;
                tailf:cli-compact-syntax;
                tailf:cli-hide-in-submode;
                uses interface-name-grouping;
              }

              // ethernet ring g8032 * / port1 interface / monitor service
              container monitor {
                tailf:info "Assign the Ethernet Service Instance to monitor g.8032 ring port";
                container service {
                  tailf:info "Specify an Ethernet Service Instance";
                  leaf instance {
                    tailf:info "Specify an Ethernet Service Instance";
                    type uint16 {
                      tailf:info "Ethernet Service Instance ID";
                      range "1..8000";
                    }
                  }
                }
              }
            }

            // ethernet ring g8032 * / port1 none
            container port1-none {
              tailf:cli-drop-node-name;
              container port1 {
                tailf:info "Port1 of the local node connected to G.8032 ring";
                leaf none {
                  tailf:info "Assign port1 as none to enable g.8032 open-ring";
                  type empty;
                }
              }
            }
          }

          // ethernet ring g8032 * / instance *
          list instance {
            tailf:info "Configure the g.8032 ethernet ring instance";
            tailf:cli-mode-name "config-erp-inst";
            tailf:cli-full-command;
            key instance-id;
            leaf instance-id {
              type uint8 {
                tailf:info "<1-2>;;Instance number";
                range "1..2";
              }
            }

            // ethernet ring g8032 * / instance * / description
            uses description-grouping;

            // ethernet ring g8032 * / instance * / profile
            leaf profile {
              tailf:info "Specify associated g.8032 ethernet ring profile";
              type string {
                tailf:info "WORD;;Ethernet ring profile name";
              }
            }

            // ethernet ring g8032 * / instance * / rpl
            container rpl {
              tailf:info "Specify RPL owner, neighbor or next-neighbor";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              leaf port {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type enumeration {
                  enum port0 {
                    tailf:info "Assign port0 as RPL owner, neighbor or next-neighbor";
                  }
                  enum port1 {
                    tailf:info "Assign port1 as RPL owner, neighbor or next-neighbor";
                  }
                }
              }
              leaf type {
                tailf:cli-drop-node-name;
                type enumeration {
                  enum neighbor {
                    tailf:info "RPL neighbor";
                  }
                  enum next-neighbor {
                    tailf:info "RPL next neighbor";
                  }
                  enum owner {
                    tailf:info "RPL owner";
                  }
                }
              }
            }

            // ethernet ring g8032 * / instance * / inclusion-list *
            container inclusion-list {
              tailf:info "Specify inclusion list protected by ERP";
              leaf-list vlan-ids {
                tailf:info "Associates a set of VLAN IDs with the current instance";
                tailf:cli-range-list-syntax;
                tailf:cli-remove-before-change;
                ios:erps-inject-delete;
                type uint16 {
                  tailf:info "WORD;;List of VLAN IDs in the form a-b,c,d,e-f,g";
                  range "1..4094";
                }
              }
            }

            // ethernet ring g8032 * / instance * / aps-channel
            container aps-channel {
              tailf:info "Configure g.8032 instance aps-channel";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-erp-inst-aps";
              // ethernet ring g8032 * / instance * / aps-channel / port0
              container port0 {
                tailf:info "Configure g.8032 aps-channel info associated to port0";
                container service {
                  tailf:info "Specify an Ethernet Service Instance";
                  leaf instance {
                    tailf:info "Specify an Ethernet Service Instance";
                    type uint16 {
                      tailf:info "<1-8000>;;Ethernet Service Instance ID";
                      range "1..8000";
                    }
                  }
                }
              }
              // ethernet ring g8032 * / instance * / aps-channel / port1
              container port1 {
                tailf:info "Configure g.8032 aps-channel info associated to port1";
                choice port1-choice {
                  // ethernet ring g8032 * / instance * / aps-channel / port1 service
                  container service {
                    tailf:info "Specify an Ethernet Service Instance";
                    leaf instance {
                      tailf:info "Specify an Ethernet Service Instance";
                      type uint16 {
                        tailf:info "<1-8000>;;Ethernet Service Instance ID";
                        range "1..8000";
                      }
                    }
                  }
                  // ethernet ring g8032 * / instance * / aps-channel / port1 none
                  leaf none {
                    tailf:info "Specify port1 APS channel as none";
                    type empty;
                  }
                }
              }
            }
          }
        }
      }
    }

    // ethernet tcn-propagation *
    list tcn-propagation {
      tailf:info "Enable TCN propagation";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key "source to";
      leaf source {
        type enumeration {
          enum g8032 {
            tailf:info "g.8032 ethernet ring";
          }
          enum rep {
            tailf:info "REP ethernet ring";
          }
        }
      }
      leaf to {
        tailf:info "propagate TCN to";
        tailf:cli-expose-key-name;
        type enumeration {
          enum g8032 {
            tailf:info "g.8032 ethernet ring";
          }
          enum rep {
            tailf:info "REP ethernet ring";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// access-list
  /// ========================================================================

  container access-list {
    tailf:info "Add an access list entry";
    tailf:cli-incomplete-command;

    // access-list *
    list access-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-incomplete-command;
      ios:redeploy-with-change "no  :: (access-list \\d+)";
      key id;
      leaf id {
        tailf:cli-incomplete-no;
        tailf:cli-suppress-range;
        type union {
          type uint16 {
            tailf:info "<1-99>;;IP standard access list";
            range "1..99";
          }
          type uint16 {
            tailf:info "<100-199>;;IP extended access list";
            range "100..199";
          }
          type uint16 {
            tailf:info "<200-299>;;Protocol type-code access list";
            range "200..299";
          }
          type uint16 {
            tailf:info "<600-699>;;Appletalk access list";
            range "600..699";
          }
          type uint16 {
            tailf:info "<700-799>;;48-bit MAC address access list";
            range "700..799";
          }
          type uint16 {
            tailf:info "<800-899>;;IPX standard access list";
            range "800..899";
          }
          type uint16 {
            tailf:info "<900-999>;;IPX extended access list";
            range "900..999";
          }
          type uint16 {
            tailf:info "<1000-1099>;;IPX SAP access list";
            range "1000..1099";
          }
          type uint16 {
            tailf:info "<1100-1199>;;Extended 48-bit MAC address access list";
            range "1100..1199";
          }
          type uint16 {
            tailf:info "<1200-1299>;;IPX summary address access list";
            range "1200..1299";
          }
          type uint16 {
            tailf:info "<1300-1999>;;IP standard access list (expanded range)";
            range "1300..1999";
          }
          type uint16 {
            tailf:info "<2000-2699>;;IP extended access list (expanded range)";
            range "2000..2699";
          }
          type uint16 {
            tailf:info "<2700-2799>;;MPLS access list";
            range "2700..2799";
          }
        }
      }
      list rule {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-show-long-obu-diffs;
        ordered-by user;
        key rule;
        leaf seq {
          // note: shown when "ip access-list persistent" is set
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type uint32 {
            tailf:info "<1-2147483647>;;Sequence Number [with ip access-list persistent]";
            range "1..2147483647";
          }
        }
        leaf rule {
          tailf:cli-multi-word-key;
          type string {
            tailf:info "<RULE>;;deny <options> | permit <options> | remark <comment>";
            pattern "(permit.*)|(deny.*)|(remark.*)|(dynamic.*)";
          }
        }
      }
    }

    // access-list dynamic-extended
    leaf dynamic-extended {
      tailf:info "Extend the dynamic ACL absolute timer";
      tailf:cli-full-command;
      type empty;
    }

    // access-list rate-limit *
    list rate-limit {
      tailf:info "Simple rate-limit specific access list";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      key id;
      leaf id {
        type union {
          type uint8 {
            tailf:info "<0-99>;;Precedence ACL index";
            range "0..99";
          }
          type uint8 {
            tailf:info "<100-199>;;MAC address ACL index";
            range "100..199";
          }
        }
      }
      choice rate-choice {
        leaf mac-address {
          tailf:cli-drop-node-name;
          type mac-address-type;
        }
        leaf precedence {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<0-7>;;Precedence";
            range "0..7";
          }
        }
        leaf mask {
          tailf:info "Use precedence bitmask";
          type string {
            tailf:info "<0-FF>;;Precedence bit mask";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// access-session
  /// ========================================================================

  container access-session {
    tailf:info "Access Sesion Global Configuration Commands";

    // access-session acl
    container acl {
      tailf:info "Application of ACLs on access-session";

      // access-session acl default passthrough
      container default {
        tailf:info "Defines the behaviour in the absence of an explicit ACL";
        leaf passthrough {
          tailf:info "Allows session to send traffic through acl";
          type empty;
        }
      }
    }

    // access-session mac-move deny
    container mac-move {
      tailf:info "Set required action when a MAC move is detected";
      leaf deny {
        tailf:info "DENY MAC moves (clears existing session)";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// arp
  /// ========================================================================

  container arp {
    tailf:info "Set a static ARP entry";

    // arp *
    uses arp-grouping;

    // arp vrf *
    list vrf {
      tailf:info "Configure static ARP for a VPN Routing/Forwarding instance";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-incomplete-command;
      key name;
      leaf name {
        tailf:cli-diff-dependency "../../../ip/vrf";
        tailf:cli-diff-dependency "../../../vrf/definition";
        type string {
          tailf:info "WORD;;VPN Routing/Forwarding instance name";
        }
      }
      uses arp-grouping;
    }

    // arp access-list *
    list access-list {
      tailf:info "Named access-list";
      tailf:cli-mode-name "config-arp-nacl";
      tailf:cli-full-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;access-list name";
        }
      }

      // arp access-list * / <rule>
      list access-list-rule {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        tailf:cli-show-long-obu-diffs;
        tailf:cli-case-sensitive;
        ordered-by user;
        key rule;
        leaf rule {
          tailf:cli-drop-node-name;
          tailf:cli-multi-word-key;
          type string {
            tailf:info "deny;;Specify packets to reject || permit;;Specify packets to forwards";
            pattern "(deny .*)|(permit .*)";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// threat-visibility
  /// ========================================================================

  // threat-visibility
  container threat-visibility {
    tailf:info "Global Threat Visibility";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-threat-vi";
    presence true;
  }


  /// ========================================================================
  /// utd
  /// ========================================================================

  // utd "single-tenancy"
  container utd-st {
    tailf:cli-drop-node-name;
    tailf:cli-diff-dependency "../parameter-map";
    container utd {
      tailf:info "Global Unified Threat Defense";
      tailf:cli-incomplete-command;
      tailf:cli-incomplete-no;

      // utd web-filter
      uses utd-web-filter-grouping {
        augment "web-filter/domain" {
          list profile {
            tailf:info "Provide the profile ID";
            tailf:cli-mode-name "config-utd-webfltr-domain";
            key id;
            leaf id {
              tailf:cli-suppress-range;
              type string {
                tailf:info "<1-255>;;ID of the Domain based web filter profile";
              }
            }

            // utd web-filter domain profile * / alert
            leaf alert {
              tailf:info "Provide the logging alert level";
              type enumeration {
                enum all {
                  tailf:info "Log all the alerts";
                }
                enum blacklist {
                  tailf:info "Log alerts for Blacklisted URLs";
                }
                enum whitelist {
                  tailf:info "Log alerts for Whitelisted URLs";
                }
              }
            }

            // utd web-filter domain profile * / blacklist
            container blacklist {
              tailf:info "Choose the blacklist parameter-map";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-utd-webf-dmn-bl";
              presence true;

              // utd web-filter domain profile * / blacklist / parameter-map regexp
              container parameter-map {
                tailf:info "Enter the parameter-map information for the regex";
                leaf regex {
                  tailf:info "Provide the regex parameter-map name";
                  tailf:non-strict-leafref {
                    path "/ios:parameter-map/type/regex/name";
                  }
                  type string {
                    tailf:info "WORD;;Enter the name of the regex parameter-map";
                  }
                }
              }
            }

            // utd web-filter domain profile * / redirect-server
            container redirect-server {
              tailf:info "Provide the IP address for the redirect server for blocked domains";
              choice id-choice {
                leaf external {
                  tailf:info "Provide data about the external redirect server";
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;IP address of the redirect server";
                  }
                }
                leaf local-block-server {
                  tailf:info "Use the local block server as the redirect server";
                  tailf:non-strict-leafref {
                    path "../../../../block/local-server/profile/id";
                  }
                  type string {
                    tailf:info "<1-255>;;Provide the ID of the local block server profile";
                  }
                }
              }
            }

            // utd web-filter domain profile * / whitelist
            container whitelist {
              tailf:info "Choose the whitelist parameter-map";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-utd-webf-dmn-wl";
              presence true;

              // utd web-filter domain profile * / whitelist / parameter-map regexp
              container parameter-map {
                tailf:info "Enter the parameter-map information for the regex";
                leaf regex {
                  tailf:info "Provide the regex parameter-map name";
                  tailf:non-strict-leafref {
                    path "/ios:parameter-map/type/regex/name";
                  }
                  type string {
                    tailf:info "WORD;;Enter the name of the regex parameter-map";
                  }
                }
              }
            }
          }

        }
      }

      // utd engine
      container engine {
        tailf:info "UTD engine";

        // utd engine standard
        container standard {
          tailf:info "UTD engine standard";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-utd-eng-std";
          tailf:cli-full-command;
          presence true;

          // utd engine standard / logging
          // utd engine standard / threat-inspection
          // utd engine standard / web-filter
          uses utd-engine-standard-grouping {
            augment "threat-inspection" {
              // utd engine standard / threat-inspection / threat
              // utd engine standard / threat-inspection / policy
              // utd engine standard / threat-inspection / logging level
              uses utd-engine-threat-inspection-grouping;

              // utd engine standard / threat-inspection / whitelist
              leaf whitelist {
                tailf:info "Enable whitelisting under the utd engine";
                tailf:cli-diff-dependency "../../../../threat-inspection/whitelist";
                type empty;
              }
            }
          }

          // utd engine standard / web-filter
          container web-filter {
            tailf:info "UTD engine standard web-filtering configs";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-utd-engstd-webf";
            tailf:cli-full-command;
            presence true;

            // utd engine standard / web-filter / domain-profile
            leaf domain-profile {
              tailf:info "Choose the domain profile to use for web filtering";
              tailf:cli-no-value-on-delete;
              tailf:non-strict-leafref {
                path "../../../../web-filter/domain/profile/id";
              }
              type string {
                tailf:info "<1-255>;;Provide the web filtering profile ID";
              }
            }

            // utd engine standard / web-filter / sourcedb
            leaf sourcedb {
              tailf:info "Choose the source DB profile to use for web filtering";
              tailf:non-strict-leafref {
                path "../../../../web-filter/sourcedb/id";
              }
              type string {
                tailf:info "<1-255>;;Provide the source db profile ID";
              }
            }

            // utd engine standard / web-filter / url-profile
            leaf url-profile {
              tailf:info "Choose the url profile to use for web filtering";
              tailf:cli-no-value-on-delete;
              tailf:non-strict-leafref {
                path "../../../../web-filter/url/profile/id";
              }
              type string {
                tailf:info "<1-255>;;Provide the web filtering profile ID";
              }
            }
          }
        }

        // utd engine advanced
        container advanced {
          tailf:info "UTD engine advanced";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-utd-eng-adv";
          tailf:cli-full-command;
          presence true;

          // utd engine advanced / threat detection
          container threat {
            tailf:info "Provide threat detection";
            leaf detection {
              tailf:info "Provide threat detection";
              type empty;
            }
          }
        }
      }

      // utd threat-inspection whitelist
      container threat-inspection {
        tailf:info "UTD Threat Inspection (IPS/IDS) config modes";
        container whitelist {
          tailf:info "UTD whitelist config submode";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-utd-whitelist";
          presence true;

          // utd threat-inspection whitelist / signature id *
          list signature {
            tailf:info "Provide signatures for the whitelist";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key id;
            leaf id {
              tailf:info "Provide signature id for the whitelist";
              tailf:cli-expose-key-name;
              tailf:cli-suppress-range;
              type uint32 {
                tailf:info "<0-4294967295>;;Provide the signature ID to be whitelisted";
              }
            }
            leaf comment {
              tailf:info "Provide a comment for the signature";
              tailf:cli-no-name-on-delete;
              tailf:cli-no-value-on-delete;
              tailf:cli-remove-before-change;
              ios:string-remove-quotes "comment <STRING>";
              type string {
                tailf:info "LINE;;Enter the comment string";
              }
            }
          }
        }
      }
    }
  }

  // utd multi-tenancy
  container utd-mt {
    tailf:cli-drop-node-name;
    tailf:cli-explicit-exit;
    tailf:cli-diff-dependency "../interface";
    container utd {
      tailf:info "Global Unified Threat Defense";
      tailf:cli-incomplete-command;
      tailf:cli-incomplete-no;

      // utd multi-tenancy
      leaf multi-tenancy {
        tailf:info "Enable UTD multi-tenancy mode";
        type empty;
      }

      // utd engine standard multi-tenancy
      container engine {
        tailf:info "UTD engine";
        container standard {
          tailf:info "UTD engine standard";
          container multi-tenancy {
            tailf:info "Enable UTD multi-tenancy mode";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-utd-multi-tenancy";
            tailf:cli-full-command;
            tailf:cli-diff-dependency "../../../multi-tenancy";
            presence true;

            // utd engine standard multi-tenancy / web-filter
            uses utd-web-filter-grouping;

            // utd engine standard multi-tenancy / threat-inspection whitelist profile *
            container threat-inspection {
              tailf:info "UTD Threat Inspection (IPS/IDS) config modes";

              // utd engine standard multi-tenancy / threat-inspection whitelist profile *
              container whitelist {
                tailf:info "UTD whitelist config submode";
                list profile {
                  tailf:info "UTD whitelist profile";
                  tailf:cli-mode-name "config-utd-mt-whitelist";
                  key name;
                  leaf name {
                    tailf:cli-suppress-range;
                    type string {
                      tailf:info "WORD;;UTD whitelist profile name";
                    }
                  }

                  // utd engine standard multi-tenancy / threat-inspection whitelist profile * / signature id *
                  list signature {
                    tailf:info "Provide signatures for the whitelist";
                    tailf:cli-suppress-mode;
                    tailf:cli-delete-when-empty;
                    key id;
                    leaf id {
                      tailf:info "Provide signature id for the whitelist";
                      tailf:cli-expose-key-name;
                      tailf:cli-suppress-range;
                      type uint32 {
                        tailf:info "<0-4294967295>;;Provide the signature ID to be whitelisted";
                      }
                    }
                    leaf comment {
                      tailf:info "Provide a comment for the signature";
                      tailf:cli-no-name-on-delete;
                      tailf:cli-no-value-on-delete;
                      tailf:cli-remove-before-change;
                      ios:string-remove-quotes "comment <STRING>";
                      type string {
                        tailf:info "LINE;;Enter the comment string";
                      }
                    }
                  }
                }
              }

              // utd engine standard multi-tenancy / threat-inspection profile *
              list profile {
                tailf:info "UTD Threat Inspection profile";
                tailf:cli-mode-name "config-utd-mt-threat";
                key name;
                leaf name {
                  tailf:cli-suppress-range;
                  type string {
                    tailf:info "WORD;;UTD threat-inspection profile name";
                  }
                }

                // utd engine standard multi-tenancy / threat-inspection profile * / threat
                // utd engine standard multi-tenancy / threat-inspection profile * / policy
                // utd engine standard multi-tenancy / threat-inspection profile * / logging level
                uses utd-engine-threat-inspection-grouping;

                // utd engine standard multi-tenancy / threat-inspection profile * / whitelist profile
                container whitelist {
                  tailf:info "Associate a whitelist profile with this profile";
                  leaf profile {
                    tailf:info "UTD whitelist profile";
                    tailf:non-strict-leafref {
                      path "../../../whitelist/profile/name";
                    }
                    type string {
                      tailf:info "WORD;;UTD whitelist profile name";
                    }
                  }
                }
              }
            }

            // utd engine standard multi-tenancy / utd global
            container utd {
              tailf:info "UTD engine standard settings";
              container global {
                tailf:info "UTD engine standard global settings";
                tailf:cli-add-mode;
                tailf:cli-mode-name "config-utd-mt-global";
                presence true;

                // utd engine standard multi-tenancy / utd global
                uses utd-engine-standard-grouping;

                // utd engine standard multi-tenancy / utd global / web-filter
                container web-filter {
                  tailf:info "UTD engine standard web-filtering configs";
                  tailf:cli-add-mode;
                  tailf:cli-mode-name "config-utd-engstd-webf";
                  tailf:cli-full-command;
                  presence true;

                  // utd engine standard / web-filter / sourcedb
                  leaf sourcedb {
                    tailf:info "Choose the source DB profile to use for web filtering";
                    tailf:non-strict-leafref {
                      path "../../../../web-filter/sourcedb/id";
                    }
                    type string {
                      tailf:info "<1-255>;;Provide the source db profile ID";
                    }
                  }
                }
              }
            }

            // utd engine standard multi-tenancy / policy *
            list policy {
              tailf:info "Multi-tenancy utd policy";
              tailf:cli-mode-name "config-utd-mt-policy";
              tailf:cli-diff-dependency "../utd/global";
              key name;
              leaf name {
                tailf:cli-suppress-range;
                type string {
                  tailf:info "WORD;;policy name";
                }
              }

              // utd engine standard multi-tenancy / policy * / vrf *
              list vrf {
                tailf:info "Associate a VRF with this policy";
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                key name;
                leaf name {
                  tailf:cli-diff-dependency "../../../policy/vrf/name" {
                    tailf:cli-trigger-on-set;
                  }
                  tailf:cli-diff-dependency "../../../../../../../../ip/vrf";
                  tailf:cli-diff-dependency "../../../../../../../../vrf/definition";
                  type string {
                    tailf:info "WORD;;Name of VRF";
                  }
                }
              }

              // utd engine standard multi-tenancy / policy * / all-interfaces
              leaf all-interfaces {
                tailf:info "Enable intrusion inspection on all supported interfaces for this set of VRFs";
                type empty;
              }

              // utd engine standard multi-tenancy / policy * / threat-inspection profile
              container threat-inspection {
                tailf:info "Associate threat-inspection profile with this policy";
                leaf profile {
                  tailf:info "Associate threat-inspection profile with this policy";
                  tailf:non-strict-leafref {
                    path "../../../threat-inspection/profile/name";
                  }
                  type string {
                    tailf:info "WORD;;Name of threat-protection profile";
                  }
                }
              }

              // utd engine standard multi-tenancy / policy * / web-filter url profile
              container web-filter {
                tailf:info "Associate web filter profile with this policy";
                container url {
                  tailf:info "Associate web filter profile with this policy";
                  leaf profile {
                    tailf:info "Associate web filter profile with this policy";
                    tailf:non-strict-leafref {
                      path "../../../../web-filter/url/profile/id";
                    }
                    type string {
                      tailf:info "<1-255>;;ID of the web filtering url profile";
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  // utd
  container utd {
    tailf:info "Global Unified Threat Defense";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-utd";
    tailf:cli-full-command;
    tailf:cli-full-no;
    presence true;

    // utd / all-interfaces
    leaf all-interfaces {
      tailf:info "Enable intrusion inspection on all supported interfaces";
      type empty;
    }

    // utd / redirect interface
    container redirect {
      tailf:info "Specify the interface connected to the UTD";
      container interface {
        tailf:info "Specify the interface connected to UTD";
        choice interface-choice {
          leaf BDI {
            tailf:info "Bridge-Domain interface";
            tailf:cli-allow-join-with-value {
              tailf:cli-display-joined;
            }
            tailf:non-strict-leafref {
              path "/ios:interface/BDI/name";
            }
            type uint16 {
              tailf:info "<1-4095>;;BDI interface number";
              range "1..4095";
            }
          }
          leaf VirtualPortGroup {
            tailf:info "Virtual Port Group";
            tailf:cli-allow-join-with-value {
              tailf:cli-display-joined;
            }
            tailf:non-strict-leafref {
              path "/ios:interface/VirtualPortGroup/name";
            }
            type uint8 {
              tailf:info "<0-31>;;VirtualPortGroup interface number";
            }
          }
        }
      }
    }

    // utd / engine advanced
    // utd / engine standard
    container engine {
      tailf:info "Select UTD engine mode to run";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-engine";
      presence true;
      leaf mode {
        tailf:cli-drop-node-name;
        tailf:cli-hide-in-submode;
        type enumeration {
          enum standard {
            tailf:info "Intrusion inspection standard mode";
          }
          enum  advanced {
            tailf:info "Intrusion inspection advanced mode";
          }
        }
      }

      // utd / engine standard / fail close
      container fail {
        tailf:info "Enter the UTD engine fail mode operation";
        leaf close {
          tailf:info "Drop all IPS/IDS traffic on UTD engine failure";
          type empty;
        }
      }
    }
  }


  /// ========================================================================
  /// virtual-service
  /// ========================================================================

  // virtual-service *
  list virtual-service {
    tailf:info "Configure virtual service";
    tailf:cli-mode-name "config-virt-serv";
    tailf:cli-explicit-exit;
    tailf:cli-recursive-delete;
    tailf:cli-diff-dependency "../interface/VirtualPortGroup";
    ios:shutdown-before-modify "activate" {
      cli:arguments "delete-to-disable";
    }
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;Virtual service name (up to 63 characters)";
      }
    }

    // virtual-service * / description
    leaf description {
      tailf:info "Virtual service description";
      tailf:cli-multi-value;
      tailf:cli-preformatted;
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;Description of this virtual service (up to 191 characters)";
        length "0..191";
      }
    }

    // virtual-service * / ip shared host-interface
    container ip {
      tailf:info "Share IP address with a host interface";
      container shared {
        tailf:info "Share IP address with a host interface";
        container host-interface {
          tailf:info "Host interface to share IP address with";
          leaf GigabitEthernet {
            tailf:info "GigabitEthernet IEEE 802.3z";
            tailf:cli-allow-join-with-value {
              tailf:cli-display-joined;
            }
            tailf:non-strict-leafref {
              path "../../../../../interface/GigabitEthernet/name";
            }
            type string {
              tailf:info "WORD;;GigabitEthernet interface id";
              pattern '[0-9]+.*';
            }
          }
        }
      }
    }

    // virtual-service * / profile
    leaf profile {
      tailf:info "Specify the resource profile for virtual service";
      tailf:cli-remove-before-change;
      tailf:cli-full-command;
      type enumeration {
        enum ISR-WAAS-1300 {
          tailf:info "ISR-WAAS profile for 1300 TCP connections";
        }
        enum ISR-WAAS-750 {
          tailf:info "ISR-WAAS profile for 750 TCP connections";
        }
        enum ISR-WAAS-2500 {
          tailf:info "ISR-WAAS profile for 2500 TCP connections";
        }
        enum high {
          tailf:info "CSR UTD IPS/IDS HIGH profile";
        }
        enum low {
          tailf:info "CSR UTD IPS/IDS LOW profile";
        }
        enum medium {
          tailf:info "CSR UTD IPS/IDS MEDIUM profile";
        }
        enum urlf-low {
          tailf:info "CSR UTD URL Filtering LOW profile";
        }
        enum multi-tenancy {
          tailf:info "CSR UTD Multi-Tenancy profile";
        }
      }
    }

    // virtual-service * / vnic
    container vnic {
      tailf:info "Guest vnic configuration";

      // virtual-service * / vnic gateway VirtualPortGroup*
      container gateway {
        tailf:info "Gateway interface to connect to the guest vnic";
        list VirtualPortGroup {
          tailf:info "Virtual Port Group";
          tailf:cli-allow-join-with-key {
            tailf:cli-display-joined;
          }
          tailf:cli-mode-name "config-virt-serv-vnic";
          tailf:cli-suppress-key-abbreviation;
          key name;
          leaf name {
            tailf:non-strict-leafref {
              path "../../../../../interface/VirtualPortGroup/name";
            }
            type uint8 {
              tailf:info "<0-31>;;VirtualPortGroup interface number";
            }
          }

          // virtual-service * / vnic gateway VirtualPortGroup* / guest
          container guest {
            tailf:info "Configure guest vnic address";

            // virtual-service * / vnic gateway VirtualPortGroup* / guest ip address
            container ip {
              tailf:info "Guest vnic IP address";
              leaf address {
                tailf:info "Set the IP address of virtual interface on guest";
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IP address";
                }
              }
            }

            // virtual-service * / vnic gateway VirtualPortGroup* / guest ipv6 address
            container ipv6 {
              tailf:info "Guest vnic IPv6 address";
              leaf address {
                tailf:info "Set the IPv6 address of virtual interface on guest";
                type inet:ipv6-address {
                  tailf:info "X:X:X:X::X;;IPv6 prefix";
                }
              }
            }
          }
        }
      }

      // virtual-service * / vnic management GigabitEthernet*
      container management {
        tailf:info "Management interface to connect to the guest vnic";
        list GigabitEthernet {
          tailf:info "GigabitEthernet";
          tailf:cli-allow-join-with-key {
            tailf:cli-display-joined;
          }
          tailf:cli-mode-name "config-virt-serv-vnic";
          tailf:cli-suppress-key-abbreviation;
          key name;
          leaf name {
            type string {
              tailf:info "<ID>;;GigabitEthernet interface id";
              pattern '[0-9]+.*';
            }
          }

          // virtual-service * / vnic management GigabitEthernet* / guest ip address
          container guest {
            tailf:info "Configure guest vnic address";

            // virtual-service * / vnic management GigabitEthernet* / guest ip address
            container ip {
              tailf:info "Guest vnic IP address";
              leaf address {
                tailf:info "Set the IP address of virtual interface on guest";
                type inet:host {
                  tailf:info "A.B.C.D;;IP address";
                }
              }
            }

            // virtual-service * / vnic management GigabitEthernet* / guest ipv6 address
            container ipv6 {
              tailf:info "Guest vnic IPv6 address";
              leaf address {
                tailf:info "Set the IPv6 address of virtual interface on guest";
                type inet:ipv6-address {
                  tailf:info "X:X:X:X::X;;IPv6 prefix";
                }
              }
            }
          }
        }
      }
    }

    // virtual-service * / activate
    leaf activate {
      tailf:info "Activate configured virtual service";
      tailf:ned-ignore-compare-config;
      type empty;
    }
  }


  /// ========================================================================
  /// route-map
  /// ========================================================================

  list route-map {
    tailf:info "Route map tag";
    tailf:cli-mode-name "config-route-map";
    tailf:cli-compact-syntax;
    tailf:cli-full-command;
    tailf:cli-diff-dependency "../ip/community-list";
    tailf:cli-diff-dependency "../ip/extcommunity-list";
    tailf:cli-diff-dependency "../ip/policy-list";
    key "name sequence";
    leaf name {
      type string {
        tailf:info "WORD;;Route map tag";
      }
    }

    // route-map * #
    leaf sequence {
      tailf:cli-drop-node-name;
      type uint16 {
        tailf:info "<0-65535>;;Sequence to insert to/delete from existing route-map entry";
        range "0..65535";
      }
    }

    // route-map * permit
    // route-map * deny
    leaf operation {
      tailf:cli-drop-node-name;
      tailf:cli-delete-container-on-delete;
      tailf:cli-prefix-key {
        tailf:cli-before-key 2;
      }
      type enumeration {
        enum deny {
          tailf:code-name "op_deny";
          tailf:info "Route map denies set operations";
        }
        enum permit {
          tailf:code-name "op_internet";
          tailf:info "Route map permits set operations";
        }
      }
    }

    // route-map * / description
    leaf description {
      tailf:info "Route-map comment";
      tailf:cli-multi-value;
      tailf:cli-preformatted;
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;Comment up to 100 characters";
        length "0..100";
      }
    }

    // route-map * / match
    container match {
      tailf:info "Match values from routing table";

      // route-map * / match as-path *
      leaf-list as-path {
        tailf:info "Match BGP AS path list";
        tailf:cli-flat-list-syntax;
        type string {
          tailf:info "WORD;;Access-list number or name";
        }
      }

      // route-map * / match ip
      container ip {
        tailf:info "IP specific information";

        // route-map * / match ip address
        container address {
          tailf:info "Match address of route or match packet";

          // route-map * / match ip address *
          leaf-list access-list {
            tailf:cli-drop-node-name;
            tailf:cli-flat-list-syntax;
            tailf:cli-disallow-value "prefix-list";
            type exp-ip-acl-type;
          }

          // route-map * / match ip address prefix-list *
          leaf-list prefix-list {
            tailf:info "Match entries of prefix-lists";
            tailf:cli-flat-list-syntax;
            tailf:non-strict-leafref {
              path "../../../../../ip/prefix-list/prefixes/name";
            }
            type string {
              tailf:info "WORD;;IP prefix-list name";
            }
          }
        }

        // route-map * / match ip next-hop
        container next-hop {
          tailf:info "Match next-hop address of route";

          // route-map * / match ip next-hop *
          leaf-list access-list {
            tailf:cli-drop-node-name;
            tailf:cli-flat-list-syntax;
            tailf:cli-disallow-value "prefix-list";
            type std-ip-acl-type;
          }

          // route-map * / match ip next-hop prefix-list *
          leaf-list prefix-list {
            tailf:info "Match entries of prefix-lists";
            tailf:cli-flat-list-syntax;
            tailf:non-strict-leafref {
              path "../../../../../ip/prefix-list/prefixes/name";
            }
            type string {
              tailf:info "WORD;;IP prefix-list name";
            }
          }
        }

        // route-map * / match ip route-source
        container route-source {
          tailf:info "Match advertising source address of route";

          // route-map * / match ip route-source *
          leaf-list access-list {
            tailf:cli-drop-node-name;
            tailf:cli-flat-list-syntax;
            tailf:cli-disallow-value "prefix-list";
            type std-ip-acl-type;
          }

          // route-map * / match ip route-source prefix-list *
          leaf-list prefix-list {
            tailf:info "Match entries of prefix-lists";
            tailf:cli-flat-list-syntax;
            tailf:non-strict-leafref {
              path "../../../../../ip/prefix-list/prefixes/name";
            }
            type string {
              tailf:info "WORD;;IP prefix-list name";
            }
          }
        }
      }

      // route-map * / match ipv6
      container ipv6 {
        tailf:info "IPv6 specific information";

        // route-map * / match ipv6 address
        container address {
          tailf:info "Match address of route";

          // route-map * / match ipv6 address
          leaf access-list {
            tailf:cli-drop-node-name;
            tailf:cli-disallow-value "prefix-list";
            tailf:cli-remove-before-change;
            tailf:cli-full-command;
            tailf:cli-diff-dependency "../prefix-list" {
              tailf:cli-trigger-on-set;
            }
            type string {
              tailf:info "WORD;;IPv6 access-list name";
            }
          }

          // route-map * / match ipv6 address prefix-list
          leaf prefix-list {
            tailf:info "IPv6 prefix-list";
            tailf:cli-remove-before-change;
            tailf:cli-full-command;
            tailf:cli-diff-dependency "../access-list" {
              tailf:cli-trigger-on-set;
            }
            tailf:non-strict-leafref {
              path "../../../../../ipv6/prefix-list/prefixes/name";
            }
            type string {
              tailf:info "WORD;;Name of a IPv6 prefix list";
            }
          }
        }

        // route-map * / match ipv6 next-hop
        container next-hop {
          tailf:info "Match next-hop address of route";

          // route-map * / match ipv6 next-hop ?
          leaf access-list {
            tailf:cli-drop-node-name;
            tailf:cli-disallow-value "prefix-list";
            type string {
              tailf:info "WORD;;IPv6 access-list name";
            }
          }

          // route-map * / match ipv6 next-hop prefix-list
          leaf prefix-list {
            tailf:info "IPv6 prefix-list";
            tailf:non-strict-leafref {
              path "../../../../../ipv6/prefix-list/prefixes/name";
            }
            type string {
              tailf:info "WORD;;Name of a IPv6 prefix list";
            }
          }
        }

        // route-map * / match ipv6 route-source
        container route-source {
          tailf:info "Match advertising source address of route";

          // route-map * / match ipv6 route-source ?
          leaf access-list {
            tailf:cli-drop-node-name;
            tailf:cli-disallow-value "prefix-list";
            type string {
              tailf:info "WORD;;IPv6 access-list name";
            }
          }

          // route-map * / match ipv6 route-source prefix-list
          leaf prefix-list {
            tailf:info "IPv6 prefix-list";
            tailf:non-strict-leafref {
              path "../../../../../ipv6/prefix-list/prefixes/name";
            }
            type string {
              tailf:info "WORD;;Name of a IPv6 prefix list";
            }
          }
        }
      }

      // route-map * / match community *
      leaf-list community {
        tailf:info "Match BGP community list";
        tailf:cli-flat-list-syntax;
        type string {
          tailf:info "WORD;;Community-list number or name";
        }
      }

      // route-map * / match extcommunity *
      leaf-list extcommunity {
        tailf:info "Match BGP/VPN extended community list";
        tailf:cli-flat-list-syntax;
        type string {
          tailf:info "WORD;;Community-list number or name";
        }
      }

      // route-map * / match tag *
      leaf-list tag {
        tailf:info "Match tag of route";
        tailf:cli-flat-list-syntax;
        type uint32 {
          tailf:info "<0-4294967295>;;Tag value";
        }
      }

      // route-map * / match clns address *
      container clns {
        tailf:info "CLNS information";
        leaf-list address {
          tailf:info "Match address of route or match packet";
          tailf:cli-flat-list-syntax;
          type string {
            tailf:info "WORD;;OSI filter set";
          }
        }
      }

      // route-map * / match interface *
      leaf-list interface {
        tailf:info "Match first hop interface of route";
        tailf:cli-flat-list-syntax;
        tailf:cli-diff-dependency "../../../interface";
        //cli:ned-diff-add ">interface :: after :: ^route-map \\S+ (permit|deny) \\d+<LF> match interface" {
        //cli:arguments "when-set";
        //}
        cli:ned-diff-add ">no interface :: after :: ^route-map \\S+ (permit|deny) \\d+<LF> no match interface" {
          cli:arguments "when-delete";
        }
        ios:max-values-output "2 :: 8"; // values start after 2 words, max 8 per line
        type string {
          tailf:info "WORD;;Interface name";
        }
      }

      // route-map * / match source-protocol *
      leaf-list source-protocol {
        tailf:info "Match source-protocol of route";
        tailf:cli-flat-list-syntax;
        type union {
          type enumeration {
            enum bgp {
              tailf:info "Border Gateway Protocol (BGP)";
            }
            enum connected {
              tailf:info "Connected";
            }
            enum eigrp {
              tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
            }
            enum isis {
              tailf:info "ISO IS-IS";
            }
            enum lisp {
              tailf:info "Locator ID Separation Protocol (LISP)";
            }
            enum mobile {
              tailf:info "Mobile routes";
            }
            enum ospf {
              tailf:info "Open Shortest Path First (OSPF)";
            }
            enum ospfv3 {
              tailf:info "OSPFv3";
            }
            enum rip {
              tailf:info "Routing Information Protocol (RIP)";
            }
            enum static {
              tailf:info "Static routes";
            }
          }
          type string {
            tailf:info "WORD;;Router id, e.g. AS number, process id etc.";
          }
        }
      }

      // route-map * / match route-type *
      list route-type {
        tailf:info "Match route-type of route";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-show-long-obu-diffs;
        ordered-by user;
        key tag;
        leaf tag {
          tailf:cli-multi-word-key;
          type string {
            tailf:info "WORD;external|internal|level-1|level-2|local|nssa-external|type-1|type-2";
          }
        }
      }

      // route-map * / match local-preference *
      leaf-list local-preference {
        tailf:info "Local preference for route";
        tailf:cli-flat-list-syntax;
        type uint32 {
          tailf:info "<0-4294967295>;;Local preference value";
        }
      }

      // route-map * / match policy-list *
      list policy-list {
        tailf:info "Match IP policy list";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          tailf:cli-multi-word-key;
          type string {
            tailf:info "WORD;;IP Policy map name";
          }
        }
      }

      // route-map * / match track
      leaf track {
        tailf:info "tracking object";
        tailf:cli-remove-before-change;
        type uint16 {
          tailf:info "<1-1000>;;tracked object number";
          range "1..1000";
        }
      }

      // route-map * / match length
      container length {
        tailf:info "Packet length";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf min {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<0-2147483647>;;Minimum packet length";
          }
        }
        leaf max {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<0-2147483647>;;Maximum packet length";
          }
        }
      }
    }

    // Routex-map * / set
    container set {
      tailf:info "Set values in destination routing protocol";

      // route-map * / set global
      leaf global {
        tailf:info "Set to global routing table";
        tailf:cli-full-command;
        type empty;
      }

      // route-map * / set as-path
      container as-path {
        tailf:info "Prepend string for a BGP AS-path attribute";

        // route-map * / set as-path prepend
        container prepend {
          tailf:info "Prepend to the as-path";

          // route-map * / set as-path prepend *
          leaf as-list {
            tailf:cli-drop-node-name;
            tailf:cli-multi-value;
            type string {
              tailf:info "<1-4294967295>|<1-65535>[.<0-65535>];;AS number";
              pattern '(([0-9]+\.)?([0-9]+) )*(([0-9]+\.)?([0-9]+))';
            }
          }

          // route-map * / set as-path prepend last-as
          leaf last-as {
            tailf:info "Prepend last AS to the as-path";
            tailf:cli-full-command;
            type uint8 {
              tailf:info "<1..10>;;number of last-AS prepends";
              range "1..10";
            }
          }
        }

        container tag {
          tailf:info "Set the tag as an AS-path attribute";
          tailf:cli-full-command;
          presence true;
        }
      }

      // route-map * / set comm-list
      container comm-list {
        tailf:info "set BGP community list (for deletion)";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf name {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type union {
            type uint16 {
              tailf:info "<1-99>;;Community-list number (standard)";
              range "1..99";
            }
            type uint16 {
              tailf:info "<100-500>;;Community-list number (expanded)";
              range "100..500";
            }
            type string {
              tailf:info "WORD;;Community-list name";
            }
          }
        }
        leaf delete {
          tailf:info "Delete matching communities";
          type empty;
        }
      }

      // route-map * / set community
      container community {
        tailf:info "BGP community attribute";
        choice set-community-choice {

          // route-map * / set community none
          leaf none {
            tailf:info "No community attribute";
            tailf:cli-full-command;
            type empty;
          }

          // route-map * / set community *
          leaf-list community-number {
            tailf:cli-drop-node-name;
            tailf:cli-flat-list-syntax;
            tailf:cli-replace-all;
            tailf:cli-remove-before-change;
            tailf:cli-no-value-on-delete;
            type union {
              type uint32 {
                tailf:info "<1-4294967295>;;community number";
                range "1..4294967295";
              }
              type enumeration {
                enum additive {
                  tailf:info "Add to the existing community";
                }
                enum internet {
                  tailf:info "Internet (well-known community)";
                }
                enum local-AS {
                  tailf:info "Do not send outside local AS (well-known community)";
                }
                enum no-advertise {
                  tailf:info "Do not advertise to any peer (well-known community)";
                }
                enum no-export {
                  tailf:info "Do not export to next AS (well-known community)";
                }
                enum gshut {
                  tailf:info "Graceful Shutdown (well-known community)";
                }
              }
              type string {
                tailf:info "aa:nn;;community number in aa:nn format";
                pattern "[0-9]+:[0-9]+";
              }
            }
          }
        }
      }

      // route-map * / set extcomm-list
      container extcomm-list {
        tailf:info "Set BGP/VPN extended community list (for deletion)";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf name {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type union {
            type uint16 {
              tailf:info "<1-99>;;Extended community-list number (standard)";
              range "1..99";
            }
            type uint16 {
              tailf:info "<100-500>;;Extended community-list number (expanded)";
              range "100..500";
            }
            type string {
              tailf:info "WORD;;extcommunity-list name";
            }
          }
        }
        leaf delete {
          tailf:info "Delete matching extended communities";
          type empty;
        }
      }

      // route-map * / set extcommunity
      container extcommunity {
        tailf:info "BGP extended community attribute";

        // route-map * / set extcommunity soo
        leaf soo {
          tailf:info "Site-of-Origin extended community";
          tailf:cli-remove-before-change;
          type string {
            tailf:info "ASN:nn or IP-address:nn;;VPN extended community";
          }
        }

        // route-map * / set extcommunity color
        leaf color {
          tailf:info "Color extended community";
          tailf:cli-remove-before-change;
          type uint32 {
            tailf:info "<1-4294967295>;;Color Value";
            range "1..4294967295";
          }
        }

        // route-map * / set extcommunity rt *
        leaf-list rt {
          tailf:info "Route Target extended community";
          tailf:cli-flat-list-syntax;
          tailf:cli-replace-all;
          tailf:cli-remove-before-change;
          tailf:cli-no-value-on-delete;
          ordered-by user;
          type union {
            type enumeration {
              enum "range" {
                tailf:info "Specify a range of extended community";
              }
              enum "additive" {
                tailf:info "Add to the existing community";
              }
            }
            type asn-ip-type {
              tailf:info "ASN:nn or IP-address:nn;;VPN extended community";
            }
          }
        }
      }

      // route-map * / set ip
      container ip {
        tailf:info "IP specific information";

        // route-map * / set ip address prefix-list
        container address {
          tailf:info "Specify IP address";
          leaf prefix-list {
            tailf:info "Specify prefix-list";
            type string {
              tailf:info "WORD;;Prefix-list name to set ip address";
            }
          }
        }

        // route-map * / set ip vrf * next-hop *
        list vrf {
          tailf:info "VRF name";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          key name;
          leaf name {
            tailf:cli-diff-dependency "../../../../../ip/vrf";
            tailf:cli-diff-dependency "../../../../../vrf/definition";
            type string {
              tailf:info "WORD;;VRF name";
            }
          }
          leaf-list next-hop {
            tailf:info "Next hop address";
            tailf:cli-flat-list-syntax;
            tailf:cli-replace-all;
            tailf:cli-remove-before-change;
            ios:max-values-output "5 :: 8"; // values start after 5 words, max 8 per line
            ordered-by user;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP address of next hop";
            }
          }
        }

        // route-map * / set ip next-hop
        container next-hop {
          tailf:info "Next hop address";

          // route-map * / set ip next-hop self
          leaf self {
            tailf:info "Use self address (for BGP only)";
            type empty;
          }

          // route-map * / set ip next-hop verify-availability *
          container verify-availability-conf {
            tailf:cli-drop-node-name;
            list verify-availability {
              tailf:info "Verify if nexthop is reachable";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              tailf:cli-incomplete-command;
              key address;
              leaf address {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IP address of next hop";
                }
              }
              leaf sequence {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type uint16 {
                  tailf:info "<1-65535>;;Sequence to insert into next-hop list";
                  range "1..65535";
                }
              }
              leaf track {
                tailf:info "set the next hop depending on the state of a tracked object";
                type uint16 {
                  tailf:info "<1-1000>;;tracked object number";
                  range "1..1000";
                }
              }
            }
          }

          // route-map * / set ip next-hop peer-address
          leaf peer-address {
            tailf:info "Use peer address (for BGP only)";
            tailf:cli-full-command;
            tailf:cli-diff-dependency "../address" {
              tailf:cli-trigger-on-set;
            }
            type empty;
          }

          // route-map * / set ip next-hop *
          leaf-list address {
            tailf:cli-drop-node-name;
            tailf:cli-flat-list-syntax;
            tailf:cli-replace-all;
            tailf:cli-remove-before-change;
            tailf:cli-full-command;
            tailf:cli-diff-dependency "../peer-address" {
              tailf:cli-trigger-on-set;
            }
            ios:max-values-output "3 :: 12"; // values start after 3 words, max 12 per line
            ordered-by user;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP address of next hop";
            }
          }

          // route-map * / set ip next-hop verify-availability
          leaf verify-availability {
            tailf:info "Verify if nexthop is reachable";
            tailf:cli-full-command;
            type empty;
          }

          // route-map * / set ip next-hop dynamic
          container dynamic {
            tailf:info "application dynamically sets next hop";
            leaf dhcp {
              tailf:info "DHCP learned next hop";
              type empty;
            }
          }

          // route-map * / set ip next-hop recursive
          container recursive {
            tailf:info "Recursive next-hop";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            choice global-or-vrf-choice {
              leaf global {
                tailf:info "global routing table";
                tailf:cli-optional-in-sequence;
                tailf:cli-incomplete-command;
                type empty;
              }
              leaf vrf {
                tailf:info "VRF name";
                tailf:cli-optional-in-sequence;
                tailf:cli-incomplete-command;
                type string {
                  tailf:info "WORD;;VRF name";
                }
              }
            }
            leaf address {
              tailf:cli-drop-node-name;
              tailf:cli-full-command;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IP address of recursive next hop";
              }
            }
          }

          // route-map * / set ip next-hop encapsulate
          container encapsulate {
            tailf:info "Encapsulation profile for VPN nexthop";
            leaf l3vpn {
              tailf:info "L3VPN";
              type string {
                tailf:info "WORD;;Encapsulation profile name";
              }
            }
          }
        }

        // route-map * / set ip df
        container df {
          tailf:info "Set DF bit";
          tailf:cli-delete-when-empty;
          presence true;
          leaf bit {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<0-1>;;DF bit";
              range "0..1";
            }
          }
        }

        // route-map * / set ip precedence
        leaf precedence {
          tailf:info "Set precedence field";
          tailf:cli-full-command;
          type precedence-type;
        }

        // route-map * / set ip qos-group
        leaf qos-group {
          tailf:info "Set QOS Group ID";
          type uint8 {
            tailf:info "<0-99>;;QOS Group ID";
            range "0..99";
          }
        }

        // route-map * / set ip tos
        leaf tos {
          tailf:info "Set type of service field";
          type union {
            type uint8 {
              tailf:info "<0-15>;;Type of service value";
              range "0..15";
            }
            type enumeration {
              enum normal {
                tailf:info "Set normal TOS (0)";
                value 0;
              }
              enum min-monetary-cost {
                tailf:info "Set min monetary cost TOS (1)";
                value 1;
              }
              enum max-reliability {
                tailf:info "Set max reliable TOS (2)";
                value 2;
              }
              enum max-throughput {
                tailf:info "Set max throughput TOS (4)";
                value 4;
              }
              enum min-delay {
                tailf:info "Set min delay TOS (8)";
                value 8;
              }
            }
          }
        }

        // route-map * / set ip default
        container default {
          tailf:info "Set default information";

          // route-map * / set ip default next-hop *
          container next-hop {
            tailf:info "Next hop along path";

            // route-map * / set ip default next-hop *
            leaf-list address {
              tailf:cli-drop-node-name;
              tailf:cli-flat-list-syntax;
              tailf:cli-replace-all;
              tailf:cli-remove-before-change;
              tailf:cli-full-command;
              ios:max-values-output "4 :: 8"; // values start after 4 words, max 8 per line
              ordered-by user;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IP address of next hop";
              }
            }
          }

          // route-map * / set ip default vrf * next-hop *
          list vrf {
            tailf:info "VRF name";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key name;
            leaf name {
              tailf:cli-diff-dependency "../../../../../../ip/vrf";
              tailf:cli-diff-dependency "../../../../../../vrf/definition";
              type string {
                tailf:info "WORD;;VRF name";
              }
            }
            leaf-list next-hop {
              tailf:info "Next hop address";
              tailf:cli-flat-list-syntax;
              tailf:cli-replace-all;
              tailf:cli-remove-before-change;
              ios:max-values-output "6 :: 8"; // values start after 6 words, max 8 per line
              ordered-by user;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IP address of next hop";
              }
            }
          }
        }
      }

      // route-map * / set ipv6
      container ipv6 {
        tailf:info "IPv6 specific information";

        // route-map * / set ipv6 next-hop
        container next-hop {
          tailf:info "IPv6 Next hop";
          choice next-hop-choice {
            leaf-list address {
              tailf:cli-drop-node-name;
              tailf:cli-flat-list-syntax;
              tailf:cli-replace-all;
              tailf:cli-remove-before-change;
              tailf:cli-full-command;
              ios:max-values-output "3 :: 6"; // values start after 3 words, max 6 per line
              ordered-by user;
              type inet:ipv6-address {
                tailf:info "X:X:X:X::X;;Next hop address";
              }
            }
            leaf peer-address {
              tailf:info "Use peer address (for BGP only)";
              tailf:cli-full-command;
              type empty;
            }
          }

          // route-map * / set ipv6 next-hop recursive
          leaf recursive {
            tailf:info "Recursive next-hop";
            type inet:ipv6-address {
              tailf:info "X:X:X:X::X;;IPv6 address of recursive next-hop";
            }
          }
        }

        // route-map * / set ipv6 precedence
        leaf precedence {
          tailf:info "IPv6 Precedence";
          type uint8 {
            tailf:info "<0-7>;;Precedence value";
            range "0..7";
          }
        }
      }

      // route-map * / set level
      leaf level {
        tailf:info "Where to import route";
        type enumeration {
          enum level-1 {
            tailf:info "Import into a level-1 area";
          }
          enum level-1-2 {
            tailf:info "Import into level-1 and level-2";
          }
          enum level-2 {
            tailf:info "Import into level-2 sub-domain";
          }
          enum nssa-only {
            tailf:info "Import only into OSPF NSSA areas and don't propagate";
          }
        }
      }

      // route-map * / set local-preference
      container local-preference {
        tailf:info "BGP local preference path attribute";
        tailf:cli-delete-when-empty;
        presence true;
        leaf value {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<0-4294967295>;;Preference value";
          }
        }
      }

      // route-map * / set metric
      leaf-list metric {
        tailf:info "Metric value for destination routing protocol";
        tailf:cli-flat-list-syntax;
        tailf:cli-replace-all;
        tailf:cli-remove-before-change;
        ordered-by user;
        type string {
          tailf:info "+/-<metric>;;Add or subtract metric <0-4294967295>;;Metric value or Bandwidth in Kbits per second";
          pattern '[+-]?[0-9]*';
        }
      }

      // route-map * / set aigp-metric
      leaf aigp-metric {
        tailf:info "accumulated metric value";
        type union {
          type uint32 {
            tailf:info "<0-4294967295>;;manual value";
          }
          type enumeration {
            enum igp-metric {
              tailf:info "metric value from rib";
            }
          }
        }
      }

      // route-map * / set metric-type
      leaf metric-type {
        tailf:info "Type of metric for destination routing protocol";
        type enumeration {
          enum external {
            tailf:info "IS-IS external metric";
          }
          enum internal {
            tailf:info "IS-IS internal metric or Use IGP metric as the MED for BGP";
          }
          enum type-1 {
            tailf:info "OSPF external type 1 metric";
          }
          enum type-2 {
            tailf:info "OSPF external type 2 metric";
          }
        }
      }

      // route-map * / set weight
      leaf weight {
        tailf:info "BGP weight for routing table";
        type uint32 {
          tailf:info "<0-65535>;;Weight value";
          range "0..65535";
        }
      }

      // route-map * / set origin
      container origin {
        tailf:info "BGP origin code";
        choice origin-choice {
          leaf origin-value {
            tailf:cli-drop-node-name;
            type enumeration {
              enum igp {
                tailf:info "local IGP";
              }
              enum incomplete {
                tailf:info "unknown heritage";
              }
            }
          }
          leaf egp {
            tailf:info "remote EGP";
            type uint32 {
              tailf:info "<0-65535>;;remote AS";
              range "0..65535";
            }
          }
        }
      }

      // route-map * / set vrf
      leaf vrf {
        tailf:info "Define VRF name";
        tailf:cli-diff-dependency "../../../ip/vrf";
        tailf:cli-diff-dependency "../../../vrf/definition";
        type string {
          tailf:info "WORD;;VPN Routing/Forwarding instance name";
        }
      }

      // route-map * / set tag
      leaf tag {
        tailf:info "Tag value for destination routing protocol";
        type uint32 {
          tailf:info "<0-4294967295>;;Tag value";
        }
      }

      // route-map * / set mpls-label
      leaf mpls-label {
        tailf:info "Set MPLS label for prefix";
        type empty;
      }

      // route-map * / set interface
      leaf-list interface {
        tailf:info "Output interface";
        tailf:cli-flat-list-syntax;
        ordered-by user;
        type string {
          tailf:info "WORD;;Interface name";
        }
      }

      // route-map * / set default interface
      container default {
        tailf:info "Set default information";
        container interface {
          tailf:info "Default output interface";
          tailf:cli-compact-syntax;
          uses interface-name-grouping;
        }
      }
    }

    // route-map * / continue
    container continue {
      tailf:info "Continue on a different entry within the route-map";
      tailf:cli-delete-when-empty;
      presence true;
      leaf sequence-number {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<0-65535>;;Route-map entry sequence number";
        }
      }
    }
  }


  /// ========================================================================
  /// dialer
  /// ========================================================================

  container dialer {
    tailf:info "Dialer commands";

    // dialer watch-list *
    list watch-list {
      tailf:info "Dialer watch list";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key id;
      leaf id {
        type uint16 {
          tailf:info "<1-255>;;Dialer watch group number";
          range "1..255";
        }
      }

      // dialer watch-list * ip *
      list ip {
        tailf:info "IP";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key address;
        leaf address {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Protocol specific address";
          }
        }
        leaf mask {
          tailf:cli-drop-node-name;
          tailf:cli-no-value-on-delete;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP subnet mask";
          }
        }
      }

      // dialer watch-list * delay
      container delay {
        tailf:info "Dialer watch delay";

        // dialer watch-list * delay route-check initial
        container route-check {
          tailf:info "Interval for checking watched route";
          leaf initial {
            tailf:info "Delay for initial check of watched route after boot";
            type uint32 {
              tailf:info "<1-2147483>;;Delay time in seconds";
            }
          }
        }

        // dialer watch-list * delay connect
        leaf connect {
          tailf:info "Interval before dialing the secondary route";
          type uint32 {
            tailf:info "<1-2147483>;;Delay time in seconds";
            range "1..2147483";
          }
        }

        // dialer watch-list * delay disconnect
        leaf disconnect {
          tailf:info "Interval before disconnecting the secondary route";
          type uint32 {
            tailf:info "<1-2147483>;;Delay time in seconds";
            range "1..2147483";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// dialer-list
  /// ========================================================================

  list dialer-list {
    tailf:info "Create a dialer list entry";
    tailf:cli-suppress-mode;
    tailf:cli-delete-when-empty;
    tailf:cli-compact-syntax;
    key id;
    leaf id {
      type uint16 {
        tailf:info "<1-128>;;Dialer group number";
      }
    }
    container protocol {
      tailf:info "Permit or Deny based on protocols";
      leaf ip {
        tailf:info "IP";
        type enumeration {
          enum deny {
            tailf:info "Deny specified protocol";
          }
          enum "list" {
            tailf:info "Add access list to dialer list";
          }
          enum permit {
            tailf:info "Permit specified protocol";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// authentication
  /// ========================================================================

  container authentication {
    tailf:info "Auth Manager Global Configuration Commands";

    // authentication critical recovery delay
    container critical {
      tailf:info "Set Critical Authentication parameters";
      container recovery {
        tailf:info "Set Critical Authentication Recovery parameters";
        leaf delay {
          tailf:info "Set Critical Authentication Recovery Delay period";
          type uint16 {
            tailf:info "<1-10000>;;Critical Authentication Recovery delay in milliseconds. Default 100";
            range "1..10000";
          }
          default 100;
        }
      }
    }

    // authentication mac-move permit
    container mac-move {
      tailf:info "Set required action when a MAC move is detected";
      leaf permit {
        tailf:info "PERMIT MAC moves (clears existing session)";
        type empty;
      }
    }

    // authentication logging verbose
    container logging {
      tailf:info "Set logging parameters";
      leaf verbose {
        tailf:info "Show verbose messages in system logs";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// banner
  /// ========================================================================

  container banner {
    tailf:info "Define a login banner";

    // banner exec
    leaf exec {
      tailf:info "Set EXEC process creation banner. ";
      tailf:cli-no-value-on-delete;
      type string {
        tailf:info "LINE;;Quoted string. Use \\r\\n for newline. delimeter ^ is added automatically.";
      }
    }

    // banner incoming
    leaf incoming {
      tailf:info "Set incoming terminal line banner";
      tailf:cli-no-value-on-delete;
      type string {
        tailf:info "LINE;;Quoted string. Use \\r\\n for newline. delimeter ^ is added automatically.";
      }
    }

    // banner login
    leaf login {
      tailf:info "Set login banner.";
      tailf:cli-no-value-on-delete;
      type string {
        tailf:info "LINE;;Quoted string. Use \\r\\n for newline. delimeter ^ is added automatically.";
      }
    }

    // banner lcd
    leaf lcd {
      tailf:info "Set Message for LCD banner";
      tailf:cli-no-value-on-delete;
      type string {
        tailf:info "LINE;;Quoted string. Use \\r\\n for newline. delimeter ^ is added automatically.";
      }
    }

    // banner prompt-timeout
    leaf prompt-timeout {
      tailf:info "Set Message for login authentication timeout.";
      tailf:cli-no-value-on-delete;
      type string {
        tailf:info "LINE;;Quoted string. Use \\r\\n for newline. delimeter ^ is added automatically.";
      }
    }

    // banner motd
    leaf motd {
      tailf:info "Set Message of the Day banner.";
      tailf:cli-no-value-on-delete;
      type string {
        tailf:info "LINE;;Quoted string. Use \\r\\n for newline. delimeter ^ is added automatically.";
      }
    }

    // banner config-save
    leaf config-save {
      tailf:info "Set message for saving configuration";
      tailf:cli-no-value-on-delete;
      type string {
        tailf:info "LINE;;Quoted string. Use \\r\\n for newline. delimeter ^ is added automatically.";
      }
    }
  }


  /// ========================================================================
  /// pseudowire-static-oam
  /// ========================================================================

  // pseudowire-static-oam class *
  container pseudowire-static-oam {
    tailf:info "Static PW OAM configuration";
    list class {
      tailf:info "Static PW OAM class configuration";
      tailf:cli-mode-name "config-st-pw-oam-class";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Static PW OAM class name";
        }
      }

      // pseudowire-static-oam class * / timeout refresh send
      container timeout {
        tailf:info "timeout configurations";
        container refresh {
          tailf:info "refresh timeout configurations";
          leaf send {
            tailf:info "refresh send timeout configuration";
            type uint16 {
              tailf:info "<1-4095>;;Seconds, default is 30";
              range "1..4095";
            }
            default 30;
          }
        }
      }

      // pseudowire-static-oam class * / ttl
      leaf ttl {
        tailf:info "TTL value for multi-segment PW OAM data";
        type uint8 {
          tailf:info "<1-255>;;TTL, default is 1";
          range "1..255";
        }
        default 1;
      }
    }
  }


  /// ========================================================================
  /// control-plane
  /// ========================================================================

  // control-plane host
  container control-plane-host {
    tailf:cli-drop-node-name;
    container control-plane {
      tailf:info "Configure control plane services";
      container host {
        tailf:info "Host traffic control-plane configuration";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-cp-host";
        presence true;

        // control-plane host / management-interface *
        list management-interface {
          tailf:info "Configure interface for receiving network management traffic";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          tailf:cli-diff-dependency "../../../../interface";
          key interface;
          leaf interface {
            type string {
              tailf:info "WORD;;Interface name";
            }
          }
          leaf-list allow {
            tailf:info "Allowed network management protocols on selected interface";
            tailf:cli-flat-list-syntax;
            type enumeration {
              enum  beep {
                tailf:info "Beep Protocol";
              }
              enum ftp {
                tailf:info "File Transfer Protocol";
              }
              enum http {
                tailf:info "HTTP Protocol";
              }
              enum https {
                tailf:info "HTTPS Protocol";
              }
              enum snmp {
                tailf:info "Simple Network Management Protocol";
              }
              enum ssh {
                tailf:info "Secure Shell Protocol";
              }
              enum telnet {
                tailf:info "Telnet Protocol";
              }
              enum tftp {
                tailf:info "Trivial File Transfer Protocol";
              }
              enum tl1 {
                tailf:info "Transaction Language Session Protocol";
              }
            }
          }
        }
      }
    }
  }

  // control-plane
  container control-plane {
    tailf:info "Configure control plane services";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-cp";
    presence true;

    // control-plane service-policy
    container service-policy {
      tailf:info "Configure QOS Service Policy";
      uses service-policy-grouping;
    }
  }


  /// ========================================================================
  /// credentials
  /// ========================================================================

  // credentials
  container credentials {
    tailf:info "credentials service";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-credentials";
    presence true;
  }


  /// ========================================================================
  /// cops
  /// ========================================================================

  container cops {
    tailf:info "Common Open Policy Service (COPS)";

    // cops listener access-list
    container listener {
      tailf:info "Incoming connections from policy decision points (PDPs)";
      leaf access-list {
        tailf:info "Rules for PDPs connecting to local COPS listeners";
        type exp-ip-acl-type;
      }
    }

    // cops ip dscp
    container ip {
      tailf:info "IP parameters for COPS connections";
      leaf dscp {
        tailf:info "Differentiated Services Code Point marking for COPS messages";
        type dscp-type;
      }
    }
  }


  /// ========================================================================
  /// connect
  /// ========================================================================

  list connect {
    tailf:info "cross-connect two interfaces";
    tailf:cli-mode-name "config-connection";
    tailf:cli-compact-syntax;
    tailf:cli-sequence-commands {
      tailf:cli-reset-siblings;
    }
    tailf:cli-diff-delete-before "../interface/GigabitEthernet/service/instance";
    tailf:cli-diff-delete-before "../interface/TenGigabitEthernet/service/instance";
    tailf:cli-diff-dependency "../interface";
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;Name for this connection";
      }
    }
    leaf interface1 {
      tailf:cli-drop-node-name;
      tailf:cli-hide-in-submode;
      type string {
        tailf:info "WORD;;First interface name";
      }
    }
    leaf number1 {
      tailf:cli-drop-node-name;
      tailf:cli-optional-in-sequence;
      tailf:cli-hide-in-submode;
      type uint16 {
        tailf:info "<1-8184>;;Service Instance Identifier";
        range "1..8184";
      }
    }
    leaf interface2 {
      tailf:cli-drop-node-name;
      tailf:cli-hide-in-submode;
      type string {
        tailf:info "WORD;;Second interface name";
      }
    }
    leaf number2 {
      tailf:cli-drop-node-name;
      tailf:cli-optional-in-sequence;
      tailf:cli-hide-in-submode;
      type uint16 {
        tailf:info "<1-8184>;;Service Instance Identifier";
        range "1..8184";
      }
    }

    // connect * / backup
    container backup {
      tailf:cli-break-sequence-commands;
      tailf:info "Xconnect backup configuration commands";

      // connect * / backup peer
      container peer {
        tailf:info "Backup pseudowire";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf peer-router-ip-addr {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP address of peer";
          }
        }
        leaf vcid {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-4294967295>;;Peer VC ID value";
            range "1..4294967295";
          }
        }
        leaf pw-class {
          tailf:cli-optional-in-sequence;
          tailf:non-strict-leafref {
            path "../../../../pseudowire-class/name";
          }
          type string {
            tailf:info "Optional Pseudowire-class to use for backup pseudowire";
          }
        }
      }
    }

    // connect * / xconnect
    uses xconnect-grouping;
  }


  /// ========================================================================
  /// voice-port
  /// ========================================================================

  list voice-port {
    tailf:info "Configure a specific voice-port";
    tailf:cli-mode-name "config-voiceport";
    key name;
    leaf name {
      type string {
        tailf:info "<0-0>;;Voice interface slot #";
      }
    }

    // voice-port * / trunk-group
    leaf trunk-group {
      tailf:info "Configure interface to be in a trunk group";
      tailf:cli-remove-before-change;
      tailf:cli-no-value-on-delete;
      type string {
        tailf:info "WORD;;Trunk group label";
      }
    }

    // voice-port * / translation-profile
    container translation-profile {
      tailf:info "Translation profile";

      // voice-port * / translation-profile incoming
      leaf incoming {
        tailf:info "Translation Profile for incoming call leg";
        tailf:non-strict-leafref {
          path "/ios:voice/translation-profile/name";
        }
        type string {
          tailf:info "WORD;;Profile name";
        }
      }

      // voice-port * / translation-profile outgoing
      leaf outgoing {
        tailf:info "Translation Profile for outgoing call leg";
        tailf:non-strict-leafref {
          path "/ios:voice/translation-profile/name";
        }
        type string {
          tailf:info "WORD;;Profile name";
        }
      }
    }

    // voice-port * / signal
    container signal {
      tailf:info "The signaling type for the interface FXS or FXO";

      // voice-port * / signal groundStart
      leaf groundStart {
        tailf:info "Ground Start";
        type empty;
      }
    }

    // voice-port * / echo-cancel
    container echo-cancel {
      tailf:info "Echo-cancellation option";

      // voice-port * / echo-cancel coverage
      leaf coverage {
        tailf:info "Echo Cancel Coverage";
        type enumeration {
          enum 24 {
            tailf:info "24 milliseconds echo canceller coverage";
          }
          enum 32 {
            tailf:info "32 milliseconds echo canceller coverage";
          }
          enum 48 {
            tailf:info "48 milliseconds echo canceller coverage";
          }
          enum 64 {
            tailf:info "64 milliseconds echo canceller coverage";
          }
          enum 80 {
            tailf:info "80 milliseconds echo canceller coverage";
          }
          enum 96 {
            tailf:info "96 milliseconds echo canceller coverage";
          }
          enum 112 {
            tailf:info "112 milliseconds echo canceller coverage";
          }
          enum 128 {
            tailf:info "128 milliseconds echo canceller coverage";
          }
        }
      }
    }

    // voice-port * / no vad
    leaf vad {
      tailf:info "Use VoiceActivityDetection as necessary option";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
      default true;
    }

    // voice-port * / timeouts
    container timeouts {
      tailf:info "Configure voice timeout parameters";

      // voice-port * / timeouts ringing
      leaf ringing {
        tailf:info "Ringing no answer timeout duration in seconds";
        type union {
          type uint16 {
            tailf:info "<5-60000>;;seconds";
            range "5..60000";
          }
          type enumeration {
            enum infinity {
              tailf:info "infinite timeout";
            }
          }
        }
      }

      // voice-port * / timeouts interdigit
      leaf interdigit {
        tailf:info "Interdigit Timeout duration in seconds";
        type uint8 {
          tailf:info "<0-120>;;seconds";
          range "0..120";
        }
      }
    }

    // voice-port * / shutdown
    leaf shutdown {
      tailf:cli-full-command;
      type empty;
    }

    // voice-port * / connection
    container connection {
      tailf:info "Specify Trunking Parameters";

      // voice-port * / connection plar
      container plar {
        tailf:info "Private Line Auto Ringdown";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf opx {
          tailf:info "Off-Premises eXtension PLAR";
          tailf:cli-optional-in-sequence;
          type empty;
        }
        leaf digits {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;A string of digits including wild cards";
          }
        }
      }
    }

    // voice-port * / description
    uses description-grouping;

    // voice-port * / bearer-cap
    leaf bearer-cap {
      tailf:info "Specify the bear capability";
      type enumeration {
        enum 3100hz {
          tailf:info "enable 3100hz";
        }
        enum Speech {
          tailf:info "enable speech";
        }
      }
    }

    // voice-port * / station-id
    container station-id {
      tailf:info "Configure station ID";

      // voice-port * / station-id name
      leaf-list name {
        tailf:info "A string describing station name";
        tailf:cli-flat-list-syntax;
        tailf:cli-no-value-on-delete;
        type string {
          tailf:info "LINE;;Station name";
        }
      }

      // voice-port * / station-id number
      leaf number {
        tailf:info "A full E.164 telephone number";
        tailf:cli-no-value-on-delete;
        type string {
          tailf:info "WORD;;Station telephone number";
        }
      }
    }

    // voice-port * / caller-id
    container caller-id {
      tailf:info "Configure port caller id parameters";
      // voice-port * / caller-id enable
      container enable {
        tailf:info "Enable caller id on this port";
        presence true;
      }
    }

    // voice-port * / busyout
    container busyout {
      tailf:info "Configure busyout trigger event & procedure";

      // voice-port * / busyout action shutdown
      container action {
        tailf:info "busyout action";
        leaf shutdown {
          tailf:info "shutdown D channel";
          type empty;
        }
      }

      // voice-port * / busyout monitor
      container monitor {
        tailf:info "The event of this interface triggers busyout";

        // voice-port * / busyout monitor action
        container action {
          tailf:info "busyout action when monitoring triggered";
          choice action-choice {
            leaf graceful {
              tailf:info "graceful busyout when monitoring triggered";
              type empty;
            }
            leaf shutdown {
              tailf:info "shutdown D channel when monitoring triggered";
              type empty;
            }
            container alarm {
              tailf:info "Use alarm generation";
              leaf blue {
                tailf:info "Use blue alarm";
                type empty;
              }
            }
          }
        }

        // voice-port * / busyout monitor *
        list state {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Interface name";
            }
          }
          leaf in-service {
            tailf:info "Inverted logic trigger by interface back up or in service";
            type empty;
          }
        }
      }
    }
  }


  /// ========================================================================
  /// dspfarm
  /// ========================================================================

  // dspfarm profile *
  container dspfarm {
    tailf:info "Enable the dspfarm service";
    list profile {
      tailf:info "Specify the DSPFARM profile information";
      tailf:cli-mode-name "config-dspfarm-profile";
      key id;
      leaf id {
        type uint16 {
          tailf:info "<1-65535>;;Profile ID";
          range "1..65535";
        }
      }
      leaf type {
        tailf:cli-drop-node-name;
        tailf:cli-hide-in-submode;
        type enumeration {
          enum conference {
            tailf:info "Profile type Conference";
          }
          enum mtp {
            tailf:info "Profile type MTP";
          }
          enum transcode {
            tailf:info "Profile type Transcoding";
          }
        }
      }

      // dspfarm profile * / description
      uses description-grouping;

      // dspfarm profile * / codec *
      list codec {
        tailf:info "The codec rate to be attempted for SCCP controlled connections";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type enumeration {
            enum pass-through {
              tailf:info "Stream Pass Through";
            }
            enum ilbc {
              tailf:info "ILBC codec";
            }
            enum isac {
              tailf:info "ISAC codec";
            }
            enum g729br8 {
              tailf:info "G.729b 8000 bps";
            }
            enum g729r8 {
              tailf:info "G.729 8000 bps";
            }
            enum g729abr8 {
              tailf:info "G.729ab 8000 bps";
            }
            enum g729ar8 {
              tailf:info "G.729a 8000 bps";
            }
            enum g711alaw {
              tailf:info "G.711 A Law 64000 bps";
            }
            enum g711ulaw {
              tailf:info "G.711 u Law 64000 bps";
            }
            enum g722-64 {
              tailf:info "G722r64";
            }
          }
        }
      }

      // dspfarm profile * / maximum
      container maximum {
        tailf:info "Configure maximum limit";

        // dspfarm profile * / maximum conference-participants
        leaf conference-participants {
          tailf:info "Configure maximum number of conferee per session";
          type uint32 {
            tailf:info "<0-4294967295>;;Number of participants per conference session";
          }
        }

        // dspfarm profile * / maximum sessions
        container sessions {
          tailf:info "Configure maximum number of sessions";
          leaf value {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<0-0>;;Number of sessions assigned to this profile";
            }
          }

          // dspfarm profile * / maximum sessions hardware
          leaf hardware {
            tailf:info "Hardware MTP";
            type uint32 {
              tailf:info "<0-0>;;Number of sessions assigned to this profile";
            }
          }

          // dspfarm profile * / maximum sessions software
          leaf software {
            tailf:info "Software MTP";
            type uint32 {
              tailf:info "<1-20000>;;Number of sessions assigned to this profile";
            }
          }
        }
      }

      // dspfarm profile * / conference-join custom-cptone
      container conference-join {
        tailf:info "Define the custom cptone for conference join";
        leaf custom-cptone {
          tailf:info "Custom cptone";
          type string {
            tailf:info "WORD;;Custom cptone ID string";
          }
        }
      }

      // dspfarm profile * / conference-leave custom-cptone
      container conference-leave {
        tailf:info "Define the custom cptone for conference leave";
        leaf custom-cptone {
          tailf:info "Custom cptone";
          type string {
            tailf:info "WORD;;Custom cptone ID string";
          }
        }
      }

      // dspfarm profile * / associate application
      container associate {
        tailf:info "Associations this profile";
        leaf application {
          tailf:info "Assign an application to the profile";
          type enumeration {
            enum CUBE {
              tailf:info "Cisco Unified Border Element application";
            }
            enum SCCP {
              tailf:info "skinny client control application";
            }
          }
        }
      }

      // dspfarm profile * / shutdown
      leaf shutdown {
        tailf:info "Disable or enable this profile";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// presence
  /// ========================================================================

  // presence
  container presence {
    tailf:info "presence service submode";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-presence";
    tailf:cli-explicit-exit;
    presence true;

    // presence / presence
    container presence {
      tailf:info "enable BLF call list feature";

      // presence / presence call-list
      leaf call-list {
        tailf:info "enable BLF call list feature";
        type empty;
      }
    }

    // presence / max-subscription
    leaf max-subscription {
      tailf:info "Define max subscription allowed";
      type uint16 {
        tailf:info "<100-1200>;;maximum subscription supported";
        range "100..1200";
      }
    }

    // presence / watcher all
    container watcher {
      tailf:info "watcher";
      leaf all {
        tailf:info "allow external watchers for presence";
        type empty;
      }
    }

    // presence / allow subscribe
    container allow {
      tailf:info "allow";
      leaf subscribe {
        tailf:info "allow external subscription for presence";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// call-manager-fallback
  /// ========================================================================

  container call-manager-fallback {
    tailf:info "SRST for Cisco Call Manager fallback. For Cisco Unified Communications Manager Express configuration use the 'telephony-service' command";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-cm-callback";
    tailf:cli-explicit-exit;
    tailf:cli-diff-delete-before "../telephony-service" {
      tailf:cli-when-target-set;
    }
    presence true;

    // call-manager-fallback / max-conferences
    container max-conferences {
      tailf:info "Define max number of 3 party G.711 conferences";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf max {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-230>;;Maximum conferences to support";
        }
      }
      leaf gain {
        tailf:info "Define conference mixer gain as 6dB, 3db, 0db or -6dB (default)";
        type int8 {
          tailf:info "<-6 - 6>;;conference mixer gain 6, 3, 0 or -6";
          range "-6..6";
        }
      }
    }

    // call-manager-fallback / transfer-system
    leaf transfer-system {
      tailf:info "Define call transfer system: blind/consult and local/end-to-end";
      type enumeration {
        enum blind {
          tailf:info "Perform blind call transfers (without consultation) with single phone line using Cisco proprietary method";
        }
        enum full-blind {
          tailf:info "Perform call transfers without consultation using H.450.2 or SIP REFER standard methods";
        }
        enum full-consult {
          tailf:info "Perform H.450.2/SIP call transfers with consultation using second phone line if available, fallback to full-blind if second line unavailable";
        }
        enum local-consult {
          tailf:info "Perform call transfers with local consultation using second phone line if available, fallback to blind for non-local consultation/transfer target. Uses Cisco proprietary method";

        }
      }
    }

    // call-manager-fallback / limit-dn *
    list limit-dn {
      tailf:info "Limit number of directory numbers per phone";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        tailf:cli-incomplete-command;
        type string {
          tailf:info "WORD;;phone type";
        }
      }
      leaf max-lines {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-76>;;number of dns";
          range "1..76";
        }
      }
    }

    // call-manager-fallback / timeouts
    container timeouts {
      tailf:info "Define timeout value for IP phone";

      // call-manager-fallback / timeouts interdigit
      leaf interdigit {
        tailf:info "Interdigit timeout in seconds";
        type uint8 {
          tailf:info "<2-120>;;seconds";
          range "2..120";
        }
      }

      // call-manager-fallback / timeouts ringing
      leaf ringing {
        tailf:info "Ringing timeout in seconds";
        type uint16 {
          tailf:info "<5-60000>;;seconds";
          range "5..60000";
        }
      }
    }

    // call-manager-fallback / max-ephones
    container max-ephones {
      tailf:info "Define max number of IP phones";
      leaf max {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<1-1500>;;Maximum phones to support";
          range "1..1500";
        }
      }
    }

    // call-manager-fallback / max-dn
    container max-dn {
      tailf:info "Maximum directory numbers supported";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf max {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<1-2500>;;Maximum single/dual/octo line  directory numbers supported";
          range "1..2500";
        }
      }
      leaf line {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum dual-line {
            tailf:info "enables dual-line dn mode";
          }
          enum octo-line {
            tailf:info "enables octo-line dn mode";
          }
        }
      }
      leaf preference {
        tailf:info "Global preference for all DNs";
        type uint8 {
          tailf:info "<0-10>;;Preference order";
          range "0..10";
        }
      }
    }

    // call-manager-fallback / transfer-pattern *
    list transfer-pattern {
      tailf:info "Define valid call transfer destinations";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key pattern;
      leaf pattern {
        type string {
          tailf:info "WORD;;digit string pattern for permitted non-local call transfers";
        }
      }
    }

    // call-manager-fallback / keepalive
    container keepalive {
      tailf:info "Define keepalive timeout period to unregister IP phones";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf seconds {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<10-65535>;;Time in seconds";
          range "10..65535";
        }
      }
      leaf auxiliary {
        tailf:info "Define auxiliary keepalive timeout period to unregister TAPI";
        type uint16 {
          tailf:info "<1-65535>;;Time in seconds";
          range "1..65535";
        }
      }
    }

    // call-manager-fallback / translate
    container translate {
      tailf:info "Translation rule";

      // call-manager-fallback / translate calling
      leaf calling {
        tailf:info "calling party number will required translate ";
        type uint32 {
          tailf:info "<1-2147483647>;;Translation rule TAG";
          range "1..2147483647";
        }
      }

      // call-manager-fallback / translate called
      leaf called {
        tailf:info "called party number will required translate ";
        type uint32 {
          tailf:info "<1-2147483647>;;Translation rule TAG";
          range "1..2147483647";
        }
      }
    }

    // call-manager-fallback / call-forward
    container call-forward {
      tailf:info "Configure parameters for call forwarding";

      // call-manager-fallback / call-forward pattern *
      list pattern {
        tailf:info "H.450.3/SIP match calling-party number forwarding pattern. This is used to enable remote party redirect forwarding with H.450.3/SIP";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key pattern;
        leaf pattern {
          type string {
            tailf:info "WORD;;A sequence of digits (including wildcards) - representing calling-party number. Use '.T' to enable remote party redirect forwarding for all VoIP calling-party numbers.";
          }
        }
      }

      // call-manager-fallback / call-forward system redirecting-expanded
      container system {
        tailf:info "Define call forward system parameters. ";
        leaf redirecting-expanded {
          tailf:info "Define call forward system parameters. This is used to enable the E164 expansion for the redirecting number.";
          type empty;
        }
      }

      // call-manager-fallback / call-forward busy
      leaf busy {
        tailf:info "forward call on busy";
        type string {
          tailf:info "WORD;;A sequence of digits - representing E.164 number";
        }
      }

      // call-manager-fallback / call-forward noan
      container noan {
        tailf:info "forward call on no-answer";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf target-number {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type string {
            tailf:info "WORD;;A sequence of digits - representing E.164 number";
          }
        }
        leaf timeout {
          tailf:info "Ringing no answer timeout duration";
          type uint16 {
            tailf:info "<3-60000>;;Ringing no answer timeout duration in seconds";
            range "3..60000";
          }
        }
      }
    }

    // call-manager-fallback / multicast moh
    container multicast {
      tailf:info "Configure ip multicast parameters";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf moh {
        tailf:info "Set IP multicast address for use with music-on-hold from flash";
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Define music-on-hold IP multicast address from flash";
        }
      }
      leaf port {
        tailf:info "Define media port for multicast moh";
        type uint16 {
          tailf:info "<2000-65535>;;Specify the RTP port: 2000 - 65535";
          range "2000..65535";
        }
      }
      leaf route {
        tailf:info "optionally define explicit IP route for MoH multicast. Default is to use the ip source-address configured";
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Define IP address route for  music-on-hold IP multicast";
        }
      }
    }

    // call-manager-fallback / time-zone
    leaf time-zone {
      tailf:info "Set timezone for IP Phones";
      type uint16 {
        tailf:info "<1-56>;;select timezone name used by IP phones (offset in minutes)";
        range "1..56";
      }
    }
  }


  /// ========================================================================
  /// dial-peer
  /// ========================================================================

  container dial-peer {
    tailf:info "Dial Map (Peer) configuration commands";

    // dial-peer cor
    container cor {
      tailf:info "Class of Restriction";

      // dial-peer cor custom
      container custom {
        tailf:info "Define custom Class of Restriction";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-dp-cor";
        presence true;

        // dial-peer cor custom / name *
        list name {
          tailf:info "name of Class of Restriction";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Name of Class of Restriction";
            }
          }
        }
      }

      // dial-peer cor list *
      list list {
        tailf:info "Define List of Class of Restriction";
        tailf:cli-mode-name "config-dp-corlist";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;name of Class of Restriction list";
          }
        }

        // dial-peer cor list * / member *
        list member {
          tailf:info "member in COR list";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Name of COR list member";
            }
          }
        }
      }
    }

    // dial-peer voice *
    list voice {
      tailf:info "Voice type";
      tailf:cli-mode-name "config-dial-peer";
      tailf:cli-incomplete-command;
      tailf:cli-sequence-commands;
      key id;
      leaf id {
        type uint32 {
          tailf:info "<1-2147483647>;;Voice dial-peer tag";
          range "1..2147483647";
        }
      }
      leaf peer {
        tailf:cli-drop-node-name;
        tailf:cli-hide-in-submode;
        type enumeration {
          enum mmoip {
            tailf:info "Multi Media Over IP";
          }
          enum pots {
            tailf:info "Telephony";
          }
          enum voatm {
            tailf:info "Voice over ATM";
          }
          enum vofr {
            tailf:info "Voice over Frame Relay";
          }
          enum voip {
            tailf:info "Voice over IP";
          }
        }
      }

      // dial-peer voice * / answer-address
      leaf answer-address {
        tailf:cli-break-sequence-commands;
        tailf:info "The Call Destination Number";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;A string of digits including wild cards";
        }
      }

      // dial-peer voice * / trunkgroup
      leaf trunkgroup {
        tailf:info "trunk groups associated with this peer";
        tailf:non-strict-leafref {
          path "../../../trunk/group/name";
        }
        type string {
          tailf:info "WORD;;trunkgroup id";
        }
      }

      // dial-peer voice * / corlist
      container corlist {
        tailf:info "set the Class of Restriction lists";

        // dial-peer voice * / corlist incoming
        leaf incoming {
          tailf:info "set the incoming Class of Restriction lists";
          type string {
            tailf:info "WORD;;incoming Class of Restriction list name";
          }
        }

        // dial-peer voice * / corlist outgoing
        leaf outgoing {
          tailf:info "set the outgoing Class of Restriction lists";
          tailf:non-strict-leafref {
            path "../../../../dial-peer/cor/list/name";
          }
          type string {
            tailf:info "WORD;;outgoing Class of Restriction list name";
          }
        }
      }

      // dial-peer voice * / description
      leaf description {
        tailf:info "Dialpeer specific description";
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE;;Up to 64 characters describing this dialpeer";
          length "1..64";
        }
      }

      // dial-peer voice * / preference
      leaf preference {
        tailf:info "Configure the preference order of this dialpeer";
        type uint8 {
          tailf:info "<0-10>;;Preference order";
          range "0..10";
        }
        default 0;
      }

      // dial-peer voice * / translation-profile
      container translation-profile {
        tailf:info "Translation profile";
        leaf incoming {
          tailf:info "Translation Profile for incoming call leg";
          tailf:non-strict-leafref {
            path "/ios:voice/translation-profile/name";
          }
          type string {
            tailf:info "WORD;;Profile name";
          }
        }
        leaf outgoing {
          tailf:info "Translation Profile for outgoing call leg";
          tailf:non-strict-leafref {
            path "/ios:voice/translation-profile/name";
          }
          type string {
            tailf:info "WORD;;Profile name";
          }
        }
      }

      // dial-peer voice * / call-block
      container call-block {
        tailf:info "Incoming Call Blocking";

        // dial-peer voice * / call-block translation-profile incoming
        container translation-profile {
          tailf:info "Configure translation profile";
          leaf incoming {
            tailf:info "Specify incoming translation profile";
            type string {
              tailf:info "WORD;;Specify the name of a translation profile";
            }
          }
        }

        // dial-peer voice * / call-block disconnect-cause incoming
        container disconnect-cause {
          tailf:info "Configure disconnect-cause";
          leaf incoming {
            tailf:info "Specify disconnect cause for incoming call";
            type enumeration {
              enum call-reject {
                tailf:info "Call Reject";
              }
              enum invalid-number {
                tailf:info "Invalid Number";
              }
              enum unassigned-number {
                tailf:info "Unassigned Number";
              }
              enum user-busy {
                tailf:info "User Busy";
              }
            }
          }
        }
      }

      // dial-peer voice * / huntstop
      leaf huntstop {
        tailf:info "Stop hunting on Dial-Peers";
        type empty;
      }

      // dial-peer voice * / max-conn
      leaf max-conn {
        tailf:info "Sets the maximum connections per peer, negation sets to unlimited";
        type uint32 {
          tailf:info "<1-2147483647>;;Maximum connections, negation sets to unlimited";
        }
      }

      // dial-peer voice * / destination
      container destination {
        tailf:info "Outbound dial-peer match config";

        // dial-peer voice * / destination e164-pattern-map
        leaf e164-pattern-map {
          tailf:info "Configure voice class to match destination e164-pattern-map";
          type uint32 {
            tailf:info "<1-10000>;;The e164-pattern-map group tag number";
            range "1..10000";
          }
        }
      }

      // dial-peer voice * / destination-pattern
      leaf destination-pattern {
        tailf:info "A full E.164 telephone number prefix";
        type string {
          tailf:info "WORD;;A sequence of digits - representing the prefix or full telephone number";
        }
      }

      // dial-peer voice * / prefix
      leaf prefix {
        tailf:info "The pattern to be dialed before the dialed num";
        type string {
          tailf:info "WORD;;A string of digits";
        }
      }

      // dial-peer voice * / modem passthrough
      container modem {
        tailf:info "Modem commands through this peer";
        container passthrough {
          tailf:info "Pass modem traffic via clear channel";
          choice passthrough-choice {
            // dial-peer voice * / no modem passthrough system
            leaf system {
              tailf:info "Use global configuration";
              tailf:cli-boolean-no;
              tailf:cli-full-command;
              type boolean;
              default true;
            }
            container nse {
              tailf:info "Use Named Signaling Events (NSE)";
              tailf:cli-compact-syntax;
              leaf payload-type {
                tailf:info "Configure NSE payload type";
                type uint32 {
                  tailf:info "<98-117>;;Payload type value";
                }
              }
              leaf codec {
                tailf:info "Codec selections for upspeed";
                type enumeration {
                  enum g711ulaw {
                    tailf:info "G.711 u Law 64000 bp";
                  }
                  enum g711alaw {
                    tailf:info "G.711 A Law 64000 bps";
                  }
                }
              }
              leaf redundancy {
                tailf:info "Use Packet Redundancy (RFC2198) for modem traffic";
                type empty;
              }
            }
          }
        }
      }

      // dial-peer voice * / session
      container session {
        tailf:info "The session [ target | protocol | transport ] for this peer";

        // dial-peer voice * / session protocol
        leaf protocol {
          tailf:info "The session protocol to be used in getting to this peer";
          type enumeration {
            enum aal2-trunk {}
            enum cisco {
              tailf:info "Cisco Session Protocol";
            }
            enum sipv2 {
              tailf:info "IETF Session Initiation Protocol";
            }
            enum smtp {}
            enum multicast {
              tailf:info "Multicast Session Protocol(voice conferencing)";
            }
          }
        }

        // dial-peer voice * / session server-group
        leaf server-group {
          tailf:info "Configure voice class server-group";
          type uint16 {
            tailf:info "<1-10000>;;The voice class server-group tag number";
            range "1..10000";
          }
        }

        // dial-peer voice * / session target
        leaf target {
          tailf:info "The session target for this peer";
          tailf:cli-multi-value;
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;A string specifying the session target";
          }
        }

        // dial-peer voice * / session transport
        container transport {
          tailf:info "The transport layer protocol used for this peer";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf protocol {
            tailf:cli-drop-node-name;
            type enumeration {
              enum system {
                tailf:info "defer to voice service voip session transport";
              }
              enum tcp {
                tailf:info "Transport Layer Protocol - TCP";
              }
              enum udp {
                tailf:info "Transport Layer Protocol - UDP";
              }
            }
            default system;
          }
          leaf tls {
            tailf:info "Transport Layer Protocol - TLS over TCP";
            when "../protocol = 'tcp'" {
              tailf:dependency "../protocol";
            }
            type empty;
          }
        }
      }

      // dial-peer voice * / numbering-type
      leaf numbering-type {
        tailf:info "The calling/called party numbering type";
        type enumeration {
          enum abbreviated {
            tailf:info "The numbering type is abbreviated";
          }
          enum international {
            tailf:info "The numbering type is international";
          }
          enum national {
            tailf:info "The numbering type is national";
          }
          enum network {
            tailf:info "The numbering type is network";
          }
          enum reserved {
            tailf:info "The numbering type is reserved";
          }
          enum subscriber {
            tailf:info "The numbering type is subscriber";
          }
          enum unknown {
            tailf:info "The numbering type is unknown";
          }
        }
      }

      // dial-peer voice * / incoming
      container incoming {
        tailf:info "Incoming called number";

        // dial-peer voice * / incoming called-number
        leaf called-number {
          tailf:info "An incoming called number pattern";
          type string {
            tailf:info "WORD;;A sequence of digits representing a phone number prefix";
          }
        }

        // dial-peer voice * voip / incoming uri
        container uri {
          tailf:info "Incoming URI class";

          // dial-peer voice * voip / incoming uri via
          leaf via {
            tailf:info "Match incoming topmost Via header";
            tailf:non-strict-leafref {
              path "/ios:voice/class/uri/name";
            }
            type string {
              tailf:info "WORD;;Voice URI Class tag";
            }
          }

          // dial-peer voice * voip / incoming uri from
          leaf from {
            tailf:info "Match incoming To header";
            tailf:non-strict-leafref {
              path "/ios:voice/class/uri/name";
            }
            type string {
              tailf:info "WORD;;Voice URI Class tag";
            }
          }
        }
      }

      // dial-peer voice * / voice-class
      container voice-class {
        tailf:info "Set Dial-peer voice class control parameters";

        // dial-peer voice * / voice-class codec
        container codec {
          tailf:info "Set Global Codec parameters";
          leaf id {
            tailf:cli-drop-node-name;
            tailf:cli-no-value-on-delete;
            tailf:non-strict-leafref {
              path "../../../../../voice/class/codec/id";
            }
            type uint16 {
              tailf:info "<1-10000>;;The codec group tag number";
              range "1..10000";
            }
          }
        }

        // dial-peer voice * / voice-class sip
        container sip {
          tailf:info "Set SIP parameters";

          // dial-peer voice * / no voice-class sip outbound-proxy
          // dial-peer voice * / voice-class sip outbound-proxy proxy-address
          choice proxy-address-choice {
            leaf outbound-proxy {
              tailf:info "Configure no voice-class outbound-proxy";
              tailf:cli-boolean-no;
              tailf:cli-full-command;
              ios:boolean-delete-with-default;
              type boolean;
              default true;
            }
            container outbound-proxy-conf {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-no;
              tailf:cli-incomplete-command;
              container outbound-proxy {
                tailf:info "Configure an Outbound Proxy Server";
                leaf proxy-address {
                  tailf:cli-drop-node-name;
                  ios:delete-with-default;
                  type string {
                    tailf:info "ipv4:x.x.x.x or ipv6:[X:X:X:X::X]";
                  }
                }
              }
            }
          }

          // dial-peer voice * / voice-class sip options-keepalive
          container options-keepalive {
            tailf:info "send out-of-dialogue OPTIONS PING to configured proxy/session-target";
            presence true;
          }

          // dial-peer voice * / voice-class sip bind
          container bind {
            tailf:info "SIP bind command";

            // dial-peer voice * / voice-class sip bind control source-interface
            container control {
              tailf:info "bind only SIP control packets";
              container source-interface {
                tailf:info "Specify interface for source address of SIP packets";
                uses interface-name-grouping;
              }
            }

            // dial-peer voice * / voice-class sip bind media source-interface
            container media {
              tailf:info "bind only SIP media packets";
              container source-interface {
                tailf:info "Specify interface for source address of SIP packets";
                uses interface-name-grouping;
              }
            }
          }
        }
      }

      // dial-peer voice * / dtmf-relay *
      leaf-list dtmf-relay {
        tailf:info "Transport DTMF digits across IP link. Enter DTMF Relay options in order of preference.";
        tailf:cli-flat-list-syntax;
        tailf:cli-no-value-on-delete;
        ordered-by user;
        type enumeration {
          enum cisco-rtp {
            tailf:info "Cisco Proprietary RTP";
          }
          enum h245-alphanumeric {
            tailf:info "DTMF Relay via H245 Alphanumeric IE";
          }
          enum h245-signal {
            tailf:info "DTMF Relay via H245 Signal IE";
          }
          enum rtp-nte {
            tailf:info "RTP Named Telephone Event RFC 2833";
          }
          enum sip-kpml {
            tailf:info "DTMF Relay via KPML over SIP SUBCRIBE/NOTIFY";
          }
          enum digit-drop {
            tailf:info "Digits to be passed out-of-band and in-band digits dropped";
          }
        }
      }

      // dial-peer voice * / direct-inward-dial
      leaf direct-inward-dial {
        tailf:info "Use Called Number as final call destination";
        type empty;
      }

      // dial-peer voice * / forward-digits
      leaf forward-digits {
        tailf:info "Configure the destination digits forward of this dialpeer";
        type union {
          type uint8 {
            tailf:info "<0-32>;;number of right-justified dialed digits to be forwarded";
            range "0..32";
          }
          type enumeration {
            enum all {
              tailf:info "forward all destination digits";
            }
            enum extra {
              tailf:info "extra dialed digits to be forwarded";
            }
          }
        }
      }

      // dial-peer voice * pots / port
      leaf port {
        tailf:info "Voice port associated with this peer";
        type string {
          tailf:info "WORD;;voice port";
        }
      }

      // dial-peer voice * / no sip-register
      leaf sip-register {
        tailf:info "Enable SIP registrations - enabled by default";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // dial-peer voice * / codec
      container codec {
        tailf:info "The codec rate to be attempted in getting to this peer";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf name {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;Codec name";
          }
        }
        leaf bytes {
          tailf:info "Specify number of voice data bytes per frame";
          tailf:cli-break-sequence-commands;
          type uint32;
        }
        leaf mode {
          tailf:info "Specify the value of the mode";
          type uint32 {
            tailf:info "20 = 15.2 kbps, 30 = 13.33 kbps";
          }
        }
      }

      // dial-peer voice * / fax protocol
      container fax {
        tailf:info "Configure fax";
        container protocol {
          tailf:info "The fax protocol to be attempted in getting to this peer";
          choice protocol-option {
            leaf none {
              tailf:info "No FAX protocol";
              type empty;
            }
            leaf cisco {
              tailf:info "Use Cisco proprietary protocol";
              type empty;
            }
            leaf pass-through {
              tailf:info "Use an audio codec for fax transport";
              type enumeration {
                enum g711ulaw {
                  tailf:info "G.711 u Law 64000 bps (for T1)";
                }
                enum g711alaw {
                  tailf:info "G.711 A Law 64000 bps (for E1)";
                }
              }
            }
          }
        }
      }

      // dial-peer voice * / ip qos dscp *
      container ip {
        tailf:info "Set ip packet options";
        container qos {
          tailf:info "Set ip QoS Parameters";
          list dscp {
            tailf:info "Specify ip DSCP";
            tailf:cli-compact-syntax;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key name;
            leaf name {
              // number | set-af | set-cs | default | ef
              type string {
                tailf:info "WORD;;voice set";
              }
            }
            choice dscp-choice {
              leaf media {
                tailf:info "Apply DSCP to media payload packets";
                type empty;
              }
              leaf signaling {
                tailf:info "Apply DSCP to signaling packets";
                type empty;
              }
              leaf video {
                tailf:info "Apply DSCP to video packets";
                type enumeration {
                  enum rsvp-none {
                    tailf:info "Use this DSCP value if RSVP is not configured";
                  }
                  enum rsvp-pass {
                    tailf:info "Use this DSCP value if RSVP reservation is successful";
                  }
                  enum rsvp-fail {
                    tailf:info "Use this DSCP value if RSVP reservation fails";
                  }
                }
              }
            }
          }
        }
      }

      // dial-peer voice * / no vad
      leaf vad {
        tailf:info "Use VoiceActivityDetection as necessary option";
        tailf:cli-full-command;
        tailf:cli-boolean-no;
        type boolean;
        default true;
      }
    }

    // no dial-peer outbound status-check pots
    container outbound {
      tailf:info "Define the outbound options";
      container status-check {
        tailf:info "Enable or disable status checking";
        leaf pots {
          tailf:info "Telephony";
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }
      }
    }
  }


  /// ========================================================================
  /// config-register
  /// ========================================================================

  leaf config-register {
    tailf:info "Define the configuration register";
    type string {
      tailf:info "<0x0-0xFFFF>;;Config register number";
      pattern "[0-9xXa-fA-F].*";
    }
  }


  /// ========================================================================
  /// network-clock-participate
  /// ========================================================================

  container network-clock-participate {
    tailf:info "Participate in Network Clocking";

    // no network-clock-participate slot *
    container slot {
      tailf:info "Network Module Slot";
      list slot-disabled {
        tailf:info "Use if want to configure 'no network-clock-participate slot *'";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key slot;
        leaf slot {
          tailf:cli-suppress-range;
          type uint8 {
            tailf:info "<1-1>;;Slot Number";
          }
        }
      }
    }

    // network-clock-participate wic *
    // no network-clock-participate wic *
    container wic {
      tailf:info "WIC Module";
      list wic-enabled {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key slot;
        leaf slot {
          tailf:cli-suppress-range;
          type uint8 {
            tailf:info "<0-3>;;Slot Number (physical)";
            range "0..3";
          }
        }
      }
      list wic-disabled {
        tailf:info "Use if want to configure 'no network-clock-participate wic *'";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key slot;
        leaf slot {
          tailf:cli-suppress-range;
          type uint8 {
            tailf:info "<0-3>;;Slot Number (physical)";
            range "0..3";
          }
        }
      }
    }

    // network-clock-participate T1 *
    list T1 {
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        tailf:cli-suppress-range;
        type string {
          pattern '[0-9]+.*';
        }
      }
    }
  }


  /// ========================================================================
  /// service-routing
  /// ========================================================================

  container service-routing {
    tailf:info "Configure service-routing";

    // no service-routing capabilities-manager
    leaf capabilities-manager {
      tailf:info "Service-Routing Capabilities Manager configuration";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
      default true;
    }
  }


  /// ========================================================================
  /// mgcp
  /// ========================================================================

  container mgcp {
    tailf:info "Enable Media Gateway Control Protocol";

    // mgcp fax t38 ecm
    container fax {
      tailf:info "Configure MGCP Fax Parameters";
      container t38 {
        tailf:info "Configure MGCP Fax T.38 Parameters";
        leaf ecm {
          tailf:info "Enable Error Correction Mode (ECM)";
          tailf:cli-full-command;
          type empty;
        }
      }
    }

    // mgcp behavior *
    list behavior {
      tailf:info "Set MGCP message behavior";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key category;
      leaf category {
        type string {
          tailf:info "WORD;;Set the category for this behavior";
        }
      }
      leaf version {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "WORD;;Set the version for this behavior category";
        }
      }
    }

    // mgcp profile *
    list profile {
      tailf:info "MGCP profile configuration mode";
      tailf:cli-mode-name "config-mgcp-profile";
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        type union {
          type enumeration {
            enum "default" {
              tailf:info "Configure MGCP default profile";
            }
          }
          type string {
            tailf:info "Enter the name(is limited to 32 characters) of the profile";
            length "0..32";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// sccp
  /// ========================================================================

  container sccp {
    tailf:info "Enable Skinny Client Control Protocol";
    tailf:cli-incomplete-command;
    tailf:cli-incomplete-no;

    // sccp local
    container local {
      tailf:info "Specify the local gateway related parameters values";
      tailf:cli-diff-delete-after "../../sccp-enable/sccp";
      uses interface-name-grouping;
    }

    // sccp ccm
    container ccm {
      tailf:info "Specify the Call Manager related parameters value";
      tailf:cli-diff-delete-after "../../sccp-enable/sccp";

      // sccp ccm *
      list list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-remove-before-change;
        key address;
        leaf address {
          type inet:host {
            tailf:info "Hostname or A.B.C.D or X:X:X:X::X;;Specify the IP address of the Call Manager";
          }
        }
        leaf identifier {
          tailf:info "Specify the Call Manager identifier";
          type uint16 {
            tailf:info "<1-65535>;;Select the Call Manager identifier number";
            range "1..65535";
          }
        }
        leaf version {
          tailf:info "Specify the supported Call Manager version";
          type string {
            tailf:info "WORD;;Version string, e.g. 6.0";
            pattern '[0-9]+.*';
          }
        }
      }

      // sccp ccm group *
      list group {
        tailf:info "Specify the Call Managers group";
        tailf:cli-mode-name "config-sccp-ccm";
        tailf:cli-diff-dependency "../list";
        key id;
        leaf id {
          type uint16 {
            tailf:info "<1-65535>;;Select the Call Manager group identifier";
            range "1..65535";
          }
        }

        // sccp ccm group * / associate
        container associate {
          tailf:info "Associate various entities or elements to CCM group";

          // sccp ccm group * / associate ccm * priority
          list ccm {
            tailf:info "Select a CCM to associate to this CCM group";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key id;
            leaf id {
              type uint16 {
                tailf:info "<1-65535>;;Select the CCM identifier that needs to be associated";
                range "1..65535";
              }
            }
            leaf priority {
              tailf:info "Specify the priority level for the associating CCM";
              type uint8 {
                tailf:info "<1-4>;;Specify the priority level";
                range "1..4";
              }
            }
          }

          // sccp ccm group * / associate profile * register
          list profile {
            tailf:info "Select a DSPFARM profile to associate to this CCM group";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key id;
            leaf id {
              type uint16 {
                tailf:info "<1-65535>;;Select the DSPFARM profile identifier that needs to be associated";
                range "1..65535";
              }
            }
            leaf register {
              tailf:info "Configure CCM registration related parameters";
              type string {
                tailf:info "WORD;;Specify the device name (max 15 characters) to register with the CCM";
              }
            }
          }
        }
      }
    }
  }

  // sccp
  container sccp-enable {
    tailf:cli-drop-node-name;
    leaf sccp {
      tailf:info "Enable Skinny Client Control Protocol";
      type empty;
    }
  }


  /// ========================================================================
  /// sip-ua
  /// ========================================================================

  container sip-ua {
    tailf:info "SIP User Agent (UA)";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-sip-ua";
    presence true;

    // sip-ua / no remote-party-id
    leaf remote-party-id {
      tailf:info "Enable Remote-Party-ID support in SIP User Agent calls";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
      default true;
    }

    // sip-ua / retry
    container retry {
      tailf:info "Change default retries for each SIP Method";

      // sip-ua / retry invite
      leaf invite {
        tailf:info "INVITE retry value";
        type uint8 {
          tailf:info "<1-10>;;Number of retries (1-10)";
          range "1..10";
        }
      }
    }

    // sip-ua / timers
    container timers {
      tailf:info "SIP Signaling Timers Configuration";

      // sip-ua / timers connect
      leaf connect {
        tailf:info "Time to wait for confirmation a session connected";
        type uint16 {
          tailf:info "<100-1000>;;connect timer value in milliseconds";
          range "100..1000";
        }
      }
    }

    // sip-ua / mwi-server
    container mwi-server {
      tailf:info "Configure a mwi Server";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      leaf address {
        tailf:cli-drop-node-name;
        tailf:cli-remove-before-change;
        type string {
          tailf:info "WORD;;Specify the Server address";
        }
      }
      leaf expires {
        tailf:info "Set expires timer";
        tailf:cli-break-sequence-commands;
        type uint32 {
          tailf:info "<1-999999>;;Number of Seconds";
          range "1..999999";
        }
      }
      leaf port {
        tailf:info "Define tcp port for MWI Server";
        type uint16 {
          tailf:info "<2000-9999>;;Specify the port: 2000 - 9999";
          range "2000..9999";
        }
      }
      leaf transport {
        tailf:info "Define transport to SIP MWI Server";
        type enumeration {
          enum tcp {
                    tailf:info "Transport Layer Protocol - TCP";
          }
          enum udp {
                    tailf:info "Transport Layer Protocol - UDP";
          }
        }
      }
      leaf unsolicited {
        tailf:info "unsolicited MWI Server";
        type empty;
      }
    }

    // sip-ua / sip-server
    leaf sip-server {
      tailf:info "Configure a SIP Server Interface";
      type string {
        tailf:info "WORD;;sip-server ipv4:<addr> | ipv6:<addr> | dns:host.domain";
      }
    }

    // sip-ua / presence enable
    container presence {
      tailf:info "Enable/Disable Presence support";
      leaf enable {
        tailf:info "Enable Presence support";
        type empty;
      }
    }

    // sip-ua / transport
    container transport {
      tailf:info "Enable SIP UA transport for TCP/UDP";

      // sip-ua / no transport udp
      leaf udp {
        tailf:info "Enable SIP User Agent in UDP Mode";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // sip-ua / no transport tcp
      leaf tcp {
        tailf:info "Enable SIP User Agent in TCP Mode";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // sip-ua / no transport tcp tls
      container tcp-tls {
        tailf:cli-drop-node-name;
        container tcp {
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          leaf tls {
            tailf:info "Enable SIP User Agent in TLS over TCP mode (Default: All TLS versions with fallback)";
            tailf:cli-boolean-no;
            type boolean;
            default true;
          }
        }
      }
    }

    // sip-ua / crypto signaling
    container crypto {
      tailf:info "sip-ua crypto commands";
      container signaling {
        tailf:info "signaling";

        // sip-ua / crypto signaling remote-addr *
        list remote-addr {
          tailf:info "Associate an IP network to a trustpoint";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          key "address mask";
          leaf address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Enter the IP address";
            }
          }
          leaf mask {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Enter the mask";
            }
          }
          leaf trustpoint {
            tailf:info "Associate a trustpoint";
            type string {
              tailf:info "WORD;;Specify the trustpoint label";
            }
          }
          leaf cipher {
            tailf:cli-drop-node-name;
            type enumeration {
              enum ecdsa-cipher {
                tailf:info "Use ECDSA Ciphers";
              }
              enum strict-cipher {
                tailf:info "Use only ciphers mandated by SIP standards";
              }
            }
          }
        }

        // sip-ua / crypto signaling default
        container default {
          tailf:info "Configure the default trustpoint";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf trustpoint {
            tailf:info "Associate a trustpoint";
            type string {
              tailf:info "WORD;;Specify the trustpoint label";
            }
          }
          leaf cipher {
            tailf:cli-drop-node-name;
            type enumeration {
              enum ecdsa-cipher {
                tailf:info "Use ECDSA Ciphers";
              }
              enum strict-cipher {
                tailf:info "Use only ciphers mandated by SIP standards";
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// gatekeeper
  /// ========================================================================

  container gatekeeper {
    tailf:info "Enter gatekeeper configuration mode";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-gk";

    // gatekeeper shutdown
    leaf shutdown {
      tailf:info "Shutdown Gatekeeper";
      type empty;
    }
  }

  /// ========================================================================
  /// telephony-service
  /// ========================================================================

  container telephony-service {
    tailf:info "Configure Cisco Unified Communications Manager Express";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-telephony";
    presence true;
    tailf:cli-diff-delete-before "../call-manager-fallback" {
      tailf:cli-when-target-set;
    }

    // telephony-service / mode esrst
    container mode {
      tailf:info "Mode configuration commands";
      leaf esrst {
        tailf:info "configure ESRST mode";
        type empty;
      }
    }

    // telephony-service / mode srst
    container srst {
      tailf:info "srst commands";

      // telephony-service / srst mode auto-provision
      container mode {
        tailf:info "srst mode";
        leaf auto-provision {
          tailf:info "auto-provision selections";
          type enumeration {
            enum none {
              tailf:info "SRST mode ON (include NONE of the learned DNs/ephones into show running)";
            }
            enum dn {
              tailf:info "SRST mode ON (include only learned DNs into show running)";
            }
            enum all {
              tailf:info "SRST mode ON (include both learned DNs and phones into show running)";
            }
          }
        }
      }

      // telephony-service / srst ephone
      container ephone {
        tailf:info "ephone";

        // telephony-service / srst ephone template
        leaf template {
          tailf:info "Define srst ephone template tag";
          type uint8 {
            tailf:info "<1-20>;;Template tag";
          }
        }
      }

      // telephony-service / srst dn
      container dn {
        tailf:info "dn";

        // telephony-service / srst dn template
        leaf template {
          tailf:info "Define srst dn template tag";
          type uint8 {
            tailf:info "<1-15>;;Template tag";
          }
        }

        // telephony-service / srst dn line-mode
        leaf line-mode {
          tailf:info "Define srst dn line-mode";
          type enumeration {
            enum single {
              tailf:info "single line-mode for the srst learned DNs";
            }
            enum octo {
              tailf:info "octo line-mode for the srst learned DNs";
            }
            enum dual {
              tailf:info "dual line-mode for the srst learned DNs";
            }
            enum dual-octo {
              tailf:info "dual-octo line-mode for the srst learned DNs";
            }
          }
        }
      }
    }

    // telephony-service / sdspfarm
    container sdspfarm {
      tailf:info "Define dspfarm parameters";
      // telephony-service / sdspfarm conference
      container conference {
        tailf:info "Define conference options";
        // telephony-service / sdspfarm conference mute-on
        container mute {
          tailf:cli-drop-node-name;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf mute-on {
            tailf:info "Mute on keyword";
            tailf:cli-incomplete-command;
            tailf:cli-no-value-on-delete;
            type string {
              tailf:info "WORD;;Mute on, max 3 digits";
            }
          }
          leaf mute-off {
            tailf:info "Mute off keyword";
            tailf:cli-no-name-on-delete;
            tailf:cli-no-value-on-delete;
            type string {
              tailf:info "WORD;;Mute on, max 3 digits";
            }
          }
        }
      }

      // telephony-service / sdspfarm units
      leaf units {
        tailf:info "Define maximum number of dspfarm units";
        tailf:cli-no-value-on-delete;
        type uint8 {
          tailf:info "<1-10>;;number of units";
        }
      }

      // telephony-service / sdspfarm tag *
      list tag {
        tailf:info "DSPFARM tag";
        tailf:cli-suppress-mode;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        tailf:cli-diff-delete-before "../units";
        key value;
        leaf value {
          type uint8 {
            tailf:info "<1-10>;;tag value";
          }
        }
        leaf device-name {
          tailf:cli-drop-node-name;
          tailf:cli-no-value-on-delete;
          type string {
            tailf:info "WORD;;A device name";
          }
        }
      }
    }

    // telephony-service / conference
    container conference {
      tailf:info "Configure conference parameters";
      leaf hardware {
        tailf:info "Hardware conference type";
        type empty;
      }
    }

    // telephony-service / no auto-reg-ephone
    leaf auto-reg-ephone {
      tailf:info "Enable Ephone Auto-Registration";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
      default true;
    }

    // telephony-service / authentication
    container authentication {
      tailf:info "Config CME authentication server";
      // telephony-service / authentication credential *
      list credential {
        tailf:info "Specify authorized credential";
        tailf:cli-suppress-mode;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key user-name;
        leaf user-name {
          type string {
            tailf:info "WORD;;User name maximum 15 charecters";
          }
        }
        leaf password {
          tailf:cli-drop-node-name;
          tailf:cli-no-value-on-delete;
          ios:password-dequote-output "credential (?:\\S+) (\\S+)";
          type NEDCOM_SECRET_TYPE {
            tailf:info "WORD;;Password name maximum 15 charecters";
          }
        }
      }
    }

    // telephony-service / em
    container em {
      tailf:info "Config Extension Mobility";
      leaf logout {
        tailf:info "Define EM auto logout time of day";
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-full-command;
        tailf:cli-no-value-on-delete;
        type string {
          tailf:info "hh:mm;;Time in 24hr format";
        }
      }
    }

    // telephony-service / max-ephones
    leaf max-ephones {
      tailf:info "Define max number of IP phones";
      tailf:cli-no-value-on-delete;
      type uint16 {
        tailf:info "<1-uint16>;;Maximum phones to support";
      }
    }

    // telephony-service / max-dn
    container max-dn {
      tailf:info "Maximum directory numbers supported";
      leaf number-of-directories {
        tailf:cli-drop-node-name;
        tailf:cli-no-value-on-delete;
        type uint16 {
          tailf:info "<1-500>;;Maximum directory numbers supported";
        }
      }
    }

    // telephony-service / ip
    container ip {
      tailf:info "Set IP options for Telephony-Service/Fallback";

      // telephony-service / ip source-address
      container source-address {
        tailf:info "Define IP address and port";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf address {
          tailf:cli-drop-node-name;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Define IP source address";
          }
        }
        leaf port {
          tailf:info "Define tcp port for Telephony Service/CM FALLBACK";
          type uint16 {
            tailf:info "<2000-9999>;;Specify the port: 2000 - 9999";
            range "2000..9999";
          }
        }
      }
    }

    // telephony-service / calling-number
    container calling-number {
      tailf:info "Replace calling number with local for hairpin";
      // telephony-service / calling-number initiator
      leaf initiator {
        tailf:info "initiator number as calling number";
        type empty;
      }
    }

    // telephony-service / service
    container service {
      tailf:info "Service configuration in ITS";

      // telephony-service / service phone *
      list phone {
        tailf:info "set parameters under <vendorConfig> section in IP phone SEP*.cnf.xml "+
          "configuration files. Invoke 'create cnf-file' command to update "+
          "phone configuration files.";
        key parameter-name;
        tailf:cli-suppress-mode;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        leaf parameter-name {
          type string {
            tailf:info "WORD;;enter the phone xml file parameter NAME without <> brackets";
          }
        }
        leaf parameter-text {
          tailf:cli-drop-node-name;
          type string {
            tailf:info " WORD;;enter the phone xml file parameter text for the previously entered parameter name";
          }
        }
      }
    }

    // telephony-service / system
    container system {
      tailf:info "Define system message";

      // telephony-service / system message
      leaf message {
        tailf:info "Define system message";
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-full-command;
        tailf:cli-no-value-on-delete;
        type string {
          tailf:info "LINE;;system message string";
        }
      }
    }

    // telephony-service / url
    container url {
      tailf:info "Define Ephone URL's";

      // telephony-service / url directories
      leaf directories {
        tailf:info "directories url";
        tailf:cli-no-value-on-delete;
        type string {
          tailf:info "WORD;;A string URL";
        }
      }

      // telephony-service / url services
      container services {
        tailf:info "services url";
        leaf url {
          tailf:cli-drop-node-name;
          tailf:cli-no-value-on-delete;
          type string {
            tailf:info "WORD;;A string URL";
          }
        }
      }

      // telephony-service / url authentication
      container authentication {
        tailf:info "authentication url";
        leaf url {
          tailf:cli-drop-node-name;
          tailf:cli-no-value-on-delete;
          type string {
            tailf:info "WORD;;A string URL";
          }
        }
      }
    }

    // telephony-service / cnf-file
    container cnf-file {
      tailf:info "Ephone CNF file config options";

      // telephony-service / cnf-file location
      container location {
        tailf:info "CNF file storage location";

        // telephony-service / cnf-file location flash:
        leaf flash {
          tailf:info "Store CNF files to flash:";
          tailf:alt-name "flash:";
          type empty;
        }
      }
    }

    // telephony-service / load *
    list load {
      tailf:info "Select the firmware load file";
      tailf:cli-suppress-mode;
      tailf:cli-compact-syntax;
      tailf:cli-incomplete-command;
      key ip-phone-module;
      leaf ip-phone-module {
        type string {
          tailf:info "WORD;;Firmware load file";
        }
      }
      leaf firmware-filename {
        tailf:cli-drop-node-name;
        tailf:cli-no-value-on-delete;
        type string {
          tailf:info "firmware filename with extension for automatic tftpbinding creation "+
            "or firmware filename without extension if user wants to create manual tftp bindings";
        }
      }
    }

    // telephony-service / time-zone
    leaf time-zone {
      tailf:info "Set timezone for IP Phones";
      tailf:cli-no-value-on-delete;
      type uint8 {
        tailf:info "<1-56>;;select timezone name used by IP phones (offset in minutes)";
      }
    }

    // telephony-service / voicemail
    leaf voicemail {
      tailf:info "Set the voicemail access number called when the MESSAGES IP phone button is pressed";
      tailf:cli-no-value-on-delete;
      type string {
        tailf:info "WORD;;voicemail access number";
      }
    }

    // telephony-service / max-conferences
    container max-conferences {
      tailf:info "Define max number of 3 party G.711 conferences";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf no-of-conferences {
        tailf:cli-drop-node-name;
        tailf:cli-no-value-on-delete;
        type uint8 {
          tailf:info "<1-64>;;Maximum conferences to support";
          range "1..64";
        }
      }
      leaf gain {
        tailf:info "Define conference mixer gain as 6dB, 3db, 0db or -6dB (default)";
        tailf:cli-no-name-on-delete;
        tailf:cli-no-value-on-delete;
        type int8 {
          tailf:info "<-6 - 6>  conference mixer gain 6, 3, 0 or -6";
          range "-6..6";
        }
      }
    }

    // telephony-service / call-park
    container call-park {
      tailf:info "Configure parameters for call park";

      // telephony-service / call-park system
      container system {
        tailf:info "This is used to configure system parameters for call park/pickup feature.";

        // telephony-service / call-park system application
        leaf application {
          tailf:info "Enable call park for both sccp and sip lines.";
          type empty;
        }
      }
    }

    // telephony-service / call-forward
    container call-forward {
      tailf:info "Configure parameters for call forwarding";

      // telephony-service / call-forward pattern *
      leaf-list pattern {
        tailf:info "H.450.3/SIP match calling-party number forwarding pattern.";
        tailf:cli-list-syntax;
        type string {
          tailf:info "WORD;;A sequence of digits (including wildcards)";
        }
      }
    }

    // telephony-service / moh
    leaf moh {
      tailf:info "Define music-on-hold filename";
      tailf:cli-no-value-on-delete;
      type string {
        tailf:info "WORD;;music-on-hold filename containing G.711 A-law or u-law 8KHz encoded audio file";
      }
    }

    // telephony-service / web
    container web {
      tailf:info "define username for admin user";

      // telephony-service / web admin
      container admin {
        tailf:info "define username for admin user";
        // telephony-service / web admin system
        container system {
          tailf:info "system admin";
          tailf:cli-compact-syntax;
          leaf name {
            tailf:info "admin username";
            tailf:cli-no-name-on-delete;
            tailf:cli-no-value-on-delete;
            type string {
              tailf:info "WORD ;;username for admin";
            }
          }
          leaf password {
            tailf:info "admin password";
            tailf:cli-no-name-on-delete;
            tailf:cli-no-value-on-delete;
            ios:password-dequote-output "password (\\S+)";
            type NEDCOM_SECRET_TYPE {
              tailf:info "WORD;;password for admin";
            }
          }
        }
      }
    }

    // telephony-service / dn-webedit
    leaf dn-webedit {
      tailf:info "enable Edit DN through Web";
      type empty;
    }

    // telephony-service / time-webedit
    leaf time-webedit {
      tailf:info "enable Edit Time through Web";
      type empty;
    }

    // telephony-service / transfer-system
    container transfer-system {
      tailf:info "Define call transfer system: blind/consult and local/end-to-end";

      // telephony-service / transfer-system full-consult
      container full-consult {
        tailf:info "Perform H.450.2/SIP call transfers with consultation using second phone line";
        presence true;
      }
    }

    // telephony-service / transfer-pattern *
    list transfer-pattern {
      tailf:info "Define valid call transfer destinations";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key pattern;
      leaf pattern {
        type string {
          tailf:info "WORD;;digit string pattern for permitted non-local call transfers";
        }
      }
    }

    // telephony-service / secondary-dialtone
    leaf secondary-dialtone {
      tailf:info "configure the secondary dial tone";
      tailf:cli-no-value-on-delete;
      type string {
        tailf:info "WORD;;dial digit string";
      }
    }

    // telephony-service / after-hours
    container after-hours {
      tailf:info "define after-hours patterns, date, etc";

      // telephony-service / after-hours block
      container block {
        tailf:info "define after-hours block pattern";
        // telephony-service / after-hours block pattern *
        list pattern {
          tailf:info "block pattern";
          tailf:cli-suppress-mode;
          tailf:cli-compact-syntax;
          tailf:cli-incomplete-command;
          key index;
          leaf index {
            type uint8 {
              tailf:info "<1-100>;;index of patterns";
            }
          }
          leaf digits-string {
            tailf:cli-drop-node-name;
            tailf:cli-no-value-on-delete;
            type string {
              tailf:info "WORD;;digits string for after hour block pattern";
            }
          }
          leaf twenty-four-seven {
            tailf:info "block pattern works for 7 * 24";
            tailf:alt-name "7-24";
            tailf:cli-no-name-on-delete;
            type empty;
          }
        }
      }
    }

    // telephony-service / night-service
    container night-service {
      tailf:info "define night-service options";

      // telephony-service / night-service code
      leaf code {
        tailf:info "define night-service code";
        tailf:cli-no-value-on-delete;
        type string {
          tailf:info "WORD;;A sequence of digits (max 16 chars) starting with a '*'";
        }
      }

      // telephony-service / night-service everyday
      container everyday {
        tailf:info "define everyday";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf time-to-start {
          tailf:cli-drop-node-name;
          tailf:cli-no-value-on-delete;
          type string {
            tailf:info "Time to start (hh:mm)";
          }
        }
        leaf time-to-stop {
          tailf:cli-drop-node-name;
          tailf:cli-no-value-on-delete;
          type string {
            tailf:info "Time to stop (hh:mm)";
          }
        }
      }
    }

    // telephony-service / fac
    container fac {
      tailf:info "Define Feature Access Code";

      // telephony-service / fac standard
      leaf standard {
        tailf:info "Select standard feature access code";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// ephone-dn-template
  /// ========================================================================

  // ephone-dn-template *
  list ephone-dn-template {
    tailf:info "Define ephone-dn-template tag";
    tailf:cli-mode-name "config-ephone-dn-template";
    tailf:cli-diff-dependency "../telephony-service";
    key tag;
    leaf tag {
      type uint8 {
        tailf:info "<1-15>;;ephone-dn-template tag";
      }
    }
    uses ephone-dn-grouping;
  }


  /// ========================================================================
  /// ephone-template
  /// ========================================================================

  // ephone-template *
  list ephone-template {
    tailf:info "Define ephone-template tag";
    tailf:cli-mode-name "config-ephone-template";
    tailf:cli-diff-dependency "../telephony-service";
    key tag;
    leaf tag {
      type uint8 {
        tailf:info "<1-20>;;ephone-template tag";
      }
    }

    uses ephone-grouping;

    // ephone-template * / softkeys
    container softkeys {
      tailf:info "define softkeys per state";

      // ephone-template * / softkeys hold *
      leaf-list hold {
        tailf:info "Softkey order for HOLD state";
        tailf:cli-flat-list-syntax;
        tailf:cli-no-value-on-delete;
        ordered-by user;
        type enumeration {
          enum Newcall {
            tailf:info "New call";
          }
          enum Join {
            tailf:info "Join established call to conference";
          }
          enum Select {
            tailf:info "Select call to join in conference";
          }
          enum Resume {
            tailf:info "Resume";
          }
        }
      }

      // ephone-template * / softkeys idle *
      leaf-list idle {
        tailf:info "Softkey order for IDLE state";
        tailf:cli-flat-list-syntax;
        tailf:cli-no-value-on-delete;
        ordered-by user;
        type enumeration {
          enum Cfwdall {
            tailf:info "Call forward all";
          }
          enum ConfList {
            tailf:info "List all participants in conference";
          }
          enum Dnd {
            tailf:info "Do not Disturb";
          }
          enum Gpickup {
            tailf:info "Group Call Pick Up";
          }
          enum HLog {
            tailf:info "HLog";
          }
          enum Join {
            tailf:info "Join established call to conferenc";
          }
          enum Login {
            tailf:info "Login";
          }
          enum Mobility {
            tailf:info "Mobility SNR";
          }
          enum Newcall {
            tailf:info "New call";
          }
          enum Pickup {
            tailf:info "Call Pick Up";
          }
          enum Redial {
            tailf:info "Redial";
          }
          enum RmLstC {
            tailf:info "Remove last conference participant";
          }
        }
      }

      // ephone-template * / softkeys seized *
      leaf-list seized {
        tailf:info "Softkey order for seized state";
        tailf:cli-flat-list-syntax;
        tailf:cli-no-value-on-delete;
        ordered-by user;
        type enumeration {
          enum CWOff {
            tailf:info "Cancel Call Waiting";
          }
          enum Callback {
            tailf:info "Call back";
          }
          enum Cfwdall {
            tailf:info "Call forward all";
          }
          enum Endcall {
            tailf:info "End call";
          }
          enum Gpickup {
            tailf:info "Group Call Pick Up";
          }
          enum HLog {
            tailf:info "HLog";
          }
          enum Meetme {
            tailf:info "MeetMe Conference";
          }
          enum Pickup {
            tailf:info "Call Pick Up";
          }
          enum Redial {
            tailf:info "Redial";
          }
        }
      }

      // ephone-template * / softkeys alerting *
      leaf-list alerting {
        tailf:info "Softkey order for alerting (ring out) state";
        tailf:cli-flat-list-syntax;
        tailf:cli-no-value-on-delete;
        ordered-by user;
        type enumeration {
          enum Acct {
            tailf:info "Account Code";
          }
          enum Callback {
            tailf:info "Call back";
          }
          enum Endcall {
            tailf:info "End call";
          }
        }
      }

      // ephone-template * / softkeys connected *
      leaf-list connected {
        tailf:info "Softkey order for connected state";
        tailf:cli-flat-list-syntax;
        tailf:cli-no-value-on-delete;
        ordered-by user;
        type enumeration {
          enum Acct {
            tailf:info "Account Code";
          }
          enum ConfList {
            tailf:info "List all participants in conference";
          }
          enum Confrn {
            tailf:info "Conference";
          }
          enum Endcall {
            tailf:info "End call";
          }
          enum Flash {
            tailf:info "Hook Flash";
          }
          enum HLog {
            tailf:info "HLog";
          }
          enum Hold {
            tailf:info "Hold";
          }
          enum Join {
            tailf:info "Join established call to conference";
          }
          enum LiveRcd {
            tailf:info "Enable live recording on the current cal";
          }
          enum Mobility {
            tailf:info "Mobility SNR";
          }
          enum Park {
            tailf:info "Call Park";
          }
          enum RmLstC {
            tailf:info "Remove last conference participant";
          }
          enum Select {
            tailf:info "Select call to join in conference";
          }
          enum TrnsfVM {
            tailf:info "Select call to transfer to voice mail";
          }
          enum Trnsfer {
            tailf:info "Call Transfer";
          }
        }
      }

      // ephone-template * / softkeys ringing *
      leaf-list ringing {
        tailf:info "Softkey order for ringing state";
        tailf:cli-flat-list-syntax;
        tailf:cli-no-value-on-delete;
        ordered-by user;
        type enumeration {
          enum Answer {
            tailf:info "Answer";
          }
          enum Dnd {
            tailf:info "Do not Disturb";
          }
          enum HLog {
            tailf:info "HLog";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// ephone-dn
  /// ========================================================================

  // ephone-dn *
  list ephone-dn {
    tailf:info "Configure ephone phone lines (Directory Numbers)";
    tailf:cli-mode-name "config-ephone-dn";
    tailf:cli-diff-dependency "../telephony-service";
    key tag;
    leaf tag {
      type uint16 {
        tailf:info "<1-400>;;ephone-dn tag";
      }
    }
    leaf dual-line {
      tailf:info "dual-line DN (2 calls per line/button)";
      tailf:cli-hide-in-submode;
      type empty;
    }
    leaf octo-line {
      tailf:info "octo-line DN (8 calls per line/button)";
      tailf:cli-hide-in-submode;
      type empty;
    }

    // ephone-dn * / number
    container number {
      tailf:info "Define E.164 telephone number";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf telephone-number {
        tailf:cli-drop-node-name;
        cli:ned-diff-move-last {
          cli:arguments "when-delete";
        }
        type string {
          tailf:info "WORD;;A sequence of digits - representing telephone number";
        }
      }
      leaf secondary {
        tailf:info "secondary dn number";
        tailf:cli-optional-in-sequence;
        type string {
          tailf:info "WORD;;A sequence of digits - representing telephone number";
        }
      }
      leaf no-reg {
        tailf:info "Set E164 not register";
        type empty;
      }
      leaf not-registered {
        tailf:cli-drop-node-name;
        type enumeration {
          enum primary {
            tailf:info "primary number not register";
          }
         enum both {
            tailf:info "both number not register";
          }
        }
      }
    }

    // ephone-dn * / park-slot
    container park-slot {
      tailf:info "set ephone-dn as park slot";
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      presence true;
      container timeout {
        tailf:info "Set call park timeout";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        leaf park-timeout {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-65535>;;Specify the park timeout (seconds) before the call is returned to the number it was parked from";
          }
        }
        leaf limit {
          tailf:info "Set call park timeout count limit";
          tailf:cli-break-sequence-commands;
          type uint16 {
            tailf:info "<1-65535>;;Specify the number of park timeout cycles before the call is disconnected";
          }
        }
        leaf recall {
          tailf:info "recall transfer back to originator phone after timeout";
          type empty;
        }
        leaf retry {
          tailf:info "Set recall/transfer retry interval if target is in use";
          type uint16 {
            tailf:info "<1-65535>;;Specify the retry delay for park recall/transfer hold-off in case recall/transfer target is in-use";
          }
        }
        leaf retry-limit {
          tailf:alt-name "limit";
          tailf:info "et call park recall/transfer hold-off retry count limit.";
          type uint16 {
            tailf:info "<1-65535>;;Specify the number of recall/transfer retry cycles before the call is disconnected";
          }
        }
      }
    }

    // ephone-dn * / label
    leaf label {
      tailf:info "dn label, for DN Display text";
      tailf:cli-multi-value;
      tailf:cli-preformatted;
      tailf:cli-full-command;
      tailf:cli-no-value-on-delete;
      type string {
        tailf:info "LINE;;label, will go on a phone's line button text";
      }
    }

    // ephone-dn * / name
    leaf name {
      tailf:info "Define dn user name";
      tailf:cli-multi-value;
      tailf:cli-preformatted;
      tailf:cli-full-command;
      tailf:cli-no-value-on-delete;
      type string {
        tailf:info "LINE;;user name string";
      }
    }

    // ephone-dn * / ephone-dn-template
    leaf ephone-dn-template {
      tailf:info "Define ephone-dn-template tag";
      tailf:non-strict-leafref {
        path "../../ephone-dn-template/tag";
      }
      type uint8 {
        tailf:info "<1-15>;;Template tag";
      }
    }

    // ephone-dn * / description
    // ephone-dn * / allow
    // ephone-dn * / caller-id
    // ephone-dn * / call-forward
    // ephone-dn * / corlist
    // ephone-dn * / hold-alert
    uses ephone-dn-grouping;

    // ephone-dn * / conference
    leaf conference {
      tailf:info "conference dn, octo-line DN recommended. At least 2 DNs must be configured for dual-line DNs";
      tailf:cli-remove-before-change;
      type enumeration {
        enum ad-hoc {
          tailf:info "Ad-hoc conference, octo-line DN recommended. At least 2 DNs must be configured for dual-line DNs";
        }
        enum meetme {
          tailf:info "Meetme conference, octo-line DN recommended. At least 2 DNs must be configured for dual-line DNs";
        }
      }
    }

    // ephone-dn * / mwi
    // ephone-dn * / paging
    choice mwi-paging {

      // ephone-dn * / mwi
      container mwi {
        tailf:info "set message waiting indicator options (mwi)";
        tailf:cli-diff-delete-before "../call-forward/noan" {
          tailf:cli-when-target-set;
        }
        leaf action {
          tailf:cli-drop-node-name;
          tailf:cli-remove-before-change;
          type enumeration {
            enum off {
              tailf:info "Set ephone-dn to process mwi off action";
            }
            enum on {
              tailf:info "Set ephone-dn to process mwi on action";
            }
            enum on-off {
              tailf:info "Set ephone-dn to process mwi on/off actions using main/secondary telephone numbers";
            }
            enum qsig {
              tailf:info "Register ephone-dn for qsig mwi service";
            }
            enum sip {
              tailf:info "Register ephone-dn for sip mwi service";
            }
          }
        }
      }

      // ephone-dn * / paging
      container paging {
        tailf:info "set audio paging mode";
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;

        // ephone-dn * / paging ip
        container ip {
          tailf:info "Use IP multicast for audio paging";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf multicast-address {
            tailf:cli-drop-node-name;
            tailf:cli-no-value-on-delete;
            tailf:cli-incomplete-command;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Define audio paging IP multicast address";
            }
          }
          leaf port {
            tailf:info "Define media port for multicast paging";
            tailf:cli-no-name-on-delete;
            tailf:cli-no-value-on-delete;
            type uint16 {
              tailf:info "<2000-65535>;;Specify the port: 2000 - 65535";
            }
          }
        }
      }
    }

    // ephone-dn * / transfer-mode
    leaf transfer-mode {
      tailf:info "Define call transfer mode: blind vs. consult";
      tailf:cli-no-value-on-delete;
      type enumeration {
        enum blind {
          tailf:info "Perform blind call transfers (without consultation) using single phone line";
        }
        enum consult {
          tailf:info "Perform call transfers with consultation using second phone line if available";
        }
      }
    }

    // ephone-dn * / night-service bell
    container night-service {
      tailf:info "Define night-service bell";
      leaf bell {
        tailf:info "night-service bell";
        type empty;
      }
    }
  }

  // ephone-dn *
  // ephone-dn-template *
  grouping ephone-dn-grouping {

    // ephone-dn * / description
    uses description-grouping;

    // ephone-dn * / allow
    container allow {
      tailf:info "allow watcher";
      leaf watch {
        tailf:info "allow watcher for presence";
        tailf:cli-no-name-on-delete;
        type empty;
      }
    }

    // ephone-dn * / caller-id
    container caller-id {
      tailf:info "Configure port caller id parameters";

      // ephone-dn * / caller-id block
      leaf block {
        tailf:info "Block the caller id of the calls made from this port";
        type empty;
      }
    }

    // ephone-dn * / call-forward
    container call-forward {
      tailf:info "Define E.164 telephone number for call forwarding";

      // ephone-dn * / all
      leaf all {
        tailf:info "forward all calls";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;A sequence of digits";
        }
      }

      // ephone-dn * / call-forward busy
      container busy {
        tailf:info "forward call on busy";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf digits {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;A sequence of digits";
          }
        }
        leaf forward {
          tailf:cli-drop-node-name;
          type enumeration {
            enum primary {
              tailf:info "forward to dial-peer created for the primary number";
            }
            enum secondary {
              tailf:info "forward to dial-peer created for the secondary number";
            }
          }
        }
        leaf dialplan-pattern {
          tailf:info "forward to dial-peer created for the dialplan-pattern";
          type empty;
        }
      }

      // ephone-dn * / call-forward night-service
      leaf night-service {
        tailf:info "forward call on activated night-service";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;A sequence of digits";
        }
      }

      // ephone-dn * / call-forward noan
      container noan {
        tailf:info "forward call on no-answer";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf digits {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;A sequence of digits - representing E.164 number";
          }
        }
        leaf timeout {
          tailf:info "Ringing no answer timeout duration";
          type uint16 {
            tailf:info "<3-60000>;;Ringing no answer timeout duration in seconds";
          }
        }
      }
    }

    // ephone-dn * / corlist
    container corlist {
      tailf:info "Class of Restriction on dial-peer for this dn";

      // ephone-dn * / corlist incoming
      leaf incoming {
        tailf:info "incoming class of restriction list";
        tailf:cli-no-value-on-delete;
        tailf:non-strict-leafref {
          path "../../../dial-peer/cor/list/name";
        }
        type string {
          tailf:info "WORD;;cor list name";
        }
      }

      // ephone-dn * / corlist outgoing
      leaf outgoing {
        tailf:info "outgoing class of restriction list";
        tailf:cli-no-value-on-delete;
        tailf:non-strict-leafref {
          path "../../../dial-peer/cor/list/name";
        }
        type string {
          tailf:info "WORD;;cor list name";
        }
      }
    }

    // ephone-dn * / hold-alert
    container hold-alert {
      tailf:info "Set Call On-Hold timeout alert parameters";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      leaf timeout {
        tailf:cli-drop-node-name;
        tailf:cli-no-value-on-delete;
        type uint16 {
          tailf:info "<15-300>;;call on-hold timeout in seconds";
        }
      }
      leaf type {
        tailf:cli-drop-node-name;
        tailf:cli-break-sequence-commands;
        tailf:cli-no-value-on-delete;
        type enumeration {
          enum idle {
            tailf:info "alert on-hold originator only if idle";
          }
          enum originator {
            tailf:info "alert on-hold originator always";
          }
          enum shared {
            tailf:info "alert all phones that share the line";
          }
          enum shared-idle {
            tailf:info "alert all idle phones that share the line";
          }
        }
      }
    }

    // ephone-dn * / translation-profile
    container translation-profile {
      tailf:info "Translation profile";
      leaf incoming {
        tailf:info "Translation Profile for incoming call leg";
        tailf:non-strict-leafref {
          path "/ios:voice/translation-profile/name";
        }
        type string {
          tailf:info "WORD;;Profile name";
        }
      }
      leaf outgoing {
        tailf:info "Translation Profile for outgoing call leg";
        tailf:non-strict-leafref {
          path "/ios:voice/translation-profile/name";
        }
        type string {
          tailf:info "WORD;;Profile name";
        }
      }
    }
  }


  /// ========================================================================
  /// ephone
  /// ========================================================================

  // ephone *
  list ephone {
    tailf:info "define ethernet phone";
    tailf:cli-mode-name "config-ephone";
    tailf:cli-diff-delete-before "../ephone-dn";
    tailf:cli-diff-dependency "../telephony-service";
    key tag;
    leaf tag {
      type uint16 {
        tailf:info "<1-uint16>;;Ethernet phone tag";
      }
    }

    // ephone * / no multicast-moh
    leaf multicast-moh {
      tailf:info "Enable Multicast Moh";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
      default true;
    }

    // ephone * / device-security-mode
    leaf device-security-mode {
      tailf:info "Device Security Mode";
      type enumeration {
        enum none {
          tailf:info "None";
        }
        enum authenticated {
          tailf:info "Authenticated";
        }
        enum encrypted {
          tailf:info "Encrypted";
        }
      }
    }

    // ephone * / mac-address
    leaf mac-address {
      tailf:info "define ethernet phone MAC address";
      tailf:cli-no-value-on-delete;
      type mac-address-type {
        tailf:info "H.H.H;;Mac address";
      }
    }

    // ephone * / ephone-template
    leaf ephone-template {
      tailf:info "Define ephone-template tag";
      tailf:cli-no-value-on-delete;
      tailf:non-strict-leafref {
        path "../../ephone-template/tag";
      }
      type uint8 {
        tailf:info "<1-20>;;Template tag";
      }
    }

    // ephone * / description
    // ephone * / max-calls-per-button
    // ephone * / busy-trigger-per-button
    // ephone * / conference
    // ephone * / fastdial *
    // ephone * / speed-dial *
    // ephone * / type
    uses ephone-grouping;

    // ephone * / username
    container username {
      tailf:info "define username to access ethernet phone from Web";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf name {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "WORD;;User name";
        }
      }
      leaf password {
        tailf:cli-no-name-on-delete;
        tailf:cli-no-value-on-delete;
        ios:password-dequote-output "password (\\S+)";
        type NEDCOM_SECRET_TYPE {
          tailf:info "WORD;;password name";
        }
      }
    }

    // ephone * / blf-speed-dial *
    list blf-speed-dial {
      tailf:info "Define BLF speed dial ip-phone button";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-incomplete-command;
      key index;
      leaf index {
        type uint8 {
          tailf:info "<1-75>;;BLF speed dial Index";
        }
      }
      leaf phone-number {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        tailf:cli-no-value-on-delete;
        type uint64 {
          tailf:info "WORD;;BLF Speed-dial phone number";
        }
      }
      leaf label {
        tailf:info "Define a text label for the BLF speed dial";
        tailf:cli-no-name-on-delete;
        tailf:cli-no-value-on-delete;
        type string {
          tailf:info "WORD;;BLF Speed-dial text label, use quoted string if including spaces";
        }
      }
    }

    // ephone * / button *
    list button {
      tailf:info "Assign ephone-dn phone lines to phone using format with feature options.";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-show-long-obu-diffs;
      ordered-by user;
      key name;
      leaf name {
        tailf:cli-multi-word-key;
        type string {
          tailf:info "WORD;;button config";
        }
      }
    }

    // ephone * / pin
    leaf pin {
      tailf:info "Define 4-8 digit personal identification number";
      type string {
        tailf:info "WORD;;A sequence of digits - representing personal identification number";
      }
    }
  }


  // ephone *
  // ephone-template *
  grouping ephone-grouping {

    // ephone * / description
    uses description-grouping;

    // ephone * / conference
    container conference {
      tailf:info "Adhoc hardware conference configuration";

      // ephone * / conference drop-mode
      container drop-mode {
        tailf:info "Adhoc hardware conference drop mode.  Default is never drop.";
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        leaf creator {
          tailf:info "The active conference terminates when the conference creator hangs up.";
          type empty;
        }
        leaf local {
          tailf:info "The active conference terminates when the last local party in the conference hangs up or drops out of the conference.";
          type empty;
        }
      }

      // ephone * / conference add-mode
      container add-mode {
        tailf:info " Adhoc hardware conference add mode.";
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        leaf creator {
          tailf:info "Allow add party by creator only";
          type empty;
        }
      }

      // ephone * / conference admin
      leaf admin {
        tailf:info "Adhoc/Meetme hardware conference admin.";
        type empty;
      }
    }

    // ephone * / max-calls-per-button
    leaf max-calls-per-button {
      tailf:info "Define maximum number of calls per octo-line button of this ephone";
      type uint8 {
        tailf:info "<1-8>;;Maximum number of calls supported per octo-line button";
        range "1..8";
      }
    }

    // ephone * / busy-trigger-per-button
    leaf busy-trigger-per-button {
      tailf:info "Define the number of calls that triggers call forward busy per octo-line button of this ephone";
      type uint8 {
        tailf:info "<1-8>;;The number of calls that triggers call forward busy per octo-line button";
        range "1..8";
      }
    }

    // ephone * / fastdial *
    list fastdial {
      tailf:info "Define ip-phone fastdial number";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-incomplete-command;
      key tag;
      leaf tag {
        type uint8 {
          tailf:info "<1-100>;;fast-dial entry tag";
        }
      }
      leaf phone-number {
        tailf:cli-drop-node-name;
        tailf:cli-no-value-on-delete;
        type string {
          tailf:info "WORD;;fast-dial phone number";
        }
      }
      leaf name {
        tailf:info "Define a text name for the fast dial";
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-full-command;
        tailf:cli-no-name-on-delete;
        tailf:cli-no-value-on-delete;
        type string {
          tailf:info "LINE;;fast-dial name, no quotes required";
        }
      }
    }

    // ephone * / speed-dial *
    list speed-dial {
      tailf:info "Define ip-phone speed-dial number";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-incomplete-command;
      key tag;
      leaf tag {
        type string {
          tailf:info "<1-75>;;Speed-dial string tag";
        }
      }
      leaf phone-number {
        tailf:cli-drop-node-name;
        tailf:cli-no-value-on-delete;
        type uint64 {
          tailf:info "WORD;;Speed-dial phone number";
        }
      }
      leaf label {
        tailf:info "Define a text label for the speed dial";
        tailf:cli-no-name-on-delete;
        tailf:cli-no-value-on-delete;
        type string {
          tailf:info "WORD;;Speed-dial text label, use quoted string if including spaces";
        }
      }
    }

    // ephone * / type
    container type {
      tailf:info "Define ip-phone type";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      leaf ip-phone-module {
        tailf:cli-drop-node-name;
        tailf:cli-break-sequence-commands;
        type string {
          tailf:info "WORD;;ip phone module";
        }
      }
      container addon {
        tailf:info "Define ip-phone addon module";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf module-number-1 {
          tailf:alt-name "1";
          tailf:info "addon module number";
          tailf:cli-no-name-on-delete;
          tailf:cli-no-value-on-delete;
          type string {
            tailf:info "Cisco IP Phone ABCD XY-Button Line Expansion Module";
          }
        }
        leaf module-number-2 {
          tailf:alt-name "2";
          tailf:info "addon module number";
          tailf:cli-no-name-on-delete;
          tailf:cli-no-value-on-delete;
          type string {
            tailf:info "Cisco IP Phone ABCD XY-Button Line Expansion Module";
          }
        }
      }
    }

    // ephone * / paging-dn
    container paging-dn {
      tailf:info "set audio paging dn group for phone";
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      presence true;
      leaf ephone-dn-tag {
        tailf:cli-drop-node-name;
        tailf:cli-no-value-on-delete;
        tailf:non-strict-leafref {
          path "../../../ephone-dn/tag";
        }
        type uint16 {
          tailf:info "<1-1200>;;ephone-dn tag used for paging number";
        }
      }
    }

    // ephone * / night-service bell
    container night-service {
      tailf:info "Define night-service bell";
      leaf bell {
        tailf:info "night-service bell";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// parser
  /// ========================================================================

  container parser {
    tailf:info "Configure parser";

    // no parser cache
    leaf cache {
      tailf:info "Configure parser cache";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
      default true;
    }

    // parser view *
    list view {
      tailf:info "View Commands";
      tailf:cli-mode-name "config-view";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;View Name";
        }
      }

      // parser view * / secret
      container secret {
        tailf:info "Set a secret for the current view";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf type {
          tailf:cli-optional-in-sequence;
          tailf:cli-drop-node-name;
          tailf:cli-no-value-on-delete;
          tailf:cli-incomplete-command;
          type enumeration {
            enum "0" {
              tailf:info "Specifies an UNENCRYPTED secret will follow";
            }
            enum "5" {
              tailf:info "Specifies a HIDDEN secret will follow";
            }
          }
        }
        leaf secret {
          tailf:cli-drop-node-name;
          tailf:cli-reset-container;
          tailf:cli-disallow-value "0|5";
          tailf:cli-no-value-on-delete;
          cli:secret " secret <SECRET>";
          type NEDCOM_SECRET_TYPE {
            tailf:info "WORD;;The HIDDEN user secret string";
          }
        }
      }

      // parser view * / commands *
      list commands {
        tailf:info "Configure commands for a view";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key line;
        leaf line {
          tailf:cli-multi-word-key;
          type string {
            tailf:info "WORD;;commands line";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// configuration
  /// ========================================================================

  // configuration mode exclusive
  container configuration {
    tailf:info "Configuration access";
    container mode {
      tailf:info "Configuration mode";
      container exclusive {
        tailf:info "Configuration mode exclusive";
        presence true;
      }
    }
  }


  /// ========================================================================
  /// line
  /// ========================================================================

  container line {
    tailf:info "Configure a terminal line";

    // line con(sole) 0
    list console {
      tailf:info "Primary terminal line";
      tailf:cli-full-command;
      tailf:cli-mode-name "config-line";
      key first;
      max-elements 1;
      leaf first {
        type enumeration {
          enum "0" {
            tailf:info "<0-0>;;First Line number";
          }
        }
      }
      uses line-grouping {
        refine "password/secret" {
          cli:secret " password <SECRET>";
        }
      }
    }

    // line aux 0
    list aux {
      tailf:info "Auxiliary line";
      tailf:cli-full-command;
      tailf:cli-mode-name "config-line";
      key first;
      max-elements 1;
      leaf first {
        type enumeration {
          enum "0" {
            tailf:info "<0-0>;;First Line number";
          }
        }
      }
      uses line-grouping;
    }

    // line vty *
    container vty-single-conf {
      tailf:cli-drop-node-name;
      list vty {
        tailf:info "Virtual terminal";
        tailf:cli-full-command;
        tailf:cli-mode-name "config-line";
        //ios:range-list-syntax "line vty (\\d+)$";
        key first;
        leaf first {
          type uint16 {
            tailf:info "<0-1869>;;First Line number";
            range "0..1869";
          }
        }
        uses line-grouping;
      }
    }

    // line vty * *
    list vty {
      tailf:info "Virtual terminal";
      tailf:cli-full-command;
      tailf:cli-mode-name "config-line";
      when "not(../../tailfned/api/expanded-line-vty-format)" {
        tailf:dependency "../../tailfned/api/expanded-line-vty-format";
      }
      key "first last";
      leaf first {
        type uint16 {
          tailf:info "<0-1869>;;First Line number";
          range "0..1869";
        }
      }
      leaf last {
        type uint16 {
          tailf:info "<1-1869>;;Last Line number";
          range "1..1869";
        }
      }
      uses line-grouping;
    }

    // line *
    list number-single-list {
      tailf:cli-drop-node-name;
      tailf:cli-full-command;
      tailf:cli-mode-name "config-line";
      key first;
      leaf first {
        tailf:cli-suppress-range;
        tailf:cli-disallow-value "con|console|aux|vty";
        type string {
          tailf:info "Line number";
        }
      }
      uses line-grouping;
    }
  }


  /// ========================================================================
  /// ztp
  /// ========================================================================

  // ztp disable
  container ztp {
    tailf:info "Global ZTP configuration";
    leaf disable {
      tailf:info "ZTP Disable";
      type empty;
    }
  }


  /// ========================================================================
  /// telemetry
  /// ========================================================================

  container telemetry {
    tailf:info "Telemetry configuration";

    // telemetry ietf subscription *
    container ietf {
      tailf:info "Telemetry IETF configuration";
      list subscription {
        tailf:info "Telemetry Subscription configuration";
        tailf:cli-mode-name "config-mdt-subs";
        key id;
        leaf id {
          type uint32 {
            tailf:info "<0-2147483647>;;Subscription Identifier";
            range "0..2147483647";
          }
        }

        // telemetry ietf subscription * / encoding
        leaf encoding {
          tailf:info "Configure encoding for subscription";
          type enumeration {
            enum encode-kvgpb {
              tailf:info "kvGPB encoding";
            }
            enum encode-tdl {
              tailf:info "TDL encoding";
            }
          }
        }

        // telemetry ietf subscription * / filter
        container filter {
          tailf:info "Configure filter for subscription";
          choice filter-choice {

            // telemetry ietf subscription * / filter xpath
            leaf xpath {
              tailf:info "Xpath filter type";
              type string {
                tailf:info "WORD;;Specify Xpath filter";
              }
            }

            // telemetry ietf subscription * / filter tdl-transform
            leaf tdl-transform {
              tailf:info "TDL Transform filter type";
              type string {
                tailf:info "WORD;;Specify TDL URI filter";
              }
            }

            // telemetry ietf subscription * / filter tdl-uri
            leaf tdl-uri {
              tailf:info "TDL URI filter type";
              type string {
                tailf:info "WORD;;Specify TDL URI filter";
              }
            }
          }
        }

        // telemetry ietf subscription * / stream
        leaf stream {
          tailf:info "Configure stream for subscription";
          type enumeration {
            enum native {
              tailf:info "native stream";
            }
            enum yang-push {
              tailf:info "yang-push stream";
            }
            enum yang-notif-native {
              tailf:info "yang-notif-native stream";
            }
          }
        }

        // telemetry ietf subscription * / update-policy
        container update-policy {
          tailf:info "Configure update-policy for subscription";
          choice update-policy-choice {
            leaf periodic {
              tailf:info "Enable periodic updates";
              type uint32 {
                tailf:info "<0-4294967295>;;Specify period in unit of 100ths of a second";
              }
            }
            leaf on-change {
              tailf:info "Enable on-change updates";
              type empty;
            }
          }
        }

        // telemetry ietf subscription * / receiver ip address * *
        container receiver {
          tailf:info "Configure receiver information for notification";
          container ip {
            tailf:info "Receiver IP address";
            list address {
              tailf:info "Receiver IP address";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-incomplete-command;
              key "address port";
              leaf address {
                type all-address;
              }
              leaf port {
                type uint16 {
                  tailf:info "<0-65535>;;Specify receiver port";
                }
              }
              leaf protocol {
                tailf:info "Configure Protocol for notification";
                type enumeration {
                  enum cloud-native {
                    tailf:info "Native Cloud Protocol";
                  }
                  enum cntp-tcp {
                    tailf:info "CNTP TCP Protocol";
                  }
                  enum cntp-tls {
                    tailf:info "CNTP TLS Protocol";
                  }
                  enum grpc-tcp {
                    tailf:info "GRPC TCP Protocol";
                  }
                  enum grpc-tls {
                    tailf:info "GRPC TLS Protocol";
                  }
                  enum native {
                    tailf:info "Native Protocol";
                  }
                  enum tls-native {
                    tailf:info "Native TLS Protocol";
                  }
                }
              }
            }
          }
        }
      }
    }

    // telemetry transform *
    list transform {
      tailf:info "Telemetry transform configuration";
      tailf:cli-mode-name "config-mdt-xfrm";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Transform Name";
        }
      }

      // telemetry transform * / input
      container input {
        tailf:info "Transform input table configuration";

        // telemetry transform * / input table *
        list table {
          tailf:info "Transform table configuration";
          tailf:cli-mode-name "config-mdt-xfrm-table";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Table Name";
            }
          }

          // telemetry transform * / input table * / field *
          list field {
            tailf:info "Transform input table fields";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;Field Name";
              }
            }
          }

          // telemetry transform * / input table * / join-key
          leaf join-key {
            tailf:info "Table join key";
            type string {
              tailf:info "WORD;;Specify join key";
            }
          }

          // telemetry transform * / input table * / logical-op
          leaf logical-op {
            tailf:info "Input table logical operation";
            type enumeration {
              enum and {
                tailf:info "Specify AND logical operation";
              }
              enum or {
                tailf:info "Specify OR logical operation";
              }
            }
          }

          // telemetry transform * / input table * / type
          leaf type {
            tailf:info "Input table type";
            type enumeration {
              enum mandatory {
                tailf:info "Specifies table is mandatory";
              }
              enum primary {
                tailf:info "Specifies table is primary";
              }
            }
          }

          // telemetry transform * / input table * / uri
          leaf uri {
            tailf:info "Input table URI";
            type string {
              tailf:info "WORD;;Specify input table full-path URI";
            }
          }
        }
      }

      // telemetry transform * / operation *
      list operation {
        tailf:info "Transform operation configuration";
        tailf:cli-mode-name "config-mdt-xfrm-operation";
        key id;
        leaf id {
          type uint32 {
            tailf:info "<0-4294967295>;;Operation transform ID";
          }
        }

        // telemetry transform * / operation * / filter *
        list filter {
          tailf:info "Transform output filters";
          tailf:cli-mode-name "config-mdt-xfrm-operation-filter";
          key id;
          leaf id {
            type uint32 {
              tailf:info "<0-4294967295>;;Filter ID";
            }
          }

          // telemetry transform * / operation * / filter * / event on-change
          container event {
            tailf:info "Transform output filter event configuration";
            leaf on-change {
              tailf:info "Filter operates on-change";
              type empty;
            }
          }

          // telemetry transform * / operation * / filter * / field
          leaf field {
            tailf:info "Transform output filter field";
            type string {
              tailf:info "WORD;;Field name";
            }
          }

          // telemetry transform * / operation * / filter * / logical-op
          container logical-op {
            tailf:info "Transform output filter logical operations";
            leaf next {
              tailf:info "Next logical operation to perform";
              type enumeration {
                enum and {
                  tailf:info "Specify AND logical operation";
                }
                enum or {
                  tailf:info "Specify OR logical operation";
                }
              }
            }
            leaf value {
              tailf:cli-drop-node-name;
              type enumeration {
                enum and {
                  tailf:info "Specify AND logical operation";
                }
                enum or {
                  tailf:info "Specify OR logical operation";
                }
              }
            }
          }
        }

        // telemetry transform * / operation * / output-field *
        list output-field {
          tailf:info "Transform output fields to export";
          tailf:cli-mode-name "config-mdt-xfrm-operation-field";
          key id;
          leaf id {
            type uint32 {
              tailf:info "<0-4294967295>;;Output field ID";
            }
          }

          // telemetry transform * / operation * / output-field * / field
          leaf field {
            tailf:info "Transform output field";
            type string {
              tailf:info "WORD;;Field name";
            }
          }
        }
      }

      // telemetry transform * / specified
      leaf specified {
        tailf:info "The transform configuration is fully specified";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// module
  /// ========================================================================

  container module {
    tailf:info "linecard module configuration commands";

    // module clear-config
    leaf clear-config {
      tailf:info "To clear configuration when module is removed";
      type empty;
    }

    // module provision
    container provision {
      tailf:info "Configure module provision status";

      // module provision *
      list list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          type uint8 {
            tailf:info "<1-uint8>;;slot id";
          }
        }
        leaf provision {
          tailf:cli-drop-node-name;
          ios:delete-syntax "no module provision (\\d+) first-insert" {
            cli:arguments "module provision $1 dynamic";
          }
          type enumeration {
            enum first-insert {
              tailf:info "Provision module for first inserted line card";
            }
          }
        }
      }

      // module provision switch *
      list switch {
        key id;
        leaf id {
          type uint8;
        }

        // module provision switch * / chassis-type
        container chassis-type {
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf value {
            tailf:cli-drop-node-name;
            type uint8;
          }
          leaf base-mac {
            type string;
          }
        }

        // module provision switch * / slot *
        list slot {
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          key id;
          leaf id {
            type uint8;
          }
          leaf slot-type {
            type uint16;
          }
          leaf port-type {
            tailf:cli-optional-in-sequence;
            type uint16;
          }
          leaf number {
            tailf:cli-optional-in-sequence;
            type uint16;
          }
          leaf virtual-slot {
            tailf:cli-optional-in-sequence;
            type uint16;
          }
          leaf base-mac {
            type string;
          }
        }
      }
    }
  }


  /// ========================================================================
  /// exception
  /// ========================================================================

  container exception {
    tailf:info "Exception handling";

    // exception data-corruption buffer
    container data-corruption {
      tailf:info "Data error exception handling";
      container buffer {
        tailf:info "Set buffer corruption behavior";

        // exception data-corruption buffer truncate
        leaf truncate {
          tailf:info "Truncate buffer overwrites";
          type empty;
        }
      }
    }

    // exception flash
    container flash {
      tailf:info "Set the device and erase permission";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf memory {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type enumeration {
          enum iomem {
            tailf:info "dump I/O memory";
          }
          enum procmem {
            tailf:info "dump processor memory";
          }
          enum all {
            tailf:info "dump all memory";
          }
        }
      }
      leaf device-name {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "WORD;;Device name";
        }
      }
    }

    // exception crashinfo
    choice crashinfo-choice {
      // no exception crashinfo
      container crashinfo-enable {
        tailf:cli-drop-node-name;
        leaf crashinfo {
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }
      }
      // exception crashinfo X
      container crashinfo {
        tailf:info "Crashinfo collection";
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;

        // exception crashinfo file
        leaf file {
          tailf:info "crashinfo file name in bootflash or PCMCIA slot";
          type string {
            tailf:info "<WORD>;;device:file name (up to 38 characters)";
          }
        }

        // exception crashinfo buffersize
        leaf buffersize {
          tailf:info "crashinfo log buffer size";
          type uint16 {
            tailf:info "<32-256>;;buffer size in Kbytes 256K or less (default is 32K)";
            range "32..256";
          }
          default 32;
        }

        // exception crashinfo maximum-files
        leaf maximum-files {
          tailf:info "Set maximum number of crashinfo files";
          type uint8 {
            tailf:info "<1-20>;;A value between 1-20";
            range "1..20";
          }
        }

        // exception crashinfo maximum files
        container maximum {
          tailf:info "Enable automatic deletion of old crashinfo files to create space";
          leaf files {
            tailf:info "Configure number of latest crashinfo files to retain";
            type uint8 {
              tailf:info "<1-32>;;Configure <1-32> latest crashinfo files to retain";
              range "1..32";
            }
          }
        }
      }
    }

    // exception dump
    leaf dump {
      tailf:info "Set name of host to dump to";
      type inet:host {
        tailf:info "Hostname or A.B.C.D;;Hostname or address of dump host";
      }
    }

    // exception coredump
    container coredump {
      tailf:info "Set coredump properties";
      presence true;
    }

    // exception core-file
    container core-file {
      tailf:info "Set name of core dump file";
      presence true;
      leaf name {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "WORD;;Name of the core file";
        }
      }
    }
  }


  /// ========================================================================
  /// pnp
  /// ========================================================================

  container pnp {
    tailf:info "Configure PNP";

    // pnp profile *
    list profile {
      tailf:info "PNP profile";
      tailf:cli-mode-name "config-pnp-init";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;PNP Profile name";
        }
      }

      // pnp profile * / transport
      container transport {
        tailf:info "The transport to use";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf protocol {
          tailf:cli-drop-node-name;
          type enumeration {
            enum http {
              tailf:info "Use http (plaintext) transport";
            }
            enum https {
              tailf:info "Use https (encrypted) transport";
            }
            enum xmpp {
              tailf:info "Use XMPP transport";
            }
          }
        }

        leaf over {
          tailf:cli-drop-node-name;
          when "../protocol = 'xmpp'" {
            tailf:dependency "../protocol";
          }
          type enumeration {
            enum socket {
              tailf:info "xmpp over plain socket (no encryption)";
            }
            enum starttls {
              tailf:info "xmpp starttls";
            }
            enum tls {
              tailf:info "xmpp over tls (encrypted)";
            }
          }
        }

        choice address-choice {
          leaf host {
            tailf:info "hostname of server";
            type inet:host {
              tailf:info "WORD;;Hostname of the server";
            }
          }
          leaf ipv4 {
            tailf:info "ipv4 address";
            type inet:ipv4-address {
              tailf:info "WORD;;IP address of the server";
            }
          }
          leaf ipv6 {
            tailf:info "IPv6 address";
            type inet:ipv6-address {
              tailf:info "X:X:X:X::X;;IPv6 address of server";
            }
          }
        }

        leaf port {
          tailf:info "port number";
          type uint16 {
            tailf:info "<1-65535>;;Port number to use";
          }
        }

        leaf vrf {
          tailf:info "Bind port to VRF";
          tailf:cli-optional-in-sequence;
          type string {
            tailf:info "WORD;;VRF name";
          }
        }

        container source {
          tailf:info "Bind port to interface";
          tailf:cli-optional-in-sequence;
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          uses interface-name-grouping;
        }

        leaf localcert {
          tailf:info "Local certificate";
          tailf:cli-optional-in-sequence;
          type string {
            tailf:info "WORD;;Trustpoint name";
          }
        }

        leaf remotecert {
          tailf:info "Remote certificate validation";
          type string {
            tailf:info "WORD;;Trustpoint name";
          }
        }
      }

      // pnp profile * / reconnect
      container reconnect {
        tailf:info "Pause to wait before reconnecting";
        leaf seconds {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-2000000>;;Pause in seconds";
            range "1..2000000";
          }
        }
      }
    }

    // pnp startup-vlan
    leaf startup-vlan {
      tailf:info "PNP startup-vlan";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "PNP vlan id;default vlan is 1";
        range "2..4094";
      }
    }

    // pnp tag
    leaf tag {
      tailf:info "PNP tag";
      tailf:cli-full-command;
      type string {
        tailf:info "WORD;;PNP tag name";
      }
    }
  }


  /// ========================================================================
  /// onep
  /// ========================================================================

  container onep {
    tailf:info "ONEP functionality";
    tailf:cli-add-mode;

    // onep start
    leaf start {
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
    }

    // onep transport tipc
    container transport {
      tailf:info "Transport type";
      container tipc {
        tailf:info "tipc transport";
        presence true;
      }
    }
  }


  /// ========================================================================
  /// logging
  /// ========================================================================

  container logging {
    tailf:info "Modify message logging facilities";

    // logging discriminator *
    list discriminator {
      tailf:info "Create or modify a message discriminator";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key discr-name;
      leaf discr-name {
        type string {
          tailf:info "WORD;;discriminator name; string; max. 8 characters";
        }
      }

      // logging discriminator * severity
      container severity {
        tailf:info "Severity group for message filtering";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        uses logging-discriminator-pattern-grouping;
      }

      // logging discriminator * facility
      container facility {
        tailf:info "Facility pattern for message filtering";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        uses logging-discriminator-pattern-grouping;
      }

      // logging discriminator * mnemonics
      container mnemonics {
        tailf:info "Mnemonics pattern for message filtering";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        uses logging-discriminator-pattern-grouping;
      }

      // logging discriminator * msg-body
      container msg-body {
        tailf:info "Msg-body pattern for message filtering";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        uses logging-discriminator-pattern-grouping;
      }
    }

    // logging cmts
    container cmts {
      tailf:info "CMTS config commands";
      container ipc-cable {
        tailf:info "Cable IPC config commands";
        // logging cmts ipc-cable log-level
        leaf log-level {
          tailf:info "cable ipc log level config commands";
          type logging-level-type;
        }
      }
      container sea {
        tailf:info "SEA config commands";
        // logging cmts sea syslog-level
        leaf syslog-level {
          tailf:info "Specify syslog loggging level";
          type logging-level-type;
        }
      }
    }

    // logging alarm
    leaf alarm {
      tailf:info "Configure syslog for alarms";
      tailf:cli-full-command;
      type union {
        type uint8 {
          tailf:info "<1-4>;;Alarm Logging severity level";
          range "1..4";
        }
        type enumeration {
          enum critical {
            tailf:info "Service affecting Condition       (severity=1)";
          }
          enum informational {
            tailf:info "Informational messages            (severity=4)";
          }
          enum major {
            tailf:info "Immediate action needed           (severity=2)";
          }
          enum minor {
            tailf:info "Minor warning conditions          (severity=3)";
          }
        }
      }
    }

    // logging message-counter
    container message-counter {
      tailf:info "Configure log message to include certain counter value";

      // logging message-counter log
      leaf log {
        tailf:info "counter of accumulated logging messages received by logger";
        tailf:cli-full-command;
        type empty;
      }

      // logging message-counter debug
      leaf debug {
        tailf:info "counter of accumulated buginf messages received by logger";
        tailf:cli-full-command;
        type empty;
      }

      // no logging message-counter syslog
      leaf syslog {
        tailf:info "counter of current lines of syslog messages sent";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }
    }

    // logging buffered
    container buffered {
      tailf:info "Set buffered logging parameters";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf xxml {
        tailf:alt-name xml;
        tailf:info "Enable logging in XML to XML logging buffer";
        tailf:cli-optional-in-sequence;
        type empty;
      }
      leaf discriminator {
        when "not(../xxml)" {
          tailf:dependency "../xxml";
        }
        tailf:info "Establish MD-Console association";
        tailf:cli-optional-in-sequence;
        tailf:non-strict-leafref {
          path "../../../logging/discriminator/discr-name";
        }
        type string {
          tailf:info "WORD;;discriminator name; string; max. 8 characters";
        }
      }
      leaf buffer-size {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        type uint32 {
          tailf:info "<4096-2147483647>;;Logging buffer size";
          range "4096..2147483647";
        }
      }
      leaf severity-level {
        tailf:cli-drop-node-name;
        type logging-level-type;
      }
    }

    // logging persistent
    container persistent {
      tailf:info "Set persistent logging parameters";
      tailf:cli-compact-syntax;

      // logging persistent url
      leaf url {
        tailf:info "URL to store logging messages";
        type string {
          tailf:info "WORD;;Filesystem name";
        }
      }

      // logging persistent size
      leaf size {
        tailf:info "Set disk space for writing log messages";
        type uint32 {
          tailf:info "<16384-256503808>;;Logging filesystem size";
          range "16384..256503808";
        }
      }

      // logging persistent filesize
      leaf filesize {
        tailf:info "Set size of individual log files";
        type uint32 {
          tailf:info "<8192-256503808>;;Logging file size";
          range "8192..256503808";
        }
      }
    }

    // logging exception
    leaf exception {
      tailf:info "Limit size of exception flush output";
      type uint32 {
        tailf:info "<4096-2147483647>;;Set size of logging exception flush (default 4096)";
        range "4096..2147483647";
      }
      default 4096;
    }

    // logging queue-limit
    container queue-limit {
      tailf:info "Set logger message queue size";
      leaf queuesize {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        type uint32 {
          tailf:info "<100-2147483647>;;Set new queue size. Default 1024";
          range "100..2147483647";
        }
        default 1024;
      }
    }

    // logging userinfo
    leaf userinfo {
      tailf:info "Enable logging of user info on privileged mode enabling";
      type empty;
    }

    // logging console
    // logging monitor
    grouping logging-common-grouping {
      leaf xxml {
        tailf:alt-name xml;
        tailf:info "Enable logging in XML to XML logging buffer";
        tailf:cli-optional-in-sequence;
        type empty;
      }
      leaf discriminator {
        when "not(../xxml)" {
          tailf:dependency "../xxml";
        }
        tailf:info "Establish MD-Console association";
        tailf:cli-optional-in-sequence;
        tailf:non-strict-leafref {
          path "../../../logging/discriminator/discr-name";
        }
        type string {
          tailf:info "WORD;;discriminator name; string; max. 8 characters";
        }
      }
      leaf filtered {
        tailf:info "Enable filtered logging";
        tailf:cli-optional-in-sequence;
        type empty;
      }
      leaf severity-level {
        tailf:cli-drop-node-name;
        type logging-level-type;
      }
    }

    // logging console
    container console {
      tailf:info "Set console logging parameters";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      uses logging-common-grouping;
    }

    // logging monitor
    container monitor {
      tailf:info "Set terminal line (monitor) logging parameters";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      uses logging-common-grouping;
    }

    // logging snmp-trap
    container snmp-trap {
      tailf:info "Set syslog level for sending snmp trap";

      // logging snmp-trap emergencies
      leaf emergencies {
        tailf:info "System is not stable               (severity=0)";
        type empty;
      }

      // logging snmp-trap critical
      leaf critical {
        tailf:info "Critical conditions               (severity=2)";
        type empty;
      }

      // logging snmp-trap errors
      leaf errors {
        tailf:info "Error conditions                  (severity=3)";
        type empty;
      }

      // logging snmp-trap informational
      leaf informational {
        tailf:info "Informational messages            (severity=6)";
        type empty;
      }

      // logging snmp-trap alerts
      leaf alerts {
        tailf:info "Immediate action needed           (severity=1)";
        type empty;
      }

      // logging snmp-trap warnings
      leaf warnings {
        tailf:info "Warning conditions                (severity=4)";
        type empty;
      }

      // logging snmp-trap notifications
      leaf  notifications {
        tailf:info "Normal but significant conditions (severity=5)";
        type empty;
      }

      // logging snmp-trap debugging
      leaf debugging {
        tailf:info "Debugging messages                (severity=7)";
        type empty;
      }
    }

    // logging snmp-authfail
    leaf snmp-authfail {
      tailf:cli-full-command;
      type empty;
    }

    // logging event
    container event {
      tailf:info "Global interface events";

      // logging event link-status
      container link-status {
        tailf:info "Globally enable/disable link UPDOWN message";
        leaf boot {
          tailf:info "Supress/Allow link UPDOWN messages during boot";
          type empty;
        }
        leaf global {
          type empty;
        }
        leaf default {
          tailf:info "Link UPDOWN messages for all interfaces";
          type empty;
        }
      }

      // logging event trunk-status global
      container trunk-status {
        tailf:info "trunk status logging event";
        leaf global {
          tailf:info "global trunk status logging event";
          type empty;
        }
      }
    }

    // logging esm config
    container esm {
      tailf:info "Set ESM filter restrictions";
      leaf config {
        tailf:info "Permit/Deny configuration changes from ESM filters";
        type empty;
      }
    }

    // logging facility
    leaf facility {
      tailf:info "Facility parameter for syslog messages";
      tailf:cli-full-command;
      type enumeration {
        enum auth {
          tailf:info "Authorization system";
        }
        enum cron {
          tailf:info "Cron/at facility";
        }
        enum daemon {
          tailf:info "System daemons";
        }
        enum kern {
          tailf:info "Kernel";
        }
        enum local0 {
          tailf:info "Local use";
        }
        enum local1 {
          tailf:info "Local use";
        }
        enum local2 {
          tailf:info "Local use";
        }
        enum local3 {
          tailf:info "Local use";
        }
        enum local4 {
          tailf:info "Local use";
        }
        enum local5 {
          tailf:info "Local use";
        }
        enum local6 {
          tailf:info "Local use";
        }
        enum local7 {
          tailf:info "Local use";
        }
        enum lpr {
          tailf:info "Line printer system";
        }
        enum mail {
          tailf:info "Mail system";
        }
        enum news {
          tailf:info "USENET news";
        }
        enum sys10 {
          tailf:info "System use";
        }
        enum sys11 {
          tailf:info "System use";
        }
        enum sys12 {
          tailf:info "System use";
        }
        enum sys13 {
          tailf:info "System use";
        }
        enum sys14 {
          tailf:info "System use";
        }
        enum sys9 {
          tailf:info "System use";
        }
        enum syslog {
          tailf:info "Syslog itself";
        }
        enum user {
          tailf:info "User process";
        }
        enum uucp {
          tailf:info "Unix-to-Unix copy system";
        }
      }
      default local7;
    }

    // logging history
    container history {
      tailf:info "Configure syslog history table";

      // logging history size
      leaf size {
        tailf:info "Set history table size. Default 1";
        type uint16 {
          tailf:info "<0-500>;History size";
          range "0..500";
        }
        default 1;
      }

      // logging history ?
      leaf severity-level {
        tailf:cli-drop-node-name;
        type logging-level-type;
      }
    }

    // logging *
    list hostname {
      tailf:info "Hostname or A.B.C.D;;IP address of the logging host";
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key host;
      leaf host {
        tailf:cli-disallow-value "esm|alarm|buffered|facility|reload|userinfo"+
          "|history|rate-limit|source-interface|host|console|trap|origin-id|linecard";
        tailf:cli-full-command;
        type inet:host {
          tailf:info "Hostname or A.B.C.D;;IP address of the logging host";
        }
      }
    }

    // logging host
    container host {
      tailf:info "Set syslog server IP address and parameters";

      // logging host fqdn
      container fqdn {
        tailf:info "Configure periodic address resolution for syslog server";

        // logging host fqdn ipv4 *
        list ipv4 {
          tailf:info "Configure IPv4 syslog server";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key host;
          leaf host {
            type string {
              tailf:info "WORD;;Fully Qualified Domain name of syslog server";
            }
          }
          uses logging-host-grouping;
        }
      }

      // logging host *
      list ipv4 {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-diff-delete-before "../../hostname";
        key host;
        leaf host {
          tailf:cli-disallow-value "fqdn|ipv6";
          type inet:host {
            tailf:info "Hostname or A.B.C.D;;IP address of the syslog server";
          }
        }
        uses logging-host-grouping;
      }

      // logging host * vrf
      list ipv4-vrf {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-diff-delete-before "../ipv4";
        key "host vrf";
        leaf host {
          tailf:cli-disallow-value "fqdn|ipv6";
          type inet:host {
            tailf:info "Hostname or A.B.C.D;;IP address of the syslog server";
          }
        }
        leaf vrf {
          tailf:info "Set VRF option";
          tailf:cli-expose-key-name;
          tailf:cli-diff-dependency "../../../../ip/vrf";
          tailf:cli-diff-dependency "../../../../vrf/definition";
          type string {
            tailf:info "WORD;;VPN Routing/Forwarding instance name";
          }
        }
        uses logging-host-grouping;
      }

      // logging host ipv6 *
      list ipv6 {
        tailf:info "Configure IPv6 syslog server";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-diff-delete-before "../../hostname";
        key host;
        leaf host {
          type inet:host {
            tailf:info "Hostname or X:X:X:X::X;;IPv6 address of the syslog server";
          }
        }
        uses logging-host-grouping;
      }

      // logging host ipv6 * vrf
      container ipv6-vrf {
        tailf:cli-drop-node-name;
        list ipv6 {
          tailf:info "Configure IPv6 syslog server";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-diff-delete-before "../../ipv6";
          key "host vrf";
          leaf host {
            type inet:host {
              tailf:info "Hostname or X:X:X:X::X;;IPv6 address of the syslog server";
            }
          }
          leaf vrf {
            tailf:info "Set VRF option";
            tailf:cli-expose-key-name;
            tailf:cli-diff-dependency "../../../../../vrf/definition";
            type string {
              tailf:info "WORD;;VPN Routing/Forwarding instance name";
            }
          }
          uses logging-host-grouping;
        }
      }
    }

    // logging rate-limit
    choice rate-limit-choice {
      // no logging rate-limit
      leaf rate-limit {
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }
      // logging rate-limit
      container rate-limit-conf {
        tailf:cli-drop-node-name;
        container rate-limit {
          tailf:info "Set messages per second limit";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          leaf console {
            tailf:info "Rate limit only console messages";
            tailf:cli-optional-in-sequence;
            tailf:cli-incomplete-command;
            type empty;
          }
          leaf all {
            tailf:info "Rate limit all messages, including debug messages";
            tailf:cli-optional-in-sequence;
            tailf:cli-incomplete-command;
            type empty;
          }
          leaf rate {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<1-10000>;;Messages per second";
              range "1..10000";
            }
          }
          leaf except {
            tailf:info "Messages of this severity or higher";
            type logging-level-type;
          }
        }
      }
    }

    // logging source-interface *
    list source-interface {
      tailf:info "Specify interface for source address in logging transactions";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key name;
      leaf name {
        tailf:cli-diff-dependency "../../../interface";
        type string {
          tailf:info "WORD;;Interface name";
        }
      }
      leaf vrf {
        tailf:info "Specify the vrf of source interface for logging transactions";
        tailf:cli-diff-dependency "../../../ip/vrf";
        tailf:cli-diff-dependency "../../../vrf/definition";
        type string {
          tailf:info "WORD;;VPN Routing/Forwarding instance name";
        }
      }
    }

    // logging trap
    choice logging-trap-choice {
      leaf trap {
        tailf:info "Set syslog server logging level";
        tailf:cli-full-command;
        type logging-level-type;
        default informational;
      }

      // logging trap syslog-format
      container trap-syslog-format {
        tailf:cli-drop-node-name;

        container trap {
          tailf:info "Set syslog server logging level";
          tailf:cli-compact-syntax;
          tailf:cli-reset-container;

          leaf level {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type logging-level-type;
            default informational;
          }
          leaf syslog-format {
            tailf:info "Set RFC format of syslog message";
            type enumeration {
              enum "rfc5424" {
                tailf:info "RFC format 5424";
              }
            }
          }
        }
      }
    }

    // logging origin-id
    container origin-id {
      tailf:info "Add origin ID to syslog messages";
      choice origin-id-choice {
        leaf hostname {
          tailf:info "Use origin hostname as ID";
          type empty;
        }
        leaf ip {
          tailf:info "Use origin IP address as ID";
          type empty;
        }
        leaf ipv6 {
          tailf:info "Use origin IPv6 address as ID";
          type empty;
        }
        leaf string {
          tailf:info "Define a unique text string as ID";
          type string {
            tailf:info "WORD;;Text string";
          }
        }
      }
    }

    // logging linecard
    container linecard {
      tailf:info "specify logging parameters for a linecard messages";
      leaf size {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        type uint32 {
          tailf:info "<4096-65536>;;number of bytes of message log per slot";
          range "4096..65535";
        }
        default 8192;
      }
      leaf level {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        type logging-level-type;
      }
    }

    // logging reload
    leaf reload {
      tailf:info "Set reload logging level";
      type enumeration {
        enum alerts {
          tailf:info "Immediate action needed";
        }
        enum critical {
          tailf:info "Critical conditions";
        }
        enum debugging {
          tailf:info "Debugging messages";
        }
        enum emergencies {
          tailf:info "System is unusable";
        }
        enum errors {
          tailf:info "Error conditions";
        }
        enum informational {
          tailf:info "Informational messages";
        }
        enum notifications {
          tailf:info "Normal but significant conditions";
        }
        enum warnings {
          tailf:info "Warning conditions";
        }
      }
      default notifications;
    }

    // logging ip access-list cache
    container ip {
      tailf:info "IP configuration";
      container access-list {
        tailf:info "Access-list";
        container cache {
          tailf:info "Optimized logging";
          tailf:cli-compact-syntax;
          leaf entries {
            tailf:info "Maximum number of log entries cached in software";
            type uint32 {
              tailf:info "<0-1048576>;;Number of entries";
              range "0..1048576";
            }
          }
          leaf interval {
            tailf:info "Log-update interval (in sec)";
            type uint32 {
              tailf:info "<5-86400>;;Log-update interval in seconds";
              range "5..86400";
            }
          }
          leaf threshold {
            tailf:info "Log-update threshold";
            type uint32 {
              tailf:info "<0-1000000>;;Log-update threshold (number of hits)";
              range "0..1000000";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// firewall
  /// ========================================================================

  container firewall {
    tailf:info "Specify secure VLANs groups and tie them to firewall modules";

    // firewall autostate
    leaf autostate {
      tailf:info "enable auto state";
      type empty;
    }

    // firewall multiple-vlan-interfaces
    leaf multiple-vlan-interfaces {
      tailf:info "Enable multiple vlan interfaces mode for firewall modules";
      type empty;
    }

    // firewall module * vlan-group *
    list module {
      tailf:info "Secure group which VLANs will be tied to";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      key id;
      leaf id {
        type uint8 {
          tailf:info "<1-10>;;Module number";
        }
      }
      leaf-list vlan-group {
        tailf:cli-range-list-syntax;
        tailf:cli-remove-before-change;
        type uint16 {
          tailf:info "WORD;;group range (1-65535) ex: 1,32,80-90";
        }
      }
    }

    // firewall vlan-group *
    list vlan-group {
      tailf:info "Secure group which VLANs will be tied to";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      key id;
      leaf id {
        type uint16 {
          tailf:info "<1-65535>;;group-number";
          range "1..65535";
        }
      }
      leaf-list vlan {
        tailf:cli-drop-node-name;
        tailf:cli-range-list-syntax;
        type uint16 {
          tailf:info "WORD;;vlan range (2-1001,1006-4094) ex: 2-65,72,300-320";
        }
      }
    }
  }


  /// ========================================================================
  /// standby
  /// ========================================================================

  container standby {
    tailf:info "Global HSRP configuration commands";

    // no standby redirect
    leaf redirect {
      tailf:info "Configure sending of ICMP Redirect messages with an HSRP virtual IP address as the gateway IP address";
      tailf:cli-boolean-no;
      type boolean;
      default true;
    }
  }


  /// ========================================================================
  /// cpd
  /// ========================================================================

  container cpd {
    tailf:info "Global Control Point Discovery Configuration";
    tailf:cli-display-separated;
    presence true;

    // cpd cr-id
    leaf cr-id {
      tailf:info "Control Relationship Identifier";
      type uint16 {
        tailf:info "<1-65535>;;Control Relationship Identifier Value";
        range "1..65535";
      }
    }
  }


  /// ========================================================================
  /// nls
  /// ========================================================================

  container nls {
    tailf:info "Global Network Layer Signaling Configuration";
    tailf:cli-display-separated;
    presence true;

    // nls resp-timeout
    leaf resp-timeout {
      tailf:info "NLS Response Timeout";
      type uint8 {
        tailf:info "<1-60>;;NLS Response Timeout Value";
        range "1..60";
      }
    }
  }


  /// ========================================================================
  /// flow-sampler-map
  /// ========================================================================

  list flow-sampler-map {
    tailf:info "Flow sampler configuration";
    tailf:cli-mode-name "config-sampler";
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;Name of the flow sampler";
      }
    }

    // flow-sampler-map * / mode
    container mode {
      tailf:info "Mode of packet sampling for netflow processing";
      container random {
        tailf:info "Random mode of sampling";
        leaf one-out-of {
          tailf:info "Select one packet out of";
          type uint16 {
            tailf:info "<1-65535>;number of sequential packets to select one packet from";
            range "1..65535";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// frame-relay
  /// ========================================================================

  container frame-relay {
    tailf:info "global frame relay configuration commands";

    // frame-relay switching
    leaf switching {
      tailf:info "enable frame relay pvc switching";
      type empty;
    }
  }


  /// ========================================================================
  /// scheduler
  /// ========================================================================

  container scheduler {
    tailf:info "Scheduler parameters";

    // scheduler process-watchdog
    leaf process-watchdog {
      tailf:info "Action for looping processes";
      type enumeration {
        enum normal {
          tailf:info "Factory specified per-process behavior";
        }
        enum hang {
          tailf:info "Retain the process but do not schedule it";
        }
        enum reload {
          tailf:info "Reload the system";
        }
        enum terminate {
          tailf:info "Terminate the process and continue";
        }
      }
      default normal;
    }

    // scheduler allocate
    container allocate {
      tailf:info "Guarantee CPU time for processes";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf interrupt-time {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint16 {
          tailf:info "<400-60000>;;Microseconds handling network interrupts";
          range "400..60000";
        }
      }
      leaf process-time {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<100-4000>;;Microseconds running processes";
          range "100..4000";
        }
      }
    }

    // scheduler interval
    leaf interval {
      tailf:info "Maximum interval before running lowest priority process";
      type uint32 {
        tailf:info "<100-2147483647>;;Milliseconds";
        range "100..2147483647";
      }
    }

    // scheduler isr-watchdog
    leaf isr-watchdog {
      tailf:info "Detect ISR Hang";
      type empty;
    }

    // scheduler runtime netinput
    container runtime {
      tailf:info "Process runtime controls";
      leaf netinput {
        tailf:info "Enable packet process-switching run time";
        type uint16 {
          tailf:info "<100-40000>;;Process-switching run time (in milliseconds)";
          range "100..40000";
        }
      }
    }
  }


  /// ========================================================================
  /// wsma
  /// ========================================================================

  container wsma {
    tailf:info "Configure Web Services Management Agents";

    // wsma agent *
    list agent {
      tailf:info "Configure WSMA agents";
      key name;
      leaf name {
        type enumeration {
          enum "config" {
            tailf:info "Start WSMA config agent";
          }
          enum exec {
            tailf:info "Start WSMA exec agent";
          }
          enum filesys {
            tailf:info "Start WSMA file system agent";
          }
          enum notify {
            tailf:info "Start WSMA notify agent";
          }
        }
      }
      list profile {
        tailf:info "Profile to use";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Profile name";
          }
        }
      }
    }

    // wsma profile
    container profile {
      tailf:info "Configure WSMA profil";

      // wsma profile listener *
      list listener {
        tailf:cli-mode-name "config-wsma-listen";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Listener profile name";
          }
        }

        // wsma profile listener * / transport
        container transport {
          tailf:info "The transport to use";
          choice transport-choice {
            container http {
              tailf:info "Use http (plaintext) transport";
              presence true;
            }
            container https {
              tailf:info "Use https (encrypted) transport";
              presence true;
            }
            container ssh {
              tailf:info "Use SSH V2";
              presence true;
            }
          }
        }
      }

      // wsma profile initiator *
      list initiator {
        tailf:cli-mode-name "config-wsma-init";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Initiator profile name";
          }
        }

        // wsma profile initiator * / transport
        container transport {
          tailf:info "The transport to use";
          choice transport-choice {
            container http {
              tailf:info "Use http (plaintext) transport";
              presence true;
            }
            container https {
              tailf:info "Use https (encrypted) transport";
              presence true;
            }
            container ssh {
              tailf:info "Use SSH V2";
              presence true;
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// process
  /// ========================================================================

  container process {
    tailf:info "Configure process";

    // process cpu
    container cpu {
      tailf:info "Configure cpu parameters";

      // process cpu threshold
      container threshold {
        tailf:info "cpu threshold parameters";
        container type {
          tailf:info "cpu threshold type";
          tailf:cli-compact-syntax;

          // process cpu threshold type total
          container total {
            tailf:info "total cpu utilization";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            uses process-cpu-threshold-grouping;
          }

          // process cpu threshold type interrupt
          container interrupt {
            tailf:info "interrupt level utilization";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            uses process-cpu-threshold-grouping;
          }

          // process cpu threshold type process
          container process {
            tailf:info "process level utilization";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            uses process-cpu-threshold-grouping;
          }
        }
      }

      // process cpu statistics limit
      container statistics {
        tailf:info "cpu statistics";
        container limit {
          tailf:info "cpu utilization history";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf entry-percentage {
            tailf:info "cpu history entry percentage";
            type uint8 {
              tailf:info "<1-100>";
              range "1..100";
            }
          }
          leaf size {
            tailf:info "cpu history size in seconds";
            type uint32 {
              tailf:info "<5-86400>";
              range "5..86400";
            }
          }
        }
      }

      // no process cpu autoprofile hog
      container autoprofile {
        tailf:info "Enable automatic cpuhog profiling";
        leaf hog {
          tailf:info "Enable automatic cpuhog profiling";
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }
      }
    }
  }


  /// ========================================================================
  /// ntp
  /// ========================================================================

  container ntp {
    tailf:info "Configure NTP";

    // ntp max-associations
    leaf max-associations {
      tailf:info "Set maximum number of associations";
      tailf:cli-full-command;
      type uint32 {
        tailf:info "<0-4294967295>;;Number of associations. Default 100";
      }
      default 100;
    }

    // ntp clock-period
    // NOT MODELLED BECAUSE VALUE CHANGE RUNTIME

    // ntp passive
    leaf passive {
      tailf:info "NTP passive mode";
      tailf:cli-full-command;
      type empty;
    }

    // ntp logging
    leaf logging {
      tailf:info "Enable NTP message logging";
      tailf:cli-full-command;
      type empty;
    }

    // ntp panic
    container panic {
      tailf:info "Reject time updates > panic threshold (default 1000Sec)";
      leaf update {
        tailf:info "Reject time updates > panic threshold (default 1000Sec)";
        type empty;
      }
    }

    // ntp authentication-key *
    list authentication-key {
      tailf:info "Authentication key for trusted time sources";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-sequence-commands;
      tailf:cli-compact-syntax;
      tailf:cli-incomplete-command;
      key number;
      leaf number {
        type uint32 {
          tailf:info "<1-4294967295>;;Key number";
          range "1..4294967295";
        }
      }
      container md5 {
        tailf:info "MD5 authentication";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf secret {
          tailf:cli-drop-node-name;
          tailf:cli-reset-container;
          cli:secret " md5 <SECRET>";
          type NEDCOM_SECRET_TYPE {
            tailf:info "WORD;;Authentication key";
          }
        }
        leaf type {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<0-4294967295>;;Authentication key encryption type";
          }
        }
      }
    }

    // ntp authenticate
    leaf authenticate {
      tailf:info "Authenticate time sources";
      tailf:cli-full-command;
      type empty;
    }

    // ntp trusted-key *
    list trusted-key {
      tailf:info "Key numbers for trusted time sources";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      key key-number;
      leaf key-number {
        type uint16 {
          tailf:info "<1-65535>;;Key number";
          range "1..65535";
        }
      }
      leaf hyphen {
        tailf:info "hyphen";
        tailf:alt-name "-";
        tailf:cli-incomplete-command;
        type empty;
      }
      leaf end-key-number {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<1-65535>;;End Key range";
          range "1..65535";
        }
      }
    }

    // ntp orphan
    leaf orphan {
      tailf:info "Threshold Stratum for orphan mode";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<1-16>;;Orphan stratum";
        range "1..16";
      }
    }

    // ntp mindistance
    leaf mindistance {
      tailf:info "Minimum distance to consider for clockhop";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<1-500>;;Minimum distance to consider for clockhop. Default 1";
        range "1..500";
      }
      default 1;
    }

    // ntp maxdistance
    leaf maxdistance {
      tailf:info "Maximum Distance for synchronization";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<1-16>;;Maximum distance for synchronization. Default 8";
        range "1..16";
      }
      default 8;
    }

    // ntp broadcastdelay
    leaf broadcastdelay {
      tailf:info "Estimated round-trip delay";
      tailf:cli-full-command;
      type uint32 {
        tailf:info "<1-999999>;;Round-trip delay in microseconds";
        range "1..999999";
      }
    }

    // ntp source
    container source {
      tailf:info "Configure interface for source address";
      uses interface-name-grouping;
    }

    // ntp access-group
    container access-group {
      tailf:info "Control NTP access";

      // ntp access-group peer
      container peer {
        tailf:info "Provide full access";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf access-list {
          tailf:cli-drop-node-name;
          type std-ip-acl-type;
        }
        leaf kod {
          tailf:info "Send a Kiss-o-Death packet for failing peers";
          type empty;
        }
      }

      // ntp access-group query-only
      container query-only {
        tailf:info "Allow only control queries";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf access-list {
          tailf:cli-drop-node-name;
          type std-ip-acl-type;
        }
        leaf kod {
          tailf:info "Send a Kiss-o-Death packet for failing peers";
          type empty;
        }
      }

      // ntp access-group serve
      container serve {
        tailf:info "Provide server and query access";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf access-list {
          tailf:cli-drop-node-name;
          type std-ip-acl-type;
        }
        leaf kod {
          tailf:info "Send a Kiss-o-Death packet for failing peers";
          type empty;
        }
      }

      // ntp access-group server-only
      container serve-only {
        tailf:info "Provide only server access";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf access-list {
          tailf:cli-drop-node-name;
          type std-ip-acl-type;
        }
        leaf kod {
          tailf:info "Send a Kiss-o-Death packet for failing peers";
          type empty;
        }
      }

      // ntp access-group ipv6
      container ipv6 {
        tailf:info "ipv6 access lists";

        // ntp access-group ipv6 peer
        container peer {
          tailf:info "Provide full access";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf access-list {
            tailf:cli-drop-node-name;
            type std-ip-acl-type;
          }
          leaf kod {
            tailf:info "Send a Kiss-o-Death packet for failing peers";
            type empty;
          }
        }
      }
    }

    // ntp master
    container master {
      tailf:info "Act as NTP master clock";
      tailf:cli-delete-when-empty;
      presence true;
      leaf stratum {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-15>;;Stratum number";
          range "1..15";
        }
      }
    }

    // ntp peer
    container peer {
      tailf:info "Configure NTP peer";
      uses ntp-peer-grouping;
      // ntp peer ip
      container ip {
        tailf:info "Use IP for DNS resolution";
        tailf:cli-compact-syntax;
        uses ntp-peer-grouping;
      }
      // ntp peer ipv6
      container ipv6 {
        tailf:info "Use IPv6 for DNS resolution";
        tailf:cli-compact-syntax;
        uses ntp-peer-grouping;
      }
      // ntp peer vrf *
      list vrf {
        tailf:info "VPN Routing/Forwarding Information";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          tailf:cli-diff-dependency "../../../../ip/vrf";
          tailf:cli-diff-dependency "../../../../vrf/definition";
          type string {
            tailf:info "WORD;;VPN Routing/Forwarding instance name";
          }
        }
        uses ntp-peer-grouping;
      }
    }

    // ntp server *
    container server {
      tailf:info "Configure NTP server";
      uses ntp-peer-grouping;
      // ntp server ip *
      container ip {
        tailf:info "Use IP for DNS resolution";
        tailf:cli-compact-syntax;
        uses ntp-peer-grouping;
      }
      // ntp server ipv6 *
      container ipv6 {
        tailf:info "Use IPv6 for DNS resolution";
        tailf:cli-compact-syntax;
        uses ntp-peer-grouping;
      }
      // ntp server vrf *
      list vrf {
        tailf:info "VPN Routing/Forwarding Information";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          tailf:cli-diff-dependency "../../../../ip/vrf";
          tailf:cli-diff-dependency "../../../../vrf/definition";
          type string {
            tailf:info "WORD;;VPN Routing/Forwarding instance name";
          }
        }
        uses ntp-peer-grouping;
      }
    }

    // ntp allow mode
    container allow {
      tailf:info "Allow processing of packets";
      container mode {
        tailf:info "Allow processing of particular mode packets";

        // ntp allow mode control
        leaf control {
          tailf:info "Allow processing control mode packets";
          type uint8 {
            tailf:info "<0-15>;;Rate limiting delay (s)";
            range "0..15";
          }
          //removed in newer versions: default 0;
        }

        // ntp allow mode private
        leaf private {
          tailf:info "Allow processing private mode packets";
          type empty;
        }
      }
    }

    // ntp update-calender
    leaf update-calendar {
      tailf:info "Periodically update calendar with NTP time";
      type empty;
    }

  }


  /// ========================================================================
  /// sntp
  /// ========================================================================

  container sntp {
    tailf:info "Configure SNTP";
    tailf:cli-incomplete-no;

    // sntp logging
    leaf logging {
      tailf:info "Enable SNTP message logging";
      tailf:cli-full-command;
      type empty;
    }

    // sntp authentication-key *
    list authentication-key {
      tailf:info "Authentication key for trusted time sources";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-sequence-commands;
      tailf:cli-compact-syntax;
      tailf:cli-incomplete-command;
      key number;
      leaf number {
        type uint32 {
          tailf:info "<1-4294967295>;;Key number";
          range "1..4294967295";
        }
      }
      leaf md5 {
        tailf:info "MD5 authentication";
        type string {
          tailf:info "WORD;;Authentication key";
        }
      }
      leaf encryption-type {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<0-4294967295>;;Authentication key encryption type";
        }
      }
    }

    // sntp authenticate
    leaf authenticate {
      tailf:info "Authenticate time sources";
      tailf:cli-full-command;
      type empty;
    }

    // sntp trusted-key *
    list trusted-key {
      tailf:info "Key numbers for trusted time sources";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-sequence-commands;
      tailf:cli-compact-syntax;
      key key-number;
      leaf key-number {
        type uint16 {
          tailf:info "<1-65535>;;Key number";
          range "1..65535";
        }
      }
      leaf hyphen {
        tailf:info "hyphen";
        tailf:alt-name "-";
        tailf:cli-incomplete-command;
        type empty;
      }
      leaf end-key-number {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<1-65535>;;End Key range";
          range "1..65535";
        }
      }
    }

    // sntp server *
    container server {
      tailf:info "Configure SNTP server";
      uses sntp-server-grouping;
      // sntp server ip *
      container ip {
        tailf:info "Use IP for DNS resolution";
        tailf:cli-compact-syntax;
        uses sntp-server-grouping;
      }
      // sntp server ipv6 *
      container ipv6 {
        tailf:info "Use IPv6 for DNS resolution";
        tailf:cli-compact-syntax;
        uses sntp-server-grouping;
      }
      // sntp server vrf *
      list vrf {
        tailf:info "VPN Routing/Forwarding Information";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          tailf:cli-diff-dependency "../../../../ip/vrf";
          tailf:cli-diff-dependency "../../../../vrf/definition";
          type string {
            tailf:info "WORD;;VPN Routing/Forwarding instance name";
          }
        }
        uses sntp-server-grouping;
      }
    }

    // sntp broadcast
    container broadcast {
      tailf:info "Configure SNTP broadcast services";
      leaf client {
        tailf:info "Enable SNTP broadcast client mode";
        type empty;
      }
    }

    // sntp multicast client
    container multicast {
      tailf:info "Configure SNTP multicast services";
      container client {
        tailf:info "Enable SNTP multicast client mode";
        tailf:cli-delete-when-empty;
        tailf:cli-reset-container;
        presence true;
        leaf address {
          tailf:cli-drop-node-name;
          type union {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Multicast client IP address";
            }
            type inet:ipv6-address {
              tailf:info "X:X:X:X::X;;Multicast client IPv6 address";
            }
          }
        }
      }
    }

    // sntp source-interface
    container source-interface {
      tailf:info "Configure interface for source address";
      uses interface-name-grouping;
    }

  }


  /// ========================================================================
  /// nat64
  /// ========================================================================

  container nat64 {
    tailf:info "NAT64 configuration commands";

    // nat64 prefix
    container prefix {
      tailf:info "NAT64 prefix";

      // nat64 prefix stateful
      leaf stateful {
        tailf:info "Stateful prefix";
        type ipv6-prefix {
          tailf:info "X:X:X:X::X/<0-128>;;IPv6 prefix";
        }
      }
    }

    // nat64 v4 pool *
    container v4 {
      tailf:info "IPv4 configuration";
      list pool {
        tailf:info "NAT64 pool";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;NAT64 pool name";
          }
        }
        leaf start-address-range {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Starting address of pool address range";
          }
        }
        leaf end-address-range {
          tailf:cli-drop-node-name;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Ending address of pool address range";
          }
        }
        leaf forced {
          type empty;
        }
      }
    }

    // nat64 v6v4
    container v6v4 {
      tailf:info "IPv6 to IPv4 mapping";

      // nat64 v6v4 static *
      list static {
        tailf:info "Static mapping";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        key ipv6-address;
        leaf ipv6-address {
          type inet:ipv6-address {
            tailf:info "X:X:X:X::X;;IPv6 address";
          }
        }
        leaf ipv4-address {
          tailf:cli-drop-node-name;
          tailf:cli-remove-before-change;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IPv4 address";
          }
        }
        leaf redundancy {
          tailf:info "Redundancy group";
          tailf:cli-incomplete-command;
          tailf:non-strict-leafref {
            path "../../../../redundancy/application/redundancy/group/id";
          }
          type uint8 {
            tailf:info "<1-2>;;Redundancy group ID";
            range "1..2";
          }
        }
        leaf mapping-id {
          tailf:info "Unique ID to use for the mapping (same ID should be configured on active and standby boxes)";
          type uint32 {
            tailf:info "<1-20480>;;Redundancy mapping ID";
            range "1..20480";
          }
        }
      }

      // nat64 v6v4 list *
      list list {
        tailf:info "Access list for dynamic mapping";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;IPv6 ACL name";
          }
        }
        leaf pool {
          tailf:info "NAT64 pool for dynamic mapping";
          type string {
            tailf:info "WORD;;NAT64 pool name";
          }
        }
        leaf overload {
          tailf:info "Overload address translations";
          tailf:cli-optional-in-sequence;
          type empty;
        }
        leaf redundancy {
          tailf:info "Redundancy group";
          tailf:cli-incomplete-command;
          tailf:non-strict-leafref {
            path "../../../../redundancy/application/redundancy/group/id";
          }
          type uint8 {
            tailf:info "<1-2>;;Redundancy group ID";
            range "1..2";
          }
        }
        leaf mapping-id {
          tailf:info "Unique ID to use for the mapping (same ID should be configured on active and standby boxes)";
          type uint32 {
            tailf:info "<1-20480>;;Redundancy mapping ID";
          }
        }
      }
    }

    // nat64 settings
    container settings {
      tailf:info "NAT64 settings";

      // nat64 settings fragmentation header disable
      container fragmentation {
        tailf:info "NAT64 settings fragmentation";
        container header {
          tailf:info "NAT64 settings fragmentation header";
          leaf disable {
            tailf:info "Disable fragmentation header";
            type empty;

          }
        }
      }
    }
  }


  /// ========================================================================
  /// ptp
  /// ========================================================================

  container ptp {
    tailf:info "Precision Time Protocol";

    // ptp clock
    container clock {
      tailf:info "Configure PTP clock";

      // ptp clock profile *
      list profile {
        tailf:info "Create a PTP Clock Profile";
        tailf:cli-mode-name "config-ptp";
        key id;
        leaf id {
          type uint8 {
            tailf:info "<0-63>;;RPD PTP Ds Domain Number";
            range "0..63";
          }
        }

        // ptp clock profile * / clock-source1
        container clock-source1 {
          tailf:info "Clock Source";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf address {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Source IP addr";
            }
          }
          leaf gw {
            tailf:info "Clock Source Gateway";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Source Gateway addr";
            }
          }
        }
      }

      // ptp clock ordinary domain *
      container ordinary {
        tailf:info "Configure PTP Ordinary clock";
        tailf:cli-diff-dependency "../../../interface";
        list domain {
          tailf:info "PTP domain";
          tailf:cli-mode-name "config-ptp-clk";
          key id;
          max-elements 1;
          leaf id {
            type uint8 {
              tailf:info "<0-127>;;Domain number";
              range "0..127";
            }
          }
          leaf hybrid {
            tailf:info "Hybrid Mode";
            tailf:cli-hide-in-submode;
            type empty;
          }
          uses ptp-clock-domain-grouping;
        }
      }

      // ptp clock boundary domain *
      container boundary {
        tailf:info "Configure PTP Boundary clock";
        list domain {
          tailf:info "PTP domain";
          tailf:cli-mode-name "config-ptp-clk";
          key id;
          max-elements 1;
          leaf id {
            type uint8 {
              tailf:info "<0-127>;;Domain number";
              range "0..127";
            }
          }
          leaf hybrid {
            tailf:info "Hybrid Mode";
            tailf:cli-hide-in-submode;
            type empty;
          }
          uses ptp-clock-domain-grouping;
        }
      }
    }

    // ptp r-dti *
    list r-dti {
      tailf:info "Create a R-DTI configuration";
      tailf:cli-mode-name "config-r-dti";
      key id;
      leaf id {
        type uint8 {
          tailf:info "<1-64>;;RPD R-DTI configuration number";
          range "1..64";
        }
      }

      // ptp r-dti * / profile
      leaf profile {
        tailf:info "Set PTP ITU-T profile";
        type string {
          tailf:info "WORD;;Set PTP profile, e.g. G.8275.2";
        }
      }

      // ptp r-dti * / ptp-domain
      leaf ptp-domain {
        tailf:info "The domain number of IEEE 1588";
        type uint8 {
          tailf:info "<0-127>;;Domain number";
        }
      }

      // ptp r-dti * / clock-port *
      list clock-port {
        tailf:info "Configure clock port";
        tailf:cli-mode-name "config-r-dti-port";
        key id;
        leaf id {
          type uint8 {
            tailf:info "<1-32>;;RPD PTP port Number";
          }
        }

        // ptp r-dti * / clock-port * / ethernet
        leaf ethernet {
          tailf:info "Set ethernet port for clock port";
          type uint8 {
            tailf:info "<0 - 32>;;Index of ethernet port";
            range "0..32";
          }
        }

        // ptp r-dti * / clock-port * / transport
        container transport {
          tailf:info "Set port transport parameters";

          // ptp r-dti * / clock-port * / transport ipv4
          // ptp r-dti * / clock-port * / transport ipv6
          // ptp r-dti * / clock-port * / transport other
          leaf encapsulation {
            tailf:cli-drop-node-name;
            type enumeration {
              enum ipv4 {
                tailf:info "Use IPv4 encapsulation";
              }
              enum ipv6 {
                tailf:info "Use IPv6 encapsulation";
              }
              enum other {
                tailf:info "Use Other encapsulation (Ethernet)";
              }
            }
            default ipv4;
          }
        }

        // ptp r-dti * / clock-port * / clock source ip
        // ptp r-dti * / clock-port * / clock source ipv6
        container clock {
          tailf:info "Set clock parameters";

          container source {
            tailf:info "Local clock address";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf protocol {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type enumeration {
                enum ip {
                  tailf:info "IP";
                }
                enum ipv6 {
                  tailf:info "IPV6";
                }
              }
            }
            leaf address {
              tailf:cli-drop-node-name;
              type union {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Protocol specific address";
                }
                type inet:ipv6-address {
                  tailf:info "X:X:X:X::X;;Protocol specific address";
                }
              }
            }
            container gateway {
              tailf:info "Gateway of the clock addrress";
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf protocol {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type enumeration {
                  enum ip {
                    tailf:info "IP";
                  }
                  enum ipv6 {
                    tailf:info "IPV6";
                  }
                }
              }
              leaf address {
                tailf:cli-drop-node-name;
                type union {
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;Protocol specific address";
                  }
                  type inet:ipv6-address {
                    tailf:info "X:X:X:X::X;;Protocol specific address";
                  }
                }
              }
            }
          }

          container source-alternate {
            tailf:cli-drop-node-name;
            container source {
              tailf:info "Local clock address";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf protocol {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type enumeration {
                  enum ip {
                    tailf:info "IP";
                  }
                  enum ipv6 {
                    tailf:info "IPV6";
                  }
                }
              }
              leaf address {
                tailf:cli-drop-node-name;
                type union {
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;Protocol specific address";
                  }
                  type inet:ipv6-address {
                    tailf:info "X:X:X:X::X;;Protocol specific address";
                  }
                }
              }
              leaf alternate {
                tailf:info "Alternate address";
                type empty;
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// qos-overhead-accounting
  /// ========================================================================

  container qos-overhead-accounting {
    tailf:info "Overhead Accounting";

    // qos-overhead-accounting negative
    // qos-overhead-accounting positive
    choice overhead-choice {
      leaf negative {
        tailf:info "Negative Overhead Compensation";
        type uint8 {
          tailf:info "<0-32>;;Overhead Accounting Bytes";
          range "0..32";
        }
      }
      leaf positive {
        tailf:info "Positive Overhead Compensation";
        type uint8 {
          tailf:info "<0-32>;;Overhead Accounting Bytes";
          range "0..32";
        }
      }
    }

    // qos-overhead-accounting enable
    container enable {
      tailf:info "Enable Overhead Accounting for an Interface";

      // qos-overhead-accounting enable GigabitEthernet *
      list GigabitEthernet {
        tailf:info "GigabitEthernet IEEE 802.3z";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "<0-66>/<0-128>;;GigabitEthernet interface number";
            pattern '[0-9]+.*';
          }
        }
      }

      // qos-overhead-accounting enable TenGigabitEthernet *
      list TenGigabitEthernet {
        tailf:info "Ten Gigabit Ethernet";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "<0-66>/<0-128>;;TenGigabitEthernet interface number";
            pattern '[0-9]+.*';
          }
        }
      }
    }
  }


  /// ========================================================================
  /// mac-address-table
  /// ========================================================================

  container mac-address-table {
    tailf:info "Configure the MAC address table";

    // mac-address-table notification mac-move
    container notification {
      tailf:info "Enable a Notification feature";
      leaf mac-move {
        tailf:info "Enable Mac Move Notification";
        type empty;
      }
    }

    // mac-address-table move update
    container move {
      tailf:info "Move keyword";
      container update {
        tailf:info "Notification keyword";
        // mac-address-table move update transmit
        leaf transmit {
          tailf:info "Transmit keyword";
          type empty;
        }
        // mac-address-table move update receive
        leaf receive {
          tailf:info "Receive keyword";
          type empty;
        }
      }
    }

    // mac-address-table synchronize
    container synchronize {
      tailf:info "Synchronize MAC address table entries in the system";
      tailf:cli-display-separated;
      presence true;
      leaf activity-time {
        tailf:info "Set activity time for MAC entry synchronization";
        type uint16 {
          tailf:info "<0-1275>;;Enter time in seconds <160, 320, 640>";
        }
      }
    }

    // no mac-address-table aging-type routed-mac
    container aging-type {
      tailf:info "Enable routed MAC entries aging";
      leaf routed-mac {
        tailf:info "Enable routed MAC entries aging";
        tailf:cli-boolean-no;
        type boolean;
        default true;
      }
    }

    // mac-address-table aging-time
    leaf aging-time {
      tailf:info "Set MAC address table entry maximum age";
      tailf:cli-full-command;
      type union {
        type uint32 {
          tailf:info "<0-0>;;Enter 0 to disable aging";
          range "0";
        }
        type uint32 {
          tailf:info "<10-1000000>;;Aging time in seconds";
          range "10..1000000";
        }
      }
    }

    // mac-address-table aging-time ? routed-mac
    container againg-time-routed-mac {
      tailf:cli-drop-node-name;
      container aging-time {
        tailf:info "Set MAC address table entry maximum age";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        leaf speed {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          type union {
            type uint32 {
              tailf:info "<0-0>;;Enter 0 to disable aging";
              range "0";
            }
            type uint32 {
              tailf:info "<10-1000000>;;Aging time in seconds";
              range "10..1000000";
            }
          }
        }
        leaf routed-mac {
          tailf:info "Set RM Aging interval";
          tailf:cli-full-command;
          type empty;
        }
      }
    }

    // mac-address-table aging-time ? vlan *
    container againg-time-vlan {
      tailf:cli-drop-node-name;
      list aging-time {
        tailf:info "Set MAC address table entry maximum age";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        key vlan;
        leaf vlan {
          tailf:info "VLAN Keyword";
          tailf:cli-expose-key-name;
          type uint16 {
            tailf:info "<1-4094>;;VLAN id";
            range "1..4094";
          }
        }
        leaf speed {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type union {
            type uint32 {
              tailf:info "<0-0>;;Enter 0 to disable aging";
              range "0";
            }
            type uint32 {
              tailf:info "<10-1000000>;;Aging time in seconds";
              range "10..1000000";
            }
          }
        }
      }
    }

    // mac-address-table limit
    container limit-enable {
      tailf:cli-drop-node-name;
      leaf limit {
        tailf:info "Enter parameters for mac limit feature";
        tailf:cli-full-command;
        tailf:cli-full-no;
        type empty;
      }
    }

    // mac-address-table limit X
    container limit {
      tailf:info "Enter parameters for mac limit feature";
      tailf:cli-incomplete-command;
      tailf:cli-incomplete-no;

      // mac-address-table limit maximum
      leaf maximum {
        tailf:info "Enter max allowed entries";
        tailf:cli-no-value-on-delete;
        tailf:cli-diff-dependency "../../limit-enable/limit";
        type uint16 {
          tailf:info "<5-32768>;;Max allowed entries";
          range "5..32768";
        }
      }

      // mac-address-table limit vlan *
      list vlan {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          type uint16 {
            tailf:info "<1-4094>;;Enter VLAN Number";
            range "1..4094";
          }
        }
        // mac-address-table limit vlan * maximum
        leaf maximum {
          tailf:info "Enter max allowed entries";
          tailf:cli-no-name-on-delete;
          tailf:cli-no-value-on-delete;
          type uint16 {
            tailf:info "<5-16000>;;Max allowed entries";
          }
        }
        // mac-address-table limit vlan * action
        leaf action {
          tailf:info "Enter action";
          tailf:cli-no-name-on-delete;
          tailf:cli-no-value-on-delete;
          type enumeration {
            enum warning {}
            enum limit {}
            enum shutdown {}
          }
        }
        // mac-address-table limit vlan * flood
        leaf flood {
          tailf:info "Disable flooding on this vlan";
          tailf:cli-no-name-on-delete;
          type empty;
        }
      }

      // mac-address-table limit bdomain *
      list bdomain {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          type uint16 {
          }
        }
        // mac-address-table limit bdomain * maximum
        leaf maximum {
          tailf:info "Enter max allowed entries";
          type uint16 {
            tailf:info "<5-16000>;;Max allowed entries";
          }
        }
        // mac-address-table limit bdomain * action
        leaf action {
          tailf:info "Enter action";
          type enumeration {
            enum warning {}
            enum limit {}
            enum shutdown {}
          }
        }
        // mac-address-table limit bdomain * flood
        leaf flood {
          tailf:info "Disable flooding on this vlan";
          type empty;
        }
      }
    }

    // no mac-address-table learning vlan *
    // mac-address-table learning vlan no-list *
    container learning {
      tailf:info "Enable a MAC table learning feature";
      container vlan {
        tailf:info "Layer 2 table learning per VLAN";
        list no-list {
          tailf:info "'no mac-address-table learning vlan' entry";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key id;
          leaf id {
            type uint16 {
              tailf:info "<1-4094>;;VLAN ID";
              range "1..4094";
            }
          }
          leaf module {
            tailf:info "Layer 2 table learning per VLAN per module";
            type uint8 {
              tailf:info "<1-9>;;Module";
              range "1..9";
            }
          }
        }
      }
    }

    // mac-address-table static * vlan *
    list static {
      tailf:info "static keyword";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-incomplete-command;
      key "id vlan";
      leaf id {
        type string {
          tailf:info "H.H.H;;48 bit mac address";
        }
      }
      leaf vlan {
        tailf:info "VLAN keyword";
        tailf:cli-expose-key-name;
        type uint16 {
          tailf:info "<1-4094>;;VLAN id of mac address table";
          range "1..4094";
        }
      }
      choice table-choice {
        // mac-address-table static * vlan * drop
        leaf drop {
          tailf:info "drop frames";
          type empty;
        }

        // mac-address-table static * vlan * interface *
        container interface {
          tailf:info "interface";
          tailf:cli-delete-when-empty;
          tailf:cli-reset-container;
          presence true;
          leaf-list list {
            tailf:cli-drop-node-name;
            tailf:cli-flat-list-syntax;
            type string {
              tailf:info "WORD;;Interface name";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// mac
  /// ========================================================================

  container mac {
    tailf:info "Global MAC configuration subcommands";

    // mac access-list extended *
    container access-list {
      tailf:info "Named access-list";
      list extended {
        tailf:info "Extended Access List";
        tailf:cli-mode-name "config-ext-macl";
        tailf:cli-full-command;
        tailf:cli-explicit-exit;
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;access-list name";
          }
        }
        list entry {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-show-long-obu-diffs;
          ordered-by user;
          key rule;
          leaf rule {
            tailf:cli-drop-node-name;
            tailf:cli-multi-word-key;
            type string {
              tailf:info "deny;;Specify packets to reject || permit;;Specify packets to forwards";
              pattern "(permit .*)|(deny .*)";
            }
          }
        }
      }
    }

    // mac address-table
    container address-table {
      tailf:info "Configure the MAC address table";
      tailf:cli-diff-dependency "../../interface";

      // mac address-table aging-time
      leaf aging-time {
        tailf:info "Set MAC address table entry maximum age";
        tailf:cli-full-command;
        type union {
          type uint32 {
            tailf:info "<0-0>;;Enter 0 to disable aging";
            range "0";
          }
          type uint32 {
            tailf:info "<10-1000000>;;Aging time in seconds";
            range "10..1000000";
          }
        }
      }

      // mac address-table aging-time ? vlan *
      container aging-time-vlan {
        tailf:cli-drop-node-name;
        list aging-time {
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key vlan;
          leaf vlan {
            tailf:cli-expose-key-name;
            type uint16 {
              tailf:info "<1-4094>;;Vlan interface number";
              range "1..4094";
            }
          }
          leaf aging-time {
            tailf:cli-drop-node-name;
            tailf:cli-prefix-key;
            type union {
              type uint32 {
                tailf:info "<0-0>;;Enter 0 to disable aging";
                range "0";
              }
              type uint32 {
                tailf:info "<10-1000000>;;Aging time in seconds";
                range "10..1000000";
              }
            }
          }
        }
      }

      // mac address-table notification
      container notification {
        tailf:info "Enable/Disable MAC Notification on the switch";
        leaf change {
          tailf:info "Enable/Disable MAC Notification feature on the switch";
          type empty;
        }
        leaf mac-move {
          tailf:info "Enable Mac Move Notification";
          type empty;
        }
      }

      // mac address-table move update
      container move {
        tailf:info "Move keyword";
        container update {
          tailf:info "Notification keyword";
          leaf transmit {
            tailf:info "Transmit keyword";
            type empty;
          }
          leaf receive {
            tailf:info "Receive keyword";
            type empty;
          }
        }
      }

      // mac address-table static * vlan *
      list static {
        tailf:info "static keyword";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key "id vlan";
        leaf id {
          type string {
            tailf:info "H.H.H;;48 bit mac address";
          }
        }
        leaf vlan {
          tailf:info "VLAN keyword";
          tailf:cli-expose-key-name;
          type uint16 {
            tailf:info "<1-4094>;;VLAN id of mac address table";
            range "1..4094";
          }
        }
        choice table-choice {
          // mac address-table static * vlan * drop
          leaf drop {
            tailf:info "drop frames";
            type empty;
          }
          // mac address-table static * vlan * interface *
          leaf-list interface {
            tailf:info "interface";
            tailf:cli-flat-list-syntax;
            type string {
              tailf:info "WORD;;Interface name";
            }
          }
        }
      }

      // no mac address-table learning vlan *
      // mac address-table learning vlan no-list *
      container learning {
        tailf:info "Enable a MAC table learning feature";
        container vlan {
          tailf:info "Layer 2 table learning per VLAN";
          list no-list {
            tailf:info "'no mac address-table learning vlan' entry";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key id;
            leaf id {
              type uint16 {
                tailf:info "<1-4094>;;VLAN ID";
                range "1..4094";
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// wireless
  /// ========================================================================

  container wireless {
    tailf:info "Configure wireless parameters";

    // wireless mobility
    container mobility {
      tailf:info "Configure the Inter-Switch Mobility Manager";

      // wireless mobility group name
      container group {
        tailf:info "Configures the Mobility group parameters";
        leaf name {
          tailf:info "Configures the Mobility domain name";
          type string {
            tailf:info "WORD;;Enter ASCII String up to 31 characters, case sensitive";
          }
        }
      }
    }

    // wireless aaa policy *
    container aaa {
      tailf:info "AAA policy configurations";
      list policy {
        tailf:info "Create new AAA Policy";
        tailf:cli-mode-name "config-aaa-policy";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Enter Wireless AAA Policy name";
          }
        }

        // wireless aaa policy * / aaa-realm enable
        container aaa-realm {
          tailf:info "AAA radius selection by realm";
          leaf enable {
            tailf:info "Enable aaa-realm on the wlan-config policy";
            type empty;
          }
        }
      }
    }

    // wireless cts-sxp profile *
    container cts-sxp {
      tailf:info "cts-sxp policy configurations";
      list profile {
        tailf:info "Create new CTS-SXP Profile";
        tailf:cli-mode-name "config-cts-sxp-profile";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Enter CTS-SXP Profile name";
          }
        }
      }
    }

    // wireless ipv6
    container ipv6 {
      tailf:info "Global wireless IPv6 configurations";

      // no wireless ipv6 ra wired
      container ra {
        tailf:info "Configure wireless IPv6 RA parameters";
        leaf wired {
          tailf:info "Enable forwarding of Router Advertisement message to wired clients";
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }
      }
    }

    // wireless management
    container management {
      tailf:info "Configure wireless management parameters";

      // wireless management trustpoint
      leaf trustpoint {
        tailf:info "Select a trustpoint to configure";
        type string {
          tailf:info "WORD;;Enter trustpoint name";
        }
      }

      // wireless management interface
      container interface {
        tailf:info "Select an interface to configure";
        uses interface-name-grouping;
      }
    }

    // wireless profile
    container profile {
      tailf:info "Configure profile parameters";

      // wireless profile ap
      container ap {
        tailf:info "Configures AP profiles";

        // wireless profile ap packet-capture *
        list packet-capture {
          tailf:info "Configure ap packet capture";
          tailf:cli-mode-name "config-packet-capture";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Enter ap packet capture profile name";
            }
          }

          // wireless profile ap packet-capture * / description
          leaf description {
            tailf:info "Add a description";
            type string {
              tailf:info "WORD;;Description";
            }
          }
        }
      }

      // wireless profile airtime-fairness *
      list airtime-fairness {
        tailf:info "Create new ATF-policy";
        tailf:cli-mode-name "config-config-atf";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Enter atf-profile name";
          }
        }
        leaf id {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          tailf:cli-remove-before-change;
          type uint16 {
            tailf:info "<0-511>;;Enter atf-profile ID";
            range "0..511";
          }
        }
      }

      // wireless profile flex *
      list flex {
        tailf:info "Create new flex-policy";
        tailf:cli-mode-name "config-wireless-flex-profile";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Enter flex-profile name (default flex profile name:default-flex-profile)";
          }
        }

        // wireless profile flex * / description
        leaf description {
          tailf:info "Add a description";
          type string {
            tailf:info "WORD;;Description";
          }
        }
      }

      // wireless profile mesh *
      list mesh {
        tailf:info "Configure mesh profile";
        tailf:cli-mode-name "config-wireless-mesh-profile";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Enter mesh profile name(default mesh profile name:default-mesh-profile)";
          }
        }

        // wireless profile mesh * / description
        leaf description {
          tailf:info "Add a description";
          type string {
            tailf:info "WORD;;Description";
          }
        }
      }

      // wireless profile policy *
      list policy {
        tailf:info "Configure WLAN policy profile";
        tailf:cli-mode-name "config-wireless-policy";
        ios:shutdown-before-modify "shutdown" {
          cli:arguments "boolean-no";
        }
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of WLAN policy profile (default policy profile name:default-policy-profile)";
          }
        }

        // wireless profile policy * / description
        leaf description {
          tailf:info "Add a description";
          type string {
            tailf:info "WORD;;Description";
          }
        }

        // wireless profile policy * / aaa-override
        leaf aaa-override {
          tailf:info "AAA policy override";
          type empty;
        }

        // wireless profile policy * / accounting-list
        leaf accounting-list {
          tailf:info "Accounting configuration";
          type string {
            tailf:info "WORD;;Accounting configuration";
          }
        }

        // wireless profile policy * / no exclusionlist
        leaf exclusionlist {
          tailf:info "Set exclusion-listing on WLAN";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }

        // wireless profile policy * / exclusionlist timeout
        container exclusionlist-conf {
          tailf:cli-drop-node-name;
          container exclusionlist {
            tailf:info "Set exclusion-listing on WLAN";
            tailf:cli-incomplete-command;
            tailf:cli-incomplete-no;
            leaf timeout {
              tailf:info "Set time the client will be excluded";
              type uint32 {
                tailf:info "<0-2147483647>;;Exclusion-list timeout (in seconds). Zero (0) for no timeout.";
              }
            }
          }
        }

        // wireless profile policy * / mdns-sd service-policy
        container mdns-sd {
          tailf:info "Configure mDNS related parameters";
          leaf service-policy {
            tailf:info "Configure mdns service-policy";
            type string {
              tailf:info "WORD;;Configure mdns service-policy name(default name: default-mdns-service-policy)";
            }
          }
        }

        // wireless profile policy * / nac
        leaf nac {
          tailf:info "Configures Radius NAC support(Identity Service Engine).";
          type empty;
        }

        // wireless profile policy * / service-policy
        container service-policy {
          tailf:info "Configure WLAN QOS or Local Profiling  Service Policy";
          uses service-policy-grouping;
        }

        // wireless profile policy * / vlan
        leaf vlan {
          tailf:info "Configure vlan name or vlan Id";
          type string {
            tailf:info "WORD;;Enter Vlan";
          }
        }

        // wireless profile policy * / session-timeout
        leaf session-timeout {
          tailf:info "Configures client Session timeout";
          type uint32 {
            tailf:info "<0-86400>;;The duration of session in seconds, Zero (0) for disable session timeout";
          }
        }

        // wireless profile policy * / no shutdown
        leaf shutdown {
          tailf:info "Disable policy profile";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          cli:ned-diff-add "=shutdown :: first";
          type boolean;
          default true;
        }
      }
    }

    // wireless rfid timeout
    container rfid {
      tailf:info "Configure wireless rfid parameters";
      leaf timeout {
        tailf:info "Configure the static RFID tag data timeout";
        type uint16 {
          tailf:info "<60-7200>;;timeout value to cleanup table (default 1200)";
          range "60..7200";
        }
        default 1200;
      }
    }

    // wireless tag
    container tag {
      tailf:info "Configure tag parameters";
      tailf:cli-explicit-exit;

      // wireless tag site *
      list site {
        tailf:info "Configure site tag";
        tailf:cli-mode-name "config-site-tag";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Enter Site-tag name(default site tag name:default-site-tag)";
          }
        }

        // wireless tag site * / description
        leaf description {
          tailf:info "Add a description";
          type string {
            tailf:info "WORD;;Description";
          }
        }

        // wireless tag site * / ap-profile
        leaf ap-profile {
          tailf:info "Configure AP join profile";
          tailf:non-strict-leafref {
            path "../../../../ap/profile/name";
          }
          type string {
            tailf:info "WORD;;Enter AP join profile name";
          }
        }

        // wireless tag site * / flex-profile
        leaf flex-profile {
          tailf:info "Configure flex profile";
          cli:ned-diff-move-after "=no local-site" {
            cli:arguments "when-set";
          }
          tailf:non-strict-leafref {
            path "../../../profile/flex/name";
          }
          type string {
            tailf:info "WORD;;name of the flex profile";
          }
        }

        // wireless tag site * / no local-site
        leaf local-site {
          tailf:info "Configure this site as local site";
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }
      }

      // wireless tag policy *
      list policy {
        tailf:info "Configure policy tag";
        tailf:cli-mode-name "config-policy-tag";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of policy tag(default policy tag:default-policy-tag)";
          }
        }

        // wireless tag policy * / description
        leaf description {
          tailf:info "Add a description";
          type string {
            tailf:info "WORD;;Description";
          }
        }

        // wireless tag policy * / wlan * policy
        list wlan {
          tailf:info "Map a WLAN profile to a policy profile";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Name of the WLAN profile";
            }
          }
          leaf policy {
            tailf:info "Map a policy profile to a WLAN profile";
            tailf:non-strict-leafref {
              path "../../../../profile/policy/name";
            }
            type string {
              tailf:info "WORD;;Name of the policy profile";
            }
          }
        }
      }

      // wireless tag rf *
      list rf {
        tailf:info "Configure RF tag";
        tailf:cli-mode-name "config-wireless-rf-tag";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of the RF tag";
          }
        }

        // wireless tag rf * / description
        leaf description {
          tailf:info "Add a description";
          type string {
            tailf:info "WORD;;Description";
          }
        }

        // wireless tag rf * / 5ghz-rf-policy
        leaf fiveghz-rf-policy {
          tailf:info "Configure dot11a policy";
          tailf:alt-name "5ghz-rf-policy";
          tailf:non-strict-leafref {
            path "../../../../ap/dot11/fiveghz/rf-profile/name";
          }
          type string {
            tailf:info "WORD;;Name of the dot11a policy";
          }
        }
      }
    }

    // wireless wps
    container wps {
      tailf:info "Global WPS settings";

      // wireless wps rogue
      container rogue {
        tailf:info "Configures rogue devices";

        // wireless wps rogue ap
        container ap {
          tailf:info "Configure rogue access points";

          // wireless wps rogue ap rldp
          container rldp {
            tailf:info "Configure Rogue Location Discovery Protocol";

            // wireless wps rogue ap rldp alarm-only
            container alarm-only {
              tailf:info "Set RLDP and alarm if rogue is detected";
              tailf:cli-reset-container;
              tailf:cli-delete-when-empty;
              presence true;
              leaf monitor-ap-only {
                tailf:info "Perform RLDP only on monitor AP";
                type empty;
              }
            }
          }
        }

        // wireless wps rogue rule * priority
        list rule {
          tailf:info "Configure rogue classification rules";
          tailf:cli-mode-name "config-rule";
          key name;
          unique priority;
          leaf name {
            type string {
              tailf:info "WORD;;Rogue classification rule name";
            }
          }
          leaf priority {
            tailf:info "Rule priority";
            tailf:cli-hide-in-submode;
            type uint16 {
              tailf:info "<1 - 512>;;Rule priority value. Low values have high priority";
              range "1..512";
            }
          }

          // wireless wps rogue rule * / classify
          container classify {
            tailf:info "Classifies a rule";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf type {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type enumeration {
                enum custom {
                  tailf:info "Classifies devices matching this rule as custom";
                }
                enum friendly {
                  tailf:info "Classifies devices matching this rule as friendly";
                }
                enum malicious {
                  tailf:info "Classifies devices matching this rule as malicious";
                }
              }
            }
            leaf state {
              tailf:info "Final state if rule is matched";
              type enumeration {
                enum alert {
                  tailf:info "Alert mode";
                }
                enum contained {
                  tailf:info "Contain the rogue AP";
                }
                enum external {
                  tailf:info "Acknowledge the presence of a rogue access point";
                }
                enum internal {
                  tailf:info "Trust a foreign access point";
                }
              }
            }
          }

          // wireless wps rogue rule * / condition
          container condition {
            tailf:info "Configure a condition";

            // wireless wps rogue rule * / condition duration
            leaf duration {
              tailf:info "Requires that the rogue has been detected for a minimum period of time";
              type uint16 {
                tailf:info "<0-3600>;;Enter minimum duration in seconds";
                range "0..3600";
              }
            }

            // wireless wps rogue rule * / condition rssi
            leaf rssi {
              tailf:info "Requires a RSSI value. This is the maximum threshold for Friendly classification, minimum otherwise";
              type int8 {
                tailf:info "<-128 - 0>;;Enter rssi value in dBm";
              }
            }

            // wireless wps rogue rule * / condition infrastructure ssid
            container infrastructure {
              tailf:info "Requires the SSID to be known to the controller";
              leaf ssid {
                tailf:info "SSID";
                type empty;
              }
            }
          }

          // wireless wps rogue rule * / match
          leaf match {
            tailf:info "Configure matching criteria for a rule";
            type enumeration {
              enum all {
                tailf:info "Requires all conditions to be met for the rule to be matched";
              }
              enum any {
                tailf:info "Requires any one condition to be met for the rule to be matched";
              }
            }
            default any;
          }

          // wireless wps rogue rule * / no shutdown
          leaf shutdown {
            tailf:info "Shutdown";
            tailf:cli-boolean-no;
            type boolean;
            default true;
          }
        }
      }
    }

    // wireless client
    container client {
      tailf:info "Configure client parameters";

      // wireless client onboarding-event
      leaf onboarding-event {
        tailf:info "Enable client onboarding event";
        type empty;
      }
    }

    // wireless rf-network
    leaf rf-network {
      tailf:info "Sets the RF-Network Name";
      type string {
        tailf:info "WORD;;Enter ASCII String up to 19 characters, case sensitive";
      }
    }

    // wireless security
    container security {
      tailf:info "Configure wireless security";

      // wireless security dot1x
      container dot1x {
        tailf:info "IEEE 802.1X wireless global configuration commands";

        // wireless security dot1x eapol-key
        container eapol-key {
          tailf:info "Configure eapol-key related parameters";

          // wireless security dot1x eapol-key retries
          leaf retries {
            tailf:info "Maximum number of EAPOL key retries";
            type uint8 {
              tailf:info "<0-4>;;Enter the maximum EAPOL key retries value";
              range "0..4";
            }
            default 2;
          }

          // wireless security dot1x eapol-key timeout
          leaf timeout {
            tailf:info "Timeout for EAPOL key retransmission";
            type uint16 {
              tailf:info "<200-5000>;;EAPOL key retransmission timeout value in milliseconds";
              range "200..5000";
            }
            default 1000;
          }
        }

        // wireless security dot1x identify-request
        container identity-request {
          tailf:info "Configure EAP ID request related parameters";

          // wireless security dot1x identity-request retries
          leaf retries {
            tailf:info "Maximum number of EAP ID request retries";
            type uint8 {
              tailf:info "<1-20>;;Maximum number of EAP ID request retransmissions";
              range "1..20";
            }
            default 2;
          }

          // wireless security dot1x identity-request timeout
          leaf timeout {
            tailf:info "no description";
            type uint8 {
              tailf:info "<1-120>;;EAP ID request-timeout value in seconds";
              range "1..120";
            }
            default 30;
          }
        }

        // wireless security dot1x request
        container request {
          tailf:info "Configure EAP request related parameters";

          // wireless security dot1x request retries
          leaf retries {
            tailf:info "Maximum number of EAP  request retries";
            type uint8 {
              tailf:info "<0-20>;;Maximum number of EAP request retransmissions";
              range "0..20";
            }
            default 2;
          }

          // wireless security dot1x request timeout
          leaf timeout {
            tailf:info "Timeout for EAP request";
            type uint8 {
              tailf:info "<1-120>;;EAP request retransmission timeout value in seconds";
              range "1..120";
            }
            default 30;
          }
        }
      }
    }

    // wireless multicast
    container multicast {
      tailf:info "Enable Ethernet Multicast Support";
      leaf address {
        tailf:cli-drop-node-name;
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Enter multicast-over-multicast IPv4 Address";
        }
      }
    }

    // wireless fabric
    container fabric {
      tailf:info "Enable wireless fabric mode";

      // wireless fabric control-plane *
      list control-plane {
        tailf:info "Configure control plane details";
        tailf:cli-mode-name "config-wireless-cp";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Configure control plane name (default control plane name:default-control-plane) ";
          }
        }
      }
    }

    // wireless country *
    list country {
      tailf:info "Configure country code";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Country code";
        }
      }
    }
  }


  /// ========================================================================
  /// nmsp
  /// ========================================================================

  container nmsp {
    tailf:info "Configures NMSP parameters";

    // nmsp enable
    leaf enable {
      tailf:info "Enable NMSP on premises services";
      type empty;
    }
  }


  /// ========================================================================
  /// wlan
  /// ========================================================================

  container wlan {
    tailf:info "Configures the Wireless LAN Network";

    // wlan *
    list list {
      tailf:cli-drop-node-name;
      tailf:cli-mode-name "config-apgroup";
      ios:shutdown-before-modify "shutdown" {
        cli:arguments "boolean-no";
      }
      key name;
      leaf name {
        tailf:cli-incomplete-command;
        tailf:cli-disallow-value "shutdown";
        type string {
          tailf:info "WORD;;Enter Profile Name up to 32 alphanumeric characters";
        }
      }
      leaf wlan-id {
        tailf:cli-drop-node-name;
        tailf:cli-hide-in-submode;
        type uint16 {
          tailf:info "<1-4096>;;Create WLAN Identifier";
          range "1..4096";
        }
      }
      leaf ssid {
        tailf:cli-drop-node-name;
        tailf:cli-hide-in-submode;
        tailf:cli-remove-before-change;
        type string {
          tailf:info "WORD;;Enter SSID (Network Name) up to 32 alphanumeric characters";
        }
      }

      // wlan * / description
      leaf description {
        tailf:info "Add a description";
        type string {
          tailf:info "WORD;;Description";
        }
      }

      // wlan * / band-select
      leaf band-select {
        tailf:info "Allow|Disallow Band Select on a WLAN.";
        type empty;
      }

      // wlan * / security
      container security {
        tailf:info "Configures the security policy for a WLAN";

        // wlan * / security wpa
        container wpa {
          tailf:info "Configures WPA/WPA2 Support for a WLAN";
          container akm {
            tailf:info "Configures Auth Key Management";

            // wlan * / no security wpa akm dot1x
            leaf dot1x {
              tailf:info "802.1x support";
              tailf:cli-boolean-no;
              type boolean;
              default true;
            }
          }
        }

        // wlan * / security dot1x
        container dot1x {
          tailf:info "Configures 802.1X";

          // wlan * / security dot1x authentication-list
          leaf authentication-list {
            tailf:info "Sets the authentication list for IEEE 802.1x";
            tailf:cli-diff-dependency "../../../../../aaa/authentication/dot1x/name";
            type string {
              tailf:info "WORD;;Enter the Authentication list name";
            }
          }
        }
      }

      // wlan * / dtim dot11
      container dtim {
        tailf:info "Set the DTIM period for the WLAN";
        container dot11 {
          tailf:info "Configures 802.11 parameters";

          // wlan * / dtim dot11 5ghz
          leaf fiveghz {
            tailf:info "Set the DTIM period for 802.11a radio for the WLAN";
            tailf:alt-name "5ghz";
            type uint8 {
              tailf:info "<1-255>;;DTIM Period";
              range "1..255";
            }
          }
        }
      }

      // wlan * / radio
      leaf radio {
        tailf:info "Configures the Radio Policy";
        type enumeration {
          enum dot11a {
            tailf:info "Configures the WLAN on 802.11a only";
          }
          enum dot11ag {
            tailf:info "Configures the WLAN on 802.11a and 802.11g only";
          }
          enum dot11bg {
            tailf:info "Configures the WLAN on 802.11b/g only (802.11b only, if 802.11g is disabled)";
          }
          enum dot11g {
            tailf:info "Configures the WLAN on 802.11g only";
          }
        }
      }

      // wlan * / mac-filtering
      leaf mac-filtering {
        tailf:info "Set MAC filtering support on WLAN";
        tailf:cli-diff-dependency "../../../aaa/authorization/network/name";
        type string {
          tailf:info "WORD;;Authorization list name";
        }
      }

      // wlan * / channel-scan
      container channel-scan {
        tailf:info "Configures off channel scanning deferral parameters";

        // wlan * / channel-scan defer-priority
        leaf defer-priority {
          tailf:info "Configures priority markings for packets";
          type uint8 {
            tailf:info "<0-7>;;Enable priority";
            range "0..7";
          }
        }
      }

      // wlan * / no shutdown
      leaf shutdown {
        tailf:info "Disable WLAN";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        cli:ned-diff-add "=shutdown :: first";
        type boolean;
        default true;
      }
    }
  }


  /// ========================================================================
  /// ap
  /// ========================================================================

  container ap {
    tailf:info "Configures Cisco APs";

    // ap dot11
    container dot11 {
      tailf:info "Configures 802.11 parameters";

      // ap dot11 airtime-fairness policy-name *
      container airtime-fairness {
        tailf:info "Configures airtime-fairness policy.";
        list policy-name {
          tailf:info "Configure airtime-fairness policy";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Enter the airtime-fairness policy name";
            }
          }
          leaf id {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<0-511>;;Enter airtime-fairness policy id to create new policy";
              range "0..511";
            }
          }
        }
      }

      // ap dot11 24ghz
      container twentyfourghz {
        tailf:info "Configures 802.11b parameters";
        tailf:alt-name "24ghz";
        ios:ap-dot11-shutdown "24ghz";
        uses ap-dot11-ghz-grouping;
      }

      // ap dot11 5ghz
      container fiveghz {
        tailf:info "Configures 802.11a parameters";
        tailf:alt-name "5ghz";
        ios:ap-dot11-shutdown "5ghz";
        uses ap-dot11-ghz-grouping;
      }
    }

    // ap fra
    container fra {
      tailf:info "Enable/Disable Fra on all Cisco APs";

      // ap fra interval
      leaf interval {
        tailf:info "Configure Fra Interval in hours";
        type uint8 {
          tailf:info "<1-24>;;Enter number of hours";
          range "1..24";
        }
      }
    }

    // ap country
    leaf country {
      tailf:info "Configure the country of operation (deprecated";
      tailf:cli-diff-set-before "../dot11";
      ios:ap-dot11-shutdown;
      type string {
        tailf:info "WORD;;Enter the country code (e.g. US,MX,IN) upto a maximum of 20 countries (deprecated)";
      }
    }

    // ap tag-source-priority * source
    list tag-source-priority {
      tailf:info "Configure ap tag source priority";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-incomplete-command;
      key id;
      leaf id {
        type uint8 {
          tailf:info "<2-3>;;Enter the ap tag source priority";
        }
      }
      leaf source {
        tailf:info "Specifiy the source for which priority is been set";
        type enumeration {
          enum ap {
            tailf:info "AP as tag source ";
          }
          enum filter {
            tailf:info "Ap filter as tag source ";
          }
        }
      }
    }

    // ap group *
    list group {
      tailf:info "Manage AP Groups VLAN feature";
      tailf:cli-mode-name "config-apgroup";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Specify the name of the apgroup to configure";
        }
      }
    }

    // ap profile *
    list profile {
      tailf:info "Configure ap-profile";
      tailf:cli-mode-name "config-ap-profile";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Enter ap-profile name (default ap join profile name: default-ap-profile)";
        }
      }

      // ap profile * / description
      leaf description {
        tailf:info "Add a description";
        type string {
          tailf:info "WORD;;Description";
        }
      }

      // ap profile * / packet-capture
      leaf packet-capture {
        tailf:info "Configure packet capture profile";
        type string {
          tailf:info "WORD;;Enter profile name";
        }
      }

      // ap profile * / preferred-mode
      leaf preferred-mode {
        tailf:info "Select preferred mode of APs";
        type enumeration {
          enum disable {
            tailf:info "Disable preferred-mode";
          }
          enum ipv4 {
            tailf:info "Use IPv4 to join the controller";
          }
          enum ipv6 {
            tailf:info "Use IPv6 to join the controller";
          }
        }
        default disable;
      }

      // ap profile * / rogue detection
      container rogue {
        tailf:info "Enable/Disable rogue for all APs in this profile";
        container detection {
          tailf:info "Configure rogue detection settings";

          // ap profile * / rogue detection min-rssi
          leaf min-rssi {
            tailf:info "Configure rogue report minimum RSSI for Cisco APs.";
            type int8 {
              tailf:info "<-128 - -70>;;Enter the minimum RSSI in db";
            }
          }
        }
      }

      // ap profile * / tcp-adjust-mss
      container tcp-adjust-mss {
        tailf:info "Enable/Disable TCP MSS configuration for all Cisco APs";

        // ap profile * / tcp-adjust-mss size
        leaf size {
          tailf:info "TCP MSS configuration size";
          type uint16 {
            tailf:info "<536-1363>;;Enter the TCP MSS value(IPv4: 536 - 1363, IPv6: 1220 - 1331) for all Cisco APs";
            range "536..1363";
          }
        }
      }

      // ap profile * / capwap
      container capwap {
        tailf:info "ap capwap parameters";

        // ap profile * / capwap backup
        container backup {
          tailf:info "Configures controller backup";

          // ap profile * / capwap backup primary
          container primary {
            tailf:info "Configures primary Controller";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf wlc-name {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "WORD;;Enter Controller name";
              }
            }
            leaf wlc-ip {
              tailf:cli-drop-node-name;
              type union {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Enter Controller IP address";
                }
                type inet:ipv6-address {
                  tailf:info "X:X:X:X::X;;Enter Controller IP address";
                }
              }
            }
          }

          // ap profile * / capwap backup secondary
          container secondary {
            tailf:info "Configures secondary Controller";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf wlc-name {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "WORD;;Enter Controller name";
              }
            }
            leaf wlc-ip {
              tailf:cli-drop-node-name;
              type union {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Enter Controller IP address";
                }
                type inet:ipv6-address {
                  tailf:info "X:X:X:X::X;;Enter Controller IP address";
                }
              }
            }
          }
        }

        // ap profile * / no capwap fallback
        leaf fallback {
          tailf:info "Configures AP fallback";
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }
      }

      // ap profile * / mgmtuser
      container mgmtuser {
        tailf:info "Configure the user for AP management";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf username {
          tailf:info "Configures the username for AP management";
          tailf:cli-incomplete-command;
          type string {
            tailf:info "WORD;;Enter the username";
          }
        }
        container password {
          tailf:info "Configure the password for AP management";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          leaf type {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type enumeration {
              enum 0 {
                tailf:info "Specifies an UNENCRYPTED password will follow.";
              }
              enum 8 {
                tailf:info "Specifies an AES encrypted password will follow.";
              }
            }
          }
          leaf password {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;Enter the password";
            }
          }
        }
        container secret {
          tailf:info "Configure the secret for privileged AP management";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          leaf type {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type enumeration {
              enum 0 {
                tailf:info "Specifies an UNENCRYPTED password will follow.";
              }
              enum 8 {
                tailf:info "Specifies an AES encrypted password will follow.";
              }
            }
          }
          leaf secret {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;Enter the secret";
            }
          }
        }
      }

      // ap profile * / ssh
      leaf ssh {
        tailf:info "Enable SSH (If the AP user management credentials are non default)";
        type empty;
      }
    }

    // ap *
    list mac-address {
      tailf:cli-drop-node-name;
      tailf:cli-mode-name "config-ap-tag";
      key address;
      leaf address {
        type string {
          pattern "[0-9a-f]{4}(\\.[0-9a-f]{4}){2}";
          tailf:info "H.H.H;;Ethernet MAC address of the AP";
        }
      }

      // ap * / policy-tag
      leaf policy-tag {
        tailf:info "Map a Policy tag to the AP(AP will re-join)";
        type string {
          tailf:info "WORD;;Name of the policy tag(default:default-policy-tag)";
        }
      }

      // ap * / rf-tag
      leaf rf-tag {
        tailf:info "Map a RF tag to the AP(AP will re-join)";
        type string {
          tailf:info "WORD;;Name of the RF tag(default:default-rf-tag)";
        }
      }

      // ap * / site-tag
      leaf site-tag {
        tailf:info "Map a Site tag to the AP(AP will re-join)";
        type string {
          tailf:info "WORD;;Name of the site tag(default:default-site-tag)";
        }
      }
    }
  }


  /// ========================================================================
  /// app-hosting
  /// ========================================================================

  container app-hosting {
    tailf:info "Application hosting configuration mode";

    // app-hosting appid *
    list appid {
      tailf:info "Enter Application Name up to 40 alphanumeric characters";
      tailf:cli-mode-name "config-app-hosting";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;no description";
        }
      }

      // app-hosting appid * / app-vnic
      container app-vnic {
        tailf:info "Virtual Network Interface";

        // app-hosting appid * / app-vnic gateway*
        list gateway {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          key name;
          leaf name {
            type enumeration {
              enum gateway0 {
                 tailf:info "Application Network Gateway0";
              }
              enum gateway1 {
                 tailf:info "Application Network Gateway1";
              }
              enum gateway2 {
                 tailf:info "Application Network Gateway2";
              }
              enum gateway3 {
                 tailf:info "Application Network Gateway3";
              }
            }
          }
          leaf virtualportgroup {
            tailf:info "VirtualPortGroupN(0..31) for Gateway1";
            tailf:cli-hide-in-submode;
            type string {
              tailf:info "WORD;;Virtualportgroup# ";
            }
          }
          leaf guest-interface {
            tailf:info "EthN(0..3) as Gateway1";
            tailf:cli-hide-in-submode;
            type string {
              tailf:info "WORD;;Application Network Interface #(0..3)";
            }
          }
        }
      }

      // app-hosting appid * / app-resource profile *
      container app-resource {
        tailf:info "Application resources";
        list profile {
          tailf:info "Application profile name";
          tailf:cli-mode-name "config-app-resource-profile";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Application profile name";
            }
          }

          // app-hosting appid * / app-resource profile * / cpu
          leaf cpu {
            tailf:info "Application cpu units/share quota ";
            type uint16 {
              tailf:info "<0-20000>;;Application cpu units/share quota ";
              range "0..20000";
            }
          }

          // app-hosting appid * / app-resource profile * / memory
          leaf memory {
            tailf:info "Memory reservation MB units";
            type uint16 {
              tailf:info "<0-4096>;;Memory reservation MB units";
              range "0..4096";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// time-range
  /// ========================================================================

  // time-range *
  list time-range {
    tailf:info "Define time range entries";
    tailf:cli-mode-name "config-time-range";
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;Time range name";
      }
    }

    // time-range * / absolute
    container absolute {
      tailf:info "absolute time and date";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      container start {
        tailf:info "starting time and date";
        tailf:cli-optional-in-sequence;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        uses time-range-abs-grouping;
      }
      container end {
        tailf:info "end time and date";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        uses time-range-abs-grouping;
      }
    }
  }

  grouping time-range-abs-grouping {
    leaf time {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type hhmm-type {
        tailf:info "hh:mm;;time";
      }
    }
    leaf date {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type uint8 {
        tailf:info "<1-31>;;Day of the month";
        range "1..31";
      }
    }
    leaf month {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type month-full-type {
        tailf:info "MONTH;;Month of the year";
      }
    }
    leaf year {
      tailf:cli-drop-node-name;
      type uint16 {
        tailf:info "<1993-2035>;;Year";
        range "1993..2035";
      }
    }
  }


  /// ========================================================================
  /// privilege
  /// ========================================================================

  container privilege {
    tailf:info "Command privilege parameters";
    ios:privilege-redeploy;

    // privilege exec
    container exec {
      tailf:info "Exec mode";
      container all {
        tailf:info "All suboption will be set to the same level";
        uses privilege-level-grouping;
      }
      uses privilege-level-grouping;
    }

    // privilege configure
    container configure {
      tailf:info "Global configuration mode";
      container all {
        tailf:info "All suboption will be set to the same level";
        uses privilege-level-grouping;
      }
      uses privilege-level-grouping;
    }

    // privilege *
    list list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      key name;
      leaf name {
        tailf:cli-disallow-value "exec|configure";
        type string {
          tailf:info "WORD;;privilege name, e.g. interface|router|etc.";
        }
      }
      container all {
        tailf:info "All suboption will be set to the same level";
        uses privilege-level-grouping;
      }
      uses privilege-level-grouping;
    }
  }

  grouping privilege-level-grouping {
    list level {
      tailf:info "Set privilege level of command";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-incomplete-command;
      tailf:cli-incomplete-no;
      tailf:cli-no-key-completion;
      key privilege;
      leaf privilege {
        tailf:cli-incomplete-no;
        tailf:cli-suppress-range;
        type uint8 {
          tailf:info "<0-15>;;Privilege level";
          range "0..15";
        }
      }
      list command-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-no-key-completion;
        tailf:cli-suppress-key-abbreviation;
        tailf:cli-no-match-completion;
        key command;
        leaf command {
          tailf:cli-multi-word-key;
          tailf:cli-suppress-range;
          type string {
            tailf:info "LINE;;Initial keywords of the command to modify";
          }
        }
      }
    }
  }

  /// ========================================================================
  /// default-value
  /// ========================================================================

  container default-value {
    tailf:info "Default character-bits values";

    // default-value special-character-bits
    leaf special-character-bits {
      tailf:info "Size of the escape (and other special) characters";
      type uint8 {
        tailf:info "<7-8>;;Bits per character";
        range "7..8";
      }
    }
  }


  /// ========================================================================
  /// spanning-tree
  /// ========================================================================

  container spanning-tree {
    tailf:info "Spanning Tree Subsystem";

    // spanning-tree etherchannel
    container etherchannel {
      tailf:info "Spanning tree etherchannel specific configuration";
      container guard {
        tailf:info "Configure guard features for etherchannel";
        leaf misconfig {
          tailf:info "Enable guard to protect against etherchannel misconfiguration";
          type empty;
        }
      }
    }

    // spanning-tree logging
    leaf logging {
      tailf:info "Enable Spanning tree logging";
      type empty;
    }

    // spanning-tree extend system-id
    container extend {
      tailf:info "Spanning Tree 802.1t extensions";
      leaf system-id {
        tailf:info "Extend system-id into priority portion of the bridge id (PVST & Rapid PVST only)";
        type empty;
      }
    }

    // spanning-tree backbonefast
    leaf backbonefast {
      tailf:info "Enable BackboneFast Feature";
      type empty;
    }

    // spanning-tree loopguard
    container loopguard {
      tailf:info "Spanning tree loopguard options";
      leaf default {
        tailf:info "Enable loopguard by default on all ports";
        type empty;
      }
    }

    // spanning-tree mst
    container mst {
      tailf:info "Multiple spanning tree configuration";

      // spanning-tree mst *
      list instance-range {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        tailf:cli-range-list-syntax;
        //ios:range-list-syntax "spanning-tree mst (\\d+) \\S+ \\S+";
        key id;
        leaf id {
          type uint16 {
            tailf:info "<0-4094>;;MST instance id";
            range "0..4094";
          }
        }
        leaf priority {
          tailf:info "Set the bridge priority for the spanning tree";
          type uint16 {
            tailf:info "<0-61440>;;bridge priority in increments of 4096";
            range "0..61440";
          }
        }
      }

      // spanning-tree mst configuration
      container configuration {
        tailf:info "Enter MST configuration submode";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-mst";

        // spanning-tree mst configuration / revision
        leaf revision {
          tailf:info "Set configuration revision number";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<0-65535>;;Configuration revision number";
          }
        }

        // spanning-tree mst configuration / name
        leaf name {
          tailf:info "Set configuration name";
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;Configuration name";
          }
        }

        // spanning-tree mst configuration / instance *
        list instance {
          tailf:info "Map vlans to an MST instance";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          key id;
          leaf id {
            type uint16 {
              tailf:info "<0-4094>;;MST instance id";
              range "0..4094";
            }
          }
          leaf-list vlan {
            tailf:info "Range of vlans to add to the instance mapping";
            tailf:cli-range-list-syntax;
            type uint16 {
              tailf:info "LINE;;vlan range ex: 1-65, 72, 300 -200";
            }
          }
        }
      }

      // spanning-tree mst forward-time
      leaf forward-time {
        tailf:info "Set the forward delay for the spanning tree";
        type uint8 {
          tailf:info "<4-30>;;number of seconds for the forward delay timer";
          range "4..30";
        }
      }
    }

    // no spanning-tree optimize bpdu transmission
    container optimize {
      container bpdu {
        tailf:info "Optimize BPDU Handling";
        leaf transmission {
          tailf:info "Optimize transmission of BPDUs";
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }
      }
    }

    // spanning-tree portfast
    container portfast {
      tailf:info "Spanning tree portfast options";
      uses spanning-tree-portfast-grouping;
      container edge {
        uses spanning-tree-portfast-grouping;
      }
    }

    // spanning-tree uplinkfast max-update-rate
    container uplinkfast-conf {
      tailf:cli-drop-node-name;
      container uplinkfast {
        tailf:info "Enable UplinkFast Feature";
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        leaf max-update-rate {
          tailf:info "Rate at which station address updates are sent";
          type uint16 {
            tailf:info "<0-32000>;;Maximum number of update packets per second";
            range "0..32000";
          }
        }
      }
    }

    // spanning-tree uplinkfast
    leaf uplinkfast {
      tailf:info "Enable UplinkFast Feature";
      tailf:cli-full-command;
      type empty;
    }

    // spanning-tree pathcost method
    container pathcost {
      tailf:info "Spanning tree pathcost options";
      leaf method {
        tailf:info "Method to calculate default port path cost";
        type enumeration {
          enum long {
            tailf:info "Use 32 bit based values for default port path costs";
          }
          enum short {
            tailf:info "Use 16 bit based values for default port path costs";
          }
        }
        default short;
      }
    }

    // spanning-tree mode
    leaf mode {
      tailf:info "Spanning tree operating mode";
      tailf:cli-full-command;
      type enumeration {
        enum mst {
          tailf:info "Multiple spanning tree mode";
        }
        enum pvst {
          tailf:info "Per-Vlan spanning tree mode";
        }
        enum rapid-pvst {
          tailf:info "Per-Vlan rapid spanning tree mode";
        }
      }
    }

    // spanning-tree vlan
    container vlan {
      tailf:info "VLAN Switch Spanning Tree";

      // no spanning-tree vlan *
      list no-list {
        tailf:info "'no spanning-tree vlan' list entry";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-range-list-syntax;
        //ios:range-list-syntax "spanning-tree vlan no-list (\\d+)";
        key id;
        leaf id {
          type uint16 {
            tailf:info "<1-4094>;;Spanning tree VLAN id";
            range "1..4094";
          }
        }
      }

      // spanning-tree vlan * hello-time
      // spanning-tree vlan * priority
      // spanning-tree vlan * forward-time
      // spanning-tree vlan * max-age
      list vlan-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-range-list-syntax;
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        //ios:range-list-syntax "spanning-tree vlan (\\d+) \\S+ \\S+$";
        key id;
        leaf id {
          type uint16 {
            tailf:info "WORD;;vlan range, example: 1,3-5,7,9-11";
            range "1..4096";
          }
        }
        leaf hello-time {
          tailf:info "Set the hello interval for the spanning tree";
          type uint8 {
            tailf:info "<1-10>;;number of seconds between generation of config BPDUs";
            range "1..10";
          }
        }
        leaf priority {
          tailf:info "Set the bridge priority for the spanning tree";
          type uint16 {
            tailf:info "<0-65535>;;bridge priority";
          }
        }
        leaf forward-time {
          tailf:info "Set the forward delay for the spanning tree";
          type uint8 {
            tailf:info "<4-30>;;number of seconds for the forward delay timer";
            range "4..30";
          }
        }
        leaf max-age {
          tailf:info "Set the max age interval for the spanning tree";
          type uint8 {
            tailf:info "<6-40>;;maximum number of seconds the information in a BPDU is valid";
            range "6..40";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// lacp
  /// ========================================================================

  container lacp {
    tailf:info "LACP configuration";

    // lacp system-priority
    leaf system-priority {
      tailf:info "LACP priority for the system";
      type uint16 {
        tailf:info "<0-65535>;;Priority value. Default 32768";
      }
      default 32768;
    }
  }


  /// ========================================================================
  /// dot1x
  /// ========================================================================

  container dot1x {
    tailf:info "IEEE 802.1X Global Configuration Commands";

    // dot1x critical
    container critical {
      tailf:info "Set 802.1x Critical Authentication parameters";
      leaf eapol {
        tailf:info "Send EAPOL-Success on successful Critical Authentication";
        type empty;
      }
      container recovery {
        tailf:info "Set 802.1x Critical Authentication Recovery parameters";
        leaf delay {
          tailf:info "Set 802.1x Critical Authentication Recovery Delay period";
          type uint16 {
            tailf:info "<1-10000>;;802.1x Critical Authentication Recovery delay in milliseconds";
            range "1..10000";
          }
        }
      }
    }

    // dot1x system-auth-control
    leaf system-auth-control {
      tailf:info "Enable or Disable SysAuthControl";
      type empty;
    }
  }


  /// ========================================================================
  /// power
  /// ========================================================================

  container power {
    tailf:info "Power configure";

    // no power enable module *
    // power enable module no-list *
    container enable {
      tailf:info "module slot power control";
      container module {
        tailf:info "specify module <slot>";
        list no-list {
          tailf:info "'no power enable module' entry";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key id;
          leaf id {
            type uint8 {
              tailf:info "<1-uint8>;;module slot number";
            }
          }
        }
      }
    }

    // power redundancy-mode
    container redundancy-mode {
      tailf:info "set power supply redundancy mode";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      choice mode-choice {
        leaf combined {
          tailf:info "combine power supply outputs (no redundancy)";
          type empty;
        }
        case redundant {
          leaf redundant {
            tailf:info "either power supply can operate system (redundancy)";
            type empty;
          }
          leaf mode {
            tailf:cli-drop-node-name;
            type enumeration {
              enum "n+1" {
                tailf:info "Redundant N+1";
              }
              enum "n+n" {
                tailf:info "Redundant N+N";
              }
            }
          }
          leaf-list slot {
            tailf:cli-drop-node-name;
            tailf:cli-flat-list-syntax;
            tailf:cli-replace-all;
            ordered-by user;
            type uint8 {
              tailf:info "<1-8>;;standby slot";
            }
          }
        }
      }
    }

    // power supply autoLC
    container supply {
      tailf:info "Power supply configuration";
      container autoLC {
        tailf:info "Automatic linecard power configuration";

        // no power supply autoLC shutdown
        leaf shutdown {
          tailf:info "Linecard auto shutdown control";
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }

        // power supply autoLC priority *
        leaf-list priority {
          tailf:info "Set priority (highest to lowest) of auto linecard shutdown";
          tailf:cli-flat-list-syntax;
          tailf:cli-replace-all;
          tailf:cli-no-value-on-delete;
          ordered-by user;
          type uint8 {
            tailf:info "<1-7>;;Physical slot number";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// power-supply
  /// ========================================================================

  container power-supply {

    // power-supply dual
    container dual {
      tailf:cli-delete-when-empty;
      presence true;
      // power-supply dual dc-feed
      leaf dc-feed {
        type empty;
      }
    }
  }


  /// ========================================================================
  /// parameter-map
  /// ========================================================================

  container parameter-map {
    tailf:info "parameter map";

    // parameter-map type
    container type {
      tailf:info "parameter map type";

      // parameter-map type inspect *
      list inspect {
        tailf:info "inspect parameter-map";
        tailf:cli-mode-name "config-profile";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;parameter-map name";
          }
        }
        uses parameter-map-grouping;
      }

      // parameter-map type inspect-vrf *
      list inspect-vrf {
        tailf:info "inspect vrf parameter-map";
        tailf:cli-mode-name "config-profile";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;parameter-map name";
          }
        }
        uses parameter-map-grouping;
      }

      // parameter-map type inspect-zone *
      list inspect-zone {
        tailf:info "inspect zone parameter-map";
        tailf:cli-mode-name "config-profile";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;parameter-map name";
          }
        }
        uses parameter-map-grouping;
      }

      // parameter-map type inspect-global
      container inspect-global {
        tailf:info "Global Parameter Map Configuration";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-profile";
        uses parameter-map-grouping;
      }

      // parameter-map type regex *
      list regex {
        tailf:info "regex parameter-map";
        tailf:cli-mode-name "config-profile";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;parameter-map name";
          }
        }

        // parameter-map type regexp * / pattern *
        list pattern {
          tailf:info "Configure pattern to match";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key regexp;
          leaf regexp {
            type string {
              tailf:info "WORD;;Specify the regex pattern";
            }
          }
        }
      }

      // parameter-map type umbrella global
      container umbrella {
        tailf:info "Umbrella mode";
        container global {
          tailf:info "umbrella global parameter-map";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-profile";
          presence true;

          // parameter-map type umbrella global / token
          leaf token {
            tailf:info "Config umbrella token";
            type string {
              tailf:info "WORD;;Token value";
            }
          }

          // parameter-map type umbrella global / local-domain
          leaf local-domain {
            tailf:info "Local domain processing";
            tailf:non-strict-leafref {
              path "../../../regex/name";
            }
            type string {
              tailf:info "WORD;;Regex parameter-map name";
            }
          }

          // parameter-map type umbrella global / dnscrypt
          // parameter-map type umbrella global / no dnscrypt
          leaf dnscrypt {
            tailf:info "Enable DNSCrypt";
            tailf:cli-boolean-no;
            type boolean;
          }

          // parameter-map type umbrella global / public-key
          leaf public-key {
            tailf:info "DNSCrypt provider public key";
            type string {
              tailf:info "WORD;;Provider public key";
            }
          }

          // parameter-map type umbrella global / udp-timeout
          leaf udp-timeout {
            tailf:info "Config timeout value for UDP sessions";
            type uint8 {
              tailf:info "<1-30>;;Timeout value in seconds";
              range "1..30";
            }
          }

          // parameter-map type umbrella global / resolver
          container resolver {
            tailf:info "Anycast address";
            // parameter-map type umbrella global / resolver ipv4 *
            list ipv4 {
              tailf:info "IPv4 anycast address";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key address;
              leaf address {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IPv4 address";
                }
              }
            }
            // parameter-map type umbrella global / resolver ipv6 *
            list ipv6 {
              tailf:info "IPv6 anycast address";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key address;
              leaf address {
                type inet:ipv6-address {
                  tailf:info "X:X:X:X::X;;IPv6 address";
                }
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// vpdn
  /// ========================================================================

  container vpdn {
    tailf:info "Virtual Private Dialup Network";

    // vpdn enable
    leaf enable {
      tailf:info "Enable VPDN";
      type empty;
    }

    // vpdn authen-before-forward
    leaf authen-before-forward {
      tailf:info "Authenticate a user locally before tunnelling";
      tailf:cli-diff-dependency "../enable";
      type empty;
    }

    // vpdn session-limit
    leaf session-limit {
      tailf:info "Maximum simultaneous VPDN sessions";
      tailf:cli-diff-dependency "../enable";
      type uint32 {
        tailf:info "<1-4294967295>;;Number of sessions";
        range "1..4294967295";
      }
    }

    // vpdn search-order *
    leaf-list search-order {
      tailf:info "Configure the order to search different VPDN tunnel types";
      tailf:cli-diff-dependency "../enable";
      tailf:cli-flat-list-syntax;
      tailf:cli-replace-all;
      tailf:cli-full-command;
      ordered-by user;
      type enumeration {
        enum dnis {
          tailf:info "Tunnel based on DNIS";
        }
        enum domain {
          tailf:info "Tunnel based on domain";
        }
        enum multihop-hostname {
          tailf:info "Tunnel based on peer hostname from ingress tunnel";
        }
      }
    }
  }


  /// ========================================================================
  /// vpdn-group
  /// ========================================================================

  // vpdn-group *
  list vpdn-group {
    tailf:info "VPDN group configuration";
    key name;
    leaf name {
      tailf:cli-diff-dependency "../../vpdn/enable";
      type string {
        tailf:info "WORD;;VPDN Group name";
      }
    }

    // vpdn-group * / accept-dialin
    container accept-dialin {
      tailf:info "VPDN accept-dialin group configuration";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-vpdn-acc-in";

      // vpdn-group * / accept-dialin protocol
      leaf protocol {
        tailf:info "Tunneling protocol to be used";
        tailf:cli-no-value-on-delete;
        tailf:cli-remove-before-change;
        type enumeration {
          enum "any" {
            tailf:info "Use any protocol";
          }
          enum "l2tp" {
            tailf:info "Use L2TP";
          }
          enum "pptp" {
            tailf:info "Use PPTP";
          }
        }
      }

      // vpdn-group * / accept-dialin virtual-template
      leaf virtual-template {
        tailf:info "Virtual template to clone from";
        tailf:non-strict-leafref {
          path "../../../interface/Virtual-Template/name";
        }
        type uint16 {
          tailf:info "<1-4095>;;Virtual Template interface number";
          range "1..4095";
        }
      }
    }

    // vpdn-group * / description
    leaf description {
      tailf:info "Description for this VPDN group";
      tailf:cli-multi-value;
      tailf:cli-preformatted;
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;Description of vpdn-group (up to 60 characters)";
        length "1..60";
      }
    }

    // vpdn-group * / dsl-line-info-forwarding
    leaf dsl-line-info-forwarding {
      tailf:info "Forward DSL Line Info attributes";
      type empty;
    }

    // vpdn-group * / force-local-chap
    leaf force-local-chap {
      tailf:info "Force a CHAP challenge to be instigated locally";
      type empty;
    }

    // vpdn-group * / ip
    container ip {
      tailf:info "IP settings for tunnel";

      // vpdn-group * / ip mtu
      leaf mtu {
        tailf:info "Set IP MTU settings";
        tailf:cli-full-command;
        type enumeration {
          enum "adjust" {
            tailf:info "Automatically adjust IP MTU for virtual-access";
          }
        }
      }

      // vpdn-group * / ip pmtu
      leaf pmtu {
        tailf:info "Enable PMTU for tunnel";
        tailf:cli-full-command;
        type empty;
      }

      // vpdn-group * / ip precedence
      leaf precedence {
        tailf:info "Set IP Precedence value for tunneled traffic";
        tailf:cli-full-command;
        type enumeration {
          enum "critical" {
            tailf:info "Set critical precedence (5)";
          }
          enum "flash" {
            tailf:info "Set flash precedence (3)";
          }
          enum "flash-override" {
            tailf:info "Set flash override precedence (4)";
          }
          enum "immediate" {
            tailf:info "Set immediate precedence (2)";
          }
          enum "internet" {
            tailf:info "Set internetwork control precedence (6)";
          }
          enum "network" {
            tailf:info "Set network control precedence (7)";
          }
          enum "priority" {
            tailf:info "Set priority precedence (1)";
          }
          enum "routine" {
            tailf:info "Set routine precedence (0)";
          }
        }
        default "routine";
      }

      // vpdn-group * / ip tos
      leaf tos {
        tailf:info "Set IP ToS value for tunneled traffic";
        tailf:cli-full-command;
        type union {
          type uint8 {
            range "3|5|9..15";
          }
          type enumeration {
            enum "max-reliability" {
              tailf:info "Set max reliable ToS (2)";
            }
            enum "max-throughput" {
              tailf:info "Set max throughput ToS (4)";
            }
            enum "min-delay" {
              tailf:info "Set min delay ToS (8)";
            }
            enum "min-monetary-cost" {
              tailf:info "Set min monetary cost ToS (1)";
            }
            enum "normal" {
              tailf:info "Set normal ToS (0)";
            }
            enum "reflect" {
              tailf:info "Reflect IP payload ToS on tunnel";
            }
          }
        }
        default "normal";
      }
    }

    // vpdn-group * / l2tp
    container l2tp {
      tailf:info "L2TP specific commands";
      //tailf:cli-diff-dependency "../pptp" {
      //    tailf:cli-trigger-on-set;
      //}
      tailf:cli-diff-dependency "../accept-dialin/protocol";
      when "not(../accept-dialin/protocol='pptp')" {
        tailf:dependency "../accept-dialin/protocol";
      }
      container attribute {
        tailf:info "Configure AVP options";
        container clid {
          tailf:info "Options to apply on Calling Station Id";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }

          // vpdn-group * / l2tp attribute clid mask-method
          container mask-method {
            tailf:info "Mask characters by method";

            // vpdn-group * / l2tp attribute clid mask-method remove
            container remove {
              tailf:info "Remove CLID";
              presence true;

              // vpdn-group * / l2tp attribute clid mask-method remove match
              leaf match {
                tailf:info "Apply options only on substring match of username";
                tailf:cli-full-command;
                type string {
                  tailf:info "WORD;;Substring of username";
                }
              }
            }

            // vpdn-group * / l2tp attribute clid mask-method right
            container right {
              tailf:info "Mask from the right side";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }

              // vpdn-group * / l2tp attribute clid mask-method right character
              leaf character {
                tailf:info "CHAR;;Character used for masking";
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type string {
                  length "1";
                }
              }

              // vpdn-group * / l2tp attribute clid mask-method right bytes
              leaf bytes {
                tailf:info "<0-255>;;Number of bytes to mask";
                tailf:cli-drop-node-name;
                type uint8;
              }

              // vpdn-group * / l2tp attribute clid mask-method right match
              leaf match {
                tailf:info "Apply options only on substring match of username";
                type string {
                  tailf:info "WORD;;Substring of username";
                }
              }
            }
          }
        }
      }

      // vpdn-group * / l2tp drop
      leaf drop {
        tailf:info "Drop packets under certain conditions";
        tailf:cli-full-command;
        type enumeration {
          enum "out-of-order" {
            tailf:info "Drop out of order data packets";
          }
        }
      }

      // vpdn-group * / l2tp hidden
      leaf hidden {
        tailf:info "Allow AVPs to be hidden";
        tailf:cli-full-command;
        type empty;
      }

      // vpdn-group * / l2tp ignore
      leaf ignore {
        tailf:info "Ignore certain AVP values";
        tailf:cli-full-command;
        type enumeration {
          enum "tx-speed" {
            tailf:info "L2TPv2 AVP#24: Connect Speed";
          }
        }
      }

      // vpdn-group * / l2tp ip
      container ip {
        tailf:info "IP specific commands";

        // vpdn-group * / l2tp ip udp
        leaf udp {
          tailf:info "udp;;UDP specific commands";
          type enumeration {
            enum "checksum" {
              tailf:info "perform checksum on data packets";
            }
          }
        }
      }

      // vpdn-group * / l2tp rx-speed
      container rx-speed {
        tailf:info "l2tp receive speed";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }

        // vpdn-group * / l2tp rx-speed ANCP
        leaf ANCP {
          tailf:info "rx-speed source ANCP";
          tailf:cli-optional-in-sequence;
          type empty;
        }

        // vpdn-group * / l2tp rx-speed RAM-min
        leaf RAM-min {
          tailf:info "rx-speed source Rate Adaptive Mode - Minimum";
          tailf:cli-optional-in-sequence;
          when "not(../ANCP)" {
            tailf:dependency "../ANCP";
          }
          type empty;
        }

        // vpdn-group * / l2tp rx-speed rx-speed
        leaf rx-speed {
          tailf:info "<0-2147483>;;value of rx-speed in kbps";
          tailf:cli-drop-node-name;
          type uint32 {
            range "0..2147483";
          }
        }
      }

      // vpdn-group * / l2tp sequencing
      leaf sequencing {
        tailf:info "Enable sequencing";
        tailf:cli-full-command;
        type empty;
      }

      // vpdn-group * / l2tp tunnel
      container tunnel {
        tailf:info "L2TP tunnel commands";

        // vpdn-group * / l2tp tunnel authentication
        leaf authentication {
          tailf:info "Authenticate tunnel";
          tailf:cli-full-command;
          type empty;
        }

        // vpdn-group * / l2tp tunnel bearer
        container bearer {
          tailf:info "Bearer attributes";

          // vpdn-group * / l2tp tunnel bearer capabilities
          leaf capabilities {
            tailf:info "AVP#4 : Bearer capabilities";
            type enumeration {
              enum "all" {
                tailf:info "All bearer types";
              }
              enum "analog" {
                tailf:info "Analog bearer type";
              }
              enum "digital" {
                tailf:info "Digital bearer type";
              }
              enum "none" {
                tailf:info "No bearer type";
              }
            }
          }
        }

        // vpdn-group * / l2tp tunnel busy
        container busy {
          tailf:info "Busy list commands";

          // vpdn-group * / l2tp tunnel busy timeout
          leaf timeout {
            tailf:info "Busy list timeout length";
            type uint16 {
              tailf:info "<5-6000>;;Seconds";
              range "5..6000";
            }
          }
        }

        // vpdn-group * / l2tp tunnel framing
        container framing {
          tailf:info "Framing attributes";

          // vpdn-group * / l2tp tunnel framing capabilities
          leaf capabilities {
            tailf:info "AVP#3: Framing capabilities";
            type enumeration {
              enum "all" {
                tailf:info "All framing types";
              }
              enum "asynchronous" {
                tailf:info "Asynchronous framing";
              }
              enum "none" {
                tailf:info "No framing";
              }
              enum "synchronous" {
                tailf:info "Synchronous framing";
              }
            }
          }
        }

        // vpdn-group * / l2tp tunnel hello
        leaf hello {
          tailf:info "Hello packet interval";
          type uint16 {
            tailf:info "<0-1000>;;seconds, default is 60";
            range "0..1000";
          }
          default 60;
        }

        // vpdn-group * / l2tp tunnel password
        container password {
          tailf:info "Tunnel password for authentication and/or AVP hiding";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          uses password-grouping {
            refine "secret" {
              cli:secret " tunnel password <SECRET>";
            }
          }
        }

        // vpdn-group * / l2tp tunnel receive-window
        leaf receive-window {
          tailf:info "Receive window size for control channel";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<1-8192>;;Number of packets";
            range "1..8192";
          }
        }

        // vpdn-group * / l2tp tunnel resync
        leaf resync {
          tailf:info "Number of unacknowledged packets sent to the peer for SSO";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<1-1024>;;Number of packets";
            range "1..1024";
          }
        }

        // vpdn-group * / l2tp tunnel retransmit
        container retransmit {
          tailf:info "Control packet retransmission parameters";

          // vpdn-group * / l2tp tunnel retransmit initial
          container initial {
            tailf:info "SCCRQ control retries/timeout settings";

            // vpdn-group * / l2tp tunnel retransmit initial retries
            leaf retries {
              tailf:info "Number of initial retries before placing LNS on busy list";
              tailf:cli-full-command;
              type uint16 {
                tailf:info "<1-1000>;;Maximum SCCRQ retransmissions";
                range "1..1000";
              }
            }

            // vpdn-group * / l2tp tunnel retransmit initial timeout
            container timeout {
              tailf:info "SCCRQ retransmission timeout parameters";
              leaf max {
                tailf:info "Maximum timeout";
                tailf:cli-full-command;
                type uint8 {
                  range "0..8";
                }
              }
              leaf min {
                tailf:info "Minimum timeout";
                tailf:cli-full-command;
                type uint8 {
                  range "0..8";
                }
              }
            }
          }

          // vpdn-group * / l2tp tunnel retransmit retries
          leaf retries {
            tailf:info "Number of retries before tearing down a tunnel";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<5-1000>;;Maximum retransmissions";
              range "5..1000";
            }
          }

          // vpdn-group * / l2tp tunnel retransmit timeout
          container timeout {
            tailf:info "Control packet retransmission timeout parameters";
            leaf max {
              tailf:info "Maximum timeout";
              tailf:cli-full-command;
              type uint8 {
                range "0..8";
              }
            }
            leaf min {
              tailf:info "Minimum timeout";
              tailf:cli-full-command;
              type uint8 {
                range "0..8";
              }
            }
          }
        }

        // vpdn-group * / l2tp tunnel timeout
        container timeout {
          tailf:info "Tunnel timeout values";

          // vpdn-group * / l2tp tunnel timeout no-session
          leaf no-session {
            tailf:info "No-session timeout for tunnel";
            tailf:cli-full-command;
            type union {
              type uint32 {
                tailf:info "<0-86400>;;Timeout in seconds";
                range "0..86400";
              }
              type enumeration {
                enum "never" {
                  tailf:info "Never timeout";
                }
              }
            }
          }

          // vpdn-group * / l2tp tunnel timeout setup
          leaf setup {
            tailf:info "Time permitted to setup a tunnel";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<60-6000>;;Timeout in seconds";
              range "60..6000";
            }
          }
        }

        // vpdn-group * / l2tp tunnel zlb
        container zlb {
          tailf:info "Tunnel ZLB options";
          leaf delay {
            tailf:info "<1-5>;;Delay in seconds";
            type uint8 {
              range "1..5";
            }
          }
        }
      }

      // vpdn-group * / l2tp tx-speed
      container tx-speed {
        tailf:info "l2tp transmit speed";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }

        // vpdn-group * / l2tp tx-speed ANCP
        leaf ANCP {
          tailf:info "tx-speed source ANCP";
          tailf:cli-optional-in-sequence;
          type empty;
        }

        // vpdn-group * / l2tp tx-speed RAM-min
        leaf RAM-min {
          tailf:info "tx-speed source Rate Adaptive Mode - Minimum";
          tailf:cli-optional-in-sequence;
          when "not(../ANCP)" {
            tailf:dependency "../ANCP";
          }
          type empty;
        }

        // vpdn-group * / l2tp tx-speed tx-speed
        leaf tx-speed {
          tailf:info "<0-2147483>;;value of tx-speed in kbps";
          tailf:cli-drop-node-name;
          type uint32 {
            range "0..2147483";
          }
        }
      }
    }

    // vpdn-group * / lcp
    container lcp {
      tailf:info "LCP specific commands";

      // vpdn-group * / lcp renegotiation
      leaf renegotiation {
        tailf:info "LNS/HGW renegotiates LCP";
        type enumeration {
          enum always {
            tailf:info "Always renegotiate";
          }
          enum on-mismatch {
            tailf:info "Renego only when config mismatch between LNS/HGW and LAC/NAS";
          }
        }
      }
    }

    // vpdn-group * / local
    container local {
      tailf:info "Local information";
      leaf name {
        type string {
          tailf:info "name;;Local name used for group authentication";
        }
      }
    }

    // vpdn-group * / pptp
    container pptp {
      tailf:info "PPTP specific commands";
      //tailf:cli-diff-dependency "../l2tp" {
      //    tailf:cli-trigger-on-set;
      //}
      tailf:cli-diff-dependency "../accept-dialin/protocol";
      when "not(../accept-dialin/protocol='l2tp')" {
        tailf:dependency "../accept-dialin/protocol";
      }

      // vpdn-group * / pptp flow-control
      container flow-control {
        tailf:info "PPTP flow control commands";

        // vpdn-group * / pptp flow-control receive-window
        leaf receive-window {
          tailf:info "Receive window for incoming packets";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<1-64>;;packets";
            range "1..64";
          }
        }

        // vpdn-group * / pptp flow-control static-rtt
        leaf static-rtt {
          tailf:info "Static round trip time";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<100-5000>;;milliseconds";
            range "100..5000";
          }
        }
      }

      // vpdn-group * / relay
      container relay {
        tailf:info "Relay options configuration";

        // vpdn-group * / relay ppoe
        container pppoe {
          tailf:info "PPPoE relay options";

          // vpdn-group * / relay ppoe bba-group
          leaf bba-group {
            tailf:info "WORD;;bba-group name for protocol PPPoE";
            type string;
          }
        }
      }

      // vpdn-group * / pptp tunnel
      container tunnel {
        tailf:info "PPTP tunnel commands";

        // vpdn-group * / pptp tunnel echo
        leaf echo {
          tailf:info "Echo packet interval";
          type uint16 {
            tailf:info "<0-1000>;;seconds, default is 60";
            range "0..1000";
          }
          default 60;
        }
      }
    }

    // vpdn-group * / redirect
    container redirect {
      tailf:info "Call redirection options";

      // vpdn-group * / redirect identifier
      leaf identifier {
        tailf:info "WORD;;Redirect identifier name (31 chars max)";
        type string {
          length "1..31";
        }
      }
    }

    // vpdn-group * / source
    container source {
      tailf:info "Configuration source for this vpdn-group";

      // vpdn-group * / source vpdn-template
      leaf vpdn-template {
        tailf:info "Use vpdn-template";
        type string;
      }
    }

    // vpdn-group * / source-ip
    leaf source-ip {
      tailf:info "Set source IP address for this vpdn-group";
      type inet:ipv4-address;
    }

    // vpdn-group * / terminate-from
    container terminate-from {
      tailf:info "";

      // vpdn-group * / terminate-from hostname
      leaf hostname {
        tailf:info "";
        tailf:cli-full-command;
        type string;
      }
    }

    // vpdn-group * / vpn
    container vpn {
      tailf:info "VPN ID/VRF name";

      // vpdn-group * / id
      leaf id {
        tailf:info "VPN ID";
        tailf:cli-full-command;
        type string;
      }

      // vpdn-group * / vrf
      leaf vrf {
        tailf:info "VPN Routing/Forwarding instance name";
        tailf:cli-full-command;
        tailf:cli-diff-dependency "../../../ip/vrf";
        tailf:cli-diff-dependency "../../../vrf/definition";
        type string {
          tailf:info "WORD;;VPN Routing/Forwarding instance name";
        }
      }
    }
  }


  /// ========================================================================
  /// bba-group
  /// ========================================================================

  container bba-group {
    tailf:info "Configure BBA Group";

    // bba-group pppoe *
    list pppoe {
      tailf:info "PPPoE type";
      key id;
      leaf id {
        type union {
          type string {
            tailf:info "WORD;;BBA Group name";
          }
          type enumeration {
            enum global {
              tailf:info "PPPoE global group";
            }
          }
        }
      }

      // bba-group pppoe * / vendor-tag
      container vendor-tag {
        tailf:info "PPPoE Vendor Specific Tag";

        // bba-group pppoe * / vendor-tag circuit-id service
        container circuit-id {
          tailf:info "Circuit-Id";
          leaf service {
            tailf:info "Enable processing";
            type empty;
          }
        }

        // bba-group pppoe * / vendor-tag dsl-sync-rate service
        container dsl-sync-rate {
          tailf:info "DSL-Sync-Rate";
          leaf service {
            tailf:info "Enable processing";
            type empty;
          }
        }

        // bba-group pppoe * / vendor-tag remote-id service
        container remote-id {
          tailf:info "Remote-Id";
          leaf service {
            tailf:info "Enable processing";
            type empty;
          }
        }

        // bba-group pppoe * / vendor-tag strip
        leaf strip {
          tailf:info "Strip all vendor tags";
          type empty;
        }
      }

      // bba-group pppoe * / virtual-template
      leaf virtual-template {
        tailf:info "BBA virtual template command";
        tailf:non-strict-leafref {
          path "../../../interface/Virtual-Template/name";
        }
        type uint16 {
          tailf:info "<1-4095>;;Virtual Template interface number";
          range "1..4095";
        }
      }
    }
  }


  /// ========================================================================
  /// tacacs-server
  /// ========================================================================

  container tacacs-server {
    tailf:info "Modify TACACS query parameters";
    tailf:cli-diff-dependency "../aaa/new-model";

    // tacacs-server administration
    leaf administration {
      tailf:info "Start tacacs+ deamon handling administrative messages";
      type empty;
    }

    // tacacs-server attempts
    leaf attempts {
      tailf:info "Number of login attempts via TACACS";
      type uint16 {
        tailf:info "<1-1000>;;Number of login attempts";
      }
    }

    // tacacs-server host *
    list host {
      tailf:info "Specify a TACACS server";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      tailf:cli-show-long-obu-diffs;
      ordered-by user;
      key name;
      leaf name {
        type inet:host {
          tailf:info "Hostname or A.B.C.D;;IP address of TACACS server";
        }
      }

      // tacacs-server host * port
      leaf port {
        tailf:info "TCP port for TACACS+ server (default is 49)";
        type uint16 {
          tailf:info "<1-65535>;;Port number";
          range "1..65535";
        }
      }

      // tacacs-server host * timeout
      leaf timeout {
        tailf:info "Time to wait for this TACACS server to reply (overrides default)";
        type uint16 {
          tailf:info "<1-1000>;;Timeout value in seconds to wait for server to reply";
          range "1..1000";
        }
      }

      // tacacs-server host * key
      container key {
        tailf:info "per-server encryption key (overrides default)";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        uses password-grouping {
          refine "secret" {
            cli:secret " key <SECRET>";
          }
        }
      }
    }

    // tacacs-server timeout
    leaf timeout {
      tailf:info "Time to wait for a TACACS server to reply";
      type uint16 {
        tailf:info "<1-1000>;;Wait time (default 5 seconds)";
        range "1..1000";
      }
      default 5;
    }

    // tacacs-server directed-request
    container directed-request {
      tailf:info "Allow user to specify tacacs server to use with `@server'";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      presence true;
      leaf restricted {
        tailf:info "restrict queries to directed request servers only";
        tailf:cli-optional-in-sequence;
        type empty;
      }
      leaf no-truncate {
        tailf:info "Do not truncate the @hostname from username.";
        type empty;
      }
    }

    // tacacs-server key
    container key {
      tailf:info "Set TACACS+ encryption key.";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      uses password-grouping {
        refine "secret" {
          cli:secret " key <SECRET>";
        }
      }
    }

    // tacacs-server last-resort
    leaf last-resort {
      tailf:info "Define TACACS action if no server responds";
      type enumeration {
        enum password {
          tailf:info "The 'enable' password must be provided";
        }
        enum succeed {
          tailf:info "Access to privileged level is granted";
        }
      }
    }
  }


  /// ========================================================================
  /// tacacs
  /// ========================================================================

  container tacacs {
    tailf:info "TACACS server configuration command";
    tailf:cli-diff-dependency "../aaa/new-model";

    // tacacs server *
    list server {
      tailf:info "Server configuration";
      tailf:cli-mode-name "config-server-tacacs";
      tailf:cli-full-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Name for the tacacs server configuration";
        }
      }

      // tacacs server * / address
      container address {
        tailf:info "Specify ip address for tacacs server";
        tailf:cli-diff-delete-before "../../server/name";
        tailf:cli-diff-delete-before "../../../tacacs-server";
        tailf:cli-diff-set-after "../../../tacacs-server/host" {
          tailf:cli-when-target-delete;
        }
        choice address-choice {
          leaf ipv4 {
            tailf:info "Configure ipv4 address for tacacs server";
            type inet:host {
              tailf:info "Hostname or A.B.C.D;;IP address of tacacs server";
            }
          }
          leaf ipv6 {
            tailf:info "Configure ipv6 address for tacacs server";
            tailf:cli-case-insensitive;
            type inet:host {
              tailf:info "Hostname or X:X:X:X::X;;IP address of tacacs server";
            }
          }
        }
      }

      // tacacs server * / key
      container key {
        tailf:info "per-server encryption key (overrides default)";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        uses password-grouping {
          refine "secret" {
            cli:secret " key <SECRET>";
          }
        }
      }

      // tacacs server * / port
      leaf port {
        tailf:info "TCP port for TACACS+ server (default is 49)";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<1-65535>;;Port number";
          range "1..65535";
        }
        default 49;
      }

      // tacacs server * / timeout
      leaf timeout {
        tailf:info "Time to wait for this TACACS server to reply (overrides default)";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<1-1000>;;Timeout value in seconds to wait for server to reply";
          range "1..1000";
        }
      }

      // tacacs server * / single-connection
      leaf single-connection {
        tailf:info "Multiplex all packets over a single tcp connection to server (for CiscoSecure)";
        type empty;
      }

      // tacacs server * / send-nat-address
      leaf send-nat-address {
        tailf:info "To send client's post NAT address to tacacs+ server";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// udld
  /// ========================================================================

  container udld {
    tailf:info "Configure global UDLD setting";

    // udld enable
    leaf enable {
      tailf:info "Enable UDLD protocol on fiber ports except where locally configured";
      type empty;
    }

    // udld aggressive
    leaf aggressive {
      tailf:info "Enable UDLD protocol in aggressive mode on fiber ports except where locally configured";
      type empty;
    }

    // udld message time
    container message {
      tailf:info "Set UDLD message parameters";
      leaf time {
        tailf:info "Set UDLD message time period";
        type uint8 {
          tailf:info "<1-90>;;Time in seconds between sending of messages in steady state";
          range "1..90";
        }
      }
    }

    // udld recovery
    leaf recovery {
      tailf:info "Enable timer to recover from udld error disable state";
      tailf:cli-full-command;
      type empty;
    }

    // udld recovery interval
    container recovery-conf {
      tailf:cli-drop-node-name;
      container recovery {
        tailf:info "Enable timer to recover from udld error disable state";
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        leaf interval {
          tailf:info "Error disable recovery timer value";
          type uint32 {
            tailf:info "<30-86400>;;timer-interval(sec)";
            range "30..86400";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// rep
  /// ========================================================================

  container rep {
    tailf:info "Resilient Ethernet Protocol characteristics";

    // rep admin
    container admin {
      tailf:info "administrative configuration";

      // rep admin vlan *
      list vlan {
        tailf:info "VLAN";
        key name;
        leaf name {
          type uint16 {
            tailf:info "<2-4094>;;between 2 and 4094";
            range "2..4094";
          }
        }
      }
    }
  }

  /// ========================================================================
  /// x29
  /// ========================================================================

  // x29
  container x29 {
    tailf:info "X29 commands";

    // x29 profile *
    list profile {
      tailf:info "Create an X.3 profile";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Name of the profile";
        }
      }
      leaf values {
        tailf:cli-drop-node-name;
        tailf:cli-multi-value;
        type string {
          tailf:info "<0-22>:<0-255>;;X.3 PAD parameters and values";
        }
      }
    }
  }

  /// ========================================================================
  /// xconnect
  /// ========================================================================

  // xconnect logging
  container xconnect {
    tailf:info "Xconnect config commands";
    container logging {
      tailf:info "Configure logging flags";

      // xconnect logging pseudowire status
      container pseudowire {
        tailf:info "pseudowire status transition logging";
        leaf status {
          tailf:info "pseudowire status up/down logging";
          tailf:cli-full-command;
          type empty;
        }
      }

      // xconnect logging redundancy
      leaf redundancy {
        tailf:info "xconnect redundancy events";
        tailf:cli-full-command;
        type empty;
      }
    }
  }


  /// ========================================================================
  /// template
  /// ========================================================================

  list template {
    tailf:info "Select a template to configure";
    tailf:cli-mode-name "config-template";
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;Template name";
      }
    }

    // template type pseudowire *
    leaf type {
      tailf:info "Type of the template";
      tailf:cli-prefix-key;
      type enumeration {
        enum pseudowire {
          tailf:info "Template customized interface pseudowire";
        }
      }
    }

    // template * / encapsulation
    leaf encapsulation {
      tailf:info "Data encapsulation method";
      type enumeration {
        enum l2tpv3 {
          tailf:info "Use L2TPv3 encapsulation";
        }
        enum mpls {
          tailf:info "Use MPLS encapsulation";
        }
      }
    }

    // template * / vc type
    container vc {
      tailf:info "Virtual Circuit options";
      tailf:cli-diff-delete-before "../encapsulation";
      leaf type {
        tailf:info "Virtual Circuit type to use";
        type enumeration {
          enum vlan {
            tailf:info "VLAN (type 4)";
            value 4;
          }
          enum ethernet {
            tailf:info "Ethernet (type 5)";
            value 5;
          }
        }
      }
    }

    // template * / mtu
    leaf mtu {
      tailf:info "set Maximum Transmission Unit";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<64-65535>;;Maximum Transmission Unit value";
        range "64..65535";
      }
    }

    // template * / control-word
    leaf control-word {
      tailf:info "Control-word options";
      type enumeration {
        enum "exclude" {
          tailf:info "Exclude control-word in pseudowire packets";
        }
        enum "include" {
          tailf:info "Include control-word in pseudowire packets";
        }
      }
    }

    // template * / preferred-path
    container preferred-path {
      tailf:info "Preferred path";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      choice interface-or-peer {
        leaf interface {
          tailf:info "Output Interface";
          tailf:cli-diff-dependency "../../../interface/Tunnel";
          type string {
            tailf:info "WORD;;Interface Name";
          }
        }
        leaf peer {
          tailf:info "Peer Address";
          type inet:host {
            tailf:info "Hostname or A.B.C.D;;IP address or host name of Peer PE";
          }
        }
        // template * / preferred-path segment-routing traffic-eng
        container segment-routing {
          tailf:info "Segment-routing option";
          tailf:cli-flatten-container;
          container traffic-eng {
            tailf:info "Segment-routing traffic engineering option";
            choice te-choice {
              // template * / preferred-path segment-routing traffic-eng attribute-set
              leaf attribute-set {
                tailf:info "Set MPLS traffic engineering attribute for auto-tunnel";
                tailf:non-strict-leafref {
                  path "/ios:mpls/traffic-eng/lsp/attributes/name";
                }
                type string {
                  tailf:info "WORD;;MPLS traffic engineering profile name";
                }
              }
              // template * / preferred-path segment-routing traffic-eng policy
              leaf policy {
                tailf:info "Specify SR TE policy for preferred path";
                tailf:non-strict-leafref {
                  path "/ios:segment-routing/traffic-eng/policy/name";
                }
                type string {
                  tailf:info "WORD;;Name of SR TE policy";
                }
              }
            }
          }
        }
      }
      leaf disable-fallback {
        tailf:info "disable fall back to alternative route";
        type empty;
      }
    }

    // template * / signaling protocol
    container signaling {
      tailf:info "Signaling options";
      leaf protocol {
        tailf:info "Signaling protocol to use";
        type enumeration {
          enum ldp {
            tailf:info "Use LDP signaling";
          }
          enum none {
            tailf:info "No signaling, use manually configured pseudowires";
          }
        }
      }
    }

    // template * / dot1x pae authenticator pae
    container dot1x {
      tailf:info "Interface Config Commands for IEEE 802.1X";
      leaf pae {
        tailf:info "Set 802.1x interface pae type";
        type enumeration {
          enum authenticator {
            tailf:info "Set pae type as Authenticator";
          }
          enum supplicant {
            tailf:info "Set pae type as Supplicant";
          }
        }
      }
    }

    // template * / spanning-tree
    container spanning-tree {
      tailf:info "Spanning Tree Subsystem";

      // template * / spanning-tree portfast
      container portfast {
        tailf:info "Spanning tree portfast options";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence true;
        choice portfast-choice {
          leaf disable {
            tailf:info "Disable portfast for this interface";
            type empty;
          }
          leaf network {
            tailf:info "Enable portfast network on the interface";
            type empty;
          }
          case trunk-mode {
            leaf edge {
              tailf:info "Enable portfast edge on the interface";
              type empty;
            }
            leaf trunk {
              tailf:info "Enable portfast edge on the interface even in trunk mode";
              type empty;
            }
          }
        }
      }

      // template * / spanning-tree guard root
      leaf guard {
        tailf:info "Change an interface's spanning tree guard mode";
        type enumeration {
          enum loop {
            tailf:info "Set guard mode to loop guard on interface";
          }
          enum none {
            tailf:info "Set guard mode to none";
          }
          enum root {
            tailf:info "Set guard mode to root guard on interface";
          }
        }
      }
    }

    // template * / mab
    container mab {
      tailf:info "MAC Authentication Bypass Interface Config Commands";
      tailf:cli-reset-container;
      presence true;
      // template * / mab eap
      leaf eap {
        tailf:info "Use EAP authentication for MAC Auth Bypass";
        type empty;
      }
    }

    // template * / access-session
    container access-session {
      tailf:info "Access Session specific Interface Configuration Commands";

      // template * / access-session control-direction
      leaf control-direction {
        tailf:info "Set the control-direction on the interface";
        type enumeration {
          enum both {
            tailf:info "Control traffic in BOTH directions";
          }
          enum in {
            tailf:info "Control inbound traffic only";
          }
        }
        default both;
      }

      // template * / access-session closed
      leaf closed {
        tailf:info "Enable closed access on port (disabled by default, i.e. open access)";
        type empty;
      }

      // template * / access-session port-control
      leaf port-control {
        tailf:info "Set the port-control value";
        type enumeration {
          enum auto {
            tailf:info "PortState set to automatic";
          }
          enum force-authorized {
            tailf:info "PortState set to AUTHORIZED";
          }
          enum force-unauthorized {
            tailf:info "PortState set to UnAuthorized";
          }
        }
      }
    }

    // template * / authentication
    container authentication {
      tailf:info "Auth Manager Interface Configuration Commands";

      // template * / authentication periodic
      leaf periodic {
        tailf:info "Enable or Disable Reauthentication for this port";
        type empty;
      }

      // template * / authentication timer reauthenticate
      container timer {
        tailf:info "Set authentication timer values";
        leaf reauthenticate {
          tailf:info "Time in seconds after which an automatic "+
            "re-authentication should be initiated (default 1 hour)";
          type union {
            type enumeration {
              enum server {
                tailf:info "Obtain re-authentication timeout value from the server";
              }
            }
            type uint16 {
              tailf:info "<1-65535>;;Enter a value between 1 and 65535";
              range "1..65535";
            }
          }
          default 3600;
        }
      }
    }

    // template * / service-policy type control subscriber
    container service-policy {
      tailf:info "Configure CPL Service Policy";
      container type {
        tailf:info "Configure CPL Service Policy";
        container control {
          tailf:info "Apply a control policy to the interface";
          leaf subscriber {
            tailf:info "Apply a subscriber control policy to the interfac";
            tailf:non-strict-leafref {
              path "../../../../../policy-map-event-control/policy-map/name";
            }
            type string {
              tailf:info "WORD;;policy-map name";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// source
  /// ========================================================================

  container source {
    tailf:info "Get config from another source";

    // source template
    leaf template {
      tailf:info "global template";
      type string {
        tailf:info "WORD;;Template name";
      }
    }
  }


  /// ========================================================================
  /// fabric
  /// ========================================================================

  container fabric {
    tailf:info "Catalyst 6000 crossbar fabric configuration commands";

    // fabric switching-mode
    container switching-mode {
      tailf:info "Switching mode settings";

      // fabric switching-mode allow
      container allow {
        tailf:info "Allow settings";
        choice allow-choice {
          leaf bus-mode {
            tailf:info "Allow switching in bus mode for modules";
            type empty;
          }
          container truncated {
            tailf:info "Truncated switching mode";
            presence true;
            leaf threshold {
              tailf:info "Number of SFM-capable modules for truncated "
                +"switching mode. Switch applies the threshold only when the "
                +"mode is disallowed. Switch ignores the threshold when the "
                +"truncated mode is allowed";
              type uint8 {
                tailf:info "<1-9>;;Threshold for truncated switching mode.";
                range "1..9";
              }
            }
          }
          leaf dcef-only {
            tailf:info "Allow switching in only dCEF mode for all modules";
            type empty;
          }
        }
      }

      // fabric switching-mode force
      container force {
        tailf:info "Force modules to different switching modes";
        leaf bus-mode {
          tailf:info "Switching mode of service modules will be forced to bus-mode by powercycling it";
          type empty;
        }
      }
    }

    // fabric buffer-reserve
    container buffer-reserve {
      tailf:info "Reserve FIFO buffer";

      // fabric buffer-reserve queue
      leaf queue {
        tailf:info "Queue setting for buffer reserve";
        type empty;
      }
    }

    // fabric required
    leaf required {
      tailf:info "Fabric required for system to operate";
      type empty;
    }

    // fabric timer
    leaf timer {
      tailf:info "set poll time (in Seconds) for drop counter timestamp and peak utilization";
      type uint16 {
        tailf:info "<1-1800>;;polling time in seconds";
        range "1..1800";
      }
    }
  }


  /// ========================================================================
  /// port-channel
  /// ========================================================================

  container port-channel {
    tailf:info "EtherChannel configuration";

    // port-channel per-module load-balance
    container per-module {
      tailf:info "per-module configuration";
      leaf load-balance {
        tailf:info "Load Balance Enable";
        type empty;
      }
    }

    // port-channel load-balance
    container load-balance {
      tailf:info "Load Balancing method";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf value {
        tailf:cli-drop-node-name;
        type enumeration {
          enum dst-ip {
            tailf:info "Dst IP Addr";
          }
          enum dst-mac {
            tailf:info "Dst Mac Addr";
          }
          enum dst-mixed-ip-port {
            tailf:info "Dst IP Addr and TCP/UDP Port";
          }
          enum dst-port {
            tailf:info "Dst TCP/UDP Port";
          }
          enum mpls {
                     tailf:info "Load Balancing for MPLS packets";
          }
          enum src-dst-ip {
            tailf:info "Src XOR Dst IP Addr";
          }
          enum src-dst-mac {
            tailf:info "Src XOR Dst Mac Addr";
          }
          enum src-dst-mixed-ip-port {
            tailf:info "Src XOR Dst IP Addr and TCP/UDP Port";
          }
          enum src-dst-port {
            tailf:info "Src XOR Dst TCP/UDP Port";
          }
          enum src-ip {
            tailf:info "Src IP Addr";
          }
          enum src-mac {
            tailf:info "Src Mac Addr";
          }
          enum src-mixed-ip-port {
            tailf:info "Src IP Addr and TCP/UDP Port";
          }
          enum src-port {
            tailf:info "Src TCP/UDP Port";
          }
        }
      }
      container exclude {
        tailf:info "Exclusion parameters";
        tailf:cli-flatten-container;
        leaf vlan {
          tailf:info "Exclude vlan";
          type empty;
        }
      }
    }

    // port-channel load-balance-hash-algo
    leaf load-balance-hash-algo {
      tailf:info "Algorithm selection for FBLB";
      type string;
    }
  }


  /// ========================================================================
  /// l2protocol-tunnel
  /// ========================================================================

  container l2protocol-tunnel {
    tailf:info "Tunnel Layer2 protocols";

    // l2protocol-tunnel cos
    leaf cos {
      tailf:info "Class of Service";
      type uint8 {
        tailf:info "<0-7>;;priority value";
        range "0..7";
      }
    }

    // l2protocol-tunnel global
    container global {
      tailf:info "Global settings";
      leaf drop-threshold {
        tailf:info "L2PT packets drop threshold";
        type uint16 {
          tailf:info "<100-20000>;;Packets per second";
          range "100..20000";
        }
      }
    }
  }


  /// ========================================================================
  /// l2vpn
  /// ========================================================================

  // l2vpn
  container l2vpn {
    tailf:info "Layer2 VPN commands";
    tailf:cli-add-mode;
    tailf:cli-full-command;
    presence true;

    // l2vpn / logging
    container logging {
      tailf:info "Configure logging flags";

      // l2vpn / logging pseudowire status
      container pseudowire {
        tailf:info "pseudowire status transition logging";
        leaf status {
          tailf:info "pseudowire status up/down logging";
          type empty;
        }
      }

      // l2vpn / logging redundancy
      leaf redundancy {
        tailf:info "xconnect redundancy events";
        type empty;
      }
    }

    // l2vpn / router-id
    leaf router-id {
      tailf:info "Configure a Layer2 router-id";
      type inet:ipv4-address {
        tailf:info "A.B.C.D;;Layer2 router-id value";
      }
    }
  }

  // l2vpn vfi
  container l2vpn-vfi {
    tailf:cli-drop-node-name;
    container l2vpn {
      container vfi {
        tailf:info "Configure a Virtual Forwarding Instance (VFI)";

        // l2vpn vfi context *
        list context {
          tailf:info "Layer2 VPN Context";
          tailf:cli-mode-name "config-vfi";
          key name;
          leaf name {
            tailf:cli-diff-dependency "../../../../../template";
            type string {
              tailf:info "WORD;;Virtual Forwarding Instance (VFI) name";
            }
          }

          // l2vpn vfi context * / vpn id
          container vpn {
            tailf:info "VPN configuration";
            leaf id {
              tailf:info "VPN id";
              type uint32 {
                tailf:info "<1-4294967295>;;VPN id value";
                range "1..4294967295";
              }
            }
          }

          // l2vpn vfi context * / l2protocol forward
          container l2protocol {
            tailf:info "Configure l2 control protocol processing";
            container forward {
              tailf:info "forward L2 control protocol packets as data";
              presence true;
            }
          }

          // l2vpn vfi context * / autodiscovery bgp signaling
          container autodiscovery {
            tailf:info "Auto Discovery mode";
            container bgp {
              tailf:info "Use BGP for neighbor discovery";
              container signaling {
                tailf:info "Signaling protocol to use";
                tailf:cli-add-mode;
                tailf:cli-mode-name "config-vfi-autodiscovery";
                tailf:cli-explicit-exit;
                presence true;
                choice protocol-choice {
                  // l2vpn vfi context * / autodiscovery bgp signaling bgp
                  leaf bgp {
                    tailf:info "Use BGP signaling";
                    tailf:cli-hide-in-submode;
                    type empty;
                  }
                  // l2vpn vfi context * / autodiscovery bgp signaling ldp
                  leaf ldp {
                    tailf:info "Use LDP signaling";
                    tailf:cli-hide-in-submode;
                    type empty;
                  }
                }
                // l2vpn vfi context * / autodiscovery bgp signaling * template
                leaf template {
                  tailf:info "Template to be used for autodiscovered pseudowires";
                  tailf:cli-hide-in-submode;
                  tailf:non-strict-leafref {
                    path "../../../../../../../../template/name";
                  }
                  type string {
                    tailf:info "WORD;;template name (Max size 32)";
                  }
                }

                // l2vpn vfi context * / autodiscovery bgp signaling bgp / ve
                container ve {
                  tailf:info "Specify VPLS Edge device parameters";

                  // l2vpn vfi context * / autodiscovery bgp signaling bgp / ve id
                  leaf id {
                    tailf:info "Specify VPLS Edge device ID";
                    type uint16 {
                      tailf:info "<1-16384>;;VPLS Edge device ID value";
                      range "1..16384";
                    }
                  }

                  // l2vpn vfi context * / autodiscovery bgp signaling bgp / ve range
                  leaf range {
                    tailf:info "Specify VPLS Edge device ID range";
                    type uint8 {
                      tailf:info "<11-100>;;Specify VPLS Edge device ID range value";
                      range "11..100";
                    }
                  }
                }

                // l2vpn vfi context * / autodiscovery bgp signaling bgp / rd
                leaf rd {
                  tailf:info "Specify Route Distinguisher";
                  tailf:cli-remove-before-change;
                  tailf:cli-full-command;
                  type rd-type;
                }

                // l2vpn vfi context * / autodiscovery bgp signaling ldp / vpls-id
                leaf vpls-id {
                  tailf:info "Specify VPLS-ID Extendended Community";
                  tailf:cli-full-command;
                  type asn-ip-type {
                    tailf:info "ASN:nn or IP-address:nn;;Specify VPLS-ID Extendended Community";
                  }
                }

                // l2vpn vfi context * / autodiscovery bgp signaling bgp / route-target
                container route-target {
                  tailf:info "Specify Route Target VPN Extended Communities";
                  uses route-target-grouping;
                }

                // l2vpn vfi context * / autodiscovery bgp signaling bgp / no auto-route-target
                leaf auto-route-target {
                  tailf:info "Automatically set a route-target";
                  tailf:cli-boolean-no;
                  type boolean;
                  default true;
                }
              }
            }
          }

          // l2vpn vfi context * / member
          container member {
            tailf:info "Configure the cross connect member";

            // l2vpn vfi context * / member *
            list ip-address-list {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              key ip-address;
              leaf ip-address {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IP address of the peer";
                }
              }
              choice encapsulation-template-choice {
                leaf encapsulation {
                  tailf:info "Data encapsulation method";
                  type enumeration {
                    enum mpls {
                      tailf:info "Use MPLS encapsulation";
                    }
                  }
                }
                leaf template {
                  tailf:info "Template to use for encapsulation and protocol configuration";
                  tailf:cli-full-command;
                  tailf:non-strict-leafref {
                    path "../../../../../../../template/name";
                  }
                  type string {
                    tailf:info "WORD;;template name (Max size 32)";
                  }
                }
              }
            }

            // l2vpn vfi context * / member *
            list ip-address-vc-id-list {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              key "ip-address vc-id";
              leaf ip-address {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IP address of the peer";
                }
              }
              leaf vc-id {
                type uint32 {
                  tailf:info "<1-4294967295>;;Enter VC ID value";
                }
              }
              choice encapsulation-template-choice {
                leaf encapsulation {
                  tailf:info "Data encapsulation method";
                  type enumeration {
                    enum mpls {
                      tailf:info "Use MPLS encapsulation";
                    }
                  }
                }
                leaf template {
                  tailf:info "Template to use for encapsulation and protocol configuration";
                  tailf:cli-full-command;
                  tailf:non-strict-leafref {
                    path "../../../../../../../template/name";
                  }
                  type string {
                    tailf:info "WORD;;template name (Max size 32)";
                  }
                }
              }
            }

            // l2vpn vfi context * / member pseudowire *
            list pseudowire {
              tailf:info "Pseudowire interface";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              tailf:cli-allow-join-with-key {
                tailf:cli-display-joined;
              }
              key name;
              leaf name {
                tailf:non-strict-leafref {
                  path "../../../../../../../interface/pseudowire/name";
                }
                type uint32 {
                  tailf:info "<1-231072>;;Pseudowire interface number";
                  range "1..231072";
                }
              }
              leaf ip-address {
                tailf:cli-drop-node-name;
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IP address of the peer";
                }
              }
              leaf vc-id {
                tailf:cli-drop-node-name;
                tailf:cli-optional-in-sequence;
                type uint32 {
                  tailf:info "<1-4294967295>;;Enter VC ID value";
                }
              }
              choice encapsulation-template-choice {
                leaf encapsulation {
                  tailf:info "Data encapsulation method";
                  type enumeration {
                    enum mpls {
                      tailf:info "Use MPLS encapsulation";
                    }
                  }
                }
                leaf template {
                  tailf:info "Template to use for encapsulation and protocol configuration";
                  tailf:cli-full-command;
                  tailf:non-strict-leafref {
                    path "../../../../../../../template/name";
                  }
                  type string {
                    tailf:info "WORD;;template name (Max size 32)";
                  }
                }
              }
            }
          }

          // l2vpn vfi context * / mtu
          leaf mtu {
            tailf:info "set Maximum Transmission Unit";
            type uint16 {
              tailf:info "<1500-9216>;;Maximum Transmission Unit value";
              range "1500..9216";
            }
          }

          // l2vpn vfi context * / evc
          leaf evc {
            tailf:info "EVC Name";
            tailf:non-strict-leafref {
              path "../../../../../ethernet/evc/name";
            }
            type string {
              tailf:info "WORD;;EVC name (Max size 100)";
              length "1..100";
            }
          }
        }
      }
    }
  }

  // l2vpn xconnect
  container l2vpn-xconnect {
    tailf:cli-drop-node-name;
    container l2vpn {
      tailf:info "Layer2 VPN commands";
      container xconnect {
        tailf:info "Configure a cross connect";

        // l2vpn xconnect context *
        list context {
          tailf:info "Layer2 VPN Context";
          tailf:cli-mode-name "config-xconnect";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Configure the cross connect name";
            }
          }

          // l2vpn xconnect context * / description
          uses description-grouping;

          // l2vpn xconnect context * / no remote link failure notification
          container remote {
            tailf:info "L2VPN remote peer configuration commands";
            container link {
              tailf:info "Link information";
              container failure {
                tailf:info "Failure information";
                leaf notification {
                  tailf:info "Notify in case of remote link failure";
                  tailf:cli-boolean-no;
                  type boolean;
                  default true;
                }
              }
            }
          }

          // l2vpn xconnect context * / interworking
          leaf interworking {
            tailf:info "Interworking options for the cross connect";
            tailf:cli-full-command;
            type enumeration {
              enum ethernet {
                tailf:info "Ethernet interworking";
              }
              enum ip {
                tailf:info "IP interworking";
              }
              enum vlan {
                tailf:info "VLAN interworking";
              }
            }
          }

          // l2vpn xconnect context * / member
          container member {
            tailf:info "Configure the cross connect member";
            cli:ned-diff-move-first "no member";

            // l2vpn xconnect context * / member *
            list interface-list {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              key name;
              leaf name {
                tailf:cli-diff-dependency "../../../../../../../interface";
                type string {
                  tailf:info "WORD;;Interface name";
                }
              }
              leaf group {
                tailf:info "Configure the cross connect member redundancy group";
                type string {
                  tailf:info "WORD;;Enter redundancy group name";
                }
              }
              leaf priority {
                tailf:info "Configure the cross connect member priority";
                type uint8 {
                  tailf:info "<0-16>;;Enter priority number of the member (0: Highest, 16: Lowest)";
                  range "0..16";
                }
              }
            }

            // l2vpn xconnect context * / member * *
            list member-list {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              key "name service-instance";
              leaf name {
                type string {
                  tailf:info "WORD;;Interface name";
                }
              }
              leaf service-instance {
                tailf:info "Ethernet Service Instance";
                tailf:cli-expose-key-name;
                // Note: needed due to NSO bug with new dependencies [CISCOIOS-2201]
                tailf:cli-diff-dependency "../../../../../../../interface/Ethernet/service/instance";
                tailf:cli-diff-dependency "../../../../../../../interface/FastEthernet/service/instance";
                tailf:cli-diff-dependency "../../../../../../../interface/GigabitEthernet/service/instance";
                tailf:cli-diff-dependency "../../../../../../../interface/TwoGigabitEthernet/service/instance";
                tailf:cli-diff-dependency "../../../../../../../interface/TenGigabitEthernet/service/instance";
                tailf:cli-diff-dependency "../../../../../../../interface/TwentyFiveGigE/service/instance";
                tailf:cli-diff-dependency "../../../../../../../interface/FortyGigabitEthernet/service/instance";
                tailf:cli-diff-dependency "../../../../../../../interface/HundredGigE/service/instance";
                tailf:cli-diff-dependency "../../../../../../../interface/Port-channel/service/instance";
                tailf:cli-diff-dependency "../../../../../../../interface/Vlan/service/instance";
                type uint32 {
                  tailf:info "<1-4000>;;Service Instance ID";
                }
              }
              leaf group {
                tailf:info "Configure the cross connect member redundancy group";
                type string {
                  tailf:info "WORD;;Enter redundancy group name";
                }
              }
              leaf priority {
                tailf:info "Configure the cross connect member priority";
                type uint8 {
                  tailf:info "<0-16>;;Enter priority number of the member (0: Highest, 16: Lowest)";
                  range "0..16";
                }
              }
            }

            // l2vpn xconnect context * / member * *
            list address-list {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              tailf:cli-incomplete-command;
              key "name vcid";
              leaf name {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IP address of the peer";
                }
              }
              leaf vcid {
                type uint32 {
                  tailf:info "<1-4294967295>;;Enter VC ID value";
                  range "1..4294967295";
                }
              }
              choice encap-or-termplate {
                leaf encapsulation {
                  tailf:info "Data encapsulation method";
                  type enumeration {
                    enum mpls {
                      tailf:info "Use MPLS encapsulation";
                    }
                  }
                }
                leaf template {
                  tailf:info "template to use for encapsulation and protocol configuration";
                  tailf:non-strict-leafref {
                    path "../../../../../../../template/name";
                  }
                  type string {
                    tailf:info "WORD;;template name (Max size 32)";
                  }
                }
              }
              leaf group {
                tailf:info "Configure the cross connect member redundancy group";
                type string {
                  tailf:info "WORD;;Enter redundancy group name";
                }
              }
              leaf priority {
                tailf:info "Configure the cross connect member priority";
                type uint8 {
                  tailf:info "<0-16>;;Enter priority number of the member (0: Highest, 16: Lowest)";
                  range "0..16";
                }
              }
            }
          }

          // l2vpn xconnect context * / redundancy
          container redundancy {
            tailf:info "Xconnect redundancy information";

            // l2vpn xconnect context * / redundancy predictive
            leaf predictive {
              tailf:info "Switch over to backup member without waiting for UP status";
              type enumeration {
                enum disabled {
                  tailf:info "Disable predictive switchover capability for this xconnect";
                }
                enum enabled {
                  tailf:info "Enable predictive switchover capability for this xconnect";
                }
              }
            }

            // l2vpn xconnect context * / redundancy delay
            list delay {
              tailf:info "Xconnect redundancy delay parameters";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              key group;
              leaf group {
                tailf:info "Redundancy group name";
                tailf:cli-expose-key-name;
                type string {
                  tailf:info "Redundancy group name";
                }
              }
              leaf enable-delay {
                tailf:cli-drop-node-name;
                tailf:cli-prefix-key;
                type uint8 {
                  tailf:info "<0-180>;;Enable delay";
                  range "0..180";
                }
              }
              leaf disable-delay {
                tailf:cli-drop-node-name;
                tailf:cli-prefix-key;
                type union {
                  type uint8 {
                    tailf:info "<0-180>;;Disable delay";
                    range "0..180";
                  }
                  type enumeration {
                    enum never {
                      tailf:info "Disallow disable";
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  // l2vpn evpn
  container l2vpn-evpn-mode {
    tailf:cli-drop-node-name;
    container l2vpn {
      tailf:info "Layer2 VPN commands";
      container evpn {
        tailf:info "Ethernet Virtual Private Network (EVPN) configuration";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-evpn";

        // l2vpn evpn / replication-type ingress
        container replication-type {
          tailf:info "Specify method for replicating BUM traffic";
          leaf ingress {
            tailf:info "Ingress replication";
            type empty;
          }
        }

        // l2vpn evpn / mpls label mode
        container mpls {
          tailf:info "MPLS parameters";
          container label {
            tailf:info "MPLS label parameters";
            leaf mode {
              tailf:info "Set MPLS label mode";
              type enumeration {
                enum per-bd {
                  tailf:info "Allocate one MPLS label per Bridge Domain";
                }
                enum per-ce {
                  tailf:info "Allocate one MPLS label per Customer Edge device";
                }
              }
              default per-bd;
            }
          }
        }

        // l2vpn evpn / router-id
        container router-id {
          tailf:info "EVPN router ID";
          uses interface-name-grouping;
        }
      }
    }
  }

  // l2vpn evpn instance *
  container l2vpn-evpn {
    tailf:cli-drop-node-name;
    container l2vpn {
      tailf:info "Layer2 VPN commands";
      container evpn {
        tailf:info "Ethernet Virtual Private Network (EVPN) configuration";

        // l2vpn evpn instance * point-to-point
        // l2vpn evpn instance * vlan-based
        list instance {
          tailf:info "EVPN instance (EVI)";
          tailf:cli-incomplete-command;
          tailf:cli-mode-name "config-evpn-evi";
          key id;
          leaf id {
            type uint16 {
              tailf:info "<1-65535>;;EVPN instance identifier value";
              range "1..65535";
            }
          }
          leaf vlan-based {
            tailf:info "VLAN-Based service interface";
            tailf:cli-hide-in-submode;
            tailf:cli-full-command;
            type empty;
          }
          leaf point-to-point {
            tailf:info "EVPN Virtual Private Wire Service (EVPN VPWS)";
            tailf:cli-hide-in-submode;
            tailf:cli-full-command;
            type empty;
          }

          // l2vpn evpn instance * point-to-point / rd
          leaf rd {
            tailf:info "EVPN Route Distinguisher";
            tailf:cli-remove-before-change;
            tailf:cli-full-command;
            type rd-type;
          }

          // l2vpn evpn instance * point-to-point / route-target
          container route-target {
            tailf:info "Route Target VPN Extended Communities";
            uses route-target-grouping;
          }

          // l2vpn evpn instance * point-to-point / no auto-route-target
          leaf auto-route-target {
            tailf:info "Automatically set a route-target";
            tailf:cli-boolean-no;
            tailf:cli-full-command;
            type boolean;
            default true;
          }

          // l2vpn evpn instance * point-to-point / vpws context *
          container vpws {
            tailf:info "EVPN Virtual Private Wire Service configuration";
            list context {
              tailf:info "EVPN VPWS context";
              tailf:cli-mode-name "config-evpn-vpws";
              tailf:cli-full-command;
              key name;
              leaf name {
                type string {
                  tailf:info "WORD;;EVPN VPWS context name";
                }
              }

              // l2vpn evpn instance * point-to-point / vpws context * / service
              container service {
                tailf:info "VPWS Service Instance";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands;
                leaf target {
                  tailf:info "Target (remote) VPWS Service Instance identifier";
                  tailf:cli-incomplete-command;
                  type uint32 {
                    tailf:info "<1-16777215>;;Target VPWS Service Instance identifier value";
                    range "1..16777215";
                  }
                }
                leaf source {
                  tailf:info "Source (local) VPWS Service Instance identifier";
                  type uint32 {
                    tailf:info "<1-16777215>;;Source VPWS Service Instance identifier value";
                    range "1..16777215";
                  }
                }
              }

              // l2vpn evpn instance * point-to-point / vpws context * / member
              container member {
                tailf:info "EVPN member configuration";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands;
                leaf interface {
                  tailf:cli-drop-node-name;
                  tailf:cli-remove-before-change;
                  type string {
                    tailf:info "WORD;;Interface name";
                  }
                }
                leaf service-instance {
                  tailf:info "Ethernet Service Instance";
                  tailf:cli-diff-dependency "../../../../../../../../interface/Ethernet/service/instance";
                  tailf:cli-diff-dependency "../../../../../../../../interface/FastEthernet/service/instance";
                  tailf:cli-diff-dependency "../../../../../../../../interface/GigabitEthernet/service/instance";
                  tailf:cli-diff-dependency "../../../../../../../../interface/TenGigabitEthernet/service/instance";
                  tailf:cli-diff-dependency "../../../../../../../../interface/FortyGigabitEthernet/service/instance";
                  tailf:cli-diff-dependency "../../../../../../../../interface/HundredGigE/service/instance";
                  tailf:cli-diff-dependency "../../../../../../../../interface/Port-channel/service/instance";
                  tailf:cli-diff-dependency "../../../../../../../../interface/Vlan/service/instance";
                  type uint16 {
                    tailf:info "<1-4000>;;Service Instance ID";
                    range "1..4000";
                  }
                }
              }

              // l2vpn evpn instance * point-to-point / vpws context * / shutdown
              leaf shutdown {
                tailf:info "Shut down the EVPN VPWS service";
                type empty;
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// segment-routing
  /// ========================================================================

  // segment-routing
  container segment-routing {
    tailf:info "Enter Segment Routing Mode";

    // segment-routing mpls
    container mpls {
      tailf:info "Segment Routing MPLS Mode";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-srmpls";
      presence true;

      // segment-routing mpls / shutdown
      leaf shutdown {
        tailf:info "SR Shutdown";
        type empty;
      }

      // segment-routing mpls / set-attributes
      container set-attributes {
        tailf:info "Enter SR Set Attributes Mode";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-srmpls-attr";

        // segment-routing mpls / set-attributes / address-family ipv4
        container address-family {
          tailf:info "Enter Address Family command mode";
          container ipv4 {
            tailf:info "Address family";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-srmpls-attr-af";
            tailf:cli-exit-command "exit-address-family" {
              tailf:info "Exit Address Family command mode";
            }

            // segment-routing mpls / set-attributes / address-family ipv4 / sr-label-preferred
            leaf sr-label-preferred {
              tailf:info "SR Label Preferred Config";
              type empty;
            }

            // segment-routing mpls / set-attributes / address-family ipv4 / explicit-null
            leaf explicit-null {
              tailf:info "SR Explicit Null Config";
              type empty;
            }
          }
        }
      }

      // segment-routing mpls / global-block
      container global-block {
        tailf:info "SR Global Block Config";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf start {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          tailf:cli-remove-before-change;
          type uint32 {
            tailf:info "<16-uint32>;;SR GB Label Range Start";
          }
        }
        leaf end {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<16-uint32>;;SR GB Label Range End";
          }
        }
      }

      // segment-routing mpls / local-block
      container local-block {
        tailf:info "SR Local Block Config";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf start {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          tailf:cli-remove-before-change;
          type uint32 {
            tailf:info "<16-uint32>;;SR LB Label Range Start";
          }
        }
        leaf end {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<16-uint32>;;SR LB Label Range End";
          }
        }
      }

      // segment-routing mpls / connected-prefix-sid-map
      container connected-prefix-sid-map {
        tailf:info "Enter Connected Prefix Sid Map  Mode";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-srmpls-conn";

        // segment-routing mpls / connected-prefix-sid-map / address-family
        container address-family {
          tailf:info "Enter Address Family command mode";

          // segment-routing mpls / connected-prefix-sid-map / address-family ipv4
          container ipv4 {
            tailf:info "Address Family";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-srmpls-conn-af";
            tailf:cli-exit-command "exit-address-family" {
              tailf:info "Exit Address Family command mode";
            }

            // segment-routing mpls / connected-prefix-sid-map / address-family ipv4 / *
            uses sr-connected-prefix-sid-map-af-grouping;
          }

          // segment-routing mpls / connected-prefix-sid-map / address-family ipv4 X
          container ipv4-conf {
            tailf:cli-drop-node-name;
            container ipv4 {
              tailf:info "Address Family";

              // segment-routing mpls / connected-prefix-sid-map / address-family ipv4 strict-spf
              container strict-spf {
                tailf:info "Strict SPF";
                tailf:cli-add-mode;
                tailf:cli-mode-name "config-srmpls-conn-af-ss";
                tailf:cli-exit-command "exit-address-family" {
                  tailf:info "Exit Address Family command mode";
                }

                // segment-routing mpls / connected-prefix-sid-map / address-family ipv4 strict-spf / *
                uses sr-connected-prefix-sid-map-af-grouping;
              }

              // segment-routing mpls / connected-prefix-sid-map / address-family ipv4 algorithm *
              list algorithm {
                tailf:info "Algorithm";
                tailf:cli-mode-name "config-srmpls-conn-af";
                tailf:cli-exit-command "exit-address-family" {
                  tailf:info "Exit Address Family command mode";
                }
                key id;
                leaf id {
                  type uint8 {
                    tailf:info "<128-255>;;Algorithm number";
                  }
                }

                // segment-routing mpls / connected-prefix-sid-map / address-family ipv4 algorithm * / *
                uses sr-connected-prefix-sid-map-af-grouping;
              }
            }
          }
        }
      }
    }

    // segment-routing traffic-eng
    container traffic-eng {
      tailf:info "Segment Routing Traffic-eng Mode";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-srte";
      presence true;
      tailf:cli-diff-dependency "/ios:interface";

      // segment-routing traffic-eng / interface *
      list interface {
        tailf:info "Enter interface command mode";
        tailf:cli-mode-name "config-srte-if";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Interface Name";
          }
        }

        // segment-routing traffic-eng / interface * / metric
        leaf metric {
          tailf:info "TE metric";
          type uint32 {
            tailf:info "<0-4294967295>;;TE metric value";
          }
        }

        // segment-routing traffic-eng / interface * / affinity
        container affinity {
          tailf:info "Affinity configuration";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-srte-if-aff";

          // segment-routing traffic-eng / interface * / affinity / name *
          list name {
            tailf:info "Affinity color name";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;Affinity color name";
              }
            }
          }
        }
      }

      // segment-routing traffic-eng / logging policy status
      container logging {
        tailf:info "Logging configuration";
        container policy {
          tailf:info "Configure policy logging parameters";
          leaf status {
            tailf:info "Enable policy status logging";
            type empty;
          }
        }
      }

      // segment-routing traffic-eng / segment-list name *
      container segment-list {
        tailf:info "Segment-list configuration";
        list name {
          tailf:info "Segment-list name";
          tailf:cli-mode-name "config-srte-ep";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Identifying name for segment-list";
            }
          }

          // segment-routing traffic-eng / segment-list name * / index * mpls
          list index {
            tailf:info "Specify the next entry index to add, edit (or delete)";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key id;
            leaf id {
              tailf:cli-suppress-range;
              tailf:cli-incomplete-command;
              type uint32 {
                tailf:info "<1-4294967295>;;Enter index value";
                range "1..4294967295";
              }
            }
            container mpls {
              tailf:info "MPLS configuration";
              choice mpls-choice {
                leaf adjacency {
                  tailf:info "MPLS adjacency configuration";
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;Enter ipv4 address";
                  }
                }
                leaf label {
                  tailf:info "MPLS label configuration";
                  type uint32 {
                    tailf:info "<0-1048575>;;MPLS label value";
                    range "0..1048575";
                  }
                }
                container prefix {
                  tailf:info "MPLS prefix configuration";
                  tailf:cli-compact-syntax;
                  tailf:cli-sequence-commands {
                    tailf:cli-reset-siblings;
                  }
                  leaf address {
                    tailf:cli-drop-node-name;
                    type inet:ipv4-address {
                      tailf:info "A.B.C.D;;Enter ipv4 address";
                    }
                  }
                  leaf algorithm {
                    tailf:info "MPLS prefix algorithm configuration";
                    type uint8 {
                      tailf:info "<0-1>;;Algorithm value";
                      range "0..1";
                    }
                  }
                }
              }
            }
          }
        }
      }

      // segment-routing traffic-eng / policy *
      list policy {
        tailf:info "Enter policy command mode";
        tailf:cli-mode-name "config-srte-policy";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Policy Name";
          }
        }

        // segment-routing traffic-eng / policy * / autoroute
        container autoroute {
          tailf:info "Autoroute configuration";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-srte-policy-autoroute";

          // segment-routing traffic-eng / policy * / autoroute / include all
          container include {
            tailf:info "Prefixes for which IGP routes will be installed";
            leaf all {
              tailf:info "Include all eligible prefixes";
              type empty;
            }
          }

          // segment-routing traffic-eng / policy * / autoroute / metric
          container metric {
            tailf:info "Autoroute metric";
            choice metric-choice {
              leaf constant {
                tailf:info "Set metric mode constant";
                type uint32 {
                  tailf:info "<1-2147483647>;;Constant metric";
                }
              }
              leaf relative {
                tailf:info "Set metric mode relative";
                type int8 {
                  tailf:info "<-10 - 10>;;Relative metric";
                  range "-10..10";
                }
              }
            }
          }
        }

        // segment-routing traffic-eng / policy * / color
        container color {
          tailf:info "Specify color for policy";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf id {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<1-4294967295>;;Color";
              range "1..4294967295";
            }
          }
          leaf end-point {
            tailf:info "Policy endpoint";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IPv4 address";
            }
          }
        }

        // segment-routing traffic-eng / policy * / binding-sid mpls
        container binding-sid {
          tailf:info "static binding SID";
          leaf mpls {
            tailf:info "MPLS label";
            type uint32 {
              tailf:info "<16-1048575>;;MPLS label";
              range "16..1048575";
            }
          }
        }

        // segment-routing traffic-eng / policy * / candidate-paths
        container candidate-paths {
          tailf:info "Candidate-paths configuration";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-srte-policy-path";
          presence true;

          // segment-routing traffic-eng / policy * / candidate-paths / preference *
          list preference {
            tailf:info "Policy path-option preference entry";
            tailf:cli-mode-name "config-srte-policy-path-pref";
            key id;
            leaf id {
              type uint16 {
                tailf:info "<1-65535>;;Path-option preference";
                range "1..65535";
              }
            }
            uses segment-routing-preference-grouping;
          }
        }
      }

      // segment-routing traffic-eng / pcc
      container pcc {
        tailf:info "Enter path computation client mode";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-srte-pcc";

        // segment-routing traffic-eng / pcc / pce address *
        container pce {
          tailf:info "Path Computation Element (PCE) server";
          list address {
            tailf:info "Specify address of PCE server";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            key address;
            leaf address {
              type union {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Enter ipv4 address";
                }
                type inet:ipv6-address {
                  tailf:info "X:X:X:X::X;;Enter ipv6 address";
                }
              }
            }
            leaf source-address {
              tailf:info "Specify source IP address";
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Enter ipv4 address";
              }
            }
          }
        }

        // segment-routing traffic-eng / pcc / report-all
        leaf report-all {
          tailf:info "Report all local SR policies to connected PCEP peers";
          type empty;
        }
      }

      // segment-routing traffic-eng / on-demand color *
      container on-demand {
        tailf:info "On-Demand configuration";
        list color {
          tailf:info "On-Demand color configuration";
          tailf:cli-mode-name "config-srte-on-demand-color";
          key id;
          leaf id {
            type uint32 {
              tailf:info "<1-4294967295>;;Permitted colour";
              range "1..4294967295";
            }
          }

          // segment-routing traffic-eng / on-demand color * / description
          uses description-grouping;

          // segment-routing traffic-eng / on-demand color * / authorize
          container authorize {
            tailf:info "Authorize colour";
            presence true;

            // segment-routing traffic-eng / on-demand color * / authorize restrict
            container restrict {
              tailf:info "restrict";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-srte-odn-restrict";
              presence true;

              // segment-routing traffic-eng / on-demand color * / authorize restrict / ipv4 prefix-list
              container ipv4 {
                tailf:info "on-demand color authrorize restrict ipv4";
                leaf prefix-list {
                  tailf:info "prefix-list";
                  type string {
                    tailf:info "WORD;;name";
                  }
                }
              }
            }
          }

          // segment-routing traffic-eng / on-demand color * / candidate-paths
          container candidate-paths {
            tailf:info "Candidate-paths configuration";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-srte-odn-path";
            presence true;

            // segment-routing traffic-eng / on-demand color * / candidate-paths / preference *
            list preference {
              tailf:info "Policy path-option preference entry";
              tailf:cli-mode-name "config-srte-odn-path-pref";
              key id;
              leaf id {
                type uint16 {
                  tailf:info "<1-65535>;;Path-option preference";
                  range "1..65535";
                }
              }
              uses segment-routing-preference-grouping;
            }
          }
        }
      }

      // segment-routing traffic-eng / affinity-map
      container affinity-map {
        tailf:info "Enter affinity-map command mode";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-srte-af";

        // segment-routing traffic-eng / affinity-map / name * bit-position
        list name {
          tailf:info "Affinity color name";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Affinity color name";
            }
          }
          leaf bit-position {
            tailf:info "Bit position";
            type uint8 {
              tailf:info "<0-31>;;index";
              range "0..31";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// system
  /// ========================================================================

  container system {
    tailf:info "Set the system configuration";

    // system env
    container env {
      tailf:info "Set the system environment settings";
      container temperature {
        tailf:info "Set the system temperature settings";
        container threshold {
          tailf:info "Set the system temperature thresholds";
          leaf yellow {
            tailf:info "Set the yellow threshold";
            type uint8 {
              tailf:info "<0-25>;;Delta value from Red threshold in Degree Celsius";
              range "0..25";
            }
          }
        }
      }
    }

    // system mtu
    container mtu {
      tailf:info "Set the system Maximum Transmission Unit (MTU)";
      leaf size {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<1500-9216>;;MTU size in bytes";
          range "1500..9216";
        }
        default 1500;
      }

      // system mtu jumbo
      leaf jumbo {
        tailf:info "Set Jumbo MTU value for GigabitEthernet or TenGigabitEthernet interfaces";
        type uint16 {
          tailf:info "<1500-9216>;;Jumbo MTU size in bytes";
          range "1500..9216";
        }
        default 1500;
      }

      // system mtu routing
      leaf routing {
        tailf:info "Set the Routing MTU for the system";
        type uint16 {
          tailf:info "<NUM>;;MTU size in bytes";
        }
        default 1500;
      }
    }

    // system flowcontrol bus auto
    container flowcontrol {
      container bus {
        leaf auto {
          type empty;
        }
      }
    }

    // system jumbomtu
    leaf jumbomtu {
      tailf:info "Configure system jumbo mtu size";
      type uint16 {
        tailf:info "<1500-9216>;;Jumbo mtu size in Bytes, default is 9216";
        range "1500..9216";
      }
    }
  }


  /// ========================================================================
  /// stackmaker
  /// ========================================================================

  container stackmaker {
    tailf:info "Specify stack name and add its member";

    // stackmaker name
    leaf name {
      tailf:info "Specify stack name";
      tailf:cli-full-command;
      type string {
        tailf:info "WORD;;Name of the stack";
      }
    }
  }


  /// ========================================================================
  /// diagnostic
  /// ========================================================================

  container diagnostic {
    tailf:info "Configure diagnostic information";

    // diagnostic bootup level
    container bootup {
      tailf:info "Configure diagnostic for bootup";
      leaf level {
        tailf:info "Select diagnostic level";
        type enumeration {
          enum complete {
            tailf:info "Complete level";
          }
          enum minimal {
            tailf:info "Minimal level";
          }
        }
      }
    }

    // diagnostic cns
    container cns {
      tailf:info "Configure diagnostic cns information";
      leaf publish {
        tailf:info "Configure diagnostic cns publish";
        type string {
          tailf:info "WORD;;Diagnostic cns subject";
        }
      }
      leaf subscribe {
        tailf:info "Configure diagnostic cns subscribe";
        type string {
          tailf:info "WORD;;Diagnostic cns subject";
        }
      }
    }

    // diagnostic monitor
    container monitor {
      tailf:info "Configure diagnostic monitoring tests";

      // diagnostic monitor syslog
      leaf syslog {
        tailf:info "Configure diagnostic monitoring syslog";
        type empty;
      }

      // diagnostic monitor interval Module *
      container interval {
        tailf:info "Configure diagnostic monitoring tests interval";
        list Module {
          tailf:info "Module Keyword";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-incomplete-command;
          key id;
          leaf id {
            type string;
          }
          leaf test {
            tailf:info "Diagnostic test selection";
            tailf:cli-incomplete-command;
            type string {
              tailf:info "WORD;;Test Name";
            }
          }
          leaf interval {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type string {
              tailf:info "hh:mm:ss;;Monitoring interval in hh:mm:ss format";
            }
          }
          leaf milliseconds {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<0-999>;;Number of milli-seconds [0-999]";
              range "0..999";
            }
          }
          leaf days {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<0-20>;;Number of days [0-20]";
              range "0..20";
            }
          }
          leaf cardindex {
            tailf:info "Card Index";
            type uint16;
          }
        }
      }

      // diagnostic monitor Module *
      list Module {
        tailf:info "Module Keyword";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        key id;
        leaf id {
          type string;
        }
        leaf test {
          tailf:info "Diagnostic test selection";
          type string {
            tailf:info "WORD;;Test Name";
          }
        }
        leaf cardindex {
          tailf:info "Card Index";
          type uint16;
        }
        leaf disable {
          tailf:info "Set to create a 'no diagnostic monitor Module *' entry";
          type empty;
        }
      }
    }
  }


  /// ========================================================================
  /// et-analytics
  /// ========================================================================

  // et-analytics
  container et-analytics {
    tailf:info "Encrypted Traffic Analytics";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-et-analytics";
    tailf:cli-recursive-delete;
    presence true;

    // et-analytics / ip flow-export destination *
    container ip {
      tailf:info "Specify netflow record export destination ip address and port";
      container flow-export {
        tailf:info "netflow record export";
        list destination {
          tailf:info "netflow record export destination";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key "address port";
          leaf address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP address";
            }
          }
          leaf port {
            type uint16 {
              tailf:info "<1-65535>;;Valid Port number";
              range "1..65535";
            }
          }
        }
        container destination-vrf {
          tailf:cli-drop-node-name;
          list destination {
            tailf:info "netflow record export destination";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key "address port vrf";
            leaf address {
              tailf:cli-suppress-range;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IP address";
              }
            }
            leaf port {
              tailf:cli-suppress-range;
              type uint16 {
                tailf:info "<1-65535>;;Valid Port number";
                range "1..65535";
              }
            }
            leaf vrf {
              tailf:info "Optional VRF label";
              tailf:cli-expose-key-name;
              tailf:cli-suppress-range;
              tailf:cli-diff-dependency "../../../../../../ip/vrf";
              tailf:cli-diff-dependency "../../../../../../vrf/definition";
              type string {
                tailf:info "WORD;;VRF Label";
              }
            }
          }
        }
      }
    }

    // et-analytics / inactive-timeout
    leaf inactive-timeout {
      tailf:info "Specify Inactive flow timeout value";
      type uint32 {
        tailf:info "<1-604800>;;Inactive timeout in seconds";
        range "1..604800";
      }
    }

    // et-analytics / whitelist acl
    container whitelist {
      tailf:info "Whitelist traffic";
      tailf:cli-diff-dependency "../ip";
      leaf acl {
        tailf:info "Access list";
        tailf:cli-remove-before-change;
        type exp-ip-acl-type;
      }
    }
  }


  /// ========================================================================
  /// identity
  /// ========================================================================

  container identity {
    tailf:info "Identity Configuration Commands";

    // identity policy *
    list policy {
      tailf:info "Create an Identity policy";
      tailf:cli-mode-name "config-identity-policy";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Specify a policy name";
        }
      }

      // identity policy * / inactivity-timer
      container inactivity-timer {
        tailf:info "Inactivity timeout value in seconds";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf value {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-65535>;;Enter a value between 1 and 65535";
          }
        }
        leaf probe {
          tailf:info "ARP probe";
          type empty;
        }
      }
    }
  }


  /// ========================================================================
  /// errdisable
  /// ========================================================================

  container errdisable {
    tailf:info "Error disable";

    // no errdisable detect cause
    container detect {
      tailf:info "Error disable detection";
      container cause {
        tailf:info "Enable error disable detection for application";

        // no errdisable detect cause arp-inspection
        leaf arp-inspection {
          tailf:info "Enable error detection for arp inspection";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }

        // no errdisable detect cause bpduguard
        leaf bpduguard {
          tailf:info "Enable error detection on bpdu-guard";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }

        // no errdisable detect cause dhcp-rate-limit
        leaf dhcp-rate-limit {
          tailf:info "Enable error detection on dhcp-rate-limit";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }

        // no errdisable detect cause dtp-flap
        leaf dtp-flap {
          tailf:info "Enable error detection on dtp-flapping";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }

        // no errdisable detect cause gbic-invalid
        leaf gbic-invalid {
          tailf:info "Enable error detection on gbic-invalid";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }

        // no errdisable detect cause inline-power
        leaf inline-power {
          tailf:info "Enable error detection for inline-power";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }

        // no errdisable detect cause l2ptguard
        leaf l2ptguard {
          tailf:info "Enable timer to recover from l2protocol-tunnel error disable state";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }

        // no errdisable detect cause link-flap
        leaf link-flap {
          tailf:info "Enable error detection on linkstate-flapping";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }

        // no errdisable detect cause loopback
        leaf loopback {
          tailf:info "Enable error detection on loopback";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }

        // no errdisable detect cause mlacp-minlink
        leaf mlacp-minlink {
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }

        // no errdisable detect cause pagp-flap
        leaf pagp-flap {
          tailf:info "Enable error detection on pagp-flapping";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }

        // no errdisable detect pppoe-ia-rate-limit
        leaf pppoe-ia-rate-limit {
          tailf:info "Enable error detection on PPPoE IA rate-limit";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }

        // no errdisable detect security-violation
        leaf security-violation {
          tailf:info "Enable error detection on 802.1x-guard";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }

        // no errdisable detect sfp-config-mismatch
        leaf sfp-config-mismatch {
          tailf:info "Enable error detection on SFP config mismatch";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }

        // no errdisable detect small-frame
        leaf small-frame {
          tailf:info "Enable error detection on small_frame";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }

        // no errdisable detect udld
        leaf udld {
          tailf:info "Enable error detection on udld";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }

        // no errdisable detect rootguard
        leaf rootguard {
          tailf:info "Enable error detection on rootguard";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }
      }
    }

    // errdisable flap-setting cause
    container flap-setting {
      tailf:info "Error disable flap detection setting";
      container cause {
        tailf:info "Set error disable flap parameters for application";

        // errdisable flap-setting cause dtp-flap
        container dtp-flap {
          tailf:info "Set the variables related to detection of dtp flaps";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf max-flaps {
            tailf:info "maximum flaps allowed before setting to errdisable";
            tailf:cli-incomplete-command;
            cli:parse-alt-name "max-flap";
            type uint8 {
              tailf:info "<1-100>;;flap count";
              range "1..100";
            }
          }
          leaf time {
            tailf:info "time period the flaps are counted";
            type uint8 {
              tailf:info "<1-120>;;flap count time";
              range "1..120";
            }
          }
        }

        // errdisable flap-setting cause link-flap
        container link-flap {
          tailf:info "Set the variables related to detection of link flaps";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf max-flaps {
            tailf:info "maximum flaps allowed before setting to errdisable";
            tailf:cli-incomplete-command;
            cli:parse-alt-name "max-flap";
            type uint8 {
              tailf:info "<1-100>;;flap count";
              range "1..100";
            }
          }
          leaf time {
            tailf:info "time period the flaps are counted";
            type uint8 {
              tailf:info "<1-120>;;flap count time";
              range "1..120";
            }
          }
        }

        // errdisable flap-setting cause pagp-flap
        container pagp-flap {
          tailf:info "Set the variables related to detection of pagp flaps";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf max-flaps {
            tailf:info "maximum flaps allowed before setting to errdisable";
            tailf:cli-incomplete-command;
            cli:parse-alt-name "max-flap";
            type uint8 {
              tailf:info "<1-100>;;flap count";
              range "1..100";
            }
          }
          leaf time {
            tailf:info "time period the flaps are counted";
            type uint8 {
              tailf:info "<1-120>;;flap count time";
              range "1..120";
            }
          }
        }
      }
    }

    // errdisable recovery
    container recovery {
      tailf:info "Error disable recovery";

      // errdisable recovery cause
      container cause {
        tailf:info "Enable error disable recovery for application";
        leaf arp-inspection {
          tailf:info "Enable timer to recover from arp inspection error disable state";
          type empty;
        }
        leaf bpduguard {
          tailf:info "Enable timer to recover from BPDU Guard error";
          type empty;
        }
        leaf channel-misconfig {
          tailf:info "(STP)  Enable timer to recover from channel misconfig error";
          type empty;
        }
        leaf dhcp-rate-limit {
          tailf:info "Enable timer to recover from dhcp-rate-limit error";
          type empty;
        }
        leaf dtp-flap {
          tailf:info "Enable timer to recover from dtp-flap error";
          type empty;
        }
        leaf gbic-invalid {
          tailf:info "Enable timer to recover from invalid GBIC error";
          type empty;
        }
        leaf inline-power {
          tailf:info "Enable timer to recover from inline-power error";
          type empty;
        }
        leaf l2ptguard {
          tailf:info "Enable timer to recover from l2protocol-tunnel error disable state";
          type empty;
        }
        leaf link-flap {
          tailf:info "Enable timer to recover from link-flap error";
          type empty;
        }
        leaf link-monitor-failure {
          tailf:info "Enable timer to recover from link monitoring failure";
          type empty;
        }
        leaf loopback {
          tailf:info "Enable timer to recover from loopback error";
          type empty;
        }
        leaf mac-limit {
          tailf:info "Enable timer to recover from mac limit disable state";
          type empty;
        }
        leaf mlacp-minlink {
          tailf:info "Enable timer to recover from mlacp minlink error disable state";
          type empty;
        }
        // errdisable recovery cause oam-remote-failure-enable
        container oam-remote-failure-enable {
          tailf:cli-drop-node-name;
          leaf oam-remote-failure {
            tailf:info "Enable timer to recover from remote failure detected by OAM";
            tailf:cli-full-no;
            type empty;
          }
        }
        container oam-remote-failure {
          tailf:info "Enable timer to recover from remote failure detected by OAM";
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          leaf critical-event {
            tailf:info "Enable timer to recover from remote failure detected by OAM critical event";
            type empty;
          }
          leaf dying-gasp {
            tailf:info "Enable timer to recover from remote failure detected by OAM dying gasp";
            type empty;
          }
          leaf link-fault {
            tailf:info "Enable timer to recover from remote failure detected by OAM link fault";
            type empty;
          }
        }
        leaf pagp-flap {
          tailf:info "Enable timer to recover from pagp-flap error";
          type empty;
        }
        leaf port-mode-failure {
          tailf:info "Enable timer to recover from port mode change failure";
          type empty;
        }
        leaf pppoe-ia-rate-limit {
          tailf:info "Enable timer to recover from PPPoE IA rate-limit error";
          type empty;
        }
        leaf psp {
          tailf:info "Enable timer to recover from psp";
          type empty;
        }
        leaf psecure-violation {
          tailf:info "Enable timer to recover from psecure violation error";
          type empty;
        }
        leaf security-violation {
          tailf:info "Enable timer to recover from 802.1x violation error";
          type empty;
        }
        leaf sfp-config-mismatch {
          tailf:info "Enable timer to recover from SFP config mismatch error";
          type empty;
        }
        leaf small-frame {
          tailf:info "Enable timer to recover from small frame error";
          type empty;
        }
        leaf storm-control {
          tailf:info "Enable timer to recover from storm-control error";
          type empty;
        }
        leaf udld {
          tailf:info "Enable timer to recover from udld error";
          type empty;
        }
        leaf unicast-flood {
          tailf:info "Enable timer to recover from unicast flood disable state";
          type empty;
        }
        leaf vmps {
          tailf:info "Enable timer to recover from vmps shutdown error";
          type empty;
        }
      }

      // errdisable recovery interval
      leaf interval {
        tailf:info "Error disable recovery timer value";
        type uint32 {
          tailf:info "<30-86400>;;timer-interval(sec)";
          range "30..86400";
        }
      }
    }
  }


  /// ========================================================================
  /// monitor
  /// ========================================================================

  container monitor {
    tailf:info "Monitoring different system events";
    tailf:cli-explicit-exit;

    // monitor session *
    list session {
      tailf:info "Configure a SPAN session";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      key id;
      leaf id {
        tailf:cli-suppress-range;
        type uint16 {
          tailf:info "<1-1024>;;SPAN session number";
          range "1..1024";
        }
      }

      // monitor session * destination
      container destination {
        tailf:info "SPAN destination interface or VLAN";

        // monitor session * destination interface *
        list interface {
          tailf:info "SPAN destination interface";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          ios:trim-delete-when-empty "( interface \\S+)";
          key id;
          leaf id {
            tailf:cli-suppress-range;
            type string {
              tailf:info "WORD;;Abbreviated Interface Name";
            }
          }
          leaf encapsulation {
            tailf:info "Set encapsulation for destination interface";
            tailf:cli-optional-in-sequence;
            type enumeration {
              enum dot1q {
                tailf:info "interface uses only dot1q encapsulation";
              }
              enum isl {
                tailf:info "interface uses only isl encapsulation";
              }
              enum replicate {
                tailf:info "interface uses only replicate encapsulation";
              }
            }
          }
          leaf ingress {
            tailf:info "Enable ingress traffic forwarding";
            type empty;
          }
          choice ingress-choice {
            leaf vlan {
              tailf:info "Set default VLAN for untagged ingress traffic";
              tailf:cli-optional-in-sequence;
              type uint16 {
                tailf:info "<1-4094>;;Default VLAN for untagged ingress traffic";
                range "1..4094";
              }
            }
            leaf learning {
              tailf:info "Enable host learning on ingress-enabled destination port";
              type empty;
            }
          }
        }

        // monitor session * destination remote vlan
        container remote {
          tailf:info "SPAN destination Remote";
          leaf vlan {
            tailf:info "Remote SPAN destination RSPAN VLAN";
            type uint16 {
              tailf:info "<2-1001,1006-4094>;;Remote SPAN destination VLAN number";
              range "2..1001|1006..4094";
            }
          }
        }
      }

      // monitor session * source
      container source {
        tailf:info "SPAN source interface, VLAN ";

        // monitor session * source interface *
        list interface {
          tailf:info "SPAN source interface";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-remove-before-change;
          key id;
          leaf id {
            tailf:cli-suppress-range;
            type string {
              tailf:info "WORD;;Abbreviated Interface Name";
            }
          }
          leaf mode {
            tailf:cli-drop-node-name;
            type enumeration {
              enum rx {
                tailf:info "Monitor received traffic only";
              }
              enum tx {
                tailf:info "Monitor transmitted traffic only";
              }
              enum both {
                tailf:info "Monitor received and transmitted traffic";
              }
            }
            default both;
          }
        }

        // monitor session * source vlan *
        list vlan {
          tailf:info "SPAN source VLAN";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-remove-before-change;
          key id;
          leaf id {
            tailf:cli-suppress-range;
            type uint16 {
              tailf:info "<1-4094>;;SPAN source VLAN";
              range "1..4094";
            }
          }
          leaf mode {
            tailf:cli-drop-node-name;
            type enumeration {
              enum rx {
                tailf:info "Monitor received traffic only";
              }
              enum tx {
                tailf:info "Monitor transmitted traffic only";
              }
              enum both {
                tailf:info "Monitor received and transmitted traffic";
              }
            }
            default both;
          }
        }

        // monitor session * source remote vlan
        container remote {
          tailf:info "SPAN source Remote";
          leaf vlan {
            tailf:info "Remote SPAN source RSPAN VLAN";
            type uint16 {
              tailf:info "<2-1001,1006-4094>;;Remote SPAN source VLAN number";
              range "2..1001|1006..4094";
            }
          }
        }
      }

      // monitor session * filter
      container filter {
        tailf:info "SPAN filter";

        // monitor session * filter vlan *
        leaf-list vlan {
          tailf:info "SPAN filter VLAN";
          tailf:cli-range-list-syntax;
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<1-4094>;;SPAN source VLAN";
            range "1..4094";
          }
        }

        // monitor session * filter packet-type
        container packet-type {
          tailf:info "SPAN filter packet-type";

          // monitor session * filter packet-type good rx
          container good {
            tailf:info "Monitor the good packets only";
            tailf:cli-diff-dependency "../bad" {
              tailf:cli-trigger-on-set;
            }
            leaf rx {
              tailf:info "Monitor received traffic only";
              type empty;
            }
          }

          // monitor session * filter packet-type bad rx
          container bad {
            tailf:info "Monitor the bad packets only";
            tailf:cli-diff-dependency "../good" {
              tailf:cli-trigger-on-set;
            }
            leaf rx {
              tailf:info "Monitor received traffic only";
              type empty;
            }
          }
        }

        // monitor session * filter ip access-group
        container ip {
          tailf:info "Specify IP Access control rules";
          leaf access-group {
            tailf:info "Specify access control group";
            type exp-ip-acl-type;
          }
        }

        // monitor session * filter mac access-group
        container mac {
          tailf:info "Specify MAC Access control rules";
          leaf access-group {
            tailf:info "Specify access control group";
            type string {
              tailf:info "WORD;;ACL name";
            }
          }
        }

        // monitor session * filter ipv6 access-group
        container ipv6 {
          tailf:info "Specify IPv6 Access control rules";
          leaf access-group {
            tailf:info "Specify access control group";
            type string {
              tailf:info "WORD;;ACL name";
            }
          }
        }

        // monitor session * filter address-type *
        list address-type {
          tailf:info "SPAN filter address-type";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key id;
          leaf id {
            type enumeration {
              enum broadcast {
                tailf:info "Monitor broadcast packets only";
              }
              enum multicast {
                tailf:info "Monitor multicast packets only";
              }
              enum unicast {
                tailf:info "Monitor unicast packets only";
              }
            }
          }
          leaf rx {
            tailf:info "Monitor received traffic only";
            type empty;
          }
          leaf tx {
            tailf:info "Monitor transmitted traffic only";
            type empty;
          }
        }
      }
    }

    // monitor session * type local
    container session-local {
      tailf:cli-drop-node-name;
      list session {
        tailf:info "Configure a SPAN session";
        tailf:cli-mode-name "config-mon-local";
        key "id type";
        leaf id {
          tailf:cli-suppress-range;
          type uint16 {
            tailf:info "<1-1024>;;SPAN session number";
            range "1..1024";
          }
        }
        leaf type {
          tailf:info "Type of monitor session";
          tailf:cli-expose-key-name;
          tailf:cli-full-command;
          type enumeration {
            enum local {
              tailf:info "Local SPAN Session";
            }
          }
        }

        // monitor session * type local / description
        uses description-quote-grouping;

        // monitor session * type local / shutdown
        leaf shutdown {
          tailf:info "Shutdown this session";
          type empty;
        }

        // monitor session * type local / source
        container source {
          tailf:info "SPAN source";

          // monitor session * type local / source interface *
          list interface {
            tailf:info "SPAN source interface";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key id;
            leaf id {
              type string {
                tailf:info "WORD;;Abbreviated Interface Name";
              }
            }
          }

          // monitor session * type local / source vlan *
          list vlan {
            tailf:info "SPAN source VLAN";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-remove-before-change;
            key id;
            leaf id {
              tailf:cli-suppress-range;
              type uint16 {
                tailf:info "<1-4094>;;SPAN source VLAN";
                range "1..4094";
              }
            }
            leaf mode {
              tailf:cli-drop-node-name;
              type enumeration {
                enum rx {
                  tailf:info "Monitor received traffic only";
                }
                enum tx {
                  tailf:info "Monitor transmitted traffic only";
                }
                enum both {
                  tailf:info "Monitor received and transmitted traffic";
                }
              }
              default both;
            }
          }
        }

        // monitor session * type local / destination interface *
        container destination {
          tailf:info "SPAN destination";
          list interface {
            tailf:info "SPAN destination interface";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key id;
            leaf id {
              type string {
                tailf:info "WORD;;Abbreviated Interface Name";
              }
            }
          }
        }
      }
    }

    // monitor session * type rspan-source
    container session-rspan-source {
      tailf:cli-drop-node-name;
      list session {
        tailf:info "Configure a SPAN session";
        tailf:cli-mode-name "config-mon-rspan-src";
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          tailf:cli-suppress-range;
          type uint16 {
            tailf:info "<1-1024>;;SPAN session number";
            range "1..1024";
          }
        }
        leaf type {
          tailf:info "Type of monitor session";
          tailf:cli-hide-in-submode;
          type enumeration {
            enum rspan-source {
              tailf:info "RSPAN Source Session";
            }
          }
        }

        // monitor session * type rspan-source / description
        uses description-quote-grouping;

        // monitor session * type rspan-source / shutdown
        leaf shutdown {
          tailf:info "Shutdown this session";
          type empty;
        }

        // monitor session * type rspan-source / source
        container source {
          tailf:info "SPAN source Interface/VLAN/CPU";

          // monitor session * type rspan-source / source interface *
          list interface {
            tailf:info "SPAN source interface";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key id;
            leaf id {
              type string {
                tailf:info "WORD;;Abbreviated Interface Name";
              }
            }
          }
        }

        // monitor session * type rspan-source / destination remote vlan
        container destination {
          tailf:info "SPAN destination";
          container remote {
            tailf:info "SPAN destination remote";
            leaf vlan {
              tailf:info "Remote SPAN VLAN";
              type uint16 {
                tailf:info "RSPAN VLAN number ";
                range "2..1001|1006..4094";
              }
            }
          }
        }
      }
    }

    // monitor session * type rspan-destination
    container session-rspan-destination {
      tailf:cli-drop-node-name;
      list session {
        tailf:info "Configure a SPAN session";
        tailf:cli-mode-name "config-mon-rspan-dst";
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          tailf:cli-suppress-range;
          type uint16 {
            tailf:info "<1-1024>;;SPAN session number";
            range "1..1024";
          }
        }
        leaf type {
          tailf:info "Type of monitor session";
          tailf:cli-hide-in-submode;
          type enumeration {
            enum rspan-destination {
              tailf:info "RSPAN Destination Session";
            }
          }
        }

        // monitor session * type rspan-destination / description
        uses description-quote-grouping;

        // monitor session * type rspan-destination / source remote vlan
        container source {
          tailf:info "SPAN source Interface/VLAN ";
          container remote {
            tailf:info "SPAN destination remote";
            leaf vlan {
              tailf:info "Remote SPAN VLAN";
              type uint16 {
                tailf:info "RSPAN VLAN number ";
                range "2..1001|1006..4094";
              }
            }
          }
        }

        // monitor session * type rspan-destination / destination
        container destination {
          tailf:info "SPAN destination";

          // monitor session * type rspan-destination / destination interface *
          list interface {
            tailf:info "SPAN destination interface";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key id;
            leaf id {
              type string {
                tailf:info "WORD;;Abbreviated Interface Name";
              }
            }
          }
        }
      }
    }

    // monitor session * type erspan-source
    container session-erspan-source {
      tailf:cli-drop-node-name;
      list session {
        tailf:info "Configure a SPAN session";
        tailf:cli-mode-name "config-mon-erspan-src";
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          tailf:cli-suppress-range;
          type uint16 {
            tailf:info "<1-1024>;;SPAN session number";
            range "1..1024";
          }
        }
        leaf type {
          tailf:info "Type of monitor session";
          tailf:cli-hide-in-submode;
          type enumeration {
            enum erspan-source {
              tailf:info "Encapsulated RSPAN Source Session";
            }
          }
        }

        // monitor session * type erspan-source / description
        uses description-quote-grouping;

        // monitor session * type erspan-source / shutdown
        leaf shutdown {
          tailf:info "Shutdown this session";
          type empty;
        }

        // monitor session * type erspan-source / source
        container source {
          tailf:info "SPAN source";

          // monitor session * type erspan-source / source vlan *
          list vlan {
            tailf:info "SPAN source VLAN";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-remove-before-change;
            key id;
            leaf id {
              tailf:cli-suppress-range;
              type uint16 {
                tailf:info "<1-4094>;;SPAN source VLAN";
                range "1..4094";
              }
            }
            leaf mode {
              tailf:cli-drop-node-name;
              type enumeration {
                enum rx {
                  tailf:info "Monitor received traffic only";
                }
                enum tx {
                  tailf:info "Monitor transmitted traffic only";
                }
                enum both {
                  tailf:info "Monitor received and transmitted traffic";
                }
              }
              default both;
            }
          }

          // monitor session * type erspan-source / source interface *
          list interface {
            tailf:info "SPAN source interface";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key id;
            leaf id {
              type string {
                tailf:info "WORD;;Abbreviated Interface Name";
              }
            }
          }
        }

        // monitor session * type erspan-source / destination
        container destination {
          tailf:info "Specify Destination and their properties";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-mon-erspan-src-dst";
          tailf:cli-full-command;

          // monitor session * type erspan-source / destination / erspan-id
          leaf erspan-id {
            tailf:info "Enter ERSPAN Identifier";
            type uint16 {
              tailf:info "<1-1023>;;Erspan ID";
              range "1..1023";
            }
          }

          // monitor session * type erspan-source / destination / mtu
          leaf mtu {
            tailf:info "Set the limitation size of ERSPAN encapsulation";
            type uint16 {
              tailf:info "<64-9216>;;MTU size in bytes";
              range "64..9216";
            }
          }

          // monitor session * type erspan-source / destination / ip
          container ip {
            tailf:info "IP Properties";

            // monitor session * type erspan-source / destination / ip address
            leaf address {
              tailf:info "Enter IP Address";
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IP address";
              }
            }
          }

          // monitor session * type erspan-source / destination / origin ip address
          container origin {
            tailf:info "Origin IP Properties";
            container ip {
              tailf:info "Origin IP Properties";
              leaf address {
                tailf:info "Enter IP Address";
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IP address";
                }
              }
            }
          }

          // monitor session * type erspan-source / destination / vrf
          leaf vrf {
            tailf:info "Enter VRF number";
            tailf:cli-diff-dependency "/ios:ip/vrf";
            tailf:cli-diff-dependency "/ios:vrf/definition";
            type string {
              tailf:info "WORD;;VRF ID";
            }
          }
        }
      }
    }

    // monitor session * type erspan-destination
    container session-erspan-destination {
      tailf:cli-drop-node-name;
      list session {
        tailf:info "Configure a SPAN session";
        tailf:cli-mode-name "config-mon-erspan-dst";
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          tailf:cli-suppress-range;
          type uint16 {
            tailf:info "<1-1024>;;SPAN session number";
            range "1..1024";
          }
        }
        leaf type {
          tailf:info "Type of monitor session";
          tailf:cli-hide-in-submode;
          type enumeration {
            enum erspan-destination {
              tailf:info "Encapsulated RSPAN Destination Session";
            }
          }
        }

        // monitor session * type erspan-destination / description
        uses description-quote-grouping;

        // monitor session * type erspan-destination / shutdown
        leaf shutdown {
          tailf:info "Shutdown this session";
          type empty;
        }

        // monitor session * type erspan-destination / destination interface *
        container destination {
          tailf:info "SPAN destination interface";
          list interface {
            tailf:info "SPAN destination interface";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key id;
            leaf id {
              type string {
                tailf:info "WORD;;Abbreviated Interface Name";
              }
            }
          }
        }

        // monitor session * type erspan-destination / source
        container source {
          tailf:info "Specify Source and their properties";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-mon-erspan-dst-src";
          tailf:cli-full-command;

          // monitor session * type erspan-destination / source / erspan-id
          leaf erspan-id {
            tailf:info "Enter ERSPAN Identifier";
            type uint16 {
              tailf:info "<1-1023>;;Erspan ID";
              range "1..1023";
            }
          }

          // monitor session * type erspan-destination / source / ip address
          container ip {
            tailf:info "IP Properties";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf address {
              tailf:info "Enter IP Address";
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IP address";
              }
            }
            leaf force {
              tailf:info "Change source IP Address for all ERSPAN Destination Sessions";
              type empty;
            }
          }

          // monitor session * type erspan-destination / source / vrf
          leaf vrf {
            tailf:info "Enter VRF number";
            tailf:cli-diff-dependency "/ios:ip/vrf";
            tailf:cli-diff-dependency "/ios:vrf/definition";
            type string {
              tailf:info "WORD;;VRF ID";
            }
          }
        }
      }
    }

    // monitor session * type capture
    container session-capture {
      tailf:cli-drop-node-name;
      list session {
        tailf:info "Configure a SPAN session";
        tailf:cli-mode-name "config-mon-capture";
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          tailf:cli-suppress-range;
          type uint16 {
            tailf:info "<1-1024>;;SPAN session number";
            range "1..1024";
          }
        }
        leaf type {
          tailf:info "Type of monitor session";
          tailf:cli-hide-in-submode;
          type enumeration {
            enum capture {
              tailf:info "Packet Capture SPAN Session";
            }
          }
        }

        // monitor session * type capture / description
        uses description-quote-grouping;

        // monitor session * type capture / buffer-size
        leaf buffer-size {
          tailf:info "Capture buffer size";
          type uint16 {
            tailf:info "<32-65535>;;size in kilobytes";
            range "32..65535";
          }
        }

        // monitor session * type capture / rate-limit
        leaf rate-limit {
          tailf:info "Packets per second value";
          type uint32 {
            tailf:info "<10-100000>;;packets per seconds";
            range "10..100000";
          }
        }

        // monitor session * type capture / filter
        container filter {
          tailf:info "Capture filter";

          // monitor session * type capture / filter length
          container length {
            tailf:info "Matching L2-packet length (software based)";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf min {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<0-9216>;;Minimun length of the packet";
                range "0..9216";
              }
              default 0;
            }
            leaf max {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<0-9216>;;Max length of the packet";
                range "0..9216";
              }
              default 0;
            }
          }

          // monitor session * type capture / filter access-group
          leaf access-group {
            tailf:info "Filter access-list (hardware based)";
            type exp-ip-acl-type;
          }

          // monitor session * type capture / filter vlan *
          leaf-list vlan {
            tailf:info "Filter vlan (hardware based)";
            tailf:cli-range-list-syntax;
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<1-4094>;;SPAN source VLAN";
              range "1..4094";
            }
          }
        }

        // monitor session * type capture / source
        container source {
          tailf:info "SPAN source";

          // monitor session * type capture / source vlan
          list vlan {
            tailf:info "SPAN source VLAN";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-remove-before-change;
            key id;
            leaf id {
              tailf:cli-suppress-range;
              type uint16 {
                tailf:info "<1-4094>;;SPAN source VLAN";
                range "1..4094";
              }
            }
            leaf mode {
              tailf:cli-drop-node-name;
              type enumeration {
                enum rx {
                  tailf:info "Monitor received traffic only";
                }
                enum tx {
                  tailf:info "Monitor transmitted traffic only";
                }
                enum both {
                  tailf:info "Monitor received and transmitted traffic";
                }
              }
              default both;
            }
          }

          // monitor session * type capture / source interface *
          list interface {
            tailf:info "SPAN source interface";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key id;
            leaf id {
              type string {
                tailf:info "WORD;;Abbreviated Interface Name";
              }
            }
            leaf mode {
              tailf:cli-drop-node-name;
              type enumeration {
                enum rx {
                 tailf:info "Monitor received traffic only";
                }
                enum tx {
                 tailf:info "Monitor transmitted traffic only";
                }
                enum both {
                 tailf:info "Monitor received and transmitted traffic";
                }
              }
              default both;
            }
          }
        }
      }
    }

    // monitor session X
    container session-conf {
      tailf:cli-drop-node-name;
      container session {
        tailf:info "Configure a SPAN session";

        // no monitor session servicemodule
        leaf servicemodule {
          tailf:info "Use SPAN to enable service module";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }
      }
    }

    // monitor event-trace *
    container event-trace {
      tailf:info "Tracing of system events";
      list event-trace-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key name;
        leaf name {
          tailf:cli-multi-word-key;
          type string {
            tailf:info "WORD;;event trace entry";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// network-clock-select
  /// ========================================================================

  // network-clock-select *
  list network-clock-select {
    tailf:info "Choose system clocking priority";
    tailf:cli-suppress-mode;
    tailf:cli-delete-when-empty;
    tailf:cli-compact-syntax;
    tailf:cli-sequence-commands {
      tailf:cli-reset-siblings;
    }
    key priority;
    leaf priority {
      type uint8 {
        tailf:info "<1-8>;;priority";
        range "1..8";
      }
    }
    leaf controller {
      tailf:cli-drop-node-name;
      type enumeration {
        enum E1 {
        }
        enum T1 {
        }
        enum ATM {
        }
        enum BRI {
        }
      }
    }
    leaf slot-port {
      tailf:cli-drop-node-name;
      type string;
    }
  }


  /// ========================================================================
  /// network-clock
  /// ========================================================================

  container network-clock {
    tailf:info "Network clock config commands";

    // network-clock revertive
    leaf revertive {
      tailf:info "Reference clock reverts to the highest QL/priority after failure";
      tailf:cli-full-command;
      tailf:cli-diff-set-after "../synchronization";
      type empty;
    }

    // network-clock synchronization
    container synchronization {
      tailf:info "Network clock synchronization selection process";

      // network-clock synchronization automatic
      leaf automatic {
        tailf:info "ITU-T G.781/Telcordia standard based synchronization selection process";
        type empty;
      }

      // network-clock synchronization ssm option
      container ssm {
        tailf:info "Synchronization Status Message process";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf option {
          tailf:info "Synchronization networking Option";
          type enumeration {
            enum "1" {
              tailf:info "Synchronization networking Option I";
            }
            enum "2" {
              tailf:info "Synchronization networking Option II";
            }
          }
          default "1";
        }
        leaf generation {
          tailf:cli-drop-node-name;
          when "../option = '2'" {
            tailf:dependency "../option";
          }
          type enumeration {
            enum GEN1 {
              tailf:info "Option II Generation 1";
            }
            enum GEN2 {
              tailf:info "Option II Generation 2";
            }
          }
        }
      }

      // network-clock synchronization mode
      container mode {
        tailf:info "synchronization networking mode";
        leaf QL-enabled {
          tailf:info "QL-enabled mode";
          type empty;
        }
      }
    }

    // network-clock input-source *
    list input-source {
      tailf:info "Synchronization Input Source";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-incomplete-command;
      key priority;
      leaf priority {
        type uint8 {
          tailf:info "<1-250>;;Priority";
          range "1..250";
        }
      }

      // network-clock input-source * interface
      container interface {
        tailf:info "Specify Ethernet, Sonet or ToP Interface";
        uses interface-name-grouping;
      }

      // network-clock input-source * ptp domain
      container ptp {
        tailf:info "Select a PTP Clock as a Frequency Clock Source";
        leaf domain {
          tailf:info "Domain Number for the PTP Clock Source";
          tailf:non-strict-leafref {
            path "/ios:ptp/clock/ordinary/domain/id";
          }
          type uint8 {
            tailf:info "<0-127>;;PTP Clock Domain Number";
            range "0..127";
          }
        }
      }
    }

    // network-clock input-source ? External *
    container input-source-external {
      tailf:cli-drop-node-name;
      list input-source {
        tailf:info "Synchronization Input Source";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-incomplete-command;
        key External;
        leaf priority {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type uint8 {
            tailf:info "<1-250>;;Priority";
            range "1..250";
          }
        }
        leaf External {
          tailf:info "External Interface (BITS/SSU/GPS";
          tailf:cli-expose-key-name;
          type string {
            tailf:info "WORD;;netsync X bits source slot";
          }
        }
        leaf signal-mode {
          tailf:cli-drop-node-name;
          type enumeration {
            enum 2m {
              tailf:info "2.048MHz Signal Mode";
            }
            enum 10m {
              tailf:info "10 MHz Signal Mode";
            }
            enum t1 {
              tailf:info "T1 Signal Mode";
            }
          }
        }
        leaf frame-signal-mode {
          tailf:cli-drop-node-name;
          type enumeration {
            enum d4 {
              tailf:info "D4 Super Frame Signal Mode";
            }
            enum esf {
              tailf:info "Extended Super Frame Signal Mode";
            }
            enum sf {
              tailf:info "Super Frame Signal Mode";
            }
          }
        }
        leaf linecode {
          tailf:info "Linecode option";
          type enumeration {
            enum ami {
              tailf:info "Linecode ami";
            }
            enum b8zs {
              tailf:info "Linecode b8zs";
            }
          }
        }
        leaf line-build-out {
          tailf:info "Line build out option";
          type enumeration {
            enum 0-133ft {
              tailf:info "0ft-133ft line build out";
            }
            enum 133-266ft {
              tailf:info "133ft-266ft line build out";
            }
            enum 266-399ft {
              tailf:info "266ft-399ft line build out";
            }
            enum 399-533ft {
              tailf:info "399ft-533ft line build out";
            }
            enum 533-655ft {
              tailf:info "533ft-655ft line build out";
            }
          }
        }
      }
    }

    // network-clock output-source system *
    container output-source {
      tailf:info "Synchronization output Source";
      list system {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key priority;
        leaf priority {
          type uint8 {
            tailf:info "<1-250>;;Priority";
            range "1..250";
          }
        }

        // network-clock output-source system * External *
        list External {
          tailf:info "External Interface (BITS/SSU/GPS)";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key name;
          leaf name {
            type union {
              type string {
                tailf:info "<slot>/<card>/<port>;;Enter 0 if card or port parameter is not valid";
              }
              type enumeration {
                enum "R0" {
                  tailf:info "netsync RP0 bits source slot";
                }
                enum "R1" {
                  tailf:info "netsync RP1 bits source slot";
                }
              }
            }
          }

          // network-clock output-source system * External * e1
          leaf e1 {
            tailf:info "E1 Signal Mode";
            type enumeration {
              enum cas {
                tailf:info "E1 Channel Associated Signal Mode";
              }
              enum crc4 {
                tailf:info "E1 With CRC4 Signal Mode";
              }
              enum fas {
                tailf:info "E1 Frame Alignment Signal Mode";
              }
            }
          }

          // network-clock output-source system * External * ohms
          leaf ohms {
            tailf:cli-drop-node-name;
            type enumeration {
              enum "120ohms" {
                tailf:info "120 ohms";
              }
              enum "75ohms" {
                tailf:info "75 ohms";
              }
            }
          }

          // network-clock output-source system * External * linecode
          leaf linecode {
            tailf:info "linecode option";
            type enumeration {
              enum ami {
                tailf:info "linecode ami";
              }
              enum hdb3 {
                tailf:info "linecode hdb3";
              }
            }
          }
        }
      }
    }

    // network-clock wait-to-restore
    container wait-to-restore {
      tailf:info "Wait-to-Restore timer";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf seconds {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<0-86400>;;sec (default 300 seconds)";
          range "0..86400";
        }
      }
      leaf global {
        tailf:info "Global";
        type empty;
      }
    }

    // network-clock log ql-changes
    container log {
      tailf:info "Logging options";
      leaf ql-changes {
        tailf:info "Log input QL changes";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// esmc
  /// ========================================================================

  container esmc {
    tailf:info "Ethernet Synchronization Messaging Channel";

    // esmc process
    leaf process {
      tailf:info "process";
      type empty;
    }
  }


  /// ========================================================================
  /// trapflags
  /// ========================================================================

  // trapflags *
  list trapflags {
    tailf:info "Enable or Disable trap flags that apply to the switch";
    tailf:cli-suppress-mode;
    tailf:cli-delete-when-empty;
    tailf:cli-full-command;
    key name;
    leaf name {
      tailf:cli-multi-word-key;
      type string {
        tailf:info "WORD;;Trap flag name, e.g. 'ap crash";
      }
    }
  }


  /// ========================================================================
  /// restconf
  /// ========================================================================

  // restconf
  container restconf {
    tailf:info "Enable restconf";
    presence true;
  }


  /// ========================================================================
  /// netconf
  /// ========================================================================

  container netconf {
    tailf:info "Configure NETCONF";

    // netconf max-sessions
    leaf max-sessions {
      tailf:info "Limit total number of NETCONF sessions";
      type uint8 {
        tailf:info "<4-16>;;Maximum NETCONF sessions (default 4)";
        range "4..16";
      }
      default 4;
    }

    // netconf lock-time
    leaf lock-time {
      tailf:info "Limit time NETCONF can lock configuration";
      type uint16 {
        tailf:info "<1-300>;;Maximum NETCONF config lock time in seconds. Default 10";
        range "1..300";
      }
      default 10;
    }

    // netconf max-message
    leaf max-message {
      tailf:info "maximum received message size";
      type uint32 {
        tailf:info "<1-2147483>;;Kbytes";
        range "1..2147483";
      }
    }

    // netconf ssh
    container ssh {
      tailf:info "Use SSH to establish NETCONF session";
      tailf:cli-delete-when-empty;
      tailf:cli-reset-container;
      presence true;

      // netconf ssh acl
      leaf acl {
        tailf:info "use an access list on this session";
        type uint32 {
          tailf:info "<1-65536>;;ACL to use for this session";
          range "1..65536";
        }
      }
    }
  }


  /// ========================================================================
  /// netconf-yang
  /// ========================================================================

  container netconf-yang {
    tailf:info "Enable netconf-yang";
    tailf:cli-incomplete-command;
    tailf:cli-incomplete-no;

    // netconf-yang cisco-ia
    container cisco-ia {
      tailf:info "Configure cisco-ia parameters";

      // netconf-yang cisco-ia snmp-trap-control *
      container snmp-trap-control {
        tailf:info "Configuration parameters for SNMP trap to NetConf notification processing";

        // netconf-yang cisco-ia snmp-trap-control trap-list *
        list trap-list {
          tailf:info "Configure translation of SNMP Traps to NetConf notifications";
          tailf:cli-mode-name "config-cia-trap";
          key oid;
          leaf oid {
            type string {
              tailf:info "WORD;;Enter SNMP trap OID string";
            }
          }
        }
      }

      // netconf-yang cisco-ia logging
      container logging {
        tailf:info "CIA logging configuration";

        // netconf-yang cisco-ia logging nes-log-level
        leaf nes-log-level {
          tailf:info "Logging level for NES";
          type netconf-yang-cia-log-level;
          default error;
        }

        // netconf-yang cisco-ia logging sync-log-level
        leaf sync-log-level {
          tailf:info "Logging level for SyncD";
          type netconf-yang-cia-log-level;
          default error;
        }
      }
    }

    // netconf-yang cisco-odm
    container cisco-odm {
      tailf:info "Configure cisco-odm parameters";

      // netconf-yang cisco-odm actions *
      list actions {
        tailf:info "Configure cisco-odm actions";
        tailf:cli-mode-name "config-odm-action";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Enter action string";
          }
        }
      }

      // netconf-yang cisco-odm polling-enable
      leaf polling-enable {
        tailf:info "Enables ODM polling";
        type empty;
      }
    }

    // netconf-yang feature candidate-datastore
    container feature {
      tailf:info "Configure netconf-yang features";
      leaf candidate-datastore {
        tailf:info "Enable the Candidate Datastore";
        type empty;
      }
    }

    // netconf-yang ssh
    container ssh {
      tailf:info "Configqure ssh options";

      // netconf-yang ssh port
      leaf port {
        tailf:info "Starting (or only) Port number to listen on";
        type uint16 {
          tailf:info "<1-65535>;;Port number range (default port number is 830)";
          range "1..65535";
        }
        default 830;
      }

      // netconf-yang ssh ipv4 access-list name
      container ipv4 {
        tailf:info "IPv4 configuration parameters";
        container access-list {
          tailf:info "Configure the NETCONF-YANG SSH service to use an IPv4 ACL";
          leaf name {
            tailf:info "Configure the NETCONF-YANG SSH service to use a named IPv4 ACL";
            tailf:cli-diff-dependency "../../../../../ip/access-list";
            type string {
              tailf:info "WORD;;A named IPv4 ACL";
            }
          }
        }
      }
    }
  }

  // netconf-yang
  container netconf-yang-enable {
    tailf:cli-drop-node-name;
    leaf netconf-yang {
      tailf:info "Enable netconf-yang";
      type empty;
    }
  }


  /// ========================================================================
  /// tftp-server
  /// ========================================================================

  list tftp-server {
    tailf:info "Provide TFTP service for netload requests";
    tailf:cli-suppress-mode;
    tailf:cli-delete-when-empty;
    tailf:cli-compact-syntax;
    key name;
    leaf name {
      type string {
        tailf:info "Allow URL file TFTP load requests";
      }
    }
    leaf alias {
      tailf:info "file alias";
      type string {
        tailf:info "WORD;;file alias";
      }
    }
    leaf access-list {
      tailf:cli-drop-node-name;
      tailf:cli-disallow-value "alias";
      type std-ip-acl-type;
    }
  }


  /// ========================================================================
  /// ftp-server
  /// ========================================================================

  container ftp-server {

    // no ftp-server write-enable
    leaf write-enable {
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
      default true;
    }

    // ftp-server enable
    leaf enable {
      tailf:info "Enable IOS FTP Server";
      type empty;
    }
  }


  /// ========================================================================
  /// radius-server
  /// ========================================================================

  container radius-server {
    tailf:info "Modify RADIUS query parameters";
    tailf:cli-diff-dependency "../aaa/new-model";

    // radius-server load-balance method least-outstanding
    container load-balance {
      tailf:info "Radius load-balancing options.";
      container method {
        tailf:info "Method by which the next host will be picked.";
        container least-outstanding {
          tailf:info "Pick the server with the least transactions outstanding.";
          tailf:cli-compact-syntax;
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          presence true;
          leaf batch-size {
            tailf:info "Size of the transaction batch that should be load-balanced.";
            type uint32 {
              tailf:info "<1-2147483647>;;Number of transactions after which load-balancing should be performed (Default 25)";
              range "1..2147483647";
            }
            default 25;
          }
          leaf ignore-preferred-server {
            tailf:info "Should the preferred-server be ignored.";
            type empty;
          }
        }
      }
    }

    // radius-server attribute 11 default direction
    // note: outside the list due to hidden default out, making whole line disappear
    container attribute-11 {
      tailf:cli-drop-node-name;
      container attribute {
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf id {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type enumeration {
            enum "11" {
              tailf:info "NUM;;attribute id";
            }
          }
          default "11";
        }
        container default {
          tailf:info "Set the attribute defaults";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          leaf direction {
            tailf:info "Set the attribute default direction";
            type enumeration {
              enum "in" {
                tailf:info "Filtering is applied to ingress(inbound) packets only";
              }
              enum "out" {
                tailf:info "Filtering is applied to egress(outbound) packets only";
              }
            }
            default "out";
          }
        }
      }
    }

    // radius-server attribute *
    container attribute {
      tailf:info "Customize selected radius attributes";
      list attribute-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key id;
        leaf id {
          type union {
            type uint8 {
              tailf:info "NUM;;attribute id";
            }
            type enumeration {
              enum nas-port {
                tailf:info "NAS-Port attribute configuration";
              }
              enum nas-port-id {
                tailf:info "Nas-Port-Id attribute configuration";
              }
              enum wireless {
                tailf:info "Radius wireless attributes";
              }
            }
          }
        }

        // radius-server attribute * on-for-login-auth
        leaf on-for-login-auth {
          tailf:info "Send attribute 6 in authentication packet";
          type empty;
        }

        // radius-server attribute * support-multiple
        leaf support-multiple {
          tailf:info "Support multiple Service-Type values per Radius profile";
          type empty;
        }

        // radius-server attribute * mandatory
        leaf mandatory {
          tailf:info "Enforce Service-Type attribute in Access-Accep";
          type empty;
        }

        // radius-server attribute * include-in-access-req
        leaf include-in-access-req {
          tailf:info "Send attribute 8 in access-req packet";
          type empty;
        }

        // radius-server attribute 32 include-in-accounting-req
        leaf include-in-accounting-req {
          tailf:info "Send attr 32 in accounting req";
          type empty;
        }

        // radius-server attribute * remote-id
        leaf remote-id {
          tailf:info "Replace with Remote-id if available";
          type empty;
        }

        // radius-server attribute * access-request include
        container access-request {
          tailf:info "Access-Request packet";
          leaf include {
            tailf:info "Include attribute";
            type empty;
          }
        }

        // radius-server attribute * send nas-port-detail
        container send {
          tailf:info "Calling Station ID options";
          container nas-port-detail {
            tailf:info "include nas-port details in Calling Station ID";
            tailf:cli-reset-container;
            tailf:cli-delete-when-empty;
            presence true;
            leaf mac-only {
              tailf:info "include only mac-addr if available in the Calling-station-id";
              type empty;
            }
          }
        }

        // radius-server attribute * mac format
        container mac {
          tailf:info "Customize MAC address based Calling Station ID";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf format {
            tailf:info "Specify format (default format ex: 0000.4096.3e4a)";
            type enumeration {
              enum default {
                tailf:info "format ex: 0000.4096.3e4a";
              }
              enum ietf {
                tailf:info "format ex: 00-00-40-96-3E-4A";
              }
              enum one-byte {
                tailf:info "format ex: 00.00.40.96.3e.4a";
              }
              enum three-byte {
                tailf:info "format ex: 000040.963e4a";
              }
              enum two-byte {
                tailf:info "format ex: 0000.4096.3e4a";
              }
              enum unformatted {
                tailf:info "format ex: 000040963e4a";
              }
            }
            default default;
          }
          leaf case {
            tailf:cli-drop-node-name;
            type enumeration {
              enum lower-case {
                tailf:info "Specify MAC address in lower case";
              }
              enum upper-case {
                tailf:info "Specify MAC address in upper case";
              }
            }
            default lower-case;
          }
        }

        // radius-server attribute * include
        container include {
          tailf:info "include one or more identifiers in nas-port-id";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf identifier {
            tailf:cli-drop-node-name;
            type enumeration {
              enum circuit-id {
                tailf:info "Circuit ID";
              }
              enum remote-id {
                tailf:info "Remote ID";
              }
              enum vendor-class-id {
                tailf:info "Vendor Class ID";
              }
            }
          }
          leaf plus {
            tailf:info "Use additional identifiers";
            type enumeration {
              enum circuit-id {
                tailf:info "Circuit ID";
              }
              enum remote-id {
                tailf:info "Remote ID";
              }
              enum vendor-class-id {
                tailf:info "Vendor Class ID";
              }
            }
          }
          container plus2 {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            tailf:cli-flatten-container;
            leaf plus {
              tailf:info "Use additional identifiers";
              type enumeration {
                enum circuit-id {
                  tailf:info "Circuit ID";
                }
                enum remote-id {
                  tailf:info "Remote ID";
                }
                enum vendor-class-id {
                  tailf:info "Vendor Class ID";
                }
              }
            }
          }
          leaf separator {
            tailf:info "separator to be used between keys";
            type string {
              tailf:info "WORD;;separator to be used between keys, default is ':'";
            }
            default ":";
          }
        }

        // radius-server attribute * authentication
        container authentication {
          tailf:info "Radius authentication attributes";

          // radius-server attribute * wireless authentication call-station-id
          leaf call-station-id {
            tailf:info "Configure Call Station Id sent in radius authentication messages";
            type enumeration {
              enum ap-ethmac-only {
                tailf:info "Sets Call Station Id Type to AP's MAC";
              }
              enum ap-ethmac-ssid {
                tailf:info "Sets Call Station Id Type to 'AP's MAC':'SSID'";
              }
              enum ap-group-name {
                tailf:info "Sets Call Station Id Type to AP Group Name";
              }
              enum ap-label-address {
                tailf:info "Sets Call Station Id Type to AP label address";
              }
              enum ap-label-address-ssid {
                tailf:info "Sets Call Station Id Type to 'AP label address':'SSID'";
              }
              enum ap-location {
                tailf:info "Sets Call Station Id Type to AP Location";
              }
              enum ap-macaddress {
                tailf:info "Sets Call Station Id Type to the AP's MAC Address";
              }
              enum ap-macaddress-ssid {
                tailf:info "Sets Call Station Id Type to 'AP MAC address':'SSID'";
              }
              enum ap-name {
                tailf:info "Sets Call Station Id Type to the AP Name";
              }
              enum ap-name-ssid {
                tailf:info "Sets Call Station Id Type to 'AP Name':'SSID'";
              }
              enum ipaddress {
                tailf:info "Sets Call Station Id Type to the system's IP Address";
              }
              enum macaddress {
                tailf:info "Sets Call Station Id Type to the system's MAC Address";
              }
              enum site-tag-name {
                tailf:info "Sets Call Station Id Type to AP Site tag Name";
              }
              enum vlan-id {
                tailf:info "Sets Call Station Id Type to the vlan-id";
              }
            }
          }
        }
      }
    }

    // radius-server dead-criteria
    container dead-criteria {
      tailf:info "Set the criteria used to decide when a radius server is marked dead";
      tailf:cli-compact-syntax;
      leaf time {
        tailf:info "The time during which no properly formed response must be recieved from the RADIUS server";
        type uint8 {
          tailf:info "<1-120>;;Time in seconds during which no response must "+
            "be recieved from the RADIUS server in order to consider it dead";
          range "1..120";
        }
      }
      leaf tries {
        tailf:info "The number of times the router must fail to recieve a response from the radius server to mark it as dead";
        type uint8 {
          tailf:info "<1-100>;;Number of transmits to radius server without responses before marking server as dead";
          range "1..100";
        }
      }
    }

    // radius-server configure-nas
    leaf configure-nas {
      tailf:info "Attempt to upload static routes and IP pools at startup";
      type empty;
    }

    // radius-server throttle
    container throttle {
      tailf:info "Throttle requests to radius server";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf accounting {
        tailf:info "Throttle accounting requests sent to a radius server";
        tailf:cli-optional-in-sequence;
        type uint16 {
          tailf:info "<0-65535>;;Number of outstanding accounting transactions after which throttling should be performed";
        }
      }
      leaf access {
        tailf:info "Throttle access requests sent to a radius server";
        type uint16 {
          tailf:info "<0-65535>;;Number of outstanding access transactions after which throttling should be performed";
        }
      }
      leaf access-timeout {
        tailf:info "Number of consecutive timeouts exceeding which the access request is dropped";
        type uint8 {
          tailf:info "<1-10>;;Number of timeouts for a transaction (Default 3)";
          range "1..10";
        }
      }
    }

    // radius-server deadtime
    leaf deadtime {
      tailf:info "Time to stop using a server that doesn't respond";
      type uint16 {
        tailf:info "<1-1440>;;time in minutes";
        range "1..1440";
      }
    }

    // radius-server host *
    list host {
      tailf:info "Specify a RADIUS server";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-show-long-obu-diffs;
      ordered-by user;
      key id;
      leaf id {
        type inet:host {
          tailf:info "Hostname or A.B.C.D;;IP address of RADIUS server";
        }
      }
      uses radius-server-grouping;
    }

    // radius-server retransmit
    leaf retransmit {
      tailf:info "Specify the number of retries to active server";
      type uint8 {
        tailf:info "<0-100>;;Number of retries for a transaction (default is 3)";
        range "0..100";
      }
      default 3;
    }

    // radius-server timeout
    leaf timeout {
      tailf:info "Time to wait for a RADIUS server to reply";
      type uint16 {
        tailf:info "<1-1000>;;Wait time (default 5 seconds)";
        range "1..1000";
      }
      default 5;
    }

    // radius-server vsa
    container vsa {
      tailf:info "Vendor specific attribute configuration";

      // radius-server vsa send
      container send {
        tailf:info "Send vendor-specific attributes in requests";
        leaf accounting {
          tailf:info "Send in accounting requests";
          type empty;
        }
        leaf authentication {
          tailf:info "Send in access requests";
          type empty;
        }
      }
    }

    // radius-server key
    container key {
      tailf:info "encryption key shared with the RADIUS servers";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      uses password-grouping {
        refine "secret" {
          cli:secret " key <SECRET>";
        }
      }
    }

    // radius-server authorization permit missing service-Type
    container authorization {
      tailf:info "DEPRECATED hidden command";
      container permit {
        tailf:info "DEPRECATED hidden command";
        container missing {
          tailf:info "DEPRECATED hidden command";
          leaf service-Type {
            tailf:info "Warning!!! ' radius-server authorization permit missing Service-Type ' is a hidden command."
              +"Use of this command is not recommended/supported and will be removed in future.";
            type empty;
          }
        }
      }
    }
  }


  /// ========================================================================
  /// radius
  /// ========================================================================

  container radius {
    tailf:info "RADIUS server configuration command";

    // radius filter *
    list filter {
      tailf:info "Packet filter configuration";
      key id;
      leaf id {
        type string {
          tailf:info "WORD;;Name of the filter (max 31 characters, longer will be rejected";
        }
      }
      leaf match {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        type enumeration {
          enum match-all {
            tailf:info "Filter if all of the attributes matches";
          }
          enum match-any {
            tailf:info "Filter if any of the attributes matches";
          }
        }
      }
    }

    // radius server *
    list server {
      tailf:info "Server configuration";
      tailf:cli-mode-name "config-radius-server";
      key id;
      leaf id {
        type string {
          tailf:info "WORD;;Name for the radius server configuration";
        }
      }

      // radius server * / address
      container address {
        tailf:info "Specify the radius server address";

        // radius server * / address ipv4
        container ipv4 {
          tailf:info "IPv4 Address";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf host {
            tailf:cli-drop-node-name;
            type inet:host {
              tailf:info "Hostname or A.B.C.D;;IPv4 Address of radius server";
            }
          }
          // alias 1-8 aliases for this server (max. 8)
          leaf auth-port {
            tailf:info "UDP port for RADIUS authentication server (default is 1645)";
            tailf:cli-optional-in-sequence;
            type uint16 {
              tailf:info "<0-65535>;;Port number";
              range "0..65535";
            }
          }
          leaf acct-port {
            tailf:info "UDP port for RADIUS accounting server (default is 1646)";
            type uint16 {
              tailf:info "<0-65535>;;Port number";
              range "0..65535";
            }
          }
        }
      }

      // radius server * / timeout
      leaf timeout {
        tailf:info "Time to wait (in seconds) for this radius server to reply (overrides default)";
        type uint16 {
          tailf:info "<1-1000>;;Timeout value in seconds";
          range "1..1000";
        }
      }

      // radius server * / retransmit
      leaf retransmit {
        tailf:info "Number of retries to active server (overrides default)";
        type uint8 {
          tailf:info "<0-100>;;Number of retries to this server";
          range "0..100";
        }
      }

      // radius server * / non-standard
      leaf non-standard {
        tailf:info "Attributes to be parsed that violate RADIUS standard";
        type empty;
      }

      // radius server * / backoff exponential
      container backoff {
        tailf:info "Retry backoff pattern(Default is retransmits with constant delay)";
        container exponential {
          tailf:info "Exponential retransmit backoff";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          presence true;
          leaf max-delay {
            tailf:cli-optional-in-sequence;
            tailf:info "Max delay between retransmits(default is 3 min)";
            type uint8 {
              tailf:info "<1-120>;;Max time (in minutes) to delay between retransmits";
              range "1..120";
            }
          }
          leaf backoff-retry {
            tailf:info "Exponential backoff retry number(default is 8)";
            type uint8 {
              tailf:info "<1-50>;;Number of retransmits in the exponential backoff mode";
              range "1..50";
            }
          }
        }
      }

      // radius server * / key
      // radius server * / pac key
      choice key-choice {
        container key {
          tailf:info "Per-server encryption key";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          uses password-grouping {
            refine "secret" {
              cli:secret " key <SECRET>";
            }
          }
        }
        container pac {
          tailf:info "Protected Access Credential key";
          container key {
            tailf:info "Per-server encryption key";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            uses password-grouping {
              refine "secret" {
                cli:secret " key <SECRET>";
              }
            }
          }
        }
      }

      // radius server * / automate-tester username
      container automate-tester {
        tailf:info "Configure server automated testing.";
        container username {
          tailf:info "A name that should be used to send requests.";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-all-siblings;
          }
          leaf name {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;User Name";
            }
          }
          leaf ignore-auth-port {
            tailf:info "Do not test authentication port of the servers.";
            tailf:cli-break-sequence-commands;
            type empty;
          }
          leaf ignore-acct-port {
            tailf:info "Do not test accounting ports of the servers.";
            type empty;
          }
          leaf probe-on {
            tailf:info "Send a packet to verify the server status";
            type empty;
          }
          leaf idle-time {
            tailf:info "Minutes of idle-time after which server state should be verified.";
            type uint16 {
              tailf:info "<1-35791>;;Idle-time in minutes (default 60 mins).";
              range "1..35791";
            }
            default 60;
          }
        }
      }
    }
  }


  /// ========================================================================
  /// zone
  /// ========================================================================

  container zone {
    tailf:info "FW with zoning";

    // zone security *
    list security {
      tailf:info "Security zone";
      tailf:cli-mode-name "config-sec-zone";
      tailf:cli-full-command;
      key id;
      leaf id {
        type string {
          tailf:info "WORD;;Name of security zone";
        }
      }

      // zone security * / description
      leaf description {
        tailf:info "Zone description";
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE;;Description of zone (up to 200 characters)";
        }
      }

      // zone security * / protection
      leaf protection {
        tailf:info "config syn cookie protection against sync flood";
        tailf:cli-diff-dependency "../../../parameter-map";
        type string {
          tailf:info "WORD;;parameter map name";
        }
      }
    }
  }


  /// ========================================================================
  /// zone-pair
  /// ========================================================================

  container zone-pair {
    tailf:info "Zone pair command";

    // zone-pair security *
    list security {
      tailf:info "Zone-pair name";
      tailf:cli-mode-name "config-sec-zone-pair";
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      key id;
      leaf id {
        type string {
          tailf:info "WORD;;Name of zone-pair";
        }
      }

      // zone-pair security * source
      leaf source {
        tailf:info "Source zone";
        tailf:cli-hide-in-submode;
        tailf:non-strict-leafref {
          path "../../../zone/security/id";
        }
        type string {
          tailf:info "WORD;;Name of source zone";
        }
      }

      // zone-pair security * destination
      leaf destination {
        tailf:info "Destination zone";
        tailf:cli-hide-in-submode;
        tailf:non-strict-leafref {
          path "../../../zone/security/id";
        }
        type string {
          tailf:info "WORD;;Name of destination zone";
        }
      }

      // zone-pair security * / description
      leaf description {
        tailf:info "Zone description";
        tailf:cli-break-sequence-commands;
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE;;Description of zone (up to 200 characters)";
          length "1..200";
        }
      }

      // zone-pair security * / service-policy
      container service-policy {
        tailf:info "Configure CBAC Service Policy";
        container type {
          tailf:info "Service Policy type";
          leaf inspect {
            tailf:info "Configure CBAC Service Policy type inspect";
            tailf:cli-remove-before-change;
            tailf:non-strict-leafref {
              path "../../../../../policy-map/name";
            }
            type string {
              tailf:info "WORD;;output Policy-map name";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// alarm-profile
  /// ========================================================================

  // alarm-profile *
  container alarm-profile {
    tailf:info "Configure Alarm Profile";
    tailf:cli-explicit-exit;

    // alarm-profile *
    list entry-list {
      tailf:cli-drop-node-name;
      tailf:cli-sequence-commands;
      tailf:cli-mode-name "config-alarm-profile";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;alarm-profile name";
        }
      }
      leaf type {
        tailf:cli-drop-node-name;
        tailf:cli-hide-in-submode;
        tailf:cli-full-command;
        type enumeration {
          enum attach {
            tailf:info "Attach alarm profile";
          }
          enum card {
            tailf:info "Card Level Profile";
          }
          enum chassis {
            tailf:info "Chassis Level Profile";
          }
          enum port {
            tailf:info "Port Level Profile";
          }
        }
      }

      // alarm-profile * / ains
      leaf ains {
        tailf:cli-break-sequence-commands;
        tailf:info "Enable ains for the profile";
        type empty;
      }

      // alarm-profile * / alarm *
      list alarm {
        tailf:info "Alarm types";
        tailf:cli-mode-name "config-alarm-properties";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Alarms name, e.g. ds1|ds3|gig etc";
          }
        }

        // alarm-profile * / alarm * / *
        list property {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          key name;
          leaf name {
            tailf:cli-disallow-value "exit";
            type string {
              tailf:info "WORD;;Alarm property name";
            }
          }
          leaf suppress {
            tailf:info "Suppress alarm reporting for a single alarm";
            type empty;
          }
          leaf severity {
            tailf:info "Change severity";
            type enumeration {
              enum INFO {
                tailf:info "INFO";
              }
              enum MINOR {
                tailf:info "MINOR";
              }
              enum MAJOR {
                tailf:info "MAJOR";
              }
              enum CRITICAL {
                tailf:info "CRITICAL";
              }
            }
          }
        }
      }
    }

    // alarm-profile * attach chassis
    container attach-chassis {
      tailf:cli-drop-node-name;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf name {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        tailf:non-strict-leafref {
          path "../../entry-list/name";
        }
        type string {
          tailf:info "WORD;;alarm-profile name";
        }
      }
      leaf attach {
        tailf:info "Attach alarm profile";
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        type empty;
      }
      leaf chassis {
        tailf:info "Attach profile to chassis";
        type empty;
      }
    }

    // alarm-profile * attach card *
    list attach-card-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      key card;
      leaf name {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        tailf:non-strict-leafref {
          path "../../entry-list/name";
        }
        type string {
          tailf:info "WORD;;alarm-profile name";
        }
      }
      leaf attach {
        tailf:info "Attach alarm profile";
        tailf:cli-prefix-key;
        type empty;
      }
      leaf card {
        tailf:info "Attach profile to card";
        tailf:cli-expose-key-name;
        type string {
          tailf:info "<0-1>/<0-15>;;Enter card slot/subslot number";
        }
      }
    }
  }


  /// ========================================================================
  /// alarm-contact
  /// ========================================================================

  list alarm-contact {
    tailf:info "Configure the system alarm contact settings";
    tailf:cli-suppress-mode;
    tailf:cli-delete-when-empty;
    tailf:cli-incomplete-command;
    key name;
    leaf name {
      type union {
        type uint8 {
          tailf:info "<1-4>;;Alarm contact number";
          range "1..4";
        }
        type enumeration {
          enum all {
            tailf:info "Configure all alarm contacts";
          }
        }
      }
    }

    // alarm-contact * description
    leaf description {
      tailf:cli-multi-value;
      tailf:cli-preformatted;
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;Description";
        length "1..80";
      }
    }

    // alarm-contact * severity
    leaf severity {
      tailf:info "Set the severity level reported";
      type enumeration {
        enum critical {
          tailf:info "Critical alarm severity";
        }
        enum major {
          tailf:info "Major alarm severity";
        }
        enum minor {
          tailf:info "Minor alarm severity";
        }
      }
    }

    // alarm-contact * trigger
    leaf trigger {
      tailf:info "Set the alarm trigger";
      type enumeration {
        enum closed {
          tailf:info "Assert alarm when contact is closed";
        }
        enum open {
          tailf:info "Assert alarm when contact is open";
        }
      }
    }
  }


  /// ========================================================================
  /// routing-default-optimize
  /// ========================================================================

  // no routing-default-optimize
  leaf routing-default-optimize {
    tailf:info "Enable routing default optimization";
    tailf:cli-boolean-no;
    tailf:cli-full-command;
    type boolean;
    default true;
  }


  /// ========================================================================
  /// mpls
  /// ========================================================================

  container mpls {
    tailf:info "Configure MPLS parameters";

    // mpls atm
    container atm {
      tailf:info "Configure ATM options";
      leaf disable-headend-vc {
        tailf:info "Dedicated lsc capability: In this mode headend Tag VCs are disabled.";
        type empty;
      }
    }

    // mpls oam
    container oam {
      tailf:info "OAM configuration";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-mpls";

      // mpls oam / echo
      container echo {
        tailf:info "Echo Packet Attributes";

        // mpls oam / echo revision
        leaf revision {
          tailf:info "Echo packet default revision";
          type enumeration {
            enum 3 {
              tailf:info "draft-ietf-mpls-lsp-ping-03 (rev 2)";
            }
            enum 4 {
              tailf:info "RFC 4379 Compliant";
            }
          }
        }
      }
    }

    // mpls cos-map
    leaf cos-map {
      tailf:info "Configure MPLS CoS ATM Multi-VC CoS Map";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<1-255>;;cos-map number";
        range "1..255";
      }
    }

    // no mpls ip
    leaf ip {
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
      default true;
    }

    // mpls ip
    container mpls-ip-conf {
      tailf:cli-drop-node-name;
      container ip {
        tailf:info "Dynamic MPLS forwarding for IP";
        tailf:cli-incomplete-no;
        tailf:cli-incomplete-command;

        // mpls ip default-route
        leaf default-route {
          tailf:info "Allow MPLS forwarding for ip default route";
          tailf:cli-full-command;
          type empty;
        }

        choice propagate-ttl-choice {
          // no mpls ip propagate-ttl
          container propagate-ttl-conf {
            tailf:cli-drop-node-name;
            leaf propagate-ttl {
              tailf:info "Propagate IP TTL into the label stack";
              tailf:cli-boolean-no;
              tailf:cli-full-command;
              type boolean;
              default true;
            }
          }
          // no mpls ip propagate-ttl forwarded
          container propagate-ttl {
            tailf:cli-incomplete-command;
            tailf:cli-incomplete-no;
            leaf forwarded {
              tailf:info "Propagate IP TTL for forwarded traffic";
              tailf:cli-boolean-no;
              tailf:cli-full-command;
              type boolean;
              default true;
            }
          }
        }

        // mpls ip ttl-exp
        container ttl-expiration {
          tailf:info "Control MPLS TTL expiration behavior";
          leaf pop {
            tailf:info "Popping labels on TTL expiration";
            type uint8 {
              tailf:info "<1-6>;;Popping all labels if original packet has less than N labels";
              range "1..6";
            }
          }
        }
      }
    }

    // mpls label
    container label {
      tailf:info "Label properties";

      // mpls label mode
      container mode {
        tailf:info "MPLS Label allocation mode";

        // mpls label mode all-vrfs
        container all-vrfs {
          tailf:info "MPLS Label allocation mode for all VRFs";
          uses mpls-label-mode-grouping;
        }

        // mpls label mode vrf *
        list vrf {
          tailf:info "MPLS Label allocation mode for a specific VRF";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          key name;
          leaf name {
            tailf:cli-diff-dependency "../../../../../ip/vrf";
            tailf:cli-diff-dependency "../../../../../vrf/definition";
            type string {
              tailf:info "WORD;;VPN Routing/Forwarding instance name";
            }
          }
          uses mpls-label-mode-grouping;
        }
      }

      // mpls label atm
      container atm {
        tailf:info "Configure ATM options";
        leaf disable-headend-vc {
          tailf:info "Dedicated lsc capability: In this mode headend Tag VCs are disabled.";
          type empty;
        }
      }

      // mpls label protocol
      leaf protocol {
        tailf:info "Set platform default label distribution protocol";
        tailf:cli-full-command;
        type enumeration {
          enum ldp {
            tailf:info "Use LDP (default)";
          }
          enum tdp {
            tailf:info "Use TDP";
          }
        }
      }

      // mpls label range
      container range {
        tailf:info "Label range";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf min {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<16-1048575>;;Minimum label value";
            range "16..1048575";
          }
        }
        leaf max {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<16-1048575>;;Maximum label value";
            range "16..1048575";
          }
        }
        leaf static {
          tailf:info "Specify block of labels for static bindings";
          tailf:cli-incomplete-command;
          type empty;
        }
        leaf static-min {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "NUM;;Upper minimum static label value";
          }
        }
        leaf static-max {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "NUM;;Maximum static label value";
          }
        }
      }
    }

    // mpls feature php mpls
    container feature {
      tailf:info "Control MPLS features";
      container php {
        tailf:info "Control php feature use";
        leaf mpls {
          tailf:info "use mpls features at php";
          type empty;
        }
      }
    }

    // mpls ldp
    container ldp {
      tailf:info "Label Distribution Protocol";
      tailf:cli-diff-dependency "../../ip/access-list";

      // no mpls ldp advertise-labels
      leaf advertise-labels {
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // mpls ldp nsr
      leaf nsr {
        tailf:info "Enable Non Stop Routing for LDP";
        tailf:cli-full-command;
        type empty;
      }

      // mpls ldp advertise-labels
      container advertise-labels-conf {
        tailf:cli-drop-node-name;
        container advertise-labels {
          tailf:info "Label advertisements";
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;

          // mpls ldp advertise-labels for *
          list for {
            tailf:info "Access-list specifying controls on destination prefixes";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            key from;
            leaf from {
              type string {
                tailf:info "WORD;;IP access-list for destination prefixes; name or number (1-99)";
              }
            }
            leaf to {
              tailf:info "Access-list specifying controls on LDP peers";
              type string {
                tailf:info "WORD;;IP access-list for LDP peers name or number (1-99)";
              }
            }
          }

          // mpls ldp advertise-labels interface
          container interface {
            tailf:info "Advertise /32 interface address";
            uses interface-name-grouping;
          }

          // mpls ldp advertise-labels oldstyle
          leaf oldstyle {
            tailf:info "Use old style (TDP) method for matching prefix acl";
            tailf:cli-full-command;
            type empty;
          }
        }
      }

      // mpls ldp password
      container password {
        tailf:info "Configure LDP MD5 password";

        // mpls ldp password required
        container required {
          tailf:info "MD5 password is required for the peer";
          tailf:cli-delete-when-empty;
          tailf:cli-reset-container;
          presence true;

          // mpls ldp password required for
          leaf for {
            tailf:info "IP access-list specifying control on LDP peers";
            type string {
              tailf:info "WORD;;IP standard access-list for LDP peers; name or number (1-99)";
            }
          }
        }

        // mpls ldp password fallback
        container fallback {
          tailf:info "Specifies a fallback password will follow";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          choice fallback-choice {
            // mpls ldp password fallback key-chain
            leaf key-chain {
              tailf:info "Specifies a key-chain name will follow";
              tailf:cli-full-command;
              tailf:non-strict-leafref {
                path "../../../../../key/chain/name";
              }
              type string {
                tailf:info "LINE;;name of key-chain";
              }
            }
            // mpls ldp password fallback [0|7] <secret>
            case password-case {
              uses password-grouping {
                refine "secret" {
                  cli:secret " password fallback <SECRET>";
                }
              }
            }
          }
        }

        // mpls ldp password option * for
        list option {
          tailf:info "LDP password options";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-incomplete-command;
          key id;
          leaf id {
            type uint16 {
              tailf:info "<1-32767>;;Sequence number of the LDP password option";
              range "1..32767";
            }
          }
          leaf for {
            tailf:info "IP access-list specifying control on LDP peers";
            tailf:cli-incomplete-command;
            type string {
              tailf:info "WORD;;IP standard access-list for LDP peers; name or number (1-99)";
            }
          }
          choice password-choice {
            leaf key-chain {
              tailf:info "Specifies a key-chain name will follow";
              tailf:cli-optional-in-sequence;
              tailf:non-strict-leafref {
                path "/ios:key/chain/name";
              }
              type string {
                tailf:info "WORD;;Key-chain name";
              }
            }
            case password {
              uses password-grouping {
                refine "secret" {
                  cli:secret " for \\S+ ((?:[0-9] )?\\S+)";
                }
              }
            }
          }
        }
      }

      // mpls ldp atm
      container atm {
        tailf:info "Configure ATM MPLS options";

        // mpls ldp atm control-mode
        leaf control-mode {
          tailf:info "Select LSP setup control mode for MPLS VCs";
          tailf:cli-full-command;
          type enumeration {
            enum independent {
              tailf:info "Independent Downstream on Demand Label VC setup";
            }
            enum ordered {
              tailf:info "Ordered Dowstream on Demand Label VC setup";
            }
          }
          //default "ordered";
        }

        // no mpls ldp atm vc-merge
        leaf vc-merge {
          tailf:info "Select VC merge capability";
          tailf:cli-full-command;
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }
      }

      // mpls ldp backoff
      container backoff {
        tailf:info "Set LDP session backoff parameters";
        tailf:cli-sequence-commands;
        tailf:cli-compact-syntax;
        leaf initial {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<5-2147483>;;Initial session backoff time (seconds)";
            range "5..2147483";
          }
        }
        leaf max {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<5-2147483>;;Maximum session backoff time (seconds)";
            range "5..2147483";
          }
        }
      }

      // mpls ldp discovery
      container discovery {
        tailf:info "LDP discovery";

        // mpls ldp discovery hello
        container hello {
          tailf:info "LDP discovery Hello";

          // mpls ldp discovery hello holdtime
          leaf holdtime {
            tailf:info "LDP discovery Hello holdtime";
            type uint16 {
              tailf:info "<1-65535>;;Holdtime in seconds. Default 15";
              range "1..65535";
            }
            default 15;
          }

          // mpls ldp discovery hello interval
          leaf interval {
            tailf:info "LDP discovery Hello interval";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<1-65535>;;Hello interval in seconds. Default 5";
              range "1..65535";
            }
            default 5;
          }
        }

        // mpls ldp discovery targeted-hello
        container targeted-hello {
          tailf:info "LDP discovery Targeted Hello";

          // mpls ldp discovery targeted-hello accept
          container accept {
            tailf:info "Accept targeted hellos";
            tailf:cli-delete-when-empty;
            presence true;
            leaf from {
              tailf:info "Access list to specify acceptable targeted hello sources";
              type string {
                tailf:info "WORD;;IP access-list for acceptable targeted hello sources";
              }
            }
          }

          // mpls ldp discovery targeted-hello holdtime
          leaf holdtime {
            tailf:info "LDP discovery Hello holdtime";
            type uint16 {
              tailf:info "<1-65535>;;Holdtime in seconds. Default 90";
              range "1..65535";
            }
            default 90;
          }

          // mpls ldp discovery targeted-hello interval
          leaf interval {
            tailf:info "LDP discovery Hello interval";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<1-65535>;;Hello interval in seconds. Default 10";
              range "1..65535";
            }
            default 10;
          }
        }

        // mpls ldp discovery quick-start
        leaf quick-start {
          tailf:info "Enable quick LDP Hello transmissions on inteface up";
          type empty;
        }
      }

      // mpls ldp explicit-null
      container explicit-null {
        tailf:info "Advertise Explicit Null label in place of Implicit Null";
        tailf:cli-delete-when-empty;
        presence true;
        leaf for {
          tailf:info "Access-list specifying controls on destination prefixes";
          type string {
            tailf:info "WORD;;IP access-list for destination prefixes; name or number (1-99)";
          }
        }
        leaf to {
          tailf:info "Access-list specifying controls on LDP peers";
          type string {
            tailf:info "WORD;;IP access-list for LDP peers; name or number (1-99)";
          }
        }
      }

      // mpls ldp loop-detection
      leaf loop-detection {
        tailf:info "Enable LDP Loop Detection";
        tailf:cli-full-command;
        type empty;
      }

      // mpls ldp graceful-restart timers
      container graceful-restart {
        tailf:info "Configure Graceful Restart timers";
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        container timers {
          tailf:info "Configure Graceful Restart timers";

          // mpls ldp graceful-restart timers forwarding-holding
          leaf forwarding-holding {
            tailf:info "Forwarding State Holding time";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<30-600>;;seconds. Default 600";
              range "30..600";
            }
            default 600;
          }

          // mpls ldp graceful-restart timers max-recovery
          leaf max-recovery {
            tailf:info "Max-Recovery time";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<15-600>;;seconds. Default 120";
              range "15..600";
            }
            default 120;
          }

          // mpls ldp graceful-restart timers neighbor-liveness
          leaf neighbor-liveness {
            tailf:info "Neighbor-Liveness time";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<5-300>;;seconds. Default 120";
              range "5..600";
            }
            default 120;
          }
        }
      }

      // mpls ldp graceful-restart
      container graceful-restart-enable {
        tailf:cli-drop-node-name;
        leaf graceful-restart {
          tailf:info "Configure Graceful Restart timers";
          tailf:cli-full-command;
          tailf:cli-full-no;
          type empty;
        }
      }

      // mpls ldp tcp pak-priority
      container tcp {
        tailf:info "Set TCP parameters for LDP";
        leaf pak-priority {
          tailf:info "Set (local) priority for LDP session TCP connection";
          type empty;
        }
      }

      // mpls ldp holdtime
      leaf holdtime {
        tailf:info "LDP session holdtime";
        tailf:cli-full-command;
        type uint32 {
          tailf:info "<15-2147483>;;Holdtime in seconds. Default 180";
          range "15..2147483";
        }
        default 180;
      }

      // no mpls ldp logging
      container logging {
        tailf:info "Enable LDP logging";
        leaf neighbor-changes {
          tailf:info "Log LDP neighbor state changes";
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }
      }

      // mpls ldp maxhops
      leaf maxhops {
        tailf:info "Limit hop count for LDP LSP setup";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<1-255>;;Maximum hop count value. Default 255";
          range "1..255";
        }
        default 255;
      }

      // mpls ldp neighbor *
      list neighbor {
        tailf:info "Configure neighbor parameters";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key address;
        leaf address {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP address for LDP neighbor";
          }
        }

        // mpls ldp neighbor * implicit-withdraw
        leaf implicit-withdraw {
          tailf:info "Enable LDP Implicit Withdraw Label";
          tailf:cli-full-command;
          type empty;
        }

        // mpls ldp neighbor * labels accept
        container labels {
          tailf:info "Configure label binding exchange controls";
          leaf accept {
            tailf:info "Specify label bindings to accept";
            type string {
              tailf:info "WORD;;IP access-list for LDP peers; name or number (1-99)";
            }
          }
        }

        // mpls ldp neighbor * password
        container password {
          tailf:info "Set a password";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          uses password-grouping {
            refine "secret" {
              cli:secret " password <SECRET>";
            }
          }
        }

        // mpls ldp neighbor * targeted
        container targeted {
          tailf:info "Establish targeted session";
          tailf:cli-delete-when-empty;
          presence "Establish targeted session";
          leaf protocol {
            tailf:cli-drop-node-name;
            type enumeration {
              // mpls ldp neighbor * targeted ldp
              enum ldp {
                tailf:info "User LDP";
              }
              // mpls ldp neighbor * targeted tdp
              enum tdp {
                tailf:info "Use TDP";
              }
            }
          }
        }
      }

      // mpls ldp request-labels for
      container request-labels {
        tailf:info "Access list to specify valid downstream on demand destinations.";
        leaf for {
          tailf:info "Access list to specify acceptable downstream on demand destinations";
          type string {
            tailf:info "WORD;;IP access-list for destination prefixes; name or number (1-99)";
          }
        }
      }

      // mpls ldp router-id
      container router-id {
        tailf:info "Select interface to prefer for LDP identifier address";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf interface {
          tailf:cli-drop-node-name;
          tailf:cli-diff-dependency "../../../../interface";
          type string {
            tailf:info "WORD;;intrace name";
          }
        }
        leaf force {
          tailf:info "Forcibly change the LDP router id";
          type empty;
        }
      }

      // mpls ldp session protection
      container session {
        tailf:info "Configure session parameters";
        container protection {
          tailf:info "Configure session protection parameters";
          tailf:cli-compact-syntax;
          presence true;
          // mpls ldp session protection duration
          leaf duration {
            tailf:info "Period to sustain session protection after loss of link discovery";
            type union {
              type enumeration {
                enum "infinite" {
                  tailf:info "Protect session forever after loss of link discovery";
                }
              }
              type uint32 {
                tailf:info "<30-2147483>;;Holdup time in seconds";
                range "30..2147483";
              }
            }
          }
          // mpls ldp session protection for
          leaf for {
            tailf:info "Access-list to specify LDP peers";
            tailf:cli-diff-dependency "/ios:ip/access-list";
            type string {
              tailf:info "WORD;;IP access-list for LDP peers; name or number (1-99)";
            }
          }
        }
      }

      // mpls ldp label
      container label {
        tailf:info "LDP label mode";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-ldp-lbl";
        container allocate {
          tailf:info "Allocate local labels for specified destination prefixes";
          container global {
            tailf:info "Specify global Routing/Forwarding instance";
            tailf:cli-delete-when-empty;
            presence true;
            choice global-choice {
              leaf host-routes {
                tailf:info "allocate local label for host routes only";
                type empty;
              }
              leaf prefix-list {
                tailf:info "Specify a prefix list for local label filtering";
                type string {
                  tailf:info "WORD;;IP prefix-list for destination prefixes; name or number (1-99)";
                }
              }
            }
          }
        }
      }

      // mpls ldp igp sync holddown
      container igp {
        tailf:info "Configure IGP-related LDP parameters";
        container sync {
          tailf:info "Configure LDP-IGP Synchronization parameters";
          leaf holddown {
            tailf:info "Configure the LDP-IGP Synchronization holddown time";
            type uint32 {
              tailf:info "<1-2147483647>;;Hold down time in milliseconds";
            }
          }
        }
      }
    }

    // no mpls mldp
    leaf mldp {
      tailf:info "Configure MLDP routing protocol parameters";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      tailf:cli-full-no;
      type boolean;
      default true;
    }

    // mpls mldp X
    container mldp-conf {
      tailf:cli-drop-node-name;
      container mldp {
        tailf:info "Configure MLDP routing protocol parameters";
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;

        // no mpls mldp forwarding recursive
        container forwarding {
          tailf:info "Multicast LDP forwarding commands";
          leaf recursive {
            tailf:info "Enable recursion on unicast LSPs";
            tailf:cli-boolean-no;
            type boolean;
            default true;
          }
        }

        // mpls mldp logging notifications
        container logging {
          tailf:info "Multicast LDP logging";
          leaf notifications {
            tailf:info "Log notifications";
            type empty;
          }
        }
      }
    }

    // mpls prefix-map
    container prefix-map {
      tailf:info "Configure MPLS CoS Tag-VC Multi-VC Prefix Map";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf nr {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint8 {
          tailf:info "<1-255>;;prefix-map number";
          range "1..255";
        }
      }
      leaf access-list {
        tailf:info "Configure access-list for this prefix-map";
        tailf:cli-incomplete-command;
        type uint8 {
          tailf:info "<1-255>;;access-list number";
          range "1..255";
        }
      }
      leaf cos-map {
        tailf:info "Configure cos-map for this prefix-map";
        type uint8 {
          tailf:info "<1-255>;;cos-map number";
          range "1..255";
        }
      }
    }

    // mpls traffic-eng
    container traffic-eng {
      tailf:info "Configure Traffic Engineering parameters";

      // mpls traffic-eng auto-bw timers
      container auto-bw {
        tailf:info "auto-bw parameters";
        choice timers-choice {
          // mpls traffic-eng auto-bw timers frequency
          container timers-conf {
            tailf:cli-drop-node-name;
            container timers {
              tailf:info "Enable auto-bw Timers Collection and Application";
              tailf:cli-incomplete-command;
              tailf:cli-incomplete-no;
              ios:delete-syntax "mpls traffic-eng auto-bw timers";
              leaf frequency {
                tailf:info "Interval between auto-bw data collection";
                type uint32 {
                  tailf:info "<1-604800>;;seconds between auto-bw. Default 300";
                  range "0..604800";
                }
                default 300;
              }
            }
          }
          // no mpls traffic-eng auto-bw timers
          leaf timers {
            tailf:info "Enable auto-bw Timers Collection and Application";
            tailf:cli-boolean-no;
            tailf:cli-full-command;
            tailf:cli-full-no;
            type boolean;
            default true;
          }
        }
      }

      // mpls traffic-eng link-management timers
      container link-management {
        tailf:info "Link Management configuration";
        container timers {
          tailf:info "Link Management timers configuration";

          // mpls traffic-eng link-management timers bandwidth-hold
          leaf bandwidth-hold {
            tailf:info "Link Management bandwidth hold timer";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<1-300>;;seconds. Default 15";
              range "1..300";
            }
            default 15;
          }

          // mpls traffic-eng link-management timers periodic-flooding
          leaf periodic-flooding {
            tailf:info "Link Management periodic flooding interval";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<0-3600>;;seconds. Default 60";
              range "0..3600";
            }
            default 60;
          }
        }
      }

      // mpls traffic-eng logging
      container logging {
        tailf:info "Trap logging configuration";

        // mpls traffic-eng logging lsp
        container lsp {
          tailf:info "LSP-specific traps logging configuration";

          // mpls traffic-eng logging lsp path-errors
          container path-errors {
            tailf:info "Log LSP Path Error traps";
            tailf:cli-delete-when-empty;
            tailf:cli-reset-container;
            presence true;
            leaf access-list {

              type exp-ip-acl-type;
            }
          }

          // mpls traffic-eng logging lsp preemption
          container preemption {
            tailf:info "Log LSP Preemption traps";
            tailf:cli-delete-when-empty;
            tailf:cli-reset-container;
            presence true;
            leaf access-list {
              tailf:cli-drop-node-name;
              type exp-ip-acl-type;
            }
          }

          // mpls traffic-eng logging lsp reservation-errors
          container reservation-errors {
            tailf:info "Log LSP Reservation Error traps";
            tailf:cli-delete-when-empty;
            tailf:cli-reset-container;
            presence true;
            leaf access-list {
              tailf:cli-drop-node-name;
              type exp-ip-acl-type;
            }
          }

          // mpls traffic-eng logging lsp setups
          container setups {
            tailf:info "Log LSP Establishment Traps";
            tailf:cli-delete-when-empty;
            tailf:cli-reset-container;
            presence true;
            leaf access-list {
              tailf:cli-drop-node-name;
              type exp-ip-acl-type;
            }
          }

          // mpls traffic-eng logging lsp teardowns
          container teardowns {
            tailf:info "Log LSP Teardown Traps";
            tailf:cli-delete-when-empty;
            tailf:cli-reset-container;
            presence true;
            leaf access-list {
              tailf:cli-drop-node-name;
              type exp-ip-acl-type;
            }
          }
        }

        // mpls traffic-eng logging tunnel
        container tunnel {
          tailf:info "Tunnel-specific traps logging configuration";

          // mpls traffic-eng logging tunnel lsp-switchover
          container lsp-switchover {
            tailf:info "Log Tunnel LSP Switchover traps";
            tailf:cli-delete-when-empty;
            tailf:cli-reset-container;
            presence true;
            leaf access-list {
              tailf:cli-drop-node-name;
              type exp-ip-acl-type;
            }
          }

          // mpls traffic-eng logging tunnel lsp-selection
          container lsp-selection {
            tailf:info "Log Tunnel LSP Selection traps";
            tailf:cli-delete-when-empty;
            tailf:cli-reset-container;
            presence true;
            leaf access-list {
              tailf:cli-drop-node-name;
              type exp-ip-acl-type;
            }
          }

          // mpls traffic-eng logging tunnel path change
          container path {
            tailf:info "Log Tunnel Path-related traps";
            container change {
              tailf:info "Log Tunnel Path change traps";
              tailf:cli-delete-when-empty;
              tailf:cli-reset-container;
              presence true;
              leaf access-list {
                tailf:cli-drop-node-name;
                type exp-ip-acl-type;
              }
            }
          }
        }
      }

      // mpls traffic-eng pcc
      container pcc {
        tailf:info "Path Computation Client for MPLS-TE";

        // mpls traffic-eng pcc peer *
        list peer {
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          key address;
          leaf address {
            type inet:host {
              tailf:info "Hostname or A.B.C.D/X:X:X:X::X;;address of PCE server";
            }
          }
          leaf source {
            tailf:info "Local address to use for PCEP TCP session";
            tailf:cli-optional-in-sequence;
            type inet:host {
              tailf:info "Hostname or A.B.C.D/X:X:X:X::X;;Source address";
            }
          }
          leaf precedence {
            tailf:info "PCE server precedence (default is 255)";
            tailf:cli-optional-in-sequence;
            type uint8 {
              tailf:info "<0-255>;;Lower precedence number makes the PCE more preferred";
            }
          }
          container password {
            tailf:info "Configure PCE MD5 password";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf type {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type enumeration {
                enum clear {
                  tailf:info "Cleartext password";
                }
                enum encrypted {
                  tailf:info "Hidden password";
                }
              }
            }
            leaf secret {
              tailf:cli-drop-node-name;
              tailf:cli-reset-container;
              tailf:cli-disallow-value "clear|encrypted";
              cli:secret " password <SECRET>";
              type NEDCOM_SECRET_TYPE {
                tailf:info "LINE;;<password text> | <keychain name>";
              }
            }
          }
        }

        // mpls traffic-eng pcc report-all
        leaf report-all {
          tailf:info "Force reporting of all MPLS-TE LSPs";
          type empty;
        }
      }

      // mpls traffic-eng auto-tunnel
      container auto-tunnel {
        tailf:info "Configure automatic TE tunnels";

        // mpls traffic-eng auto-tunnel backup
        leaf backup {
          tailf:info "Configure auto-tunnel backup tunnel";
          tailf:cli-full-command;
          type empty;
        }

        // mpls traffic-eng auto-tunnel backup X
        container backup-conf {
          tailf:cli-drop-node-name;
          container backup {
            tailf:info "Configure auto-tunnel backup tunnel";
            tailf:cli-incomplete-no;
            tailf:cli-incomplete-command;

            // mpls traffic-eng auto-tunnel backup config
            container config {
              tailf:info "Config commands to apply to all backup auto-tunnels";

              // mpls traffic-eng auto-tunnel backup config unnumbered-interface
              container unnumbered-interface {
                tailf:info "Configure the interface to use for unnumbered";
                uses interface-name-grouping;
              }

              // mpls traffic-eng auto-tunnel backup config affinity
              container affinity {
                tailf:info "desired link attributes for links comprising tunnel";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                leaf value {
                  tailf:cli-drop-node-name;
                  type string {
                    tailf:info "<0x0-0xFFFFFFFF>;;affinity value";
                  }
                }
                leaf mask {
                  tailf:info "mask on desired link attributes";
                  type string {
                    tailf:info "<0x0-0xFFFFFFFF>;;mask value";
                  }
                }
              }
            }

            // mpls traffic-eng auto-tunnel backup timers removal unused
            container timers {
              tailf:info "Configure timers for backup auto-tunnels";
              container removal {
                tailf:info "Configure timer for removal of backup tunnel";
                container unused {
                  tailf:info "Configure period to check for removing not in use tunnels";
                  tailf:cli-compact-syntax;
                  tailf:cli-sequence-commands {
                    tailf:cli-reset-siblings;
                  }
                  leaf sec-canning {
                    tailf:cli-drop-node-name;
                    type uint32 {
                      tailf:info "<0-604800>;;seconds between scanning to remove not in use tunnels";
                      range "0..604800";
                    }
                  }
                  leaf sec-unused {
                    tailf:cli-drop-node-name;
                    type uint32 {
                      tailf:info "<0-604800>;;How long (secs) auto backup is unused before removal, 0 = never remove";
                    }
                  }
                }
              }
            }

            // mpls traffic-eng auto-tunnel backup nhop-only
            leaf nhop-only {
              tailf:info "Automatically create n-hop backup tunnels only";
              type empty;
            }

            // mpls traffic-eng auto-tunnel backup tunnel-num
            container tunnel-num {
              tailf:info "Configure tunnel I/F numbers for backup auto-tunnels";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf min {
                tailf:info "Configure the starting id-range";
                type uint16 {
                  tailf:info "<0-65535>;;starting tunnel number range";
                }
              }
              leaf max {
                tailf:info "Configure the ending id-range";
                type uint16 {
                  tailf:info "<0-65535>;;ending tunnel number range";
                }
              }
            }

            // mpls traffic-eng auto-tunnel backup srlg exclude
            container srlg {
              tailf:info "Shared Risk Link Groups influence backup tunnel path selection";
              leaf exclude {
                tailf:info "Backup tunnels avoid SRLGs of protected interfaces";
                type enumeration {
                  enum force {
                              tailf:info "Backup tunnels MUST not use SRLGs of protected interfaces";
                  }
                  enum preferred {
                                  tailf:info "Backup tunnels try to avoid using SRLGs of protected interfaces";
                  }
                }
              }
            }
          }
        }

        // mpls traffic-eng auto-tunnel primary
        container primary {
          tailf:info "Automatically create one-hop primary tunnels";

          // mpls traffic-eng auto-tunnel primary config mpls ip
          container config {
            tailf:info "Config commands to apply to all primary auto-tunnels";
            container mpls {
              tailf:info "Configure dynamic MPLS forwarding";
              leaf ip {
                tailf:info "Configure dynamic MPLS forwarding for ip";
                type empty;
              }
            }
          }

          // mpls traffic-eng auto-tunnel primary tunnel-num
          container tunnel-num {
            tailf:info "Configure tunnel I/F numbers for primary auto-tunnels";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf min {
              tailf:info "Configure the starting id-range";
              type uint16 {
                tailf:info "<0-65535>;;starting tunnel number range";
              }
            }
            leaf max {
              tailf:info "Configure the ending id-range";
              type uint16 {
                tailf:info "<0-65535>;;ending tunnel number range";
              }
            }
          }
        }

        // mpls traffic-eng auto-tunnel p2p
        container p2p {
          tailf:info "Enable and configure TE service P2P auto tunnels";
          //tailf:cli-keep-when-empty;
          ios:trim-delete-when-empty "( auto-tunnel p2p)";
          presence true;

          // mpls traffic-eng auto-tunnel p2p config unnumbered-interface
          container config {
            tailf:info "Config commands to apply to all TE service P2P auto-tunnels";
            container unnumbered-interface {
              tailf:info "Configure the interface to use for unnumbered";
              uses interface-name-grouping;
            }
          }

          // mpls traffic-eng auto-tunnel p2p tunnel-num
          container tunnel-num {
            tailf:info "Configure tunnel I/F numbers for TE service P2P auto-tunnels";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf min {
              tailf:info "Configure the starting id-range";
              type uint16 {
                tailf:info "<0-65535>;;starting tunnel number range";
              }
            }
            leaf max {
              tailf:info "Configure the ending id-range";
              type uint16 {
                tailf:info "<1-65535>;;ending tunnel number range";
                range "1..65535";
              }
            }
          }
        }
      }

      // mpls traffic-eng path-selection
      container path-selection {
        tailf:info "Path Selection Configuration";

        // mpls traffic-eng path-selection metric
        leaf metric {
          tailf:info "Metric Type Configuration";
          tailf:cli-full-command;
          type enumeration {
            enum igp {
                      tailf:info "Use IGP metric";
            }
            enum te {
                     tailf:info "User TE metric";
            }
          }
          default te;
        }

        // mpls traffic-eng path-selection overload allow
        container overload {
          tailf:info "Overload Node Configuration";
          leaf allow {
            tailf:info "Allow overloaded nodes in CSPFs";
            type enumeration {
              enum head {
                         tailf:info "Allow overloaded head node in TE CSPF";
              }
              enum middle {
                           tailf:info "Allow overloaded middle node in TE CSPF";
              }
              enum tail {
                         tailf:info "Allow overloaded middle node in TE CSPF";
              }
            }
          }
        }
      }

      // mpls traffic-eng fault-oam
      leaf fault-oam {
        tailf:info "Node level fault OAM configuration";
        type empty;
      }

      // mpls traffic-eng fast-reroute
      container fast-reroute {
        tailf:info "fast-reroute parameters";

        // mpls traffic-eng fast-reroute timers promotion
        container timers {
          tailf:info "configure fast-reroute timer";
          leaf promotion {
            tailf:info "Configure how often we scan for LSP backup promotion";
            type uint32 {
              tailf:info "<0-604800>;;seconds between promotions (0 disables promotion.)";
              range "0..604800";
            }
          }
        }
      }

      // mpls traffic-eng reoptimize
      container reoptimize {
        tailf:info "Reoptimization parameters";

        // mpls traffic-eng reoptimize events
        container events {
          tailf:info "Reoptimization triggers";
          leaf link-up {
            tailf:info "Reoptimize tunnels on link up events";
            type empty;
          }
        }

        // mpls traffic-eng reoptimize timers
        container timers {
          tailf:info "Reoptimization timers";

          // mpls traffic-eng reoptimize timers delay
          container delay {
            tailf:info "Delay reoptimization action";

            // mpls traffic-eng reoptimize timers delay cleanup
            leaf cleanup {
              tailf:info "Delay cleanup of reoptimized LSP";
              tailf:cli-full-command;
              type uint16 {
                tailf:info "<0-300>;;seconds to delay cleanup of replaced tunnel LSP. Default 10";
                range "0..300";
              }
              default 10;
            }

            // mpls traffic-eng reoptimize timers delay installation
            leaf installation {
              tailf:info "Delay replacement of current LSP by reoptimized LSP";
              tailf:cli-full-command;
              type uint16 {
                tailf:info "<0-3600>;;seconds to delay replacement of tunnel LSP. Default 3";
                range "0..3600";
              }
              default 3;
            }
          }

          // mpls traffic-eng reoptimize timers frequency
          leaf frequency {
            tailf:info "Interval between reoptimization scans";
            tailf:cli-full-command;
            type uint32 {
              tailf:info "<0-604800>;;seconds between reoptimizations (0 disables reoptimization, default 3600)";
              range "0..604800";
            }
            default 3600;
          }
        }
      }

      // mpls traffic-eng signalling
      container signalling {
        tailf:info "Traffic Engineering Signalling Parameters";

        // mpls traffic-eng signalling advertise
        container advertise {
          tailf:info "Signalling advertisement parameters";

          // mpls traffic-eng signalling advertise explicit-null
          container explicit-null {
            tailf:info "Use MPLS encoding for Explicit-Null Label in signalling messages";
            presence true;
          }

          // mpls traffic-eng signalling advertise implicit-null
          container implicit-null {
            tailf:info "Use MPLS encoding for Implicit-Null Label in signalling messages";
            presence true;
            leaf nr {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<1-99>;;Number of IP access-list to determine applicable signalling peers";
                range "1..99";
              }
            }
          }
        }

        // mpls traffic-eng signalling forwarding
        container forwarding {
          tailf:info "Control interaction of LSP signalling and LFIB maintenance";
          leaf sync {
            tailf:info "Program linecard LFIBs before signalling LSP label upstream";
            type empty;
          }
        }

        // mpls traffic-eng signalling restart
        container restart {
          tailf:info "Signalling restart parameters";
          container neighbors {
            tailf:info "Identify signalling restart capable neighbors";
            tailf:cli-delete-when-empty;
            tailf:cli-reset-container;
            presence true;
            leaf nr {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<1-99>;;Number of IP access-list to determine applicable signalling peers";
                range "1..99";
              }
            }
          }
        }
      }

      // mpls traffic-eng topology
      container topology {
        tailf:info "Topology Database Configuration";
        container holddown {
          tailf:info "Topology Database hold down timers";
          leaf sigerr {
            tailf:info "Link hold down time for signalling errors";
            type uint16 {
              tailf:info "<0-300>;;Hold down time in seconds";
              range "0..300";
            }
          }
        }
      }

      // mpls traffic-eng tunnels
      leaf tunnels {
        tailf:info "Traffic Engineering tunnels";
        tailf:cli-full-command;
        type empty;
      }

      // mpls traffic-eng lsp attributes *
      container lsp {
        tailf:info "Configure LSP parameters";
        list attributes {
          tailf:info "Configure LSP attributes";
          tailf:cli-mode-name "config-lsp-attr";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Name of LSP attribute list";
            }
          }

          // mpls traffic-eng lsp attributes * / affinity
          container affinity {
            tailf:info "Specify attribute flags for links comprising LSP";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf attributes {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "<0x0-0xFFFFFFFF>;;affinity value";
              }
            }
            leaf mask {
              tailf:info "mask on desired link attributes";
              type string {
                tailf:info "<0x0-0xFFFFFFFF>;;affinity mask value";
              }
            }
          }

          // mpls traffic-eng lsp attributes * / priority
          container priority {
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf setup {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint8 {
                tailf:info "<0-7>;;setup priority";
                range "0..7";
              }
            }
            leaf hold {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<0-7>;;hold priority";
                range "0..7";
              }
            }
          }

          // mpls traffic-eng lsp attributes * / path-selection
          container path-selection {
            tailf:info "Path Selection Configuration";

            // mpls traffic-eng lsp attributes * / path-selection metric
            leaf metric {
              tailf:info "Metric type for path calculation";
              type enumeration {
                enum igp {
                  tailf:info "Use IGP Metric";
                }
                enum te {
                  tailf:info "Use TE Metric";
                }
              }
            }
          }

          // mpls traffic-eng lsp attributes * / record-route
          leaf record-route {
            tailf:info "Record the route used by the LSP";
            type empty;
          }

          // mpls traffic-eng lsp attributes * / pce
          container pce {
            tailf:info "Specify PCE Configuration";
            tailf:cli-delete-when-empty;
            tailf:cli-reset-container;
            presence true;

            // mpls traffic-eng lsp attributes * / pce disjoint-path
            container disjoint-path {
              tailf:info "Disjoint Path Configuration";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              leaf source {
                tailf:info "Source address";
                tailf:cli-incomplete-command;
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IPv4 address";
                }
              }
              leaf type {
                tailf:info "Disjointness type";
                tailf:cli-incomplete-command;
                type enumeration {
                  enum link {
                             tailf:info "Link Disjointness";
                  }
                  enum node {
                             tailf:info "Node Disjointness";
                  }
                  enum srlg {
                             tailf:info "SRLG Disjointness";
                  }
                }
              }
              leaf group-id {
                tailf:info "Group ID";
                type uint32 {
                  tailf:info "<1-4294967295>;;Enter group-id";
                  range "1..4294967295";
                }
              }
            }
          }

          // mpls traffic-eng lsp attributes * / lockdown
          container lockdown {
            tailf:info "Lockdown the LSP--disable reoptimization";
            tailf:cli-delete-when-empty;
            tailf:cli-reset-container;
            presence true;
            leaf sticky {
              tailf:info "stay on the same path after change in required resources";
              type empty;
            }
          }
        }
      }

      // mpls traffic-eng nsr
      leaf nsr {
        tailf:info "TE NSR configuration";
        type empty;
      }
    }

    // mpls propagate-cos
    leaf propagate-cos {
      type empty;
    }

    // mpls discovery vpn
    container discovery {
      tailf:info "Configure LSP discovery";
      container vpn {
        tailf:info "Configure Layer 3 VPN LSP discovery";

        // mpls discovery vpn interval
        leaf interval {
          tailf:info "Configure discovery refresh interval";
          type uint32 {
            tailf:info "<1-86400>;;Refresh interval in seconds";
            range "1..86400";
          }
        }

        leaf next-hop {
          tailf:info "Configure Layer 3 VPN LSP discovery";
          type empty;
        }
      }
    }

    // mpls static
    leaf static {
      tailf:info "MPLS static application";
      tailf:cli-full-command;
      tailf:cli-full-no;
      type empty;
    }

    // mpls static binding ipv4 *
    container static-binding {
      tailf:cli-drop-node-name;
      container static {
        tailf:info "MPLS static application";
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        tailf:cli-diff-dependency "../../label/range";
        container binding {
          tailf:info "Establish static label bindings";
          list ipv4 {
            tailf:info "Bind IPv4 destination with label";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            tailf:cli-remove-before-change;
            //vrf      VRF Routing/Forwarding instance information
            key "prefix mask";
            leaf prefix {
              tailf:cli-suppress-range;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Destination prefix";
              }
            }
            leaf mask {
              tailf:cli-suppress-range;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Destination prefix mask";
              }
            }
            leaf input {
              tailf:cli-drop-node-name;
              tailf:cli-full-command;
              type uint32 {
                tailf:info "<min-max>;;Input Label Value";
              }
            }
            list output {
              tailf:info "Outgoing (remote) label";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-incomplete-command;
              key nexthop;
              leaf nexthop {
                tailf:cli-suppress-range;
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Destination next hop";
                }
              }
              choice label-choice {
                leaf label {
                  tailf:cli-drop-node-name;
                  type uint32 {
                    tailf:info "<min-max>;;Output Label Value";
                  }
                }
                leaf explicit-null {
                  tailf:info "IETF MPLS IPv4 explicit null label (0)";
                  type empty;
                }
                leaf implicit-null {
                  tailf:info "IETF MPLS implicit null label (3)";
                  type empty;
                }
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// clns
  /// ========================================================================

  container clns {
    tailf:info "Global CLNS configuration subcommands";

    // clns routing
    leaf routing {
      tailf:info "Enable clns routing";
      type empty;
    }

    // clns filter-set *
    list filter-set {
      tailf:info "Define CLNS filter set";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-incomplete-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Name of filter set";
        }
      }
      // clns filter-set * permit|deny
      leaf operation {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type enumeration {
          enum deny {
            tailf:info "Deny matching addresses";
          }
          enum permit {
            tailf:info "Permit matching addresses";
          }
        }
      }
      leaf template {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "WORD;;Address template to filter";
        }
      }
    }
  }


  /// ========================================================================
  /// isis
  /// ========================================================================

  container isis {
    tailf:info "Global ISIS configuration subcommands";

    // no isis optimize inline
    // no isis optimize lspdb-walk
    container optimize {
      tailf:info "internal optimizations";
      leaf inline {
        tailf:info "match lspid/sysid";
        tailf:cli-boolean-no;
        type boolean;
        default true;
      }
      leaf lspdb-walk {
        tailf:info "lspdb access";
        tailf:cli-boolean-no;
        type boolean;
        default true;
      }
    }
  }


  /// ========================================================================
  /// call
  /// ========================================================================

  container call {
    tailf:info "Configure Call parameters";

    // call admission
    container admission {
      tailf:info "Configure Call Admission";

      // call admission new-model
      leaf new-model {
        tailf:info "Enable new-model based CAC";
        type empty;
      }

      // call admission limit
      leaf limit {
        tailf:info "Maximum total concurrent charge";
        type uint32 {
          tailf:info "<0-100000>;;Total charge";
          range "0..100000";
        }
      }

      // call admission cpu-limit
      leaf cpu-limit {
        tailf:info "Maximum CPU% at which CAC should become active";
        type uint8 {
          tailf:info "<0-100>;;CPU load at which CAC should reject (newmodel)";
          range "0..100";
        }
      }

      // call admission vpdn
      container vpdn {
        tailf:info "VPDN session charge profile";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf charge {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-1000>;;Per-session-charge";
            range "0..1000";
          }
        }
        leaf lifetime {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<1-31>;;Session Lifetime";
            range "1..31";
          }
        }
      }
    }

    // call rsvp-sync
    // no call rsvp-sync
    leaf rsvp-sync {
      tailf:info "Enable|Disable Sync Feature/Configure Reservation Timer";
      tailf:cli-boolean-no;
      type boolean;
    }
  }


  /// ========================================================================
  /// fax
  /// ========================================================================

  // fax interface-type fax-mail
  container fax {
    tailf:info "Configure fax parameters";
    container interface-type {
      tailf:info "Interface to be used to handle the call";
      leaf fax-mail {
        tailf:info "Enable fax mail feature";
        type empty;
      }
    }
  }

  /// ========================================================================
  /// mta
  /// ========================================================================

  container mta {
    tailf:info "Configure the Mail Transfer Agent";

    // mta receive maximum-recipients
    container receive {
      tailf:info "Configure the receiving Mail Transfer Agent";
      leaf maximum-recipients {
        tailf:info "Maximum recipients for all SMTP connections";
        type uint16 {
          tailf:info "<0-1024>;;Maximum recipients";
          range "0..1024";
        }
      }
    }
  }


  /// ========================================================================
  /// location
  /// ========================================================================

  container location {
    tailf:info "Global location configuration commands";

    // location admin-tag
    leaf admin-tag {
      tailf:info "Administrative Tag or Site information";
      type string {
        tailf:info "WORD;;admin-tag string";
      }
    }

    // location expiry
    container expiry {
      tailf:info "Configure the timeout for RSSI values";

      // location expiry calibrating-client
      leaf calibrating-client {
        tailf:info "Timeout for calibrating clients";
        type uint16 {
          tailf:info "<1-3600>;;Enter value within 3600 seconds";
          range "1..3600";
        }
        default 5;
      }

      // location expiry client
      leaf client {
        tailf:info "Timeout for clients";
        type uint16 {
          tailf:info "<5-3600>;;Enter value between 5 and 3600 seconds";
          range "5..3600";
        }
        default 15;
      }

      // location expiry tags
      leaf tags {
        tailf:info "Timeout for rfid tags";
        type uint16 {
          tailf:info "<5-300>;;Enter value between 5 and 300 seconds";
          range "5..300";
        }
        default 5;
      }
    }
  }


  /// ========================================================================
  /// l3-over-l2
  /// ========================================================================

  container l3-over-l2 {
    tailf:info "L3 over L2 specific configuration";
    container flush {
      tailf:info "configure whether L3 buffers should be flushed";
      leaf buffers {
        tailf:info "Enable flushing of L3 buffers for L3-over-L2 support";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// l3vpn
  /// ========================================================================

  container l3vpn {
    tailf:info "l3vpn encapsulation ip commands";
    container encapsulation {
      tailf:info "l3vpn encapsulation ip";

      // l3vpn encapsulation ip *
      list ip {
        tailf:info "l3vpn encapsulation ip";
        tailf:cli-mode-name "config-l3vpn-encap-ip";
        tailf:cli-full-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;profile name";
          }
        }

        // l3vpn encapsulation ip * / transport ipv4
        container transport {
          tailf:info "transport mode";
          container ipv4 {
            tailf:info "transport ipv4 mode";
            presence true;
            // l3vpn encapsulation ip * / transport ipv4 source
            container source {
              tailf:info "transport source";
              uses interface-name-grouping;
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// router
  /// ========================================================================

  container router {
    tailf:info "Enable a routing process";

    // router mobile
    container mobile {
      tailf:info "Mobile routes";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-router";
      tailf:cli-diff-dependency "../../ip/routing" {
        tailf:cli-trigger-on-set;
      }
      presence true;
    }

    /// router bgp
    // router bgp *
    list bgp {
      tailf:info "Border Gateway Protocol (BGP)";
      tailf:cli-mode-name "config-router";
      tailf:cli-diff-dependency "../../ip/routing" {
        tailf:cli-trigger-on-set;
      }
      tailf:cli-diff-dependency "../../ipv6/unicast-routing";
      tailf:cli-diff-dependency "../../route-map";
      //NSO BUG [ENG 17823]: tailf:cli-diff-dependency "../../ip/prefix-list";
      tailf:cli-diff-delete-before "../../ip/prefix-list";
      //ios:bgp-nbr-redeploy;
      max-elements 1;
      key as-no;
      leaf as-no {
        tailf:cli-suppress-range;
        tailf:cli-diff-dependency "/ios:router/bgp" {
          tailf:cli-trigger-on-set;
        }
        type bgp-as-no-type;
      }

      // router bgp * / template
      container template {
        tailf:info "Enter template command mode";

        // router bgp * / template peer-policy *
        list peer-policy {
          tailf:info "Template configuration for policy parameters";
          tailf:cli-mode-name "config-router-ptmp";
          tailf:cli-exit-command "exit-peer-policy" {
            tailf:info "Exit from template configuration mode";
          }
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Name of peer-policy template";
            }
          }

          // router bgp * / template peer-policy * / inherit peer-policy
          container inherit {
            tailf:info "Inherit a template";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf peer-policy {
              tailf:info "Inherit a peer-policy template";
              tailf:cli-incomplete-command;
              tailf:non-strict-leafref {
                path "../../../peer-policy/name";
              }
              type string {
                tailf:info "WORD;;Template name";
              }
            }
            leaf sequence {
              tailf:cli-drop-node-name;
              tailf:cli-full-command;
              type uint16 {
                tailf:info "<1-65535>;;Sequence number";
                range "1..65535";
              }
            }
          }
          uses router-bgp-peer-policy-grouping;
        }

        // router bgp * / template peer-session *
        list peer-session {
          tailf:info "Template configuration for session parameters";
          tailf:cli-mode-name "config-router-stmp";
          tailf:cli-exit-command "exit-peer-session" {
            tailf:info "Exit from template configuration mode";
          }
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Name of peer-session template";
            }
          }

          // router bgp * / template peer-session * / remote-as
          leaf remote-as {
            tailf:info "Specify a BGP neighbor";
            tailf:cli-full-command;
            tailf:cli-diff-delete-after "../../peer-session/inherit/peer-session";
            type string {
              tailf:info "AS of remote neighbor";
            }
          }

          // router bgp * / template peer-session * / description
          uses description-grouping;

          // router bgp * / template peer-session * / inherit peer-session
          container inherit {
            tailf:info "Inherit a template";
            leaf peer-session {
              tailf:info "Inherit a peer-session template";
              tailf:non-strict-leafref {
                path "../../../peer-session/name";
              }
              type string {
                tailf:info "WORD;;Template name";
              }
            }
          }
          uses router-bgp-peer-session-grouping;
        }
      }

      // router bgp * / bgp
      uses router-bgp-bgp-grouping;

      // router bgp * /
      uses router-bgp-af-grouping {
        refine "neighbor/password/text" {
          cli:secret " password <SECRET>";
        }
        refine "neighbor/peer-group" {
          ios:bgp-nbr-redeploy-trigger;
        }
        refine "neighbor/remote-as" {
          ios:bgp-nbr-redeploy-trigger;
        }
      }

      // router bgp * / address-family
      container address-family {
        tailf:info "Enter Address Family command mode";
        tailf:cli-diff-dependency "../neighbor";
        tailf:cli-diff-dependency "../neighbor-tag/neighbor";

        // router bgp * / address-family ipv4 *
        list ipv4 {
          tailf:info "Address family";
          tailf:cli-mode-name "config-router-af";
          tailf:cli-delete-when-empty;
          tailf:cli-full-command;
          tailf:cli-exit-command "exit-address-family" {
            tailf:info "Exit from Address Family configuration mode";
          }
          key af;
          leaf af {
            tailf:key-default "unicast";
            type enumeration {
              enum unicast {
                tailf:info "Address Family modifier";
              }
              enum multicast {
                tailf:info "Address Family modifier";
              }
              enum mdt {
                tailf:info "IPv4 multicast distribution tree (MDT)";
              }
              enum tunnel {
                tailf:info "IPv4 tunnel address prefixes.";
              }
              enum labeled-unicast {
                tailf:info "IPv4 labeled-unicast address prefixes";
              }
              enum flowspec {
                tailf:info "Address Family modifier";
              }
              enum mvpn {
                tailf:info "Address Family modifier";
              }
            }
          }
          uses router-bgp-af-grouping {
            refine "neighbor" {
              tailf:cli-diff-dependency "../../../neighbor";
            }
          }
          uses router-bgp-af2-grouping;
        }

        // router bgp * / address-family ipv6 *
        list ipv6 {
          tailf:info "Address family";
          tailf:cli-mode-name "config-router-af";
          tailf:cli-delete-when-empty;
          tailf:cli-full-command;
          tailf:cli-exit-command "exit-address-family" {
            tailf:info "Exit from Address Family configuration mode";
          }
          key af;
          leaf af {
            tailf:key-default "unicast";
            type enumeration {
              enum unicast {
                tailf:info "Address Family modifier";
              }
              enum multicast {
                tailf:info "Address Family modifier";
              }
              enum flowspec {
                tailf:info "Address Family modifier";
              }
              enum mvpn {
                tailf:info "Address Family modifier";
              }
            }
          }
          uses router-bgp-af-grouping {
            refine "neighbor" {
              tailf:cli-diff-dependency "../../../neighbor";
            }
          }
          uses router-bgp-af2-grouping;
        }

        // router bgp * / address-family ipv4 vrf *
        container with-vrf {
          tailf:cli-drop-node-name;
          list ipv4 {
            tailf:info "Address family";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            tailf:cli-incomplete-no;
            key af;
            leaf af {
              tailf:key-default "unicast";
              type enumeration {
                enum unicast {
                  tailf:info "Address Family modifier";
                }
                enum multicast {
                  tailf:info "Address Family modifier";
                }
                enum mdt {
                  tailf:info "IPv4 multicast distribution tree (MDT)";
                }
                enum tunnel {
                  tailf:info "IPv4 tunnel address prefixes.";
                }
                enum labeled-unicast {
                  tailf:info "IPv4 labeled-unicast address prefixes";
                }
                enum flowspec {
                  tailf:info "Address Family modifier";
                }
              }
            }
            // router bgp * / address-family ipv4 vrf *
            list vrf {
              tailf:cli-mode-name "config-router-af";
              tailf:cli-delete-when-empty;
              tailf:cli-full-command;
              tailf:cli-exit-command "exit-address-family" {
                tailf:info "Exit from Address Family configuration mode";
              }
              key name;
              leaf name {
                tailf:cli-diff-dependency "../../../../../../../ip/vrf";
                tailf:cli-diff-dependency "../../../../../../../vrf/definition";
                type string {
                  tailf:info "WORD;;VPN Routing/Forwarding instance name";
                }
              }
              uses router-bgp-bgp-grouping;
              uses router-bgp-af-grouping {
                refine "neighbor" {
                  tailf:cli-diff-dependency "../../../../../../../ip/vrf/rd";
                }
              }
            }
          }
        }

        // router bgp * / address-family ipv6 * vrf *
        container ipv6-with-vrf {
          tailf:cli-drop-node-name;
          list ipv6 {
            tailf:info "Address family";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            tailf:cli-incomplete-no;
            key af;
            leaf af {
              type enumeration {
                enum unicast {
                  tailf:info "Address Family modifier";
                }
                enum multicast {
                  tailf:info "Address Family modifier";
                }
                enum flowspec {
                  tailf:info "Address Family modifier";
                }
              }
              tailf:key-default "unicast";
            }
            // router bgp * / address-family ipv6 * vrf *
            list vrf {
              tailf:cli-mode-name "config-router-af";
              tailf:cli-delete-when-empty;
              tailf:cli-full-command;
              tailf:cli-exit-command "exit-address-family" {
                tailf:info "Exit from Address Family configuration mode";
              }
              key name;
              leaf name {
                tailf:cli-diff-dependency "../../../../../../../vrf/definition";
                tailf:cli-diff-dependency "../../../../../../../vrf/definition/address-family/ipv6";
                tailf:cli-diff-dependency "../../../../../../../ip/vrf";
                type string {
                  tailf:info "WORD;;VPN Routing/Forwarding instance name";
                }
              }
              uses router-bgp-bgp-grouping;
              uses router-bgp-af-grouping {
                refine "neighbor" {
                  tailf:cli-diff-dependency "../../../../../neighbor";
                }
              }
            }
          }
        }

        // router bgp * / address-family vpnv4 *
        list vpnv4 {
          tailf:info "Address family";
          tailf:cli-mode-name "config-router-af";
          tailf:cli-delete-when-empty;
          tailf:cli-exit-command "exit-address-family" {
            tailf:info "Exit from Address Family configuration mode";
          }
          key af;
          leaf af {
            tailf:key-default "unicast";
            type enumeration {
              enum unicast {
                tailf:info "Address Family modifier";
              }
              enum multicast {
                tailf:info "Address Family modifier";
              }
              enum flowspec {
                tailf:info "Address Family modifier";
              }
            }
          }
          uses router-bgp-af-grouping {
            refine "neighbor" {
              tailf:cli-diff-dependency "../../../neighbor";
            }
          }
        }

        // router bgp * / address-family vpnv6 *
        list vpnv6 {
          tailf:info "Address family";
          tailf:cli-mode-name "config-router-af";
          tailf:cli-delete-when-empty;
          tailf:cli-exit-command "exit-address-family" {
            tailf:info "Exit from Address Family configuration mode";
          }
          key af;
          leaf af {
            tailf:key-default "unicast";
            type enumeration {
              enum unicast {
                tailf:info "Address Family modifier";
              }
              enum multicast {
                tailf:info "Address Family modifier";
              }
              enum flowspec {
                tailf:info "Address Family modifier";
              }
            }
          }
          uses router-bgp-af-grouping {
            refine "neighbor" {
              tailf:cli-diff-dependency "../../../neighbor";
            }
          }
        }

        // router bgp * / address-family l2vpn *
        list l2vpn {
          tailf:info "Address family";
          tailf:cli-mode-name "config-router-af";
          tailf:cli-delete-when-empty;
          tailf:cli-exit-command "exit-address-family" {
            tailf:info "Exit from Address Family configuration mode";
          }
          key af;
          leaf af {
            tailf:key-default "vpls";
            type enumeration {
              enum evpn {
                tailf:info "Address Family modifier";
              }
              enum vpls {
                tailf:info "Address Family modifier";
              }
            }
          }
          uses router-bgp-af-grouping {
            refine "neighbor" {
              tailf:cli-diff-dependency "../../../neighbor";
            }
          }
        }

        // router bgp * / address-family nsap *
        list nsap {
          tailf:info "Address family";
          tailf:cli-mode-name "config-router-af";
          tailf:cli-delete-when-empty;
          tailf:cli-exit-command "exit-address-family" {
            tailf:info "Exit from Address Family configuration mode";
          }
          key af;
          leaf af {
            tailf:key-default "unicast";
            type enumeration {
              enum unicast {
                tailf:info "Address Family modifier";
              }
            }
          }
          uses router-bgp-af-grouping {
            refine "neighbor" {
              tailf:cli-diff-dependency "../../../neighbor";
            }
          }
        }

        // router bgp * / address-family rtfilter *
        list rtfilter {
          tailf:info "Address family";
          tailf:cli-mode-name "config-router-af";
          tailf:cli-delete-when-empty;
          tailf:cli-exit-command "exit-address-family" {
            tailf:info "Exit from Address Family configuration mode";
          }
          key af;
          leaf af {
            tailf:key-default "unicast";
            type enumeration {
              enum unicast {
                tailf:info "Address Family modifier";
              }
            }
          }
          uses router-bgp-af-grouping {
            refine "neighbor" {
              tailf:cli-diff-dependency "../../../neighbor";
            }
          }
        }

        // router bgp * / address-family link-state link-state
        container link-state {
          tailf:info "Address family";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-router-af";
          presence true;
          tailf:cli-exit-command "exit-address-family" {
            tailf:info "Exit from Address Family configuration mode";
          }
          leaf af {
            tailf:cli-drop-node-name;
            tailf:cli-hide-in-submode;
            type enumeration {
              enum link-state {
                tailf:info "Address Family Modifier";
              }
            }
          }
          uses router-bgp-af-grouping {
            refine "neighbor" {
              tailf:cli-diff-dependency "../../../neighbor";
            }
          }
        }
      }
    }

    /// router eigrp
    // router eigrp *
    container eigrp-virtual-instance {
      tailf:cli-drop-node-name;
      list eigrp {
        tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
        tailf:cli-mode-name "config-router";
        tailf:cli-diff-dependency "../../../ip/routing" {
          tailf:cli-trigger-on-set;
        }
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;EIGRP Virtual-Instance Name";
            pattern "[A-Za-z]+.*";
          }
        }

        // router eigrp * / address-family
        container address-family {
          tailf:info "Enter Address Family command mode";

          // router eigrp * / address-family ipv4 unicast vrf *
          container ipv4-vrf {
            tailf:cli-drop-node-name;
            container ipv4 {
              tailf:info "Address family IPv4";
              container unicast {
                tailf:info "Address Family Unicast";
                list vrf {
                  tailf:info "Specify a specific virtual routing/forwarding instance";
                  tailf:cli-mode-name "config-router-af";
                  tailf:cli-sequence-commands;
                  tailf:cli-incomplete-command;
                  tailf:cli-exit-command "exit-address-family" {
                    tailf:info "Exit Address Family configuration mode";
                  }
                  key name;
                  leaf name {
                    tailf:cli-diff-dependency "../../../../../../../../../ip/vrf";
                    tailf:cli-diff-dependency "../../../../../../../../../vrf/definition";
                    type string {
                      tailf:info "WORD;;Virtual Routing/Forwarding instance name";
                    }
                  }
                  leaf autonomous-system {
                    tailf:info "Specify Address-Family Autonomous System Number";
                    tailf:cli-hide-in-submode;
                    tailf:cli-full-command;
                    type uint16 {
                      tailf:info "<1-65535>;;Autonomous System";
                      range "1..65535";
                    }
                  }
                  uses router-eigrp-af-virtual-instance-grouping;
                }
              }
            }
          }

          // router eigrp * / address-family ipv4
          container ipv4 {
            tailf:info "Address family IPv4";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-router-af";
            tailf:cli-sequence-commands;
            tailf:cli-incomplete-command;
            tailf:cli-exit-command "exit-address-family" {
              tailf:info "Exit Address Family configuration mode";
            }
            presence true;
            leaf af {
              tailf:cli-drop-node-name;
              tailf:cli-hide-in-submode;
              tailf:cli-incomplete-command;
              type enumeration {
                enum unicast {
                  tailf:info "Address Family Unicast";
                }
                enum multicast {
                  tailf:info "Address Family Multicast";
                }
              }
            }
            leaf autonomous-system {
              tailf:info "Specify Address-Family Autonomous System Number";
              tailf:cli-hide-in-submode;
              tailf:cli-remove-before-change;
              tailf:cli-full-command;
              type uint16 {
                tailf:info "<1-65535>;;Autonomous System";
                range "1..65535";
              }
            }
            uses router-eigrp-af-virtual-instance-grouping;
          }

          // router eigrp * / address-family ipv6 unicast vrf *
          container ipv6-vrf {
            tailf:cli-drop-node-name;
            container ipv6 {
              tailf:info "Address family IPv6";
              container unicast {
                tailf:info "Address Family Unicast";
                list vrf {
                  tailf:info "Specify a specific virtual routing/forwarding instance";
                  tailf:cli-mode-name "config-router-af";
                  tailf:cli-sequence-commands;
                  tailf:cli-incomplete-command;
                  tailf:cli-exit-command "exit-address-family" {
                    tailf:info "Exit Address Family configuration mode";
                  }
                  tailf:cli-diff-dependency "/ios:ipv6/unicast-routing";
                  key name;
                  leaf name {
                    tailf:cli-diff-dependency "../../../../../../../../../ip/vrf";
                    tailf:cli-diff-dependency "../../../../../../../../../vrf/definition";
                    type string {
                      tailf:info "WORD;;Virtual Routing/Forwarding instance name";
                    }
                  }
                  leaf autonomous-system {
                    tailf:info "Specify Address-Family Autonomous System Number";
                    tailf:cli-hide-in-submode;
                    tailf:cli-full-command;
                    type uint16 {
                      tailf:info "<1-65535>;;Autonomous System";
                      range "1..65535";
                    }
                  }
                  uses router-eigrp-af-virtual-instance-grouping;
                }
              }
            }
          }

          // router eigrp * / address-family ipv6
          container ipv6 {
            tailf:info "Address family IPv6";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-router-af";
            tailf:cli-sequence-commands;
            tailf:cli-incomplete-command;
            tailf:cli-exit-command "exit-address-family" {
              tailf:info "Exit Address Family configuration mode";
            }
            tailf:cli-diff-dependency "/ios:ipv6/unicast-routing";
            presence true;
            leaf af {
              tailf:cli-drop-node-name;
              tailf:cli-hide-in-submode;
              tailf:cli-incomplete-command;
              type enumeration {
                enum unicast {
                  tailf:info "Address Family Unicast";
                }
                enum multicast {
                  tailf:info "Address Family Multicast";
                }
              }
            }
            leaf autonomous-system {
              tailf:info "Specify Address-Family Autonomous System Number";
              tailf:cli-hide-in-submode;
              tailf:cli-full-command;
              type uint16 {
                tailf:info "<1-65535>;;Autonomous System";
                range "1..65535";
              }
            }
            uses router-eigrp-af-virtual-instance-grouping;
          }
        }
      }
    }

    // router eigrp *
    list eigrp {
      tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
      tailf:cli-mode-name "config-router";
      tailf:cli-diff-dependency "../../ip/routing" {
        tailf:cli-trigger-on-set;
      }
      key as-no;
      leaf as-no {
        type uint16 {
          tailf:info "<1-65535>;;Autonomous system number";
          range "1..65535";
        }
      }

      // router eigrp * / address-family ipv4 vrf *
      container address-family {
        tailf:info "Enter Address Family command mode";
        container ipv4 {
          tailf:info "Address Family IPv4";
          list vrf {
            tailf:info "Specify a specific virtual routing/forwarding instance";
            tailf:cli-mode-name "config-router-af";
            tailf:cli-exit-command "exit-address-family" {
              tailf:info "Exit Address Family configuration mode";
            }
            key name;
            leaf name {
              tailf:cli-diff-dependency "../../../../../../vrf/definition";
              tailf:cli-diff-dependency "../../../../../../ip/vrf";
              type string {
                tailf:info "WORD;;Virtual Routing/Forwarding instance name";
              }
            }
            leaf autonomous-system {
              tailf:info "Specify Address-Family Autonomous System Number";
              type uint16 {
                tailf:info "<1-65535>;;Autonomous System";
                range "1..65535";
              }
            }

            // router eigrp * / address-family ipv4 vrf * / network *
            // router eigrp * / address-family ipv4 vrf * / eigrp
            uses router-eigrp-grouping;

            // router eigrp * / address-family ipv4 vrf * / redistribute
            // router eigrp * / address-family ipv4 vrf * / auto-summary
            uses router-eigrp-base-grouping;
          }
        }
      }

      // router eigrp * / network *
      // router eigrp * / eigrp
      uses router-eigrp-grouping;

      // router eigrp * / redistribute
      // router eigrp * / auto-summary
      uses router-eigrp-base-grouping;
    }

    /// router ospfv3
    // router ospfv3 *
    list ospfv3 {
      tailf:info "OSPFv3";
      tailf:cli-mode-name "config-router";
      tailf:cli-diff-dependency "../../ipv6/unicast-routing";
      tailf:cli-diff-dependency "../../ip/routing" {
        tailf:cli-trigger-on-set;
      }
      key id;
      leaf id {
        tailf:cli-suppress-range;
        type uint16 {
          tailf:info "<1-65535>;;Process ID";
          range "1..65535";
        }
      }

      uses router-ospfv3-grouping;
      uses router-ospf-common-grouping;

      // router ospfv3 * / shutdown
      leaf shutdown {
        tailf:info "Shutdown the router process";
        type empty;
      }

      // router ospfv3 * / address-family
      container address-family {
        tailf:info "Enter Address Family command mode";

        // router ospfv3 * / address-family ipv4 unicast
        container ipv4 {
          tailf:info "Address family";
          container unicast {
            tailf:info "Address Family Modifier";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-router-af";
            tailf:cli-full-command;
            tailf:cli-exit-command "exit-address-family" {
              tailf:info "Exit from Address Family configuration mode";
            }
            uses router-ospfv3-grouping;
            uses router-ospf-common-grouping;
            uses router-ospf-common-af-grouping;
            uses router-ospfv3-af-grouping;
          }
        }

        // router ospfv3 * / address-family ipv6
        container ipv6 {
          tailf:info "Address family";
          container unicast {
            tailf:info "Address Family Modifier";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-router-af";
            tailf:cli-full-command;
            tailf:cli-exit-command "exit-address-family" {
              tailf:info "Exit from Address Family configuration mode";
            }
            uses router-ospfv3-grouping;
            uses router-ospf-common-grouping;
            uses router-ospf-common-af-grouping;
            uses router-ospfv3-af-grouping;
          }
        }

        // router ospfv3 * / address-family ipv4 unicast vrf *
        container ipv4-vrf {
          tailf:cli-drop-node-name;
          container ipv4 {
            tailf:info "Address family";
            container unicast {
              tailf:info "Address Family Modifier";
              list vrf {
                tailf:info "Specify parameters for a VPN Routing/Forwarding instance";
                tailf:cli-mode-name "config-router-af";
                tailf:cli-full-command;
                tailf:cli-exit-command "exit-address-family" {
                  tailf:info "Exit from Address Family configuration mode";
                }
                key name;
                leaf name {
                  tailf:cli-diff-dependency "../../../../../../../../ip/vrf";
                  tailf:cli-diff-dependency "../../../../../../../../vrf/definition";
                  type string {
                    tailf:info "WORD;;VPN Routing/Forwarding instance name";
                  }
                }
                uses router-ospfv3-grouping;
                uses router-ospf-common-grouping;
                uses router-ospf-common-af-grouping;
                uses router-ospfv3-af-grouping;
              }
            }
          }
        }

        // router ospfv3 * / address-family ipv6 unicast vrf *
        container ipv6-vrf {
          tailf:cli-drop-node-name;
          container ipv6 {
            tailf:info "Address family";
            container unicast {
              tailf:info "Address Family Modifier";
              list vrf {
                tailf:info "Specify parameters for a VPN Routing/Forwarding instance";
                tailf:cli-mode-name "config-router-af";
                tailf:cli-full-command;
                tailf:cli-exit-command "exit-address-family" {
                  tailf:info "Exit from Address Family configuration mode";
                }
                key name;
                leaf name {
                  tailf:cli-diff-dependency "../../../../../../../../ip/vrf";
                  tailf:cli-diff-dependency "../../../../../../../../vrf/definition";
                  type string {
                    tailf:info "WORD;;VPN Routing/Forwarding instance name";
                  }
                }
                uses router-ospfv3-grouping;
                uses router-ospf-common-grouping;
                uses router-ospf-common-af-grouping;
                uses router-ospfv3-af-grouping;
              }
            }
          }
        }
      }
    }

    /// router ospf
    // router ospf *
    list ospf {
      tailf:info "Open Shortest Path First (OSPF)";
      tailf:cli-mode-name "config-router";
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-explicit-exit;
      tailf:cli-diff-dependency "../../ip/routing" {
        tailf:cli-trigger-on-set;
      }
      key id;
      leaf id {
        tailf:cli-suppress-range;
        type uint16 {
          tailf:info "<1-65535>;;Process ID";
          range "1..65535";
        }
      }
      leaf vrf {
        tailf:info "VPN Routing/Forwarding Instance";
        tailf:cli-hide-in-submode;
        tailf:cli-delete-container-on-delete;
        tailf:cli-remove-before-change;
        tailf:cli-full-command;
        tailf:cli-diff-dependency "../../../ip/vrf";
        tailf:cli-diff-dependency "../../../vrf/definition";
        ios:list-redeploy "/../ :: 0";
        type string {
          tailf:info "WORD;;VPN Routing/Forwarding Instance (VRF) name";
        }
      }
      uses router-ospf-common-grouping {
        refine "area" {
          tailf:cli-break-sequence-commands;
        }
      }
      uses router-ospf-common-af-grouping;
      uses router-ospf-grouping;
    }

    /// router isis
    // router isis
    container isis {
      tailf:info "ISO IS-IS";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-router";
      tailf:cli-full-command;
      tailf:cli-diff-dependency "../../ip/routing";
      presence true;
      uses router-isis-grouping;
    }

    // router isis *
    container isis-container {
      tailf:cli-drop-node-name;
      list isis {
        tailf:info "ISO IS-IS";
        tailf:cli-mode-name "config-router";
        tailf:cli-diff-dependency "../../../ip/routing";
        key area-tag;
        leaf area-tag {
          type string {
            tailf:info "WORD;;ISO routing area tag";
          }
        }
        uses router-isis-grouping;
      }
    }

    /// router rip
    // router rip
    container rip {
      tailf:info "Routing Information Protocol (RIP)";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-router";
      tailf:cli-full-command;

      uses router-rip-grouping {
        refine "version" {
          tailf:cli-diff-dependency "../../../ip/routing" {
            tailf:cli-trigger-on-set;
          }
        }
      }

      // router rip / address-family
      container address-family {
        tailf:info "Enter Address Family command mode";
        container ipv4 {
          tailf:info "Address family";

          // router rip / address-family ipv4 unicast
          container unicast {
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-router-af";
            tailf:info "Address Family Modifier";
            tailf:cli-full-command;
            tailf:cli-exit-command "exit-address-family" {
              tailf:info "Exit from Address Family configuration mode";
            }
            tailf:cli-diff-dependency "../../../../../ip/routing" {
              tailf:cli-trigger-on-set;
            }
            uses router-rip-grouping;
          }

          // router rip / address-family ipv4 vrf *
          list vrf {
            tailf:info "Specify parameters for a VPN Routing/Forwarding instance";
            tailf:cli-mode-name "config-router-af";
            tailf:cli-full-command;
            tailf:cli-exit-command "exit-address-family" {
              tailf:info "Exit from Address Family configuration mode";
            }
            tailf:cli-diff-dependency "../../../../../ip/routing" {
              tailf:cli-trigger-on-set;
            }
            key name;
            leaf name {
              tailf:cli-diff-dependency "../../../../../../ip/vrf";
              tailf:cli-diff-dependency "../../../../../../vrf/definition";
              type string {
                tailf:info "WORD;;VPN Routing/Forwarding instance name";
              }
            }
            uses router-rip-af-grouping;
          }
        }
      }
    }

    /// router lisp
    // router lisp
    container lisp {
      tailf:info "Locator/ID Separation Protocol";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-router-lisp";
      tailf:cli-diff-dependency "../../interface";
      presence true;
      uses router-lisp-grouping {
        refine "eid-table/vrf/name" {
          tailf:cli-diff-dependency "../../../../../ip/vrf";
          tailf:cli-diff-dependency "../../../../../vrf/definition";
        }
      }
    }

    // router lisp *
    container router-lisp {
      tailf:cli-drop-node-name;
      list lisp {
        tailf:cli-mode-name "config-router-lisp";
        key id;
        leaf id {
          type uint8 {
            tailf:info "<0-15>;;router lisp ID";
            range "0..15";
          }
        }
        uses router-lisp-grouping {
          refine "eid-table/vrf/name" {
            tailf:cli-diff-dependency "../../../../../../ip/vrf";
            tailf:cli-diff-dependency "../../../../../../vrf/definition";
          }
        }
      }
    }

    /// router odr
    // router odr
    container odr {
      tailf:info "On Demand stub Routes";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-router";
      tailf:cli-full-command;
      presence true;
    }
  }


  /// ========================================================================
  /// vstack
  /// ========================================================================

  // vstack XXX
  container vstack-conf {
    tailf:cli-drop-node-name;
    container vstack {
      tailf:info "Configure vstack parameters";
      tailf:cli-incomplete-command;
      tailf:cli-incomplete-no;

      // vstack director
      leaf director {
        tailf:info "Configure director's IP address";
        tailf:cli-full-command;
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Director's IP Address";
        }
      }

      // vstack basic
      leaf basic {
        tailf:info "Enable vstack director";
        tailf:cli-full-command;
        type empty;
      }
    }
  }

  // no vstack
  container vstack-no {
    tailf:cli-drop-node-name;
    leaf vstack {
      tailf:info "Configure vstack parameters and enable or disable SmartInstall";
      tailf:cli-boolean-no;
      type boolean;
      default true;
    }
  }


  /// ========================================================================
  /// snmp
  /// ========================================================================

  container snmp {
    tailf:info "Modify non engine SNMP parameters";

    // snmp ifmib
    container ifmib {
      tailf:info "IF-MIB commands";

      // snmp ifmib ifindex
      container ifindex {
        tailf:info "ifindex persistence";
        leaf persist {
          tailf:info "Persist interface indices";
          type empty;
        }
      }

      // snmp ifmib ifalias long
      container ifalias {
        tailf:info "ifAlias description option, by default it is limited to 64 character";
        leaf long {
          tailf:info "ifAlias description can be up to 256 characters";
          type empty;
        }
      }

      // snmp ifmib trap throttle
      container trap {
        tailf:info "IF-MIB trap options";
        leaf throttle {
          tailf:info "disable subinterface link down traps if main interface is down";
          type empty;
        }
      }
    }

    // snmp mib
    container mib {
      tailf:info "MIB commands";

      // snmp mib community-map *
      list community-map {
        tailf:info "Community Mapping as per RFC-2576";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key name;
        leaf name {
          tailf:non-strict-leafref {
            path "../../../../snmp-server/community/name";
          }
          type string {
            tailf:info "WORD;;SNMP community string";
          }
        }
        leaf context {
          tailf:info "Context Name for the community mapping";
          tailf:cli-optional-in-sequence;
          type string {
            tailf:info "WORD;;SNMP Context Name";
          }
        }
        leaf engineid {
          tailf:info "Engine ID for the community mapping";
          tailf:cli-optional-in-sequence;
          type string {
            tailf:info "WORD;;SNMP Engine ID";
          }
        }
        leaf security-name {
          tailf:info "Security Name for the community mapping";
          tailf:cli-optional-in-sequence;
          type string {
            tailf:info "WORD;;SNMP Security Name";
          }
        }
        leaf target-list {
          tailf:info "list of targets valid with this community";
          type string {
            tailf:info "WORD;;target list name";
          }
        }
      }

      // snmp mib bulkstat
      container bulkstat {
        tailf:info "Bulkstat Configuration commands";

        // snmp mib bulkstat object-list
        list object-list {
          tailf:info "Configure an Object List.";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Name of object list";
            }
          }
        }
      }

      // snmp mib persist
      container persist {
        tailf:info "Persistence for MIBS";
        tailf:cli-diff-set-after "../../../snmp-server/ifindex/persist";

        // snmp mib persist v3mibs
        leaf v3mibs {
          tailf:info "Persistence for v3 MIBS";
          type empty;
        }

        // snmp mib persist dsmib
        leaf dsmib {
          tailf:info "DiffServ MIB persistence";
          type empty;
        }

        // snmp mib persist cbqos
        leaf cbqos {
          tailf:info "CBQOS MIB index persistence";
          type empty;
        }

        // snmp mib persist circuit
        leaf circuit {
          tailf:info "Circuit MIB persistence";
          type empty;
        }
      }
    }
  }


  /// ========================================================================
  /// menu
  /// ========================================================================

  // menu * title
  list menu {
    tailf:info "Define a user-interface menu";
    tailf:cli-suppress-mode;
    tailf:cli-delete-when-empty;
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;Name of this menu";
      }
    }

    // menu * title
    leaf title {
      tailf:info "Set menu title";
      tailf:cli-no-value-on-delete;
      type string {
        tailf:info "LINE;;Quoted text of title. Use \\r\\n for newline. delimeter ^ is added automatically.";
      }
    }

    // menu * prompt
    leaf prompt {
      tailf:info "Set prompt string";
      tailf:cli-no-value-on-delete;
      type string {
        tailf:info "LINE;;Quoted string. Use \\r\\n for newline. delimeter ^ is added automatically.";
      }
    }

    // menu * text *
    list text {
      tailf:info "Set text of menu line";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      key item;
      leaf item {
        type string {
          tailf:info "WORD;;Menu item number or character";
        }
      }
      leaf line {
        tailf:cli-drop-node-name;
        tailf:cli-multi-value;
        type string {
          tailf:info "LINE;;Text for this menu item";
        }
      }
    }

    // menu * command *
    list command {
      tailf:info "Set menu command";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      key item;
      leaf item {
        type string {
          tailf:info "WORD;;Menu item number or character";
        }
      }
      leaf command {
        tailf:cli-drop-node-name;
        tailf:cli-multi-value;
        type string {
          tailf:info "LINE;;Command for this menu item";
        }
      }
    }

    // menu * options *
    list options {
      tailf:info "Set per-item options";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      key item;
      leaf item {
        type string {
          tailf:info "WORD;;Menu item number or character";
        }
      }
      leaf pause {
        tailf:info "after command, before redrawing menu";
        tailf:cli-optional-in-sequence;
        type empty;
      }
      leaf login {
        tailf:info "Login required before command";
        type empty;
      }
    }

    // menu * clear-screen
    leaf clear-screen {
      tailf:info "Use termcap database to clear screen";
      tailf:cli-full-command;
      type empty;
    }

    // menu * status-line
    leaf status-line {
      tailf:info "Display user status at top of screen";
      tailf:cli-full-command;
      type empty;
    }

    // menu * line-mode
    leaf line-mode {
      tailf:info "require <enter> after typing selection";
      tailf:cli-full-command;
      type empty;
    }

    // menu * single-space
    leaf single-space {
      tailf:info "single-space menu entries on display";
      tailf:cli-full-command;
      type empty;
    }
  }


  /// ========================================================================
  /// cpu
  /// ========================================================================

  // cpu traffic qos
  container cpu {
    tailf:info "Qos parameters for CPU generated traffic";
    container traffic {
      tailf:info "control plane traffic";
      container qos {
        tailf:info "qos parameters for control plane traffic";

        // cpu traffic qos cos
        container cos {
          tailf:info "cos value for control plane traffic";
          leaf value {
            tailf:cli-drop-node-name;
            tailf:cli-full-command;
            type uint8 {
              tailf:info "<0-7>;;cos value";
              range "0..7";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// snmp-server
  /// ========================================================================

  container snmp-server {
    tailf:info "Modify SNMP engine parameters";

    // snmp-server user *
    list user {
      tailf:info "Define a user who can access the SNMP engine";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-incomplete-command;
      key name;
      leaf name {
        tailf:cli-diff-dependency "../../engineID";
        type string {
          tailf:info "WORD;;Name of the user";
        }
      }
      leaf group {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type string {
          tailf:info "WORD;;Group to which the user belongs";
        }
      }
      uses snmp-server-user-grouping;
    }

    // snmp-server user * <group> remote *
    container user-remote {
      tailf:cli-drop-node-name;
      list user {
        tailf:info "Define a user who can access the SNMP engine";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-incomplete-command;
        key "name remote";
        leaf name {
          tailf:cli-diff-dependency "../../../engineID";
          type string {
            tailf:info "WORD;;Name of the user";
          }
        }
        leaf group {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key {
            tailf:cli-before-key 2;
          }
          type string {
            tailf:info "WORD;;Group to which the user belongs";
          }
        }
        leaf remote {
          tailf:info "Specify a remote SNMP entity to which the user belongs";
          tailf:cli-expose-key-name;
          type inet:host {
            tailf:info "WORD;;IP/IPv6 address of remote SNMP entity";
          }
        }
        leaf udp-port {
          tailf:info "The remote SNMP entity's UDP port number";
          tailf:cli-optional-in-sequence;
          type uint16 {
            tailf:info "<0-65535>;;The remote SNMP entity's UDP port number";
          }
        }
        uses snmp-server-user-grouping;
      }
    }

    // snmp-server chassis-id
    leaf chassis-id {
      tailf:info "String to uniquely identify this chassis";
      tailf:cli-multi-value;
      type string {
        tailf:info "LINE;;Unique ID string";
      }
    }

    // snmp-server community *
    list community {
      tailf:info "Enable SNMP; set community string and access privs";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;SNMP community string";
        }
      }
      leaf view {
        tailf:info "Restrict this community to a named MIB view";
        tailf:cli-optional-in-sequence;
        type string {
          tailf:info "WORD;;MIB view to which this community has access";
        }
      }
      choice access-choice {
        leaf RO {
          tailf:info "Read-only access with this community string";
          tailf:cli-optional-in-sequence;
          type empty;
        }
        leaf RW {
          tailf:info "Read-write access with this community string";
          tailf:cli-optional-in-sequence;
          type empty;
        }
      }
      leaf ipv6 {
        tailf:info "Specify IPv6 Named Access-List";
        tailf:cli-optional-in-sequence;
        tailf:non-strict-leafref {
          path "/ios:ipv6/access-list/named-acl/name";
        }
        type string {
          tailf:info "WORD;;IPv6 Access-list name";
        }
      }
      leaf access-list-name {
        tailf:cli-drop-node-name;
        type std-ip-acl-type;
      }
    }

    // snmp-server contact
    leaf contact {
      tailf:info "Text for mib object sysContact";
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;identification of the contact person for this managed node";
      }
    }

    // snmp-server context *
    list context {
      tailf:info "Create/Delete a context apart from default";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Context Name";
        }
      }
    }

    // snmp-server drop
    container drop {
      tailf:info "Silently drop SNMP packets";
      leaf vrf-traffic {
        tailf:info "Silently drop SNMP packets that come on VRF interface";
        type empty;
      }
    }

    // snmp-server enable
    container enable {
      tailf:info "Enable SNMP Traps or Informs";
      choice enable-choice {

        // snmp-server enable informs
        leaf informs {
          tailf:info "Enable SNMP Informs";
          type empty;
        }

        // snmp-server enable traps *
        list traps {
          tailf:info "Enable SNMP Traps";
          when "not(../../../tailfned/api/snmp-server-enable-all-traps)" {
            tailf:dependency "../../../tailfned/api/snmp-server-enable-all-traps";
          }
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-full-command;
          key name;
          leaf name {
            tailf:cli-multi-word-key;
            tailf:cli-disallow-value "all-traps"; // to avoid accidental misconfiguration
            type string {
              tailf:info "WORD;;Trap name";
            }
          }
        }

        // snmp-server enable all-traps
        leaf all-traps {
          tailf:info "use with 'api/snmp-server-enable-all-traps' ned-setting to enable all traps on device";
          when "../../../tailfned/api/snmp-server-enable-all-traps" {
            tailf:dependency "../../../tailfned/api/snmp-server-enable-all-traps";
          }
          ios:snmp-server-all-traps;
          type empty;
        }
      }
    }

    // snmp-server engine-id
    container engineID {
      tailf:info "Configure a local or remote SNMPv3 engineID";

      // snmp-server engineID local
      leaf local {
        tailf:info "engineID of the local agent";
        type string {
          tailf:info "WORD;;engine ID octet string";
          length "1..24";
        }
      }

      // snmp-server engineID remote *
      // FIXME: one entry per udp-port|vrf|udp-port&vrf can co-exist.
      list remote {
        tailf:info "engineID of the remote agent";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        key address;
        leaf address {
          type inet:host {
            tailf:info "Hostname, A.B.C.D or X:X:X:X::X;;Remote address";
          }
        }
        leaf udp-port {
          tailf:info "The remote notification host's UDP port number";
          tailf:cli-optional-in-sequence;
          type uint16 {
            tailf:info "<0-65535>;;The remote notification host's UDP port number";
          }
        }
        leaf vrf {
          tailf:info "The remote notification host's VPN routing instance";
          tailf:cli-optional-in-sequence;
          tailf:cli-diff-dependency "../../../../ip/vrf";
          tailf:cli-diff-dependency "../../../../vrf/definition";
          type string {
            tailf:info "WORD;;VPN Routing/Forwarding instance name";
          }
        }
        leaf engineid-string {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;engine ID octet string";
          }
        }
      }
    }

    // snmp-server group *
    list group {
      tailf:info "Define a User Security Model group";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      key "id model";
      leaf id {
        tailf:cli-suppress-range;
        type string {
          tailf:info "WORD;;Name of the group";
        }
      }
      leaf model {
        tailf:cli-suppress-range;
        type enumeration {
          enum v1 {
            tailf:info "group using the v1 security model";
          }
          enum v2c {
            tailf:info "group using the v2c security model";
          }
          enum v3 {
            tailf:info "group using the User Security Model (SNMPv3)";
          }
        }
      }
      list level {
        when "../model = 'v3'" {
          tailf:dependency "../model";
        }
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key name;
        leaf name {
          tailf:cli-suppress-range;
          type enumeration {
            enum auth {
              tailf:info "group using the authNoPriv Security Level";
            }
            enum noauth {
              tailf:info "group using the noAuthNoPriv Security Level";
            }
            enum priv {
              tailf:info "group using SNMPv3 authPriv security level";
            }
          }
        }
        uses snmp-server-group-grouping; // v3
      }
      uses snmp-server-group-grouping; // v1 or v2c
    }

    // snmp-server group * context *
    container group-context {
      tailf:cli-drop-node-name;
      list group {
        tailf:info "Define a User Security Model group";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key "id model context";
        leaf id {
          tailf:cli-suppress-range;
          type string {
            tailf:info "WORD;;Name of the group";
          }
        }
        leaf model {
          tailf:cli-suppress-range;
          type enumeration {
            enum v1 {
              tailf:info "group using the v1 security model";
            }
            enum v2c {
              tailf:info "group using the v2c security model";
            }
          }
        }
        leaf context {
          tailf:info "specify a context to associate these views for the group";
          tailf:cli-suppress-range;
          tailf:cli-expose-key-name;
          type string {
            tailf:info "WORD;;context name";
          }
        }
        uses snmp-server-group-grouping;
      }
    }

    // snmp-server group * context *
    container group-v3-context {
      tailf:cli-drop-node-name;
      list group {
        tailf:info "Define a User Security Model group";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key "id model level context";
        leaf id {
          tailf:cli-suppress-range;
          type string {
            tailf:info "WORD;;Name of the group";
          }
        }
        leaf model {
          tailf:cli-suppress-range;
          type enumeration {
            enum v3 {
              tailf:info "group using the User Security Model (SNMPv3)";
            }
          }
        }
        leaf level {
          tailf:cli-suppress-range;
          type enumeration {
            enum auth {
              tailf:info "group using the authNoPriv Security Level";
            }
            enum noauth {
              tailf:info "group using the noAuthNoPriv Security Level";
            }
            enum priv {
              tailf:info "group using SNMPv3 authPriv security level";
            }
          }
        }
        leaf context {
          tailf:info "specify a context to associate these views for the group";
          tailf:cli-suppress-range;
          tailf:cli-expose-key-name;
          type string {
            tailf:info "WORD;;context name";
          }
        }
        uses snmp-server-group-grouping;
      }
    }

    // snmp-server host *
    // With 'ned-settings cisco-ios api new-snmp-server-host true'
    container community-list {
      tailf:cli-drop-node-name;
      when "../../tailfned/api/new-snmp-server-host" {
        tailf:dependency "../../tailfned/api/new-snmp-server-host";
      }
      list host {
        tailf:info "Specify hosts to receive SNMP notifications";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key "ip-address message-type community-string";
        leaf ip-address {
          tailf:cli-disallow-value "vrf";
          tailf:cli-case-sensitive;
          tailf:cli-suppress-range;
          type inet:host {
            tailf:info "WORD;;Hostname or IP/IPv6 address of SNMP notification host";
          }
        }
        uses snmp-server-host-new-grouping;
      }
      container host-vrf {
        tailf:cli-drop-node-name;
        list host {
          tailf:info "Specify hosts to receive SNMP notifications";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          key "ip-address vrf message-type community-string";
          leaf ip-address {
            tailf:cli-disallow-value "vrf";
            tailf:cli-case-sensitive;
            tailf:cli-suppress-range;
            type inet:host {
              tailf:info "WORD;;Hostname or IP/IPv6 address of SNMP notification host";
            }
          }
          leaf vrf {
            tailf:info "VPN Routing instance for this host";
            tailf:cli-expose-key-name;
            tailf:cli-diff-dependency "../../../../../ip/vrf";
            tailf:cli-diff-dependency "../../../../../vrf/definition";
            type string {
              tailf:info "WORD;;VPN Routing/Forwarding instance name";
            }
          }
          uses snmp-server-host-new-grouping;
        }
      }
    }

    // snmp-server host *
    list host {
      when "not(../../tailfned/api/new-snmp-server-host)" {
        tailf:dependency "../../tailfned/api/new-snmp-server-host";
      }
      tailf:info "Specify hosts to receive SNMP notifications";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      tailf:cli-incomplete-command;
      key "ip-address message-type";
      leaf ip-address {
        tailf:cli-disallow-value "vrf";
        tailf:cli-case-sensitive;
        tailf:cli-suppress-range;
        type inet:host {
          tailf:info "WORD;;Hostname or IP/IPv6 address of SNMP notification host";
        }
      }
      uses snmp-server-host-grouping;
    }

    // snmp-server host * vrf *
    container host-vrf {
      tailf:cli-drop-node-name;
      when "not(../../tailfned/api/new-snmp-server-host)" {
        tailf:dependency "../../tailfned/api/new-snmp-server-host";
      }
      list host {
        tailf:info "Specify hosts to receive SNMP notifications";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        tailf:cli-incomplete-command;
        key "ip-address vrf message-type";
        leaf ip-address {
          tailf:cli-case-sensitive;
          tailf:cli-suppress-range;
          type inet:host {
            tailf:info "WORD;;Hostname or IP/IPv6 address of SNMP notification host";
          }
        }
        leaf vrf {
          tailf:info "VPN Routing instance for this host";
          tailf:cli-expose-key-name;
          tailf:cli-diff-dependency "../../../../ip/vrf";
          tailf:cli-diff-dependency "../../../../vrf/definition";
          type string {
            tailf:info "WORD;;VPN Routing/Forwarding instance name";
          }
        }
        uses snmp-server-host-grouping;
      }
    }

    // snmp-server ip
    container ip {
      tailf:info "IP ToS configuration for SNMP traffic";

      // snmp-server ip dscp
      leaf dscp {
        tailf:info "IP DSCP value for SNMP traffic";
        type uint8 {
          tailf:info "<0-63>;;ip dscp value (default value 0 )";
          range "0..63";
        }
      }

      // snmp-server ip precedence
      leaf precedence {
        tailf:info "IP Precedence value for SNMP traffic";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<0-7>;;ip precedence value (default value 0)";
          range "0..7";
        }
      }
    }

    // snmp-server ifindex
    container ifindex {
      tailf:info "Enable ifindex persistence";
      leaf persist {
        tailf:info "Persist interface indices";
        type empty;
      }
    }

    // snmp-server location
    leaf location {
      tailf:info "Text for mib object sysLocation";
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;The physical location of this node";
      }
    }

    // snmp-server manager
    container manager {
      tailf:info "Modify SNMP manager parameters";
      tailf:cli-display-separated;
      presence true;
      leaf session-timeout {
        tailf:info "Timeout value for destroying sessions";
        cli:ned-diff-move-before "=no snmp-server manager" {
          cli:arguments "when-delete";
        }
        type uint32 {
          tailf:info "<10-2147483>;;seconds";
          range "10..2147483";
        }
      }
    }

    // snmp-server packetsize
    leaf packetsize {
      tailf:info "Largest SNMP packet size";
      type uint16 {
        tailf:info "<484-17940>;;Packet size. Default 1500";
        range "484..17940";
      }
      default 1500;
    }

    // snmp-server queue-length
    leaf queue-length {
      tailf:info "Message queue length for each TRAP host";
      type uint16 {
        tailf:info "<1-5000>;;Queue length (default 10)";
        range "1..5000";
      }
      default 10;
    }

    // snmp-server queue-limit notification-host
    container queue-limit {
      tailf:info "Message queue size for different queues";
      leaf notification-host {
        tailf:info "Message queue length for each notification host";
        type uint16 {
          tailf:info "<1-5000>;;notification host queue length";
          range "1..5000";
        }
      }
    }

    // snmp-server tftp-server-list
    leaf tftp-server-list {
      tailf:info "Limit TFTP servers used via SNMP";
      tailf:cli-full-command;
      type std-acl-type;
    }

    // snmp-server system-shutdown
    leaf system-shutdown {
      tailf:info "Enable use of the SNMP reload command";
      type empty;
    }

    // snmp-server file-transfer access-group *
    container file-transfer {
      tailf:info "File transfer related commands";
      list access-group {
        tailf:info "Access control for file transfers";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type std-ip-acl-type;
        }

        // snmp-server file-transfer access-group * protocol *
        leaf-list protocol {
          tailf:info "protocol options";
          tailf:cli-list-syntax;
          type enumeration {
            enum ftp {
              tailf:info "Configure acl for ftp transfer protocol";
            }
            enum rcp {
              tailf:info "Configure acl for rcp transfer protocol";
            }
            enum scp {
              tailf:info "Configure acl for scp transfer protocol";
            }
            enum sftp {
              tailf:info "Configure acl for sftp transfer protocol";
            }
            enum tftp {
              tailf:info "Configure acl for tftp transfer protocol";
            }
          }
        }
      }
    }

    // snmp-server source-interface
    container source-interface {
      tailf:info "Assign an source interface";
      container informs {
        tailf:info "source interface for informs";
        uses interface-name-grouping;
      }
      container traps {
        tailf:info "source interface for traps";
        uses interface-name-grouping;
      }
    }

    // snmp-server trap
    container trap {
      tailf:info "SNMP trap options";

      // snmp-server trap timeout
      leaf timeout {
        tailf:info "Set timeout for TRAP message retransmissions";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<1-1000>;;Timeout (default 30 seconds)";
          range "1..1000";
        }
        default 30;
      }

      // snmp-server trap authentication
      container authentication {
        tailf:info "fine-tune enable/disable of authentication traps";

        // no snmp-server trap authentication vrf
        leaf vrf {
          tailf:info "enable authentication traps for packets on a vrf";
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }

        // no snmp-server trap authentication unknown-context
        leaf unknown-context {
          tailf:info "enable authentication traps for unknown context error";
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }
      }

      // snmp-server trap link ietf
      container link {
        tailf:info "Assign/Enable SNMP link traps";

        // snmp-server trap link ietf
        leaf ietf {
          tailf:info "Use IETF standard for SNMP traps";
          type empty;
        }

        // snmp-server trap link switchover
        leaf switchover {
          tailf:info "Enable link up/down traps during switchover";
          type empty;
        }
      }
    }

    // no snmp-server sparse-tables
    leaf sparse-tables {
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
      default true;
    }

    // snmp-server trap-source
    container trap-source {
      tailf:info "Assign an interface for the source address of all traps";
      uses interface-name-grouping;
    }

    // snmp-server trap-timeout
    leaf trap-timeout {
      tailf:info "Set timeout for TRAP message retransmissions";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<1-1000>;;Timeout (default 30 seconds)";
      }
    }

    // snmp-server view *
    list view {
      tailf:info "Define an SNMPv2 MIB view";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key "name mib";
      leaf name {
        type string {
          tailf:info "WORD;;Name of the view";
        }
      }
      leaf mib {
        type string {
          tailf:info "WORD;;MIB view family name";
        }
      }
      leaf inc-exl {
        tailf:cli-drop-node-name;
        type enumeration {
          enum excluded {
            tailf:info "MIB family is excluded from the view";
          }
          enum included {
            tailf:info "MIB family is included in the view";
          }
        }
      }
    }

    // snmp-server inform
    container inform {
      tailf:info "Configure SNMP Informs options";
      tailf:cli-compact-syntax;
      leaf retries {
        tailf:info "Set retry count for informs";
        tailf:cli-delete-container-on-delete;
        type uint8 {
          tailf:info "<0-100>;;Number of times to retry an Inform request";
          range "0..100";
        }
      }
      leaf timeout {
        tailf:info "Set timeout for informs";
        tailf:cli-delete-container-on-delete;
        type uint32 {
          tailf:info "<0-42949671>;;Timeout value, in seconds";
        }
      }
      leaf pending {
        tailf:info "Set number of unacked informs to hold";
        tailf:cli-delete-container-on-delete;
        type uint32 {
          tailf:info "<1-4294967295>;;Number of unacked informs to hold";
          range "1..4294967295";
        }
      }
    }
  }


  /// ========================================================================
  /// rtr
  /// ========================================================================

  container rtr {
    tailf:info "RTR Base Configuration";

    // rtr *
    list entry {
      tailf:cli-drop-node-name;
      tailf:cli-mode-name "config-rtr";
      key id;
      leaf id {
        type uint32 {
          tailf:info "<1-2147483647>;;Entry Number";
        }
      }

      // rtr * / type
      container type {
        tailf:info "Type of Entry";
        choice type-choice {

          // rtr * / type echo
          container echo {
            tailf:info "Echo Operation";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf protocol {
              tailf:info "Protocol to Use for Operations";
              tailf:cli-incomplete-command;
              type enumeration {
                enum ipIcmpEcho {
                   tailf:info "Use IP/ICMP";
                }
              }
            }
            leaf ipaddr {
              tailf:cli-drop-node-name;
              type inet:host {
                tailf:info "WORD;;IP Address or IP HostName";
              }
            }
            leaf source-ipaddr {
              tailf:info "Source Address";
              type inet:host {
                tailf:info "WORD;;IP Address or IP HostName";
              }
            }
          }
        }
      }

      // rtr * / owner
      leaf owner {
        tailf:info "Owner of Entry";
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE;;Owner String";
        }
      }

      // rtr * / tag
      leaf tag {
        tailf:info "User Defined Tag";
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE;;Tag String";
        }
      }

      // rtr * / threshold
      leaf threshold {
        tailf:info "Operation Threshold in Milliseconds";
        type uint32 {
          tailf:info "<0-2147483647>;;Millisecond Threshold Value";
          range "0..2147483647";
        }
      }

      // rtr * / frequency
      leaf frequency {
        tailf:info "Operation Frequency Value in Seconds";
        type uint32 {
          tailf:info "<1-604800>;;Second Frequency Interval Value";
          range "1..604800";
        }
      }
    }

    // rtr schedule *
    list schedule {
      tailf:info "RTR Entry Scheduling";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      ios:delete-syntax "!";
      key id;
      leaf id {
        type uint32 {
          tailf:info "<1-2147483647>;;Entry Number";
        }
      }
      container start-time {
        tailf:info "When to start this entry";
        choice time-choice {
          container now {
            tailf:info "Start Now";
            presence true;
          }
        }
      }
    }

    // rtr responder
    container responder {
      tailf:info "Enable RTR Responder";
      presence true;
    }

    // rtr key-chain
    leaf key-chain {
      tailf:non-strict-leafref {
        path "/ios:key/chain/name";
      }
      type string {
        tailf:info "WORD;;Key-chain name";
      }
    }
  }


  /// ========================================================================
  /// ipc
  /// ========================================================================

  container ipc {
    tailf:info "Configure IPC system";
    container zone {
      tailf:info "Configure an IPC Zone";

      // ipc zone default
      container default {
        tailf:info "Configure the default zone";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-ipczone";
        presence true;
      }
    }
  }


  /// ========================================================================
  /// cts
  /// ========================================================================

  container cts {
    tailf:info "Cisco Trusted Security commands";
    tailf:cli-diff-dependency "../ip/vrf";
    tailf:cli-diff-dependency "../vrf/definition";

    // cts server test *
    container server {
      tailf:info "CTS server list configuration";
      list test {
        tailf:info "Configure server automated test for liveness check";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type union {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Server's IP address";
            }
            type enumeration {
              enum all {
                tailf:info "Configure for all servers";
              }
            }
          }
        }

        // cts server test * no-enable
        // (no cts server test * enable)
        leaf no-enable {
          tailf:info "Disable server liveness automated test (set instead of 'no .. enable')";
          type empty;
        }

        // cts server test * deadtime
        leaf deadtime {
          tailf:info "Configure how long a server marked as dead should not be used";
          type uint32 {
            tailf:info "<1-864000>;;Timer value in seconds";
            range "1..864000";
          }
          default 20;
        }
      }
    }

    // cts authorization list
    container authorization {
      tailf:info "CTS global authorization configuration";
      leaf list {
        tailf:info "Local authorization list to use for CTS";
        type string {
          tailf:info "WORD;;Name of locally configured authorization list";
        }
      }
    }

    // cts credentials id * password
    container credentials {
      tailf:info "Insert CTS device ID and password into the keystore [cached EXEC 'config']";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf id {
        tailf:info "Specify the CTS device ID for this switch or router";
        tailf:cli-incomplete-command;
        type string {
          tailf:info "WORD;;the CTS device ID for this switch or router";
        }
      }
      leaf password {
        tailf:info "specify this device's CTS password";
        ios:password-dequote-output "password (\\S+)";
        type tailf:aes-cfb-128-encrypted-string {
          tailf:info "WORD;;this device's CTS password";
        }
      }
    }

    // cts sgt
    leaf sgt {
      tailf:info "Local device security group";
      type uint16 {
        tailf:info "<2-65519>;;Security Group Tag (SGT) value";
        range "2..65519";
      }
    }

    // cts logging verbose
    container logging {
      tailf:info "Set logging parameters";
      leaf verbose {
        tailf:info "Show verbose messages in system logs";
        type empty;
      }
    }

    // cts role-based
    container role-based {
      tailf:info "Role-based Access Control configuration commands";

      // cts role-based sgt-map * sgt
      list sgt-map {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key address;
        leaf address {
          type string {
            tailf:info "ADDRESS;;A.B.C.D, A.B.C.D/nn, X:X:X:X::X or X:X:X:X::X/<0-128>";
          }
        }
        leaf sgt {
          tailf:info "Security Group Tag (SGT)";
          tailf:cli-no-name-on-delete;
          tailf:cli-no-value-on-delete;
          type uint16 {
            tailf:info "<2-65519>;;Security Group Tag value";
            range "2..65519";
          }
        }
      }

      // cts role-based sgt-map vrf *sgt *
      container sgt-map-vrf {
        tailf:cli-drop-node-name;
        list sgt-map {
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          key "vrf address";
          leaf vrf {
            tailf:info "Select VPN Routing/Forwarding instance for the binding";
            tailf:cli-expose-key-name;
            type string {
              tailf:info "WORD;;VPN Routing/Forwarding instance name";
            }
          }
          leaf address {
            type string {
              tailf:info "ADDRESS;;A.B.C.D, A.B.C.D/nn, X:X:X:X::X or X:X:X:X::X/<0-128>";
            }
          }
          leaf sgt {
            tailf:info "Security Group Tag (SGT)";
            tailf:cli-no-name-on-delete;
            tailf:cli-no-value-on-delete;
            type uint16 {
              tailf:info "<2-65519>;;Security Group Tag value";
              range "2..65519";
            }
          }
        }
      }

      // cts role-based enforcement
      leaf enforcement {
        tailf:info "Enable Role-based Access Control enforcement";
        tailf:cli-full-command;
        type empty;
      }

      // cts role-based X
      container enforcement-conf {
        tailf:cli-drop-node-name;
        container enforcement {
          tailf:info "Enable Role-based Access Control enforcement";
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;

          // cts role-based enforcement vlan-list
          leaf-list vlan-list {
            tailf:info "Specify vlan(s) (range 1-4094)";
            tailf:cli-range-list-syntax;
            type uint16 {
              tailf:info "WORD;;vlan range, example: 1,3-5,7,9-11";
              range "1..4094";
            }
          }

          // cts role-based enforcement logging-interval
          leaf logging-interval {
            type uint32 {
              range "5..86400";
            }
            default 300;
          }
        }
      }
    }

    // cts sxp
    container sxp {
      tailf:info "CTS sxp configuration";

      // cts sxp enable
      leaf enable {
        tailf:info "Enable CTS SXP support";
        type empty;
      }

      // cts sxp default
      container default {
        tailf:info "Enter default value";

        // cts sxp default source-ip
        leaf source-ip {
          tailf:info "Source IP addr";
          tailf:cli-full-command;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Enter Source IPv4 Address";
          }
        }

        // cts sxp default password
        container password {
          tailf:info "Enter the SXP Password";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          uses password-grouping {
            refine "secret" {
              cli:secret " password <SECRET>";
            }
          }
        }
      }

      // cts sxp retry period
      container retry {
        tailf:info "Connection Retry Params";
        leaf period {
          tailf:info "Interval between connection reattempts";
          type uint32 {
            tailf:info "<0-64000>;;Enter Conn Retry Period in seconds (0 = forever)";
            range "0..64000";
          }
          default 120;
        }
      }

      // cts sxp connection peer *
      container connection {
        tailf:info "CTS SXP Connection Configuration";
        list peer {
          tailf:info "SXP Peer IP address";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-remove-before-change;
          tailf:cli-incomplete-command;
          key address;
          leaf address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Enter SXP Peer IP address (IPv4)";
            }
          }
          leaf source {
            tailf:info "Source IP address";
            tailf:cli-optional-in-sequence;
            tailf:cli-incomplete-command;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Enter SXP Source IP address (IPv4)";
            }
          }
          leaf password {
            tailf:info "password details";
            tailf:cli-incomplete-command;
            type enumeration {
              enum "default" {
                tailf:info "Use default password";
              }
              enum none {
                tailf:info "password NOT required for the conn";
              }
            }
          }
          leaf mode {
            tailf:info "Specify SXP connection mode";
            type enumeration {
              enum local {
                          tailf:info "Configure the mode on the local device";
              }
              enum peer {
                         tailf:info "Configure the mode on the peer device";
              }
            }
          }
          leaf direction {
            tailf:cli-drop-node-name;
            type enumeration {
              enum listener {
                             tailf:info "Receive SXP messages on the conn";
              }
              enum speaker {
                            tailf:info "Send SXP messages on the conn";
              }
              enum both {
                         tailf:info "Configure the mode as both";
              }
            }
          }
          leaf hold-time {
            tailf:info "Connection hold time period";
            tailf:cli-optional-in-sequence;
            type uint16 {
              tailf:info "<0-65535>;;Enter minimum allowed Hold Time in seconds (0: apply global, 65535: no keepalive)";
            }
          }
          leaf vrf {
            tailf:info "Name of the vrf this connection is in";
            type string {
              tailf:info "WORD;;vrf name string";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// mab
  /// ========================================================================

  container mab {
    tailf:info "MAC Authentication Bypass Global Configuration Commands";

    // mab request format attribute
    container request {
      tailf:info "Customize MAB request";
      container format {
        tailf:info "Configure the customized MAB request format";
        container attribute {
          tailf:info "Format selected attributes";

          // mab request format attribute 32 vlan access-vlan
          container thirtytwo {
            tailf:alt-name "32";
            tailf:info "NAS-Identifier attribute";
            container vlan {
              tailf:info "Add the vlan";
              leaf access-vlan {
                tailf:info "Add the configured access vlan";
                type empty;
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// license
  /// ========================================================================

  container license {
    tailf:info "Configure license features";

    // license accept end user agreement
    container accept {
      tailf:info "Accept all further License Agreements";
      container end {
        tailf:info "Accept all further License Agreements";
        container user {
          tailf:info "Accept all further License Agreements";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf agreement {
            tailf:info "Accept all further License Agreements";
            type empty;
          }
          // license accept end user agreement force
          leaf force {
            tailf:info "Accept Eula implicitly without displaying";
            type empty;
          }
        }
      }
    }

    // license feature *
    list feature {
      tailf:info "License features";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      ordered-by user;
      key line;
      leaf line {
        tailf:cli-multi-word-key;
        type string {
          tailf:info "WORD;;License line";
        }
      }
    }

    // license boot *
    list boot {
      tailf:info "license boot config commands";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      ordered-by user;
      key line;
      leaf line {
        tailf:cli-multi-word-key;
        type string {
          tailf:info "WORD;;License line";
        }
      }
    }

    // license smart
    container smart {
      tailf:info "Smart licensing";

      // license smart enable
      leaf enable {
        tailf:info "Enable Smart Licensing";
        type empty;
      }

      // license smart utility customer_info
      container utility {
        tailf:info "Enable or disable usage reporting on the device";
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        container customer_info {
          tailf:info "Set the customer info";
          leaf id {
            tailf:info "Set a customer defined company id";
            tailf:cli-no-value-on-delete;
            type string {
              tailf:info "WORD;;Customer defined id";
            }
          }
          leaf name {
            tailf:info "Set a customer defined company name";
            tailf:cli-no-value-on-delete;
            type string {
              tailf:info "WORD;;Customer defined name";
            }
          }
          leaf street {
            tailf:info "Set customer info street";
            tailf:cli-no-value-on-delete;
            type string {
              tailf:info "WORD;;Customer defined street";
            }
          }
          leaf city {
            tailf:info "Set customer info city";
            tailf:cli-no-value-on-delete;
            type string {
              tailf:info "WORD;;Customer defined city";
            }
          }
          leaf state {
            tailf:info "Set customer info state";
            tailf:cli-no-value-on-delete;
            type string {
              tailf:info "WORD;;Customer defined state";
            }
          }
          leaf country {
            tailf:info "Set customer info country";
            tailf:cli-no-value-on-delete;
            type string {
              tailf:info "WORD;;Customer defined country";
            }
          }
          leaf postalcode {
            tailf:info "Set customer info postalcode";
            tailf:cli-no-value-on-delete;
            type string {
              tailf:info "WORD;;Customer defined postalcode";
            }
          }
        }
      }

      // license smart utility
      container utility-enable {
        tailf:cli-drop-node-name;
        leaf utility {
          tailf:info "Enable or disable usage reporting on the device";
          type empty;
        }
      }

      // license smart url
      leaf url {
        tailf:info "Set the Smart Transport Primary and the Utility URL";
        tailf:cli-disallow-value "utility|cslu|smart";
        tailf:cli-no-value-on-delete;
        type string {
          tailf:info "WORD;;Set the Smart Transport URL.";
        }
      }

      // license smart url cslu
      container url-cslu {
        tailf:cli-drop-node-name;
        container url {
          tailf:info "Set the Smart Transport Primary and the Utility URL";
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          leaf cslu {
            tailf:info "Set the CSLU IP or address";
            tailf:cli-no-value-on-delete;
            type string {
              tailf:info "WORD;;Set the Smart Transport URL.";
            }
          }
        }
      }

      // license smart url smart
      container url-smart {
        tailf:cli-drop-node-name;
        container url {
          tailf:info "Set the Smart Transport Primary and the Utility URL";
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          leaf smart {
            tailf:info "Set the smart address.";
            tailf:cli-no-value-on-delete;
            type string {
              tailf:info "WORD;;Set the Smart Transport URL.";
            }
          }
        }
      }

      // license smart url utility
      container url-utility {
        tailf:cli-drop-node-name;
        container url {
          tailf:info "Set the Smart Transport Primary and the Utility URL";
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          leaf utility {
            tailf:info "Set the secondary URL for reporting Utility Licensing usage.";
            tailf:cli-no-value-on-delete;
            type string {
              tailf:info "WORD;;Set the Smart Transport URL.";
            }
          }
        }
      }

      // license smart transport
      leaf transport {
        tailf:info "Select the type of message transport for Smart Agent";
        type enumeration {
          enum smart {
            tailf:info "Use the Smart Transport.";
          }
          enum callhome {
            tailf:info "Use the Callhome as transport.";
          }
          enum off {
            tailf:info "Disable all communication from Smart Agent.";
          }
          enum cslu {
            tailf:info "All future communication will use cslu url.";
          }
          enum automatic {
            tailf:info "Use default transport type.";
          }
        }
        default cslu;
      }

      // license smart reservation
      leaf reservation {
        tailf:info "Enable or disable the license reservation feature";
        type empty;
      }
    }

    // license solution level
    container solution {
      tailf:info "Configure solution license";
      container level {
        tailf:info "which level to configure";

        // license solution level securityk9
        leaf securityk9 {
          tailf:info "Security Solution";
          type empty;
        }
      }
    }
  }


  /// ========================================================================
  /// vxml
  /// ========================================================================

  container vxml {
    tailf:info "VXML Interpreter configuration commands";

    // vxml logging-tag
    leaf logging-tag {
      tailf:info "send ASR/TTS server Logging-Tag in MRCP";
      type empty;
    }
  }


  /// ========================================================================
  /// setup
  /// ========================================================================

  container setup {
    tailf:info "Configure setup options";

    // no setup express
    leaf express {
      tailf:info "Configure whether express setup mode is enabled";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
      default true;
    }
  }


  /// ========================================================================
  /// trunk
  /// ========================================================================

  container trunk {
    tailf:info "Global trunk configuration";

    // trunk group *
    list group {
      tailf:info "Specify a trunk group";
      tailf:cli-mode-name "config-trunk-group";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Trunk group label";
        }
      }

      // trunk group * / hunt-scheme
      container hunt-scheme {
        tailf:info "The hunt scheme in trunk group";
        choice hunt-scheme-choice {
          container round-robin {
            tailf:info "The next interface with free timeslots is selected";
            tailf:cli-compact-syntax;
            tailf:cli-delete-when-empty;
            presence true;
          }
          leaf random {
            tailf:info "The timeslot is selected randomly";
            type empty;
          }
          leaf sequential {
            type empty;
          }
        }
      }
    }

  }


  /// ========================================================================
  /// gw-accounting
  /// ========================================================================

  container gw-accounting {

    choice gw-accounting-choice {

      // gw-accounting syslog
      container syslog {
        tailf:info "Enable voip syslog accounting.";
        tailf:cli-delete-when-empty;
        presence true;
        // gw-accounting syslog stats
        leaf stats {
          tailf:info "Enable stats as part of accounting.";
          type empty;
        }
      }

      // gw-accounting aaa
      leaf aaa {
        tailf:info "Enable aaa accounting";
        type empty;
      }

      // gw-accounting file
      leaf file {
        tailf:info "Enable voip file accounting.";
        type empty;
      }

      // gw-accounting h323
      container h323 {
        tailf:cli-delete-when-empty;
        presence true;
        leaf vsa {
          type empty;
        }
      }

      // gw-accounting voip
      leaf voip {
        type empty;
      }
    }

  }


  /// ========================================================================
  /// voice-card
  /// ========================================================================

  // voice-card *
  list voice-card {
    tailf:info "Configure a specific voice-card";
    tailf:cli-mode-name "config-voicecard";
    key slot;
    leaf slot {
      type string {
        tailf:info "WORD;;Voice interface slot/abay";
        pattern '[0-9]+.*';
      }
    }

    // voice-card * / dspfarm
    leaf dspfarm {
      tailf:info "Enable dspFarm feature for this voice card";
      type empty;
    }

    // voice-card * / dsp
    container dsp {
      tailf:info "Manage DSP configuration for the voice card";

      // voice-card * / dsp services dspfarm
      container services {
        tailf:info "Manage DSP services configuration for the voice card";
        leaf dspfarm {
          tailf:info "Enable voice-only dspfarm services on the Voice Card";
          type empty;
        }
      }
    }

    // voice-card * / no watchdog
    leaf watchdog {
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
      default true;
    }
  }


  /// ========================================================================
  /// voice
  /// ========================================================================

  container voice {
    tailf:info "Global voice configuration";

    // voice service voip
    container service {
      tailf:info "Global packet telephony service commands";
      container voip {
        tailf:info "Voice over IP";
        tailf:cli-add-mode;
        tailf:cli-mode-name "conf-voi-serv";

        // voice service voip / ip address trusted
        container ip {
          tailf:info "Voice service voip ip setup";
          container address {
            tailf:info "Voice service voip ip address setup";
            container trusted {
              tailf:info "ip address trusted (toll fraud prevention) setup";

              // voice service voip / ip address trusted list
              container list {
                tailf:info "ip address trusted (toll fraud prevention) list setup";
                tailf:cli-add-mode;
                tailf:cli-mode-name "cfg-iptrust-list";
                presence true;

                // voice service voip / ip address trusted list / ipv4 *
                list ipv4 {
                  tailf:info "ip address trusted (toll fraud prevention) list entry";
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  key address;
                  leaf address {
                    type inet:ipv4-address {
                      tailf:info "A.B.C.D;;IPv4 Address";
                    }
                  }
                }
              }
            }
          }
        }

        // voice service voip / notify redirect
        container notify {
          tailf:info "send facility indication to application";
          container redirect {
            tailf:info "send redirect notification to application for handling";
            leaf ip2pots {
              tailf:info "send redirect notification to application for ip-to-pots calls";
              type empty;
            }
            leaf ip2ip {
              tailf:info "send redirect notification to application for ip-to-ip calls";
              tailf:cli-boolean-no;
              tailf:cli-full-command;
              type boolean;
              default true;
            }
          }
        }

        // voice service voip / mode
        container mode {
          tailf:info "Global mode setting for voip calls ";

          // voice service voip / mode border-element
          container border-element {
            tailf:info "Mode setting for Border-Element";
            presence true;
          }
        }

        // voice service voip / qsig
        container qsig {
          tailf:info "QSIG";
          leaf decode {
            tailf:info "Decode APDU";
            type empty;
          }
        }

        // voice service voip / allow-connections
        container allow-connections {
          tailf:info "Allow call connection types";
          container h323 {
            tailf:info "from-type h323";
            container to {
              tailf:info "to";
              leaf h323 {
                tailf:info "to-type h323";
                type empty;
              }
              leaf sip {
                tailf:info "to-type sip";
                type empty;
              }
            }
          }
          container sip {
            tailf:info "from-type sip";
            container to {
              tailf:info "to";
              leaf h323 {
                tailf:info "to-type h323";
                type empty;
              }
              leaf sip {
                tailf:info "to-type sip";
                type empty;
              }
            }
          }
        }

        // voice service voip / supplementary-service
        container supplementary-service {
          tailf:info "Config supplementary service features";

          // voice service voip / no supplementary-service h450.2
          leaf h450.2 {
            tailf:info "enable/disable H.450.2";
            tailf:cli-boolean-no;
            type boolean;
            default true;
          }

          // voice service voip / no supplementary-service h450.3
          leaf h450.3 {
            tailf:info "enable/disable H.450.3";
            tailf:cli-boolean-no;
            type boolean;
            default true;
          }

          // voice service voip / no supplementary-service h450.7
          leaf h450.7 {
            tailf:info "enable/disable H.450.7";
            tailf:cli-boolean-no;
            type boolean;
            default true;
          }

          // voice service voip / supplementary-service h450.12
          container h450.12 {
            tailf:info "enable/disable H.450.12";
            tailf:cli-delete-when-empty;
            tailf:cli-reset-container;
            presence true;
            leaf advertise-only {
              tailf:info "enable H.450.12 advertise only mode";
              type empty;
            }
          }

          // voice service voip / supplementary-service sip
          container sip {
            tailf:info "sip supplementary service";
            leaf moved-temporarily {
              tailf:info "enable/disable sip moved-temporarily";
              tailf:cli-boolean-no;
              type boolean;
              default true;
            }
            leaf refer {
              tailf:info "enable/disable sip refer";
              tailf:cli-boolean-no;
              type boolean;
              default true;
            }
            leaf handle-replaces {
              tailf:info "Handle INVITE with REPLACES header (SIP-SIP only)";
              tailf:cli-boolean-no;
              type boolean;
              default true;
            }
          }
        }

        // voice service voip / fax protocol
        container fax {
          tailf:info "Global fax commands";
          container protocol {
            tailf:info "The system-wide fax protocol type";
            choice protoco-choice {
              container t38 {
                tailf:info "Use T.38 protocol";
                tailf:cli-compact-syntax;
                leaf version {
                  tailf:info "t38 fax version";
                  type enumeration {
                    enum 0 {
                      tailf:info "version 0";
                    }
                    enum 3 {
                      tailf:info "version 3";
                    }
                  }
                }
                leaf ls-redundancy {
                  tailf:info "t38 low speed redundancy";
                  type uint8 {
                    tailf:info "<0-5>;;redundancy level, 0 and <cr> no redundancy";
                    range "0..5";
                  }
                }
                leaf hs-redundancy {
                  tailf:info "t38 high speed redundancy";
                  type uint8 {
                    tailf:info "<0-2>;;redundancy level, 0 and <cr> no redundancy";
                    range "0..2";
                  }
                }
                leaf fallback {
                  tailf:info "fax transport to use if T.38 unsupported on far end";
                  type enumeration {
                    enum none {
                      tailf:info "No fallback";
                    }
                    enum cisco {
                      tailf:info "Use Cisco proprietary protocol";
                    }
                    enum pass-through {
                      tailf:info "Use an audio codec for fax transport";
                    }
                  }
                }
              }
            }
          }
        }

        // voice service voip / redirect ip2ip
        container redirect {
          tailf:info "voip call redirect";
          leaf ip2ip {
            tailf:info "Redirect IP-to-IP calls";
            type empty;
          }
        }

        // voice service voip / modem
        container modem {
          tailf:info "Global modem commands";
          container passthrough {
            tailf:info "Pass modem traffic via clear channel";
            container nse {
              tailf:info "Use Named Signaling Events (NSE)";

              // voice service voip / modem passthrough nse codec
              leaf codec {
                tailf:info "Codec selections for upspeed";
                type enumeration {
                  enum g711alaw {
                    tailf:info "G.711 A Law 64000 bps (for E1)";
                  }
                  enum g711ulaw {
                    tailf:info "G.711 u Law 64000 bps (for T1)";
                  }
                }
              }
            }
          }
        }

        // voice service voip / h323
        container h323 {
          tailf:info "Global H.323 configuration commands";
          tailf:cli-add-mode;
          tailf:cli-mode-name "conf-serv-h323";
          presence true;

          // voice service voip / h323 / h225 display-ie ccm-compatible
          container h225 {
            tailf:info "TCP H225 call signalling channel";
            container display-ie {
              tailf:info "Map calling name from Q931 Facility to";
              leaf ccm-compatible {
                tailf:info "H225 Notify for CCM interoperability";
                type empty;
              }
            }
          }
        }

        // voice service voip / sip
        container sip {
          tailf:info "SIP configuration commands";
          tailf:cli-add-mode;
          tailf:cli-mode-name "conf-serv-sip";
          presence true;

          // voice service voip / sip / e911
          leaf e911 {
            tailf:info "SIP Global e911 support";
            type empty;
          }

          // voice service voip / sip / bind
          container bind {
            tailf:info "SIP bind command";

            // voice service voip / sip / bind control source-interface
            container control {
              tailf:info "bind only SIP control packets";
              container source-interface {
                tailf:info "Specify interface for source address of SIP packets";
                tailf:cli-compact-syntax;
                uses interface-name-grouping;
              }
            }

            // voice service voip / sip / bind media source-interface
            container media {
              tailf:info "bind only SIP media packets";
              container source-interface {
                tailf:info "Specify interface for source address of SIP packets";
                tailf:cli-compact-syntax;
                uses interface-name-grouping;
              }
            }
          }

          // voice service voip / sip / registrar server
          container registrar {
            tailf:info "SIP Registrar config";
            container server {
              tailf:info "Enable Local SIP Registrar";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              tailf:cli-delete-when-empty;
              presence true;
              container expires {
                tailf:info "Registration Expires time";
                tailf:cli-flatten-container;
                tailf:cli-compact-syntax;
                leaf max {
                  tailf:info "Default registration max expires time";
                  type uint32 {
                    tailf:info "<120-86400>;;Max Expires value (in seconds)";
                    range "120..86400";
                  }
                }
                leaf min {
                  tailf:info "Default registration min expires time";
                  type uint16 {
                    tailf:info "<60-3600>;;Min Expires value (in seconds)";
                  }
                }
              }
            }
          }
        }
      }
    }

    // voice class
    container class {
      tailf:info "Control parameters class";

      // voice class uri * sip|tel
      list uri {
        tailf:info "Voice URI class configuration commands";
        tailf:cli-mode-name "config-voice-uri-class";
        key name;
        leaf name {
          tailf:cli-incomplete-command;
          type string {
            tailf:info "WORD;;Voice URI Class tag";
          }
        }
        leaf type {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum sip {
              tailf:info "sip: URI class";
            }
            enum tel {
              tailf:info "tel: URI class";
            }
          }
        }

        // voice class uri * / host *
        list host {
          tailf:info "Match the Host portion of the URI";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Alphanumeric regular expression pattern Or a Valid Domain name or IPv4/IPv6 address";
            }
          }
        }
      }

      // voice class codec *
      list codec {
        tailf:info "Set codec global parameters";
        tailf:cli-mode-name "config-class";
        key id;
        leaf id {
          type uint16 {
            tailf:info "<1-10000>;;Voice class codec tag";
            range "1..10000";
          }
        }

        // voice class codec * / codec preference *
        container codec {
          tailf:info "Set class codec parameters";
          list preference {
            tailf:info "Set priority order for using this codec";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            key value;
            leaf value {
              type uint8 {
                tailf:info "<1-24>;;Priority order (1 = Highest)";
                range "1..24";
              }
            }
            leaf codec-type {
              tailf:cli-drop-node-name;
              type enumeration {
                enum aacld {
                  tailf:info "AACLD 90000 bps ";
                }
                enum clear-channel {
                  tailf:info "Clear Channel 64000 bps (No voice capabilities: data transport only)";
                }
                enum g711alaw {
                  tailf:info "G.711 A Law 64000 bps";
                }
                enum g711ulaw {
                  tailf:info "G.711 u Law 64000 bps";
                }
                enum g722-48 {
                  tailf:info "G722-48K 64000 bps - Only supported for H.320<->H.323 calls";
                }
                enum g722-56 {
                  tailf:info "G722-56K 64000 bps - Only supported for H.320<->H.323 calls";
                }
                enum g722-64 {
                  tailf:info "G722-64K 64000 bps";
                }
                enum g723ar53 {
                  tailf:info "G.723.1 ANNEX-A 5300 bps (contains built-in vad that cannot be disabled)";
                }
                enum g723ar63 {
                  tailf:info "G.723.1 ANNEX-A 6300 bps (contains built-in vad that cannot be disabled)";
                }
                enum g723r53 {
                  tailf:info "G.723.1 5300 bps";
                }
                enum g723r63 {
                  tailf:info "G.723.1 6300 bps";
                }
                enum g726r16 {
                  tailf:info "G.726 16000 bps";
                }
                enum g726r24 {
                  tailf:info "G.726 24000 bps";
                }
                enum g726r32 {
                  tailf:info "G.726 32000 bps";
                }
                enum g728 {
                  tailf:info "G.728 16000 bps";
                }
                enum g729br8 {
                  tailf:info "G.729 ANNEX-B 8000 bps (contains built-in vad that cannot be disabled)";
                }
                enum g729r8 {
                  tailf:info "G.729 8000 bps";
                }
                enum ilbc {
                  tailf:info "iLBC 13330 or 15200 bps ";
                }
                enum isac {
                  tailf:info "iSAC 10 to 32 kbps (variable bit-rate)";
                }
              }
            }
            leaf bytes {
              tailf:info "Specify number of voice data bytes per frame";
              type uint8 {
                tailf:info "codec sample payload bytes";
              }
            }
          }
        }
      }

      // voice class custom-cptone *
      list custom-cptone {
        tailf:info "configuration of customized Call Progress Tones";
        tailf:cli-mode-name "cfg-cptone";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Custom CPTone Name";
          }
        }

        // voice class custom-cptone * / dualtone *
        list dualtone {
          tailf:info "Configure call progress dualtones";
          tailf:cli-mode-name "cfg-cp-dualtone";
          key name;
          leaf name {
            type enumeration {
              enum busy {
                tailf:info "Configure busy dualtone";
              }
              enum conference {
                tailf:info "Configure conference join/leave tone";
              }
              enum disconnect {
                tailf:info "Configure disconnect dualtone";
              }
              enum number-unobtainable {
                tailf:info "Configure number-unobtainable dualtone";
              }
              enum out-of-service {
                tailf:info "Configure out-of-service dualtone";
              }
              enum reorder {
                tailf:info "Configure reorder/congestion dualtone";
              }
              enum ringback {
                tailf:info "Configure ringback dualtone";
              }
            }
          }

          // voice class custom-cptone * / dualtone * / frequency
          container frequency {
            tailf:info "Configure dualtone frequencies";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf value-1 {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<300-3600>;;First frequency of the dualtone";
                range "300..3600";
              }
            }
            leaf value-2 {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<300-3600>;;Second frequency of the dualtone";
                range "300..3600";
              }
            }
          }

          // voice class custom-cptone * / dualtone * / cadence
          container cadence {
            tailf:info "Configure dualtone cadences";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf cycle-1-on-time {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<50-10000>;;First On cadence";
                range "50..10000";
              }
            }
            leaf cycle-1-off-time {
              tailf:cli-drop-node-name;
              tailf:cli-optional-in-sequence;
              type uint16 {
                tailf:info "<50-10000>;;First Off cadence";
                range "50..10000";
              }
            }
            leaf cycle-2-on-time {
              tailf:cli-drop-node-name;
              tailf:cli-optional-in-sequence;
              type uint16 {
                tailf:info "<50-10000>;;Second On cadence";
                range "50..10000";
              }
            }
            leaf cycle-2-off-time {
              tailf:cli-drop-node-name;
              tailf:cli-optional-in-sequence;
              type uint16 {
                tailf:info "<50-10000>;;Second Off cadence";
                range "50..10000";
              }
            }
            leaf cycle-3-on-time {
              tailf:cli-drop-node-name;
              tailf:cli-optional-in-sequence;
              type uint16 {
                tailf:info "<50-10000>;;Third On cadence";
                range "50..10000";
              }
            }
            leaf cycle-3-off-time {
              tailf:cli-drop-node-name;
              tailf:cli-optional-in-sequence;
              type uint16 {
                tailf:info "<50-10000>;;Third Off cadence";
                range "50..10000";
              }
            }
            leaf cycle-4-on-time {
              tailf:cli-drop-node-name;
              tailf:cli-optional-in-sequence;
              type uint16 {
                tailf:info "<50-10000>;;Fourth On cadence";
                range "50..10000";
              }
            }
            leaf cycle-4-off-time {
              tailf:cli-drop-node-name;
              tailf:cli-optional-in-sequence;
              type uint16 {
                tailf:info "<50-10000>;;Fourth Off cadence";
                range "50..10000";
              }
            }
            leaf continuous {
              tailf:info "Configure continuous cadence";
              type empty;
            }
          }
        }
      }

      // voice class e164-pattern-map *
      list e164-pattern-map {
        tailf:info "e164 pattern map";
        tailf:cli-mode-name "config-class";
        key id;
        leaf id {
          type uint16 {
            tailf:info "<1-10000>;;Voice class e164 pattern map tag";
            range "1..10000";
          }
        }

        // voice class e164-pattern-map * / description
        uses description-grouping;

        // voice class e164-pattern-map * / e164 *
        list e164 {
          tailf:info "Set E164 pattern for the map";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Add an E164 into the map";
            }
          }
        }
      }

      // voice class server-group *
      list server-group {
        tailf:info "IP Server Group";
        tailf:cli-mode-name "config-class";
        key id;
        leaf id {
          type uint16 {
            tailf:info "<1-10000>;;Voice class server group tag";
            range "1..10000";
          }
        }

        // voice class server-group * / ipv4 *
        list ipv4 {
          tailf:info "ipv4 address type";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key address;
          leaf address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IPv4 Address";
            }
          }
          leaf preference {
            tailf:info "Preference order of this server in a group";
            type uint8 {
              tailf:info "<0-5>;;Preference order";
              range "0..5";
            }
          }
        }

        // voice class server-group * / description
        uses description-grouping;
      }

      // voice class h323 *
      list h323 {
        tailf:info "H323 Parameters";
        tailf:cli-mode-name "config-class";
        key id;
        leaf id {
          type uint16 {
            tailf:info "<1-10000>;;Voice class H323 ta";
            range "1..10000";
          }
        }

        // voice class h323 * / h225 timeout
        container h225 {
          tailf:info "h225 protocol";
          container timeout {
            tailf:info "timeout control";

            // voice class h323 * / h225 timeout tcp establish
            container tcp {
              tailf:info "tcp transport protocol";
              leaf establish {
                tailf:info "Establishing connection timeout";
                type uint8 {
                  tailf:info "<0-30>;;timeout value in seconds";
                  range "0..30";
                }
              }
            }

            // voice class h323 * / h225 timeout setup
            leaf setup {
              tailf:info "H225 SETUP timeout";
              type uint8 {
                tailf:info "<0-30>;;timeout value in seconds";
                range "0..30";
              }
            }
          }
        }
      }

      // voice class sip-profiles *
      list sip-profiles {
        tailf:info "SIP Profiles";
        tailf:cli-mode-name "config-class";
        key id;
        leaf id {
          type uint16 {
            tailf:info "<1-10000>;;Voice class sip profiles tag";
            range "1..10000";
          }
        }
      }
    }

    // voice iec syslog
    container iec {
      tailf:info "Configure Internal Error Code behavior";
      leaf syslog {
        tailf:info "Enable syslog reporting whenever an IEC is triggered";
        type empty;
      }
    }

    // voice register
    container register {
      tailf:info "voice register commands";

      // voice register global
      container global {
        tailf:info "Define global commands";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-register-global";
        presence true;

        // voice register global / mode
        leaf mode {
          tailf:info "Define mode: CME/SRST";
          type enumeration {
            enum cme {
              tailf:info "CME mode";
            }
            enum esrst {
              tailf:info "ESRST mode";
            }
          }
        }

        // voice register global / source-address
        container source-address {
          tailf:info "Define IP address and port for SIP CME";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf address {
            tailf:cli-drop-node-name;
            tailf:cli-diff-delete-before "../../mode";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Define source address";
            }
          }
          leaf port {
            tailf:info "Define tcp port for SIP CME";
            type uint16 {
              tailf:info "<2000-9999>;;Specify the port: 2000 - 9999, default 5060";
              range "2000..9999";
            }
          }
        }

        // voice register global / allow-hash-in-dn
        leaf allow-hash-in-dn {
          tailf:info "Allow the insertion of hash at all places in voice reg dn";
          tailf:cli-boolean-no;
          type boolean;
        }

        // voice register global / timeouts
        container timeouts {
          tailf:info "Define timeout value for sip phone";

          // voice register global / timeouts interdigit
          leaf interdigit {
            tailf:info "Interdigit timeout in seconds";
            type uint8 {
              tailf:info "<2-120>;;seconds";
              range "2..120";
            }
          }
        }

        // voice register global / system message
        container system {
          tailf:info "Define system message";
          leaf message {
            tailf:info "Define system message";
            tailf:cli-multi-value;
            tailf:cli-preformatted;
            tailf:cli-full-command;
            type string {
              tailf:info "LINE;;system message string";
            }
          }
        }

        // voice register global / max-dn
        leaf max-dn {
          tailf:info "Define max number of dn";
          type uint16 {
            tailf:info "<1-1000>;;Maximum directory numbers supported";
            range "1..1000";
          }
        }

        // voice register global / max-pool
        leaf max-pool {
          tailf:info "Define max number of pool";
          type uint16 {
            tailf:info "<1-730>;;Maximum pools to support";
            range "1..730";
          }
        }

        // voice register global / tftp-path
        leaf tftp-path {
          tailf:info "Define tftp path for SIP CME";
          tailf:cli-diff-delete-before "../mode";
          type string {
            tailf:info "WORD;;path in url format, choices are:";
          }
        }
      }

      // voice register pool *
      list pool {
        tailf:info "Define pool tag ";
        tailf:cli-mode-name "config-register-pool";
        key tag;
        leaf tag {
          tailf:cli-diff-dependency "../../global/mode";
          tailf:cli-diff-dependency "../../global/max-pool";
          tailf:cli-diff-delete-before "../../global";
          type uint16 {
            tailf:info "<1-730>;;voice-register-pool tag";
            range "1..730";
          }
        }

        // voice register pool * / id
        container id {
          tailf:info "define phone or device id";

          // voice register pool * / id network
          container network {
            tailf:info "define phone or device network address";
            container ipv4 {
              tailf:cli-drop-node-name;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              leaf address {
                tailf:cli-drop-node-name;
                tailf:cli-remove-before-change;
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;network address";
                }
              }
              leaf mask {
                tailf:info "define phone or device ip network mask";
                tailf:cli-remove-before-change;
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Subnet mask of the phone or device (0 for don't care)";
                }
              }
            }
            leaf ip6 {
              tailf:cli-drop-node-name;
              tailf:cli-remove-before-change;
              tailf:cli-diff-delete-before "../ipv4";
              type ipv6-prefix {
                tailf:info "X:X:X:X::X/<0-128>;;IPv6 network/mask";
              }
            }
          }
        }

        // voice register pool * / call-forward
        container call-forward {
          tailf:info "Define E.164 telephone number for call forward";

          // voice register pool * / call-forward b2bua
          container b2bua {
            tailf:info "Define call forward for B2BUA (back-to-back user agent)";

            // voice register pool * / call-forward b2bua all
            leaf all {
              tailf:info "forward all calls";
              tailf:cli-full-command;
              type string {
                tailf:info "WORD;;A sequence of digits - representing E.164 number";
              }
            }

            // voice register pool * / call-forward b2bua busy
            leaf busy {
              tailf:info "forward call on busy";
              tailf:cli-full-command;
              type string {
                tailf:info "WORD;;A sequence of digits - representing E.164 number";
              }
            }

            // voice register pool * / call-forward b2bua mailbox
            leaf mailbox {
              tailf:info "mailbox number";
              tailf:cli-full-command;
              type string {
                tailf:info "WORD;;A sequence of digits - representing E.164 number";
              }
            }

            // voice register pool * / call-forward b2bua noan
            container noan {
              tailf:info "forward call on no-answer";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf target-number {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type string {
                  tailf:info "WORD;;A sequence of digits - representing E.164 number";
                }
              }
              leaf timeout {
                tailf:info "Ringing no answer timeout duration";
                type uint16 {
                  tailf:info "<3-60000>;;Ringing no answer timeout duration in seconds";
                  range "3..60000";
                }
              }
            }

            // voice register pool * / call-forward b2bua unreachable
            leaf unreachable {
              tailf:info "unreachable number";
              type string {
                tailf:info "WORD;;A sequence of digits - representing E.164 number";
              }
            }
          }
        }

        // voice register pool * / no vad
        leaf vad {
          tailf:info "Enable vad on dial-peer and phone";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }
      }
    }

    // voice translation-rule *
    list translation-rule {
      tailf:info "Translation Rule configuration commands";
      tailf:cli-mode-name "cfg-translation-rule";
      key tag;
      leaf tag {
        type uint32 {
          tailf:info "<1-2147483647>;;Translation rule tag";
          range "1..2147483647";
        }
      }

      // voice translation-rule * / rule *
      list rule {
        tailf:info "Translation rule";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-incomplete-command;
        key tag;
        leaf tag {
          type uint8 {
            tailf:info "<1-100>;;Translation rule tag";
            range "1..100";
          }
        }
        leaf reject {
          tailf:info "Call block rule";
          tailf:cli-optional-in-sequence;
          type empty;
        }
        leaf matching-pattern {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type string {
            tailf:info "/WORD/;;Matching pattern";
            pattern '[/].*[/]';
          }
        }
        leaf replacement-pattern {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "/WORD/;;Replacement pattern";
            pattern '[/].*[/]';
          }
        }
      }
    }

    // voice translation-profile *
    list translation-profile {
      tailf:info "Translation profile configuration commands";
      tailf:cli-mode-name "cfg-translation-profile";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Translation profile name";
        }
      }

      // voice translation-profile * / translate
      container translate {
        tailf:info "Specify numbers that should be translated";

        // voice translation-profile * / translate calling
        container calling {
          tailf:info "Translation rule for the calling-number";
          leaf tag {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-2147483647>;;Translation rule tag";
              range "1..2147483647";
            }
          }
        }

        // voice translation-profile * / translate redirect-called
        container redirect-called {
          tailf:info "Translation rule for the redirect-number";
          leaf tag {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-2147483647>;;Translation rule tag";
              range "1..2147483647";
            }
          }
        }

        // voice translation-profile * / translate called
        container called {
          tailf:info "Translation rule for the called-number";
          leaf tag {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-2147483647>;;Translation rule tag";
              range "1..2147483647";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// event
  /// ========================================================================

  container event {
    tailf:info "Event related configuration commands";

    // event manager
    container manager {
      tailf:info "Event Manager configuration commands";
      tailf:cli-explicit-exit;

      // event manager environment *
      list environment {
        tailf:info "Set an Embedded Event Manager global environment variable";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of the global environment variable";
          }
        }
        leaf value {
          tailf:cli-drop-node-name;
          tailf:cli-multi-value;
          tailf:cli-preformatted;
          tailf:cli-no-value-on-delete;
          ios:string-multi-transform "environment \\S+ <STRING>";
          type string {
            tailf:info "LINE;;Value of the global environment variable";
          }
        }
      }

      // event manager session cli username
      container session {
        tailf:info "Set Embedded Event Manager session attributes";
        container cli {
          tailf:info "Set Embedded Event Manager session cli attributes";
          leaf username {
            tailf:info "Set username used in Embedded Event Manager cli sessions";
            type string {
              tailf:info "WORD;;username";
            }
          }
        }
      }

      // event manager directory user
      container directory {
        tailf:info "Set Embedded Event Manager directory information";
        container user {
          tailf:info "Set Embedded Event Manager user directory information";

          // event manager directory user policy
          leaf policy {
            tailf:info "Set Embedded Event Manager user policy directory";
            type string {
              tailf:info "WORD;;Path of the Embedded Event Manager user policy directory";
            }
          }

          // event manager directory user repository
          leaf repository {
            tailf:info "Set Embedded Event Manager user policy repository directory";
            type string {
              tailf:info "WORD;;Path of the Embedded Event Manager user policy repository directory";
            }
          }
        }
      }

      // event manager applet *
      list applet {
        tailf:info "Register an Event Manager applet";
        tailf:cli-mode-name "config-applet";
        tailf:cli-exit-command "exit" {
          tailf:info "Exit from Event Manager applet configuration submode";
        }
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of the Event Manager applet";
          }
        }

        // event manager applet * / description
        leaf description {
          tailf:info "Add or modify an applet description";
          tailf:cli-multi-value;
          tailf:cli-preformatted;
          tailf:cli-full-command;
          type string {
            tailf:info "LINE;;description";
          }
        }

        // event manager applet * / authorization
        leaf authorization {
          tailf:info "Specify an authorization type for the applet";
          tailf:cli-hide-in-submode;
          type enumeration {
            enum bypass {
              tailf:info "EEM aaa authorization type bypass";
            }
          }
        }

        // event manager applet * / class
        leaf class {
          tailf:info "Specify a class for the applet";
          tailf:cli-hide-in-submode;
          type string {
            tailf:info "Class A-Z | default - default class";
            pattern "[A-Z]|default";
          }
        }

        // event manager applet * / trap
        leaf trap {
          tailf:info "Generate an SNMP trap when applet is triggered.";
          tailf:cli-hide-in-submode;
          type empty;
        }

        // event manager applet * / event
        container event {
          tailf:info "Add or modify event information";
          uses event-manager-applet-event-grouping;

          // event manager applet * / event tag *
          list tag {
            tailf:info "event tag identifier";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;tag name";
              }
            }
            uses event-manager-applet-event-grouping;
          }
        }

        // event manager applet * / action *
        list action {
          tailf:info "Add or modify an action statement";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-reset-container;
          tailf:cli-incomplete-command;
          ordered-by user;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Label";
            }
          }

          choice action-choice {
            // event manager applet * / action * cli
            container cli {
              tailf:info "Execute a CLI command";
              tailf:cli-compact-syntax;
              leaf command {
                tailf:info "CLI command";
                type string {
                  tailf:info "WORD;;CLI string";
                }
              }
              leaf pattern {
                tailf:info "response pattern";
                type string {
                  tailf:info "WORD;;pattern";
                }
              }
            }

            // event manager applet * / action * regexp
            leaf regexp {
              tailf:info "regular expression match";
              tailf:cli-no-value-on-delete;
              tailf:cli-full-command;
              ios:regex-string;
              type string {
                tailf:info "WORD;;regular expression pattern";
              }
            }

            // event manager applet * / action * string
            leaf string {
              tailf:info "string commands";
              tailf:cli-no-value-on-delete;
              tailf:cli-full-command;
              ios:regex-string;
              type string {
                tailf:info "LINE;;string command line";
              }
            }

            // event manager applet * / action * comment
            leaf comment {
              tailf:info "add comment";
              tailf:cli-no-value-on-delete;
              tailf:cli-full-command;
              ios:regex-string;
              type string {
                tailf:info "LINE;;comment line";
              }
            }

            // event manager applet * / action * wait
            leaf wait {
              tailf:info "Wait for a specified amount of time";
              type uint32 {
                tailf:info "<1-31536000>;;Seconds value";
                range "1..31536000";
              }
            }

            // event manager applet * / action * syslog
            container syslog {
              tailf:info "Log a syslog message";
              tailf:cli-compact-syntax;

              // event manager applet * / action * syslog priority
              leaf priority {
                tailf:info "Priority of syslog message";
                type logging-level-type;
              }

              // event manager applet * / action * syslog msg
              leaf msg {
                tailf:info "Syslog message";
                type string {
                  tailf:info "WORD;;message string";
                }
              }

              // event manager applet * / action * syslog facility
              leaf facility {
                tailf:info "Facility string";
                type string {
                  tailf:info "WORD;;facility string";
                }
              }

              // event manager applet * / action * syslog filter
              leaf filter {
                tailf:info "Filter destination of syslog message";
                type enumeration {
                  enum esm {
                            tailf:info "Filter destination is ESM";
                  }
                }
              }
            }

            // event manager applet * / action * snmp-trap
            container snmp-trap {
              tailf:info "Send an SNMP trap";
              tailf:cli-compact-syntax;
              leaf intdata1 {
                tailf:info "SNMP integer data1";
                type int32 {
                  tailf:info "<-2147483648 - 2147483647>;;SNMP trap integer value1";
                }
              }
              leaf intdata2 {
                tailf:info "SNMP integer data2";
                type int32 {
                  tailf:info "<-2147483648 - 2147483647>;;SNMP trap integer value2";
                }
              }
              leaf strdata {
                tailf:info "SNMP trap string";
                type string {
                  tailf:info "WORD;;SNMP trap string value";
                }
              }
            }

            // event manager applet * / action * puts
            container puts {
              tailf:info "print data to active tty";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf nonewline {
                tailf:info "Do not display newline";
                tailf:cli-optional-in-sequence;
                type empty;
              }
              leaf data {
                tailf:cli-drop-node-name;
                tailf:cli-disallow-value "nonewline";
                type string {
                  tailf:info "WORD;;data";
                }
              }
            }

            // GENERIC DEFAULT
            // event manager applet * / action * ?
            leaf cmd {
              tailf:cli-drop-node-name;
              tailf:cli-multi-value;
              tailf:cli-disallow-value "reg.*";
              //note: tailf:cli-preformatted; - removes "".
              type string {
                tailf:info "Action string within quotes";
              }
            }
          }
        }

        // event manager applet * / trigger
        container trigger {
          tailf:info "Enter applet trigger configuration submode";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-applet-trigger";
          presence true;

          leaf occurs {
            tailf:info "The number of occurrences before raising the event";
            tailf:cli-hide-in-submode;
            type uint32 {
              tailf:info "<1-4294967295>;;Occurs value";
              range "1..4294967295";
            }
          }

          leaf period {
            tailf:info "Number of occurrences must occur within this time period";
            tailf:cli-hide-in-submode;
            type string {
              tailf:info "<0-4294967295>;;Enter seconds[.milliseconds] value";
            }
          }

          leaf period-start {
            tailf:info "Cron entry for period start";
            tailf:cli-hide-in-submode;
            type string {
              tailf:info "WORD;;Cron entry string";
            }
          }

          leaf delay {
            tailf:info "Time to delay raising event after all conditions met";
            tailf:cli-hide-in-submode;
            type string {
              tailf:info "<0-4294967295>;;Enter seconds[.milliseconds] value";
            }
          }

          // event manager applet * / trigger / correlate
          container correlate {
            tailf:info "event correlation statement";
            leaf statement {
              tailf:cli-drop-node-name;
              tailf:cli-multi-value;
              tailf:cli-preformatted;
              tailf:cli-no-value-on-delete;
              tailf:cli-full-command;
              type string {
                tailf:info "WORD;;[and|andnot|or] event <value>|track <1-500>";
              }
            }
          }
        }
      }

      // event manager policy *
      list policy {
        tailf:info "Run a pre-registered policy";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of the Embedded Event Manager policy file";
          }
        }
        leaf type {
          tailf:info "Type of Embedded Event Manager policy";
          type enumeration {
            enum system {
                         tailf:info "Search for a Embedded Event Manager system policy";
            }
            enum user {
                       tailf:info "Search for a Embedded Event Manager user policy";
            }
          }
        }
        leaf authorization {
          tailf:info "Specify an authorization type for the policy";
          type enumeration {
            enum bypass {
                         tailf:info "EEM aaa authorization type bypass";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// disable-eadi
  /// ========================================================================

  leaf disable-eadi {
    tailf:cli-full-command;
    type empty;
  }


  /// ========================================================================
  /// memory-size
  /// ========================================================================

  container memory-size {
    tailf:info "Adjust memory size by percentage";

    // memory-size iomem
    leaf iomem {
      tailf:info "I/O memory";
      type uint8 {
        tailf:info "<5-25>;;percentage of DRAM to use for I/O memory: 5, 10, 15, 20, 25";
        range "5..25" {
          tailf:step 5;
        }
      }
    }
  }


  /// ========================================================================
  /// memory
  /// ========================================================================

  container memory {
    tailf:info "Configure memory management";

    // memory free low-watermark
    container free {
      tailf:info "free memory low water mark";
      container low-watermark {
        tailf:info "low water mark for notifications";

        // memory free low-watermark processor
        leaf processor {
          tailf:info "Processor memory";
          type uint32 {
            tailf:info "<1-3994575>;;low water mark of memory in KB";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// transceiver
  /// ========================================================================

  container transceiver {
    tailf:info "Select from transceiver configuration commands";
    container type {
      tailf:info "type keyword";

      // transceiver type all
      container all {
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-xcvr-type";
        tailf:cli-full-command;

        // transceiver type all / monitoring
        container monitoring {
          tailf:info "Enable/disable monitoring";
          presence true;

          // transceiver type all / monitoring interval
          leaf interval {
            tailf:info "Set interval for monitoring";
            type uint32 {
              tailf:info "<300-600000>;;Time interval for monitoring transceiver in seconds";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// define
  /// ========================================================================

  container define {
    tailf:info "interface range macro definition";

    // define interface-range *
    list interface-range {
      tailf:info "interface-range";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-remove-before-change;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;macro definition";
        }
      }
      leaf interface {
        tailf:cli-drop-node-name;
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        type string {
          tailf:info "WORD;;Interface name";
        }
      }
    }
  }


  /// ========================================================================
  /// alias
  /// ========================================================================

  list alias {
    tailf:info "Create command alias";
    tailf:cli-suppress-mode;
    tailf:cli-delete-when-empty;
    key "mode name";
    leaf mode {
      type string {
        tailf:info "WORD;;Alias mode";
      }
    }
    leaf name {
      type string {
        tailf:info "WORD;;Alias name";
      }
    }
    leaf line {
      tailf:cli-drop-node-name;
      tailf:cli-multi-value;
      tailf:cli-preformatted;
      tailf:cli-no-value-on-delete;
      tailf:cli-full-command;
      type string {
        tailf:info "WORD;;alias line";
      }
    }
  }


  /// ========================================================================
  /// spd
  /// ========================================================================

  container spd {
    // no spd enable
    leaf enable {
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
      default true;
    }

    // spd headroom
    leaf headroom {
      tailf:info "Set the number of priority packets that can be enqueued over limit";
      type uint16 {
        tailf:info "<0-65535>;;packets";
      }
      default 1000;
    }

    // spd extended-headroom
    leaf extended-headroom {
      tailf:info "Set the number of priority packets that can be enqueued overspd headroom";
      type uint16 {
        tailf:info "<0-65535>;;packets";
      }
      default 10;
    }
  }


  /// ========================================================================
  /// audit
  /// ========================================================================

  // audit
  container audit-enable {
    tailf:cli-drop-node-name;
    leaf audit {
      tailf:info "Router Audit";
      type empty;
    }
  }

  // audit X
  container audit {
    tailf:info "Router Audit";

    // audit interval
    leaf interval {
      tailf:info "Audit Interval";
      type uint16 {
        tailf:info "<120-3600>;Seconds";
        range "120..3600";
      }
      default 300;
    }
  }


  /// ========================================================================
  /// cached-show
  /// ========================================================================
  /// Cached output of exec command show

  container cached-show {
    tailf:info "DEPRECATED, use live-status version|inventory";

    // show version
    container version {
      tailf:info "Cached output of 'show version' on device [DEPRECATED]. Use show devices <device> live-status version";
      leaf version {
        type string;
      }
      leaf xe-version {
        type string;
      }
      leaf model {
        type string;
      }
      container license {
        leaf level {
          type string;
        }
        leaf type {
          type string;
        }
      }
    }

    // show inventory
    list inventory {
      tailf:info "Cached output of 'show inventory' on device [DEPRECATED]. Use show devices <device> live-status inventory";
      tailf:cli-suppress-mode;
      key name;
      leaf name {
        tailf:cli-expose-key-name;
        type string;
      }
      leaf sn {
        type string;
      }
    }
  }


  /// ========================================================================
  /// xxyyzztop
  /// ========================================================================

  leaf xxyyzztop {
    tailf:info "Internal state variable, do not modify.";
    tailf:cli-run-template "";
    tailf:cli-show-with-default;
    tailf:ned-ignore-compare-config;
    type uint16;
    default "0";
  }

  // debug trick to fail last in transaction, do not set
  leaf xxyyzzfail {
    type empty;
  }


  /// ========================================================================
  //                          EOF
  /// ========================================================================
}
