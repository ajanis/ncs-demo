// =========================================================================
//                          CISCO-ASA NED
// =========================================================================

module tailf-ned-cisco-asa {
  namespace "http://cisco.com/ned/asa";
  prefix asa;

  import tailf-common {
    prefix tailf;
  }
  import ietf-inet-types {
    prefix inet;
  }
  import cliparser-extensions-v11 {
    prefix cli;
  }


  // =========================================================================
  // REVISION
  // =========================================================================

  revision 2019-07-19 {
    description "6.6.10, see CHANGES";
  }


  // =========================================================================
  // TYPEDEF
  // =========================================================================

  typedef percentage-type {
    type uint8 {
      tailf:info "<1-100>;;Percentage";
      range "1..100";
    }
  }

  // IPv4 prefix (address and mask length) in A.B.C.D/P format
  typedef ipv4-prefix {
    type string {
      pattern
        '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}'
        +  '([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'
        + '/(([0-9])|([1-2][0-9])|(3[0-2]))';
    }
  }

  // IPv6 prefix in standard format
  typedef ipv6-prefix {
    type string {
      pattern '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}'
        + '((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|'
        + '(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\.){3}'
        + '(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))'
        + '(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))';
      pattern '(([^:]+:){6}(([^:]+:[^:]+)|(.*\..*)))|'
        + '((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?)'
        + '(/.+)';
    }
  }

  // Host type, clean
  typedef host-type {
    type union {
      type inet:ip-address {
        tailf:info "";
      }
      type inet:domain-name {
        tailf:info "";
      }
    }
  }

  // ASN IP type
  typedef asn-ip-type {
    type string {
      tailf:info "ASN:nn or IP-address:nn";
      pattern '(([0-9]+)|((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-'
        + '5])\.){3}'
        + '([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]))):[0-9]+';
    }
  }

  // Hour&minute type
  typedef hhmm-type {
    type string {
      tailf:info "hh:mm;;Hour:Minute of the day";
      pattern "([0-1]?[0-9]|2[0-4]):([0-5][0-9])(:[0-5][0-9])?";
    }
  }

  // Hour&minute&second type
  typedef hhmmss-type {
    type string {
      tailf:info "hh:mm:ss;;Hour:Minute:Second of the day";
      pattern "([0-1]?[0-9]|2[0-4]):([0-5][0-9])(:[0-5][0-9])?";
    }
  }

  // Weekday type
  typedef weekday-type {
    type enumeration {
      enum Mon;
      enum Tue;
      enum Wed;
      enum Thu;
      enum Fri;
      enum Sat;
      enum Sun;
    }
  }

  // Month type
  typedef month-type {
    type enumeration {
      enum Jan;
      enum Feb;
      enum Mar;
      enum Apr;
      enum May;
      enum Jun;
      enum Jul;
      enum Aug;
      enum Sep;
      enum Oct;
      enum Nov;
      enum Dec;
    }
  }

  // nameif type
  typedef nameif-type {
    type string {
      tailf:info "WORD;;Interface assigned name (nameif)";
    }
  }

  // secret128 type
  typedef secret128-type {
    type string {
      tailf:info "WORD < 129 char;;Enter an alphanumeric string "
        + "up to 128 characters";
      length "1..128";
    }
  }

  // DSCP type
  typedef dscp-type {
    type union {
      type uint8 {
        tailf:info "<0-63>;;Differentiated services codepoint value";
        range "0..63";
      }
      type enumeration {
        enum af11 {
          tailf:info "Match packets with AF11 dscp (001010)";
          value 10011;
        }
        enum af12 {
          tailf:info "Match packets with AF12 dscp (001100)";
          value 10012;
        }
        enum af13 {
          tailf:info "Match packets with AF13 dscp (001110)";
          value 10013;
        }
        enum af21 {
          tailf:info "Match packets with AF21 dscp (010010)";
          value 10021;
        }
        enum af22 {
          tailf:info "Match packets with AF22 dscp (010100)";
          value 10022;
        }
        enum af23 {
          tailf:info "Match packets with AF23 dscp (010110)";
          value 10023;
        }
        enum af31 {
          tailf:info "Match packets with AF31 dscp (011010)";
          value 10031;
        }
        enum af32 {
          tailf:info "Match packets with AF32 dscp (011100)";
          value 10032;
        }
        enum af33 {
          tailf:info "Match packets with AF33 dscp (011110)";
          value 10033;
        }
        enum af41 {
          tailf:info "Match packets with AF41 dscp (100010)";
          value 10041;
        }
        enum af42 {
          tailf:info "Match packets with AF42 dscp (100100)";
          value 10042;
        }
        enum af43 {
          tailf:info "Match packets with AF43 dscp (100110)";
          value 10043;
        }
        enum cs1 {
          tailf:info "Match packets with CS1(precedence 1) dscp"+
            " (001000)";
          value 10001;
        }
        enum cs2 {
          tailf:info "Match packets with CS2(precedence 2) dscp"+
            " (010000)";
          value 10002;
        }
        enum cs3 {
          tailf:info "Match packets with CS3(precedence 3) dscp"+
            " (011000)";
          value 10003;
        }
        enum cs4 {
          tailf:info "Match packets with CS4(precedence 4) dscp"+
            " (100000)";
          value 10004;
        }
        enum cs5 {
          tailf:info "Match packets with CS5(precedence 5) dscp"+
            " (101000)";
          value 10005;
        }
        enum cs6 {
          tailf:info "Match packets with CS6(precedence 6) dscp"+
            " (110000)";
          value 10006;
        }
        enum cs7 {
          tailf:info "Match packets with CS7(precedence 7) dscp"+
            " (111000)";
          value 10007;
        }
        enum "default" {
          tailf:info "Match packets with default dscp (000000)";
          tailf:code-name "dscp_default";
          value 1000;
        }
        enum dscp {
          tailf:info "Set packet dscp from dscp";
          value 1001;
        }
        enum ef {
          tailf:info "Match packets with EF dscp (101110)";
          value 1002;
        }
        enum precedence {
          tailf:info "Set packet dscp from precedence";
          value 1003;
        }
      }
    }
  }

  // Precedence type
  typedef precedence-type {
    type union {
      type uint8 {
        tailf:info "<0-7>;;Precedence value";
        range "0..7";
      }
      type enumeration {
        enum critical {
          tailf:info "Set packets with critical precedence (5)";
        }
        enum flash {
          tailf:info "Set packets with flash precedence (3)";
        }
        enum flash-override {
          tailf:info "Set packets with flash override precedence (4)";
        }
        enum immediate {
          tailf:info "Set packets with immediate precedence (2)";
        }
        enum internet {
          tailf:code-name "prec_internet";
          tailf:info "Set packets with internetwork control"+
          " precedence (6)";
        }
        enum network {
          tailf:info "Set packets with network control precedence"+
          " (7)";
        }
        enum priority {
          tailf:code-name "prec_priority";
          tailf:info "Set packets with priority precedence (1)";
        }
        enum routine {
          tailf:info "Set packets with routine precedence (0)";
        }
      }
    }
  }

  typedef access-list-in-out-type {
    type enumeration {
      enum in {
        tailf:info "Filter incoming routing updates";
      }
      enum out {
        tailf:info "Filter outgoing routing updates";
      }
    }
  }

  typedef ospf-area-type {
    type union {
      type uint32 {
        tailf:info "<0-4294967295>;;OSPF area ID as a decimal value";
        range "0..4294967295";
      }
      type inet:host {
        tailf:info "A.B.C.D;;OSPF area ID in IP address format";
      }
    }
  }

  typedef ospf-metric-type {
    type uint8 {
      tailf:info "<1-2>;;OSPF Link State type";
      range "1..2";
    }
  }

  typedef logging-level-type {
    type enumeration {
      enum alerts {
        tailf:info "Immediate action needed           (severity=1)";
      }
      enum critical {
        tailf:info "Critical conditions               (severity=2)";
      }
      enum debugging {
        tailf:info "Debugging messages                (severity=7)";
      }
      enum emergencies {
        tailf:info "System is unusable                (severity=0)";
      }
      enum errors {
        tailf:info "Error conditions                  (severity=3)";
      }
      enum informational {
        tailf:info "Informational messages            (severity=6)";
      }
      enum notifications {
        tailf:info "Normal but significant conditions (severity=5)";
      }
      enum warnings {
        tailf:info "Warning conditions                (severity=4)";
      }
    }
  }

  typedef logging-type {
    type union {
      type string {
        tailf:info "WORD;;Specify the name of logging list";
      }
      type logging-level-type;
    }
  }

  typedef bgp-as-no-type {
    type union {
      type uint32 {
        tailf:info "<1-4294967295>;;Autonomous system number";
        range "1..4294967295";
      }
      type string {
        tailf:info "<1.0-XX.YY>;;Autonomous system number";
      }
    }
  }

  typedef eigrp-as-no-type {
    type uint16 {
      tailf:info "<1-65535>;;Autonomous system number";
      range "1..65535";
    }
  }

  typedef attribute-type {
    type enumeration {
      enum "C" {
        tailf:info "Country";
      }
      enum "CN" {
        tailf:info "Common Name";
      }
      enum "DNQ" {
        tailf:info "DN Qualifier";
      }
      enum "EA" {
        tailf:info "Email Address";
      }
      enum "GENQ" {
        tailf:info "Generational Qualifier";
      }
      enum "GN" {
        tailf:info "Given Name";
      }
      enum "I" {
        tailf:info "Initials";
      }
      enum "L" {
        tailf:info "Locality";
      }
      enum "N" {
        tailf:info "Name";
      }
      enum "O" {
        tailf:info "Organization Name";
      }
      enum "OU" {
        tailf:info "Organizational Unit";
      }
      enum "SER" {
        tailf:info "Serial Number";
      }
      enum "SN" {
        tailf:info "Surname";
      }
      enum "SP" {
        tailf:info "State/Province";
      }
      enum "T" {
        tailf:info "Title";
      }
      enum "UID" {
        tailf:info "User ID";
      }
      enum "UPN" {
        tailf:info "User Principal Name";
      }
    }
  }

  typedef tls-version-type {
    type enumeration {
      enum tlsv1 {
        tailf:info "Enter this keyword to accept SSLv2 ClientHellos and negotiate TLSv1 (or greater)";
      }
      enum tlsv1.1 {
        tailf:info "Enter this keyword to accept SSLv2 ClientHellos and negotiate TLSv1.1 (or greater)";
      }
      enum tlsv1.2 {
        tailf:info "Enter this keyword to accept SSLv2 ClientHellos and negotiate TLSv1.2 (or greater)";
      }
    }
  }


  // =========================================================================
  // GROUPING
  // =========================================================================

  // password-08-grouping
  grouping password-08-grouping {
    leaf "type" {
      tailf:cli-drop-node-name;
      tailf:cli-optional-in-sequence;
      tailf:cli-incomplete-command;
      type enumeration {
        enum "0" {
            tailf:info "Specifies an UNENCRYPTED password will follow";
        }
        enum "8" {
          tailf:info "Specifies an ENCRYPTED password will follow";
        }
      }
      default 0;
    }
    leaf secret {
      tailf:cli-drop-node-name;
      tailf:cli-reset-container;
      tailf:cli-disallow-value "0|8";
      type string {
        tailf:info "LINE;;The UNENCRYPTED (cleartext) password/key";
      }
    }
  }

  // passwd
  // enable password
  grouping password-grouping {
    leaf word {
      tailf:cli-drop-node-name;
      type secret128-type;
    }
    leaf level {
      tailf:info "Enter this keyword to specify the privilege level";
      tailf:cli-optional-in-sequence;
      type uint8 {
        tailf:info "<1-15>;;Specify the privilege level (1 - 15)";
      }
    }
    choice encrypt-choice {
      leaf encrypted {
        tailf:info "Indicates that the password specified is encrypted";
        tailf:cli-optional-in-sequence;
        type empty;
      }
      leaf pbkdf2 {
        tailf:info "Indicates that the password specified is hashed using pbkdf2";
        type empty;
      }
    }
  }

  // service resetinbound interface *
  // service resetoutbound interface *
  // ip verify reverse-path interface *
  grouping interface-list-grouping {
    list name {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        type nameif-type;
      }
    }
  }


  // NOTE: For interfaces named with "nameif" leaf.
  grouping interface-name-grouping {
    leaf nameif {
      tailf:cli-drop-node-name;
      tailf:cli-disallow-value "Management|Ethernet|FastEthernet"+
        "|GigabitEthernet|TenGigabitEthernet|Vlan|Port-channel|Redundant|BVI";
      type nameif-type;
    }
  }

  // router rip / distribute-list
  // router ospf * / distribute-list
  // router bgp * / address-family * distribute-list
  // router bgp * / address-family * / neighbor * distribute-list *
  grouping distribute-list-content-grouping {

    // distribute-list <access-list-name> in|out [interface <nameif>]
    leaf access-list-name {
      tailf:cli-drop-node-name;
      tailf:cli-disallow-value "in|out";
      tailf:cli-prefix-key;
      type string {
        tailf:info "WORD;;Access-list name";
      }
    }

    leaf connected {
      tailf:info "Connected";
      tailf:cli-full-command;
      type empty;
    }

    leaf static {
      tailf:info "Static routes";
      tailf:cli-full-command;
      type empty;
    }

    leaf-list ospf {
      tailf:info "Open Shortest Path First (OSPF)";
      tailf:cli-full-command;
      tailf:cli-list-syntax;
      type uint16 {
        tailf:info "<1-65535>;;Process ID";
      }
    }

    leaf rip {
      tailf:info "Routing Information Protocol (RIP)";
      tailf:cli-full-command;
      type empty;
    }

    leaf bgp {
      tailf:info "Border Gateway Protocol (BGP)";
      tailf:cli-full-command;
      type bgp-as-no-type;
    }

    leaf eigrp {
      tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
      tailf:cli-full-command;
      type eigrp-as-no-type;
    }
  }


  // router rip
  // router ospf * / distribute-list
  // router bgp * / address-family *
  // router bgp * / address-family * / neighbor * distribute-list *
  grouping router-distribute-list-grouping {

    container distribute-list-interface {
      tailf:cli-drop-node-name;
      list distribute-list {
        tailf:info "Filter networks in routing updates";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "direction interface";
        leaf direction {
          type enumeration {
            enum "in" {
              tailf:info "Filter incoming routing updates";
            }
            enum "out" {
              tailf:info "Filter outgoing routing updates";
            }
          }
        }
        leaf interface {
          tailf:cli-expose-key-name;
          tailf:info "Interface on which to apply distribute-list";
          tailf:cli-diff-dependency "/asa:interface";
          tailf:cli-diff-dependency "/asa:interface/Management/nameif";
          tailf:cli-diff-dependency "/asa:interface/Ethernet/nameif";
          tailf:cli-diff-dependency "/asa:interface/FastEthernet/nameif";
          tailf:cli-diff-dependency "/asa:interface/GigabitEthernet/nameif";
          tailf:cli-diff-dependency "/asa:interface/TenGigabitEthernet/nameif";
          tailf:cli-diff-dependency "/asa:interface/Vlan/nameif";
          tailf:cli-diff-dependency "/asa:interface/Port-channel/nameif";
          tailf:cli-diff-dependency "/asa:interface/Port-channel-subif/Port-channel/nameif";
          tailf:cli-diff-dependency "/asa:interface/BVI/nameif";
          tailf:cli-diff-dependency "/asa:interface/Redundant/nameif";
          tailf:cli-diff-dependency "/asa:interface/allocated/nameif";
          type nameif-type;
        }
        uses distribute-list-content-grouping;
      }
    }

    list distribute-list {
      tailf:info "Filter networks in routing updates";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key direction;
      leaf direction {
        type enumeration {
          enum "in" {
            tailf:info "Filter incoming routing updates";
          }
          enum "out" {
            tailf:info "Filter outgoing routing updates";
          }
        }
      }
      uses distribute-list-content-grouping;
    }
  }


  // router rip
  // router ospf *
  grouping passive-interface-grouping {

    // router rip * / passive-interface
    container passive-interface {
      tailf:info "Suppress routing updates on an interface";
      tailf:cli-delete-when-empty;
      choice passive-interface-choice {

        // router rip * / passive-interface default
        leaf "default" {
          tailf:info "Suppress routing updates on all interfaces";
          type empty;
        }

        // router rip * / passive-interface *
        list interface {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            tailf:cli-disallow-value "default";
            type string {
              tailf:info "WORD;;Interface name";
            }
          }
        }
      }
    }

    // Fix to handle showing "no passive-interface <interface name>"
    // when passive-interface default is configured
    // this is filtered out in the NED java code
    container disable {
      when "../passive-interface/default";
      tailf:cli-diff-dependency "../passive-interface/default";
      list passive-interface {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key interface;
        leaf interface {
          tailf:cli-multi-word-key;
          type nameif-type;
        }
      }
    }
  }


  grouping ip-community-list-standard-grouping {
    container deny {
      tailf:info "Specify community to reject";
      presence true;
      list deny-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key expr;
        leaf expr {
          tailf:cli-multi-word-key {
            tailf:cli-max-words 10;
          }
          type string {
            tailf:info "<1-4294967295>  community number
            aa:nn           community number
            internet        Internet (well-known community)
            local-AS        Do not send outside local AS (well-known community)
            no-advertise    Do not advertise to any peer (well-known community)
            no-export       Do not export to next AS (well-known community)
            ";
            pattern '((internet)|(local\-AS)|(no\-advertise)|'
              +'(no\-export)|(\d+:\d+)|(\d+))'
              +'( (internet)|(local\-AS)|'
              +'(no\-advertise)|(no\-export)|(\d+:\d+)|(\d+))*';
          }
        }
      }
    }

    container permit {
      tailf:info "Specify community to accept";
      presence "Specify community to accept";
      list permit-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key expr;
        leaf expr {
          tailf:cli-multi-word-key {
            tailf:cli-max-words 10;
          }
          type string {
            tailf:info "<1-4294967295>  community number
            aa:nn           community number
            internet        Internet (well-known community)
            local-AS        Do not send outside local AS (well-known community)
            no-advertise    Do not advertise to any peer (well-known community)
            no-export       Do not export to next AS (well-known community)
            ";
            pattern '((internet)|(local-AS)|(no-advertise)|'
              +'(no-export)|(\d+:\d+)|(\d+))( (internet)|'
              +'(local-AS)|(no-advertise)|(no-export)|'
              +'(\d+:\d+)|(\d+))*';
          }
        }
      }
    }
  }


  // grouping interface-common-grouping0
  grouping interface-common-grouping0 {

    // interface * / description
    leaf description {
      tailf:info "Interface specific description";
      tailf:cli-multi-value;
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;Up to 200 characters describing this interface";
        length "0..200";
      }
    }

    // interface * / management-only
    leaf management-only {
      tailf:info "Dedicate an interface to management. Block thru traffic";
      type empty;
    }

    // interface * / authentication
    container authentication {
      tailf:info "authentication subcommands";

      //  key   Authentication key-string

      // interface * / authentication mode eigrp
      container mode {
        tailf:info "mode";
        container eigrp {
          tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf process-id {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<1-65535>;;Process ID";
              range "1..65535";
            }
          }
          leaf md5 {
            tailf:info "Keyed message digest";
            type empty;
          }
        }
      }
    }

    // interface * / mac-address
    container mac-address {
      tailf:info "Assign MAC address to interface";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf active {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "H.H.H;;MAC address";
        }
      }
      leaf standby {
        tailf:info "Configure standby MAC address";
        type string {
          tailf:info "H.H.H;;MAC address";
        }
      }
    }

    // interface * / ip address
    container ip {
      tailf:info "Interface Internet Protocol config commands";
      container address {
        tailf:info "Configure the ip address and mask for an interface";
        choice address-choice {

          // interface * / ip address <address>
          container ip {
            tailf:cli-drop-node-name;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf host-ip {
              tailf:cli-drop-node-name;
              tailf:cli-disallow-value "(dhcp)|(ppoe)";
              type string {
                tailf:info "Hostname or A.B.C.D;;Firewall's network "
                  +"interface address";
              }
            }
            leaf netmask {
              tailf:cli-drop-node-name;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Netmask of ip address";
              }
            }
            choice ip-choice {
              leaf standby {
                tailf:info "Configure standby ip address after this keyword";
                type inet:host;
              }
              container pppoe {
                tailf:info "Keyword to use PPPoE to poll for information. "
                  +"Enables the PPPoE client feature on the specified "
                  +"interface";
                presence true;
                leaf setroute {
                  tailf:info "Keyword to set the default route using the "
                    +"default gateway parameter the PPPoE server returns";
                  type empty;
                }
              }
            }
          }

          // interface * / ip address dhcp
          container dhcp {
            tailf:info "Keyword to use DHCP to poll for information. Enables "
              +"the DHCP client feature on the specified interface";
            presence true;
            leaf setroute {
              tailf:info "Keyword to set the default route using the default "
                +"gateway parameter the DHCP server returns";
              type empty;
            }
          }

          // interface * / ip address pppoe
          container pppoe {
            tailf:info "Keyword to use PPPoE to poll for information. Enables "
              +"the PPPoE client feature on the specified interface";
            presence true;
            leaf setroute {
              tailf:info "Keyword to set the default route using the default "
                +"gateway parameter the PPPoE server returns";
              type empty;
            }
          }
        }
      }
    }

    // interface * / ipv6
    container ipv6 {
      tailf:info "IPv6 interface subcommands";

      // interface * / ipv6 enable
      leaf enable {
        tailf:info "Enable IPv6 on interface";
        type empty;
      }

      // interface * / ipv6 address
      container address {
        tailf:info "Configure IPv6 address on interface";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf address {
          tailf:cli-drop-node-name;
          type union {
            type inet:ip-address;
            type string;
          }
        }
        leaf standby {
          tailf:info "Configure standby IPv6 prefix";
          tailf:cli-optional-in-sequence;
          type inet:host {
            tailf:info "Hostname or X:X:X:X::X;;Standby IPv6 prefix";
          }
        }
        leaf autoconfig {
          tailf:info "Obtain address using autoconfiguration";
          type empty;
        }
      }

      // interface * / ipv6 nd suppress-ra
      container nd {
        tailf:info "IPv6 interface Neighbor Discovery subcommands";
        leaf suppress-ra {
          tailf:info "Suppress IPv6 Router Advertisements";
          type empty;
        }
      }
    }

    // interface * / vlan
    leaf vlan {
      tailf:info "Set VLAN ID";
      type uint16 {
        tailf:info "<1-4094>;;VLAN ID";
        range "1..4094";
      }
    }

    // interface * / nameif
    // Note: device still shows: 'no nameif'
    leaf nameif {
      tailf:info "Assign name to interface";
      //tailf:cli-show-no;
      type string {
        tailf:info "WORD < 49 char;;A name by which this interface will be "
          +"referred in all other commands";
        length "1..49";
      }
    }

    // interface * / shutdown
    leaf shutdown {
      tailf:info "Shutdown the selected interface";
      tailf:cli-full-command;
      tailf:cli-show-no;
      type empty;
    }

    // interface * / bridge-group
    leaf bridge-group {
      tailf:cli-full-command;
      type uint8 {
        range "1..100";
      }
    }

    // interface * / security-level
    // Note: device still shows: 'no security-level'
    leaf security-level {
      tailf:info "Specify the security level of this interface";
      //tailf:cli-show-no;
      type uint8 {
        tailf:info "<0-100>;;Security level for the interface";
        range "0..100";
      }
    }

    // interface * / ospf
    container ospf {
      tailf:info "OSPF interface commands";

      // interface * / ospf priority
      leaf priority {
        tailf:info "Router priority";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<0-255>;;Priority";
        }
        default 1;
      }

      // interface * / ospf network point-to-point non-broadcast
      container network {
        tailf:info "Network type";
        container point-to-point {
          tailf:info "Specify OSPF point-to-point network";
          leaf non-broadcast {
            tailf:info "Specify non-broadcast point-to-point network";
            type empty;
          }
        }
      }

      // interface * / ospf message-digest-key *
      list message-digest-key {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          type uint8 {
            tailf:info "<1-255>;;Key ID";
            range "1..255";
          }
        }
        container md5 {
          tailf:info "Use MD5 algorithm";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          uses password-08-grouping {
            refine "secret" {
              tailf:meta-data "secret" {
                tailf:meta-value " md5 <SECRET>";
              }
            }
          }
        }
      }

      // interface * / ospf authentication
      container authentication {
        tailf:info "Enable authentication";
        tailf:cli-delete-when-empty;
        presence true;
        leaf "type" {
          tailf:cli-drop-node-name;
          type enumeration {
            enum message-digest {
              tailf:info "Use message-digest authentication";
            }
            enum null {
              tailf:info "Use no authentication";
            }
          }
        }
      }

      // interface * / ospf cost
      leaf cost {
        tailf:info "Interface cost";
        type uint16 {
          tailf:info "<1-65535>;;Cost";
        }
      }

    }

    // interface * / policy-route route-map
    container policy-route {
      tailf:info "Enable policy based routing";
      leaf route-map {
        tailf:info "Keyword for route-map";
        type string {
          tailf:info "WORD < 58 char;;Name of route-map";
        }
      }
    }

    // interface * / zone-member
    container zone-member {
      tailf:info "Associate interface to a zone";
      leaf name {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "WORD;;Zone Name";
        }
      }
    }
  }
  grouping interface-common-grouping {
    uses interface-common-grouping0 {
      refine "policy-route/route-map" {
        tailf:cli-diff-dependency "../../../../route-map";
      }
      refine "zone-member/name" {
        tailf:cli-diff-dependency "../../../../zone/zone-list";
      }
    }
  }
  grouping sub-interface-common-grouping {
    uses interface-common-grouping0 {
      refine "policy-route/route-map" {
        tailf:cli-diff-dependency "../../../../../route-map";
      }
      refine "zone-member/name" {
        tailf:cli-diff-dependency "../../../../../zone/zone-list";
      }
    }
  }

  // interface-ethernet-grouping
  grouping interface-ethernet-grouping {

    // interface * / speed
    leaf speed {
      tailf:info "Configure speed operation";
      tailf:cli-diff-dependency "../duplex";
      type enumeration {
        enum "10" {
          tailf:info "Force 10 Mbps operation";
        }
        enum "100" {
          tailf:info "Force 100 Mbps operation";
        }
        enum "1000" {
          tailf:info "Force 1000 Mbps operation";
        }
        enum "auto" {
          tailf:info "Enable AUTO speed configuration";
        }
        enum "nonegotiate" {
          //FIXME
        }
      }
      default auto;
    }

    // interface * / duplex
    leaf duplex {
      tailf:info "Configure duplex operation";
      tailf:cli-full-command;
      type enumeration {
        enum auto {
          tailf:info "Enable AUTO duplex configuration";
        }
        enum full {
          tailf:info "Force full duplex operation";
        }
        enum half {
          tailf:info "Force half-duplex operation";
        }
      }
      default auto;
    }

    // interface * / channel-group
    container channel-group {
      tailf:info "Add this interface to an Etherchannel group";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf number {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint16 {
          tailf:info "<1-48>;;Channel group number";
          range "1..48";
        }
      }
      leaf mode {
        tailf:info "Etherchannel Mode of the interface";
        type enumeration {
          enum active {
            tailf:info "Enable LACP unconditionally";
          }
          enum on {
            tailf:info "Enable Etherchannel only";
          }
          enum passive {
            tailf:info "Enable LACP only if a LACP device is detected";
          }
        }
      }
    }

    // interface * / pppoe client
    container pppoe {
      tailf:info "Configure parameters for PPPoE client";
      container client {
        tailf:info "PPPoE client configuration";

        // interface * / pppoe client route
        container route {
          tailf:info "Options for routes installed by pppoe";
          leaf distance {
            tailf:info "Administrative distance for pppoe routes";
            type uint8 {
              tailf:info "<1-255>;;Administrative distance";
              range "1..255";
            }
            default 1;
          }
          leaf track {
            tailf:info "Track pppoe routes";
            type uint16 {
              tailf:info "<1-500>;;Tracked object number";
              range "1..500";
            }
          }
        }

        // interface * / pppoe client secondary
        container secondary {
          tailf:info "Options for backup pppoe interfaces";
          leaf track {
            tailf:info "Track pppoe routes";
            type uint16 {
              tailf:info "<1-500>;;Tracked object number";
              range "1..500";
            }
          }
        }

        // interface * / pppoe client vpdn
        container vpdn {
          tailf:info "Configure VPDN parameters";
          leaf group {
            tailf:info "Specify VPDN group name";
            type string {
              tailf:info "WORD;;Specify the name of the group";
            }
          }
        }
      }
    }

    // interface * / lacp
    container lacp {
      tailf:info "LACP interface subcommands";

      // interface * / lacp system-priority
      leaf system-priority {
        tailf:info "LACP priority for the system";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<1-65535>;;Priority value";
          range "1..65535";
        }
      }

      // interface * / lacp max-bundle
      leaf max-bundle {
        //fixme: info
        tailf:cli-full-command;
        type uint8 {
          //fixme: info
          range "1..16";
        }
      }
    }
  }

  // grouping interface-switch-grouping
  grouping interface-switch-grouping {

    // interface * / switchport
    container switchport {
      tailf:info "Set switching mode characteristics";
      tailf:cli-display-separated;
      presence true;

      // interface * / switchport access
      container access {
        tailf:info "Set access mode characteristics of the interface";
        leaf vlan {
          tailf:info "Set VLAN when interface is in access mode";
          type uint16 {
            tailf:info "<1-4094>;;VLAN ID of the VLAN when this port "+
              "is in access mode";
            range "1..4094";
          }
          //FIXME: tailf:cli-diff-dependency "/asas:vlan/vlan-list/id";
        }
      }

      // interface * / switchport trunk
      container trunk {
        tailf:info "Set trunking characteristics of the interface";

        // interface * / switchport trunk native
        container native {
          tailf:info "Set trunking native characteristics when interface "+
            "is in trunking mode";
          leaf vlan {
            tailf:info "Set native VLAN when interface is in trunking mode";
            type uint16 {
              tailf:info "<1-4094>;;VLAN ID of the native VLAN when "
                +"this port is in trunking mode";
              range "1..4094";
            }
          }
        }

        // interface * / switchport trunk allowed vlans
        container allowed {
          tailf:info "Set allowed VLAN characteristics when interface "+
            "is in trunking mode";
          leaf-list vlans {
            tailf:info "Set allowed VLANs when interface is in trunking mode";
            tailf:cli-replace-all;
            tailf:cli-range-list-syntax;
            type uint16 {
              tailf:info "WORD;;VLAN IDs of the allowed VLANs "
                +"when this port is in trunking mode";
            }
          }
        }
      }

      // interface * / switchport mode
      container mode {
        tailf:info "Set trunking mode of the interface";
        choice mode-choice {

          // interface * / switchport mode access
          container access {
            tailf:info "Set trunking mode to ACCESS unconditionally";
            presence "true";
          }

          // interface * / switchport mode trunk
          container trunk {
            tailf:info "Set trunking mode to TRUNK unconditionally";
            tailf:cli-diff-dependency "../../trunk";
            presence "true";
          }
        }
      }

      // interface * / switchport protected
      leaf protected {
        tailf:info "Configure an interface to be a protected port";
        type empty;
      }
    }
  }

  grouping redistribute-ospf-match-grouping {

    leaf match {
      tailf:info "Redistribution of OSPF routes";
      tailf:cli-incomplete-command;
      type empty;
    }

    leaf internal {
      when "../match";
      tailf:info "Redistribute OSPF internal routes";
      type empty;
    }

    container external-1 {
      when "../match";
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      leaf external {
        tailf:info "Redistribute OSPF external routes";
        type enumeration {
          enum "1" {
            tailf:info "Redistribute external type 1 routes";
          }
        }
      }
    }

    container external-2 {
      when "../match";
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      leaf external {
        tailf:info "Redistribute OSPF external routes";
        type enumeration {
          enum "2" {
            tailf:info "Redistribute external type 2 routes";
          }
        }
      }
    }

    container nssa-external-1 {
      when "../match";
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      leaf nssa-external {
        tailf:info "Redistribute OSPF NSSA external routes";
        type enumeration {
          enum "1" {
            tailf:info "Redistribute NSSA external type 1 routes";
          }
        }
      }
    }

    container nssa-external-2 {
      when "../match";
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      leaf nssa-external {
        tailf:info "Redistribute OSPF NSSA external routes";
        type enumeration {
          enum "2" {
            tailf:info "Redistribute NSSA external type 2 routes";
          }
        }
      }
    }
  }

  // router rip / redistribute connected
  // router rip / redistribute rip
  grouping router-rip-redistribute-grouping {

    // router rip / redistribute * metric
    leaf metric {
      tailf:info "Metric for redistributed routes";
      type union {
        type uint8 {
          tailf:info "<0-16>;;Default metric";
          range "0..16";
        }
        type enumeration {
          enum transparent {
            tailf:info "Transparently redistribute metric";
          }
        }
      }
    }

    // router rip / redistribute * route-map
    leaf route-map {
      tailf:info "Route map reference";
      tailf:non-strict-leafref {
        path "../../../../../route-map/name";
      }
      type string {
        tailf:info "WORD;;Pointer to route-map entries";
      }
    }
  }


  // router * / redistribute * route-map
  grouping router-route-map-grouping5 {
    leaf route-map {
      tailf:info "Route map reference";
      tailf:non-strict-leafref {
        path "../../../../../route-map/name";
      }
      type string {
        tailf:info "WORD;;Pointer to route-map entries";
      }
    }
  }

  grouping router-route-map-grouping6 {
    leaf route-map {
      tailf:info "Route map reference";
      tailf:non-strict-leafref {
        path "../../../../../../route-map/name";
      }
      type string {
        tailf:info "WORD;;Pointer to route-map entries";
      }
    }
  }

  // router ospf * / redistribute *
  grouping router-ospf-redistribute-grouping {

    // router ospf * / redistribute * metric
    leaf metric {
      tailf:info "Metric for redistributed routes";
      type uint32 {
        tailf:info "<0-16777214>;;OSPF default metric";
        range "0..16777214";
      }
    }

    // router ospf * / redistribute * metric-type
    leaf metric-type {
      tailf:info "OSPF/IS-IS exterior metric type "
        +"for redistributed routes";
      type enumeration {
        enum "1" {
          tailf:info "Set OSPF External Type 1 metrics";
        }
        enum "2" {
          tailf:info "Set OSPF External Type 2 metrics";
        }
      }
      default "2";
    }

    // router ospf * / redistribute * nssa-only
    leaf nssa-only {
      tailf:info "Limit redistributed routes to NSSA areas";
      type empty;
    }

    // router ospf * / redistribute * tag
    leaf tag {
      tailf:info "Set tag for routes redistributed into OSPF";
      type uint32 {
        tailf:info "<0-4294967295>;;32-bit tag value";
      }
    }

    // router ospf * / redistribute * subnets
    leaf subnets {
      tailf:info "Consider subnets for redistribution into OSPF";
      type empty;
    }
  }

  // router bgp * / address-family * / neighbor *
  grouping router-bgp-neighbor-grouping {

    // router bgp * / address-family * / neighbor * remote-as
    leaf remote-as {
      tailf:info "Specify a BGP neighbor";
      tailf:cli-delete-container-on-delete;
      tailf:cli-full-command;
      type string {
        tailf:info "AS of remote neighbor";
      }
    }

    // router bgp * / address-family * / neighbor * local-as
    container local-as {
      tailf:info "Specify a local-as number";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-delete-when-empty;
      tailf:cli-diff-dependency "../remote-as";
      presence true;
      leaf as-no {
        tailf:cli-drop-node-name;
        type bgp-as-no-type;
      }
      leaf no-prepend {
        tailf:info "Do not prepend local-as to updates from ebgp peers";
        type empty;
      }
      leaf replace-as {
        tailf:info "Replace real AS with local AS in the EBGP updates";
        type empty;
      }
      leaf dual-as {
        tailf:info "Accept either real AS or local AS from the ebgp peer";
        type empty;
      }
    }

    // router bgp * / address-family * / neighbor * ha-mode
    container ha-mode {
      tailf:info "high availability mode";

      container graceful-restart {
        tailf:info "graceful-restart for this peer";
        tailf:cli-delete-when-empty;
        presence true;

        leaf disable {
          tailf:info "disable graceful-restart";
          type empty;
        }
      }
    }

    // router bgp * / address-family * / neighbor * description
    leaf description {
      tailf:info "Neighbor specific description";
      tailf:cli-multi-value;
      tailf:cli-full-command;
      tailf:cli-diff-dependency "../remote-as";
      type string {
        tailf:info "LINE;;Up to 80 characters describing this neighbor";
      }
    }

    // router bgp * / address-family * / neighbor * shutdown
    leaf shutdown {
      tailf:info "Administratively shut down this neighbor";
      tailf:cli-full-command;
      tailf:cli-diff-dependency "../remote-as";
      type empty;
    }

    // router bgp * / address-family * / neighbor * ebgp-multihop
    leaf ebgp-multihop {
      tailf:info "Allow EBGP neighbors not on directly connected networks";
      tailf:cli-diff-dependency "../remote-as";
      type uint8 {
        tailf:info "<1-255>;;maximum hop count";
        range "1..255";
      }
      default 1;
    }

    // router bgp * / address-family * / neighbor * transport
    container transport {
      tailf:info "Transport options";
      tailf:cli-diff-dependency "../remote-as";

      // router bgp * / address-family * / neighbor * transport connection-mode
      leaf connection-mode {
        tailf:info "Specify passive or active connection";
        type enumeration {
          enum active {
            tailf:info "Actively establish the TCP session";
          }
          enum passive {
            tailf:info "Passively establish the TCP session";
          }
        }
      }
    }

    // router bgp * / address-family * / neighbor * password
    container password {
      tailf:info "Set a password";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-diff-dependency "../remote-as";
      leaf enctype {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        tailf:cli-incomplete-command;
        type uint8 {
          tailf:info "<0-7>;;Encryption type (0 to disable "
            +"encryption, 7 for proprietary)";
          range "0..7";
        }
        default "0";
      }
      leaf text {
        tailf:cli-drop-node-name;
        tailf:cli-reset-container;
        tailf:cli-multi-value; //??
        tailf:cli-full-command;
        tailf:cli-disallow-value "0|1|2|3|4|5|6|7";
        type secret128-type;  // Hidden only, not encrypted
      }
    }

    // router bgp * / address-family * / neighbor * ttl-security hops
    container ttl-security {
      tailf:info "BGP ttl security check";
      tailf:cli-diff-dependency "../remote-as";
      leaf hops {
        tailf:info "IP hops";
        type uint8 {
          tailf:info "<1-254>;;maximum number of hops";
          range "1..254";
        }
      }
    }

    // router bgp * / address-family * / neighbor * version
    leaf version {
      tailf:info "Set the BGP version to match a neighbor";
      tailf:cli-diff-dependency "../remote-as";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<4-4>;;Neighbor's BGP version";
        range "4";
      }
    }

    // router bgp * / address-family * / neighbor * timers
    container timers {
      tailf:info "BGP per neighbor timers";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-diff-dependency "../remote-as";
      leaf keepalive-interval {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint16 {
          tailf:info "<0-65535>;;Keepalive interval";
          range "0..65535";
        }
      }
      leaf holdtime {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<0-65535>;;Holdtime";
          range "0..65535";
        }
      }
      leaf minimum-neighbor-hold {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<0-65535>;;Minimum hold time from neighbor";
          range "0..65535";
        }
      }
    }

    // router bgp * / address-family * / neighbor * disable-connected-check
    leaf disable-connected-check {
      tailf:info "One-hop away EBGP peer using loopback address";
      tailf:cli-full-command;
      tailf:cli-diff-dependency "../remote-as";
      type empty;
    }

    // router bgp * / address-family * / neighbor * activate
    leaf activate {
      tailf:info "Enable the Address Family for this Neighbor";
      tailf:cli-full-command;
      tailf:cli-diff-dependency "../remote-as";
      type empty;
    }

    // router bgp * / address-family * / neighbor * send-community
    container send-community {
      tailf:info "Send Community attribute to this neighbor";
      tailf:cli-diff-dependency "../remote-as";
      presence true;
    }

    // router bgp * / address-family * / neighbor * advertise-map
    container advertise-map {
      tailf:info "Set condition to advertise attribute";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-diff-dependency "../remote-as";
      leaf name {
        tailf:cli-drop-node-name;
        tailf:non-strict-leafref {
          path "../../../../../../../../route-map/name";
        }
        type string {
          tailf:info "WORD;;advertise route-map name";
        }
      }
      leaf exist-map {
        tailf:info "Routemap which specifies exist condition";
        tailf:non-strict-leafref {
          path "../../../../../../../../route-map/name";
        }
        type string {
          tailf:info "WORD;;condition route-map name";
        }
      }
    }

    // router bgp * / address-family * / neighbor * next-hop-self
    leaf next-hop-self {
      tailf:info "Disable the next hop calculation for this neighbor";
      tailf:cli-full-command;
      tailf:cli-diff-dependency "../remote-as";
      type empty;
    }

    // router bgp * / address-family * / neighbor * default-originate
    container default-originate {
      tailf:info "Originate default route to this neighbour";
      tailf:cli-delete-when-empty;
      tailf:cli-diff-dependency "../remote-as";
      presence true;
      leaf route-map {
        tailf:info "Route-map to specify criteria to originate default";
        tailf:non-strict-leafref {
          path "../../../../../../../../route-map/name";
        }
        type string {
          tailf:info "WORD;;route-map name";
        }
      }
    }

    // router bgp * / address-family * / neighbor * advertisement-interval
    leaf advertisement-interval {
      tailf:info "Minimum interval between sending BGP routing updates";
      tailf:cli-full-command;
      tailf:cli-diff-dependency "../remote-as";
      type uint16 {
        tailf:info "<0-600>;;time in seconds";
        range "0..600";
      }
      default 0;
    }

    // router bgp * / address-family * / neighbor * distribute-list *
    uses router-distribute-list-grouping {
      refine "distribute-list-interface/distribute-list/access-list-name" {
        tailf:cli-diff-dependency "../../../../../../../../../access-list/access-list-id";
      }
      refine "distribute-list/access-list-name" {
        tailf:cli-diff-dependency "../../../../../../../../access-list/access-list-id";
      }
      refine distribute-list-interface {
        tailf:cli-diff-dependency "../remote-as";
      }
      refine distribute-list {
        tailf:cli-diff-dependency "../remote-as";
      }
    }

    // router bgp * / address-family * / neighbor * route-map *
    list route-map {
      tailf:info "Apply route map to neighbor";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-diff-dependency "../remote-as";
      key direction;
      leaf direction {
        type enumeration {
          enum in {
            tailf:info "Apply map to incoming routes";
          }
          enum out {
            tailf:info "Apply map to outbound routes";
          }
        }
      }
      leaf route-map-name {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        tailf:non-strict-leafref {
          path "../../../../../../../../route-map/name";
        }
        type string {
          tailf:info "WORD;;Name of route map";
        }
        mandatory true;
      }
    }

    // router bgp * / address-family * / neighbor * maximum-prefix
    container maximum-prefix {
      tailf:info "Maximum number of prefixes accepted from this peer";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      tailf:cli-diff-dependency "../remote-as";
      leaf max-prefix-no {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<1-2147483647>;;maximum no. of prefix limit";
          range "1..2147483647";
        }
      }
      leaf threshold {
        tailf:cli-drop-node-name;
        tailf:cli-break-sequence-commands;
        type uint8 {
          tailf:info "<1-100>;;Threshold value (%) at which to "
            +"generate a warning msg";
          range "1..100";
        }
      }
      leaf restart {
        tailf:cli-full-command;
        tailf:info "Restart bgp connection after limit is exceeded";
        type uint16 {
          tailf:info "<1-65535>;;Restart interval in minutes";
          range "1..65535";
        }
      }
      leaf warning-only {
        tailf:cli-full-command;
        tailf:info "Only give warning message when limit is exceeded";
        type empty;
      }
    }

    // router bgp * / address-family * / neighbor * filter-list *
    list filter-list {
      tailf:info "Establish BGP filters";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-diff-dependency "../remote-as";
      key direction;
      leaf direction {
        type enumeration {
          enum in {
            tailf:info "Filter incoming routes";
          }
          enum out {
            tailf:info "Filter outgoing routes";
          }
        }
      }
      leaf as-path-list {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        type uint16 {
          tailf:info "<1-500>;;AS path access list";
          range "1..500";
        }
      }
    }

    // router bgp * / address-family * / neighbor * weight
    leaf weight {
      tailf:info "Set default weight for routes from this neighbor";
      tailf:cli-full-command;
      tailf:cli-diff-dependency "../remote-as";
      type uint16 {
        tailf:info "<0-65535>;;default weight";
        range "0..65535";
      }
      default 0;
    }

    // router bgp * / address-family * / neighbor * prefix-list *
    list prefix-list {
      tailf:info "Filter updates to/from this neighbor";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-diff-dependency "../remote-as";
      key direction;
      leaf direction {
        type enumeration {
          enum in {
            tailf:info "Filter incoming updates";
          }
          enum out {
            tailf:info "Filter outgoing updates";
          }
        }
      }
      leaf prefix-list-name {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        tailf:non-strict-leafref {
          path "../../../../../../../../prefix-list/prefixes/name";
        }
        type string {
          tailf:info "WORD;;Name of a prefix list";
        }
      }
    }

    // router bgp * / address-family * / neighbor * remove-private-as
    leaf remove-private-as {
      tailf:info "Remove private AS number from outbound updates";
      tailf:cli-full-command;
      tailf:cli-diff-dependency "../remote-as";
      type empty;
    }
  }

  // router bgp * /
  grouping router-bgp-max-path-grouping {

    // router bgp * / maximum-paths
    container paths {
      tailf:cli-drop-node-name;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf number-of-paths {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<1-16>;;Number of paths";
          range "1..16";
        }
        default "1";
      }
      leaf "import" {
        tailf:info "Maximum import paths";
        type uint16 {
          tailf:info "<1-16>;;Number of import paths";
          range "1..16";
        }
      }
    }
  }

  // router-bgp-redistribute-grouping
  grouping router-bgp-redistribute-grouping {
    leaf metric {
      tailf:info "Metric for redistributed routes";
      type uint32 {
        tailf:info "<0-4294967295>;;Default metric";
        range "0..4294967295";
      }
    }
    leaf route-map {
      tailf:info "Route map reference";
      tailf:non-strict-leafref {
        path "../../../../../../../../route-map/name";
      }
      type string {
        tailf:info "WORD;;Pointer to route-map entries";
      }
    }
  }

  // router bgp * / address-family ipv4 unicast
  // router bgp * / address-family ipv6 unicast
  grouping router-bgp-af-grouping {

    // router bgp * / address-family * / bgp
    container bgp {
      tailf:info "BGP specific commands";

      // router bgp * / address-family * / bgp scan-time
      leaf scan-time {
        tailf:info "Configure background scanner interval";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<5-60>;;Scanner interval (seconds)";
          range "5..60";
        }
      }

      // router bgp * / address-family * / bgp nexthop
      container nexthop {
        tailf:info "Nexthop tracking commands";
        container trigger {
          tailf:info "Nexthop triggering";

          // router bgp * / address-family * / bgp nexthop trigger delay
          leaf delay {
            tailf:cli-full-command;
            tailf:info "Set the delay to tigger nexthop tracking";
            when "not(../enable = 'false')" {
              tailf:dependency "../enable";
            }
            type uint8 {
              tailf:info "<0-100>;;Delay value (seconds)";
              range "0..100";
            }
          }

          // router bgp * / address-family * / no bgp nexthop trigger enable
          leaf enable {
            tailf:info "Enable nexthop tracking";
            tailf:cli-full-command;
            tailf:cli-boolean-no;
            type boolean;
            default true;
          }
        }
      }

      // router bgp * / address-family * / bgp inject-map *
      list inject-map {
        tailf:info "Routemap which specifies prefixes to inject";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          tailf:non-strict-leafref {
            path "../../../../../../../../route-map/name";
          }
          type string {
            tailf:info "WORD;;route-map name";
          }
        }
        leaf exist-map {
          tailf:info "Routemap which specifies exist condition";
          tailf:non-strict-leafref {
            path "../../../../../../../../route-map/name";
          }
          type string {
            tailf:info "WORD;;route-map name";
          }
        }
        leaf copy-attributes {
          tailf:info "Copy attributes from aggregate";
          type empty;
        }
      }

      // router bgp * / address-family * / bgp redistribute-internal
      leaf redistribute-internal {
        tailf:info "Allow redistribution of iBGP into IGPs (dangerous)";
        tailf:cli-full-command;
        type empty;
      }

      // router bgp * / address-family * / bgp suppress-inactive
      leaf suppress-inactive {
        tailf:info "Suppress routes that are not in the routing table";
        tailf:cli-full-command;
        type empty;
      }
    }

    // router bgp * / address-family * / neighbor *
    list neighbor {
      tailf:info "Specify a neighbor router";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      key id;
      leaf id {
        type union {
          type inet:host {
            tailf:info "A.B.C.D;;Neighbor address";
          }
          type inet:ipv6-address {
            tailf:info "X:X:X:X::X;;Neighbor IPv6 address";
          }
        }
      }
      uses router-bgp-neighbor-grouping;
    }

    // router bgp * / address-family * / network
    list network {
      tailf:info "Specify a network to announce via BGP";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      key number;
      leaf number {
        type union {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Network number";
          }
          type ipv6-prefix {
            tailf:info "X:X:X:X::X/<0-128>;;IPv6 prefix";
          }
        }
      }
      leaf backdoor {
        tailf:info "Specify a BGP backdoor route";
        tailf:cli-full-command;
        type empty;
      }
      leaf mask {
        tailf:info "Network mask";
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Network mask";
        }
      }
      leaf route-map {
        tailf:info "Route-map to modify the attributes";
        tailf:non-strict-leafref {
          path "../../../../../../../route-map/name";
        }
        type string {
          tailf:info "WORD;;Name of the route map";
        }
      }
    }

    // router bgp * / address-family * / redistribute
    container redistribute {
      tailf:info "Redistribute information from another routing protocol";

      // router bgp * / address-family * / redistribute bgp
      container bgp {
        tailf:info "Border Gateway Protocol (BGP)";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        leaf as-no {
          tailf:cli-drop-node-name;
          type bgp-as-no-type;
        }
        uses router-bgp-redistribute-grouping {
          refine "metric" {
            tailf:cli-break-sequence-commands;
          }
        }
      }

      // router bgp * / address-family * / redistribute connected
      container connected {
        tailf:info "Connected";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-bgp-redistribute-grouping;
      }

      // router bgp * / address-family * / redistribute static
      container static {
        tailf:info "Static routes";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-bgp-redistribute-grouping;
      }

      // router bgp * / address-family * / redistribute eigrp *
      list eigrp {
        tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key as-no;
        leaf as-no {
          type eigrp-as-no-type;
        }
        uses router-bgp-redistribute-grouping;
      }

      // router bgp * / address-family * / redistribute ospf *
      list ospf {
        tailf:info "Open Shortest Path First (OSPF)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          type uint16 {
            tailf:info "<1-65535>;;Process ID";
            range "1..65535";
          }
        }
        uses router-bgp-redistribute-grouping;
        uses redistribute-ospf-match-grouping;
      }

      // router bgp * / address-family * / redistribute rip
      container rip {
        tailf:info "Routing Information Protocol (RIP)";
        tailf:cli-compact-syntax;
        presence true;
        uses router-bgp-redistribute-grouping;
      }
    }

    // router bgp * / address-family * / aggregate-address *
    list aggregate-address {
      tailf:info "Configure BGP aggregate entries";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      key "address mask";
      leaf address {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Aggregate address";
        }
      }
      leaf mask {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Aggregate mask";
        }
      }

      // router bgp * / address-family * / aggregate-address * as-set
      leaf as-set {
        tailf:cli-break-sequence-commands;
        tailf:info "Generate AS set path information";
        type empty;
      }

      // router bgp * / address-family * / aggregate-address * summary-only
      leaf summary-only {
        tailf:info "Filter more specific routes from updates";
        type empty;
      }

      // router bgp * / address-family * / aggregate-address * attribute-map
      leaf attribute-map {
        tailf:info "Set attributes of aggregate";
        type string {
          tailf:info "WORD;;Route map for parameter control";
        }
      }

      // router bgp * / address-family * / aggregate-address * advertise-map
      leaf advertise-map {
        tailf:info "Set condition to advertise attribute";
        tailf:non-strict-leafref {
          path "../../../../../../../route-map/name";
        }
        type string {
          tailf:info "WORD;;advertise route-map name";
        }
      }

      // router bgp * / address-family * / aggregate-address * suppress-map
      leaf suppress-map {
        tailf:info "Conditionally filter more specific routes from "
          +"updates";
        type string {
          tailf:info "WORD;;Route map for suppression";
        }
      }
    }

    // router bgp * / address-family * / distance
    container distance {
      tailf:info "Define an administrative distance";

      // router bgp * / address-family * / distance bgp
      container bgp {
        tailf:info "BGP distance";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf extern-as {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<1-255>;;Distance for routes external to the AS";
            range "1..255";
          }
        }
        leaf internal-as {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<1-255>;;Distance for routes internal to the AS";
            range "1..255";
          }
        }
        leaf local {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-255>;;Distance for local routes";
            range "1..255";
          }
        }
      }
    }

    // router bgp * / address-family * / distribute-list *
    uses router-distribute-list-grouping {
      refine "distribute-list-interface/distribute-list/access-list-name" {
        tailf:cli-diff-dependency "../../../../../../../../access-list/access-list-id";
      }
      refine "distribute-list/access-list-name" {
        tailf:cli-diff-dependency "../../../../../../../access-list/access-list-id";
      }
    }

    // router bgp * / address-family * / maximum-paths
    container maximum-paths {
      tailf:info "Forward packets over multiple paths";

      // router bgp * / address-family * / maximum-paths
      uses router-bgp-max-path-grouping;

      // router bgp * / address-family * / maximum-paths ibgp
      container ibgp {
        tailf:info "iBGP-multipath";
        choice ibgp-choice {
          default b;
          case a {
            container unequal-cost {
              tailf:info "Perform Un-Equal cost multipath selection";
              uses router-bgp-max-path-grouping;
            }
          }
          case b {
            uses router-bgp-max-path-grouping;
          }
        }
      }
    }

    // router bgp * / address-family * / table-map
    leaf table-map {
      tailf:info "Map external entry attributes into routing table";
      tailf:cli-full-command;
      tailf:non-strict-leafref {
        path "../../../../../../route-map/name";
      }
      type string {
        tailf:info "WORD;;route-map name";
      }
    }

    // router bgp * / address-family * / default-information
    container default-information {
      tailf:info "Control distribution of default information";
      leaf originate {
        tailf:info "Distribute a default route";
        type empty;
      }
    }

    // router bgp * / address-family * / auto-summary
    // router bgp * / address-family * / no auto-summary
    leaf auto-summary {
      // Cisco doc node: Disabled by default
      tailf:info "Enable automatic network number summarization";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
    }

    // router bgp * / address-family * / synchronization
    // router bgp * / address-family * / no synchronization
    leaf synchronization {
      tailf:info "Perform IGP synchronization";
      tailf:cli-full-command;
      tailf:cli-show-no;
      type empty;
    }
  }

  // router bgp *
  grouping router-bgp-grouping {

    // router bgp * / bgp
    container bgp {

      // router bgp * / bgp log-neighbor-changes
      // router bgp * / no bgp log-neighbor-changes
      leaf log-neighbor-changes {
        tailf:info "Log neighbor up/down and reset reason";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
      }

      // router bgp * / bgp always-compare-med
      leaf always-compare-med {
        tailf:info "Allow comparing MED from different neighbors";
        tailf:cli-full-command;
        type empty;
      }

      // router bgp * / bgp asnotation dot

      // router bgp * / bgp bestpath
      container bestpath {
        tailf:info "Change the default bestpath selection";

        // router bgp * / bgp bestpath compare-routerid
        leaf compare-routerid {
          tailf:info "Compare router-id for identical EBGP paths";
          tailf:cli-full-command;
          type empty;
        }

        // router bgp * / bgp bestpath med
        container med {
          tailf:info "MED attribute";
          choice med-choice {
            container confed {
              tailf:info "Compare MED among confederation paths";
              presence "Compare MED among confederation paths";
              leaf missing-at-worst {
                tailf:info "Treat missing MED as the least "
                  +"preferred one";
                type empty;
              }
            }
            leaf missing-at-worst {
              tailf:info "Treat missing MED as the least "
                +"preferred one";
              type empty;
            }
          }
        }
      }

      // router bgp * / bgp default
      container "default" {
        tailf:info "Configure BGP defaults";

        // router bgp * / no bgp default ipv4-unicast
        leaf ipv4-unicast {
          tailf:info "Activate ipv4-unicast for a peer by default";
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }

        // router bgp * / no bgp default ipv4-activate
        leaf ipv4-activate {
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }

        // router bgp * / bgp default local-preference
        leaf local-preference {
          tailf:info "local preference (higher=more preferred)";
          type uint32 {
            tailf:info "<0-4294967295>;;Configure default "
              +"local preference value";
            range "1..4294967295";
          }
        }

        // no bgp default route-target filter
        container route-target {
          tailf:info "Control behavior based on Route-Target attributes";
          leaf filter {
            tailf:info "Control automatic VPN Route-Target filtering";
            tailf:cli-boolean-no;
            type boolean;
            default true;
          }
        }
      }

      // router bgp * / bgp deterministic-med
      leaf deterministic-med {
        tailf:info "Pick the best-MED path among paths advertised from "
          +"the neighboring AS";
        tailf:cli-full-command;
        type empty;
      }

      // router bgp * / bgp graceful-restart
      container graceful-restart {
        tailf:info "Graceful restart capability parameters";
        tailf:cli-display-separated;
        tailf:cli-delete-when-empty;
        presence true;
        leaf restart-time {
          tailf:cli-full-command;
          tailf:info "Set the max time needed to restart and come back up";
          type uint16 {
            tailf:info "<1-3600>;;Delay value (seconds)";
            range "1..3600";
          }
        }
        leaf stalepath-time {
          tailf:info "Set the max time to hold onto restarting "
            +"peer's stale paths";
          type uint16 {
            tailf:info "<1-3600>;;Delay value (seconds)";
            range "1..3600";
          }
        }
      }

      // router bgp * / no bgp enforce-first-as
      leaf enforce-first-as {
        tailf:info "Enforce the first AS for EBGP routes(default)";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // router bgp * / address-family * / no bgp fast-external-fallover
      leaf fast-external-fallover {
        tailf:info "Immediately reset session if a link to a directly "
          +"connected external peer goes down";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // router bgp * / bgp router-id
      leaf router-id {
        tailf:cli-full-command;
        tailf:info "Override configured router identifier (peers will "
        +"reset)";
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Manually configured router identifier";
        }
      }

      // router bgp * / bgp maxas-limit
      leaf maxas-limit {
        tailf:info "Allow AS-PATH attribute from any neighbor imposing "
        +"a limit on number of ASes";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<1-2000>;;Number of ASes in the AS-PATH attribute";
          range "1..2000";
        }
      }
    }

    // router bgp * / timers bgp
    container timers {
      tailf:info "Adjust routing timers";
      container bgp {
        tailf:info "BGP timers";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf keepalive {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<0-65535>;;Keepalive interval";
            range "0..65535";
          }
        }
        leaf holdtime {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-65535>;;Holdtime";
            range "0..65535";
          }
        }
        leaf min-holdtime {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-65535>;;Minimum hold time from neighbor";
            range "0..65535";
          }
        }
      }
    }
  }

  grouping router-ospf-common-grouping {

    // router ospf * / log-adj-changes detail
    // router ospf * / no log-adj-changes
    container log-adj-changes {
      tailf:info "Log changes in adjacency state";
      tailf:cli-show-no;
      presence true;
      leaf detail {
        tailf:info "Log all state changes";
        type empty;
      }
    }

    // router ospf * / default-information originate
    container default-information {
      tailf:info "Control distribution of default information";
      container originate {
        tailf:info "Distribute a default route";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence true;
        leaf always {
          tailf:info "Always advertise default route";
          type empty;
        }
        leaf metric {
          tailf:info "OSPF default metric";
          type uint32 {
            tailf:info "<0-16777214>;;OSPF metric";
            range "0..16777214";
          }
          default 0;
        }
        leaf metric-type {
          tailf:info "OSPF metric type for default routes";
          type ospf-metric-type;
          default 2;
        }
        leaf route-map {
          tailf:info "Route map reference";
          type string {
            tailf:info "WORD;;Route map name";
          }
        }
      }
    }
  }

  // router ospf *
  grouping router-ospf-grouping {

    // router ospf * / router-id
    leaf router-id {
      tailf:cli-full-command;
      tailf:info "Override configured router identifier (peers will "
      +"reset)";
      type inet:ipv4-address {
        tailf:info "A.B.C.D;;Manually configured router identifier";
      }
    }

    // router ospf * / network *
    list network {
      tailf:info "Enable routing on an IP network";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      key "ip mask";
      leaf ip {
        type inet:host {
          tailf:info "A.B.C.D;;Network number";
        }
      }
      leaf mask {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;OSPF wild card bits";
        }
      }
      leaf area {
        tailf:info "Set the OSPF area ID";
        type ospf-area-type;
      }
    }

    // router ospf * / area
    list area {
      tailf:info "OSPF area parameters";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      key id;
      leaf id {
        tailf:cli-suppress-range;
        type ospf-area-type;
      }

      // router ospf * / area * authentication
      container authentication {
        tailf:info "Enable authentication";
        tailf:cli-delete-when-empty;
        presence true;
        leaf message-digest {
          tailf:info "Use message-digest authentication";
          type empty;
        }
      }

      // router ospf * / area * nssa
      container nssa {
        tailf:info "Specify a NSSA area";
        tailf:cli-compact-syntax;
        presence true;

        // router ospf * / area * nssa no-redistribution
        leaf no-redistribution {
          tailf:info "No redistribution into this NSSA area";
          type empty;
        }

        // router ospf * / area * nssa default-information-originate
        leaf default-information-originate {
          tailf:info "Originate Type 7 default into NSSA area";
          type empty;
        }

        // router ospf * / area * nssa metric-type
        leaf metric-type {
          tailf:info "OSPF metric type for default routes";
          when "../default-information-originate";
          type ospf-metric-type;
          default 2;
        }

        // router ospf * / area * nssa metric
        leaf metric {
          tailf:info "OSPF default metric";
          when "../default-information-originate";
          type int32 {
            tailf:info "<0-16777214>;;OSPF metric";
            range "0..16777214";
          }
        }

        // router ospf * / area * nssa no-summary
        leaf no-summary {
          tailf:info "Do not send summary LSA into NSSA";
          type empty;
        }
      }

      // router ospf * / area * default-cost
      leaf default-cost {
        tailf:info "Set the summary default-cost of a NSSA/stub area";
        tailf:cli-full-command;
        type uint32 {
          tailf:info "<0-16777215;;Stub's advertised external route metric";
          range "0..16777215";
        }
      }

      // router ospf * / area * filter-list *
      list filter-list {
        tailf:info "Filter networks between OSPF areas";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-diff-dependency "../id";
        key direction;
        leaf direction {
          type enumeration {
            enum in {
              tailf:info "Filter networks sent to this area";
            }
            enum out {
              tailf:info "Filter networks sent from this area";
            }
          }
        }
        leaf "prefix" {
          tailf:cli-prefix-key;
          tailf:info "Filter prefixes between OSPF areas";
          tailf:non-strict-leafref {
            path "../../../../../prefix-list/prefixes/name";
          }
          type string {
            tailf:info "WORD;;Name of an IP prefix-list";
          }
        }
      }

      // router ospf * / area * range
      list "range" {
        tailf:info "Summarize routes matching address/mask "
          +"(border routers only)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key "ip mask";
        leaf ip {
          type inet:host {
            tailf:info "A.B.C.D;;IP address to match";
          }
        }
        leaf mask {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP mask for address";
          }
        }
        leaf range-status {
          tailf:cli-drop-node-name;
          type enumeration {
            enum advertise {
              tailf:info "Advertise this range (default)";
            }
            enum not-advertise {
              tailf:info "DoNotAdvertise this range";
            }
          }
          default advertise;
        }
      }

      // router ospf * / area * range
      container range-ipv6 {
        tailf:cli-drop-node-name;
        list "range" {
          tailf:info "Summarize routes matching address/mask"
            +"(border routers only)";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key "prefix";
          leaf "prefix" {
            type ipv6-prefix {
              tailf:info "X:X:X:X::X/<0-128>;;IPv6 prefix to match";
            }
          }
          choice advertise-choice {
            leaf advertise {
              tailf:info "Advertise this range (default)";
              type empty;
            }
            leaf not-advertise {
              tailf:info "DoNotAdvertise this range";
              type empty;
            }
          }
          leaf cost {
            tailf:info "User specified metric for this range";
            type uint32 {
              tailf:info "<0-16777215>;;Advertised metric for this range";
              range "0..16777215";
            }
          }
        }
      }

      // router ospf * / area * stub
      container stub {
        tailf:info "Specify a stub area";
        tailf:cli-delete-when-empty;
        when "not(../nssa)" {
          tailf:dependency "../nssa";
        }
        presence true;
        leaf no-summary {
          tailf:info "Do not send summary LSA into stub area";
          type empty;
        }
      }

      // router ospf * / area * virtual-link *
      list virtual-link {
        tailf:info "Define a virtual link and its parameters";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        when "not(../nssa) and not(../stub)" {
          tailf:dependency "../nssa";
          tailf:dependency "../stub";
        }
        key id;
        leaf id {
          type inet:host {
            tailf:info "A.B.C.D;;ID (IP addr) associated with "
              +"virtual link neighbor";
          }
        }

        // router ospf * / area * virtual-link retransmit-interval
        leaf retransmit-interval {
          tailf:info "LSA retransmit interval";
          type uint16 {
            tailf:info "<1-8192>;;Seconds";
            range "1..8192";
          }
        }

        // router ospf * / area * virtual-link transmit-delay
        leaf transmit-delay {
          tailf:info "LSA transmission delay";
          type uint16 {
            tailf:info "<1-8192>;;Seconds";
            range "1..8192";
          }
          default 1;
        }

        // router ospf * / area * virtual-link hello-interval
        leaf hello-interval {
          tailf:info "Hello packet interval";
          type int32 {
            range "1..8192";
            tailf:info "<1-8192;;Seconds>";
          }
        }

        // router ospf * / area * virtual-link dead-interval
        leaf dead-interval {
          tailf:info "Dead router detection time";
          type uint16 {
            range "1..8192";
            tailf:info "<1-8192;;Seconds>";
          }
        }

        // router ospf * / area * virtual-link authentication
        leaf authentication {
          tailf:info "Set authentication type";
          type empty;
        }

        // router ospf * / area * virtual-link authentication-key
        container authentication-key {
          tailf:info "Set authentication key";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          uses password-08-grouping {
            refine "secret" {
              tailf:meta-data "secret" {
                tailf:meta-value " authentication-key <SECRET>";
              }
            }
          }
        }

        // router ospf * / area * virtual-link message-digest
        leaf message-digest {
          tailf:info "Message-digest authentication";
          type empty;
        }

        // router ospf * / area * virtual-link message-digest-key *
        list message-digest-key {
          tailf:info "Set message digest key";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-incomplete-command;
          key id;
          leaf id {
            tailf:cli-suppress-range;
            type uint8 {
              tailf:info "<1-255>;;Key ID";
              range "1..255";
            }
          }
          // router ospf * / area * virtual-link message-digest-key * md5
          container md5 {
            tailf:info "Use MD5 algorithm";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            uses password-08-grouping {
              refine "secret" {
                tailf:meta-data "secret" {
                  tailf:meta-value " md5 <SECRET>";
                }
              }
            }
          }
        }
      }
    }

    // router ospf * / neighbor *
    list neighbor {
      tailf:info "Specify a neighbor router";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      key ip;
      leaf ip {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Neighbor address";
        }
      }
      container interface {
        tailf:info "Specify interface to reach the neighbor";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        uses interface-name-grouping;
      }
    }

    // router ospf * / nsf
    container nsf {
      tailf:info "Non-stop forwarding";

      // router ospf * / no nsf cisco helper
      container cisco {
        tailf:info "Cisco Non-stop forwarding";
        leaf helper {
          tailf:info "helper support";
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }
      }

      // router ospf * / no nsf ietf helper
      container ietf {
        tailf:info "IETF graceful restart";
        leaf helper {
          tailf:info "helper support";
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }
      }
    }

    // router ospf * / capability
    container capability {
      tailf:info "Enable specific OSPF feature";

      // router ospf * / no capability opaque
      leaf opaque {
        tailf:info "Opaque LSA";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        tailf:cli-diff-dependency "../../nsf/ietf/helper" {
          tailf:cli-trigger-on-set;
          tailf:cli-trigger-on-delete;
        }
        tailf:cli-diff-dependency "../../nsf/cisco/helper" {
          tailf:cli-trigger-on-set;
          tailf:cli-trigger-on-delete;
        }
        type boolean;
        default true;
      }

      // router ospf * / no capability lls
      leaf lls {
        tailf:info "Link-local Signaling (LLS) support";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        tailf:cli-diff-dependency "../../nsf/ietf/helper" {
          tailf:cli-trigger-on-set;
          tailf:cli-trigger-on-delete;
        }
        tailf:cli-diff-dependency "../../nsf/cisco/helper" {
          tailf:cli-trigger-on-set;
          tailf:cli-trigger-on-delete;
        }
        type boolean;
        default true;
      }
    }

    // router ospf * / timers
    container timers {
      tailf:info "Adjust routing timers";

      // router ospf * / timers lsa arrival
      container lsa {
        tailf:info "OSPF LSA timers";
        leaf arrival {
          tailf:info "OSPF LSA arrival timer";
          tailf:cli-no-value-on-delete;
          type uint32 {
            tailf:info "<0-600000>;;The minimum interval in milliseconds "
              +"between accepting the same LSA";
            range "0..600000";
          }
        }
      }

      // router ospf * / timers pacing
      container pacing {
        tailf:info "OSPF pacing timers";
        // router ospf * / timers pacing flood
        leaf flood {
          tailf:info "OSPF flood pacing timer";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<5-100>;;The minimum interval in msec "
              +"to pace limit flooding on interface";
            range "5..100";
          }
        }
        leaf lsa-group {
          tailf:info "OSPF LSA group pacing timer";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<10-1800>;;Interval in sec between group "
              +"of LSA being refreshed or maxaged";
            range "10..1800";
          }
        }
        leaf retransmission {
          tailf:info "OSPF retransmission pacing timer";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<5-200>;;The minimum interval in msec "
              +"between neighbor retransmissions";
            range "5..200";
          }
        }
      }

      // router ospf * / timers throttle
      container throttle {
        tailf:info "OSPF throttle timers";

        // router ospf * / timers throttle lsa
        container lsa {
          tailf:info "OSPF LSA throttle timers";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf start-interval {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<0-600000>;;Delay to generate first occurrence "
                +"of LSA in milliseconds";
              range "0..600000";
            }
          }
          leaf hold-interval {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<0-600000>;;Minimum delay between originating "
                +"the same LSA in milliseconds";
              range "0..600000";
            }
          }
          leaf max-interval {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<0-600000>;;Maximum delay between originating "
                +"the same LSA in milliseconds";
              range "0..600000";
            }
          }
        }

        // router ospf * / timers throttle spf
        container spf {
          tailf:info "OSPF SPF throttle timers";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf spf-start {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<0-600000>;;Delay between receiving a change "
                +"to SPF calculation in milliseconds";
              range "0..600000";
            }
          }
          leaf spf-hold {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<0-600000>;;Delay between first and second "
                +"SPF calculation in milliseconds";
              range "0..600000";
            }
          }
          leaf spf-max-wait {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<0-600000>;;Maximum wait time in milliseconds "
                +"for SPF calculations";
              range "0..600000";
            }
          }
        }
      }
    }

    // router ospf * / distance ospf
    container distance {
      tailf:info "Define an administrative distance";
      container ospf {
        tailf:info "OSPF routes Administrative distance";
        tailf:cli-compact-syntax;
        leaf intra-area {
          tailf:info "Intra-area routes";
          type uint32 {
            tailf:info "<1-255>;;Distance for intra-area routes";
            range "1..255";
          }
        }
        leaf inter-area {
          tailf:info "Inter-area routes";
          type uint32 {
            tailf:info "<1-255>;;Distance for inter-area routes";
            range "1..255";
          }
        }
        leaf external {
          tailf:info "External routes";
          type uint32 {
            tailf:info "<1-255>;;Distance for external routes";
            range "1..255";
          }
        }
      }
    }

    // router ospf * / no compatible rfc1583
    container compatible {
      tailf:info "OSPF compatibility list";
      leaf rfc1583 {
        tailf:info "compatible with RFC 1583";
        tailf:cli-boolean-no;
        type boolean;
        default true;
      }
    }

    // router ospf * / ignore lsa mospf
    container ignore {
      tailf:info "Do not complain about specific event";
      container lsa {
        tailf:info "Do not complain upon receiving "
          +"LSA of the specified type";
        leaf mospf {
          tailf:info "MOSPF Type 6 LSA";
          type empty;
        }
      }
    }

    // router ospf * / redistribute
    container redistribute {
      tailf:info "Redistribute information from another routing protocol";

      // router ospf * / redistribute connected
      container connected {
        tailf:info "Connected";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-ospf-redistribute-grouping;
        uses router-route-map-grouping5;
      }

      // router ospf * / redistribute static
      container static {
        tailf:info "Static routes";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-ospf-redistribute-grouping;
        uses router-route-map-grouping5;
      }

      // router ospf * / redistribute bgp *
      list bgp {
        tailf:info "Border Gateway Protocol (BGP)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        max-elements 1;
        key as-no;
        leaf as-no {
          type bgp-as-no-type;
        }
        uses router-ospf-redistribute-grouping;
        uses router-route-map-grouping5;
      }

      // router ospf * / redistribute ospf *
      list ospf {
        tailf:info "Open Shortest Path First (OSPF)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          tailf:cli-suppress-range;
          type uint16 {
            tailf:info "<1-65535>;;Process ID";
            range "1..65535";
          }
        }
        uses router-ospf-redistribute-grouping;
        uses redistribute-ospf-match-grouping;
        uses router-route-map-grouping5;
      }

      // router ospf * / redistribute eigrp *
      list eigrp {
        tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key as-no;
        leaf as-no {
          type eigrp-as-no-type;
        }
        uses router-ospf-redistribute-grouping;
        uses router-route-map-grouping5;
      }

      // router ospf * / redistribute rip
      container rip {
        tailf:info "Routing Information Protocol (RIP)";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-ospf-redistribute-grouping;
        uses router-route-map-grouping5;

        // router ospf * / redistribute rip *
        list redistribute-list-rip {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;User selected string identifying this process";
            }
          }
          uses router-ospf-redistribute-grouping;
          uses router-route-map-grouping6;
        }
      }
    }

    // router ospf * / summary-address *
    list summary-address {
      tailf:info "Configure IP address summaries";
      tailf:cli-suppress-mode;
      //no, device does not delete: tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key "ip wildcard";
      leaf ip {
        type inet:host {
          tailf:info "A.B.C.D;;IP summary address";
        }
      }
      leaf wildcard {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Summary mask";
        }
      }
      leaf not-advertise {
        tailf:info "Do not advertise when translating OSPF type-7 LSA";
        type empty;
      }
      leaf tag {
        tailf:info "Set tag";
        type uint32 {
          tailf:info "<0-4294967295>;;32-bit tag value";
          range "0..4294967295";
        }
        default 0;
      }
    }

    // router ospf * / distribute-list *
    uses router-distribute-list-grouping {
      refine "distribute-list-interface/distribute-list/access-list-name" {
        tailf:cli-diff-dependency "../../../../../access-list/access-list-id";
      }
      refine "distribute-list/access-list-name" {
        tailf:cli-diff-dependency "../../../../access-list/access-list-id";
      }
    }

    uses router-ospf-common-grouping {
      refine "default-information/originate/route-map" {
        tailf:cli-diff-dependency "../../../../../route-map";
      }
    }
  }

  // router rip
  grouping router-rip-grouping {

    // router rip / network *
    list network {
      tailf:info "Enable routing on an IP network";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key ip;
      leaf ip {
        type inet:host {
          tailf:info "Hostname or A.B.C.D;;Network address";
        }
      }
    }

    // router rip / passive-interface
    uses passive-interface-grouping;

    // router rip / redistribute
    container redistribute {
      tailf:info "Redistribute information from another routing protocol";

      // router rip / redistribute connected
      container connected {
        tailf:info "Connected";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-rip-redistribute-grouping;
      }

      // router rip / redistribute bgp
      container bgp {
        tailf:info "Border Gateway Protocol (BGP)";
        tailf:cli-compact-syntax;
        leaf as-no {
          tailf:cli-drop-node-name;
          type bgp-as-no-type;
        }
        uses router-rip-redistribute-grouping;
      }

      // router rip / redistribute eigrp *
      list eigrp {
        tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key as-no;
        leaf as-no {
          type eigrp-as-no-type;
        }
        uses router-rip-redistribute-grouping;
      }

      // router rip / redistribute ospf *
      list ospf {
        tailf:info "Open Shortest Path First (OSPF)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          tailf:cli-suppress-range;
          type uint16 {
            tailf:info "<1-65535>;;Process ID";
            range "1..65535";
          }
        }
        uses router-rip-redistribute-grouping;
        uses redistribute-ospf-match-grouping;
      }

      // router rip / redistribute static
      container static {
        tailf:info "Static routes";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-rip-redistribute-grouping;
      }

      // router rip / redistribute rip
      container rip {
        tailf:info "Routing Information Protocol (RIP)";
        tailf:cli-compact-syntax;
        presence true;
        uses router-rip-redistribute-grouping;
      }
    }

    // router rip / default-information
    container default-information {
      tailf:info "Control distribution of default information";
      container originate {
        tailf:info "Distribute a default route";
        tailf:cli-delete-when-empty;
        presence true;
        leaf route-map {
          tailf:info "Route-map reference";
          tailf:non-strict-leafref {
            path "../../../../../route-map/name";
          }
          type string {
            tailf:info "WORD;;Route map name";
          }
        }
      }
    }

    // router rip / version
    leaf version {
      tailf:info "Set routing protocol version";
      type uint8 {
        tailf:info "1-2;;rip version 1 or 2";
        range "1..2";
      }
    }

    // router rip / distribute-list *
    uses router-distribute-list-grouping {
      refine "distribute-list-interface/distribute-list/access-list-name" {
        tailf:cli-diff-dependency "../../../../../access-list/access-list-id";
      }
      refine "distribute-list/access-list-name" {
        tailf:cli-diff-dependency "../../../../access-list/access-list-id";
      }
    }

    // router rip / no auto-summary
    leaf auto-summary {
      tailf:info "Enable automatic network number summarization";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
      default true;
    }
  }

  // ip audit attack
  // ip audit info
  // ip audit
  grouping ip-audit-action-grouping {

    container action {
      tailf:info "Specify the actions to be taken for signatures, the "
        +"default action is alarm, when no option is specified, all "
        +"options are disabled";
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      tailf:cli-no-name-on-delete;
      presence true;
      leaf alarm {
        tailf:info "Report to all configured syslog servers that a "
          +"signature match is detected in a packet";
        tailf:cli-no-name-on-delete;
        type empty;
      }
      leaf drop {
        tailf:info "Drop the offending packet";
        tailf:cli-no-name-on-delete;
        type empty;
      }
      leaf reset {
        tailf:info "Drop the offending packet and close the connection if "
          +"active";
        tailf:cli-no-name-on-delete;
        type empty;
      }
    }
  }

  // policy-may * / class / police
  grouping policy-map-class-police-grouping {

    leaf conform-rate {
      tailf:cli-drop-node-name;
      type uint32 {
        tailf:info "<8000-2000000000>;;Bits per second";
        range "8000..2000000000";
      }
    }

    leaf conform-burst {
      tailf:cli-drop-node-name;
      tailf:cli-optional-in-sequence;
      type uint32 {
        tailf:info "<1000-512000000>;;Burst bytes";
        range "1000..512000000";
      }
    }

    leaf conform-action {
      tailf:info "action when rate is less than conform burst";
      type enumeration {
        enum drop {
          tailf:info "drop packet";
        }
        enum transmit {
          tailf:info "transmit packet";
        }
      }
    }

    leaf exceed-action {
      tailf:info "action when rate is within conform and conform "+
        "+ exceed burst";
      type enumeration {
        enum drop {
          tailf:info "drop packet";
        }
        enum transmit {
          tailf:info "transmit packet";
        }
      }
    }
  }

  // aaa-authentication-dot1x-grouping
  grouping aaa-authentication-dot1x-grouping {
    leaf group {
      tailf:info "Use Server-group";
      type union {
        type string {
          tailf:info "Server-group name";
        }
        type enumeration {
          enum radius {
            tailf:info "Use list of all Radius hosts.";
          }
          enum "tacacs+" {
            tailf:info "Use list of all Tacacs+ hosts.";
          }
        }
      }
    }
  }

  grouping aaa-authentication-console-grouping {

    container console {
      tailf:info "Specify this keyword to identify a server group for administrative authentication";
      tailf:cli-compact-syntax;
      leaf server_group {
        tailf:cli-drop-node-name;
        tailf:cli-disallow-value "LOCAL";
        tailf:cli-remove-before-change;
        tailf:code-name "aaa_server_group";
        tailf:non-strict-leafref {
          path "../../../../../aaa-server/name";
        }
        type string {
          tailf:info "WORD;;Name of RADIUS or TACACS+ aaa-server group for administrative authentication";
        }
      }
      leaf LOCAL {
        tailf:info "Predefined server tag for AAA protocol 'local'";
        type empty;
      }
    }
  }

  grouping aaa-accounting-console-grouping {
    container console {
      tailf:info "Specify this keyword to identify a server group for "+
        "administrative access accounting";
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      leaf server_group {
        tailf:cli-drop-node-name;
        tailf:cli-disallow-value "LOCAL";
        tailf:code-name "aaa_server_group";
        tailf:non-strict-leafref {
          path "../../../../../aaa-server/name";
        }
        type string {
          tailf:info "WORD;;Specify the name of TACACS+/RADIUS (only) "+
            "aaa-server group to be used for console enable accounting";
        }
      }
    }
  }

  // snmp-server host * /
  // snmp-server host-group * /
  grouping snmp-server-host-grouping {

    // snmp-server host * poll
    // snmp-server host * trap
    choice trap-or-poll {
      leaf poll {
        tailf:info "Only allow polling from this host";
        tailf:cli-no-name-on-delete;
        tailf:cli-optional-in-sequence;
        type empty;
      }
      leaf trap {
        tailf:info "Only send traps to this host";
        tailf:cli-no-name-on-delete;
        tailf:cli-optional-in-sequence;
        type empty;
      }
    }

    // snmp-server host * community
    container community {
      tailf:info "SNMP community string for this host";
      tailf:cli-optional-in-sequence;
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-no-name-on-delete;
      uses password-08-grouping {
        refine "type" {
          tailf:cli-no-value-on-delete;
        }
        refine "secret" {
          tailf:cli-no-value-on-delete;
          tailf:meta-data "secret" {
            tailf:meta-value " community <SECRET>";
          }
        }
      }
    }

    // snmp-server host * version
    container version {
      tailf:info "SNMP version to use for notification messages";
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      tailf:cli-incomplete-command;
      tailf:cli-no-name-on-delete;
      leaf version {
        tailf:cli-drop-node-name;
        tailf:cli-no-value-on-delete;
        type enumeration {
          enum "1" {
            tailf:info "Use SNMPv1";
          }
          enum "2c" {
            tailf:info "Use SNMPv2c";
          }
          enum "3" {
            tailf:info "Use SNMPv3";
          }
        }
        default 1;
      }
      leaf username {
        tailf:cli-drop-node-name;
        tailf:cli-no-value-on-delete;
        when "../version = '3'";
        tailf:non-strict-leafref {
          path "../../../user/name";
        }
        type string {
          tailf:info "WORD;;SNMP user name";
        }
      }
    }
  }

  grouping cipher-grouping {
    choice level-choice {
      leaf level {
        tailf:cli-drop-node-name;
        type enumeration {
          enum all {
            tailf:info "Specify all ciphers";
          }
          enum low {
            tailf:info "Specify low strength and higher ciphers";
          }
          enum medium {
            tailf:info "Specify medium strength and higher ciphers";
          }
          enum fips {
            tailf:info "Specify only FIPS-compliant ciphers";
          }
          enum high {
            tailf:info "Specify only high-strength ciphers";
          }
        }
        default medium;
      }
      container level-custom {
        tailf:cli-drop-node-name;
        leaf custom {
          tailf:info "Choose a custom cipher configuration string.";
          type string {
            tailf:info "WORD < 480 char;;Custom cipher configuration string.";
            length "1..479";
          }
        }
      }
    }
  }

  grouping object-service-port-grouping {
    leaf operator {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type enumeration {
        enum eq {
          tailf:info "Port equal to operator";
        }
        enum gt {
          tailf:info "Port greater than  operator";
        }
        enum lt {
          tailf:info "Port less than operator";
        }
        enum neq {
          tailf:info "Port not equal to operator";
        }
        enum range {
          tailf:info "Port range operator";
        }
      }
    }
    leaf port {
      tailf:cli-drop-node-name;
      type string {
        tailf:info "WORD|<0-65535>;;Enter port name or number (0 - 65535)";
      }
    }
    leaf max-port {
      tailf:cli-drop-node-name;
      when "../operator = 'range'" {
        tailf:dependency "../operator";
      }
      type string {
        tailf:info "WORD|<0-65535>;;Enter port name or number (0 - 65535)";
      }
    }
  }


  // =========================================================================
  //                        MODEL
  // =========================================================================

  uses config-grouping;
  grouping config-grouping {


  /// =========================================================================
  /// firewall transparent
  /// =========================================================================

  // firewall transparent
  container firewall {
    tailf:info "Switch to router/transparent mode";
    leaf transparent {
      tailf:info "Switch to transparent mode";
      type empty;
    }
  }

  /// ========================================================================
  /// terminal
  /// ========================================================================

  container terminal {
    tailf:info "Set terminal line parameters";

    // terminal width
    leaf width {
      tailf:info "Set terminal width, default is 80 columns";
      type uint16 {
        tailf:info "<40-511>;;Terminal width columns, default is 80";
        range "40..511";
      }
      default 80;
    }
  }


  /// =========================================================================
  /// same-security-traffic
  /// =========================================================================

  container same-security-traffic {
    tailf:info "Enable same security level interfaces to communicate";

    // same-security-traffic permit
    container permit {
      tailf:info "Keyword for enabling this functionality";

      // same-security-traffic permit inter-interface
      leaf inter-interface {
        tailf:info "Permit communication between different interfaces with "
          +"the same security level";
        type empty;
      }

      // same-security-traffic permit intra-interface
      leaf intra-interface {
        tailf:info "Permit communication between peers connected to the same "
          +"interface";
        type empty;
      }
    }
  }


  /// =========================================================================
  /// object-group-search
  /// =========================================================================

  container object-group-search {
    tailf:info "Enables object group search algorithm";

    /// object-group-search access-control
    leaf access-control {
      tailf:info "For access-control domain";
      type empty;
    }
  }


  /// ========================================================================
  /// service
  /// ========================================================================

  container service {
    tailf:info "Modify use of network based services";
    tailf:cli-diff-dependency "../interface";
    tailf:cli-diff-dependency "../interface/Management/nameif";
    tailf:cli-diff-dependency "../interface/Ethernet/nameif";
    tailf:cli-diff-dependency "../interface/FastEthernet/nameif";
    tailf:cli-diff-dependency "../interface/GigabitEthernet/nameif";
    tailf:cli-diff-dependency "../interface/TenGigabitEthernet/nameif";
    tailf:cli-diff-dependency "../interface/Vlan/nameif";
    tailf:cli-diff-dependency "../interface/Port-channel/nameif";
    tailf:cli-diff-dependency "../interface/Port-channel-subif/Port-channel/nameif";
    tailf:cli-diff-dependency "../interface/BVI/nameif";
    tailf:cli-diff-dependency "../interface/Redundant/nameif";
    tailf:cli-diff-dependency "../interface/allocated/nameif";

    // service call-home
    leaf call-home {
      tailf:info "Enable or disable Smart Call-Home";
      tailf:cli-full-command;
      type empty;
    }

    // service internal
    leaf internal {
      tailf:info "Advanced settings (use only under Cisco supervision)";
      tailf:cli-full-command;
      type empty;
    }

    // no service password-recovery
    leaf password-recovery {
      tailf:info "Password recovery configuration";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
      default true;
    }

    // service resetinbound
    container resetinbound {
      tailf:info "Send reset to a denied inbound TCP packet";
      presence true;
      // service resetinbound interface *
      container interface {
        tailf:info "Keyword to specify an interface";
        tailf:cli-diff-dependency "../../../interface";
        tailf:cli-diff-dependency "../../../interface/Management/nameif";
        tailf:cli-diff-dependency "../../../interface/Ethernet/nameif";
        tailf:cli-diff-dependency "../../../interface/FastEthernet/nameif";
        tailf:cli-diff-dependency "../../../interface/GigabitEthernet/nameif";
        tailf:cli-diff-dependency "../../../interface/TenGigabitEthernet/nameif";
        tailf:cli-diff-dependency "../../../interface/Vlan/nameif";
        tailf:cli-diff-dependency "../../../interface/Port-channel/nameif";
        tailf:cli-diff-dependency "../../../interface/Port-channel-subif/Port-channel/nameif";
        tailf:cli-diff-dependency "../../../interface/BVI/nameif";
        tailf:cli-diff-dependency "../../../interface/Redundant/nameif";
        tailf:cli-diff-dependency "../../../interface/allocated/nameif";
        uses interface-list-grouping;
      }
    }

    // service resetoutbound
    container resetoutbound {
      tailf:info "Send reset to a denied outbound TCP packet";
      presence true;
      // service resetoutbound interface no-list *
      // (on device) no service resetoutbound interface *
      container interface {
        tailf:info "Keyword to specify an interface";
        tailf:cli-diff-dependency "../../../interface";
        tailf:cli-diff-dependency "../../../interface/Management/nameif";
        tailf:cli-diff-dependency "../../../interface/Ethernet/nameif";
        tailf:cli-diff-dependency "../../../interface/FastEthernet/nameif";
        tailf:cli-diff-dependency "../../../interface/GigabitEthernet/nameif";
        tailf:cli-diff-dependency "../../../interface/TenGigabitEthernet/nameif";
        tailf:cli-diff-dependency "../../../interface/Vlan/nameif";
        tailf:cli-diff-dependency "../../../interface/Port-channel/nameif";
        tailf:cli-diff-dependency "../../../interface/Port-channel-subif/Port-channel/nameif";
        tailf:cli-diff-dependency "../../../interface/BVI/nameif";
        tailf:cli-diff-dependency "../../../interface/Redundant/nameif";
        tailf:cli-diff-dependency "../../../interface/allocated/nameif";
        list no-list {
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type nameif-type;
          }
        }
      }
    }

    // service resetoutside
    leaf resetoutside {
      tailf:info "Send reset to a denied TCP packet to outside interface";
      type empty;
    }
  }


  /// ========================================================================
  /// hostname
  /// ========================================================================

  leaf hostname {
    tailf:info "Change host name of the system";
    type string {
      tailf:info "WORD < 64 char;;Host name for this system. A hostname "
        +"must start and end with "
        +"a letter or digit and have as interior characters only "
        +"letters, digits, or a hyphen.";
    }
  }


  /// ========================================================================
  /// service-policy
  /// ========================================================================

  // service-policy *
  list service-policy {
    tailf:info "Configure MPF service policy";
    tailf:cli-suppress-mode;
    tailf:cli-delete-when-empty;
    tailf:cli-compact-syntax;
    tailf:cli-sequence-commands;
    tailf:cli-incomplete-command;
    tailf:cli-diff-dependency "../interface";
    tailf:cli-diff-dependency "../interface/Management/nameif";
    tailf:cli-diff-dependency "../interface/Ethernet/nameif";
    tailf:cli-diff-dependency "../interface/FastEthernet/nameif";
    tailf:cli-diff-dependency "../interface/GigabitEthernet/nameif";
    tailf:cli-diff-dependency "../interface/TenGigabitEthernet/nameif";
    tailf:cli-diff-dependency "../interface/Vlan/nameif";
    tailf:cli-diff-dependency "../interface/Port-channel/nameif";
    tailf:cli-diff-dependency "../interface/Port-channel-subif/Port-channel/nameif";
    tailf:cli-diff-dependency "../interface/BVI/nameif";
    tailf:cli-diff-dependency "../interface/Redundant/nameif";
    tailf:cli-diff-dependency "../interface/allocated/nameif";
    key policy-map;
    leaf policy-map {
      tailf:non-strict-leafref {
        path "../../policy-map/name";
      }
      type string {
        tailf:info "WORD;;policy-map name";
      }
    }

    choice service-policy-type {
      leaf global {
        tailf:info "Enter this keyword to specify a global policy";
        type empty;
      }
      container interface {
        tailf:info "Enter this keyword to specify an interface policy";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        uses interface-name-grouping;
      }
    }

    leaf fail-close {
      tailf:info "Enable inspect to fail-close and drop-log IPv6-Ipv6 traffic";
      type empty;
    }
  }


  /// ========================================================================
  /// app-agent
  /// ========================================================================

  // app-agent heartbeat
  container app-agent {
    container heartbeat {
      tailf:info "Configure heartbeat";
      tailf:cli-compact-syntax;

      // app-agent heartbeat interval
      leaf interval {
        tailf:info "Set appagent heartbeat interval";
        type uint16 {
          tailf:info "<300-6000>;;Specify the interval value (300 - 6000) milliseconds. Only multiples of 100";
          range "300..6000" {
            tailf:step 100;
          }
        }
      }

      // app-agent heartbeat retry-count
      leaf retry-count {
        tailf:info "Set appagent heartbeat retry count";
        type uint8 {
          tailf:info "<3-10>;;Specify the retry count value (3 - 10)";
          range "3..10";
        }
      }
    }
  }


  /// ========================================================================
  /// domain-name
  /// ========================================================================

  leaf domain-name {
    tailf:info "Change domain name";
    type string {
      tailf:info "WORD;;Domain names must begin and end with a digit/letter, "
        +"only letters, digits, and hyphen are allowed as internal characters, "
        +"labels are separated by a dot. A maximum of 63 characters is "
        +"allowed.";
    }
  }


  /// ========================================================================
  /// http
  /// ========================================================================

  container http {
    tailf:info "Configure http server and https related commands";
    tailf:cli-diff-dependency "../interface";
    tailf:cli-diff-dependency "../interface/Management/nameif";
    tailf:cli-diff-dependency "../interface/Ethernet/nameif";
    tailf:cli-diff-dependency "../interface/FastEthernet/nameif";
    tailf:cli-diff-dependency "../interface/GigabitEthernet/nameif";
    tailf:cli-diff-dependency "../interface/TenGigabitEthernet/nameif";
    tailf:cli-diff-dependency "../interface/Vlan/nameif";
    tailf:cli-diff-dependency "../interface/Port-channel/nameif";
    tailf:cli-diff-dependency "../interface/Port-channel-subif/Port-channel/nameif";
    tailf:cli-diff-dependency "../interface/BVI/nameif";
    tailf:cli-diff-dependency "../interface/Redundant/nameif";
    tailf:cli-diff-dependency "../interface/allocated/nameif";

    // http server
    container server {
      tailf:info "Enable the http server required to run Device Manager";

      // http server enable
      container enable {
        tailf:info "Enable the http server required to run Device Manager";
        tailf:cli-delete-when-empty;
        presence true;
        leaf listening-port {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-65535>;;The management server's SSL listening port. "
              +"TCP port 443 is the default.";
            range "1..65535";
          }
        }
      }

      // http server session-timeout
      leaf session-timeout {
        tailf:info "Session timeout in minutes (single routed mode only)";
        type uint16 {
          tailf:info "<1-1440>;;Session timeout value "
          +"(single routed mode only)";
          range "1..1440";
        }
      }
    }

    // http *
    list address {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-incomplete-command;
      key ip;
      leaf ip {
        type string {
          tailf:info "A.B.C.D;;The IP address mask of the host and/or "
            +"network OR "
            +"X:X:X:X::X/<0-128>;;IPv6 address/prefix"
            +"authorized to access the HTTP server";
        }
      }

      // http * <mask>
      leaf mask {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        tailf:cli-incomplete-command;
        type inet:ip-address {
          tailf:info "A.B.C.D;;The IP netmask to apply to the IP address";
        }
      }

      container interface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        uses interface-name-grouping;
      }
    }
  }


  /// ========================================================================
  /// password
  /// ========================================================================

  container password {
    tailf:info "Configure password encryption";
    container encryption {
      tailf:info "Configure password encryption";

      // password encryption aes
      leaf aes {
        tailf:info "AES encryption type.";
        type empty;
      }
    }
  }



  /// ========================================================================
  /// passwd
  /// ========================================================================

  container passwd {
    tailf:info "Change Telnet console access password";
    tailf:cli-delete-when-empty;
    tailf:cli-compact-syntax;
    tailf:cli-sequence-commands;
    tailf:cli-reset-container;
    presence true;
    uses password-grouping;
  }


  /// ========================================================================
  /// enable
  /// ========================================================================

  container enable {
    tailf:info "Modify enable password parameters";

    // enable password
    container password {
      tailf:info "Assign the privileged level password (MAX of 25 characters)";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf word {
        tailf:cli-drop-node-name;
        tailf:cli-reset-container;
        tailf:cli-no-value-on-delete;
        tailf:meta-data "secret" {
          tailf:meta-value " password <SECRET>";
        }
        type secret128-type;
      }
      choice encrypt-choice {
        leaf encrypted {
          tailf:info "Indicates that the password specified is encrypted";
          tailf:cli-optional-in-sequence;
          tailf:cli-no-name-on-delete;
          type empty;
        }
        leaf pbkdf2 {
          tailf:info "Indicates that the password specified is hashed using pbkdf2";
          tailf:cli-no-name-on-delete;
          type empty;
        }
      }
    }
  }


  /// ========================================================================
  /// asp
  /// ========================================================================

  // asp rule-engine transactional-commit
  container asp {
    tailf:info "Configure ASP parameters";
    container rule-engine {
      tailf:info "Rule engine configuration commands";
      container transactional-commit {
        tailf:info "Commit rules as a transaction";

        // asp rule-engine transactional-commit access-group
        leaf access-group {
          tailf:info "Apply to access-group commands";
          type empty;
        }

        // asp rule-engine transactional-commit nat
        leaf nat {
          tailf:info "Apply to nat commands";
          type empty;
        }
      }
    }
  }


  /// ========================================================================
  /// xlate
  /// ========================================================================

  // xlate per-session *
  container xlate {
    tailf:info "Configure an xlate option";
    list per-session {
      tailf:info "Configure per-session rule for dynamic PAT";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-show-long-obu-diffs;
      ordered-by "user";
      key rule;
      leaf rule {
        tailf:cli-multi-word-key;
        type string {
          tailf:info "<RULE>;;deny <params> | permit <params>";
          pattern "(permit.*)|(deny.*)";
        }
      }
    }
  }


  /// ========================================================================
  /// mac-address
  /// ========================================================================

  // mac-address auto prefix
  container mac-address {
    tailf:info "MAC address options";
    container auto {
      tailf:info "auto-generate MAC address for context interface";
      leaf prefix {
        tailf:info "define a prefix for auto-generated MAC address";
        type uint16 {
          tailf:info "<0-65535>;;specify a 16-bit MAC address prefix";
        }
      }
    }
  }


  /// ========================================================================
  /// boot
  /// ========================================================================

  container boot {
    tailf:info "Set system boot parameters";

    // boot system
    leaf system {
      tailf:info "system image file";
      tailf:cli-full-command;
      type string {
        tailf:info "WORD;;PATH|URL:filename";
      }
    }

    // boot config
    leaf "config" {
      tailf:info "start-up config file";
      type string {
        tailf:info "WORD;;Path and filename";
      }
    }
  }


  /// ========================================================================
  /// names
  /// ========================================================================

  // names
  // no names
  leaf names {
    tailf:info "Enable/Disable IP address to name mapping";
    tailf:cli-show-no;
    tailf:cli-full-command;
    type empty;
  }


  /// ========================================================================
  /// name
  /// ========================================================================

  // name *
  list name {
    tailf:info "Associate a name with an IP address";
    tailf:cli-suppress-mode;
    tailf:cli-delete-when-empty;
    tailf:cli-compact-syntax;
    tailf:cli-incomplete-command;
    key address;
    leaf address {
      type union {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;The IPv4 address of the host/network "+
            "being named";
        }
        type inet:ipv6-address {
          tailf:info "X:X:X:X::X;;The IPv6 address of the host/network "+
            "being named";
        }
      }
    }
    leaf name {
      tailf:cli-drop-node-name;
      type string {
        tailf:info "WORD < 64 char;;The name for the host/network.";
      }
    }
  }


  /// ========================================================================
  /// time-range
  /// ========================================================================

  // time-range *
  list time-range {
    tailf:info "Define time range entries";
    tailf:cli-mode-name "config-time-range";
    key name;
    leaf name {
      type string {
        tailf:info "WORD < 129 char;;Time range name";
      }
    }
  }


  /// ========================================================================
  /// ftp
  /// ========================================================================

  container ftp {
    tailf:info "Set FTP mode";
    leaf mode {
      tailf:info "FTP mode";
      type enumeration {
        enum "passive" {
          tailf:info "Specify passive mode";
        }
      }
    }
  }


  /// ========================================================================
  /// pager
  /// ========================================================================

  // pager lines
  // no pager lines
  container pager {
    tailf:info "Control page length for pagination";
    leaf lines {
      tailf:info "The number following this keyword determines the number of "+
        "lines in a page before ---more--- prompt appears, default is 24";
      tailf:cli-show-no;
      type uint32 {
        tailf:info "<0-2147483647>;;Pager lines, 0 means no page-limit";
        range "0..2147483647";
      }
      default 0;
    }
  }


  /// ========================================================================
  /// flow-export
  /// ========================================================================

  container flow-export {
    tailf:info "Configure flow information export through NetFlow";

    // flow-export destination *
    list destination {
      tailf:info "Configure a destination to which NetFlow records will be sent";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-incomplete-command;
      key "name host";
      leaf name {
        tailf:cli-suppress-range;
        tailf:cli-diff-dependency "../../../interface";
        tailf:cli-diff-dependency "../../../interface/Management/nameif";
        tailf:cli-diff-dependency "../../../interface/Ethernet/nameif";
        tailf:cli-diff-dependency "../../../interface/FastEthernet/nameif";
        tailf:cli-diff-dependency "../../../interface/GigabitEthernet/nameif";
        tailf:cli-diff-dependency "../../../interface/TenGigabitEthernet/nameif";
        tailf:cli-diff-dependency "../../../interface/Vlan/nameif";
        tailf:cli-diff-dependency "../../../interface/Port-channel/nameif";
        tailf:cli-diff-dependency "../../../interface/Port-channel-subif/Port-channel/nameif";
        tailf:cli-diff-dependency "../../../interface/BVI/nameif";
        tailf:cli-diff-dependency "../../../interface/Redundant/nameif";
        tailf:cli-diff-dependency "../../../interface/allocated/nameif";
        type nameif-type;
      }
      leaf host {
        type inet:host {
          tailf:info "Hostname or A.B.C.D;;Destination IP address or name";
        }
      }
      leaf udp-port {
        tailf:cli-drop-node-name;
        tailf:cli-remove-before-change;
        type uint16 {
          tailf:info "<1-65535>;;UDP port number";
          range "1..65535";
        }
      }
    }

    // flow-export delay flow-create
    container delay {
      tailf:info "Configure delay for exporting NetFlow events";
      leaf flow-create {
        tailf:info "Specify delay after which flow creation event will be exported";
        type uint8 {
          tailf:info "<1-180>;;Delay in seconds";
          range "1..180";
        }
      }
    }

    // flow-export template timeout-rate
    container template {
      tailf:info "Specify the template specific configurations";
      leaf timeout-rate {
        tailf:info "Specify the time before templates are resent";
        type uint16 {
          tailf:info "<1-3600>;;Timeout in minutes (default 30 minutes)";
          range "1..3600";
        }
        default 30;
      }
    }

    // flow-export active refresh-interval
    container active {
      tailf:info "Configure Netflow parameters for active connections";
      leaf refresh-interval {
        tailf:info "Configure time interval between flow update events";
        type uint16 {
          tailf:info "<1-60>;;Number of minutes between flow update events (default 1 minute)";
          range "1..60";
        }
        default 1;
      }
    }
  }


  /// ========================================================================
  /// mtu
  /// ========================================================================

  // mtu *
  list mtu {
    tailf:info "Specify MTU(Maximum Transmission Unit) for an interface";
    tailf:cli-suppress-mode;
    tailf:cli-delete-when-empty;
    tailf:cli-incomplete-command;
    key name;
    leaf name {
      tailf:cli-diff-dependency "../../interface";
      tailf:cli-diff-dependency "../../interface/Management/nameif";
      tailf:cli-diff-dependency "../../interface/Ethernet/nameif";
      tailf:cli-diff-dependency "../../interface/FastEthernet/nameif";
      tailf:cli-diff-dependency "../../interface/GigabitEthernet/nameif";
      tailf:cli-diff-dependency "../../interface/TenGigabitEthernet/nameif";
      tailf:cli-diff-dependency "../../interface/Vlan/nameif";
      tailf:cli-diff-dependency "../../interface/Port-channel/nameif";
      tailf:cli-diff-dependency "../../interface/Port-channel-subif/Port-channel/nameif";
      tailf:cli-diff-dependency "../../interface/BVI/nameif";
      tailf:cli-diff-dependency "../../interface/Redundant/nameif";
      tailf:cli-diff-dependency "../../interface/allocated/nameif";
      type nameif-type;
    }
    leaf mtu-size {
      tailf:cli-drop-node-name;
      type uint16 {
        tailf:info "<64-65535>;;MTU bytes";
        range 64..65535;
      }
    }
  }


  /// ========================================================================
  /// dynamic-access-policy-record
  /// ========================================================================

  // dynamic-access-policy-record *
  list dynamic-access-policy-record {
    tailf:info "Dynamic Access Policy configuration commands";
    tailf:cli-mode-name "config-dynamic-access-policy-record";
    key name;
    leaf name {
      type string {
        tailf:info "WORD < 65 char;;Enter the name of the DAP record."+
          "A minimum of 4 characters is required. "+
          "A maximum of 64 characters is allowed.";
      }
    }

    // dynamic-access-policy-record * / description
    leaf description {
      tailf:info "Enter a quote \"\" delimited description for this policy";
      tailf:cli-full-command;
      type string {
        tailf:info "WORD;;Dynamic Access Policy Description";
      }
    }

    // dynamic-access-policy-record * / user-message
    leaf user-message {
      tailf:info "Enter a quote \"\" delimited user message for this policy";
      tailf:cli-full-command;
      type string {
        tailf:info "WORD < 491 char;;Dynamic Access Policy User Message";
      }
    }

    // dynamic-access-policy-record * / action
    leaf action {
      tailf:info "Enter the action for this policy";
      tailf:cli-full-command;
      type enumeration {
        enum "continue" {
          tailf:info "Specify the action to take is continue for this policy";
        }
        enum "quarantine" {
          tailf:info "Specify the action to take is quarantine for this policy";
        }
        enum "terminate" {
          tailf:info "Specify the action is to terminate for this policy";
        }
      }
      default "continue";
    }

    // dynamic-access-policy-record * / priority
    leaf priority {
      tailf:info "Specify the priority number for this policy";
      tailf:cli-full-command;
      type uint32 {
        tailf:info "<0-2147483647>;;Priority number for this policy";
        range "0..2147483647";
      }
      default 0;
    }
  }


  /// ========================================================================
  /// user-identity
  /// ========================================================================

  container user-identity {
    tailf:info "Configure user-identity firewall";
    leaf default-domain {
      tailf:info "Specify user identity default domain name";
      type string {
        tailf:info "WORD < 33 char;;Enter user identity default domain name";
      }
    }
  }


  /// ========================================================================
  /// threat-detection
  /// ========================================================================

  // threat-detection *
  list threat-detection {
    tailf:info "Show threat detection information";
    tailf:cli-suppress-mode;
    tailf:cli-delete-when-empty;
    tailf:cli-compact-syntax;
    key id;
    leaf id {
      type enumeration {
        enum basic-threat {
          tailf:info "Keyword to enable basic threat detection";
        }
        enum rate {
          tailf:info "Keyword to modify rate parameters for threat detection";
        }
        enum scanning-threat {
          tailf:info "Keyword to enable scanning threat detection";
        }
        enum statistics {
          tailf:info "Keyword to configure statistics of threat detection";
        }
      }
    }

    // threat-detection * host
    container host {
      tailf:info "Keyword to specify IP statistics";
      presence true;
    }

    // threat-detection * access-list
    container access-list {
      tailf:info "Keyword to specify access-list statistics";
      presence true;
    }

    // threat-detection * shun
    container shun {
      tailf:info "Keyword to enable shunning over hosts conducting scanning";
      tailf:cli-compact-syntax;
      presence true;

      // threat-detection * shun except
      container except {
        tailf:info "Keyword to exclude specified hosts from being shunned";

        // threat-detection * shun except ip-address *
        list ip-address {
          tailf:info "Keyword to exclude specified hosts/subnets from being shunned";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key "address mask";
          leaf address {
            type inet:host {
              tailf:info "Hostname or A.B.C.D;;Specify IP address";
            }
          }
          leaf mask {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Specify netmask for IP address";
            }
          }
        }
      }

      // threat-detection * shun duration
      leaf duration {
        tailf:info "Keyword to define the duration to shun the attacker hosts";
        type uint32 {
          tailf:info "<10-2592000>;;Enter shun duration in 10 to 2592000 "+
            "seconds (30 days). default is 3600 seconds";
          range "10..2592000";
        }
      }
    }

    // threat-detection * scanning-threat rate-interval *
    container scanning-threat {
      tailf:info "Keyword to change rate parameters for overall scanning drop.";
      list rate-interval {
        tailf:info "Keyword to assign rate interval for the specified drop type.";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        key seconds;
        leaf seconds {
          type uint32 {
            tailf:info "<600-2592000>;;Enter rate interval time in 600 to 2592000 seconds (30 days)";
            range "600..2592000" {
              tailf:step 60;
            }
          }
        }
        leaf average-rate {
          tailf:info "Keyword to specify average threshold rate to trigger";
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<0-2147483647>;;Enter per second average threshold "+
              "rate in events per second, 0 means always trigger, maximum "+
              "rate setting means never trigger";
            range "0..2147483647";
          }
        }

        leaf burst-rate {
          tailf:info "Keyword to specify burst threshold rate (~1/30 interval) to trigger";
          type uint32 {
            tailf:info "<0-2147483647>;;Enter per second burst threshold rate"+
              " to trigger, 0 means always trigger, maximum rate setting means"+
              " never trigger";
            range "0..2147483647";
          }
        }
      }
    }

    // threat-detection * tcp-intercept
    container tcp-intercept {
      tailf:info "Trace tcp intercept statistics";
      tailf:cli-compact-syntax;

      // threat-detection * tcp-intercept rate-interval
      leaf rate-interval {
        tailf:info "Keyword to configure size of monitoring window";
        tailf:cli-no-value-on-delete;
        tailf:cli-no-name-on-delete;
        type uint16 {
          tailf:info "<1-1440>;;Duration of monitoring window,"+
            "default is 30 mins";
        }
      }

      // threat-detection * tcp-intercept burst-rate
      leaf burst-rate {
        tailf:info "Keyword to configure burst rate threshold for syslog";
        tailf:cli-no-value-on-delete;
        tailf:cli-no-name-on-delete;
        type uint32 {
          tailf:info "<25-2147483647>;;Burst rate threshold for syslog,"+
            "default is 400/s";
          range "25..2147483647";
        }
      }

      // threat-detection * tcp-intercept average-rate
      leaf average-rate {
        tailf:info "Keyword to configure average rate threshold for syslog";
        tailf:cli-no-value-on-delete;
        tailf:cli-no-name-on-delete;
        type uint32 {
          tailf:info "<25-2147483647>;;Average rate threshold for syslog"+
            ", default is 200/s";
          range "25..2147483647";
        }
      }
    }
  }


  /// ========================================================================
  /// telnet
  /// ========================================================================

  container telnet {
    tailf:info "Add telnet access to system console or set idle timeout";
    tailf:cli-diff-dependency "../interface";
    tailf:cli-diff-dependency "../interface/Management/nameif";
    tailf:cli-diff-dependency "../interface/Ethernet/nameif";
    tailf:cli-diff-dependency "../interface/FastEthernet/nameif";
    tailf:cli-diff-dependency "../interface/GigabitEthernet/nameif";
    tailf:cli-diff-dependency "../interface/TenGigabitEthernet/nameif";
    tailf:cli-diff-dependency "../interface/Vlan/nameif";
    tailf:cli-diff-dependency "../interface/Port-channel/nameif";
    tailf:cli-diff-dependency "../interface/Port-channel-subif/Port-channel/nameif";
    tailf:cli-diff-dependency "../interface/BVI/nameif";
    tailf:cli-diff-dependency "../interface/Redundant/nameif";
    tailf:cli-diff-dependency "../interface/allocated/nameif";

    // telnet *
    list allowed-access {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key address;
      leaf address {
        tailf:cli-disallow-value "timeout";
        type union {
          type inet:host {
            tailf:info "Hostname or A.B.C.D;;The IP address of the host "+
              "and/or network authorized to login to the system";
          }
          type ipv6-prefix {
            tailf:info "X:X:X:X::X/<0-128>;;IPv6 address/prefix authorized "+
              "to login to the system";
          }
        }
      }
      leaf mask {
        tailf:cli-drop-node-name;
        type inet:ip-address {
          tailf:info "A.B.C.D;;The IP netmask to apply to the IP address";
        }
      }
      container interface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        uses interface-name-grouping;
      }
    }

    // telnet timeout
    leaf timeout {
      tailf:info "Configure telnet idle timeout";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<1-1440>;;Idle time in minutes after which a telnet "+
          "session will be closed; default is 5 minutes";
        range "1..1440";
      }
    }

  }


  /// ========================================================================
  /// ssh
  /// ========================================================================

  container ssh {
    tailf:info "Configure SSH options";
    tailf:cli-diff-dependency "../interface";
    tailf:cli-diff-dependency "../interface/Management/nameif";
    tailf:cli-diff-dependency "../interface/Ethernet/nameif";
    tailf:cli-diff-dependency "../interface/FastEthernet/nameif";
    tailf:cli-diff-dependency "../interface/GigabitEthernet/nameif";
    tailf:cli-diff-dependency "../interface/TenGigabitEthernet/nameif";
    tailf:cli-diff-dependency "../interface/Vlan/nameif";
    tailf:cli-diff-dependency "../interface/Port-channel/nameif";
    tailf:cli-diff-dependency "../interface/Port-channel-subif/Port-channel/nameif";
    tailf:cli-diff-dependency "../interface/BVI/nameif";
    tailf:cli-diff-dependency "../interface/Redundant/nameif";
    tailf:cli-diff-dependency "../interface/allocated/nameif";

    // ssh key-exchange group
    container key-exchange {
      tailf:info "Configure the Diffie-Hellman key exchange group to use for SSH";
      leaf group {
        tailf:info "Specify the Diffie-Hellman group to use for SSH";
        tailf:cli-no-name-on-delete;
        tailf:cli-no-value-on-delete;
        tailf:ned-default-handling report-all;
        type enumeration {
          enum dh-group1-sha1 {
            tailf:info "Diffie-Hellman group 2";
          }
          enum dh-group14-sha1 {
            tailf:info "Diffie-Hellman group 14";
          }
        }
        default dh-group1-sha1;
      }
    }

    // ssh timeout
    leaf timeout {
      tailf:info "Configure ssh idle timeout";
      tailf:cli-full-command;
      tailf:meta-data "prefer-high" {
        tailf:meta-value "^(?:no )?ssh timeout[ ]+(\\d+) :: 5";
      }
      type uint8 {
        tailf:info "<1-60>;;Idle time in minutes after which a ssh session will be closed";
        range "1..60";
      }
    }

    // ssh scopy enable
    container scopy {
      tailf:info "Secure Copy mode";
      leaf enable {
        tailf:info "Specify Secure Copy enabled, 'no ssh scopy enable' disable Secure Copy";
        type empty;
      }
    }

    // ssh stricthostkeycheck
    leaf stricthostkeycheck {
      tailf:info "Enable SSH Server Authentication";
      type empty;
    }

    // ssh version
    leaf version {
      tailf:info "Specify protocol version to be supported";
      type enumeration {
        enum "1";
        enum "2";
      }
    }

    // ssh cipher
    container cipher {
      tailf:info "Specify ssh cipher parameters";

      // ssh cipher integrity
      container integrity {
        tailf:info "integrity algorithms for ssh";
        uses cipher-grouping;
      }

      // ssh cipher encryption
      container encryption {
        tailf:info "encryption algorithms for ssh";
        choice encryption-choice {
          leaf level {
            tailf:cli-drop-node-name;
            type enumeration {
              enum all {
                tailf:info "Specify all ciphers";
              }
              enum low {
                tailf:info "Specify low strength and higher ciphers";
              }
              enum medium {
                tailf:info "Specify medium strength and higher ciphers";
              }
              enum fips {
                tailf:info "Specify only FIPS-compliant ciphers";
              }
              enum high {
                tailf:info "Specify only high-strength ciphers";
              }
            }
            default medium;
          }
          leaf custom {
            tailf:info "Choose a custom cipher encryption configuration string.";
            type string {
              tailf:info "WORD;;Custom cipher encryption string "
                +"('show ssh ciphers' shows valid ciphers. Colon-delimit multiple ciphers)";
            }
          }
        }
      }
    }

    // ssh *
    list allowed-access {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-incomplete-command;
      key "address mask";
      leaf address {
        tailf:cli-suppress-range;
        tailf:cli-disallow-value "key-exchange|timeout|scopy|stricthostkeycheck|version|cipher";
        type inet:host {
          tailf:info "Hostname or A.B.C.D;;The IP address of the host "+
            "and/or network authorized to login to the system";
        }
      }
      leaf mask {
        tailf:cli-suppress-range;
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;The IP netmask to apply to the IP address";
        }
      }
      container interface {
        tailf:cli-drop-node-name;
        uses interface-name-grouping;
      }
    }

    // ssh *
    list ipv6-access {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-incomplete-command;
      key address;
      leaf address {
        tailf:cli-suppress-range;
        type ipv6-prefix {
          tailf:info "X:X:X:X::X/<0-128>;;IPv6 address/prefix authorized to login to the system";
        }
      }
      container interface {
        tailf:cli-drop-node-name;
        uses interface-name-grouping;
      }
    }
  }


  /// ========================================================================
  /// dhcpd
  /// ========================================================================

  container dhcpd {
    tailf:info "Configure DHCP Server";

    // dhcpd address *
    list address {
      tailf:info "Configure the IP pool address range after this keyword";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-sequence-commands;
      tailf:cli-incomplete-no;
      key interface;
      leaf interface {
        tailf:cli-diff-dependency "../../../interface";
        tailf:cli-diff-dependency "../../../interface/Management/nameif";
        tailf:cli-diff-dependency "../../../interface/Ethernet/nameif";
        tailf:cli-diff-dependency "../../../interface/FastEthernet/nameif";
        tailf:cli-diff-dependency "../../../interface/GigabitEthernet/nameif";
        tailf:cli-diff-dependency "../../../interface/TenGigabitEthernet/nameif";
        tailf:cli-diff-dependency "../../../interface/Vlan/nameif";
        tailf:cli-diff-dependency "../../../interface/Port-channel/nameif";
        tailf:cli-diff-dependency "../../../interface/Port-channel-subif/Port-channel/nameif";
        tailf:cli-diff-dependency "../../../interface/BVI/nameif";
        tailf:cli-diff-dependency "../../../interface/Redundant/nameif";
        tailf:cli-diff-dependency "../../../interface/allocated/nameif";
        type nameif-type;
      }
      leaf ip-address {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        type string {
          tailf:info "WORD;;IP address[es], <ip1>[-<ip2>]";
        }
      }
    }

    // dhcpd lease
    leaf lease {
      tailf:info "Configure the DHCPD lease length after this keyword";
      tailf:cli-full-command;
      type uint32 {
        tailf:info "<300-1048575>;;The length of lease, in seconds, granted "+
          "to DHCP client from the DHCP server, default is 3600";
        range "300..1048575";
      }
      default 3600;
    }

    // dhcpd lease ? interface *
    container dhcpd-interface {
      tailf:cli-drop-node-name;
      list lease {
        tailf:info "Configure the DHCPD lease length after this keyword";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-no;
        key interface;
        leaf interface {
          tailf:cli-expose-key-name;
          tailf:info "Specify interface to which action will apply to";
          tailf:cli-diff-dependency "../../../../interface";
          tailf:cli-diff-dependency "../../../../interface/Management/nameif";
          tailf:cli-diff-dependency "../../../../interface/Ethernet/nameif";
          tailf:cli-diff-dependency "../../../../interface/FastEthernet/nameif";
          tailf:cli-diff-dependency "../../../../interface/GigabitEthernet/nameif";
          tailf:cli-diff-dependency "../../../../interface/TenGigabitEthernet/nameif";
          tailf:cli-diff-dependency "../../../../interface/Vlan/nameif";
          tailf:cli-diff-dependency "../../../../interface/Port-channel/nameif";
          tailf:cli-diff-dependency "../../../../interface/Port-channel-subif/Port-channel/nameif";
          tailf:cli-diff-dependency "../../../../interface/BVI/nameif";
          tailf:cli-diff-dependency "../../../../interface/Redundant/nameif";
          tailf:cli-diff-dependency "../../../../interface/allocated/nameif";
          type nameif-type;
        }
        leaf seconds {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type uint32 {
            tailf:info "<300-1048575>;;The length of lease, in seconds, granted "+
              "to DHCP client from the DHCP server, default is 3600";
            range "300..1048575";
          }
          default 3600;
        }
      }
    }

    // dhcpd enable *
    list enable {
      tailf:info "Enable the DHCP server";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        tailf:cli-diff-dependency "../../../interface";
        tailf:cli-diff-dependency "../../../interface/Management/nameif";
        tailf:cli-diff-dependency "../../../interface/Ethernet/nameif";
        tailf:cli-diff-dependency "../../../interface/FastEthernet/nameif";
        tailf:cli-diff-dependency "../../../interface/GigabitEthernet/nameif";
        tailf:cli-diff-dependency "../../../interface/TenGigabitEthernet/nameif";
        tailf:cli-diff-dependency "../../../interface/Vlan/nameif";
        tailf:cli-diff-dependency "../../../interface/Port-channel/nameif";
        tailf:cli-diff-dependency "../../../interface/Port-channel-subif/Port-channel/nameif";
        tailf:cli-diff-dependency "../../../interface/BVI/nameif";
        tailf:cli-diff-dependency "../../../interface/Redundant/nameif";
        tailf:cli-diff-dependency "../../../interface/allocated/nameif";
        type nameif-type;
      }
    }
  }


  /// ========================================================================
  /// username
  /// ========================================================================

  list username {
    tailf:info "Establish User Name Authentication";
    tailf:cli-suppress-mode;
    tailf:cli-delete-when-empty;
    tailf:cli-compact-syntax;
    key name;
    leaf name {
      type string {
        tailf:info "WORD < 65 char;;Enter the name of the user. A minimum of "
          +"3 characters is required. A maximum of 64 characters is allowed";
        length "3..64";
      }
    }

    choice password-choice {

      // username * password
      container password {
        tailf:info "Specify the password for the user";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf password {
          tailf:cli-drop-node-name;
          tailf:meta-data "secret" {
            tailf:meta-value " password (\\S+(?: (?:pbkdf2|encrypted))?)";
          }
          type secret128-type;
        }
        leaf mode {
          tailf:cli-drop-node-name;
          tailf:cli-optional-in-sequence;
          type enumeration {
            enum encrypted {
              tailf:info "Indicates the <password> entered is encrypted";
            }
            enum mschap {
              tailf:info "The password will be converted to unicode and hashed "
                +"using MD4. User entries must be created this way if they are "
                +"to be authenticated using MSCHAPv1 or MSCHAPv2";
            }
            enum nt-encrypted {
              tailf:info "Indicates the <password> entered has been converted "
                +"to unicode and hashed using MD4, and can be used for MS-CHAP.";
            }
            enum pbkdf2 {
              tailf:info "Indicates that the <password> entered has been salted and hashed using the pbkdf2 key derivation algorithm";
            }
          }
        }
        leaf privilege {
          tailf:info "Enter the privilege level for this user";
          type uint8 {
            tailf:info "<0-15>;;The privilege level for this user";
            range "0..15";
          }
        }
      }

      // username * nopassword
      case nopassword {
        leaf nopassword {
          tailf:info "Indicates that this user has no password";
          type empty;
        }
        leaf privilege {
          tailf:info "Enter the privilege level for this user";
          when "../nopassword";
          type uint8 {
            tailf:info "<0-15>;;The privilege level for this user";
            range "0..15";
          }
        }
      }
    }

    // username * attributes
    container attributes {
      tailf:info "Enter the attributes sub-command mode for the specified user";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-username";
      tailf:cli-diff-dependency "../../username";
      tailf:cli-full-command;

      // username * attributes / service-type
      leaf service-type {
        tailf:info "Select service type for this user.";
        tailf:cli-full-command;
        type enumeration {
          enum admin {
            tailf:info "User is allowed access to the configuration prompt.";
          }
          enum nas-prompt {
            tailf:info "User is allowed access to the exec prompt.";
          }
          enum remote-access {
            tailf:info "User is allowed network access.";
          }
        }
      }

      // username * attributes / vpn-group-policy
      leaf vpn-group-policy {
        tailf:info "Enter name of a group-policy to inherit attributes from";
        tailf:non-strict-leafref {
          path "../../../group-policy/group-policy-internal/name";
        }
        type string {
          tailf:info "WORD;;Name of a group-policy to inherit attributes from";
        }
      }

      // username * attributes / vpn-simultaneous-logins
      leaf vpn-simultaneous-logins {
        tailf:info "Enter maximum number of simultaneous logins allowed";
        type uint32 {
          tailf:info "<0-2147483647>;;Maximum number of simultaneous "+
            "logins allowed";
        }
      }

      // username * attributes / vpn-framed-ip-address
      container vpn-framed-ip-address {
        tailf:info "Enter the IP address and the net mask to be assigned to the client";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf address {
          tailf:cli-drop-node-name;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;The IP address to be assigned to the client";
          }
        }
        leaf mask {
          tailf:cli-drop-node-name;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;The IP net mask to be assigned to the client";
          }
        }
      }

      // username * attributes / ssh authentication publickey
      container ssh {
        tailf:info "Enter ssh specific configurations for this user.";
        container authentication {
          tailf:info "Configure a user to be able to use non-password based authentication for SSH";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf publickey {
            tailf:info "Specifies that SSH-RSA public key authentication can be used";
            tailf:cli-no-name-on-delete;
            tailf:cli-no-value-on-delete;
            tailf:meta-data "secret" {
              tailf:meta-value "ssh authentication publickey <SECRET>";
            }
            type string {
              tailf:info "WORD;;Raw SSH-RSA public key";
            }
          }
          leaf hashed {
            tailf:info "Indicates the <key> entered has been hashed via SHA-256";
            tailf:cli-no-name-on-delete;
            type empty;
          }
        }
      }
    }
  }


  /// ========================================================================
  /// ip
  /// ========================================================================

  container ip {
    tailf:info "Global IP configuration subcommands";
    tailf:cli-diff-dependency "../interface";
    tailf:cli-diff-dependency "../interface/Management/nameif";
    tailf:cli-diff-dependency "../interface/Ethernet/nameif";
    tailf:cli-diff-dependency "../interface/FastEthernet/nameif";
    tailf:cli-diff-dependency "../interface/GigabitEthernet/nameif";
    tailf:cli-diff-dependency "../interface/TenGigabitEthernet/nameif";
    tailf:cli-diff-dependency "../interface/Vlan/nameif";
    tailf:cli-diff-dependency "../interface/Port-channel/nameif";
    tailf:cli-diff-dependency "../interface/Port-channel-subif/Port-channel/nameif";
    tailf:cli-diff-dependency "../interface/BVI/nameif";
    tailf:cli-diff-dependency "../interface/Redundant/nameif";
    tailf:cli-diff-dependency "../interface/allocated/nameif";

    // ip audit
    container audit {
      tailf:info "Configure the Intrusion Detection System";

      // ip audit attack
      container attack {
        tailf:info "Specify the default actions to be taken for attack "
          +"signatures or disable all actions";
        tailf:cli-reset-container;
        presence true;
        uses ip-audit-action-grouping;
      }

      // ip audit info
      container info {
        tailf:info "Specify the default actions to be taken for informational "
          +"signatures or disable all actions";
        tailf:cli-reset-container;
        presence true;
        uses ip-audit-action-grouping;
      }

      // ip audit interface
      container interface {
        tailf:info "Apply an audit specification or policy (via the IP audit "
          +"name command) to an interface";
        tailf:cli-reset-container;
        presence true;
        uses ip-audit-action-grouping;
      }

      // ip audit name
      container name {
        tailf:info "Specify informational signatures, except those disabled or "
          +"excluded by the IP audit signature command, as part of the policy "
          +"signature  Specify which messages to display, attach a global "
          +"policy to a signature, and disable or exclude a signature from "
          +"auditing";
        tailf:cli-reset-container;
        presence true;
        uses ip-audit-action-grouping;
      }
    }

    // ip local pool *
    container local {
      tailf:info "Define a local pool of IP addresses";
      list pool {
        tailf:info "Keyword to define a pool of addresses";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          type string {
            tailf:info "WORD < 64 char;;Name of the local address pool";
            length "1..64";
          }
        }
        leaf address {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;Specify an IP address or a range of IP "
              +"addresses:start[-end]";
          }
        }
        leaf mask {
          tailf:info "Specify the netmask of the subnet that IP addresses "
            +"belong to";
          type string {
            tailf:info "WORD;;Enter the netmask";
          }
        }
      }
    }

    // ip verify reverse-path interface *
    container verify {
      tailf:info "Configure Unicast Reverse Path Filtering on an interface";
      container reverse-path {
        tailf:info "Keyword to indicate Reverse-Path Filtering";
        container interface {
          tailf:info "Keyword to apply RPF on an interface";
          tailf:cli-diff-dependency "../../../../interface";
          tailf:cli-diff-dependency "../../../../interface/Management/nameif";
          tailf:cli-diff-dependency "../../../../interface/Ethernet/nameif";
          tailf:cli-diff-dependency "../../../../interface/FastEthernet/nameif";
          tailf:cli-diff-dependency "../../../../interface/GigabitEthernet/nameif";
          tailf:cli-diff-dependency "../../../../interface/TenGigabitEthernet/nameif";
          tailf:cli-diff-dependency "../../../../interface/Vlan/nameif";
          tailf:cli-diff-dependency "../../../../interface/Port-channel/nameif";
          tailf:cli-diff-dependency "../../../../interface/Port-channel-subif/Port-channel/nameif";
          tailf:cli-diff-dependency "../../../../interface/BVI/nameif";
          tailf:cli-diff-dependency "../../../../interface/Redundant/nameif";
          tailf:cli-diff-dependency "../../../../interface/allocated/nameif";
          uses interface-list-grouping;
        }
      }
    }
  }


  /// ========================================================================
  /// ipv6
  /// ========================================================================

  container ipv6 {
    tailf:info "Global IPv6 configuration commands";
    tailf:cli-diff-dependency "../interface";
    tailf:cli-diff-dependency "../interface/Management/nameif";
    tailf:cli-diff-dependency "../interface/Ethernet/nameif";
    tailf:cli-diff-dependency "../interface/FastEthernet/nameif";
    tailf:cli-diff-dependency "../interface/GigabitEthernet/nameif";
    tailf:cli-diff-dependency "../interface/TenGigabitEthernet/nameif";
    tailf:cli-diff-dependency "../interface/Vlan/nameif";
    tailf:cli-diff-dependency "../interface/Port-channel/nameif";
    tailf:cli-diff-dependency "../interface/Port-channel-subif/Port-channel/nameif";
    tailf:cli-diff-dependency "../interface/BVI/nameif";
    tailf:cli-diff-dependency "../interface/Redundant/nameif";
    tailf:cli-diff-dependency "../interface/allocated/nameif";

    // ipv6 enforce-eui64
    leaf enforce-eui64 {
      tailf:info "Enforce correct EUI-64 source address";
      tailf:cli-full-command;
      type nameif-type;
    }

    // ipv6 local pool *
    container local {
      tailf:info "Define a local pool of IPv6 addresses";
      list pool {
        tailf:info "Keyword to define a pool of IPv6 addresses";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key id;
        leaf id {
          type string {
            tailf:info "WORD < 64 char;;Name of the local IPv6 address pool";
            length "1..64";
          }
        }
        leaf "prefix" {
          tailf:cli-drop-node-name;
          type ipv6-prefix {
            tailf:info "X:X:X:X::X/<0-128>;;IPv6 address/prefix";
          }
        }
        leaf number {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-16384>;;Number of addresses";
            range "1..16384";
          }
        }
      }
    }

    // ipv6 icmp * deny|permit *
    list icmp {
      tailf:info "Configure access rules for ICMPv6 traffic terminating at an interface";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      key nameif;
      leaf nameif {
        type string {
          tailf:info "LINE;;ipv6 icmp <nameif> <permit|deny rule>. Note: reordered to device!";
        }
      }
      list rule {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-show-long-obu-diffs;
        ordered-by user;
        key expr;
        leaf expr {
          tailf:cli-multi-word-key;
          type string {
            tailf:info "<RULE>;;deny <LINE> | permit <LINE>";
            pattern "(permit.*)|(deny.*)";
          }
        }
      }
    }

    // ipv6 neighbor *
    list neighbor {
      tailf:info "Neighbor";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      key address;
      leaf address {
        type inet:ipv6-address {
          tailf:info "X:X:X:X::X;;IPv6 address";
        }
      }

      leaf interface-name {
        tailf:cli-drop-node-name;
        type nameif-type;
      }

      leaf hardware-address {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "H.H.H;;48-bit hardware address";
        }
      }
    }

    // ipv6 route *
    list route {
      tailf:info "Configure IPv6 routes";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key id;
      leaf id {
        type nameif-type;
      }

      list "prefix" {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          type ipv6-prefix {
            tailf:info "X:X:X:X::X/<0-128>;;IPv6 prefix";
          }
        }
        leaf dest {
          tailf:cli-drop-node-name;
          type inet:ipv6-address {
            tailf:info "Hostname or X:X:X:X::X;;IPv6 name or address";
          }
        }

        // ipv6 route * hop-count
        leaf hop-count {
          tailf:cli-drop-node-name;
          tailf:cli-full-command;
          tailf:cli-optional-in-sequence;
          type uint8 {
            tailf:info "<1-255>;;Hop count";
            range "1..255";
          }
          default 1;
        }

        // ipv6 route * tunneled
        leaf tunneled {
          tailf:info "Enable the default tunnel gateway option, "+
            "metric is set to 255";
          tailf:cli-full-command;
          type empty;
        }
      }
    }

    // ipv6 router ospf *
    container router {
      tailf:info "Enable an IPV6 routing process";
      list ospf {
        tailf:info "Open Shortest Path First (OSPF)";
        tailf:cli-mode-name "config-rtr";
        key id;
        leaf id {
          type uint16 {
            tailf:info "<1-65535>;;Process ID";
            range "1..65535";
          }
        }
        uses router-ospf-common-grouping;
      }
    }
  }


  /// ========================================================================
  /// nat
  /// ========================================================================

  // nat *
  list nat {
    tailf:info "Associate a network with a pool of global IP addresses";
    tailf:cli-suppress-mode;
    tailf:cli-delete-when-empty;
    tailf:cli-compact-syntax;
    tailf:cli-show-long-obu-diffs;
    ordered-by "user";
    key rule;
    leaf rule {
      tailf:cli-multi-word-key;
      tailf:cli-diff-dependency "../../interface";
      tailf:cli-diff-dependency "../../interface/Management/nameif";
      tailf:cli-diff-dependency "../../interface/Ethernet/nameif";
      tailf:cli-diff-dependency "../../interface/FastEthernet/nameif";
      tailf:cli-diff-dependency "../../interface/GigabitEthernet/nameif";
      tailf:cli-diff-dependency "../../interface/TenGigabitEthernet/nameif";
      tailf:cli-diff-dependency "../../interface/Vlan/nameif";
      tailf:cli-diff-dependency "../../interface/Port-channel/nameif";
      tailf:cli-diff-dependency "../../interface/Port-channel-subif/Port-channel/nameif";
      tailf:cli-diff-dependency "../../interface/BVI/nameif";
      tailf:cli-diff-dependency "../../interface/Redundant/nameif";
      tailf:cli-diff-dependency "../../interface/allocated/nameif";
      tailf:cli-diff-dependency "../../object/network";
      tailf:cli-diff-dependency "../../object-group/network";
      type string;
    }
  }


  /// ========================================================================
  /// asdm
  /// ========================================================================

  container asdm {
    tailf:info "Configure Device Manager";

    // asdm image
    leaf image {
      tailf:info "Specify Device Manager image file path";
      tailf:cli-full-command;
      type string {
        tailf:info "WORD;;Device Manager image file path";
      }
    }

    // no asdm history enable
    container history {
      tailf:info "Enable/Disable Device Manager data sampling";
      leaf enable {
        tailf:info "Enable Device Manager data sampling, use no to disable";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }
    }
  }


  /// ========================================================================
  /// failover
  /// ========================================================================

  // failover
  container failover-conf {
    tailf:cli-drop-node-name;
    leaf failover {
      tailf:info "Enable/diable failover feature";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
    }
  }

  // failover X
  container failover {
    tailf:info "Enable/disable failover feature";
    tailf:cli-incomplete-command;
    tailf:cli-incomplete-no;

    // failover group *
    list group {
      tailf:info "Configure/Enable failover group";
      tailf:cli-mode-name "config-fover-group";
      key id;
      leaf id {
        type uint8 {
          tailf:info "<1-2>;;group number";
          range "1..2";
        }
      }

      // failover group * / primary
      // failover group * / secondary
      leaf priority {
        tailf:cli-drop-node-name;
        type enumeration {
          enum primary {
            tailf:info "Primary unit has higher priority";
          }
          enum secondary {
            tailf:info "Secondary unit has higher priority";
          }
        }
        default primary;
      }

      // failover group * / preempt
      container preempt {
        tailf:info "Allow preemption of lower priority active unit";
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        leaf delay {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-1200>;;Preemption hold-down delay in seconds";
            range "1..1200";
          }
        }
      }
    }

    // failover lan
    container lan {
      tailf:info "Specify the unit as primary or secondary or configure "+
        "the interface and vlan to be used for failover communication";

      // failover lan unit
      leaf unit {
        tailf:info "Configure the unit as primary or secondary";
        tailf:cli-full-command;
        tailf:ned-ignore-compare-config;
        type enumeration {
          enum primary {
            tailf:info "Configure the unit as primary";
          }
          enum secondary {
            tailf:info "Configure the unit as secondary";
          }
        }
      }

      // failover lan interface *
      list interface {
        tailf:info "Configure the interface and vlan to be used for "+
          "failover communication";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type nameif-type;
        }
        leaf phy_if {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;Specify physical or sub interface";
          }
        }
      }
    }

    // failover link *
    list link {
      tailf:info "Configure the interface and vlan to be used as a link for stateful update information";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        type nameif-type;
      }
      leaf phy_if {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "WORD;;Specify physical or sub interface";
        }
      }
    }

    // failover interface ip *
    container interface {
      tailf:info "Configure the IP address to be used for failover "+
        "and/or stateful update information";
      list ip {
        tailf:info "Configure the IP address and mask after this keyword";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key name;
        leaf name {
          tailf:non-strict-leafref {
            path "../../../link/name";
          }
          type nameif-type;
        }
        choice address-choice {
          case ipv4 {
            leaf ip_address {
              tailf:cli-drop-node-name;
              tailf:code-name "ipv4_address";
              type inet:host {
                tailf:info "Hostname or A.B.C.D;;Specify the IP address";
              }
            }
            leaf mask {
              tailf:cli-drop-node-name;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Specify the mask for the IP address";
              }
            }
          }
          case ipv6 {
            leaf ipv6_address {
              tailf:cli-drop-node-name;
              type ipv6-prefix {
                tailf:info "X:X:X:X::X/<0-128>;;Specify the IPv6 prefix";
              }
            }
          }
        }
        leaf standby {
          tailf:info "Configure the standby IP address after this keyword";
          type string {
            tailf:info "ADDRESS;;Hostname or A.B.C.D or X:X:X:X::X";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// interface
  /// ========================================================================

  container interface {
    tailf:info "Configure interfaces";
    tailf:cli-explicit-exit;

    // interface Management *
    list Management {
      tailf:info "Management interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      key name;
      leaf name {
        type string {
          tailf:info "<0-66>/<0-128>;;Management interface number";
          pattern "[0-9]+.*";
        }
      }
      uses interface-ethernet-grouping;
      uses interface-common-grouping;
      uses interface-switch-grouping;
    }

    // interface Ethernet *
    list Ethernet {
      tailf:info "IEEE 802.3";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      key name;
      leaf name {
        type string {
          tailf:info "<slot>/<port>;;Ethernet interface number";
          pattern "[0-9]+.*";
        }
      }
      uses interface-ethernet-grouping;
      uses interface-common-grouping;
      uses interface-switch-grouping;
    }

    // interface FastEthernet *
    list FastEthernet {
      tailf:info "FastEthernet IEEE 802.3";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      key name;
      leaf name {
        type string {
          tailf:info "<0-66>/<0-128>;;FastEthernet interface number";
          pattern "[0-9]+.*";
        }
      }
      uses interface-ethernet-grouping;
      uses interface-common-grouping;
      uses interface-switch-grouping;
    }

    // interface GigabitEthernet *
    list GigabitEthernet {
      tailf:info "GigabitEthernet IEEE 802.3z";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      key name;
      leaf name {
        type string {
          tailf:info "<0-66>/<0-128>;;GigabitEthernet interface number";
          pattern "[0-9]+.*";
        }
      }
      leaf media-type {
        tailf:info "Media type";
        type enumeration {
          enum rj45 {
            tailf:info "Copper";
          }
          enum sfp {
            tailf:info "Fiber";
          }
        }
      }
      leaf port-type {
        type enumeration {
          enum nni;
        }
      }
      uses interface-ethernet-grouping;
      uses interface-common-grouping;
      uses interface-switch-grouping;
    }

    // interface TenGigabitEthernet *
    list TenGigabitEthernet {
      tailf:info "Ten Gigabit Ethernet";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      key name;
      leaf name {
        type string {
          tailf:info "<0-66>/<0-128>;;TenGigabitEthernet interface number";
          pattern "[0-9]+.*";
        }
      }
      leaf media-type {
        tailf:info "Media type";
        type enumeration {
          enum rj45 {
            tailf:info "Copper";
          }
          enum sfp {
            tailf:info "Fiber";
          }
        }
      }
      leaf port-type {
        type enumeration {
          enum nni;
        }
      }
      uses interface-ethernet-grouping;
      uses interface-common-grouping;
      uses interface-switch-grouping;
    }

    // interface Vlan *
    list Vlan {
      tailf:info "Catalyst Vlans";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      key name;
      leaf name {
        type uint16 {
          tailf:info "<1-4090>;;Vlan interface number";
          range "1..4090";
        }
      }
      uses interface-ethernet-grouping;
      uses interface-common-grouping;
      uses interface-switch-grouping;
    }

    // interface Port-channel *
    list Port-channel {
      tailf:info "Ethernet Channel of interfaces";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      key name;
      leaf name {
        type string {
          tailf:info "Port-channel interface";
          pattern "[0-9]+";
        }
      }
      uses interface-ethernet-grouping;
      uses interface-common-grouping;
      uses interface-switch-grouping;
    }

    // interface Port-channel *.*
    container Port-channel-subif {
      tailf:cli-drop-node-name;
      list Port-channel {
        tailf:info "Ethernet Channel of interfaces";
        tailf:cli-allow-join-with-key {
          tailf:cli-display-joined;
        }
        tailf:cli-mode-name "config-subif";
        key name;
        leaf name {
          tailf:cli-diff-dependency "../../../Port-channel";
          type string {
            tailf:info "Port-channel interface";
            pattern "[0-9]+.*";
          }
        }
        uses interface-ethernet-grouping;
        uses sub-interface-common-grouping;
        uses interface-switch-grouping;
      }
    }

    // interface BVI*
    list BVI {
      tailf:info "Bridge-Group Virtual Interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      key name;
      leaf name {
        type string {
          tailf:info "<1-250>;;BVI interface number";
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-grouping;
    }

    // interface Redundant*
    list Redundant {
      tailf:info "Redundant Interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      key name;
      leaf name {
        type uint32 {
          tailf:info "<1-8>;;Redundant interface number";
          range "1..8";
        }
      }

      // interface Redundant* / member-interface *
      list member-interface {
        tailf:info "Configure member interface";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Interface name";
          }
        }
      }

      uses interface-common-grouping {
        refine nameif {
          tailf:cli-diff-dependency "../member-interface";
        }
      }
      uses interface-switch-grouping;

    }

    // interface *
    list allocated {
      tailf:cli-drop-node-name;
      tailf:cli-mode-name "config-if";
      key name;
      leaf name {
        tailf:cli-disallow-value "Management|Ethernet|FastEthernet"+
          "|GigabitEthernet|TenGigabitEthernet|Vlan|Port-channel|Redundant|BVI";
        type string {
          tailf:info "WORD;;Interface name";
        }
      }
      uses interface-ethernet-grouping;
      uses interface-common-grouping;
      uses interface-switch-grouping;
    }
  }


  /// ========================================================================
  /// class
  /// ========================================================================

  // class *
  list class {
    tailf:info "Create a resource class";
    tailf:cli-mode-name "config-class";
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;Symbolic name of the class";
      }
    }

    // class * / limit-resource *
    list limit-resource {
      tailf:info "Configure the resource limits";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      key name;
      leaf name {
        type enumeration {
          enum ASDM {
            tailf:info "ASDM Connections";
          }
          enum All {
            tailf:info "All Resources";
          }
          enum Conns {
            tailf:info "Connections";
          }
          enum Hosts {
            tailf:info "Hosts";
          }
          enum Mac-addresses {
            tailf:info "MAC Address table entries";
          }
          enum Routes {
            tailf:info "Routing Table Entries";
          }
          enum SSH {
            tailf:info "SSH Sessions";
          }
          enum Telnet {
            tailf:info "Telnet Sessions";
          }
          enum VPN {
            tailf:info "VPN resources";
          }
          enum Xlates {
            tailf:info "XLATE Objects";
          }
          enum Storage {
            tailf:info "Storage Limit Size of context directory in MB";
          }
        }
      }
      leaf value {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "WORD;;Value of resource limit (in <value> or <value>%)";
        }
      }
    }
  }


  /// =========================================================================
  /// forward-reference
  /// =========================================================================

  // forward-reference enable
  container forward-reference {
    tailf:info "Enable forward reference of acl, object and object-group names";
    leaf enable {
      tailf:info "Enable forward reference of acl, object and object-group names";
      type empty;
    }
  }


  /// ========================================================================
  /// object
  /// ========================================================================

  container object {
    tailf:info "Configure an object";
    tailf:cli-explicit-exit;
    tailf:cli-diff-dependency "../interface";
    tailf:cli-diff-dependency "../interface/Management/nameif";
    tailf:cli-diff-dependency "../interface/Ethernet/nameif";
    tailf:cli-diff-dependency "../interface/FastEthernet/nameif";
    tailf:cli-diff-dependency "../interface/GigabitEthernet/nameif";
    tailf:cli-diff-dependency "../interface/TenGigabitEthernet/nameif";
    tailf:cli-diff-dependency "../interface/Vlan/nameif";
    tailf:cli-diff-dependency "../interface/Port-channel/nameif";
    tailf:cli-diff-dependency "../interface/Port-channel-subif/Port-channel/nameif";
    tailf:cli-diff-dependency "../interface/BVI/nameif";
    tailf:cli-diff-dependency "../interface/Redundant/nameif";
    tailf:cli-diff-dependency "../interface/allocated/nameif";

    // object network *
    list network {
      tailf:info "Specifies a host, subnet or range IP addresses";
      tailf:cli-mode-name "config-network-object";
      tailf:cli-full-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD < 65 char;;Specifies object ID (1-64 characters)";
        }
      }

      // object network * / description
      leaf description {
        tailf:info "Specify description text";
        tailf:cli-full-command;
        tailf:cli-multi-value;
        type string {
          tailf:info "LINE < 201 char;;Specify description text";
          length "1..200";
        }
      }

      choice object-network-choice {
        // object network * / host
        leaf host {
          tailf:info "Enter this keyword to specify a single host object";
          tailf:cli-full-command;
          type union {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Enter a host IP address";
            }
            type inet:ipv6-address {
              tailf:info "X:X:X:X::X;;Enter a host IPV6 address";
            }
          }
        }

        // object network * / range
        container "range" {
          tailf:info "Enter this keyword to specify a range";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf start-ip {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            tailf:info "";
            type union {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Enter start IP address";
              }
              type inet:ipv6-address {
                tailf:info "X:X:X:X::X;;Enter start IPv6 address";
              }
            }
          }
          leaf end-ip {
            tailf:cli-drop-node-name;
            type union {
              type inet:ipv4-address {
                tailf:info "Enter end IP address";
              }
              type inet:ipv6-address {
                tailf:info "Enter end IPv6 address";
              }
            }
          }
        }

        // object network * / subnet
        container subnet {
          tailf:info "Enter this keyword to specify a subnet";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf address {
            tailf:cli-drop-node-name;
            type union {
              type inet:host {
                tailf:info "A.B.C.D;;Enter an IPV4 network address";
              }
              type ipv6-prefix {
                tailf:info "X:X:X:X::X/<0-128>;;Enter an IPv6 prefix";
              }
            }
          }
          leaf mask {
            tailf:cli-drop-node-name;
            when "not(contains(../address, ':'))" {
              tailf:dependency "../address";
            }
            type inet:ip-address {
              tailf:info "A.B.C.D;;Enter an IPv4 network mask";
            }
          }
        }

        // object network * / fqdn
        container fqdn {
          tailf:info "Enter this keyword to specify an FQDN";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf af {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            type enumeration {
              enum v4 {
                tailf:info "IPv4 FQDN object";
              }
              enum v6 {
                tailf:info "IPv6 FQDN object";
              }
            }
          }
          leaf domain {
            tailf:cli-drop-node-name;
            tailf:cli-reset-container;
            type string {
              tailf:info "WORD < 128 char;;Fully Qualified Domain Name - "+
                "FQDN must begin and end with a digit/letter. Only letters, "+
                "digits, and hyphen are allowed as internal characters. "+
                "Labels are separated by a dot.";
            }
          }
        }
      }

      // object network * / nat
      container nat {
        tailf:info "Enable NAT on a singleton object";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf ifc {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type string {
            tailf:info "WORD;;(real_ifc, mapped_ifc)";
          }
        }
        leaf "type" {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type enumeration {
            enum dynamic {
              tailf:info "Specify NAT type as dynamic";
            }
            enum static {
              tailf:info "Specify NAT type as static";
            }
          }
        }
        choice mapped-choice {
          leaf mapped-inline-host-ip {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Mapped IP address";
            }
          }
          leaf mapped-obj {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            tailf:cli-diff-dependency "../../../network[name=current()/../mapped-obj]";
            tailf:cli-disallow-value "interface|ipv6|net-to-net|dns|no-proxy-arp|route-lookup";
            type string {
              tailf:info "WORD;;Mapped network object/object-group name";
            }
          }
        }
        leaf interface {
          tailf:info "Use interface address as mapped IP";
          tailf:cli-optional-in-sequence;
          type empty;
        }
        leaf ipv6 {
          tailf:info "Use IPv6 address(es) as mapped IP(s)";
          tailf:cli-optional-in-sequence;
          type empty;
        }
        leaf net-to-net {
          tailf:info "Use Net to net mapping of IPv4 to IPv6 address(es)";
          tailf:cli-optional-in-sequence;
          type empty;
        }
        leaf dns {
          tailf:info "Use the created xlate to rewrite DNS record";
          tailf:cli-optional-in-sequence;
          type empty;
        }
        leaf no-proxy-arp {
          tailf:info "Disable proxy ARP on the egress interface";
          tailf:cli-optional-in-sequence;
          type empty;
        }
        leaf route-lookup {
          tailf:info "Perform route lookup for this rule";
          tailf:cli-optional-in-sequence;
          type empty;
        }
        container service {
          tailf:info "Define port mapping";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf protocol {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type enumeration {
              enum tcp {
                tailf:info "TCP to be used as transport protocol";
              }
              enum udp {
                tailf:info "UDP to be used as transport protocol";
              }
            }
          }
          leaf real-port {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type union {
              type uint16 {
                tailf:info "<0-65535>;;Specify real port";
              }
              type string {
                tailf:info "<WORD>;;Real port name";
              }
            }
          }
          leaf mapped-port {
            tailf:cli-drop-node-name;
            type union {
              type uint16 {
                tailf:info "<0-65535>;;Specify mapped port";
              }
              type string {
                tailf:info "<WORD>;;Mapped port name";
              }
            }
          }
        }
      }
    }

    // object service *
    list service {
      tailf:info "Specifies a protocol/port";
      tailf:cli-mode-name "config-service-object";
      key name;
      leaf name {
        type string {
          tailf:info "WORD < 129 char  Specifies object ID";
        }
      }

      // object service * / description
      leaf description {
        tailf:info "Specify description text";
        tailf:cli-full-command;
        tailf:cli-multi-value;
        type string {
          tailf:info "LINE < 201 char;;Specify description text";
          length "1..200";
        }
      }

      // object service * / service
      container service {
        tailf:info "Specify a protocol and/or port";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf name {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;Enter protocol name or number <0-255>";
          }
        }

        // object service * / service source
        container source {
          tailf:info "Keyword to specify source";
          tailf:cli-break-sequence-commands;
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          uses object-service-port-grouping;
        }

        // object service * / service destination
        container destination {
          tailf:info "Keyword to specify destination";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          uses object-service-port-grouping;
        }

        // object service * / service
        container icmp {
          when "../name = 'icmp'" {
            tailf:dependency "../name";
          }
          tailf:cli-drop-node-name;
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf "type" {
            tailf:cli-drop-node-name;
            type union {
              type uint8 {
                tailf:info "<0-255>;;Enter ICMP type number (0 - 255)";
              }
              type enumeration {
                enum echo-reply {
                  tailf:info "Echo reply";
                  value 0;
                }
                enum unreachable {
                  tailf:info "All unreachables";
                  value 3;
                }
                enum source-quench {
                  tailf:info "Source quenches";
                  value 4;
                }
                enum redirect {
                  tailf:info "All redirects";
                  value 5;
                }
                enum alternate-address {
                  tailf:info "Alternate address";
                  value 6;
                }
                enum echo {
                  tailf:info "Echo (ping)";
                  value 8;
                }
                enum router-advertisement {
                  tailf:info "Router discovery advertise.";
                  value 9;
                }
                enum router-solicitation {
                  tailf:info "Router discovery solicitations";
                  value 10;
                }
                enum time-exceeded {
                  tailf:info "All time exceededs";
                  value 11;
                }
                enum parameter-problem {
                  tailf:info "All parameter problems";
                  value 12;
                }
                enum timestamp-request {
                  tailf:info "Timestamp requests";
                  value 13;
                }
                enum timestamp-reply {
                  tailf:info "Timestamp replies";
                  value 14;
                }
                enum information-request {
                  tailf:info "Information requests";
                  value 15;
                }
                enum information-reply {
                  tailf:info "Information replies";
                  value 16;
                }
                enum mask-request {
                  tailf:info "Mask requests";
                  value 17;
                }
                enum mask-reply {
                  tailf:info "Mask replies";
                  value 18;
                }
                enum traceroute {
                  tailf:info "Traceroute";
                  value 30;
                }
                enum conversion-error {
                  tailf:info "Datagram conversion";
                  value 31;
                }
                enum mobile-redirect {
                  tailf:info "Mobile host redirect";
                  value 32;
                }
              }
            }
          }
          leaf code {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<0-255>;;Enter ICMP code (0 - 255)";
            }
          }
        }
      }
    }
  }


  /// =========================================================================
  /// object-group
  /// =========================================================================

  container object-group {
    tailf:info "Create an object group for use in  'access-list', etc";
    tailf:cli-diff-dependency "../object";

    // object-group icmp-type *
    list icmp-type {
      tailf:info "Specifies a group of ICMP types, such as echo";
      tailf:cli-mode-name "config-icmp";
      key id;
      leaf id {
        type string {
          tailf:info "WORD < 65 char;;Specifies object-group ID (1-64 characters)";
        }
      }

      // object-group icmp-type * / description
      leaf description {
        tailf:info "Specify description text";
        tailf:cli-multi-value;
        type string {
          tailf:info "LINE < 201 char;;Specify description text";
        }
      }

      // object-group icmp-type * / icmp-object *
      list icmp-object {
        tailf:info "Configure an ICMP-type object";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-show-long-obu-diffs;
        ordered-by "user";
        key id;
        leaf id {
          tailf:cli-multi-word-key;
          type string {
          }
        }
      }

      // object-group icmp-type * / group-object *
      leaf-list group-object {
        tailf:info "Configure an object group as an object";
        tailf:cli-list-syntax;
        tailf:cli-diff-delete-after "../../../access-list/access-list-id" {
          tailf:cli-when-target-delete;
        }
        tailf:non-strict-leafref {
          path "../../icmp-type/id";
        }
        type string {
          tailf:info "WORD;;Specifies the ID of an existing object group "+
            "of the same type as the parent object group";
        }
      }
    }

    // object-group network *
    list network {
      tailf:info "Specifies a group of host or subnet IP addresses";
      tailf:cli-mode-name "config-network";
      key id;
      leaf id {
        type string {
          tailf:info "WORD < 65 char;;Specifies object-group ID (1-64 characters)";
          length "1..65";
        }
      }

      // object-group network * / description
      leaf description {
        tailf:info "Specify description text";
        tailf:cli-multi-value;
        type string {
          tailf:info "LINE < 201 char;;Specify description text";
        }
      }

      // object-group network * / network-object *
      list network-object {
        tailf:info "Configure a network object";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-diff-delete-before "../../../object/network" {
          tailf:cli-when-target-delete;
        }
        key id;
        leaf id {
          tailf:cli-multi-word-key;
          type string {
            tailf:info "LINE;;Network object line";
          }
        }
      }

      // object-group network * / group-object *
      leaf-list group-object {
        tailf:info "Configure an object group as an object";
        tailf:cli-list-syntax;
        tailf:cli-diff-delete-after "../../../access-list/access-list-id" {
          tailf:cli-when-target-delete;
        }
        tailf:non-strict-leafref {
          path "../../network/id";
        }
        type string {
          tailf:info "WORD;;Specifies the ID of an existing object group "+
            "of the same type as the parent object group";
        }
      }
    }

    // object-group service *
    list service {
      tailf:info "Specifies a group of TCP/UDP ports/services";
      tailf:cli-mode-name "config-service";
      key id;
      leaf id {
        type string {
          tailf:info "WORD < 65 char;;Specifies object-group ID (1-64 "
            +"characters)";
          length "1..65";
        }
      }

      // object-group service * tcp
      // object-group service * tcp-udp
      // object-group service * udp
      // object-group service * icmp
      leaf proto {
        tailf:cli-drop-node-name;
        tailf:cli-hide-in-submode;
        type union {
          type uint8 {
            tailf:info "<0-255>;;An IP protocol number";
          }
          type enumeration {
            enum tcp {
              tailf:info "Specifies this object-group is for TCP protocol only";
            }
            enum tcp-udp {
              tailf:info "Specifies this object-group is for both TCP & UDP";
            }
            enum udp {
              tailf:info "Specifies this object-group is for UDP protocol only";
            }
          }
        }
      }

      // object-group service * / description
      leaf description {
        tailf:info "Specify description text";
        tailf:cli-multi-value;
        type string {
          tailf:info "LINE < 201 char;;Specify description text";
        }
      }

      // object-group service * / group-object *
      leaf-list group-object {
        tailf:info "Configure an object group as an object";
        tailf:cli-list-syntax;
        tailf:cli-diff-delete-after "../../../access-list/access-list-id" {
          tailf:cli-when-target-delete;
        }
        tailf:non-strict-leafref {
          path "../../service/id";
        }
        type string {
          tailf:info "WORD;;Specifies the ID of an existing object group of "+
            "the same type as the parent object group";
        }
      }

      // object-group service * / service-object *
      list service-object {
        tailf:info "Configure a service object";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        when "not(../proto)" {
          tailf:dependency "../proto";
        }
        key arg;
        leaf arg {
          tailf:cli-suppress-range;
          tailf:cli-multi-word-key;
          type string;
        }
      }

      // object-group service * / port-object *
      list port-object {
        tailf:info "Configure a port object";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        when "../proto" {
          tailf:dependency "../proto";
        }
        key arg;
        leaf arg {
          tailf:cli-suppress-range;
          tailf:cli-multi-word-key;
          type string;
        }
      }
    }

    // object-group user *
    list user {
      tailf:info "Specifies single user, local or import user group";
      key id;
      leaf id {
        type string {
          tailf:info "WORD < 65 char;;Specifies object-group ID (1-64 characters)";
          length "1..65";
        }
      }

      // object-group user * / description
      leaf description {
        tailf:info "Specify description text";
        tailf:cli-multi-value;
        type string {
          tailf:info "LINE < 201 char;;Specify description text";
        }
      }


      // object-group user * / group-object *
      leaf-list group-object {
        tailf:info "Configure an object group as an object";
        tailf:cli-list-syntax;
        tailf:cli-diff-delete-after "../../../access-list/access-list-id" {
          tailf:cli-when-target-delete;
        }
        tailf:non-strict-leafref {
          path "../../user/id";
        }
        type string {
          tailf:info "WORD;;Specifies the ID of an existing object group "+
            "of the same type as the parent object group";
        }
      }

      // object-group user * / user *
      list user {
        tailf:info "Configure a user object";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key id;
        leaf id {
          type string {
            tailf:info "WORD < 98 char;;User name - [<domain>\\]<user>, domain < 33 char, user < 65 char";
          }
        }
      }

      // object-group user * / user-group *
      list user-group {
        tailf:info "Configure a port object";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-show-long-obu-diffs;
        ordered-by "user";
        key id;
        leaf id {
          tailf:cli-multi-word-key;
          type string;
        }
      }
    }

    // object-group security *
    list security {
      tailf:info "service";
      tailf:cli-mode-name "config-security-object-group";
      key id;
      leaf id {
        type string {
          tailf:info "WORD < 129 char;;Specifies object-group ID";
          length "1..129";
        }
      }

      // object-group security * / description
      leaf description {
        tailf:info "Specify description text";
        tailf:cli-multi-value;
        type string {
          tailf:info "LINE < 201 char;;Specify description text";
          length "1..201";
        }
      }

      // object-group security * / security-group
      container security-group {
        tailf:info "Configure a security-group";

        // object-group security * / security-group name *
        list name {
          tailf:info "Enter this keyword to specify a security-group name";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key id;
          leaf id {
            type string {
              tailf:info "WORD < 33 char;;Enter security-group name";
            }
          }
        }

        // object-group security * / security-group tag *
        list tag {
          tailf:info "Enter this keyword to specify a security-group tag";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key id;
          leaf id {
            type uint16 {
              tailf:info "<0-65533>;;Enter security-group tag";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// access-list
  /// ========================================================================

  container access-list {
    tailf:info "Configure an access control element";
    tailf:cli-diff-set-after "../object-group";
    tailf:cli-diff-set-after "../object";
    tailf:cli-diff-delete-before "../time-range" {
      tailf:cli-when-target-delete;
    }
    tailf:cli-diff-dependency "../object-group"; // ncs-3.4.x support
    tailf:cli-diff-dependency "../object"; // ncs-3.4.x support
    tailf:cli-diff-dependency "../time-range"; // ncs-3.4.x support

    // access-list deny-flow-max
    leaf deny-flow-max {
      tailf:info "Specify the maximum number of concurrent deny flows that can"
        +" be created. If not specified, the default value is 4096";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<1-4096>;;Maximum number of concurrent deny flows that can"
          +" be created, default is 4096";
        range "1..4096";
      }
    }

    // access-list alert-interval
    leaf alert-interval {
      tailf:info "Specify the alert interval for generating syslog message "
        +"106001 which alerts that the system has reached a deny flow maximum. "
        +"If not specified, the default value is 300 sec";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<1-3600>;;Alert interval for generating syslog message "
          +"106001 which alerts that the system has reached a deny flow "
          +"maximum, default is 300";
        range "1..3600";
      }
    }

    // access-list *
    list access-list-id {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      key id;
      leaf id {
        tailf:cli-disallow-value "(alert-interval)|(deny-flow-max)";
        type string {
          tailf:info "WORD < 241 char;;Access list identifier";
        }
      }
      // Note: Java code make sure one delete is made last or other
      //       objects refering to the access-list will block it.
      list rule {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-show-obu-comments;
        ordered-by "user";
        key id;
        leaf id {
          tailf:cli-disallow-value "(extended .* (log|log .+))|(extended .* inactive.*)|(extended .* )";
          tailf:cli-diff-delete-before "../../../../object-group" {
            tailf:cli-when-target-delete;
          }
          tailf:cli-diff-delete-before "../../../../object" {
            tailf:cli-when-target-delete;
          }
          type string {
            tailf:info "WORD;;quoted rule beginning with: "+
              "remark|standard|extended|webtype|permit|deny, followed by options (e.g. log|inactive)"+
              ". For example: \"extended permit tcp any any\" log";
            pattern "(remark .*)|(standard .*)|(extended .*)|(webtype .*)|(ethertype .*)";
          }
        }
        leaf log {
          tailf:info "Keyword for enabling log option on this ACL element";
          tailf:cli-optional-in-sequence;
          type empty; // note: removed on device by setting 'log disable'
        }
        leaf level {
          when "../log";
          tailf:cli-drop-node-name;
          tailf:cli-optional-in-sequence;
          type union {
            type logging-level-type;
            type enumeration {
              enum default {
                tailf:info "Keyword for restoring default log behavior (log 106023)";
                value 106023;
              }
            }
          }
          // JAVA clear: default informational;
        }
        leaf interval {
          when "../log";
          tailf:info "Configure log interval, default value is 300 sec";
          tailf:cli-optional-in-sequence;
          type uint16 {
            tailf:info "<1-600>;;Log interval, default is 300 sec";
            range "1..600";
          }
          // JAVA clear: default 300
        }
        leaf time-range {
          tailf:info "Keyword for attaching time-range option to this ACL element";
          tailf:cli-optional-in-sequence;
          type string {
            tailf:info "WORD;;Time-range name for specifying the active period";
          }
        }
        leaf inactive {
          // Note: inactive is (sometimes) not shown on access-list webtype. Bug?
          tailf:info "Keyword for disabling an ACL element";
          type empty; // note: enabled on device by leaving out 'disable'
        }
      }
    }
  }


  /// ========================================================================
  /// access-group
  /// ========================================================================

  container access-group {
    tailf:info "Bind an access-list to an interface to filter traffic";

    // access-group ? in interface *
    // access-group ? out interface *
    list interface-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      key "direction interface";
      leaf direction {
        type enumeration {
          enum in {
            tailf:info "For input traffic";
          }
          enum out {
            tailf:info "For output traffic";
          }
        }
      }
      leaf interface {
        tailf:cli-expose-key-name;
        tailf:info "Keyword to specify an interface";
        tailf:cli-diff-dependency "../../../interface";
        tailf:cli-diff-dependency "../../../interface/Management/nameif";
        tailf:cli-diff-dependency "../../../interface/Ethernet/nameif";
        tailf:cli-diff-dependency "../../../interface/FastEthernet/nameif";
        tailf:cli-diff-dependency "../../../interface/GigabitEthernet/nameif";
        tailf:cli-diff-dependency "../../../interface/TenGigabitEthernet/nameif";
        tailf:cli-diff-dependency "../../../interface/Vlan/nameif";
        tailf:cli-diff-dependency "../../../interface/Port-channel/nameif";
        tailf:cli-diff-dependency "../../../interface/Port-channel-subif/Port-channel/nameif";
        tailf:cli-diff-dependency "../../../interface/BVI/nameif";
        tailf:cli-diff-dependency "../../../interface/Redundant/nameif";
        tailf:cli-diff-dependency "../../../interface/allocated/nameif";
        type nameif-type;
      }
      leaf access-list {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        //tailf:cli-diff-dependency "../../../access-list/access-list-id";
        tailf:non-strict-leafref {
          path "../../../access-list/access-list-id/id";
        }
        type string {
          tailf:info "WORD;;Access List name";
        }
      }
    }

    // access-group ? in interface * control-plane
    list control-plane-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-incomplete-command;
      key "direction interface";
      leaf direction {
        type enumeration {
          enum in {
            tailf:info "For input traffic";
          }
        }
      }
      leaf interface {
        tailf:cli-expose-key-name;
        tailf:info "Keyword to specify an interface";
        tailf:cli-diff-dependency "../../../interface";
        tailf:cli-diff-dependency "../../../interface/Management/nameif";
        tailf:cli-diff-dependency "../../../interface/Ethernet/nameif";
        tailf:cli-diff-dependency "../../../interface/FastEthernet/nameif";
        tailf:cli-diff-dependency "../../../interface/GigabitEthernet/nameif";
        tailf:cli-diff-dependency "../../../interface/TenGigabitEthernet/nameif";
        tailf:cli-diff-dependency "../../../interface/Vlan/nameif";
        tailf:cli-diff-dependency "../../../interface/Port-channel/nameif";
        tailf:cli-diff-dependency "../../../interface/Port-channel-subif/Port-channel/nameif";
        tailf:cli-diff-dependency "../../../interface/BVI/nameif";
        tailf:cli-diff-dependency "../../../interface/Redundant/nameif";
        tailf:cli-diff-dependency "../../../interface/allocated/nameif";
        type nameif-type;
      }
      leaf access-list {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        tailf:cli-diff-dependency "../../../access-list/access-list-id";
        tailf:non-strict-leafref {
          path "../../../access-list/access-list-id/id";
        }
        type string {
          tailf:info "WORD;;Access List name";
        }
      }
      leaf control-plane {
        tailf:info "Specify if rule is for to-the-box traffic";
        type empty;
      }
    }

    // access-group ? global
    list global-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      key global;
      leaf global {
        type enumeration {
          enum global {
            tailf:info "For traffic on all interfaces";
          }
        }
      }
      leaf access-list {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        tailf:cli-diff-dependency "../../../access-list/access-list-id";
        tailf:non-strict-leafref {
          path "../../../access-list/access-list-id/id";
        }
        type string {
          tailf:info "WORD;;Access List name";
        }
      }
    }
  }


  /// ========================================================================
  /// prefix-list
  /// ========================================================================

  container prefix-list {
    tailf:info "Build a prefix list";
    tailf:cli-diff-dependency "../router";

    // no ip prefix-list sequence-number
    leaf sequence-number {
      tailf:info "Include/exclude sequence numbers in NVGEN";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
      default true;
    }

    // ip prefix-list *
    list prefixes {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-diff-dependency "../sequence-number" {
        tailf:cli-trigger-on-set;
        tailf:cli-trigger-on-delete;
      }
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Name of a prefix list";
          pattern '([^s].*)|(s[^e].*)|(se[^q].*)'
            +'(seq[^u].*)|(sequ[^e].*)|(seque[^n].*)|'
            +'(sequen[^c].*)|(sequenc[^e].*)|(sequence'
            +'[^\-].*)|(sequence\-[^n].*)|(sequence\-n'
            +'[^u].*)|(sequence\-nu[^m].*)|(sequence\-'
            +'num[^b].*)|(sequence\-numb[^e].*)|'
            +'(sequence\-numbe[^r].*)|(sequence\-number..*)';
        }
      }

      // ip prefix-list * description
      leaf description {
        tailf:info "Prefix-list specific description";
        tailf:cli-multi-value;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE;;Up to 80 characters describing this prefix-list";
          length "1..80";
        }
      }

      // ip prefix-list * permit
      leaf permit {
        tailf:info "Specify packets to forward";
        tailf:cli-full-command;
        type ipv4-prefix {
          tailf:info "WORD;;IP address and mask of format <ipaddr>/<len>";
        }
      }

      // ip prefix-list * seq *
      list seq {
        tailf:info "sequence number of an entry";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key no;
        leaf no {
          type uint32 {
            tailf:info "<1-4294967294>;;Sequence number";
            range "1..4294967294";
          }
          tailf:key-default "10";
        }

        // ip prefix-list * seq * deny
        container deny {
          tailf:info "Specify packets to reject";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-all-siblings;
          }
          leaf ip {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "A.B.C.D;;IP prefix <network>/"
                +"<length>, e.g., 35.0.0.0/8";
            }
          }
          leaf ge {
            tailf:info "Minimum prefix length to be matched";
            tailf:cli-break-sequence-commands;
            type uint8 {
              tailf:info "<1-32>;;Minimum prefix length";
              range "1..32";
            }
          }
          leaf le {
            tailf:info "Maximum prefix length to be matched";
            tailf:cli-full-command;
            type uint8 {
              tailf:info "<1-32>;;Maximum prefix length";
              range "1..32";
            }
          }
        }

        // ip prefix-list * seq * permit
        container permit {
          tailf:info "Specify packets to forward";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-all-siblings;
          }
          leaf ip {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "A.B.C.D;;IP prefix <network>/"
                +"<length>, e.g., 35.0.0.0/8";
            }
          }
          leaf ge {
            tailf:info "Minimum prefix length to be matched";
            tailf:cli-break-sequence-commands;
            type uint8 {
              tailf:info "<1-32>;;Minimum prefix length";
              range "1..32";
            }
          }
          leaf le {
            tailf:info "Maximum prefix length to be matched";
            tailf:cli-full-command;
            type uint8 {
              tailf:info "<1-32>;;Maximum prefix length";
              range "1..32";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// policy-list
  /// ========================================================================

  list policy-list {
    tailf:info "Define IP Policy list";
    tailf:cli-mode-name "config-policy-list";
    tailf:cli-incomplete-command;
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;IP Policy list name";
      }
    }
    leaf operation {
      tailf:cli-drop-node-name;
      tailf:cli-hide-in-submode;
      type enumeration {
        enum deny {
          tailf:info "IP Policy list deny";
        }
        enum permit {
          tailf:info "IP Policy list permit";
        }
      }
    }
  }


  /// ========================================================================
  /// tcp-map
  /// ========================================================================

  // tcp-map *
  list tcp-map {
    tailf:info "Configure advanced options for TCP inspection";
    tailf:cli-mode-name "config-tcp-map";
    tailf:cli-explicit-exit;
    key name;
    leaf name {
      type string {
        tailf:info "WORD < 129 char;;tcp-map name";
      }
    }

    // tcp-map * / tcp-options
    container tcp-options {
      tailf:info "Options in TCP header";

      // tcp-map * / tcp-options range *
      list "range" {
        tailf:info "Range of TCP options, default is to clear options";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key option;
        leaf option {
          tailf:cli-suppress-range;
          type uint8 {
            tailf:info "<6-7,9-255>;;TCP option";
            range "6..7|9..255";
          }
        }
        leaf action {
          tailf:cli-drop-node-name;
          type enumeration {
            enum allow {
              tailf:info "Allow packet with this option";
            }
            enum drop {
              tailf:info "Drop packet with this option";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// route-map
  /// ========================================================================

  list route-map {
    tailf:info "Route map tag";
    tailf:cli-mode-name "config-route-map";
    tailf:cli-compact-syntax;
    tailf:cli-full-command;
    key "name sequence";
    leaf name {
      type string {
        tailf:info "WORD < 58 char;;Route map tag";
      }
    }
    leaf sequence {
      type uint16 {
        tailf:info "<0-65535>;;Sequence to insert to/delete from "
          +"existing route-map entry";
        range "0..65535";
      }
    }

    // route-map * permit
    // route-map * deny
    leaf operation {
      tailf:cli-drop-node-name;
      tailf:cli-prefix-key {
        tailf:cli-before-key 2;
      }
      type enumeration {
        enum deny {
          tailf:info "Route map denies set operations";
        }
        enum permit {
          tailf:info "Route map permits set operations";
        }
      }
      default permit;
    }

    // route-map * / match
    container match {
      tailf:info "Match values from routing table";

      // route-map * / match community *
      container community {
        tailf:info "Match BGP community list";
        leaf-list name {
          tailf:cli-drop-node-name;
          tailf:cli-flat-list-syntax;
          ordered-by user;
          type union {
            type string {
              tailf:info "WORD;;Community-list name";
            }
            type enumeration {
              enum exact-match {
                tailf:info "Do exact matching of communities";
              }
            }
          }
        }
      }

      // route-map * / match ip address
      container ip {
        tailf:info "IP specific information";
        container address {
          tailf:info "Match address of route or match packet";
          choice address-choice {
            leaf access-list {
              tailf:cli-drop-node-name;
              tailf:cli-diff-dependency "../../../../../access-list/access-list-id";
              tailf:non-strict-leafref {
                path "../../../../../access-list/access-list-id/id";
              }
              type string {
                tailf:info "WORD;;IP access-list name";
              }
            }
            leaf prefix-list {
              tailf:info "Match entries of prefix-lists";
              tailf:non-strict-leafref {
                path "../../../../../prefix-list/prefixes/name";
              }
              type string {
                tailf:info "WORD;;IP prefix-list name";
              }
            }
          }
        }
      }

      // route-map * / match route-type
      container route-type {
        tailf:info "Match route-type of route";
        tailf:cli-compact-syntax;
        leaf internal {
          tailf:info "internal route (including OSPF intra/inter area)";
          type empty;
        }
        leaf local {
          tailf:info "locally generated route";
          type empty;
        }
        container external-2 {
          tailf:cli-drop-node-name;
          tailf:cli-flatten-container;
          leaf external {
            tailf:info "external route (BGP, EIGRP and OSPF type 1/2)";
            type enumeration {
              enum type-2 {
                tailf:info "OSPF external type 2 route";
              }
            }
          }
        }
        container nssa-external-1 {
          tailf:cli-drop-node-name;
          tailf:cli-flatten-container;
          leaf nssa-external {
            tailf:info "nssa-external route (OSPF type 1/2)";
            type enumeration {
              enum type-1 {
                tailf:info "OSPF nssa-external type 1 route";
              }
            }
          }
        }
        leaf nssa-external {
          tailf:info "nssa-external route (OSPF type 1/2)";
          type empty;
        }
        container external-1 {
          tailf:cli-drop-node-name;
          tailf:cli-flatten-container;
          leaf external {
            tailf:info "external route (BGP, EIGRP and OSPF type 1/2)";
            type enumeration {
              enum type-1 {
                tailf:info "OSPF external type 1 route";
              }
            }
          }
        }
        leaf external {
          tailf:info "external route (BGP, EIGRP and OSPF type 1/2)";
          type empty;
        }
        container nssa-external-2 {
          tailf:cli-drop-node-name;
          tailf:cli-flatten-container;
          leaf nssa-external {
            tailf:info "nssa-external route (OSPF type 1/2)";
            type enumeration {
              enum type-2 {
                tailf:info "OSPF external type 2 route";
              }
            }
          }
        }
      }
    }

    // route-map * / set
    container set {
      tailf:info "Set values in destination routing protocol";

      // route-map * / set ip
      container ip {
        tailf:info "IP specific information";

        // route-map * / set ip next-hop
        container next-hop {
          tailf:info "Next hop address";
          leaf-list address {
            tailf:cli-drop-node-name;
            tailf:cli-flat-list-syntax;
            type inet:host {
              tailf:info "A.B.C.D;;IP address of next hop";
            }
          }
          leaf peer-address {
            tailf:info "Use peer address (for BGP only)";
            type empty;
          }
        }

        // route-map * / set ip address prefix-list
        container address {
          tailf:info "Specify IP address";
          leaf prefix-list {
            tailf:info "Specify prefix-list";
            tailf:non-strict-leafref {
              path "../../../../../prefix-list/prefixes/name";
            }
            type string {
              tailf:info "WORD;;Prefix-list name to set ip address";
            }
          }
        }
      }

      // route-map * / set weight
      leaf weight {
        tailf:info "BGP weight for routing table";
        type uint32 {
          tailf:info "<0-65535>;;Weight value";
          range "0..65535";
        }
      }

      // route-map * / set origin
      leaf origin {
        tailf:info "BGP origin code";
        type enumeration {
          enum igp {
            tailf:info "local IGP";
          }
          enum incomplete {
            tailf:info "unknown heritage";
          }
        }
      }

      // route-map * / set as-path
      container as-path {
        tailf:info "Prepend string for a BGP AS-path attribute";
        container prepend {
          tailf:info "Prepend to the as-path";
          container as-container {
            tailf:cli-drop-node-name;
            leaf as-no {
              tailf:cli-drop-node-name;
              tailf:cli-multi-value;
              tailf:cli-disallow-value "last-as.*";
              type string {
                tailf:info "WORD;;<1-4294967295> or <1.0-XX.YY> AS number";
              }
            }
          }
          container last-as-cont {
            tailf:cli-drop-node-name;
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            leaf last-as {
              type uint16 {
                tailf:info "<1..10>;;number of last-AS prepends";
                range "1..10";
              }
            }
          }
        }
        container tag {
          tailf:info "Set the tag as an AS-path attribute";
          tailf:cli-full-command;
          presence true;
        }
      }

      // route-map * / set community
      container community {
        tailf:info "BGP community attribute";
        leaf-list community-number {
          tailf:cli-drop-node-name;
          tailf:cli-flat-list-syntax;
          ordered-by user;
          type union {
            type uint32 {
              tailf:info "<1-4294967295>;;community number";
              range "1..4294967295";
            }
            type string {
              tailf:info "aa:nn;;community number in aa:nn format";
              pattern "[0-9]+:[0-9]+";
            }
            type enumeration {
              enum additive {
                tailf:info "Add to the existing community";
              }
              enum internet {
                tailf:info "Internet (well-known community)";
              }
              enum local-AS {
                tailf:info "Do not send outside local AS "
                  +"(well-known community)";
              }
              enum no-advertise {
                tailf:info "Do not advertise to any peer "
                  +"(well-known community)";
              }
              enum no-export {
                tailf:info "Do not export to next AS "
                  +"(well-known community)";
              }
              enum none {
                tailf:info "No community attribute";
              }
            }
          }
        }
      }

      // route-map * / set local-preference
      container local-preference {
        tailf:info "BGP local preference path attribute";
        tailf:cli-delete-when-empty;
        presence true;
        leaf value {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<0-4294967295>;;Preference value";
          }
        }
      }

      // route-map * / set metric
      leaf metric {
        tailf:info "Metric value for destination routing protocol";
        type uint32 {
          tailf:info "<0-4294967295>;;Metric value or Bandwidth in "+
            "Kbits per second";
        }
      }

      // route-map * / set metric-type
      leaf metric-type {
        tailf:info "Type of metric for destination routing protocol";
        type enumeration {
          enum internal {
            tailf:info "Use IGP metric as the MED for BGP";
          }
          enum type-1 {
            tailf:info "OSPF external type 1 metric";
          }
          enum type-2 {
            tailf:info "OSPF external type 2 metric";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// banner
  /// ========================================================================

  container banner {
    tailf:info "Define a login banner";

    // banner exec
    leaf exec {
      tailf:info "Display a banner whenever an EXEC process in initiated";
      tailf:cli-no-value-on-delete;
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;Quoted string. Use \\r\\n for newline";
      }
    }

    // banner login
    leaf login {
      tailf:info "Set login banner";
      tailf:cli-no-value-on-delete;
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;Quoted string. Use \\r\\n for newline";
      }
    }

    // banner motd
    leaf motd {
      tailf:info "Display a message-of-the-day banner";
      tailf:cli-no-value-on-delete;
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;Quoted string. Use \\r\\n for newline";
      }
    }
  }


  /// ========================================================================
  /// class-map
  /// ========================================================================

  // class-map *
  list class-map {
    tailf:info "Configure MPF Class Map";
    tailf:cli-mode-name "config-cmap";
    tailf:cli-sequence-commands;
    key name;
    leaf name {
      tailf:cli-disallow-value "type|match-any|match-all";
      type string {
        tailf:info "WORD < 129 char;;class-map name";
      }
    }

    // class-map type
    leaf type {
      tailf:info "Specifies the type of class-map";
      tailf:cli-optional-in-sequence;
      tailf:cli-prefix-key;
      type enumeration {
        enum inspect {
          tailf:info "Configure a class-map of type inspect";
        }
        enum management {
          tailf:info "Configure a class-map of type Management";
        }
        enum regex {
          tailf:info "Configure a class-map of type REGEX";
        }
      }
    }

    // class-map <protocol>
    leaf protocol {
      when "../type = 'inspect'";
      tailf:cli-drop-node-name;
      tailf:cli-prefix-key;
      tailf:cli-optional-in-sequence;
      type enumeration {
        enum dns {
          tailf:info "Configure a class-map of type DNS";
        }
        enum ftp {
          tailf:info "Configure a class-map of type FTP";
        }
        enum h323 {
          tailf:info "Configure a class-map of type H323";
        }
        enum http {
          tailf:info "Configure a class-map of type HTTP";
        }
        enum im {
          tailf:info "Configure a class-map of type IM";
        }
        enum rtsp {
          tailf:info "Configure a class-map of type RTSP";
        }
        enum scansafe {
          tailf:info "Configure a class-map of type SCANSAFE";
        }
        enum sip {
          tailf:info "Configure a class-map of type SIP";
        }
      }
    }

    // class-map * <match-any|match-all>
    leaf prematch {
      tailf:cli-drop-node-name;
      tailf:cli-prefix-key;
      tailf:cli-optional-in-sequence;
      when "not(../type = 'management')" {
        tailf:dependency "../type";
      }
      type enumeration {
        enum match-all {
          tailf:info "Logical-AND all matching statements under this classmap";
        }
        enum match-any {
          tailf:info "Logical-OR all matching statements under this classmap";
        }
      }
    }

    // class-map * / description
    leaf description {
      tailf:info "Class-Map description";
      tailf:cli-break-sequence-commands;
      tailf:cli-multi-value;
      type string {
        tailf:info "LINE;;Description of this class-map (up to 200 "+
          "characters)";
      }
    }

    // class-map * / match
    container match {
      tailf:info "Configure classification criteria";

      // class-map * / match any
      leaf any {
        tailf:info "Any packets";
        type empty;
      }

      // class-map * / match access-list
      leaf access-list {
        tailf:info "Match an Access List";
        tailf:cli-full-command;
        tailf:cli-diff-dependency "../../../access-list/access-list-id";
        tailf:non-strict-leafref {
          path "../../../access-list/access-list-id/id";
        }
        type string {
          tailf:info "WORD;;Access List name";
        }
      }

      // class-map * / match dscp
      leaf-list dscp {
        tailf:info "Match DSCP in IP(v4) and IPv6 packets";
        tailf:cli-flat-list-syntax;
        tailf:cli-full-command;
        type dscp-type;
      }

      //FIXME class-map * / match flow
      //FIXME class-map * / match port

      // class-map * / match precedence
      leaf-list precedence {
        tailf:info "Match Precedence in IP(v4) and IPv6 packets";
        tailf:cli-flat-list-syntax;
        type precedence-type;
      }

      //FIXME class-map * / match rtp
      //FIXME class-map * / match tunnel-group

      // class-map * / match default-inspection-traffic
      leaf default-inspection-traffic {
        tailf:info "Match default inspection traffic";
        tailf:cli-full-command;
        type empty;
      }
    }
  }


  /// ========================================================================
  /// policy-map
  /// ========================================================================

  list policy-map {
    tailf:info "Configure QoS Policy Map";
    tailf:cli-mode-name "config-pmap";
    tailf:cli-sequence-commands;
    tailf:cli-diff-dependency "../flow-export";
    tailf:cli-diff-dependency "../class-map";
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;policy-map name";
      }
      tailf:cli-disallow-value
        "(type)|(http)|(im)|(imap)|(p2p)|(pop3)|(smtp)|(sunrpc)";
    }

    leaf type {
      tailf:info "type of the policy-map";
      tailf:cli-prefix-key;
      tailf:cli-optional-in-sequence;
      type enumeration {
        enum inspect {
          tailf:info "Configure a policy-map of type inspect";
        }
      }
    }

    leaf protocol {
      when "../type";
      tailf:cli-drop-node-name;
      tailf:cli-prefix-key;
      tailf:cli-optional-in-sequence;
      type enumeration {
        enum dcerpc {
          tailf:info "Configure a policy-map of type DCERPC";
        }
        enum dns {
          tailf:info "Configure a policy-map of type DNS";
        }
        enum esmtp {
          tailf:info "Configure a policy-map of type ESMTP";
        }
        enum ftp {
          tailf:info "Configure a policy-map of type FTP";
        }
        enum gtp {
          tailf:info "Configure a policy-map of type GTP";
        }
        enum h323 {
          tailf:info "Configure a policy-map of type H.323";
        }
        enum http {
          tailf:info "Configure a policy-map of type HTTP";
        }
        enum im {
          tailf:info "Configure a policy-map of type IM";
        }
        enum ip-options {
          tailf:info "Configure a policy-map of type IP-OPTIONS";
        }
        enum ipsec-pass-thru {
          tailf:info "Configure a policy-map of type IPSEC-PASS-THRU";
        }
        enum ipv6 {
          tailf:info "Configure a policy-map of type IPv6";
        }
        enum mgcp {
          tailf:info "Configure a policy-map of type MGCP";
        }
        enum netbios {
          tailf:info "Configure a policy-map of type NETBIOS";
        }
        enum radius-accounting {
          tailf:info "Configure a policy-map of type Radius Accounting";
        }
        enum rtsp {
          tailf:info "Configure a policy-map of type RTSP";
        }
        enum scansafe {
          tailf:info "Configure a policy-map of type SCANSAFE";
        }
        enum sip {
          tailf:info "Configure a policy-map of type SIP";
        }
        enum skinny {
          tailf:info "Configure a policy-map of type Skinny";
        }
      }
    }

    // policy-map * / description
    leaf description {
      tailf:cli-break-sequence-commands;
      tailf:info "Policy-Map description";
      tailf:cli-multi-value;
      type string {
        tailf:info "LINE;;Description of this policy-map "+
          "(up to 200 characters)";
        length "1..200";
      }
    }

    // policy-map * / parameters
    container parameters {
      tailf:info " Specify this keyword to enter policy parameters.";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-pmap-p";

      // policy-map * / parameters / message-length maximum
      container message-length {
        tailf:info "DNS message length";
        container maximum {
          tailf:info "Maximum value";

          // policy-map * / parameters / message-length maximum client
          leaf client {
            tailf:info "Message length config for DNS client";
            type union {
              type uint16 {
                tailf:info "<512-65535>;;Enter maximum DNS message length";
                range "512..65535";
              }
              type enumeration {
                enum auto {
                  tailf:info "Adjust maximum-length based on EDNS0 OPT RR";
                }
              }
            }
          }

          // policy-map * / parameters / message-length maximum ?
          leaf length {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<512-65535>;;Enter maximum DNS message length";
              range "512..65535";
            }
          }

          // policy-map * / parameters / message-length maximum server
          leaf server {
            tailf:info "Message length config for DNS server";
            type union {
              type uint16 {
                tailf:info "<512-65535>;;Enter maximum DNS message length";
                range "512..65535";
              }
              type enumeration {
                enum auto {
                  tailf:info "Adjust maximum-length based on EDNS0 OPT RR";
                }
              }
            }
          }
        }
      }

      // policy-map * / parameters / no tcp-inspection
      // policy-map * / parameters / tcp-inspection
      leaf tcp-inspection {
        tailf:info "Enables DNS on TCP";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
      }
    }

    // policy-map * / class *
    list class {
      tailf:info "policy criteria";
      tailf:cli-mode-name "config-pmap-c";
      tailf:cli-show-long-obu-diffs;
      ordered-by user;
      key name;
      leaf name {
        tailf:cli-disallow-value "type";
        tailf:cli-diff-dependency "../../../class-map";
        type union {
          type string {
            tailf:info "WORD;;class-map name";
          }
          type enumeration {
            enum class-default {
              tailf:info "System default class matching otherwise unclassified packet";
            }
          }
        }
      }

      // policy-map * / class * / type
      leaf type {
        tailf:info "Specifies the type of class-map";
        tailf:cli-prefix-key;
        type enumeration {
          enum inspect {
            tailf:info "Configure a class-map of type inspect";
          }
          enum management {
            tailf:info "Configure a class-map of type Management";
          }
          enum regex {
            tailf:info "Configure a class-map of type REGEX";
          }
        }
      }

      // policy-map * / class * / drop-connection
      container drop-connection {
        tailf:info "Drop connection";
        presence true;
        leaf log {
          tailf:info "Generate a log message";
          type empty;
        }
      }

      // policy-map * / class * / priority
      leaf priority {
        tailf:info "Strict Scheduling Priority for this Class";
        type empty;
      }

      // policy-map * / class * / set
      container set {
        tailf:info "Set QoS values";

        // policy-map * / class * / set connection
        container connection {
          tailf:info "Configure connection parameters";
          tailf:cli-compact-syntax;

          // policy-map * / class * / set connection conn-max
          leaf conn-max {
            tailf:info "Keyword to set the maximum number of all simultaneous"+
              " connections that are allowed.  Default is 0 which means "+
              "unlimited connections.";
            type uint32 {
              tailf:info "<0-2000000>;;Enter the maximum number of "+
                "simultaneous connections";
              range "0..2000000";
            }
          }

          // policy-map * / class * / set connection embryonic-conn-max
          leaf embryonic-conn-max {
            tailf:info "Keyword to set the maximum number of TCP embryonic "
              +"connections that are allowed. Default is 0 which means "
              +"unlimited connections.";
            type uint32 {
              tailf:info "<0-2000000>;;Enter the maximum number for all "
                +"simultaneous connections";
              range "0..2000000";
            }
          }

          // policy-map * / class * / set connection per-client-embryonic-max
          leaf per-client-embryonic-max {
            tailf:info "Keyword to set the maximum number of TCP embryonic "
              +"connections that are allowed per client machine. Default "
              +"is 0 which means unlimited connections.";
            type uint32 {
              tailf:info "<0-2000000>;;Enter the maximum number for all "
                +"simultaneous connections";
            }
          }

          // policy-map * / class * / set connection random-sequence-number
          leaf random-sequence-number {
            tailf:info "Enable/disable TCP sequence number randomization."
              +"Default is to enable TCP sequence number randomization";
            type enumeration {
              enum disable {
                tailf:info "Disable TCP sequence number randomization";
              }
              enum enable {
                tailf:info "Enable TCP sequence number randomization";
              }
            }
            default enable;
          }

          // policy-map * / class * / set connection timeout
          container timeout {
            tailf:info "Configure connection timeout parameters";

            // policy-map * / class * / set connection timeout idle
            container idle {
              tailf:info "Configure idle time after which a connection state will be closed.";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf time {
                tailf:cli-drop-node-name;
                type string {
                  tailf:info "0:0:0 | <0:0:1> - <1193:0:0>;;Idle time after which a connection state will be closed.";
                  pattern '[0-9]+:[0-9]+:[0-9]+';
                }
              }
              leaf reset {
                tailf:info "Send reset to TCP endpoints before timeout";
                type empty;
              }
            }
          }

          // policy-map * / class * / set connection advanced-options
          container advanced-options {
            tailf:info "Configure advanced connection parameters";

            // policy-map * / class * / set connection advanced-options tcp-state-bypass
            leaf tcp-state-bypass {
              tailf:info "Configure as TCP state bypass";
              type empty;
            }

            // policy-map * / class * / set connection advanced-options <tcp-map>
            leaf tcp-map {
              tailf:cli-drop-node-name;
              tailf:cli-disallow-value "tcp-state-bypass";
              tailf:non-strict-leafref {
                path "../../../../../../tcp-map/name";
              }
              type string {
                tailf:info "WORD;;Enter TCP map name";
              }
            }
          }
        }
      }

      // policy-map * / class * / police
      container police {
        tailf:info "Rate limit traffic for this class";

        // policy-map * / class * / police output
        container "output" {
          tailf:info "Police traffic in output direction";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          uses policy-map-class-police-grouping;
        }

        // policy-map * / class * / police input
        container "input" {
          tailf:info "Police traffic in input direction";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          uses policy-map-class-police-grouping;
        }
      }

      // policy-map * / class * / shape
      container shape {
        tailf:info "Traffic Shaping";
        presence true;

        // policy-map * / class * / shape average
        container average {
          tailf:info "configure token bucket: CIR (bps) [Bc (bits) "+
            "[Be (bits)]], send out Bc only per interval";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          choice average-choice {
            case a {
              leaf bit-rate {
                tailf:cli-drop-node-name;
                type uint32 {
                  tailf:info "<8000-max>;;Target Bit Rate (bits per second), the value "
                    +"needs to be a multiple of 8000";
                }
              }
              leaf bits-per-interval-sustained {
                tailf:cli-drop-node-name;
                type uint32 {
                  tailf:info "<256-154400000>;;bits per interval, sustained. Needs to be "
                    +"multiple of 128. Recommend not to configure it, the algorithm will "
                    +"find out the best value";
                  range "256..154400000";
                }
              }
              leaf bits-per-interval-excess {
                tailf:cli-drop-node-name;
                type uint32 {
                  tailf:info "<0-154400000>;;bits per interval, excess. Needs to be "
                    +"multiple of 128. Bc will be used if you don't configure it.";
                  range "0..154400000";
                }
              }
            }
            case b {
              leaf percent {
                tailf:info "% of interface bandwidth for Committed information rate";
                type percentage-type;
              }
              leaf burst-size-sustained {
                tailf:cli-incomplete-command;
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<10-2000>;;Sustained burst size in msec";
                  range "10..2000";
                }
              }
              leaf ms {
                tailf:info "milliseconds";
                type empty;
              }
              container bse {
                tailf:cli-drop-node-name;
                tailf:cli-flatten-container;
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands;
                leaf burst-size-excess {
                  tailf:cli-incomplete-command;
                  type uint16 {
                    tailf:info "<10-2000>;;Excess burst size in msec";
                    range "10..2000";
                  }
                }
                leaf ms {
                  tailf:info "milliseconds";
                  type empty;
                }
              }
            }
          }
        }
      }

      // policy-map * / class * / flow-export
      container flow-export {
        tailf:info "Configure filters for NetFlow events";

        // policy-map * / class * / flow-export event-type * destination *
        list event-type {
          tailf:info "Filter NetFlow records based on event-type";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-incomplete-command;
          key name;
          leaf name {
            type enumeration {
              enum all {
                tailf:info "All Events ";
              }
              enum flow-create {
                tailf:info "Flow Creation Event ";
              }
              enum flow-denied {
                tailf:info "Flow Denied Event ";
              }
              enum flow-teardown {
                tailf:info "Flow Teardown Event";
              }
              enum flow-update {
                tailf:info "Flow Update Event";
              }
            }
          }
          leaf-list destination {
            tailf:info "Export specified NetFlow events to destination";
            tailf:cli-flat-list-syntax;
            type inet:host {
              tailf:info "Hostname or A.B.C.D;;Destination IP address or name";
            }
          }
        }
      }

      // policy-map * / class * / service-policy
      leaf service-policy {
        tailf:info "Configure Flow Next";
        tailf:cli-full-command;
        tailf:non-strict-leafref {
          path "../../../policy-map/name";
        }
        type string {
          tailf:info "WORD;;Policy map";
        }
      }

      // policy-map * / class * / inspect
      container inspect {
        tailf:info "Protocol inspection services";

        // policy-map * / class * / inspect dns
        container dns {
          presence true;
          leaf policy-map-name {
            tailf:cli-drop-node-name;
            tailf:non-strict-leafref {
              path "../../../../../policy-map/name";
            }
            type string {
              tailf:info "WORD < 129 char;;Optional DNS type policy-map name";
            }
          }
        }

        // policy-map * / class * / inspect ftp
        container ftp {
          presence true;
          leaf strict {
            tailf:info "Prevent web browsers from sending embedded "
              +"commands in FTP requests";
            type empty;
          }
        }

        // policy-map * / class * / inspect h323
        container h323 {
          leaf h225 {
            tailf:info "Enable H.225 signalling inspection";
            type empty;
          }
          leaf ras {
            tailf:info "Enable RAS inspection";
            type empty;
          }
        }

        // policy-map * / class * / inspect netbios
        container netbios {
          presence true;
        }

        // policy-map * / class * / inspect rsh
        leaf rsh {
          type empty;
        }

        // policy-map * / class * / inspect rtsp
        leaf rtsp {
          type empty;
        }

        // policy-map * / class * / inspect skinny
        container skinny {
          presence true;
        }

        // policy-map * / class * / inspect esmtp
        container esmtp {
          presence true;
        }

        // policy-map * / class * / inspect sqlnet
        leaf sqlnet {
          type empty;
        }

        // policy-map * / class * / inspect sunrpc
        leaf sunrpc {
          type empty;
        }

        // policy-map * / class * / inspect tftp
        leaf tftp {
          type empty;
        }

        // policy-map * / class * / inspect sip
        container sip {
          presence true;
        }

        // policy-map * / class * / inspect xdmcp
        leaf xdmcp {
          type empty;
        }

        // policy-map * / class * / inspect icmp
        container icmp {
          presence true;
          leaf error {
            type empty;
          }
        }

        // policy-map * / class * / inspect http
        container http {
          presence true;
        }

        // policy-map * / class * / inspect ip-options
        container ip-options {
          presence true;
        }

        // policy-map * / class * / inspect pptp
        container pptp {
          presence true;
        }
      }
    }
  }


  /// ========================================================================
  /// config-register
  /// ========================================================================

  leaf config-register {
    tailf:info "Define the configuration register";
    type string {
      tailf:info "<0x0-0xFFFF>;;Config register number";
      pattern "[0-9xXa-fA-F].*";
    }
  }


  /// ========================================================================
  /// clock
  /// ========================================================================

  container clock {
    tailf:info "Configure time-of-day clock";

    // clock summer-time
    container summer-time {
      tailf:info "Configure summer (daylight savings) time";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf zone {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        tailf:cli-disallow-value "date|recurring";
        type string {
          tailf:info "WORD;;name of time zone in summer";
          length "1..7";
        }
      }
      choice summer-choice {
        case date-case {
          leaf date {
            tailf:info "Configure absolute summer time";
            type empty;
          }
        }
        case recurring-case {
          leaf recurring {
            tailf:info "Configure recurring summer time";
            type empty;
          }
          leaf start {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type union {
              type uint8 {
                tailf:info "<1-4>;;Week number to start";
                range "1..4";
              }
              type enumeration {
                enum first {
                  tailf:info "First week of the month";
                }
                enum last {
                  tailf:info "Last week of the month";
                }
              }
            }
          }
          leaf start-day {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type weekday-type {
              tailf:info "DAY;;Weekday to start";
            }
          }
          leaf start-month {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type month-type {
              tailf:info "MONTH;;Month to start";
            }
          }
          leaf start-time {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type hhmm-type {
              tailf:info "hh:mm;;Time to start (hh:mm)";
            }
          }
          leaf end {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type union {
              type uint8 {
                tailf:info "<1-4>;;Week number to end";
                range "1..4";
              }
              type enumeration {
                enum first {
                  tailf:info "First week of the month";
                }
                enum last {
                  tailf:info "Last week of the month";
                }
              }
            }
          }
          leaf end-day {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type weekday-type {
              tailf:info "DAY;;Weekday to end";
            }
          }
          leaf end-month {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type month-type {
              tailf:info "MONTH;;Month to end";
            }
          }
          leaf end-time {
            tailf:cli-drop-node-name;
            type hhmm-type {
              tailf:info "hh:mm;;Time to end (hh:mm)";
            }
          }
        }
      }
    }

    // clock timezone
    container timezone {
      tailf:info "Configure time zone";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf zone {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type string {
          tailf:info "WORD < 8 char;;name of time zone";
          length "1..7";
        }
      }
      leaf hours {
        tailf:cli-drop-node-name;
        type int8 {
          tailf:info "<-23 - 23>;;Hours offset from UTC";
          range "-23..23";
        }
      }
      leaf minutes {
        tailf:cli-drop-node-name;
        type int8 {
          tailf:info "<0-59>;;Minutes ofset from UTC";
          range "0..59";
        }
        default 0;
      }
    }
  }


  /// ========================================================================
  /// logging
  /// ========================================================================

  container logging {
    tailf:info "Configure logging levels, recipients and other options";

    // logging enable
    leaf enable {
      tailf:info "Enable logging to all output supported destinations";
      tailf:cli-full-command;
      type empty;
    }

    // logging timestamp
    leaf timestamp {
      tailf:info "Enable logging timestamp on syslog messages";
      tailf:cli-full-command;
      type empty;
    }

    // logging permit-hostdown
    leaf permit-hostdown {
      tailf:info "Allow new connection even if TCP syslog server is down";
      tailf:cli-full-command;
      type empty;
    }

    // logging list *
    list "list" {
      tailf:info "Specify logging event list";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key name;
      leaf name {
        type string {
          tailf:info "WORD < 32 char;;Specify the logging event list";
        }
      }

      // logging list * message *
      list message {
        tailf:info "Specify a syslog message id or range";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key id;
        leaf id {
          type string {
            tailf:info "<start>[-<end>];;Enter a specific id or a range of ids "+
              "(100000 to 999999)";
            pattern "[0-9]+.*";
          }
        }
      }

      // logging list * level
      leaf level {
        tailf:info "Specify a syslog level";
        type logging-level-type;
      }

      // logging list * class
      leaf class {
        tailf:info "Specify logging event class";
        type string {
          tailf:info "WORD;;logging event class name";
        }
      }
    }

    // logging class *
    list class {
      tailf:info "Specify logging event class";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-incomplete-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;;;Specify the logging class name";
        }
      }
      leaf destination {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type enumeration {
          enum asdm {
            tailf:info "Set ASDM logging level";
          }
          enum buffered {
            tailf:info "Set buffer logging level";
          }
          enum console {
            tailf:info "Set console logging level";
          }
          enum history {
            tailf:info "Set SNMP logging level";
          }
          enum mail {
            tailf:info "Set mail logging level";
          }
          enum monitor {
            tailf:info "Set tty logging level";
          }
          enum trap {
            tailf:info "Set syslog server logging level";
          }
        }
      }
      leaf level {
        tailf:cli-drop-node-name;
        type logging-level-type;
      }
    }

    // logging buffer-size
    leaf buffer-size {
      tailf:info "Specify logging memory buffer size";
      type uint32 {
        tailf:info "<4096-52428800>;;Specify logging buffer size in bytes";
        range "4096..52428800";
      }
      default 4096;
    }

    // logging console
    leaf console {
      tailf:info "Set console logging level or list";
      tailf:cli-full-command;
      tailf:cli-diff-dependency "../list";
      type logging-type;
    }

    // logging monitor
    leaf monitor {
      tailf:info "Specify that syslog messages appear on Telnet" +
        " sessions to the Firewall console";
      tailf:cli-full-command;
      tailf:cli-diff-dependency "../list";
      type logging-type;
    }

    // logging mail
    leaf mail {
      tailf:info "Set mail logging level or list";
      tailf:cli-full-command;
      tailf:cli-diff-dependency "../list";
      type logging-type;
    }

    // logging buffered
    leaf buffered {
      tailf:info "Set buffer logging level or list";
      tailf:cli-full-command;
      tailf:cli-diff-dependency "../list";
      type logging-type;
    }

    // logging trap
    leaf trap {
      tailf:info "Set logging level or list for syslog server";
      tailf:cli-full-command;
      tailf:cli-diff-dependency "../list";
      tailf:cli-diff-delete-before "../list" {
        tailf:cli-when-target-delete;
      }
      type logging-type;
    }

    // logging history
    leaf history {
      tailf:info "Set the SNMP message level or list for sending syslog traps";
      tailf:cli-full-command;
      tailf:cli-diff-dependency "../list";
      type logging-type;
    }

    // logging asdm
    leaf asdm {
      tailf:info "Set logging level or list for ASDM";
      tailf:cli-full-command;
      tailf:cli-diff-dependency "../list";
      type logging-type;
    }

    // logging facility
    leaf facility {
      tailf:info "Specify the syslog facility, the default is 20";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<16-23>;;Eight facilities 16 through 23, the default is 20";
        range "16..23";
      }
    }

    // logging device-id
    container device-id {
      tailf:info "Specify the device-id to be included in all non-EMBLEM "+
        "formatted syslog messages";
      choice device-id-choice {

        // logging device-id hostname
        leaf hostname {
          tailf:info "Specifies to use the hostname to uniquely identify "+
            "syslog messages from the system";
          type empty;
        }

        // logging device-id cluster-id
        leaf cluster-id {
          tailf:info "Specifies to use the local cluster unit name to "+
            "identifymessages from different cluster units";
          type empty;
        }

        // logging device-id context-name
        leaf context-name {
          tailf:info "Specifies to use the name of the current security "+
            "context to uniquely identify syslog messages from the system";
          type empty;
        }

        // logging device-id string
        leaf string {
          tailf:info "Specifies the text string to uniquely identify the "+
            "syslog messages from the system";
          type string {
            tailf:info "WORD;;Specify the text string, <= 16 characters";
          }
        }
      }
    }

    // logging queue
    leaf queue {
      tailf:info "Specify queue size for storing syslog messages, " +
        "default is 512, 0 means unlimited (subject to available memory)";
      type uint16 {
        tailf:info "The length of log queue, 512 is default 0 means maximum " +
          "permitted queue size. Max queue size on ASA-5505 is 1024, "+
          "on ASA-5510 is 2048 and 8192 on all other platforms";
        range "0..8192";
      }
    }

    // logging host *
    list host {
      tailf:info "Send syslog messages to a host";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key "interface host";
      leaf interface {
        tailf:cli-disallow-value "esm|alarm|buffered|facility"+
          "|history|rate-limit|source-interface|host|console";
        tailf:cli-diff-dependency "../../../interface";
        tailf:cli-diff-dependency "../../../interface/Management/nameif";
        tailf:cli-diff-dependency "../../../interface/Ethernet/nameif";
        tailf:cli-diff-dependency "../../../interface/FastEthernet/nameif";
        tailf:cli-diff-dependency "../../../interface/GigabitEthernet/nameif";
        tailf:cli-diff-dependency "../../../interface/TenGigabitEthernet/nameif";
        tailf:cli-diff-dependency "../../../interface/Vlan/nameif";
        tailf:cli-diff-dependency "../../../interface/Port-channel/nameif";
        tailf:cli-diff-dependency "../../../interface/Port-channel-subif/Port-channel/nameif";
        tailf:cli-diff-dependency "../../../interface/BVI/nameif";
        tailf:cli-diff-dependency "../../../interface/Redundant/nameif";
        tailf:cli-diff-dependency "../../../interface/allocated/nameif";
        type nameif-type;
      }
      leaf host {
        type inet:host {
          tailf:info "Hostname or A.B.C.D;;Specify the IP address or name of "+
            "the syslog server.";
        }
      }

      // logging host * <protocol/port>
      leaf protocol-port {
        tailf:cli-drop-node-name;
        tailf:cli-disallow-value "format";
        type string {
          tailf:info "WORD;;Enter <protocol/port>.";
        }
      }

      // logging host * secure
      leaf secure {
        tailf:info "Establish secure TLS/SSL connection with TLS/SSL capable Syslog Server";
        type empty;
      }

      // logging host * format
      container format {
        tailf:info "Enable EMBLEM format logging, available only for udp "+
          "syslog messages";
        leaf emblem {
          tailf:info "Enable EMBLEM format logging, available only for udp "+
            "syslog messages";
          type empty;
        }
      }
    }

    // logging rate-limit *
    list rate-limit {
      tailf:info "Specify logging rate-limit parameters";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      key level;
      leaf level {
        tailf:cli-expose-key-name;
        tailf:info "Specify logging level for rate-limit";
        type union {
          type uint8 {
            tailf:info "<0-7>;;Enter syslog level (0 - 7)";
            range "0..7";
          }
          type logging-level-type;
        }
      }
      choice rate-limit-choice {
        leaf unlimited {
          tailf:info "Specify unlimited option for rate-limit";
          tailf:cli-prefix-key;
          type empty;
        }
        case num-limited {
          leaf num {
            tailf:cli-drop-node-name;
            tailf:cli-prefix-key;
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<1-2147483647>;;Specify logging rate-limit number";
              range "1..2147483647";
            }
          }
          leaf interval {
            tailf:cli-drop-node-name;
            tailf:cli-prefix-key;
            tailf:cli-optional-in-sequence;
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<1-2147483647>;;Specify logging rate-limit interval";
              range "1..2147483647";
            }
          }
        }
      }
    }

    // logging message no-list *
    // (on device: no logging message *)
    container message {
      tailf:info "Specify a message to be allowed";
      list no-list {
        tailf:info "'no logging message' list entry";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key id;
        leaf id {
          type uint32 {
            tailf:info "<100000-999999>;;Specify a message number";
            range "100000..999999";
          }
        }
      }

      // logging message * level
      list yes-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key id;
        leaf id {
          type uint32 {
            tailf:info "<100000-999999>;;Specify a message number";
            range "100000..999999";
          }
        }
        leaf level {
          tailf:info "Specify a syslog level";
          type logging-level-type;
        }
      }
    }
  }


  /// ========================================================================
  /// ntp
  /// ========================================================================

  container ntp {
    tailf:info "Configure NTP";
    tailf:cli-diff-dependency "../interface";
    tailf:cli-diff-dependency "../interface/Management/nameif";
    tailf:cli-diff-dependency "../interface/Ethernet/nameif";
    tailf:cli-diff-dependency "../interface/FastEthernet/nameif";
    tailf:cli-diff-dependency "../interface/GigabitEthernet/nameif";
    tailf:cli-diff-dependency "../interface/TenGigabitEthernet/nameif";
    tailf:cli-diff-dependency "../interface/Vlan/nameif";
    tailf:cli-diff-dependency "../interface/Port-channel/nameif";
    tailf:cli-diff-dependency "../interface/Port-channel-subif/Port-channel/nameif";
    tailf:cli-diff-dependency "../interface/BVI/nameif";
    tailf:cli-diff-dependency "../interface/Redundant/nameif";
    tailf:cli-diff-dependency "../interface/allocated/nameif";

    // ntp server *
    list server {
      tailf:info "Configure NTP server";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      key ip-address;
      leaf ip-address {
        type host-type {
          tailf:info "Hostname or A.B.C.D;;IP address of peer";
        }
      }

      // ntp server * key
      leaf key {
        tailf:cli-break-sequence-commands;
        tailf:info "Configure peer authentication key";
        type uint32 {
          tailf:info "<1-4294967295>;;Peer key number";
          range "1..4294967295";
        }
      }

      // ntp server * source
      container source {
        tailf:info "Interface for source address";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        uses interface-name-grouping;
      }

      // ntp server * prefer
      leaf prefer {
        tailf:info "Prefer this peer when possible";
        type empty;
      }
    }

    // ntp authentication-key *
    list authentication-key {
      tailf:info "Authentication key for trusted time sources";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      key id;
      leaf id {
        type uint32 {
          tailf:info "<1-4294967295>;;Key number";
          range "1..4294967295";
        }
      }
      container md5 {
        tailf:info "MD5 authentication";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        uses password-08-grouping {
          refine "secret" {
            tailf:meta-data "secret" {
              tailf:meta-value " md5 <SECRET>";
            }
          }
        }
      }
    }

    // ntp authenticate
    leaf authenticate {
      tailf:info "Authenticate time sources";
      tailf:cli-full-command;
      type empty;
    }

    // ntp trusted-key *
    list trusted-key {
      tailf:info "Key numbers for trusted time sources";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key id;
      leaf id {
        type uint32 {
          tailf:info "<1-4294967295>;;Key number";
          range "1..4294967295";
        }
      }
    }
  }


  /// ========================================================================
  /// privilege
  /// ========================================================================

  container privilege {
    tailf:info "Configure privilege levels for commands";

    // privilege *
    list command-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-show-long-obu-diffs;
      tailf:cli-no-key-completion;
      tailf:cli-suppress-key-abbreviation;
      tailf:cli-no-match-completion;
      ordered-by user;
      key command;
      leaf command {
        tailf:cli-multi-word-key;
        type string {
          tailf:info "LINE;;privilege line";
        }
      }
    }
  }


  /// ========================================================================
  /// vpdn
  /// ========================================================================

  container vpdn {
    tailf:info "Configure VPDN feature";

    // vpdn group
    // vpdn username

  }


  /// ========================================================================
  /// tftp-server
  /// ========================================================================

  list tftp-server {
    tailf:info "Provide TFTP service for netload requests";
    tailf:cli-suppress-mode;
    tailf:cli-delete-when-empty;
    tailf:cli-compact-syntax;
    tailf:cli-sequence-commands;
    tailf:cli-incomplete-command;
    key name;
    leaf name {
      tailf:cli-diff-dependency "../../interface";
      tailf:cli-diff-dependency "../../interface/Management/nameif";
      tailf:cli-diff-dependency "../../interface/Ethernet/nameif";
      tailf:cli-diff-dependency "../../interface/FastEthernet/nameif";
      tailf:cli-diff-dependency "../../interface/GigabitEthernet/nameif";
      tailf:cli-diff-dependency "../../interface/TenGigabitEthernet/nameif";
      tailf:cli-diff-dependency "../../interface/Vlan/nameif";
      tailf:cli-diff-dependency "../../interface/Port-channel/nameif";
      tailf:cli-diff-dependency "../../interface/Port-channel-subif/Port-channel/nameif";
      tailf:cli-diff-dependency "../../interface/BVI/nameif";
      tailf:cli-diff-dependency "../../interface/Redundant/nameif";
      tailf:cli-diff-dependency "../../interface/allocated/nameif";
      type nameif-type;
    }

    leaf server {
      tailf:cli-drop-node-name;
      type union {
        type inet:host {
          tailf:info "Hostname or A.B.C.D;;The IP address or name of the "+
            "TFTP server";
        }
        type inet:ipv6-address {
          tailf:info "Hostname or X:X:X:X::X;;The IPv6 address or name of the "+
            "TFTP server";
        }
      }
    }

    leaf filename {
      tailf:cli-drop-node-name;
      type string {
        tailf:info "WORD < 127 char;;The path and filename of the "+
          "configuration file";
      }
    }
  }


  /// ========================================================================
  /// zone
  /// ========================================================================

  container zone {
    tailf:info "FW with zoning";

    // zone *
    list zone-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Symbolic name of the zone";
        }
      }
    }
  }


  /// ========================================================================
  /// aaa-server
  /// ========================================================================

  list aaa-server {
    tailf:info "Configure a AAA server group or a AAA server";
    tailf:cli-mode-name "config-aaa-server-group";
    tailf:cli-incomplete-command;
    tailf:cli-explicit-exit;
    key name;
    leaf name {
      type string {
        tailf:info "WORD < 257 char;;Enter a AAA server group tag";
      }
    }

    // aaa-server * protocol
    leaf protocol {
      tailf:info "Enter the protocol for a AAA server group";
      tailf:cli-hide-in-submode;
      tailf:cli-full-command;
      type enumeration {
        enum http-form {
          tailf:info "Protocol HTTP form-based";
        }
        enum kerberos {
          tailf:info "Protocol Kerberos";
        }
        enum ldap {
          tailf:info "Protocol LDAP";
        }
        enum radius {
          tailf:info "Protocol RADIUS";
        }
        enum sdi {
          tailf:info "Protocol SDI";
        }
        enum tacacs+ {
          tailf:info "Protocol TACACS+";
        }
      }
    }

    // aaa-server * / interim-accounting-update
    container interim-accounting-update {
      tailf:info "Enter this keyword to enable Interim accounting update";
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      presence true;
      leaf periodic {
        tailf:info "Enter this keyword to specify the interim accounting period";
        type uint8 {
          tailf:info "<1-120>;;Number of hours";
          range "1..120";
        }
      }
    }

    // aaa-server * / reactivation-mode
    container reactivation-mode {
      tailf:info "Specify the method by which failed servers are reactivated";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf mode {
        tailf:cli-drop-node-name;
        type enumeration {
          enum timed {
            tailf:info "Failed servers will be reactivated after 30 seconds of down time";
          }
          enum depletion {
            tailf:info "Failed servers will remain inactive until all other servers in this group are inactive";
          }
        }
        default depletion;
      }
      leaf deadtime {
        tailf:info "Specify the amount of time that will elapse between the disabling of the last"
          +" server in the group and the subsequent re-enabling of all servers";
        when "../mode = 'depletion'";
        type uint16 {
          tailf:info "<0-1440>;;Number of minutes (0-1440). Default 10";
          range "0..1440";
        }
        default 10;
      }
    }

    // aaa-server * / max-failed-attempts
    leaf max-failed-attempts {
      tailf:info "Specify the maximum number of failures that will be allowed for"
        +" any server in the group before that server is deactivated";
      type uint8 {
        tailf:info "<1-5>;;Maximum number of failures (1-5)";
        range "1..5";
      }
    }

    // aaa-server * / dynamic-authorization
    container dynamic-authorization {
      tailf:info "Enter this keyword to specify dynamic-authorization mode";
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      presence true;
      leaf port {
        tailf:info "Enter this keyword to configure a port for dynamic-authorization";
        type uint16 {
          tailf:info "<1024-65535>;;Listening port for dynamic authorization from Radius servers. Default port 1700.";
          range "1024..65535";
        }
        default 1700;
      }
    }
  }

  // aaa-server * host *
  container aaa-server-host-conf {
    tailf:cli-drop-node-name;
    list aaa-server {
      tailf:info "Configure a AAA server group or a AAA server";
      tailf:cli-mode-name "config-aaa-server-host";
      tailf:cli-explicit-exit;
      tailf:cli-full-command;
      key "name interface host";
      leaf name {
        tailf:non-strict-leafref {
          path "../../../aaa-server/name";
        }
        type string {
          tailf:info "WORD < 257 char;;Enter a AAA server group tag";
        }
      }
      leaf interface {
        tailf:cli-diff-dependency "../../../interface";
        tailf:cli-diff-dependency "../../../interface/Management/nameif";
        tailf:cli-diff-dependency "../../../interface/Ethernet/nameif";
        tailf:cli-diff-dependency "../../../interface/FastEthernet/nameif";
        tailf:cli-diff-dependency "../../../interface/GigabitEthernet/nameif";
        tailf:cli-diff-dependency "../../../interface/TenGigabitEthernet/nameif";
        tailf:cli-diff-dependency "../../../interface/Vlan/nameif";
        tailf:cli-diff-dependency "../../../interface/Port-channel/nameif";
        tailf:cli-diff-dependency "../../../interface/Port-channel-subif/Port-channel/nameif";
        tailf:cli-diff-dependency "../../../interface/BVI/nameif";
        tailf:cli-diff-dependency "../../../interface/Redundant/nameif";
        tailf:cli-diff-dependency "../../../interface/allocated/nameif";
        type string {
          tailf:info "WORD;;Interface name surrounded by (), e.g. '(inside)'";
          pattern '\(.*\)';
        }
      }
      leaf host {
        tailf:cli-expose-key-name;
        tailf:info "Enter this keyword to specify the IP address for the server";
        type inet:host {
          tailf:info "Hostname or A.B.C.D;;Enter an IP address or a name";
        }
      }

      // aaa-server * host * / retry-interval
      leaf retry-interval {
        tailf:info "Specify the amount of time between retry attempts";
        type uint8 {
          tailf:info "<1-10>;;Number of seconds (1 - 10)";
          range "1..10";
        }
      }

      // aaa-server * host * / timeout
      leaf timeout {
        tailf:info "Specify the maximum time to wait for response from configured server";
        type uint16 {
          tailf:info "<1-300>;;Number of seconds (1 - 300)";
          range "1..300";
        }
      }

      // aaa-server * host * / ldap-base-dn
      leaf ldap-base-dn {
        tailf:info "Specify the location to begin searching in the LDAP hierarchy";
        type string {
          tailf:info "LINE < 129 char;;The location to begin searching in the LDAP hierarchy";
        }
      }

      // aaa-server * host * / ldap-group-base-dn
      leaf ldap-group-base-dn {
        tailf:info "Specify the location to begin searching in the LDAP hierarchy for 'show ad-groups'";
        type string {
          tailf:info "LINE < 129 char;;The location to begin searching in the LDAP hierarchy";
        }
      }

      // aaa-server * host * / ldap-scope
      leaf ldap-scope {
        tailf:info "Specify the extent of the search in the LDAP hierarchy";
        type enumeration {
          enum onelevel {
            tailf:info "Search only one level beneath the Base DN";
          }
          enum subtree {
            tailf:info "Search all levels beneath the Base DN";
          }
        }
        default onelevel;
      }

      // aaa-server * host * / ldap-naming-attribute
      leaf ldap-naming-attribute {
        tailf:info "Specify the Relative Distinguished Name attribute that"
          +" uniquely identifies an entry on the LDAP server";
        type string {
          tailf:info "WORD < 129 char;;Specify the Relative Distinguished Name"
            +" attribute that uniquely identifies an entry on the LDAP server";
        }
      }

      // aaa-server * host * / ldap-login-password
      container ldap-login-password {
        tailf:info "Specify password to be used to bind to the LDAP server";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        uses password-08-grouping {
          refine "secret" {
            tailf:meta-data "secret" {
              tailf:meta-value " ldap-login-password <SECRET>";
            }
          }
        }
      }

      // aaa-server * host * / ldap-over-ssl
      container ldap-over-ssl {
        tailf:info "Specify if an SSL connection is needed to the LDAP server";
        leaf enable {
          tailf:info "Require an SSL connection to the LDAP server";
          type empty;
        }
      }

      // aaa-server * host * / ldap-login-dn
      leaf ldap-login-dn {
        tailf:info "Specify the DN to be used to bind to the LDAP server";
        type string {
          tailf:info "LINE < 129 char;;The DN used to bind to the LDAP server";
        }
      }

      // aaa-server * host * / ldap-attribute-map
      leaf ldap-attribute-map {
        tailf:info "Specify the name of the LDAP attribute mapping table";
        tailf:non-strict-leafref {
          path "../../../ldap/attribute-map/name";
        }
        type string {
          tailf:info "WORD < 64 char;;LDAP attribute mapping table name";
        }
      }

      // aaa-server * host * / key
      container "key" {
        tailf:info "Specify the secret used to authenticate the NAS to the AAA server";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        uses password-08-grouping {
          refine "secret" {
            tailf:meta-data "secret" {
              tailf:meta-value " key <SECRET>";
            }
          }
        }
      }

      // aaa-server * host * / radius-common-pw
      leaf radius-common-pw {
        tailf:info "Specify a common password for all RADIUS authorization transactions";
        type string {
          tailf:info "WORD < 129 char;;Enter an alphanumeric string "
            + "up to 128 characters";
          length "1..128";
        }
      }

      // aaa-server * host * / server-port
      leaf server-port {
        tailf:info "Specify the port number to be used for AAA operations";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<0-65535>;;Enter port number (0 - 65535)";
        }
      }

      // aaa-server * host * / server-type
      leaf server-type {
        tailf:info "Specify the vendor of the LDAP server";
        type enumeration {
          enum auto-detect {
            tailf:info "Specify the vendor of the LDAP server is auto-detected";
          }
          enum microsoft {
            tailf:info "Specify the vendor of the LDAP server is Microsoft";
          }
          enum novell {
            tailf:info "Specify the vendor of the LDAP server is Novell";
          }
          enum openldap {
            tailf:info "Specify the vendor of the LDAP server is OpenLDAP";
          }
          enum sun {
            tailf:info "Specify the vendor of the LDAP server is Sun";
          }
        }
      }

      // aaa-server * host * / authentication-port
      leaf authentication-port {
        tailf:info "Specify the port number to be used for authentication";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<0-65535>;;Enter port number (0 - 65535)";
        }
      }

      // aaa-server * host * / accounting-port
      leaf accounting-port {
        tailf:info "Specify the port number to be used for accounting";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<0-65535>;;Enter port number (0 - 65535)";
        }
      }
    }
  }


  /// ========================================================================
  /// aaa
  /// ========================================================================

  container aaa {
    tailf:info "Authentication, Authorization and Accounting.";

    // aaa authentication
    container authentication {
      tailf:info "Authentication configurations parameters.";
      tailf:cli-diff-dependency "../../aaa-server";

      // aaa authentication ssh
      container ssh {
        tailf:info "SSH";
        uses aaa-authentication-console-grouping;
      }

      // aaa authentication telnet
      container telnet {
        tailf:info "Telnet";
        uses aaa-authentication-console-grouping;
      }

      // aaa authentication http
      container http {
        tailf:info "HTTP";
        uses aaa-authentication-console-grouping;
      }

      // aaa authentication enable
      container enable {
        tailf:info "Set authentication list for enable.";
        uses aaa-authentication-console-grouping;
      }

      // aaa authentication serial
      container serial {
        tailf:info "Serial";
        uses aaa-authentication-console-grouping;
      }

      // aaa authentication login-history
      choice login-history-choice {
        // no aaa authentication login-history
        leaf login-history {
          tailf:info "Configure login history reporting for administrators";
          tailf:cli-boolean-no;
          tailf:cli-incomplete-command;
          tailf:cli-full-no;
          type boolean;
        }
        // aaa authentication login-history
        container login-history-duration {
          tailf:cli-drop-node-name;
          container login-history {
            tailf:info "Configure login history reporting for administrators";
            tailf:cli-incomplete-no;
            presence true;
            leaf duration {
              tailf:info "The number of days for which the event history is maintained";
              type uint16 {
                tailf:info "<1-365>;;Number of days";
                range "1..365";
              }
              default 90;
            }
          }
        }
      }
    }

    // aaa authorization
    container authorization {
      tailf:info "Configure user authorization parameters";

      // aaa authorization command
      container command {
        tailf:info "Specify this keyword to allow command authorization "+
          "to be configured for all administrators on all consoles";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf server_group {
          tailf:cli-drop-node-name;
          tailf:cli-optional-in-sequence;
          tailf:cli-disallow-value "LOCAL";
          tailf:code-name "aaa_server_group";
          type string {
            tailf:info "WORD;;Specify the name of a TACACS+ aaa-server "+
              "group to be used for command authorization";
          }
        }
        leaf LOCAL {
          tailf:info "Predefined server tag for AAA protocol 'local'";
          type empty;
        }
      }

      // aaa authorization exec
      container exec {
        tailf:info "Perform administrative authorization for console "+
          "connections(ssh, http, telnet and enable) configured for "+
          "authentication to RADIUS, LDAP, TACACS or LOCAL authentication "+
          "servers.";

        // aaa authorization exec authentication-server auto-enable
        container authentication-server {
          tailf:info "Use authenticating servers";
          leaf auto-enable {
            tailf:info "Allow authenticated users with sufficient privileges "+
              "to automatically enter privileged EXEC mode on login";
            type empty;
          }
        }
      }
    }

    // aaa accounting
    container accounting {
      tailf:info "Configure user accounting parameters";

      // aaa accounting enable console
      container enable {
        tailf:info "Enable";
        uses aaa-accounting-console-grouping;
      }

      // aaa accounting ssh console
      container ssh {
        tailf:info "SSH";
        uses aaa-accounting-console-grouping;
      }

      // aaa accounting telnet console
      container telnet {
        tailf:info "Telnet";
        uses aaa-accounting-console-grouping;
      }

      // aaa accounting serial console
      container serial {
        tailf:info "Serial";
        uses aaa-accounting-console-grouping;
      }

      // aaa accounting command
      container command {
        tailf:info "Specify this keyword to allow command accounting to be "+
          "configured for all administrators on all consoles";
        tailf:cli-compact-syntax;
        leaf privilege {
          tailf:info "Specify this keyword to set command privilege levels to track";
          type uint8 {
            tailf:info "<1-15>;;Privilege level to track (1 - 15)";
            range "1..15";
          }
        }
        leaf server_group {
          tailf:cli-drop-node-name;
          tailf:cli-disallow-value "privilege";
          tailf:code-name "aaa_server_group";
          tailf:non-strict-leafref {
            path "../../../../aaa-server/name";
          }
          type string {
            tailf:info "WORD;;Specify the name of TACACS+ (only) aaa-server "+
              "group to be used for command accounting";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// route
  /// ========================================================================

  list route {
    tailf:info "Configure a static route for an interface";
    tailf:cli-suppress-mode;
    tailf:cli-delete-when-empty;
    tailf:cli-compact-syntax;
    key "id net net-mask gw";
    leaf id {
      tailf:cli-diff-dependency "../../interface";
      tailf:cli-diff-dependency "../../interface/Management/nameif";
      tailf:cli-diff-dependency "../../interface/Ethernet/nameif";
      tailf:cli-diff-dependency "../../interface/FastEthernet/nameif";
      tailf:cli-diff-dependency "../../interface/GigabitEthernet/nameif";
      tailf:cli-diff-dependency "../../interface/TenGigabitEthernet/nameif";
      tailf:cli-diff-dependency "../../interface/Vlan/nameif";
      tailf:cli-diff-dependency "../../interface/Port-channel/nameif";
      tailf:cli-diff-dependency "../../interface/Port-channel-subif/Port-channel/nameif";
      tailf:cli-diff-dependency "../../interface/BVI/nameif";
      tailf:cli-diff-dependency "../../interface/Redundant/nameif";
      tailf:cli-diff-dependency "../../interface/allocated/nameif";
      type nameif-type;
    }
    leaf net {
      type inet:host {
        tailf:info "Hostname or A.B.C.D;;The foreign network for this route, 0 means default";
      }
    }
    leaf net-mask {
      type inet:ipv4-address {
        tailf:info "A.B.C.D;;The netmask for the destined foreign network";
      }
    }
    leaf gw {
      type inet:host {
        tailf:info "Hostname or A.B.C.D;;The address of the gateway by which "
          +"the foreign network is reached.";
      }
    }

    choice route-choice {
      case a {
        leaf metric {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<1-255>;;Distance metric for this route, default is 1";
            range "1..255";
          }
        }
        leaf track {
          tailf:info "Install route depending on tracked item";
          type uint16 {
            tailf:info "<1-500>;;Tracked object number";
            range "1..500";
          }
        }
      }
      case b {
        leaf tunneled {
          tailf:info "Enable the default tunnel gateway option, metric "
            +"is set to 255";
          type empty;
        }
      }
    }
  }


  /// ========================================================================
  /// monitor-interface
  /// ========================================================================

  container monitor-interface {
    tailf:info "Enable or disable failover monitoring on a specific interface";

    // monitor-interface *
    list if-list {
      tailf:info "'no monitor-interface' list entry";
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      key name;
      leaf name {
        tailf:cli-disallow-value "service-module";
        tailf:cli-diff-dependency "../../../interface";
        tailf:cli-diff-dependency "../../../interface/Management/nameif";
        tailf:cli-diff-dependency "../../../interface/Ethernet/nameif";
        tailf:cli-diff-dependency "../../../interface/FastEthernet/nameif";
        tailf:cli-diff-dependency "../../../interface/GigabitEthernet/nameif";
        tailf:cli-diff-dependency "../../../interface/TenGigabitEthernet/nameif";
        tailf:cli-diff-dependency "../../../interface/Vlan/nameif";
        tailf:cli-diff-dependency "../../../interface/Port-channel/nameif";
        tailf:cli-diff-dependency "../../../interface/Port-channel-subif/Port-channel/nameif";
        tailf:cli-diff-dependency "../../../interface/BVI/nameif";
        tailf:cli-diff-dependency "../../../interface/Redundant/nameif";
        tailf:cli-diff-dependency "../../../interface/allocated/nameif";
        type nameif-type;
      }
      leaf status {
        tailf:cli-drop-node-name;
        type enumeration {
          enum disable {
            tailf:info "Use for devices which show 'no monitor-interface <nameif>'";
          }
          enum enable {
            tailf:info "Use for devices which show 'monitor-interface <nameif>'";
          }
        }
      }
    }

    // no monitor-interface service-module
    leaf service-module {
      tailf:info "Enable service-card monitoring";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
      default true;
    }
  }


  /// ========================================================================
  /// icmp
  /// ========================================================================

  container icmp {
    tailf:info "Configure access rules for ICMP traffic";

    // icmp unreachable
    container unreachable {
      tailf:info "Configure unreachable behavior";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf rate-limit {
        tailf:info "Limit unreachable at rate";
        tailf:cli-incomplete-command;
        type uint8 {
          tailf:info "<1-100>;;Enter unreachable rate per second";
          range "1..100";
        }
      }
      leaf burst-size {
        tailf:info "Allow burst of size";
        type uint8 {
          tailf:info "<1-10>;;Enter allowed burst size";
          range "1..10";
        }
      }
    }

    // icmp * deny|permit *
    list icmp-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      key nameif;
      leaf nameif {
        type string {
          tailf:info "LINE;;icmp <nameif> <permit|deny rule>. Note: reordered to device!";
        }
      }
      list rule {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-show-long-obu-diffs;
        ordered-by user;
        key expr;
        leaf expr {
          tailf:cli-multi-word-key;
          type string {
            tailf:info "<RULE>;;deny <LINE> | permit <LINE>";
            pattern "(permit.*)|(deny.*)";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// EXEC (exec commands executed in config mode)
  /// ========================================================================

  container EXEC {
    tailf:cli-drop-node-name;

    // execute any config exec command
    tailf:action "exec" {
      tailf:info "Execute config exec-commands, e.g. crypto key generate";
      tailf:actionpoint ncsinternal {
        tailf:internal;
      }
      input {
        leaf context {
          tailf:info "Specify context to run the command in";
          type string {
            tailf:info "WORD;;Context name";
          }
        }
        leaf input-string {
          tailf:info "Input data to command, e.g. base 64 encoded pkcs12";
          type string {
            tailf:info "LINE;;Quoted string. Use \\r\\n for newline.";
          }
        }
        list auto-prompts {
          tailf:cli-suppress-mode;
          key question;
          leaf question {
            type string;
          }
          leaf answer {
            type string;
          }
        }
        leaf-list args {
          tailf:cli-drop-node-name;
          tailf:cli-flat-list-syntax;
          type string {
            tailf:info "ACTION:;;exec [context <context>] [input-string <string>] <command> [argument(s)]";
          }
        }
      }
      output {
        leaf result {
          type string;
        }
      }
    }
  }


  /// ========================================================================
  /// fragment
  /// ========================================================================

  // fragment *
  list fragment {
    tailf:info "Configure the IP fragment database. NOTE: API differs from device, translated to work";
    tailf:cli-suppress-mode;
    tailf:cli-delete-when-empty;
    key interface;
    leaf interface {
      tailf:cli-diff-dependency "../../interface";
      tailf:cli-diff-dependency "../../interface/Management/nameif";
      tailf:cli-diff-dependency "../../interface/Ethernet/nameif";
      tailf:cli-diff-dependency "../../interface/FastEthernet/nameif";
      tailf:cli-diff-dependency "../../interface/GigabitEthernet/nameif";
      tailf:cli-diff-dependency "../../interface/TenGigabitEthernet/nameif";
      tailf:cli-diff-dependency "../../interface/Vlan/nameif";
      tailf:cli-diff-dependency "../../interface/Port-channel/nameif";
      tailf:cli-diff-dependency "../../interface/Port-channel-subif/Port-channel/nameif";
      tailf:cli-diff-dependency "../../interface/BVI/nameif";
      tailf:cli-diff-dependency "../../interface/Redundant/nameif";
      tailf:cli-diff-dependency "../../interface/allocated/nameif";
      type nameif-type;
    }

    // fragment * chain
    leaf chain {
      tailf:info "Configure maximum number of elements in a fragment set";
      type uint16 {
        tailf:info "<1-8200>;;Maximum number of elements in a fragment set, default is 24";
        range "1..8200";
      }
      default 24;
    }

    // fragment * reassembly full
    container reassembly {
      tailf:info "Configure reassembly option";
      leaf full {
        tailf:info "Configure full reassembly option";
        type empty;
      }
    }

    // fragment * size
    leaf size {
      tailf:info "Configure maximum number of blocks in database";
      tailf:cli-diff-dependency "../chain";
      type uint16 {
        tailf:info "<1-30000>;;Maximum number of blocks in database, default is 200";
        range "1..30000";
      }
      default 200;
    }

    // fragment * timeout
    leaf timeout {
      tailf:info "Configure number of seconds to assemble a fragment set";
      type uint8 {
        tailf:info "<1-30>;;Number of seconds to assemble a fragment set, default is 5";
        range "1..30";
      }
      default 5;
    }
  }


  /// ========================================================================
  /// crypto
  /// ========================================================================

  container crypto {
    tailf:info "Configure IPSec, ISAKMP, Certification authority, key";

    // crypto ca
    container ca {
      tailf:info "Certification authority";

      // crypto ca certificate
      container certificate {
        tailf:info "Actions on certificates";
        tailf:cli-diff-dependency "../trustpoint";

        // crypto ca certificate chain *
        list chain {
          tailf:info "Identify certificates";
          tailf:cli-mode-name "config-cert-chain";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;CA Server Name";
            }
          }

          // crypto ca certificate chain * / certificate *
          list certificate {
            tailf:info "Certificate issued by the CA";
            tailf:cli-mode-name "config-pki-hexmode-quotedstring";
            tailf:cli-delete-when-empty;
            tailf:cli-exit-command "quit";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            tailf:cli-reset-container;
            tailf:cli-full-command;
            key serial;
            leaf serial {
              tailf:cli-disallow-value "rollover|ca|ra-encrypt|ra-general"+
                "|ra-sign|self-signed";
              type string {
                tailf:info "WORD;;Certificate serial number";
              }
            }
            leaf cert-type {
              tailf:cli-optional-in-sequence;
              tailf:cli-drop-node-name;
              tailf:cli-prefix-key;
              type enumeration {
                enum ca {
                  tailf:info "A certificate";
                }
                enum ra-encrypt {
                  tailf:info "A encryption certificate";
                }
                enum ra-general {
                  tailf:info "A general purpose certificate";
                }
                enum ra-sign {
                  tailf:info "A signing certificate";
                }
                enum rollover {
                  tailf:info "Shadow rollover certificate";
                }
                enum self-signed {
                  tailf:info "Self-signed certificate";
                }
              }
            }
            leaf rollover {
              tailf:info "Shadow rollover certificate";
              tailf:cli-optional-in-sequence;
              tailf:cli-prefix-key;
              type empty;
            }
            leaf cert {
              tailf:cli-drop-node-name;
              tailf:cli-disallow-value "rollover|ca|ra-encrypt|ra-general"+
                "|ra-sign|self-signed";
              type string {
                tailf:info "WORD;;file specification";
              }
            }
          }
        }

        // crypto ca certificate map *
        list map {
          tailf:info "Define certificate attributes map";
          tailf:cli-mode-name "config-ca-cert-map";
          tailf:cli-delete-when-empty;
          tailf:cli-explicit-exit;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-full-command;
          key "label sequence";
          leaf label {
            type string {
              tailf:info "WORD < 65 char;;Certificate map label. Default: DefaultCertificateMap";
              length "1..65";
            }
          }
          leaf sequence {
            type uint16 {
              tailf:info "<1-65535>;Sequence to insert into certificate map entry";
              range "1..65535";
            }
          }

          // crypto ca certificate map * / subject-name attr *
          container subject-name {
            tailf:info "Certificate subject name";
            list attr {
              tailf:info "attr  Limit the comparison to a particular DN attribute";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-full-command;
              key "name sign compare";
              leaf name {
                type enumeration {
                  enum "c" {
                    tailf:info "Country";
                  }
                  enum "cn" {
                    tailf:info "Common Name";
                  }
                  enum "dc" {
                    tailf:info "Domain Component";
                  }
                  enum "dnq" {
                    tailf:info "DN Qualifier";
                  }
                  enum "ea" {
                    tailf:info "Email Address";
                  }
                  enum "genq" {
                    tailf:info "Generational Qualifier";
                  }
                  enum "gn" {
                    tailf:info "Given Name";
                  }
                  enum "i" {
                    tailf:info "Initials";
                  }
                  enum "ip" {
                    tailf:info "IP Address";
                  }
                  enum "l" {
                    tailf:info "Locality";
                  }
                  enum "n" {
                    tailf:info "Name";
                  }
                  enum "o" {
                    tailf:info "Organization Name";
                  }
                  enum "ou" {
                    tailf:info "Organizational Unit";
                  }
                  enum "ser" {
                    tailf:info "Serial Number";
                  }
                  enum "sn" {
                    tailf:info "Surname";
                  }
                  enum "sp" {
                    tailf:info "State/Province";
                  }
                  enum "t" {
                    tailf:info "Title";
                  }
                  enum "uid" {
                    tailf:info "User ID";
                  }
                  enum "uname" {
                    tailf:info "Unstructured Name";
                  }
                }
              }
              leaf sign {
                type enumeration {
                  enum "co" {
                    tailf:info "Contains";
                  }
                  enum "eq" {
                    tailf:info "Equal";
                  }
                  enum "nc" {
                    tailf:info "Does not contain";
                  }
                  enum "ne" {
                    tailf:info "Not Equal";
                  }
                }
              }
              leaf compare {
                type string {
                  tailf:info "LINE < 256 char;;Compare string";
                  length "1..256";
                }
              }
            }
          }
        }
      }

      // crypto ca trustpool
      container trustpool {
        tailf:info "Define CA trustpool";

        // crypto ca trustpool policy
        container policy {
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-ca-trustpool";
          presence true;

          // crypto ca trustpool policy / revocation-check
          leaf revocation-check {
            tailf:info "Revocation checking options";
            type enumeration {
              enum "crl" {
                tailf:info "Revocation check by CRL";
              }
              enum "none" {
                tailf:info "Ignore revocation check";
              }
              enum "ocsp" {
                tailf:info "Revocation check by OCSP";
              }
            }
          }

          // crypto ca trustpool policy / auto-import
          container auto-import {
            tailf:info "Configure automatic import of trustpool certificates";
            presence true;
          }
        }
      }

      // crypto ca trustpoint *
      list trustpoint {
        tailf:info "Define a CA trustpoint";
        tailf:cli-mode-name "config-ca-trustpoint";
        key id;
        leaf id {
          type string {
            tailf:info "WORD < 65 char;;Trustpoint Name";
          }
        }

        // crypto ca trustpoint * / revocation-check
        container revocation-check {
          tailf:info "Revocation checking options";
          tailf:cli-compact-syntax;
          leaf crl {
            tailf:info "Revocation check by CRL";
            type empty;
          }
          leaf ocsp {
            tailf:info "Revocation check by OCSP";
            type empty;
          }
          leaf none {
            tailf:info "Ignore revocation check";
            type empty;
          }
        }

        // crypto ca trustpoint * / enrollment
        container enrollment {
          tailf:info "Enrollment parameters";
          choice enrollment-choice {
            // crypto ca trustpoint * / enrollment self
            leaf self {
              tailf:info "Enrollment will generate a self-signed certificate";
              type empty;
            }
            // crypto ca trustpoint * / enrollment terminal
            leaf terminal {
              tailf:info "Enroll via the terminal (cut-and-paste)";
              type empty;
            }
            // crypto ca trustpoint * / enrollment url
            leaf url {
              tailf:info "CA server enrollment URL";
              type string {
                tailf:info "LINE < 500 char;;URL";
              }
            }
            // crypto ca trustpoint * / enrollment protocol scep url
            container protocol {
              tailf:info "Enrollment protocol";
              container scep {
                tailf:info "Simple Certificate Enrollment Protocol";
                leaf url {
                  tailf:info "CA server enrollment URL";
                  type string {
                    tailf:info "LINE < 477 char;;URL";
                    length "1..476";
                  }
                }
              }
            }
          }
        }

        // crypto ca trustpoint * / no validation-usage
        leaf validation-usage {
          tailf:info "Specifies the usage types for which validation with this "
            +"trustpoint is permitted";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }

        // crypto ca trustpoint * / crl
        container crl {
          tailf:info "CRL options";

          // crypto ca trustpoint * / crl configure
          container configure {
            tailf:info "Enter CRL configuration sub-mode";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-ca-crl";
            tailf:cli-explicit-exit;
            presence true;

            // crypto ca trustpoint * / crl configure / policy
            leaf policy {
              tailf:info "Specify CRL retrieval policy";
              type string {
                tailf:info "WORD;;IP Policy list name";
              }
            }

            // crypto ca trustpoint * / crl configure / url
            list url {
              tailf:info "Specify a static URL from where CRLs may be retrieved.";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-incomplete-command;
              key index;
              leaf index {
                type uint8 {
                  tailf:info "<1-5>;;Specify the index to determine the rank of this URL.";
                  range "1..5";
                }
              }
              leaf path {
                tailf:cli-drop-node-name;
                type string {
                  tailf:info "LINE < 500 char;;URL";
                }
              }
            }

            // crypto ca trustpoint * / crl configure / cache-time
            leaf cache-time {
              tailf:info "Specify the refresh time in minutes for the CRL "
                +"cache.";
              type uint16 {
                tailf:info "<1-1440>;;Refresh time (minutes) for the CRL "
                  +"cache.";
                range 1..1440;
              }
            }

            // crypto ca trustpoint * / crl configure / no protocol
            container protocol {
              tailf:info "Specify the permitted CRL retrieval methods.";
              // crypto ca trustpoint * / crl configure / no protocol http
              leaf http {
                tailf:info "Permit CRL retrieval using HTTP";
                tailf:cli-boolean-no;
                tailf:cli-full-command;
                type boolean;
                default true;
              }
              // crypto ca trustpoint * / crl configure / no protocol ldap
              leaf ldap {
                tailf:info "Permit CRL retrieval using LDAP";
                tailf:cli-boolean-no;
                tailf:cli-full-command;
                type boolean;
                default true;
              }
              // crypto ca trustpoint * / crl configure / no protocol scep
              leaf scep {
                tailf:info "Permit CRL retrieval using SCEP";
                tailf:cli-boolean-no;
                tailf:cli-full-command;
                type boolean;
                default true;
              }
            }
          }
        }

        // crypto ca trustpoint * / fqdn
        leaf fqdn {
          tailf:info "include fully-qualified domain name";
          type union {
            type string {
              tailf:info "LINE < 65 char;;fully-qualified domain name";
            }
            type enumeration {
              enum none {
                tailf:info "do not include fully-qualified domain name";
              }
            }
          }
        }

        // crypto ca trustpoint * / subject-name
        leaf subject-name {
          tailf:info "Subject Name";
          tailf:cli-multi-value;
          type string {
            tailf:info "LINE < 500 char;;Subject name with attributes "
              +"separated by commas";
          }
        }

        // crypto ca trustpoint * / serial-number
        leaf serial-number {
          tailf:info "include serial number";
          type empty;
        }

        // crypto ca trustpoint * / keypair
        leaf keypair {
          tailf:info "Specify the key pair whose public key is to be certified";
          type string {
            tailf:info "WORD < 129 char;;Name of key pair";
          }
        }
      }
    }

    // crypto ipsec
    container ipsec {
      tailf:info "Configure transform-set, IPSec SA lifetime, and fragmentation";

      // crypto ipsec transform-set *
      list transform-set {
        tailf:info "Define transform and settings";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD < 64 char;;Transform set tag";
            length "1..64";
          }
        }
        leaf encryption {
          tailf:cli-drop-node-name;
          type enumeration {
            enum esp-3des {
              tailf:info "esp 3des encryption";
            }
            enum esp-aes {
              tailf:info "esp aes 128 encryption";
            }
            enum esp-aes-192 {
              tailf:info "esp aes 192 encryption";
            }
            enum esp-aes-256 {
              tailf:info "esp aes 256 encryption";
            }
            enum esp-des {
              tailf:info "esp des encryption";
            }
            enum esp-null {
              tailf:info "esp null encryption";
            }
          }
        }
        leaf authentication {
          tailf:cli-drop-node-name;
          type enumeration {
            enum esp-md5-hmac {
              tailf:info "esp md5 authentication";
            }
            enum esp-none {
              tailf:info "esp no authentication";
            }
            enum esp-sha-hmac {
              tailf:info "esp sha authentication";
            }
          }
        }
      }

      // crypto ipsec ikev1 transform-set *
      container ikev1 {
        tailf:info "Set IKEv1 settings";
        list transform-set {
          tailf:info "Define transform and settings";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type string {
              tailf:info "WORD < 64 char;;Transform set tag";
              length "1..64";
            }
          }

          // crypto ipsec ikev1 transform-set * <encryption>
          container transform {
            tailf:cli-drop-node-name;
            tailf:cli-compact-syntax;
            leaf encryption {
              tailf:cli-drop-node-name;
              type enumeration {
                enum esp-3des {
                  tailf:info "esp 3des encryption";
                }
                enum esp-aes {
                  tailf:info "esp aes 128 encryption";
                }
                enum esp-aes-192 {
                  tailf:info "esp aes 192 encryption";
                }
                enum esp-aes-256 {
                  tailf:info "esp aes 256 encryption";
                }
                enum esp-des {
                  tailf:info "esp des encryption";
                }
                enum esp-null {
                  tailf:info "esp null encryption";
                }
              }
            }

            // crypto ipsec ikev1 transform-set * <authentication>
            leaf authentication {
              tailf:cli-drop-node-name;
              type enumeration {
                enum esp-md5-hmac {
                  tailf:info "esp md5 authentication";
                }
                enum esp-none {
                  tailf:info "esp no authentication";
                }
                enum esp-sha-hmac {
                  tailf:info "esp sha authentication";
                }
              }
            }
          }

          // crypto ipsec ikev1 transform-set * mode transport
          container mode {
            tailf:info "mode transport";
            leaf transport {
              tailf:info "mode transport";
              type empty;
            }
          }
        }
      }

      // crypto ipsec ikev2
      container ikev2 {
        tailf:info "Set IKEv2 settings";

        // crypto ipsec ikev2 ipsec-proposal *
        list ipsec-proposal {
          tailf:info "Configure IKEv2 IPSec Policy";
          tailf:cli-mode-name "config-ipsec-proposal";
          key name;
          leaf name {
            type string {
              tailf:info "WORD < 65 char;;Enter the name of the ipsec-proposal";
            }
          }

          // crypto ipsec ikev2 ipsec-proposal * / protocol esp
          container protocol {
            tailf:info "Configure a protocol for the IPSec proposal";
            container esp {
              tailf:info "IPsec Encapsulating Security Payload";

              // crypto ipsec ikev2 ipsec-proposal * / protocol esp encryption *
              leaf-list encryption {
                tailf:info "Add one or more encryption algorithms for this protocol";
                tailf:cli-flat-list-syntax;
                tailf:cli-replace-all;
                type enumeration {
                  enum "3des" {
                    tailf:info "3des encryption";
                  }
                  enum aes {
                    tailf:info "aes encryption";
                  }
                  enum aes-192 {
                    tailf:info "aes-192 encryption";
                  }
                  enum aes-256 {
                    tailf:info "aes-256 encryption";
                  }
                  enum aes-gcm {
                    tailf:info "aes-gcm encryption";
                  }
                  enum aes-gcm-192 {
                    tailf:info "aes-gcm-192 encryption";
                  }
                  enum aes-gcm-256 {
                    tailf:info "aes-gcm-256 encryption";
                  }
                  enum aes-gmac {
                    tailf:info "aes-gmac encryption";
                  }
                  enum aes-gmac-192 {
                    tailf:info "aes-gmac-192 encryption";
                  }
                  enum aes-gmac-256 {
                    tailf:info "aes-gmac-256 encryption";
                  }
                  enum des {
                    tailf:info "des encryption";
                  }
                  enum null {
                    tailf:info "null encryption";
                  }
                }
              }

              // crypto ipsec ikev2 ipsec-proposal * / protocol esp integrity *
              leaf-list integrity {
                tailf:info "Add one or more integrity algorithms for this protocol";
                tailf:cli-flat-list-syntax;
                tailf:cli-replace-all;
                type enumeration {
                  enum md5 {
                    tailf:info "set hash md5";
                  }
                  enum null {
                    tailf:info "set hash null";
                  }
                  enum sha-1 {
                    tailf:info "set hash sha-1";
                  }
                  enum sha-256 {
                    tailf:info "set hash sha-256";
                  }
                  enum sha-384 {
                    tailf:info "set hash sha-384";
                  }
                  enum sha-512 {
                    tailf:info "set hash sha-512";
                  }
                }
              }
            }
          }
        }
      }

      // crypto ipsec security-association
      container security-association {
        tailf:info "Set security association parameters";

        // crypto ipsec security-association lifetime
        container lifetime {
          tailf:info "Set security association lifetime";

          // crypto ipsec security-association lifetime seconds
          leaf seconds {
            tailf:info "Lifetime seconds";
            type uint32 {
              tailf:info "<120-2147483647>;;Lifetime seconds value";
              range "120..2147483647";
            }
          }

          // crypto ipsec security-association lifetime kilobytes
          leaf kilobytes {
            tailf:info "Set security association lifetime";
            type union {
              type uint32 {
                tailf:info "<10-2147483647>;;Lifetime kilobytes value";
                range "10..2147483647";
              }
              type enumeration {
                enum unlimited {
                  tailf:info "Disable data rekey";
                }
              }
            }
          }
        }

        // crypto ipsec security-association pmtu-aging
        leaf pmtu-aging {
          tailf:info "Configure pmtu-aging timer";
          type union {
            type uint8 {
              tailf:info "<10-30>;;Reset minute value";
              range "10..30";
            }
            type enumeration {
              enum infinite {
                tailf:info "Never reset PMTU";
              }
            }
          }
        }
      }
    }

    // crypto dynamic-map *
    list dynamic-map {
      tailf:info "Configure a dynamic crypto map";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key "name seq-num";
      leaf name {
        type string {
          tailf:info "WORD < 64 char;;Dynamic crypto map template tag";
          length "1..64";
        }
      }
      leaf seq-num {
        type uint16 {
          tailf:info "<1-65535>;;Sequence to insert into dynamic-map entry";
          range "1..65535";
        }
      }

      // crypto dynamic-map * set
      container set {
        tailf:info "Specify dynamic crypto map settings";

        // crypto dynamic-map * set pfs
        container pfs {
          tailf:info "Specify pfs settings";
          tailf:cli-delete-when-empty;
          presence true;
          leaf group {
            tailf:cli-drop-node-name;
            type enumeration {
              enum  group1 {
                tailf:info "D-H Group 1";
              }
              enum group14 {
                tailf:info "D-H Group 14 (Unsupported for IKEv1)";
              }
              enum group19 {
                tailf:info "D-H Group 19 (Unsupported for IKEv1)";
              }
              enum group2 {
                tailf:info "D-H Group 2";
              }
              enum group20 {
                tailf:info "D-H Group 20 (Unsupported for IKEv1)";
              }
              enum group21 {
                tailf:info "D-H Group 21 (Unsupported for IKEv1)";
              }
              enum group24 {
                tailf:info "D-H Group 24 (Unsupported for IKEv1)";
              }
              enum group5 {
                tailf:info "D-H Group 5";
              }
            }
          }
        }

        // crypto dynamic-map * set ikev1 transform-set *
        container ikev1 {
          tailf:info "Configure IKEv1 policy";
          leaf-list transform-set {
            tailf:info "Specify list of transform sets in priority order";
            tailf:cli-flat-list-syntax;
            tailf:cli-replace-all;
            tailf:non-strict-leafref {
              path "../../../../ipsec/ikev1/transform-set/name";
            }
            ordered-by user;
            type string {
              tailf:info "WORD;;Proposal tag";
            }
          }
        }

        // crypto dynamic-map * set ikev2
        container ikev2 {
          tailf:info "Configure IKEv2 policy";
          leaf-list ipsec-proposal {
            tailf:info "Specify list of IPSec proposals in priority order";
            tailf:cli-flat-list-syntax;
            tailf:cli-replace-all;
            tailf:non-strict-leafref {
              path "../../../../ipsec/ikev2/ipsec-proposal/name";
            }
            ordered-by user;
            type string {
              tailf:info "WORD;;ipsec-proposal tag";
            }
          }
        }

        // crypto dynamic-map * set security-association lifetime
        container security-association {
          tailf:info "Security association duration";
          container lifetime {
            tailf:info "Security association duration";
            // crypto dynamic-map * set security-association lifetime seconds
            leaf seconds {
              tailf:info "Security association duration in seconds";
              type uint32 {
                tailf:info "<120-2147483647>;;Security association duration in seconds";
                range "120..2147483647";
              }
            }
            // crypto dynamic-map * set security-association lifetime kilobytes
            leaf kilobytes {
              tailf:info "Security association duration in kilobytes";
              type union {
                type uint32 {
                  tailf:info "<10-2147483647>;;Security association duration in kilobytes";
                  range "10..2147483647";
                }
                type enumeration {
                  enum unlimited {
                    tailf:info "Disable data rekey";
                  }
                }
              }
            }
          }
        }

        // crypto dynamic-map * set reverse-route
        leaf reverse-route {
          tailf:info "Enable reverse route injection for connections based on this entry";
          type empty;
        }
      }
    }

    // crypto map *
    list map {
      tailf:info "Configure a crypto map";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        type string {
          tailf:info "WORD < 64 char;;Crypto map template tag";
          length "1..64";
        }
      }

      // crypto map * ipsec-isakmp dynamic
      list seq-num {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key seq-num;
        leaf seq-num {
          type uint16 {
            tailf:info "<1-65535>;;Sequence to insert into map entry";
            range "1..65535";
          }
        }

        // crypto map * match address
        container match {
          tailf:info "Match address of packets to encrypt";
          leaf address {
            tailf:info "Match address of packets to encrypt";
            tailf:cli-diff-dependency "../../../../../access-list/access-list-id";
            tailf:non-strict-leafref {
              path "../../../../../access-list/access-list-id/id";
            }
            type string {
              tailf:info "WORD;;Access-list name";
            }
          }
        }

        // crypto map * set
        container set {
          tailf:info "Specify crypto map settings";

          // crypto map * set security-association lifetime
          container security-association {
            tailf:info "Security association duration";
            container lifetime {
              tailf:info "Security association duration";

              // crypto map * set security-association lifetime kilobytes
              leaf kilobytes {
                tailf:info "Security association duration in kilobytes";
                type union {
                  type uint32 {
                    tailf:info "<10-2147483647>;;Security association duration in kilobytes";
                    range "10..2147483647";
                  }
                  type enumeration {
                    enum unlimited {
                      tailf:info "Disable data rekey";
                    }
                  }
                }
              }
            }
          }

          // crypto map * set peer
          leaf peer {
            tailf:info "Set IP address of peer";
            tailf:cli-full-command;
            type inet:host {
              tailf:info "WORD;;Hostname or A.B.C.D or X:X:X:X::X";
            }
          }

          // crypto map * set ikev1 transform-set
          container ikev1 {
            tailf:info "Configure IKEv1 policy";
            leaf-list transform-set {
              tailf:info "Specify list of transform sets in priority order";
              tailf:cli-flat-list-syntax;
              tailf:cli-replace-all;
              tailf:non-strict-leafref {
                path "../../../../../ipsec/ikev1/transform-set/name";
              }
              ordered-by user;
              type string {
                tailf:info "WORD;;Proposal tag";
              }
            }
          }

          // crypto map * set ikev2 ipsec-proposal
          container ikev2 {
            tailf:info "Configure IKEv2 policy";

            // crypto map * set ikev2 ipsec-proposal *
            leaf-list ipsec-proposal {
              tailf:info "Specify list of IPSec proposals in priority order";
              tailf:cli-flat-list-syntax;
              tailf:non-strict-leafref {
                path "../../../../../ipsec/ikev2/ipsec-proposal/name";
              }
              ordered-by user;
              type string {
                tailf:info "WORD;;ipsec-proposal tag";
              }
            }
          }

          // crypto map * set transform-set *
          leaf-list transform-set {
            tailf:info "trustpoint";
            tailf:cli-flat-list-syntax;
            tailf:non-strict-leafref {
              path "../../../../ipsec/transform-set/name";
            }
            type string {
              tailf:info "WORD;;Proposal tag";
            }
          }

          // crypto map * set reverse-route
          leaf reverse-route {
            tailf:info "Enable reverse route injection for connections based on this entry";
            type empty;
          }
        }

        // crypto map * set ipsec-isakmp dynamic
        container ipsec-isakmp {
          tailf:info "IPSec w/ISAKMP";
          leaf dynamic {
            tailf:info "Entry is a dynamic map";
            tailf:non-strict-leafref {
              path "../../../../../crypto/dynamic-map/name";
            }
            type string {
              tailf:info "WORD;;dynamic map name";
            }
          }
        }
      }

      // crypto map * interface
      container interface {
        tailf:info "Name of interface to apply the crypto map to";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        uses interface-name-grouping;
      }
    }

    // crypto ikev2
    container ikev2 {
      tailf:info "Configure IKEv2 policy";

      // crypto ikev2 policy *
      list policy {
        tailf:info "Set IKEv2 policy suite";
        tailf:cli-mode-name "config-ikev2-policy";
        tailf:cli-full-command;
        key priority;
        leaf priority {
          type uint16 {
            tailf:info "<1-65535>;;Policy suite priority(1 highest, 65535 lowest)";
            range "1..65535";
          }
        }

        // crypto ikev2 policy * / encryption
        leaf-list encryption {
          tailf:info "Configure one or more encryption algorithm";
          tailf:cli-flat-list-syntax;
          tailf:cli-replace-all;
          type enumeration {
            enum "3des" {
              tailf:info "3des encryption";
            }
            enum aes {
              tailf:info "aes encryption";
            }
            enum aes-192 {
              tailf:info "aes-192 encryption";
            }
            enum aes-256 {
              tailf:info "aes-256 encryption";
            }
            enum aes-gcm {
              tailf:info "aes-gcm encryption";
            }
            enum aes-gcm-192 {
              tailf:info "aes-gcm-192 encryption";
            }
            enum aes-gcm-256 {
              tailf:info "aes-gcm-256 encryption";
            }
            enum des {
              tailf:info "des encryption";
            }
            enum null {
              tailf:info "null encryption";
            }
          }
        }

        // crypto ikev2 policy * / integrity
        leaf-list integrity {
          tailf:info "Configure one or more integrity algorithm";
          tailf:cli-flat-list-syntax;
          tailf:cli-replace-all;
          type enumeration {
            enum md5 {
              tailf:info "set hash md5";
            }
            enum sha {
              tailf:info "set hash sha1";
            }
            enum sha256 {
              tailf:info "set hash sha256";
            }
            enum sha384 {
              tailf:info "set hash sha384";
            }
            enum sha512 {
              tailf:info "set hash sha512";
            }
          }
        }

        // crypto ikev2 policy * / group
        leaf-list group {
          tailf:info "Configure one or more DH groups";
          tailf:cli-flat-list-syntax;
          tailf:cli-replace-all;
          type enumeration {
            enum "1" {
              tailf:info "Diffie-Hellman group 1";
            }
            enum "14" {
              tailf:info "Diffie-Hellman group 14";
            }
            enum "19" {
              tailf:info "Diffie-Hellman group 19";
            }
            enum "2" {
              tailf:info "Diffie-Hellman group 2";
            }
            enum "20" {
              tailf:info "Diffie-Hellman group 20";
            }
            enum "21" {
              tailf:info "Diffie-Hellman group 21";
            }
            enum "24" {
              tailf:info "Diffie-Hellman group 24";
            }
            enum "5" {
              tailf:info "Diffie-Hellman group 5";
            }
          }
        }

        // crypto ikev2 policy * / prf
        leaf-list prf {
          tailf:info "Configure one or more hash algorithm";
          tailf:cli-flat-list-syntax;
          tailf:cli-replace-all;
          type enumeration {
            enum md5 {
              tailf:info "set hash md5";
            }
            enum sha {
              tailf:info "set hash sha1";
            }
            enum sha256 {
              tailf:info "set hash sha256";
            }
            enum sha384 {
              tailf:info "set hash sha384";
            }
            enum sha512 {
              tailf:info "set hash sha512";
            }
          }
        }

        // crypto ikev2 policy * / lifetime seconds
        container lifetime {
          tailf:info "Configure the ikev2 lifetime";
          leaf seconds {
            tailf:info "Lifetime seconds";
            type union {
              type uint32 {
                tailf:info "<120-2147483647>;;Enter the ikev2 lifetime";
                range "120..2147483647";
              }
              type enumeration {
                enum none {
                  tailf:info "Disable rekey and allow an unlimited "
                  +"rekey period";
                }
              }
            }
          }
        }
      }

      // crypto ikev2 enable *
      list enable {
        tailf:info "Enable IKEv2 on the specified interface";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key name;
        leaf name {
          tailf:cli-diff-dependency "../../../../interface";
          tailf:cli-diff-dependency "../../../../interface/Management/nameif";
          tailf:cli-diff-dependency "../../../../interface/Ethernet/nameif";
          tailf:cli-diff-dependency "../../../../interface/FastEthernet/nameif";
          tailf:cli-diff-dependency "../../../../interface/GigabitEthernet/nameif";
          tailf:cli-diff-dependency "../../../../interface/TenGigabitEthernet/nameif";
          tailf:cli-diff-dependency "../../../../interface/Vlan/nameif";
          tailf:cli-diff-dependency "../../../../interface/Port-channel/nameif";
          tailf:cli-diff-dependency "../../../../interface/Port-channel-subif/Port-channel/nameif";
          tailf:cli-diff-dependency "../../../../interface/BVI/nameif";
          tailf:cli-diff-dependency "../../../../interface/Redundant/nameif";
          tailf:cli-diff-dependency "../../../../interface/allocated/nameif";
          type nameif-type;
        }
        leaf client-services {
          tailf:info "Enable client services for IKEv2 AnyConnect on the "+
            "specified interface.";
          type empty;

        }
        leaf port {
          tailf:info "Port to open for client services";
          type uint16 {
            tailf:info "<1-65535>;;Port number. Default port is 443";
            range "1..65535";
          }
        }
      }

      // crypto ikev2 redirect
      leaf redirect {
        tailf:info "Set IKEv2 redirect";
        type enumeration {
          enum during-auth {
            tailf:info "Set IKEv2 redirect during SA auth";
          }
          enum during-init {
            tailf:info "Set IKEv2 redirect during SA init";
          }
        }
        default during-auth;
      }

      // crypto ikev2 remote-access trustpoint *
      container remote-access {
        tailf:info "Configure IKEv2 for Remote Access";
        list trustpoint {
          tailf:info "Select the trustpoint that identifies the cert to be "+
            "sent to the IKEv2 peer";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            tailf:non-strict-leafref {
              path "../../../../ca/trustpoint/id";
            }
            type string {
              tailf:info "WORD;;trustpoint";
            }
          }
          //todo:line
        }
      }
    }

    // crypto ikev1
    container ikev1 {
      tailf:info "Configure IKEv1 policy";

      // crypto ikev1 policy *
      list policy {
        tailf:info "Set IKEv1 policy suite";
        tailf:cli-mode-name "config-ikev1-policy";
        tailf:cli-full-command;
        key priority;
        leaf priority {
          type uint16 {
            tailf:info "<1-65535>;;Policy suite priority(1 highest, 65535 lowest)";
            range "1..65535";
          }
        }

        // crypto ikev1 policy * / authentication
        leaf authentication {
          tailf:info "Set authentication method (pre-share or rsa-sig)";
          type enumeration {
            enum crack {
              tailf:info "set auth crack ";
            }
            enum pre-share {
              tailf:info "set auth pre-share ";
            }
            enum rsa-sig {
              tailf:info "set auth rsa-sig ";
            }
          }
        }

        // crypto ikev1 policy * / encryption
        leaf encryption {
          tailf:info "Set encryption algorithm";
          type enumeration {
            enum "3des" {
              tailf:info "3des encryption";
            }
            enum aes {
              tailf:info "aes-128 encryption";
            }
            enum aes-192 {
              tailf:info "aes-192 encryption";
            }
            enum aes-256 {
              tailf:info "aes-256 encryption";
            }
            enum des {
              tailf:info "des encryption";
            }
          }
        }

        // crypto ikev1 policy * / hash
        leaf hash {
          tailf:info "Set hash algorithm (md5 or sha1)";
          type enumeration {
            enum md5 {
              tailf:info "set hash md5";
            }
            enum sha {
              tailf:info "set hash sha1";
            }
          }
        }

        // crypto ikev1 policy * / group
        leaf group {
          tailf:info "Set Diffie-Hellman group (1,2 or 5)";
          type enumeration {
            enum "1" {
              tailf:info "Diffie-Hellman group 1";
            }
            enum "2" {
              tailf:info "Diffie-Hellman group 2";
            }
            enum "5" {
              tailf:info "Diffie-Hellman group 5";
            }
            enum "7" {
              tailf:info "Diffie-Hellman group 7 (DEPRECATED)";
            }
          }
        }

        // crypto ikev1 policy * / lifetime
        leaf lifetime {
          tailf:info "Set IKEV1 SA lifetime (seconds)";
          type union {
            type uint32 {
              tailf:info "<120-2147483647>;;Lifetime in seconds";
              range "120..2147483647";
            }
            type enumeration {
              enum none {
                tailf:info "Disable rekey and allow an unlimited rekey period";
              }
            }
          }
        }
      }

      // crypto ikev1 enable *
      list enable {
        tailf:info "Enable IKEv1 on the specified interface";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key name;
        leaf name {
          tailf:cli-diff-dependency "../../../../interface";
          tailf:cli-diff-dependency "../../../../interface/Management/nameif";
          tailf:cli-diff-dependency "../../../../interface/Ethernet/nameif";
          tailf:cli-diff-dependency "../../../../interface/FastEthernet/nameif";
          tailf:cli-diff-dependency "../../../../interface/GigabitEthernet/nameif";
          tailf:cli-diff-dependency "../../../../interface/TenGigabitEthernet/nameif";
          tailf:cli-diff-dependency "../../../../interface/Vlan/nameif";
          tailf:cli-diff-dependency "../../../../interface/Port-channel/nameif";
          tailf:cli-diff-dependency "../../../../interface/Port-channel-subif/Port-channel/nameif";
          tailf:cli-diff-dependency "../../../../interface/BVI/nameif";
          tailf:cli-diff-dependency "../../../../interface/Redundant/nameif";
          tailf:cli-diff-dependency "../../../../interface/allocated/nameif";
          type nameif-type;
        }
      }
    }

    // crypto isakmp
    container isakmp {
      tailf:info "Configure ISAKMP";

      // crypto isakmp identity
      container "identity" {
        tailf:info "Set identity type (address, hostname or key-id)";
        choice identity-choice {
          leaf address {
            tailf:info "Use the IP address of the interface for the identity";
            type empty;
          }
          leaf auto {
            tailf:info "Identity automatically determined by the connection type:"
              +" IP address for preshared key and Cert DN for Cert based connections";
            type empty;
          }
          leaf hostname {
            tailf:info "Use the hostname of the router for the identity";
            type empty;
          }
          leaf key-id {
            tailf:info "Use the specified key-id for the identity";
            type string {
              tailf:info "WORD;;key-id string";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// track
  /// ========================================================================

  // track * rtr
  list track {
    tailf:info "Object tracking configuration commands";
    tailf:cli-suppress-mode;
    tailf:cli-delete-when-empty;
    tailf:cli-compact-syntax;
    tailf:cli-sequence-commands;
    tailf:cli-incomplete-command;
    key id;
    leaf id {
      tailf:cli-suppress-range;
      type uint16 {
        tailf:info "<1-500>;;Tracked object";
        range "1..500";
      }
    }
    leaf rtr {
      tailf:info "Response Time Reporter (RTR) entry";
      tailf:cli-incomplete-command;
      type uint32 {
        tailf:info "<1-2147483647>;;Entry number";
        range "1..2147483647";
      }
    }
    leaf reachability {
      tailf:info "Reachability";
      type empty;
    }
  }


  /// ========================================================================
  /// bgp-community
  /// ========================================================================

  // bgp-community new-format
  container bgp-community {
    tailf:info "format for BGP community";
    leaf new-format {
      tailf:info "select aa:nn format for BGP community";
      type empty;
    }
  }

  /// ========================================================================
  /// as-path
  /// ========================================================================

  container as-path {
    tailf:info "BGP autonomous system path filter";

    // as-path access-list *
    list access-list {
      tailf:info "Specify an access list number";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key id;
      leaf id {
        tailf:cli-suppress-range;
        type uint16 {
          tailf:info "<1-500>;;AS path access list number";
          range "1..500";
        }
      }
      list rule {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-show-long-obu-diffs;
        ordered-by "user";
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;quoted regular-expression to match BGP AS paths, beginning with deny|permit";
            pattern '(permit .+)|(deny .+)';
          }
        }
      }
    }
  }


  /// ========================================================================
  /// router
  /// ========================================================================

  container router {
    tailf:info "Enable a routing process";
    tailf:cli-diff-dependency "../interface";
    tailf:cli-diff-dependency "../interface/Management/nameif";
    tailf:cli-diff-dependency "../interface/Ethernet/nameif";
    tailf:cli-diff-dependency "../interface/FastEthernet/nameif";
    tailf:cli-diff-dependency "../interface/GigabitEthernet/nameif";
    tailf:cli-diff-dependency "../interface/TenGigabitEthernet/nameif";
    tailf:cli-diff-dependency "../interface/Vlan/nameif";
    tailf:cli-diff-dependency "../interface/Port-channel/nameif";
    tailf:cli-diff-dependency "../interface/Port-channel-subif/Port-channel/nameif";
    tailf:cli-diff-dependency "../interface/BVI/nameif";
    tailf:cli-diff-dependency "../interface/Redundant/nameif";
    tailf:cli-diff-dependency "../interface/allocated/nameif";

    // router rip
    container rip {
      tailf:info "Routing Information Protocol (RIP)";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-router";
      tailf:cli-full-command;
      tailf:cli-delete-when-empty;
      presence true;
      uses router-rip-grouping;
    }

    // router ospf *
    list ospf {
      tailf:info "Open Shortest Path First (OSPF)";
      tailf:cli-mode-name "config-router";
      key id;
      leaf id {
        tailf:cli-suppress-range;
        type uint16 {
          tailf:info "<1-65535>;;Process ID";
          range "1..65535";
        }
      }
      uses router-ospf-grouping;
    }

    // router bgp *
    list bgp {
      tailf:info "Border Gateway Protocol (BGP)";
      tailf:cli-mode-name "config-router";
      max-elements 1;
      key as-no;
      leaf as-no {
        tailf:cli-suppress-range;
        type bgp-as-no-type;
      }
      uses router-bgp-grouping;

      // router bgp * / address-family ipv4 unicast
      container address-family {
        tailf:info "Enter Address Family command mode";
        container ipv4 {
          tailf:info "Address family";
          container unicast {
            tailf:info "Address Family modifier";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-router-af";
            tailf:cli-exit-command "exit-address-family" {
              tailf:info "Exit from Address Family configuration mode";
            }
            tailf:cli-delete-when-empty;
            presence true;
            uses router-bgp-af-grouping;
          }
        }

        // router bgp * / address-family ipv6
        container ipv6 {
          tailf:info "Address family";
          container unicast {
            tailf:info "Address Family modifier";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-router-af";
            tailf:cli-exit-command "exit-address-family" {
              tailf:info "Exit from Address Family configuration mode";
            }
            tailf:cli-delete-when-empty;
            presence true;
            uses router-bgp-af-grouping;
          }
        }
      }
    }

    // router eigrp *
    list eigrp {
      tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
      tailf:cli-mode-name "config-router";
      key as-no;
      leaf as-no {
        tailf:cli-suppress-range;
        type eigrp-as-no-type;
      }
    }
  }


  /// ========================================================================
  /// snmp
  /// ========================================================================

  container snmp {
    tailf:info "Modify non engine SNMP parameters";

  }


  /// ========================================================================
  /// snmp-server
  /// ========================================================================

  container snmp-server {
    tailf:info "Modify SNMP engine parameters";

    // snmp-server community
    container community {
      tailf:info "Configure the community string";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      uses password-08-grouping {
        refine "secret" {
          tailf:meta-data "secret" {
            tailf:meta-value " community <SECRET>";
          }
        }
      }
    }

    // snmp-server contact
    leaf contact {
      tailf:info "Text for mib object sysContact";
      tailf:cli-show-no;
      tailf:cli-multi-value;
      type string {
        tailf:info "LINE;;SNMP contact string";
      }
    }

    // no snmp-server enable
    container enable-conf {
      tailf:cli-drop-node-name;
      leaf enable {
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }
    }

    // snmp-server enable
    container enable {
      tailf:info "Enable/Disable snmp-server or particular traps";
      tailf:cli-incomplete-command;
      tailf:cli-incomplete-no;

      // snmp-server enable traps *
      list traps {
        tailf:info "Configure traps";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-full-command;
        ordered-by "user";
        key name;
        leaf name {
          tailf:cli-multi-word-key;
          type string {
            tailf:info "WORD;;Trap name";
          }
        }
      }
    }

    // snmp-server group *
    list group {
      tailf:info "Define a User Security Model group";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-incomplete-command;
      key id;
      leaf id {
        type string {
          tailf:info "WORD < 33 char;;Name of the group";
        }
      }
      leaf v3 {
        tailf:info "group using the User Security Model (SNMPv3)";
        tailf:cli-incomplete-command;
        type empty;
      }

      leaf security-level {
        tailf:cli-drop-node-name;
        type enumeration {
          enum auth {
            tailf:info "group using the authNoPriv Security Level";
          }
          enum noauth {
            tailf:info "group using the noAuthNoPriv Security Level";
          }
          enum priv {
            tailf:info "group using SNMPv3 authPriv security level";
          }
        }
      }
    }

    // snmp-server user *
    list user {
      tailf:info "Define a user who can access the SNMP engine";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-incomplete-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD < 33 char;;Name of the user";
        }
      }
      leaf groupname {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        tailf:non-strict-leafref {
          path "../../group/id";
        }
        type string {
          tailf:info "WORD;;groupname";
        }
      }
      leaf v3 {
        tailf:info "user using the v3 security model";
        type empty;
      }
      leaf engineID {
        tailf:info "Specify engineID";
        tailf:cli-optional-in-sequence;
        type string {
          tailf:info "WORD < 257 char;;engineID for user";
        }
      }
      leaf encrypted {
        tailf:info "specifying passwords as MD5 or SHA digests";
        tailf:cli-optional-in-sequence;
        tailf:ned-ignore-compare-config;
        type empty;
      }
      leaf auth {
        tailf:info "authentication parameters for the user";
        tailf:cli-incomplete-command;
        type enumeration {
          enum md5 {
            tailf:info "Use HMAC MD5 algorithm for authentication";
          }
          enum sha {
            tailf:info "Use HMAC SHA algorithm for authentication";
          }
        }
      }
      leaf auth-password {
        when "../auth";
        tailf:cli-drop-node-name;
        tailf:meta-data "secret" {
          tailf:meta-value " auth (?:md5|sha) (\\S+) :: ( priv \\S+(?: \\d+)? \\S+)";
        }
        type string {
          tailf:info "WORD < 257 char;;authentication password for user";
        }
      }
      leaf priv {
        tailf:info "encryption parameters for the user";
        tailf:cli-incomplete-command;
        type enumeration {
          enum "3des" {
            tailf:info "Use 168 bit 3DES algorithm for encryption";
          }
          enum "aes" {
            tailf:info "Use AES algorithm for encryption";
          }
          enum "des" {
            tailf:info "Use 56 bit DES algorithm for encryption";
          }
        }
      }
      leaf bits {
        when "../priv = 'aes'";
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type enumeration {
          enum "128" {
            tailf:info "Use 128 bit AES algorithm for encryption";
          }
          enum "192" {
            tailf:info "Use 192 bit AES algorithm for encryption";
          }
          enum "256" {
            tailf:info "Use 256 bit AES algorithm for encryption";
          }
        }
      }
      leaf password {
        when "../priv";
        tailf:cli-drop-node-name;
        tailf:meta-data "secret" {
          tailf:meta-value " priv \\S+(?: 128| 192| 256)? (\\S+) :: ( auth (?:md5|sha) \\S+)";
        }
        type string {
          tailf:info "WORD < 257 char;;privacy password for user";
        }
      }
    }

    // snmp-server host-group *
    list host-group {
      tailf:info "Provide range of hosts";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      key "interface object";
      leaf interface {
        tailf:cli-diff-dependency "../../../interface";
        tailf:cli-diff-dependency "../../../interface/Management/nameif";
        tailf:cli-diff-dependency "../../../interface/Ethernet/nameif";
        tailf:cli-diff-dependency "../../../interface/FastEthernet/nameif";
        tailf:cli-diff-dependency "../../../interface/GigabitEthernet/nameif";
        tailf:cli-diff-dependency "../../../interface/TenGigabitEthernet/nameif";
        tailf:cli-diff-dependency "../../../interface/Vlan/nameif";
        tailf:cli-diff-dependency "../../../interface/Port-channel/nameif";
        tailf:cli-diff-dependency "../../../interface/Port-channel-subif/Port-channel/nameif";
        tailf:cli-diff-dependency "../../../interface/BVI/nameif";
        tailf:cli-diff-dependency "../../../interface/Redundant/nameif";
        tailf:cli-diff-dependency "../../../interface/allocated/nameif";
        type nameif-type;
      }
      leaf object {
        tailf:cli-diff-dependency "../../../object/network";
        type string {
          tailf:info "WORD;;Specify Network object to be associated";
        }
      }
      uses snmp-server-host-grouping;
    }

    // snmp-server host *
    list host {
      tailf:info "Specify hosts to receive SNMP notifications";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      key "interface ip-address";
      leaf interface {
        tailf:cli-diff-dependency "../../../interface";
        tailf:cli-diff-dependency "../../../interface/Management/nameif";
        tailf:cli-diff-dependency "../../../interface/Ethernet/nameif";
        tailf:cli-diff-dependency "../../../interface/FastEthernet/nameif";
        tailf:cli-diff-dependency "../../../interface/GigabitEthernet/nameif";
        tailf:cli-diff-dependency "../../../interface/TenGigabitEthernet/nameif";
        tailf:cli-diff-dependency "../../../interface/Vlan/nameif";
        tailf:cli-diff-dependency "../../../interface/Port-channel/nameif";
        tailf:cli-diff-dependency "../../../interface/Port-channel-subif/Port-channel/nameif";
        tailf:cli-diff-dependency "../../../interface/BVI/nameif";
        tailf:cli-diff-dependency "../../../interface/Redundant/nameif";
        tailf:cli-diff-dependency "../../../interface/allocated/nameif";
        type nameif-type;
      }
      leaf ip-address {
        type host-type {
          tailf:info "WORD;;Hostname or IP/IPv6 address of SNMP notification host";
        }
      }
      uses snmp-server-host-grouping;
    }

    // snmp-server location
    leaf location {
      tailf:info "Text for mib object sysLocation";
      tailf:cli-show-no;
      tailf:cli-multi-value;
      type string {
        tailf:info "LINE;;The physical location of this node";
      }
    }
  }


  /// ========================================================================
  /// sla
  /// ========================================================================

  container sla {
    tailf:info "IP Service Level Agreement";

    // sla monitor
    container monitor {
      tailf:info "IP Service Level Agreement Monitor";

      // sla monitor *
      list entry {
        tailf:cli-drop-node-name;
        tailf:cli-mode-name "config-sla-monitor-echo";
        tailf:cli-explicit-exit;
        tailf:cli-delete-when-empty;
        tailf:cli-full-command;
        key number;
        leaf number {
          tailf:cli-suppress-range;
          type uint32 {
            tailf:info "<1-2147483647>;;Entry Number";
            range "1..2147483647";
          }
        }

        // sla monitor * / type echo protocol
        container "type" {
          tailf:info "Type of entry";
          container echo {
            tailf:info "Echo Operation";
            container protocol {
              tailf:info "Protocol to Use for Operations";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              leaf ipIcmpEcho {
                tailf:info "Use IP/ICMP";
                type empty;
              }
              leaf hostname {
                tailf:cli-drop-node-name;
                type inet:host {
                  tailf:info "Hostname or A.B.C.D;;IP address or hostname";
                }
              }
              leaf interface {
                tailf:info "Interface keyword";
                tailf:cli-diff-dependency "../../../../../../../interface";
                tailf:cli-diff-dependency "../../../../../../../interface/Management/nameif";
                tailf:cli-diff-dependency "../../../../../../../interface/Ethernet/nameif";
                tailf:cli-diff-dependency "../../../../../../../interface/FastEthernet/nameif";
                tailf:cli-diff-dependency "../../../../../../../interface/GigabitEthernet/nameif";
                tailf:cli-diff-dependency "../../../../../../../interface/TenGigabitEthernet/nameif";
                tailf:cli-diff-dependency "../../../../../../../interface/Vlan/nameif";
                tailf:cli-diff-dependency "../../../../../../../interface/Port-channel/nameif";
                tailf:cli-diff-dependency "../../../../../../../interface/Port-channel-subif/Port-channel/nameif";
                tailf:cli-diff-dependency "../../../../../../../interface/BVI/nameif";
                tailf:cli-diff-dependency "../../../../../../../interface/Redundant/nameif";
                tailf:cli-diff-dependency "../../../../../../../interface/allocated/nameif";
                type nameif-type;
              }
            }
          }
        }

        // sla monitor * / num-packets
        leaf num-packets {
          tailf:info "Number of Packets";
          type uint8 {
            tailf:info "<1-100>;;Number of Packets to be transmitted";
            range "1..100";
          }
        }

        // sla monitor * / request-data-size
        leaf request-data-size {
          tailf:info "Request data size";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<0-16384>;;Number of bytes in payload";
            range "0..16384";
          }
        }

        // sla monitor * / tos
        leaf tos {
          tailf:info "Type Of Service";
          type uint8 {
            tailf:info "<0-255>;;Type of Service Value";
          }
        }

        // sla monitor * / timeout
        leaf timeout {
          tailf:info "Timeout of an operation";
          type uint32 {
            tailf:info "<0-604800000>;;Timeout in milliseconds";
            range "0..604800000";
          }
        }

        // sla monitor * / threshold
        leaf threshold {
          tailf:info "Operation threshold in milliseconds";
          tailf:cli-full-command;
          tailf:cli-no-value-on-delete;
          type uint32 {
            tailf:info "0-2147483647;;Millisecond threshold value";
            range "0..2147483647";
          }
        }

        // sla monitor * / frequency
        leaf frequency {
          tailf:info "Frequency of an operation";
          tailf:cli-full-command;
          tailf:cli-no-value-on-delete;
          type uint32 {
            tailf:info "1-604800;;Frequency in seconds";
            range "1..604800";
          }
       }
      }

      // sla monitor schedule *
      list schedule {
        tailf:info "IP SLA Monitor Entry Scheduling";
        tailf:cli-suppress-mode;
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        key number;
        leaf number {
          tailf:cli-suppress-range;
          tailf:non-strict-leafref {
            path "../../entry/number";
          }
          type uint32 {
            tailf:info "<1-2147483647>;;Entry Number";
            range "1..2147483647";
          }
        }

        // sla monitor schedule * life
        leaf life {
          tailf:info "Length of time to execute in seconds";
          type union {
            type enumeration {
              enum "forever" {
                tailf:info "continue running forever";
              }
            }
            type uint32 {
              tailf:info "<0-2147483647>;;Life seconds";
              range "0..2147483647";
            }
          }
        }

        // sla monitor schedule * start-time
        container start-time {
          tailf:info "When to start this entry";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          choice start-time-choice {
            leaf after {
              tailf:info "Start after a certain amount of time from now";
              type string {
                tailf:info "hh:mm:ss;;Start after (hh:mm:ss) has elapsed";
              }
            }
            leaf now {
              tailf:info "Start now";
              type empty;
            }
            leaf pending {
              tailf:info "Start pending";
              type empty;
            }
            container hhmmss {
              tailf:cli-drop-node-name;
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              leaf hhmmss {
                tailf:cli-drop-node-name;
                type hhmmss-type {
                  tailf:info "hh:mm:ss;;Start time (hh:mm:ss)";
                }
              }
              leaf day-of-month {
                tailf:cli-drop-node-name;
                tailf:cli-break-sequence-commands;
                type uint8 {
                  tailf:info "<1-31>;;Day of the month";
                  range "1..31";
                }
              }
              leaf month {
                tailf:cli-drop-node-name;
                type string {
                  tailf:info "MONTH;;Month of the year";
                }
              }
            }
          }
        }

        // sla monitor schedule * ageout
        leaf ageout {
          tailf:info "How long to keep this Entry when inactive";
          type uint32 {
            tailf:info "0-2073600;;Ageout Seconds";
            range "0..2073600";
          }
        }

        // sla monitor schedule * recurring
        leaf recurring {
          tailf:info "Probe to be scheduled automatically every day";
          type empty;
        }
      }
    }
  }

  /// ========================================================================
  /// sysopt
  /// ========================================================================

  container sysopt {
    tailf:info "Set system functional options";

    // sysopt noproxyarp *
    list noproxyarp {
      tailf:info "Disable proxy ARP";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        tailf:cli-diff-dependency "../../../interface";
        tailf:cli-diff-dependency "../../../interface/Management/nameif";
        tailf:cli-diff-dependency "../../../interface/Ethernet/nameif";
        tailf:cli-diff-dependency "../../../interface/FastEthernet/nameif";
        tailf:cli-diff-dependency "../../../interface/GigabitEthernet/nameif";
        tailf:cli-diff-dependency "../../../interface/TenGigabitEthernet/nameif";
        tailf:cli-diff-dependency "../../../interface/Vlan/nameif";
        tailf:cli-diff-dependency "../../../interface/Port-channel/nameif";
        tailf:cli-diff-dependency "../../../interface/Port-channel-subif/Port-channel/nameif";
        tailf:cli-diff-dependency "../../../interface/BVI/nameif";
        tailf:cli-diff-dependency "../../../interface/Redundant/nameif";
        tailf:cli-diff-dependency "../../../interface/allocated/nameif";
        type nameif-type;
      }
    }

    // sysopt traffic detailed-statistics
    container traffic {
      tailf:info "Change Traffic System Options";
      leaf detailed-statistics {
        tailf:info "Calculate per-second per-protocol statistics";
        type empty;
      }
    }

    // sysopt connection
    container connection {
      tailf:info "Configure sysopt connection settings";

      // sysopt connection preserve-vpn-flows
      leaf preserve-vpn-flows {
        tailf:info "Preserve stateful VPN flows when the tunnel drops";
        type empty;
      }

      // sysopt connection tcpmss
      leaf tcpmss {
        tailf:info "Set maximum TCP MSS limit. Default 1380";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<0-65535>;;TCP MSS limit in bytes";
        }
        default 1380;
      }

      // sysopt connection tcpmss minimum
      container tcpmss-minimum {
        tailf:cli-drop-node-name;
        container tcpmss {
          tailf:info "Set minimum TCP MSS limit. Default 0";
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          leaf minimum {
            tailf:info "Set minimum limit of TCP MSS";
            type uint16 {
              tailf:info "<0-65535>;;TCP MSS limit in bytes, minimum default is 0";
            }
            default 0;
          }
        }
      }

      // sysopt connection timewait
      leaf timewait {
        tailf:info "TCP connection undergoes TIMEWAIT state";
        type empty;
      }

      // no sysopt connection permit-vpn
      leaf permit-vpn {
        tailf:info "Exempt VPN traffic from access check";
        tailf:cli-boolean-no;
        type boolean;
        default true;
      }

      // no sysopt connection reclassify-vpn
      leaf reclassify-vpn {
        tailf:info "Reclassify existing flows when VPN tunnels establish";
        tailf:cli-boolean-no;
        type boolean;
        default true;
      }
    }

    // sysopt radius ignore-secret
    container radius {
      tailf:info "Ignore secret in RADIUS accounting responses";
      leaf ignore-secret {
        tailf:info "Ignore secret in RADIUS accounting responses";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// arp
  /// ========================================================================

  container arp {
    tailf:info "Change or view ARP table, set ARP timeout value, view "
      +"statistics";

    // arp *
    list entry {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-remove-before-change;
      tailf:cli-incomplete-command;
      key name;
      leaf name {
        tailf:cli-disallow-value "timeout|rate-limit|permit-nonconnected";
        tailf:cli-diff-dependency "../../../interface";
        tailf:cli-diff-dependency "../../../interface/Management/nameif";
        tailf:cli-diff-dependency "../../../interface/Ethernet/nameif";
        tailf:cli-diff-dependency "../../../interface/FastEthernet/nameif";
        tailf:cli-diff-dependency "../../../interface/GigabitEthernet/nameif";
        tailf:cli-diff-dependency "../../../interface/TenGigabitEthernet/nameif";
        tailf:cli-diff-dependency "../../../interface/Vlan/nameif";
        tailf:cli-diff-dependency "../../../interface/Port-channel/nameif";
        tailf:cli-diff-dependency "../../../interface/Port-channel-subif/Port-channel/nameif";
        tailf:cli-diff-dependency "../../../interface/BVI/nameif";
        tailf:cli-diff-dependency "../../../interface/Redundant/nameif";
        tailf:cli-diff-dependency "../../../interface/allocated/nameif";
        type nameif-type;
      }
      leaf ip_address {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        tailf:code-name "ipv4_address";
        type inet:host {
          tailf:info "Hostname or A.B.C.D;;IP address for an ARP table entry";
        }
      }
      leaf mac_address {
        tailf:cli-drop-node-name;
        tailf:code-name "arp_mac_address";
        type string {
          tailf:info "H.H.H;;Hardware MAC address";
        }
      }
      leaf alias {
        tailf:info "Don't expire this ARP entry after timeout";
        type empty;
      }
    }

    // arp timeout
    leaf timeout {
      tailf:info "Configure ARP timeout value";
      tailf:cli-full-command;
      type uint32 {
        tailf:info "<60-4294967>;;Duration in seconds that an ARP entry will "
          +"remain in the table, default is 14400";
        range "60..4294967";
      }
      default 14400;
    }

    // arp rate-limit
    leaf rate-limit {
      tailf:info "Configure ARP rate-limit value";
      type uint16 {
        tailf:info "<10-32768>;;ARP rate-limit in packets per second";
        range "10..32768";
      }
    }

    // arp permit-nonconnected
    // no arp permit-nonconnected
    leaf permit-nonconnected {
      tailf:info "Populate ARP cache with non-connected subnets";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
    }
  }


  /// ========================================================================
  /// dns
  /// ========================================================================

  container dns {
    tailf:info "Add DNS functionality to an interface";
    tailf:cli-case-insensitive;

    // dns domain-looup *
    list domain-lookup {
      tailf:info "Enable/Disable DNS host-to-address translation";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        tailf:cli-diff-dependency "../../../interface";
        tailf:cli-diff-dependency "../../../interface/Management/nameif";
        tailf:cli-diff-dependency "../../../interface/Ethernet/nameif";
        tailf:cli-diff-dependency "../../../interface/FastEthernet/nameif";
        tailf:cli-diff-dependency "../../../interface/GigabitEthernet/nameif";
        tailf:cli-diff-dependency "../../../interface/TenGigabitEthernet/nameif";
        tailf:cli-diff-dependency "../../../interface/Vlan/nameif";
        tailf:cli-diff-dependency "../../../interface/Port-channel/nameif";
        tailf:cli-diff-dependency "../../../interface/Port-channel-subif/Port-channel/nameif";
        tailf:cli-diff-dependency "../../../interface/BVI/nameif";
        tailf:cli-diff-dependency "../../../interface/Redundant/nameif";
        tailf:cli-diff-dependency "../../../interface/allocated/nameif";
        type nameif-type;
      }
    }

    // dns server-group *
    list server-group {
      tailf:info "DNS server group name";
      tailf:cli-mode-name "config-dns-server-group";
      tailf:cli-full-command;
      tailf:cli-diff-dependency "../domain-lookup";
      tailf:cli-explicit-exit;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;DNS server group name";
        }
      }

      // dns server-group * / name-server
      leaf-list name-server {
        tailf:info "Specify DNS servers";
        tailf:cli-list-syntax;
        tailf:cli-diff-dependency "../../../name";
        type inet:host {
          tailf:info "Hostname or A.B.C.D;;Server address";
        }
      }

      // dns server-group * / domain-name
      leaf domain-name {
        tailf:info "Domain name to append to DNS queries for this server group";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;Domain names must begin and end with a "+
            "digit/letter, only letters, digits, and hyphen are allowed as "+
            "internal characters, labels are separated by a dot. A maximum "+
            "of 63 characters is allowed. ";
          length "0..63";
        }
      }
    }
  }


  /// ========================================================================
  /// prompt
  /// ========================================================================

  // prompt *
  leaf-list prompt {
    tailf:info "Configure session prompt display";
    tailf:cli-flat-list-syntax;
    tailf:cli-replace-all;
    ordered-by user;
    type enumeration {
      enum hostname {
        tailf:info "Display the hostname in the session prompt";
      }
      enum domain {
        tailf:info "Display the domain in the session prompt";
      }
      enum context {
        tailf:info "Display the context in the session prompt (multimode only)";
      }
      enum cluster-unit {
        tailf:info "Display the cluster unit name in the session prompt";
      }
      enum management-mode {
        tailf:info "Display management mode";
      }
      enum priority {
        tailf:info "Display the priority in the session prompt";
      }
      enum state {
        tailf:info "Display the traffic passing state in the session prompt";
      }
    }
  }


  /// ========================================================================
  /// jumbo-frame
  /// ========================================================================

  container jumbo-frame {
    tailf:info "Configure jumbo-frame support";

    /// jumbo-frame reservation
    leaf reservation {
      tailf:info "Enable jumbo-frame support and reserve the necessary memory."
        +"A reboot will be required for the change to take affect.";
      type empty;
    }
  }


  /// ========================================================================
  /// console
  /// ========================================================================

  container console {
    tailf:info "Serial console functions";

    // console timeout
    leaf timeout {
      tailf:info "Idle time in minutes after which a console session will be "
        +"closed, 0 means timeout is disabled";
      type uint8 {
        tailf:info "<0-60>;;Idle time in minutes after which a console "+
          "session will be closed, 0 means timeout is disabled";
        range "0..60";
      }
    }
  }


  /// ========================================================================
  /// ssl
  /// ========================================================================

  container ssl {
    tailf:info "Configure SSL options";

    // ssl cipher
    container cipher {
      tailf:info "This is the ciphers to be used with SSL.";

      // ssl cipher default
      container "default" {
        tailf:info "Specify the set of ciphers for outbound connections";
        uses cipher-grouping;
      }

      // ssl cipher dtlsv1
      container dtlsv1 {
        tailf:info "Specify the ciphers for DTLSv1 inbound connections";
        uses cipher-grouping;
      }

      // ssl cipher sslv3
      container sslv3 {
        tailf:info "Specify the ciphers for SSLv3 inbound connections";
        uses cipher-grouping;
      }

      // ssl cipher tlsv1
      container tlsv1 {
        tailf:info "Specify the ciphers for TLSv1 inbound connections";
        uses cipher-grouping;
      }

      // ssl cipher tlsv1.1
      container "tlsv1.1" {
        tailf:info "Specify the ciphers for TLSv1.1 inbound connections";
        uses cipher-grouping;
      }

      // ssl cipher tlsv1.2
      container "tlsv1.2" {
        tailf:info "Specify the ciphers for TLSv1.2 inbound connections";
        uses cipher-grouping;
      }
    }

    // ssl server-version
    leaf server-version {
      tailf:info "The minimum SSL/TLS protocol version to use when acting as a server";
      type tls-version-type;
    }

    // ssl client-version
    leaf client-version {
      tailf:info "The SSL/TLS protocol version to use when acting as a client";
      type tls-version-type;
    }

    // ssl trust-point
    leaf trust-point {
      tailf:info "Configure the ssl certificate trustpoint";
      tailf:non-strict-leafref {
        path "../../crypto/ca/trustpoint/id";
      }
      type string {
        tailf:info "WORD;;configured trustpoints";
      }
    }

    // ssl trust-point * interface
    container trust-point-list {
      tailf:cli-drop-node-name;
      list trust-point {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        key interface;
        leaf interface {
          tailf:cli-diff-dependency "../../../../interface";
          tailf:cli-diff-dependency "../../../../interface/Management/nameif";
          tailf:cli-diff-dependency "../../../../interface/Ethernet/nameif";
          tailf:cli-diff-dependency "../../../../interface/FastEthernet/nameif";
          tailf:cli-diff-dependency "../../../../interface/GigabitEthernet/nameif";
          tailf:cli-diff-dependency "../../../../interface/TenGigabitEthernet/nameif";
          tailf:cli-diff-dependency "../../../../interface/Vlan/nameif";
          tailf:cli-diff-dependency "../../../../interface/Port-channel/nameif";
          tailf:cli-diff-dependency "../../../../interface/Port-channel-subif/Port-channel/nameif";
          tailf:cli-diff-dependency "../../../../interface/BVI/nameif";
          tailf:cli-diff-dependency "../../../../interface/Redundant/nameif";
          tailf:cli-diff-dependency "../../../../interface/allocated/nameif";
          type nameif-type;
        }
        leaf name {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          tailf:non-strict-leafref {
            path "../../../../crypto/ca/trustpoint/id";
          }
          type string {
            tailf:info "WORD;;configured trustpoints";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// webvpn
  /// ========================================================================

  container webvpn {
    tailf:info "Configure the WebVPN service";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-webvpn";

    // webvpn / enable *
    list enable {
      tailf:info "Enable WebVPN on the specified interface";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        tailf:cli-diff-dependency "../../../interface";
        tailf:cli-diff-dependency "../../../interface/Management/nameif";
        tailf:cli-diff-dependency "../../../interface/Ethernet/nameif";
        tailf:cli-diff-dependency "../../../interface/FastEthernet/nameif";
        tailf:cli-diff-dependency "../../../interface/GigabitEthernet/nameif";
        tailf:cli-diff-dependency "../../../interface/TenGigabitEthernet/nameif";
        tailf:cli-diff-dependency "../../../interface/Vlan/nameif";
        tailf:cli-diff-dependency "../../../interface/Port-channel/nameif";
        tailf:cli-diff-dependency "../../../interface/Port-channel-subif/Port-channel/nameif";
        tailf:cli-diff-dependency "../../../interface/BVI/nameif";
        tailf:cli-diff-dependency "../../../interface/Redundant/nameif";
        tailf:cli-diff-dependency "../../../interface/allocated/nameif";
        type nameif-type;
      }
    }

    // webvpn / hostscan
    container hostscan {
      tailf:info "This specifies whether Cisco Hostscan is enabled and the package file name to be used.";
      leaf image {
        tailf:info "Cisco Hostscan package file path";
        type string {
          tailf:info "WORD;;Cisco Hostscan package file path";
        }
      }
      leaf enable {
        tailf:info "Enable Hostscan";
        type empty;
      }
    }

    // webvpn / anyconnect-essentials
    container anyconnect-essentials {
      tailf:info "Enable/Disable AnyConnect Essentials";
      presence true;
    }

    // webvpn / anyconnect-custom-attr *
    list anyconnect-custom-attr {
      tailf:info "Define custom user policy attributes for AnyConnect";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        type string {
          tailf:info "WORD < 33 char;;The name of the attribute";
          length "1..32";
        }
      }
      leaf description {
        tailf:cli-multi-value;
        type string {
          tailf:info "LINE < 129 char;;The description of the custom attribute";
          length "1..129";
        }
      }
    }

    // webvpn / anyconnect
    container anyconnect {
      tailf:info "AnyConnect configuration parameters";

      // webvpn / anyconnect enable
      leaf enable {
        tailf:info "Enable the AnyConnect Client";
        type empty;
      }

      // webvpn / anyconnect image *
      list image {
        tailf:info "Configure the AnyConnect client package file path";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          tailf:cli-multi-word-key;
          type string;
        }
      }
      // webvpn / anyconnect profiles *
      list profiles {
        tailf:info "Configure the AnyConnect client profiles package filepath";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "name option";
        leaf name {
          type string;
        }
        leaf option {
          type string;
        }
      }
    }

    // webvpn / tunnel-group-list
    leaf tunnel-group-list {
      tailf:info "Configure WebVPN group list dropdown in login page";
      type string;
    }

    // webvpn / tunnel-group-preference
    leaf tunnel-group-preference {
      tailf:info "Enable/Disable Tunnel Group Preference";
      type enumeration {
        enum "group-url" {
          tailf:info "Prefer tunnel-group specified by group-url over "
          +"certificate map";
        }
      }
    }

    // webvpn / cache
    container cache {
      tailf:info "Configure WebVPN cache";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-webvpn-cache";

      // webvpn / cache / disable
      // webvpn / cache / no disable
      leaf disable {
        tailf:info "Disable cache";
        tailf:cli-full-command;
        tailf:cli-boolean-no;
        type boolean;
      }
    }

    // webvpn / certificate-group-map *
    list certificate-group-map {
      tailf:info "Associate a tunnel-group with a certificate map rule";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key "ca sequence tunnel";
      leaf ca {
        tailf:non-strict-leafref {
          path "../../../crypto/ca/certificate/map/label";
        }
        type string {
          tailf:info "WORD < 65 char;;Certificate map name";
          length "1..65";
        }
      }
      leaf sequence {
        tailf:non-strict-leafref {
          path "../../../crypto/ca/certificate/map/sequence";
        }
        type uint16 {
          tailf:info "<1-65535>;;Index of the map entry to associate with "
            +"the tunnel group";
          range "1..65535";
        }
      }
      leaf tunnel {
        tailf:cli-diff-dependency
          "../../../tunnel-group/tunnel-group-list[name=current()/../tunnel]";
        tailf:cli-diff-dependency
          "../../../tunnel-group/tunnel-group-general-attributes"
          +"[name=current()/../tunnel]";
        tailf:cli-diff-dependency
          "../../../tunnel-group/tunnel-group-webvpn-attributes"
          +"[name=current()/../tunnel]";
        type string {
          tailf:info "WORD < 65 char;;Tunnel group name";
          length "1..65";
        }
      }
    }

    // webvpn / error-recovery disable
    // webvpn / no error-recovery disable
    container error-recovery {
      tailf:info "Contact TAC before using this command";
      leaf disable {
        tailf:info "Disables WebVPN error recovery";
        tailf:cli-boolean-no;
        type boolean;
      }
    }
  }


  /// ========================================================================
  /// anyconnect-custom-data
  /// ========================================================================

  // anyconnect-custom-data * *
  list anyconnect-custom-data {
    tailf:info "Configure the value of a custom AnyConnect attribute";
    tailf:cli-suppress-mode;
    tailf:cli-delete-when-empty;
    tailf:cli-compact-syntax;
    tailf:cli-incomplete-command;
    key name;
    leaf name {
      tailf:non-strict-leafref {
        path "../../webvpn/anyconnect-custom-attr/name";
      }
      type string {
        tailf:info "WORD;;attribute type";
      }
    }
    list attr-name {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD < 33 char;;The name of custom attribute ";
        }
      }
      leaf-list attr-value {
        tailf:cli-drop-node-name;
        tailf:cli-list-syntax;
        tailf:cli-remove-before-change;
        tailf:cli-suppress-no;
        type string {
          tailf:info "LINE < 421 char;;A string value for this custom attribute";
        }
      }
    }
  }


  /// ========================================================================
  /// group-policy
  /// ========================================================================

  container group-policy {
    tailf:info "Configure or remove a group policy";

    // group-policy * internal
    list group-policy-internal {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        type string {
          tailf:info "WORD < 65 char;;Enter the name of the group policy";
        }
      }
      leaf internal {
        tailf:info "Enter this keyword to specify an internal group policy";
        tailf:cli-full-command;
        type empty;
      }
    }

    // group-policy * attributes
    list group-policy-attributes {
      tailf:cli-drop-node-name;
      tailf:cli-mode-name "config-group-policy";
      tailf:cli-diff-dependency "../../group-policy/group-policy-internal";
      tailf:cli-sequence-commands;
      tailf:cli-incomplete-command;
      tailf:cli-explicit-exit;  // to assure in right mode for webvpn
      key name;
      leaf name {
        type string {
          tailf:info "WORD < 65 char;;Enter the name of the group policy";
        }
        tailf:non-strict-leafref {
          path "../../group-policy-internal/name";
        }
      }
      leaf attributes {
        tailf:info "Enter the attributes sub-command mode";
        tailf:cli-hide-in-submode;
        tailf:cli-full-command;
        type empty;
      }

      // group-policy * attributes / banner value
      container banner {
        tailf:cli-break-sequence-commands;
        tailf:info "Configure a banner, or welcome text to be displayed on the VPN remote client";
        leaf value {
          tailf:info "Specify the banner or welcome text to be displayed on the VPN remote client";
          tailf:cli-no-name-on-delete;
          tailf:cli-no-value-on-delete;
          type string {
            tailf:info "LINE;;Quoted string. Use \\r\\n for newline";
          }
        }
      }

      // group-policy * attributes / group-lock
      container group-lock {
        tailf:info "Enter name of an existing tunnel-group that users are "+
          "required to connect with";
        choice group-lock-choice {

          // group-policy * attributes / group-lock none
          leaf none {
            tailf:info "Specify that there is no group-lock restriction";
            type empty;
          }

          // group-policy * attributes / group-lock value
          leaf value {
            tailf:info "Specify the name of an existing tunnel-group "+
              "that the user is required to connect with";
            type string {
              tailf:info "LINE < 65 char;;Name of an existing tunnel-group";
            }
          }
        }
      }

      // group-policy * attributes / user-authentication
      leaf user-authentication {
        tailf:info "Configure individual user authentication. "+
          "This setting applies only to HW clients.";
        tailf:cli-full-command;
        type enumeration {
          enum disable {
            tailf:info "Disable individual user authentication";
          }
          enum enable {
            tailf:info "Enable individual user authentication";
          }
        }
      }

      // group-policy * attributes / address-pools
      container address-pools {
        tailf:info "Configure list of up to 6 address pools to assign addresses from";
        choice address-pools-choice {

          // group-policy * attributes / address-pools none
          leaf none {
            tailf:info "Specify no address-pools, and disable inheritance";
            type empty;
          }

          // group-policy * attributes / address-pools value
          leaf-list "value" {
            tailf:info "Specify a list of up to 6 address pools to assign addresses from";
            tailf:cli-flat-list-syntax;
            tailf:cli-replace-all;
            tailf:cli-diff-dependency "../../../../ip/local/pool";
            max-elements 6;
            type string {
              tailf:info "WORD < 64 char;;Enter the name of up to 6 local "+
                "address pools. Entries are delimited by spaces.";
            }
          }
        }
      }

      // group-policy * attributes / split-tunnel-policy
      leaf split-tunnel-policy {
        tailf:info "Select the split tunneling method to be used for "+
          "IPv4 traffic by the remote client";
        tailf:cli-full-command;
        type enumeration {
          enum excludespecified {
            tailf:info "Exclude only networks specified by "+
              "split-tunnel-network-list";
          }
          enum tunnelall {
            tailf:info "Tunnel everything";
          }
          enum tunnelspecified {
            tailf:info "Tunnel only networks specified by "+
              "split-tunnel-network-list";
          }
        }
      }

      // group-policy * attributes / split-tunnel-network-list
      container split-tunnel-network-list {
        tailf:info "Configure name of access-list for split tunnel "+
          "configuration";
        choice split-tunnel-network-list-choice {
          leaf none {
            tailf:info "Specify that no access-list will be used for split "+
              "tunnel configuration";
            type empty;
          }
          leaf value {
            tailf:info "Specify a standard or extended type access-list "+
              "for split tunnel configuration";
            tailf:cli-diff-dependency "../../../../access-list/access-list-id";
            tailf:non-strict-leafref {
              path "../../../../access-list/access-list-id/id";
            }
            type string {
              tailf:info "WORD;;Name of a standard or extended type "+
                "access-list for split tunnel configuration";
            }
          }
        }
      }

      // group-policy * attributes / default-domain
      container default-domain {
        tailf:info "Configure default domain name given to users of this "+
          "group";
        choice default-domain-choice {
          leaf none {
            tailf:info "Specify that no default domain name will be given "+
              "to users of this group";
            type empty;
          }
          leaf value {
            tailf:info "Specify the default domain name given to users of this group";
            type string {
              tailf:info "LINE < 256 char;;Default domain name given to users "+
                "of this group";
            }
          }
        }
      }

      // group-policy * attributes / vpn-filter
      container vpn-filter {
        tailf:info "Enter name of a configured ACL to apply to users";
        choice vpn-filter-choice {

          // group-policy * attributes / vpn-filter none
          leaf none {
            tailf:info "Specify that no filter will be applied to users";
            type empty;
          }

          // group-policy * attributes / vpn-filter value
          leaf "value" {
            tailf:info "Specify the name of a filter that will be applied to users";
            tailf:cli-diff-dependency "../../../../access-list/access-list-id";
            tailf:non-strict-leafref {
              path "../../../../access-list/access-list-id/id";
            }
            type string {
              tailf:info "WORD;;User specific ACL";
            }
          }
        }
      }

      // group-policy * attributes / wins-server
      container wins-server {
        tailf:info "Configure the primary and secondary WINS servers";
        choice wins-server-choice {
          leaf none {
            tailf:info "No wins-server will be specified and disable inheritance";
            type empty;
          }
          leaf-list "value" {
            tailf:cli-flat-list-syntax;
            tailf:cli-replace-all;
            max-elements 2;
            ordered-by user;
            type inet:ip-address {
              tailf:info "A.B.C.D;;The IP address of WINS server, max 2.";
            }
          }
        }
      }

      // group-policy * attributes / dns-server
      container dns-server {
        tailf:info "Configure the primary and secondary DNS servers";
        choice dns-server-choice {

          // group-policy * attributes / dns-server none
          leaf none {
            tailf:info "No dns-server will be specified and disable inheritance";
            type empty;
          }

          // group-policy * attributes / dns-server value
          leaf-list "value" {
            tailf:info "DNS servers, at most two ipv4 and two ipv6 addresses";
            tailf:cli-flat-list-syntax;
            tailf:cli-replace-all;
            max-elements 4;
            ordered-by user;
            type union {
              type inet:ip-address {
                tailf:info "A.B.C.D;;The IP address of the First DNS server";
              }
              type inet:ipv6-address {
                tailf:info "X:X:X:X::X;;The IP address of the First DNS server";
              }
            }
          }
        }
      }

      // group-policy * attributes / dns-server
      leaf-list vpn-tunnel-protocol {
        tailf:info "Enter permitted tunneling protocols";
        tailf:cli-flat-list-syntax;
        tailf:cli-replace-all;
        type enumeration {
          enum ikev1 {
            tailf:info "IKE version 1";
          }
          enum ikev2 {
            tailf:info "IKE version 2";
          }
          enum l2tp-ipsec {
            tailf:info "L2TP using IPSec for security";
          }
          enum ssl-client {
            tailf:info "SSL VPN Client";
          }
          enum ssl-clientless {
            tailf:info "SSL Clientless VPN";
          }
        }
      }

      // group-policy * attributes / split-dns
      container split-dns {
        tailf:info "Configure list of domains to be resolved through "
        +"the Split Tunnel";

        leaf-list value {
          tailf:info "Specify a list of domains to be resolved through "
          +"the Split Tunnel";
          tailf:cli-flat-list-syntax;
          tailf:cli-replace-all;
          tailf:cli-full-command;
          type string {
            tailf:info "LINE < 256 char  Enter a list of domains to be "
            +"resolved through the Split Tunnel, separated with spaces.";
          }
        }
      }

      // group-policy * attributes / vpn-simultaneous-logins
      leaf vpn-simultaneous-logins {
        tailf:info "Enter maximum number of simultaneous logins allowed";
        tailf:cli-full-command;
        type uint32 {
          tailf:info "<0-2147483647>;;Maximum number of simultaneous logins "
          +"allowed, enter 0 to disable login and prevent user access";
          range "0..2147483647";
        }
      }

      // group-policy * attributes / vpn-idle-timeout minutes
      container vpn-idle-timeout {
        tailf:info "Enter idle timeout period in minutes";
        leaf minutes {
          tailf:cli-drop-node-name;
          tailf:cli-full-command;
          type uint32 {
            tailf:info "<1-35791394>;;Number of minutes";
            range "1..35791394";
          }
        }
      }

      // group-policy * attributes / vpn-session-timeout
      container vpn-session-timeout {
        tailf:info "Enter maximum user connection time in minutes, "
          +"enter none for unlimited time";

        leaf minutes {
          tailf:cli-drop-node-name;
          tailf:cli-full-command;
          type uint32 {
            tailf:info "<1-4473924>;;Number of minutes";
            range "1..4473924";
          }
        }
      }

      // group-policy * attributes / msie-proxy
      container msie-proxy {
        tailf:info "Enter this command to configure MSIE Browser Proxy "
          +"settings for a client system";

        // group-policy * attributes / msie-proxy server
        container server {
          tailf:info "Set the IE Browser Proxy server:port setting for "+
            "the client PC";
          choice service-choice {
            leaf none {
              tailf:info "No IP address/name will be specified for proxy "+
                "server and disable inheritance";
              type empty;
            }
            leaf "value" {
              tailf:info "Specify the ip address or name of a MSIE "+
                "<server>:<port> that will be applied for this client system.";
              type string {
                tailf:info "LINE < 100 char;;Proxy server ip address/name and "+
                  "port to apply to this client system";
                length "1..99";
              }
            }
          }
        }

        // group-policy * attributes / msie-proxy pac-url
        container pac-url {
          tailf:info "Set the PAC URL";
          choice pac-url-choice {
            leaf none {
              tailf:info "No URL will be specified for proxy PAC File "+
                "and disable inheritance";
              type empty;
            }
            leaf "value" {
              tailf:info "Specify the PAC URL";
              type string {
                tailf:info "LINE < 128;;char  Proxy PAC URL";
                length "1..127";
              }
            }
          }
        }

        // group-policy * attributes / msie-proxy lockdown
        leaf lockdown {
          tailf:info "Set the IE Browser Proxy lockdown setting for the "
            +"client PC";
          tailf:cli-full-command;
          type enumeration {
            enum disable {
              tailf:info "Do not allow proxy lockdown for this client system";
            }
            enum enable {
              tailf:info "Allow proxy lockdown for this client system";
            }
          }
        }

        // group-policy * attributes / msie-proxy method
        leaf method {
          tailf:info "Set the IE Browser Proxy method setting for the client PC";
          type enumeration {
            enum auto-detect {
              tailf:info "Set the IE Browser Proxy method setting as auto-detect";
            }
            enum no-modify {
              tailf:info "Set the IE Browser Proxy method setting as no-modify";
            }
            enum no-proxy {
              tailf:info "Set the IE Browser Proxy method setting as no-proxy";
            }
            enum none {
              tailf:info "none";
            }
            enum use-pac {
              tailf:info "Set the IE Browser Proxy method setting as use-pac";
            }
            enum use-server {
              tailf:info "Set the IE Browser Proxy method setting as use-server";
            }
          }
        }
      }

      // group-policy * attributes / anyconnect-custom *
      list anyconnect-custom {
        tailf:info "Set the value of a custom AnyConnect attribute "+
          "in a group-policy";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          tailf:non-strict-leafref {
            path "../../../../webvpn/anyconnect-custom-attr/name";
          }
          type string {
            tailf:info "WORD;;attribute type";
          }
        }
        choice none-or-value {
          leaf none {
            tailf:info "This indicates that the attribute is explicitly "+
              "omitted from the policy.";
            tailf:cli-no-name-on-delete;
            type empty;
          }
          leaf "value" {
            tailf:info "The name of configured custom attribute data.";
            tailf:cli-no-name-on-delete;
            tailf:cli-no-value-on-delete;
            type string {
              tailf:info "LINE < 33 char;;A string contains the name "+
                "of configured custom attribute data.";
            }
            tailf:cli-diff-dependency "../../../../"+
              "anyconnect-custom-data[name=current()/../name]/attr-name";
          }
        }
      }

      // group-policy * attributes / webvpn
      container webvpn {
        tailf:info "Configure group policy for WebVPN";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-group-webvpn";

        // group-policy * attributes / webvpn / customization
        container customization {
          tailf:info "Configure a customization object";
          choice customization-choice {

            // group-policy * attributes / webvpn / customization none
            leaf none {
              tailf:info "Specify no customization object";
              type empty;
            }

            // group-policy * attributes / webvpn / customization value
            leaf "value" {
              tailf:info "Specify a customization object";
              type enumeration {
                enum DfltCustomization {}
              }
            }
          }
        }

        // group-policy * attributes / webvpn / anyconnect
        container anyconnect {
          tailf:info "AnyConnect Parameters configuration";

          // group-policy * attributes / webvpn / anyconnect ssl
          container ssl {
            tailf:info "Configure AnyConnect with SSL";

            // group-policy * attributes / webvpn / anyconnect ssl keepalive
            leaf keepalive {
              tailf:info "Configure the keepalive for AnyConnect with SSL";
              tailf:cli-full-command;
              type union {
                type uint16 {
                  tailf:info "<15-600>;;Keepalive interval in seconds";
                  range "15..600";
                }
                type enumeration {
                  enum "none" {
                    tailf:info "Disable the keepalive for AnyConnect with SSL";
                  }
                }
              }
            }
          }

          // group-policy * attributes / webvpn / anyconnect dpd-interval
          container dpd-interval {
            tailf:info "Configure the AnyConnect DPD interval";

            // group-policy * attributes / webvpn / anyconnect dpd-interval client
            leaf client {
              tailf:info "Configure the AnyConnect client DPD interval";
              tailf:cli-full-command;
              type union {
                type uint16 {
                  tailf:info "<5-3600>;;DPD timeout in seconds";
                  range "5..3600";
                }
                type enumeration {
                  enum "none" {
                    tailf:info "Disable AnyConnect DPD";
                  }
                }
              }
            }

            // group-policy * attributes / webvpn / anyconnect dpd-interval gateway
            leaf gateway {
              tailf:info "Configure the AnyConnect gateway DPD interval";
              tailf:cli-full-command;
              type union {
                type uint16 {
                  tailf:info "<5-3600>;;DPD timeout in seconds";
                  range "5..3600";
                }
                type enumeration {
                  enum "none" {
                    tailf:info "Disable AnyConnect DPD";
                  }
                }
              }
            }
          }

          // group-policy * attributes / webvpn / anyconnect ask
          container ask {
            tailf:info "Configure the AnyConnect download query";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-all-siblings;
            }
            leaf enable-none {
              tailf:cli-drop-node-name;
              type enumeration {
                enum "enable" {
                  tailf:info "Ask the user to choose between AnyConnect "
                  +"and WebVPN";
                }
                enum "none" {
                  tailf:info "Do not ask the user";
                }
              }
            }

            leaf "default" {
              type enumeration {
                enum "anyconnect" {
                  tailf:info "Select AnyConnect as the default";
                }
                enum "webvpn" {
                  tailf:info "Select WebVPN as the default";
                }
                enum "svc" {
                }
              }
            }

            leaf timeout {
              tailf:info "Select a time out for the query to automatically "
                +"choose the default";
              type uint8 {
                tailf:info "<5-120>;;nummber of seconds";
                range "5..120";
              }
            }
          }

          // group-policy * attributes / webvpn / anyconnect profiles
          container profiles {
            tailf:info "Specify the profiles package to be downloaded";
            choice profiles-choice {
              leaf none {
                tailf:info "Do not download any profiles";
                type empty;
              }
              container "value" {
                tailf:info "Specify the profiles package";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                leaf name {
                  tailf:cli-drop-node-name;
                  type string {
                    tailf:info "WORD;;profile name";
                  }
                }
                leaf "type" {
                  type string {
                  }
                }
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// wccp
  /// ========================================================================

  container wccp {
    tailf:info "Web-Cache Coordination Protocol Commands";

    // wccp web-cache
    leaf web-cache {
      tailf:info "Standard web caching service";
      tailf:cli-full-command;
      type empty;
    }

    // wccp *
    list wccp-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-remove-before-change;
      key id;
      leaf id {
        type uint8 {
          tailf:info "<0-254>;;Dynamically defined service identifier number";
          range "0..254";
        }
      }

      // wccp * redirect-list
      leaf redirect-list {
        tailf:info "Set the access-list used to permit redirection";
        tailf:cli-diff-dependency "../../../access-list/access-list-id";
        tailf:non-strict-leafref {
          path "../../../access-list/access-list-id/id";
        }
        type string {
          tailf:info "WORD;;IP named access list (extended)";
        }
      }

      // wccp * password
      container password {
        tailf:info "Authentication password (key)";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        uses password-08-grouping {
          refine "secret" {
            tailf:meta-data "secret" {
              tailf:meta-value " password <SECRET>";
            }
          }
        }
      }

      // wccp * group-list
      leaf group-list {
        tailf:info "Set the access-list used to permit group membership";
        tailf:cli-diff-dependency "../../../access-list/access-list-id";
        tailf:non-strict-leafref {
          path "../../../access-list/access-list-id/id";
        }
        type string {
          tailf:info "WORD;;IP named access list (extended)";
        }
      }
    }

    // wccp interface *
    list interface {
      tailf:info "Keyword to specify an interface";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-incomplete-command;
      tailf:cli-diff-dependency "../wccp-list";
      tailf:cli-diff-dependency "../wccp-list/id";
      key "interface name";
      leaf interface {
        tailf:cli-diff-dependency "../../../interface";
        tailf:cli-diff-dependency "../../../interface/Management/nameif";
        tailf:cli-diff-dependency "../../../interface/Ethernet/nameif";
        tailf:cli-diff-dependency "../../../interface/FastEthernet/nameif";
        tailf:cli-diff-dependency "../../../interface/GigabitEthernet/nameif";
        tailf:cli-diff-dependency "../../../interface/TenGigabitEthernet/nameif";
        tailf:cli-diff-dependency "../../../interface/Vlan/nameif";
        tailf:cli-diff-dependency "../../../interface/Port-channel/nameif";
        tailf:cli-diff-dependency "../../../interface/Port-channel-subif/Port-channel/nameif";
        tailf:cli-diff-dependency "../../../interface/BVI/nameif";
        tailf:cli-diff-dependency "../../../interface/Redundant/nameif";
        tailf:cli-diff-dependency "../../../interface/allocated/nameif";
        type nameif-type;
      }
      leaf name {
        type union {
          type enumeration {
            enum web-cache {
              tailf:info "Standard web caching service";
            }
          }
          type uint8 {
            tailf:info "<0-254>;;Dynamically defined service identifier number";
            range "0..254";
          }
        }
      }

      // wccp * redirect
      leaf redirect {
        tailf:info "Set packet redirect option for service";
        type enumeration {
          enum "in" {
            tailf:info "Redirect to a Cache Engine appropriate ingress packets";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// tunnel-group
  /// ========================================================================

  container tunnel-group {
    tailf:info "Create and manage the database of connection "+
      "specific records for IPSec connections";

    // tunnel-group *
    list tunnel-group-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD < 65 char;;Enter the name of the tunnel group";
        }
      }
      leaf "type" {
        tailf:cli-no-name-on-delete;
        tailf:cli-no-value-on-delete;
        tailf:cli-full-command;
        type enumeration {
          enum ipsec-l2l {
            tailf:info "IPSec Site to Site group";
          }
          enum ipsec-ra {
            tailf:info "IPSec Remote Access group (DEPRECATED)";
          }
          enum remote-access {
            tailf:info "Remote access (IPSec and WebVPN) group";
          }
          enum webvpn {
            tailf:info "WebVPN group (DEPRECATED)";
          }
        }
      }
    }

    // tunnel-group * general-attributes
    list tunnel-group-general-attributes {
      tailf:cli-drop-node-name;
      tailf:cli-mode-name "config-tunnel-general";
      tailf:cli-sequence-commands;
      tailf:cli-incomplete-command;
      tailf:cli-diff-dependency "../tunnel-group-list";
      key name;
      leaf name {
        type string {
          tailf:info "WORD < 65 char;;Enter the name of the tunnel group";
        }
        tailf:non-strict-leafref {
          path "../../tunnel-group-list/name";
        }
      }
      leaf general-attributes {
        tailf:info "Enter the general-attributes sub command mode";
        tailf:cli-hide-in-submode;
        tailf:cli-full-command;
        type empty;
      }

      // tunnel-group * general-attributes / address-pool
      leaf address-pool {
        tailf:cli-break-sequence-commands;
        tailf:info "Enter a list of address pools to assign addresses from";
        tailf:non-strict-leafref {
          path "../../../ip/local/pool/id";
        }
        type string {
          tailf:info "WORD < 64 char;;Name of address pool to assign addresses from";
          length "0..64";
        }
      }

      // tunnel-group * general-attributes / authorization-server-group
      leaf authorization-server-group {
        tailf:info "Enter name of the authentication server group";
        tailf:non-strict-leafref {
          path "../../../aaa-server/name";
        }
        type string {
          tailf:info "WORD < 257;;char  Name of authorization server group";
          length "0..257";
        }
      }

      // tunnel-group * general-attributes / accounting-server-group
      leaf accounting-server-group {
        tailf:info "Enter name of the accounting server group";
        tailf:non-strict-leafref {
          path "../../../aaa-server/name";
        }
        type string {
          tailf:info "WORD < 257 char;;Name of accounting server group";
          length "0..257";
        }
      }

      // tunnel-group * general-attributes / authentication-server-group
      leaf authentication-server-group {
        tailf:info "Enter name of the authentication server group";
        tailf:non-strict-leafref {
          path "../../../aaa-server/name";
        }
        type string {
          tailf:info "WORD < 257 char;;Name of accounting server group";
          length "0..257";
        }
      }

      // tunnel-group * general-attributes / default-group-policy
      leaf default-group-policy {
        tailf:info "Enter name of the default group policy";
        tailf:cli-diff-dependency "../../../group-policy/group-policy-internal";
        tailf:cli-diff-dependency "../../../group-policy/group-policy-attributes";
        type string {
          tailf:info "WORD < 65 char;;Name of the default group policy";
        }
      }

      // tunnel-group * general-attributes / username-from-certificate
      container username-from-certificate {
        tailf:info "The DN of the peer certificate used as username for "
          +"authorization and/or authentication";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf primary-attr {
          tailf:cli-drop-node-name;
          type attribute-type;
        }
        leaf second-attr {
          tailf:cli-drop-node-name;
          type attribute-type;
        }
      }
    }

    // tunnel-group * webvpn-attributes
    list tunnel-group-webvpn-attributes {
      tailf:cli-drop-node-name;
      tailf:cli-mode-name "config-tunnel-webvpn";
      tailf:cli-incomplete-command;
      tailf:cli-diff-dependency "../tunnel-group-list";
      key name;
      leaf name {
        tailf:non-strict-leafref {
          path "../../tunnel-group-list/name";
        }
        type string {
          tailf:info "WORD < 65 char;;Enter the name of the tunnel group";
          length "0..65";
        }
      }
      leaf webvpn-attributes {
        tailf:info "Enter the webvpn-attributes sub command mode";
        tailf:cli-hide-in-submode;
        tailf:cli-full-command;
        type empty;
      }

      // tunnel-group * webvpn-attributes / authentication
      leaf-list authentication {
        tailf:info "This is the authentication method(s) used with WebVPN";
        tailf:cli-flat-list-syntax;
        tailf:cli-replace-all;
        type enumeration {
          enum "aaa" {
            tailf:info "Use username and password for authentication";
          }
          enum "certificate" {
            tailf:info "Use certificate for authentication";
          }
        }
      }

      // tunnel-group * webvpn-attributes / group-alias *
      list group-alias {
        tailf:info "Enter name of the Group Alias";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key name;
        leaf name {
          type string {
            tailf:info "WORD < 32 char;;Name of the Group Alias. "+
              "A maximum of 32 characters is allowed.";
          }
        }
        leaf "status" {
          tailf:cli-drop-node-name;
          type enumeration {
            enum disable {
              tailf:info "Enter this keyword to disable the alias";
            }
            enum enable {
              tailf:info "Enter this keyword to enable the alias";
            }
          }
        }
      }

      // tunnel-group * webvpn-attributes /  group-url *
      list group-url {
        tailf:info "Enter Group URL";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Group URL "+
              "(supported types: http:// or https://)";
          }
        }
        leaf "status" {
          tailf:cli-drop-node-name;
          type enumeration {
            enum disable {
              tailf:info "Enter this keyword to disable the url";
            }
            enum enable {
              tailf:info "Enter this keyword to enable the url";
            }
          }
        }
      }
    }

    // tunnel-group * ipsec-attributes
    list tunnel-group-ipsec-attributes-list {
      tailf:cli-drop-node-name;
      tailf:cli-mode-name "config-tunnel-ipsec";
      tailf:cli-incomplete-command;
      tailf:cli-diff-dependency "../tunnel-group-list";
      key name;
      leaf name {
        type string {
          tailf:info "WORD < 65 char;;Enter the name of the tunnel group";
        }
      }
      leaf ipsec-attributes {
        tailf:info "Enter the ipsec-attributes sub command mode";
        tailf:cli-hide-in-submode;
        tailf:cli-full-command;
        type empty;
      }

      // tunnel-group * ipsec-attributes / ikev1
      container ikev1 {
        tailf:info "Configure IKEv1";

        // tunnel-group * ipsec-attributes / ikev1 / pre-shared-key
        container pre-shared-key {
          tailf:info "Associate a pre-shared key with the connection policy";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          uses password-08-grouping {
            refine "secret" {
              tailf:meta-data "secret" {
                tailf:meta-value " pre-shared-key <SECRET>";
              }
            }
          }
        }

        // tunnel-group * ipsec-attributes / ikev1 / user-authentication
        container user-authentication {
          tailf:info "Set the IKEv1 user authentication method";
          tailf:cli-compact-syntax;

          leaf type {
            tailf:cli-drop-node-name;
            type enumeration {
              enum "hybrid" {
                tailf:info "IKE Hybrid Authentication for User";
              }
              enum "none" {
                tailf:info "Disable User Authentication";
              }
              enum "xauth" {
                tailf:info "IKE Extended Authentication for User";
              }
            }
          }
        }

        // tunnel-group * ipsec-attributes / ikev1 / trust-point
        leaf trust-point {
          tailf:info "Select the trustpoint that identifies the cert to be "
            +"sent to the IKE peer";
          tailf:non-strict-leafref {
            path "../../../../crypto/ca/trustpoint/id";
          }
          type string {
            tailf:info "WORD;;configured trustpoints";
          }
        }
      }

      // tunnel-group * ipsec-attributes / ikev2
      container ikev2 {
        tailf:info "Configure IKEv2";

        // tunnel-group * ipsec-attributes / ikev2 local-authentication pre-shared-key
        container local-authentication {
          tailf:info "Configure the local authentication method for IKEv2 tunnels";
          container pre-shared-key {
            tailf:info "Configure the local pre-shared-key used to "+
              "authenticate to the remote peer";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            uses password-08-grouping {
              refine "secret" {
                tailf:meta-data "secret" {
                  tailf:meta-value " pre-shared-key <SECRET>";
                }
              }
            }
          }
        }

        // tunnel-group * ipsec-attributes / ikev2 remote-authentication pre-shared-key
        container remote-authentication {
          tailf:info "Configure the remote authentication method required of the remote peer for IKEv2 tunnels";
          container pre-shared-key {
            tailf:info "Require pre-shared-key authentication from remote peer";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            uses password-08-grouping {
              refine "secret" {
                tailf:meta-data "secret" {
                  tailf:meta-value " pre-shared-key <SECRET>";
                }
              }
            }
          }
        }
      }

      // tunnel-group * ipsec-attributes / isakmp keepalive
      container isakmp {
        tailf:info "Configure ISAKMP policy";
        container keepalive {
          tailf:info "Configure ISAKMP keepalives";
          presence true;

          // tunnel-group * ipsec-attributes / isakmp keepalive disable
          leaf disable {
            tailf:info "Disable IKE keepalives";
            type empty;
          }
        }
      }

      // tunnel-group * ipsec-attributes / peer-id-validate
      leaf peer-id-validate {
        tailf:info "Validate identity of the peer using the peer's certificate";
        tailf:cli-full-command;
        type enumeration {
          enum "cert" {
            tailf:info "If supported by certificate";
          }
          enum "nocheck" {
            tailf:info "Do not check";
          }
          enum "req" {
            tailf:info "Required";
          }
        }
      }

      // tunnel-group * ipsec-attributes / chain
      leaf chain {
        tailf:info "Enable sending certificate chain";
        type empty;
      }
    }

    // tunnel-group * ppp-attributes
    list tunnel-group-ppp-attributes {
      tailf:cli-drop-node-name;
      tailf:cli-mode-name "config-tunnel-ppp";
      tailf:cli-incomplete-command;
      tailf:cli-delete-when-empty;
      tailf:cli-diff-dependency "../tunnel-group-list";
      key name;
      leaf name {
        type string {
          tailf:info "WORD < 65 char;;Enter the name of the tunnel group";
        }
      }
      leaf ppp-attributes {
        tailf:info "Enter the ppp-attributes sub command mode";
        tailf:cli-hide-in-submode;
        tailf:cli-full-command;
        type empty;
      }

      // tunnel-group * ppp-attributes / authentication
      container authentication {
        tailf:info "configure an authentication protocol";

        // tunnel-group * ppp-attributes / authentication / chap
        leaf chap {
          tailf:info "Enable ppp authentication protocol CHAP";
          tailf:cli-full-command;
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }

        // tunnel-group * ppp-attributes / authentication / pap
        leaf pap {
          tailf:info "Enable ppp authentication protocol PAP";
          tailf:cli-full-command;
          type empty;
        }

        // tunnel-group * ppp-attributes / authentication / ms-chap-v1
        leaf ms-chap-v1 {
          tailf:info "Enable ppp authentication protocol MS-CHAP version 1";
          tailf:cli-full-command;
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }

        // tunnel-group * ppp-attributes / authentication / ms-chap-v2
        leaf ms-chap-v2 {
          tailf:info "Enable ppp authentication protocol MS-CHAP version 2";
          tailf:cli-full-command;
          type empty;
        }
        // tunnel-group * ppp-attributes / authentication / pap
        leaf eap-proxy {
          tailf:info "Enable ppp authentication to be proxied to an EAP "
          +"enabled RADIUS server";
          tailf:cli-full-command;
          type empty;
        }
      }
    }
  }


  /// ========================================================================
  /// tunnel-group-map
  /// ========================================================================

  container tunnel-group-map {
    tailf:info "Specify policy by which the tunnel-group name is derived "
    +"from the content of a certificate.";

    // tunnel-group-map / enable
    container enable {
      tailf:info "Specify policy by which the tunnel-group name is derived "
      +"from the content of a certificate.";

      // tunnel-group-map / enable / ou
      leaf ou {
        tailf:info "Use the certificate OU field to determine the "
        +"tunnel-group name";
        tailf:cli-full-command;
        tailf:cli-boolean-no;
        type boolean;
        default true;
      }

      // tunnel-group-map / enable / ike-id
      leaf ike-id {
        tailf:info "Use the IKE phase 1 identifier to determine the "
        +"tunnel-group name";
        tailf:cli-full-command;
        tailf:cli-boolean-no;
        type boolean;
        default true;
      }

      // tunnel-group-map / enable / peer-ip
      leaf peer-ip {
        tailf:info "Use the IP address of the peer to determine the "
        +"tunnel-group name";
        tailf:cli-full-command;
        tailf:cli-boolean-no;
        type boolean;
        default true;
      }

      // tunnel-group-map / enable / rules
      leaf rules {
        tailf:info "Use the configured certificate map rules to match a "
        +"certificate to a tunnel-group name";
        tailf:cli-full-command;
        type empty;
      }
    }

    // tunnel-group-map *
    list tunnel-group-map-list {
      tailf:info "Associate a tunnel-group with a certificate map rule";
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key "ca sequence";
      leaf ca {
        tailf:non-strict-leafref {
          path "../../../crypto/ca/certificate/map/label";
        }
        type string {
          tailf:info "WORD < 65 char;;Certificate map name";
          length "1..65";
        }
      }
      leaf sequence {
        tailf:non-strict-leafref {
          path "../../../crypto/ca/certificate/map/sequence";
        }
        type uint16 {
          tailf:info "<1-65535>;;Index of the map entry to associate with "
            +"the tunnel group";
          range "1..65535";
        }
      }
      leaf tunnel {
        tailf:cli-drop-node-name;
        tailf:cli-diff-dependency
          "../../../tunnel-group/tunnel-group-list[name=current()/../tunnel]";
        tailf:cli-diff-dependency
          "../../../tunnel-group/tunnel-group-general-attributes"
          +"[name=current()/../tunnel]";
        tailf:cli-diff-dependency
          "../../../tunnel-group/tunnel-group-webvpn-attributes"
          +"[name=current()/../tunnel]";
        type string {
          tailf:info "WORD < 65 char;;Tunnel group name";
          length "1..65";
        }
      }
    }
  }


  /// ========================================================================
  /// vpn
  /// ========================================================================

  container vpn {
    tailf:info "Configure VPN parameters.";
    tailf:cli-diff-dependency "../crypto";

    // vpn load-balancing
    container load-balancing {
      tailf:info "Configure VPN Load Balancing parameters.";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-load-balancing";
      tailf:cli-full-command;
      tailf:cli-delete-when-empty;
      presence true;

      tailf:cli-diff-dependency "../../interface";
      tailf:cli-diff-dependency "../../interface/Management/nameif";
      tailf:cli-diff-dependency "../../interface/Ethernet/nameif";
      tailf:cli-diff-dependency "../../interface/FastEthernet/nameif";
      tailf:cli-diff-dependency "../../interface/GigabitEthernet/nameif";
      tailf:cli-diff-dependency "../../interface/TenGigabitEthernet/nameif";
      tailf:cli-diff-dependency "../../interface/Vlan/nameif";
      tailf:cli-diff-dependency "../../interface/Port-channel/nameif";
      tailf:cli-diff-dependency "../../interface/Port-channel-subif/Port-channel/nameif";
      tailf:cli-diff-dependency "../../interface/BVI/nameif";
      tailf:cli-diff-dependency "../../interface/Redundant/nameif";
      tailf:cli-diff-dependency "../../interface/allocated/nameif";

      // vpn load-balancing / nat
      leaf nat {
        tailf:info "Set the NAT address on public interface";
        tailf:cli-full-command;
        type string {
          tailf:info "ADDRESS;;Hostname or A.B.C.D or X:X:X:X::X";
        }
      }

      // vpn load-balancing / redirect-fqdn
      leaf redirect-fqdn {
        tailf:info "Redirect clients to FQDN (hostname), instead of IP address";
        tailf:cli-no-value-on-delete;
        type enumeration {
          enum disable {
            tailf:info "disable redirect FQDN";
          }
          enum enable {
            tailf:info "enable redirect FQDN";
          }
        }
        default disable;
      }

      // vpn load-balancing / priority
      leaf priority {
        tailf:info "Set the priority of the device";
        type uint8 {
          tailf:info "<1-10>;;Enter a priority number from 1 to 10";
          range "1..10";
        }
        default 5;
      }

      // vpn load-balancing / interface
      container interface {
        tailf:info "Set the interfaces of the device";
        tailf:cli-diff-dependency "../../../interface";
        tailf:cli-diff-dependency "../../../interface/Management/nameif";
        tailf:cli-diff-dependency "../../../interface/Ethernet/nameif";
        tailf:cli-diff-dependency "../../../interface/FastEthernet/nameif";
        tailf:cli-diff-dependency "../../../interface/GigabitEthernet/nameif";
        tailf:cli-diff-dependency "../../../interface/TenGigabitEthernet/nameif";
        tailf:cli-diff-dependency "../../../interface/Vlan/nameif";
        tailf:cli-diff-dependency "../../../interface/Port-channel/nameif";
        tailf:cli-diff-dependency "../../../interface/Port-channel-subif/Port-channel/nameif";
        tailf:cli-diff-dependency "../../../interface/BVI/nameif";
        tailf:cli-diff-dependency "../../../interface/Redundant/nameif";
        tailf:cli-diff-dependency "../../../interface/allocated/nameif";

        // vpn load-balancing / interface lbprivate
        leaf lbprivate {
          tailf:info "Configure VPN Load Balancing's private interface name.";
          type nameif-type;
        }

        // vpn load-balancing / interface lbpublic
        leaf lbpublic {
          tailf:info "Configure VPN Load Balancing's public interface name.";
          type nameif-type;
        }
      }

      // vpn load-balancing / cluster
      container cluster {
        tailf:info "Configure VPN Load Balancing Cluster Parameters";

        // vpn load-balancing / cluster key
        container "key" {
          tailf:info "Configure VPN Load Balancing Cluster's shared secret key.";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          uses password-08-grouping {
            refine "type" {
              tailf:cli-no-value-on-delete;
            }
            refine "secret" {
              tailf:cli-no-value-on-delete;
              tailf:meta-data "secret" {
                tailf:meta-value " cluster key <SECRET>";
              }
            }
          }
        }

        // vpn load-balancing / cluster ip address
        container ip {
          tailf:info "Configure VPN Load Balancing Cluster's IP address. ";
          leaf address {
            tailf:info "Set the cluster's IP address";
            type string {
              tailf:info "ADDRESS;;Hostname or A.B.C.D or X:X:X:X::X";
            }
          }
        }

        // vpn load-balancing / cluster encryption
        leaf encryption {
          tailf:info "Configure VPN Load Balancing Cluster's encryption flag.";
          tailf:cli-diff-dependency "../key/secret";
          type empty;
        }

        // vpn load-balancing / cluster port
        leaf port {
          tailf:info "Configure VPN Load Balancing Cluster's UDP port.";
          type uint16 {
            tailf:info "<1-65535>;;udp port";
            range "1..65535";
          }
          default 9023;
        }
      }

      // vpn load-balancing / participate
      leaf participate {
        tailf:info "Participate in VPN Load Balancing";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// management-access
  /// ========================================================================

  container management-access {
    tailf:info "Configure management access interface";
    tailf:cli-diff-dependency "../interface";
    tailf:cli-diff-dependency "../interface/Management/nameif";
    tailf:cli-diff-dependency "../interface/Ethernet/nameif";
    tailf:cli-diff-dependency "../interface/FastEthernet/nameif";
    tailf:cli-diff-dependency "../interface/GigabitEthernet/nameif";
    tailf:cli-diff-dependency "../interface/TenGigabitEthernet/nameif";
    tailf:cli-diff-dependency "../interface/Vlan/nameif";
    tailf:cli-diff-dependency "../interface/Port-channel/nameif";
    tailf:cli-diff-dependency "../interface/Port-channel-subif/Port-channel/nameif";
    tailf:cli-diff-dependency "../interface/BVI/nameif";
    tailf:cli-diff-dependency "../interface/Redundant/nameif";
    tailf:cli-diff-dependency "../interface/allocated/nameif";
    uses interface-name-grouping;
  }


  /// ========================================================================
  /// vpn-sessiondb
  /// ========================================================================

  container vpn-sessiondb {
    tailf:info "Configure the VPN Session Manager";

    // vpn-sessiondb max-anyconnect-premium-or-essentials-limit
    leaf max-anyconnect-premium-or-essentials-limit {
       tailf:info "Specify the max AnyConn Premium or Essentials session limit";
      type uint16 {
        tailf:info "<1-750>;;Number of AnyConnect Premium sessions";
        range "1..750";
      }
    }
  }


  /// ========================================================================
  /// license
  /// ========================================================================

  container license {
    tailf:info "Configure Smart Licensing options";

    // license smart
    container smart {
      tailf:info "Configure Smart Licensing options";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-smart-lic";

      // license smart / feature tier standard
      container "feature" {
        tailf:info "Set License feature";
        container tier {
          tailf:info "Specify License feature tier";
          leaf standard {
            tailf:info "Enable Standard feature tier";
            tailf:cli-no-name-on-delete;
            type empty;
          }
        }
      }

      // license smart / throughput level
      container throughput {
        tailf:info "Set License throughput";
        leaf level {
          tailf:info "Set License throughput level";
          tailf:cli-no-value-on-delete;
          type enumeration {
            enum "100m" {
              tailf:info "Enable 100 Mbps throughput level";
            }
            enum "1G" {
              tailf:info "Enable 1 Gbps throughput level";
            }
            enum "2G" {
              tailf:info "Enable 2 Gbps throughput level";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// timeout
  /// ========================================================================

  container timeout {
    tailf:info "Configure maximum idle times";
    cli:parse-compact-syntax;

    // timeout conn
    leaf conn {
      tailf:info "Configure idle time after which a TCP connection state "
        +"will be closed, default is 1:00:00";
      type hhmmss-type;
    }

    // timeout conn-holddown
    leaf conn-holddown {
      tailf:info "Connection Holddown timer to retain the routes till the  timer expires, default is 0:0:15";
      type hhmmss-type;
    }

    // timeout floating-conn
    leaf floating-conn {
      tailf:info "Configure time after which connections using the backup "
        +"route will be closed once lower metric route becomes available, "
        +"default is 0:0:0";
      type hhmmss-type;
    }

    // timeout h252
    leaf h225 {
      tailf:info "Configure idle time after which an H.225 signaling conn "
        +"will be closed, default is 1:00:00";
      type hhmmss-type;
    }

    // timeout h323
    leaf h323 {
      tailf:info "Configure idle time after which an H.323 control "
        +"connection will be closed, default is 0:05:00";
      type hhmmss-type;
    }

    // timeout half-closed
    leaf half-closed {
      tailf:info "Configure idle time after which a TCP half-closed "
        +"connection will be freed, default is 0:10:00";
      type hhmmss-type;
    }

    // timeout sctp
    leaf sctp {
      tailf:info "Configure idle timeout for SCTP";
      type hhmmss-type;
    }

    // timeout icmp
    leaf icmp {
      tailf:info "Configure idle timeout for ICMP, default is 0:00:02";
      type hhmmss-type;
    }

    // timeout mgcp
    leaf mgcp {
      tailf:info "Configure idle time after which an MGCP media connection "
        +"will be closed, default is 0:05:00";
      type hhmmss-type;
    }

    // timeout mgcp-pat
    leaf mgcp-pat {
      tailf:info "Configure the time after which an MGCP PAT Xlate will be "
        +"removed, default is 0:05:00";
      type hhmmss-type;
    }

    // timeout pat-xlate
    leaf pat-xlate {
      tailf:info "Configure idle time after which a dynamic port will be" +
                 "returned to the free PAT pool, default is 0:00:30";
      type hhmmss-type;
    }

    // timeout sip
    leaf sip {
      tailf:info "Configure idle time after which a SIP control connection "
        +"will be closed, default is 0:30:00";
      type hhmmss-type;
    }

    // timeout sip-disconnect
    leaf sip-disconnect {
      tailf:info "Configure idle timeout after which SIP session is deleted "
        +"if 200 OK is not received for a CANCEL or BYE message, "
        +"default is 0:02:00";
      type hhmmss-type;
    }

    // timeout sip-invite
    leaf sip-invite {
      tailf:info "Configure idle time after which pinholes for PROVISIONAL "
        +"responsesand media xlates will be closed, default is 0:03:00";
      type hhmmss-type;
    }

    // timeout sip-provisional-media
    leaf sip-provisional-media {
      tailf:info "Configure idle time after which a SIP provisional Media "
        +"connection will be closed, default is 0:02:00";
      type hhmmss-type;
    }

    // timeout sip_media
    leaf sip_media {
      tailf:info "Configure idle time after which a SIP Media connection "
        +"will be closed, default is 0:02:00";
      type hhmmss-type;
    }

    // timeout sunrpc
    leaf sunrpc {
      tailf:info "Configure idle time after which a SUNRPC slot will be "
        +"closed, default is 0:10:00";
      type hhmmss-type;
    }

    // timeout tcp-proxy-reassembly
    leaf tcp-proxy-reassembly {
      tailf:info "Configure idle timeout after which buffered packets "
        +"waiting for reassembly in tcp-proxy are dropped, default is 0:01:00";
      type hhmmss-type;
    }

    // timeout uath
    container uauth {
      tailf:info "Configure idle time after which an authentication will "
        +"no longer be cached and the user will need to re-authenticate on "
        +"their connection, default is 0:05:00. The default uauth timer "
        +"is absolute.";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands{
        tailf:cli-reset-all-siblings;
      }
      leaf "value" {
        tailf:cli-drop-node-name;
        type hhmmss-type {
          tailf:info "<0:0:0> - <1193:0:0>  Idle time after which an "
            +"authentication will no longer be cached and the user will "
            +"need to re-authenticate on their connection, default is "
            +"0:05:00. The default uauth timer is absolute.";
        }
      }
      leaf absolute {
        tailf:info "Run uauth timer continuously, the default uauth timer is absolute";
        type empty;
      }
    }

    // timeout igp stale-route
    container igp {
      leaf stale-route {
        type hhmmss-type;
      }
    }

    // timeout udp
    leaf udp {
      tailf:info "Configure idle time after which general UDP states will "
        +"be closed, default is 0:02:00, This timer does not apply to "
        +"DNS or SUNRPC";
      type hhmmss-type;
    }

    // timeout xlate
    leaf xlate {
      tailf:info "Configure idle time after which a dynamic address will "
        +"be returned to the free pool, default is 3:00:00";
      type hhmmss-type;
    }
  }


  /// ========================================================================
  /// ldap
  /// ========================================================================

  container ldap {
    tailf:info "Configure LDAP Mapping";
    tailf:cli-explicit-exit;

    // ldap attribute-map *
    list attribute-map {
      tailf:info "keyword";
      tailf:cli-mode-name "config-ldap-attribute-map";
      key name;
      leaf name {
        type string {
          tailf:info "WORD < 64 char;;Enter LDAP Mapping Name";
        }
      }

      // ldap attribute-map * / map-name *
      list map-name {
        tailf:info "map-name configuration";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        tailf:code-name "ldap_map_name";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Enter Customer Attribute Name";
          }
        }
        leaf cisco-name {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;cisco-attribute-names";
          }
        }
      }

      // ldap attribute-map * / map-value *
      list map-value {
        tailf:info "map-value configuration";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        key "name value";
        leaf name {
          tailf:non-strict-leafref {
            path "../../map-name/name";
          }
          type string {
            tailf:info "WORD;;Enter Customer Attribute Name";
          }
        }
        leaf "value" {
          type string {
            tailf:info "WORD;;Enter Customer Attribute Value.";
          }
        }
        leaf cisco-value {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;Enter Cisco Attribute Value.";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// loopback-proxy
  /// ========================================================================

  container loopback-proxy {
    tailf:info "Configure the loopback proxy";

    // loopback-proxy server
    // no loopback-proxy server
    leaf server {
      tailf:info "Configure the loopback proxy server";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
    }

    // loopback-proxy client syslog
    // no loopback-proxy client syslog
    container client {
      tailf:info "Configure the loopback proxy client";
      leaf syslog {
        tailf:info "Configure the loopback proxy client syslog";
        tailf:cli-boolean-no;
        type boolean;
      }
    }
  }


  /// ========================================================================
  /// tls-proxy
  /// ========================================================================

  container tls-proxy {
    tailf:info "Configure a TLS proxy instance or the maximum sessions";

    // tls-proxy maximum-session
    leaf maximum-session {
      tailf:info "Maximum number of sessions";
      type uint32 {
        tailf:info "<1-13000>;;Maximum number of sessions";
        range "1..13000";
      }
    }
  }


  ///////////////////////////////////////////////////////////////////////////
  } // config-grouping END
  ///////////////////////////////////////////////////////////////////////////


  /// ========================================================================
  /// admin-context
  /// ========================================================================

  leaf admin-context {
    tailf:info "Set administrative context";
    type string {
      tailf:info "WORD;;Name of administrative context";
    }
  }


  /// ========================================================================
  /// context
  /// ========================================================================

  list context {
    tailf:info "Create or show a Security Context";
    tailf:cli-mode-name "config-ctx";
    tailf:callpoint context-hook { tailf:set-hook node; }
    tailf:meta-data "context-delete";
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;Symbolic name of the context";
      }
    }

    // context * / description
    leaf description {
      tailf:info "Provide a description of the context";
      tailf:cli-multi-value;
      type string {
        tailf:info "LINE;;Description of the context";
      }
    }

    // context * / allocate-interface *
    list allocate-interface {
      tailf:info "Allocate interface to context";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key name;
      leaf name {
        tailf:cli-diff-dependency "/asa:interface";
        type string {
          tailf:info "WORD;;Indicate interfaces assigned to the context";
        }
      }
      leaf map_name {
        tailf:cli-drop-node-name;
        tailf:cli-disallow-value "Management|Ethernet|FastEthernet"+
          "|GigabitEthernet|TenGigabitEthernet|Vlan|Port-channel|Redundant|BVI"+
          "|invisible|visible";
        type string {
          tailf:info "WORD;;Optional interface name mapping for the context";
        }
      }
      leaf flag {
        tailf:cli-drop-node-name;
        type enumeration {
          enum invisible {
            tailf:info "Optional flag for hiding hardware property in context (default)";
          }
          enum visible {
            tailf:info "Optional flag for publishing hardware property in context";
          }
        }
      }
    }

    // context * / config-url
    leaf config-url {
      tailf:info "Configure URL for a context configuration";
      tailf:cli-full-command;
      tailf:meta-data "context-config-url";
      type string {
        tailf:info "WORD;;A URL beginning with prefix for the context's "+
          "config (file need not exist)";
      }
    }

    // context * / storage-url
    container storage-url {
      tailf:info "Configure storage URL for a context";

      // context * / storage-url private
      container private {
        tailf:info "Configure parent directory for private read-write storage for this context";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf path {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;A URL beginning with this prefix for the context's private storage";
          }
        }
        leaf context_label {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;Label name";
          }
        }
      }

      // context * / storage-url shared
      container shared {
        tailf:info "Configure shared storage URL for a context";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf path {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;A URL beginning with this prefix for the context's shared storage";
          }
        }
        leaf context_label {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;Label name";
          }
        }
      }
    }

    // context * / join-failover-group
    leaf join-failover-group {
      tailf:info "Join a context to a failover group";
      tailf:cli-full-command;
      tailf:non-strict-leafref {
        path "/asa:failover/group/id";
      }
      type uint8 {
        tailf:info "<1-2>;;Failover group number";
        range "1..2";
      }
    }
  }


  /// ========================================================================
  /// call-home
  /// ========================================================================

  // call-home call-home reporting anonymous
  // no call-home call-home reporting anonymous
  container call-home-reporting {
    tailf:cli-drop-node-name;
    container call-home {
      tailf:info "Configure Smart Call-Home reporting options";
      container reporting {
        tailf:info "Configure Smart Call-Home reporting options";
        leaf anonymous {
          tailf:info "Enable or disable anonymous reporting";
          tailf:cli-show-no;
          type empty;
        }
      }
    }
  }

  container call-home {
    tailf:info "Configure Smart Call-Home reporting options";
    tailf:cli-add-mode;
    tailf:cli-mode-name "cfg-call-home";

    // call-home / http-proxy
    container http-proxy {
      tailf:info "Specify proxy server for http request";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf name {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type string {
          tailf:info "WORD < 128 char;;Http proxy server";
        }
      }
      leaf port {
        tailf:info "http proxy server port number";
        type uint16 {
          tailf:info "<1-65535>;;proxy server port number";
          range "1..65535";
        }
      }
    }

    // call-home / profile *
    list profile {
      tailf:cli-mode-name "cfg-call-home-profile";
      key id;
      leaf id {
        type string {
          tailf:info "WORD < 24 char;;Create a new profile";
        }
      }

      // call-home / profile * / no active
      leaf active {
        tailf:info "Activate current profile";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // call-home / profile * / destination
      container destination {
        tailf:info "Configure message destination related configuration";

        // call-home / profile * / destination address
        container address {

          // call-home / profile * / destination address http *
          leaf-list http {
            tailf:info "Configure destination http-url address";
            tailf:cli-list-syntax;
            type string {
              tailf:info "WORD < 128 char;;URL(http or https url)";
            }
          }

          // call-home / profile * / destination address email *
          leaf-list email {
            tailf:info "Configure destination email address";
            tailf:cli-list-syntax;
            type string {
              tailf:info "WORD < 128 char;;E-mail address";
            }
          }
        }

        // call-home / profile * / destination transport-method
        leaf transport-method {
          tailf:info "Enable or disable email or http transport method";
          type enumeration {
            enum email {
              tailf:info "Enable or disable email transport method";
            }
            enum http {
              tailf:info "Enable or disable http transport method";
            }
          }
        }
      }

      // call-home / profile * / subscribe-to-alert-group *
      list subscribe-to-alert-group {
        tailf:info "Subscribe to an alert-group";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          type enumeration {
            enum configuration {
              tailf:info "Configuration Group";
            }
            enum diagnostic {
              tailf:info "Diagnostic Group";
            }
            enum environment {
              tailf:info "Environmental Group";
            }
            enum inventory {
              tailf:info "Inventory Group";
            }
            enum snapshot {
              tailf:info "Snapshot Group";
            }
            enum syslog {
              tailf:info "System Log Group";
            }
            enum telemetry {
              tailf:info "Telemetry Group";
            }
            enum threat {
              tailf:info "Threat Group";
            }
          }
        }

        // call-home / profile * / subscribe-to-alert-group * periodic
        container periodic {
          tailf:info "Keyword for setting periodic interval";
          choice periodic-choice {

            // .. / profile * / subscribe-to-alert-group * periodic daily
            container daily {
              tailf:info "Daily Smart Call-Home message";
              presence true;
              leaf time {
                tailf:cli-drop-node-name;
                type hhmm-type;
              }
            }

            // .. / profile * / subscribe-to-alert-group * periodic hourly
            container hourly {
              tailf:info "Hourly Smart Call-Home message";
              presence true;
              leaf minute {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<0-59>;;Minute of hour";
                  range "0..59";
                }
              }
            }

            // .. / profile * / subscribe-to-alert-group * periodic monthly
            container monthly {
              tailf:info "Monthly Smart Call-Home message";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              presence true;
              leaf day {
                tailf:cli-drop-node-name;
                tailf:cli-optional-in-sequence;
                type uint8 {
                  tailf:info "<1-31>;;Day of month";
                  range "1..31";
                }
              }
              leaf time {
                tailf:cli-drop-node-name;
                type hhmm-type;
              }
            }

            // .. / profile * / subscribe-to-alert-group * periodic weekly
            container weekly {
              tailf:info "Weekly Smart Call-Home message";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf day {
                tailf:cli-drop-node-name;
                tailf:cli-optional-in-sequence;
                type weekday-type;
              }
              leaf time {
                tailf:cli-drop-node-name;
                type hhmm-type;
              }
              presence true;
            }
          }
        }
      }
    }
    // call-home / source-interface *
    container source-interface {
      tailf:info "Configure Source interface";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf name {
        tailf:cli-drop-node-name;
        tailf:cli-no-value-on-delete;
        tailf:cli-diff-dependency "../../../interface";
        tailf:cli-diff-dependency "../../../interface/Management/nameif";
        tailf:cli-diff-dependency "../../../interface/Ethernet/nameif";
        tailf:cli-diff-dependency "../../../interface/FastEthernet/nameif";
        tailf:cli-diff-dependency "../../../interface/GigabitEthernet/nameif";
        tailf:cli-diff-dependency "../../../interface/TenGigabitEthernet/nameif";
        tailf:cli-diff-dependency "../../../interface/Vlan/nameif";
        tailf:cli-diff-dependency "../../../interface/Port-channel/nameif";
        tailf:cli-diff-dependency "../../../interface/Port-channel-subif/Port-channel/nameif";
        tailf:cli-diff-dependency "../../../interface/BVI/nameif";
        tailf:cli-diff-dependency "../../../interface/Redundant/nameif";
        tailf:cli-diff-dependency "../../../interface/allocated/nameif";
        type nameif-type;
      }
    }
  }


  // =========================================================================
  //                        rest-api
  // =========================================================================

  container rest-api {
    tailf:info "Configure REST API";

    // rest-api image
    leaf image {
      tailf:info "Install the REST API image on ASA";
      tailf:cli-full-command;
      type string {
        tailf:info "WORD;;REST API image file path";
      }
    }

    // rest-api agent
    leaf agent {
      tailf:info "Enable the REST API agent on ASA";
      tailf:cli-full-command;
      type empty;
    }
  }


  // =========================================================================
  //                        CONTEXT MODEL
  // =========================================================================

  /// changeto
  container changeto {
    tailf:info "Change the execution space in which commands will be applied";

    // changeto context *
    list context {
      tailf:info "Change to context";
      tailf:cli-full-command;
      tailf:cli-exit-command "changeto system";
      key context-name;
      leaf context-name {
        tailf:cli-suppress-range;
        tailf:non-strict-leafref {
          path "../../../context/name";
        }
        type string {
          tailf:info "WORD;;Context name";
        }
      }

      // changeto context * / CONFIG
      uses config-grouping {
        refine "interface" {
          tailf:cli-diff-dependency "/asa:context/allocate-interface";
        }
      }
    }
  }

  /// ========================================================================
  /// tailfned
  /// ========================================================================

  container tailfned {
    leaf raw-run {
      type empty;
    }
  }


  /// ========================================================================
  //                          EOF
  /// ========================================================================
}
