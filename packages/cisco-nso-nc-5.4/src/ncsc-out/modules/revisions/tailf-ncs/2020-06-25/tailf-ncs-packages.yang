submodule tailf-ncs-packages {
  // Generated by yanger -t ncs
  tailf:mount-id "cisco-nso-nc-5.4:cisco-nso-nc-5.4";

  yang-version 1.1;
  belongs-to tailf-ncs {
    prefix ncs;
  }

  import tailf-ncs-ned {
    prefix ned;
  }
  import tailf-common {
    prefix tailf;
  }
  import tailf-ncs-internal-mount {
    prefix ncs-internal;
  }

  organization
    "Tail-f Systems";
  description
    "This submodule defines the Tail-f NCS package model.

     Copyright 2019 Cisco Systems, Inc.
     All rights reserved.
     Permission is hereby granted to redistribute this file without
     modification.";

  revision 2020-06-25 {
    description
      "Released as part of NCS-5.4.

       Added leaf-list 'supported-ned-id' and leaf 'template-loading-mode'
       in grouping 'package-meta-data'.

       Added typedef 'package-version' at the top level matching the typedef
       'version' declared in grouping 'package-meta-data'.";
  }
  revision 2019-11-28 {
    description
      "Released as part of NCS-5.3.

       Added leaf 'python-uninitialized' under choice 'status' in
       /packages/package/oper-status container.

       Added support for Python upgrade components.

       Moved /packages/package/component/upgrade/java-class-name to a case
        'java' in choice /packages/package/component/upgrade/type.

       Added leaf 'python-class-name' to a case 'python' in choice
       /packages/package/component/upgrade/type.";
  }
  revision 2019-04-09 {
    description
      "Released as part of NCS-5.1.

       Changed ned-type 'snmp' from an empty leaf to a container.";
  }
  revision 2017-09-28 {
    description
      "Released as part of NCS-4.5.

       Added input parameter 'force' to /packages/reload action.";
  }
  revision 2017-03-16 {
    description
      "Released as part of NCS-4.4.

       Added range to all config leafs specifying time.";
  }
  revision 2016-11-24 {
    description
      "Released as part of NCS-4.3.

       Changed ned-type 'netconf' from an empty leaf to a container.";
  }
  revision 2016-05-26 {
    description
      "Released as part of NCS-4.2.

       Added /packages/package/component/entitlement-tag.";
  }
  revision 2015-06-16 {
    description
      "Released as part of NCS-4.0.

       Added support for Python packages.

       Added support for Erlang packages.

       Added /packages/package/python-package.
       Moved /packages/package/component/java-class-name to a case
        'java' in a choice /packages/package/component/type.";
  }
  revision 2014-11-19 {
    description
      "Released as part of NCS-3.3.

       Added /packages/package/build-info.";
  }
  revision 2014-06-30 {
    description
      "Released as part of NCS-3.2.

       Changed the output of action /packages/reload from a string to
         a list of result for each package.

       Added the NED option 'allow-abbrevs'.";
  }
  revision 2014-04-02 {
    description
      "Released as part of NCS-3.1.

       Changed /packages/package/ncs-min-version.";
  }
  revision 2013-11-12 {
    description
      "Released as part of NCS-3.0.

       Added /packages/package/oper-status/circular-dependency.

       Added /packages/package/component/upgrade.

       Removed /packages/package/component/service.

       Added /packages/package/templates.";
  }
  revision 2013-06-18 {
    description
      "Released as part of NCS-2.3.

       Added /packages/package/directory.

       Added /packages/reload action.";
  }
  revision 2013-03-12 {
    description
      "Released as part of NCS-2.2.

       Added 'templates' directory to the package file structure.";
  }
  revision 2012-11-13 {
    description
      "Released as part of NCS-2.1.

       Added /packages/package/component/service/java-trigger-class-name.";
  }
  revision 2012-10-04 {
    description
      "Released as part of NCS-2.0.2

       Added /packages/oper-status/error-info.";
  }
  revision 2012-08-30 {
    description
      "Released as part of NCS-2.0.";
  }

  typedef ncs_template_package-version {
    type string;
    description
      "The format of the NCS package version.";
  }

  typedef ncs_rpc_notif_package-version {
    type string {
      pattern '\d+\.\d+([-.](\d+|\w+))*';
    }
    description
      "The format of the NCS package version.";
  }

  typedef live_ncs_package-version {
    type string {
      pattern '\d+\.\d+([-.](\d+|\w+))*';
    }
    description
      "The format of the NCS package version.";
  }

  typedef package-version {
    type string {
      pattern '\d+\.\d+([-.](\d+|\w+))*';
    }
    description
      "The format of the NCS package version.";
  }

  grouping ncs_template_package-meta-data {
    description
      "This grouping describes meta-data for a NCS package.

       A NCS package has the following file structure:

         <package-name>/package-meta-data.xml
                        load-dir/
                        cdb/
                        shared-jar/
                        private-jar/
                        erlang-lib/
                        python/
                        webui/
                        templates/
                        scripts/
                        src/
                        doc/
                        netsim/

       The package-meta-data.xml file contains a top-level element
       'ncs-package' in the namespace defined by this module, which
       behaves as if defined as:

         container ncs-package {
           uses package-meta-data;
         }

       The optional 'load-dir' directory is appended to the
       'load-path' of NCS.  It contains fxs files and ccl files
       etc. It can also contain .xml files, which will be loaded by
       CDB during init and upgrade (i.e. these files can be used to
       include inital CDB data needed by the package).

       The optional 'shared-jar' directory contains jar files with
       Java code that is shared among all packages. Once loaded, this
       code cannot be modified without reloading all jar files for all
       packages.

       The optional 'private-jar' directory contains jar files with
       Java code that are loaded by a package-spefic class loader.
       Thus, this code is not available from other packages.  By
       putting for example the code for a specific service in a
       private jar, NCS can dynamically upgrade the service without
       affecting any other service.

       The optional 'erlang-lib' directory contains Erlang
       applications.

       The optional 'python' directory contains Python code for the
       component.

       The optional 'webui' directory contains webui customization
       files.

       The optional 'templates' directory contains templates for
       template-based services.";

    typedef version {
      type ncs_template_package-version;
      description
        "The version is a sequence of numbers and words, separated by '.'
         or '-'.  When NCS compares a version string, it parses the string
         into the sequence of numbers and words, and compares each component
         individually.";
    }
    leaf name {
      type string;
      // NCS drop mandatory statement
      description
        "A unique name, used to identify the package.";
    }
    leaf package-version {
      type version;
      // NCS drop mandatory statement
      description
        "The version of the package. An NCS customer that modifies a package
         is encouraged to add its own info to this string, e.g.
           1.2-acme-1
           1.2-acme-2";
    }
    leaf description {
      type string;
      description
        "Free-form text describing the package.";
    }
    leaf-list ncs-min-version {
      // NCS patched for predictable order
      ordered-by user;
      type version;
      description
        "Minimum NCS versions, one per NCS major, required by this package.";
    }
    container python-package {
      presence "Python specific package data";
      leaf vm-name {
        type string;
        description
          "A Python package will per default run in a seperate Python VM.
           This Python VM will get a symbolic name (for reference from
           within NCS) which per default is the package 'name'.

           However, by setting 'vm-name', its value will be used as as
           the symbolic name for the Python VM started. This will
           cause packages with the same 'vm-name' to run in the same
           Python VM.";
      }
    }
    leaf directory {
      type string;
      description
        "The path to the directory of the package.";
    }
    leaf-list templates {
      // NCS patched for predictable order
      ordered-by user;
      type string;
      description
        "The templates defined by this package.";
    }
    leaf template-loading-mode {
      type string;
      description
        "This leaf indicates whether the templates in this package are
         interpreted in strict mode or relaxed mode. It is unset if the package
         has no templates.

         Strict mode means we report all schema-related errors in templates
         that can be identified at load time (such as unknown namespace, schema
         ambiguity or unknown ned-id). Strict mode is applid when there are no
         supported-ned-ids declared or when all of the supported-ned-ids are
         loaded.

         If the package declares supported-ned-ids, but some of them are not
         recognized, then we assume relaxed mode as we will not be able to
         identify some of the schema-related errors, for example we might need
         to skip over tags in unknown namespaces because they might belong
         to the missing ned-ids that the package supports, but that are
         currently not loaded in the runtime system.

         It is important that the package developer tests the package with
         all the supported-ned-ids loaded, i.e. in strict mode, as it helps
         catch errors that may be ignored in relaxed mode.";
    }
    leaf-list supported-ned-id {
      // NCS patched for predictable order
      ordered-by user;
      type string;
      description
        "Templates defined by this package will be applied in the scope of
         this list of ned-ids. Trying to apply a template defined by this
         package to a device with a different ned-id will result at runtime
         error. If no supported-ned-id is defined, then no such restrictions
         are placed on this package's templates, however it may lead to a
         situation where loading an additional NED can prevent the package
         defining the template from loading by making a template ambiguous.

         This parameter has no effect for packages that define no templates.";
    }
    list required-package {
      // NCS patched for predictable order
      ordered-by user;
      key "name";
      description
        "A list of packages required by this package.  NCS will not
         load any package with missing dependencies.";
      leaf name {
        type string;
      }
      leaf min-version {
        type version;
        description
          "Minimum version required by this package.";
      }
    }
    list component {
      // NCS patched for predictable order
      ordered-by user;
      key "name";
      leaf name {
        type string;
        description
          "A unique name, used to identify the component within
           the package.";
      }
      leaf description {
        type string;
        description
          "Free-form text describing the component.";
      }
      leaf entitlement-tag {
        type string;
        description
          "Identifies the component for Smart Licensing.";
      }
      choice type {
        // NCS drop mandatory statement
        case ned {
          description
            "A NED package typically contains the YANG models for
             the device, and Java classes derived from these modules.
             The Java classes are delivered as 'shared' jar files, which
             makes them available for Java services and other Java code
             to use.";
          container ned {
            choice ned-type {
              // NCS drop mandatory statement
              container netconf {
                description
                  "A NETCONF NED typically consists of the YANG modules
                   for the device, and Java classes derived from these
                   modules.";
                leaf ned-id {
                  type string;
                  // NCS drop mandatory statement
                  description
                    "The identity that identifies the NETCONF NED. If
                     let empty it is just a plain NETCONF NED.";
                }
              }
              container snmp {
                description
                  "An SNMP NED typically consists of the MIB modules
                   for the device, YANG modules derived from the MIBs, and
                   Java classes derived from these models.";
                leaf ned-id {
                  type string;
                  description
                    "The identity that identifies the SNMP NED.";
                }
              }
              container cli {
                description
                  "A CLI NED typically consists of YANG models for the
                   device, Java classes derived from these modules, and
                   a Java class responsible for the communication with the
                   device.";
                leaf ned-id {
                  type string;
                  // NCS drop mandatory statement
                  description
                    "The identity that identifies the CLI NED.  All
                     devices of type 'cli' that are configured with
                     this 'ned-id' are handled by this compontent's 'NedCli'
                     Java class.";
                }
                leaf java-class-name {
                  type string;
                  // NCS drop mandatory statement
                  description
                    "The name of the Java class that implements the
                     interface 'NedCli'.";
                }
              }
              container generic {
                description
                  "A Generic NED typically consists of YANG models for the
                   device, Java classes derived from these modules, and
                   a Java class responsible for the communication with the
                   device.";
                leaf ned-id {
                  type string;
                  // NCS drop mandatory statement
                  description
                    "The identity that identifies the Generic NED.  All
                     devices of type 'generic' that are configured with
                     this 'ned-id' are handled by this component's 'NedGeneric'
                     Java class.";
                }
                leaf java-class-name {
                  type string;
                  // NCS drop mandatory statement
                  description
                    "The name of the Java class that implements the
                     interface 'NedGeneric'.";
                }
              }
            }
            container device {
              leaf vendor {
                type string;
                // NCS drop mandatory statement
                description
                  "Free-form string, used for documentation purposes.";
              }
              leaf product-family {
                type string;
                description
                  "The product-specific family of products supported by this
                   NED.

                   In some cases, this could be as generic as 'ios', if the
                   NED works with any ios release.  In other cases it could
                   be as specific as 'ios-11.4' if it works only with ios
                   release 11.4.  And in some cases, it would be some middle
                   ground, e.g., 'ios-11' or 'ios-11+'.";
              }
            }
            list option {
              // NCS patched for predictable order
              ordered-by user;
              key "name";
              description
                "A list of options to configure the behavior of this NED.
                 Available options are:

                  ordered-diff (for generic NEDs),
                     Order the operations sent the NED such that
                     dependencies are taken into account, ie if a
                     list element is deleted and there are leafref
                     references to the instance, order the leafref
                     in front of the delete of the instance.

                  show-tag (for CLI NEDs)
                     If set the NED will only ask for one top-tag in
                     the show() callback instead of invoking the show()
                     callback once for each top-tag. Many NEDs return
                     the entire configuration in one go and are only
                     interested in one show() invocation. The common
                     workaround is to only return when the show() command
                     is invoked with a specific top-tag, and return the
                     empty string for the rest. With this option set
                     there will only be one show() invocation.

                  allow-abbrevs (for CLI NEDs)
                     When set abbreviated commands are allowed to be
                     sent in the response to the show() callback. Devices
                     typically do not generate abbreviated commands and
                     setting the above option may introduce ambiguity in
                     the parsing.

                  show-partial
                    Set if the NED supports partial show.
                ";
              leaf name {
                type string;
              }
              leaf value {
                type string;
              }
            }
          }
        }
        case upgrade {
          description
            "An upgrade component is used to migrate data for packages
             where the YANG data model has changed and the automatic
             CDB upgrade is not sufficient. The upgrade component
             consists of either a Java class with a main method or a
             Python class with an upgrade method, that is expected to
             run one time only.";
          container upgrade {
            choice type {
              // NCS drop mandatory statement
              case java {
                leaf java-class-name {
                  type string;
                  description
                    "The name of the Java class that implements a main method
                     which will migrate data.";
                }
              }
              case python {
                leaf python-class-name {
                  type string;
                  description
                    "Name of the Python class that implements an upgrade
                     method which will migrate data.";
                }
              }
            }
          }
        }
        case callback {
          description
            "A data-provider can be used to implement NCS,
             services, external data providers, etc.";
          container callback {
            leaf-list java-class-name {
              // NCS patched for predictable order
              ordered-by user;
              type string;
              // NCS drop min-elements statement
              description
                "The name of the Java class that is annotated with one of
                 the callback annotations 'ServiceCallback', 'ActionCallback',
                 'AuthCallback', 'DataCallback', 'DBCallback',
                 'SnmpInformResponseCallback', 'TransCallback',
                 'TransValidateCallback', or 'ValidateCallback'.";
            }
          }
        }
        case application {
          description
            "An application is a generic type with some
             Java code, and a Java class that is instantiated by NCS.";
          container application {
            choice type {
              // NCS drop mandatory statement
              case java {
                description
                  "Java application";
                leaf java-class-name {
                  type string;
                  // NCS drop mandatory statement
                  description
                    "The name of the Java class that implements the
                     interface 'com.tailf.ncs.ApplicationComponent'.";
                }
              }
              case python {
                description
                  "Python application";
                leaf python-class-name {
                  type string;
                  // NCS drop mandatory statement
                  description
                    "The name of the Python class that will be started by NCS.

                     An empty string here indicates a Python Library,
                     i.e., no code will be invoked by NCS. However, other
                     packages may depend on this package, thus getting the
                     PYTHONPATH setup to point to this package.";
                }
              }
            }
            leaf start-phase {
              type string;
              // NCS drop default statement
              description
                "The start phase where the package is instantiated.";
            }
          }
        }
      }
    }
  }

  grouping ncs_rpc_notif_package-meta-data {
    description
      "This grouping describes meta-data for a NCS package.

       A NCS package has the following file structure:

         <package-name>/package-meta-data.xml
                        load-dir/
                        cdb/
                        shared-jar/
                        private-jar/
                        erlang-lib/
                        python/
                        webui/
                        templates/
                        scripts/
                        src/
                        doc/
                        netsim/

       The package-meta-data.xml file contains a top-level element
       'ncs-package' in the namespace defined by this module, which
       behaves as if defined as:

         container ncs-package {
           uses package-meta-data;
         }

       The optional 'load-dir' directory is appended to the
       'load-path' of NCS.  It contains fxs files and ccl files
       etc. It can also contain .xml files, which will be loaded by
       CDB during init and upgrade (i.e. these files can be used to
       include inital CDB data needed by the package).

       The optional 'shared-jar' directory contains jar files with
       Java code that is shared among all packages. Once loaded, this
       code cannot be modified without reloading all jar files for all
       packages.

       The optional 'private-jar' directory contains jar files with
       Java code that are loaded by a package-spefic class loader.
       Thus, this code is not available from other packages.  By
       putting for example the code for a specific service in a
       private jar, NCS can dynamically upgrade the service without
       affecting any other service.

       The optional 'erlang-lib' directory contains Erlang
       applications.

       The optional 'python' directory contains Python code for the
       component.

       The optional 'webui' directory contains webui customization
       files.

       The optional 'templates' directory contains templates for
       template-based services.";

    typedef version {
      type ncs_rpc_notif_package-version;
      description
        "The version is a sequence of numbers and words, separated by '.'
         or '-'.  When NCS compares a version string, it parses the string
         into the sequence of numbers and words, and compares each component
         individually.";
    }
    leaf name {
      tailf:info
        "A unique name, used to identify the package";
      type string;
      mandatory true;
      description
        "A unique name, used to identify the package.";
    }
    leaf package-version {
      tailf:info
        "The version of the package";
      type version;
      mandatory true;
      description
        "The version of the package. An NCS customer that modifies a package
         is encouraged to add its own info to this string, e.g.
           1.2-acme-1
           1.2-acme-2";
    }
    leaf description {
      tailf:info
        "Free-form text describing the package";
      type string;
      description
        "Free-form text describing the package.";
    }
    leaf-list ncs-min-version {
      tailf:info
        "Minimum NCS versions, one per NCS major,  required by this package";
      type version;
      description
        "Minimum NCS versions, one per NCS major, required by this package.";
    }
    container python-package {
      tailf:info
        "Python specific data.";
      presence "Python specific package data";
      leaf vm-name {
        type string;
        description
          "A Python package will per default run in a seperate Python VM.
           This Python VM will get a symbolic name (for reference from
           within NCS) which per default is the package 'name'.

           However, by setting 'vm-name', its value will be used as as
           the symbolic name for the Python VM started. This will
           cause packages with the same 'vm-name' to run in the same
           Python VM.";
      }
    }
    leaf directory {
      tailf:info
        "The path to the directory of the package";
      type string;
      description
        "The path to the directory of the package.";
    }
    leaf-list templates {
      tailf:info
        "The templates defined by this package";
      type string;
      description
        "The templates defined by this package.";
    }
    leaf template-loading-mode {
      type enumeration {
        enum "strict";
        enum "relaxed";
      }
      description
        "This leaf indicates whether the templates in this package are
         interpreted in strict mode or relaxed mode. It is unset if the package
         has no templates.

         Strict mode means we report all schema-related errors in templates
         that can be identified at load time (such as unknown namespace, schema
         ambiguity or unknown ned-id). Strict mode is applid when there are no
         supported-ned-ids declared or when all of the supported-ned-ids are
         loaded.

         If the package declares supported-ned-ids, but some of them are not
         recognized, then we assume relaxed mode as we will not be able to
         identify some of the schema-related errors, for example we might need
         to skip over tags in unknown namespaces because they might belong
         to the missing ned-ids that the package supports, but that are
         currently not loaded in the runtime system.

         It is important that the package developer tests the package with
         all the supported-ned-ids loaded, i.e. in strict mode, as it helps
         catch errors that may be ignored in relaxed mode.";
    }
    leaf-list supported-ned-id {
      tailf:info
        "The list of ned-ids supported by this package";
      type union {
        // NCS patched to string, due to LSA partial NED
        type string;
        type string;
      }
      description
        "Templates defined by this package will be applied in the scope of
         this list of ned-ids. Trying to apply a template defined by this
         package to a device with a different ned-id will result at runtime
         error. If no supported-ned-id is defined, then no such restrictions
         are placed on this package's templates, however it may lead to a
         situation where loading an additional NED can prevent the package
         defining the template from loading by making a template ambiguous.

         This parameter has no effect for packages that define no templates.";
    }
    list required-package {
      tailf:info
        "A list of packages required by this package";
      key "name";
      description
        "A list of packages required by this package.  NCS will not
         load any package with missing dependencies.";
      leaf name {
        tailf:info
          "Required package name";
        type string;
      }
      leaf min-version {
        tailf:info
          "Required package minimum version";
        type version;
        description
          "Minimum version required by this package.";
      }
    }
    list component {
      tailf:info
        "Package components";
      key "name";
      leaf name {
        tailf:info
          "Component name";
        type string;
        description
          "A unique name, used to identify the component within
           the package.";
      }
      leaf description {
        tailf:info
          "Free-form text describing the component";
        type string;
        description
          "Free-form text describing the component.";
      }
      leaf entitlement-tag {
        tailf:info
          "Entitlement tag for Smart Licensing.";
        type string;
        description
          "Identifies the component for Smart Licensing.";
      }
      choice type {
        mandatory true;
        case ned {
          description
            "A NED package typically contains the YANG models for
             the device, and Java classes derived from these modules.
             The Java classes are delivered as 'shared' jar files, which
             makes them available for Java services and other Java code
             to use.";
          container ned {
            tailf:info
              "NED component";
            choice ned-type {
              mandatory true;
              container netconf {
                tailf:info
                  "NETCONF NED";
                description
                  "A NETCONF NED typically consists of the YANG modules
                   for the device, and Java classes derived from these
                   modules.";
                leaf ned-id {
                  tailf:info
                    "The NETCONF NED identity";
                  // NCS patched to string, due to LSA partial NED
                  type string;
                  mandatory false;
                  description
                    "The identity that identifies the NETCONF NED. If
                     let empty it is just a plain NETCONF NED.";
                }
              }
              container snmp {
                tailf:info
                  "SNMP NED";
                description
                  "An SNMP NED typically consists of the MIB modules
                   for the device, YANG modules derived from the MIBs, and
                   Java classes derived from these models.";
                leaf ned-id {
                  tailf:info
                    "The SNMP NED identity";
                  // NCS patched to string, due to LSA partial NED
                  type string;
                  description
                    "The identity that identifies the SNMP NED.";
                }
              }
              container cli {
                tailf:info
                  "CLI NED";
                description
                  "A CLI NED typically consists of YANG models for the
                   device, Java classes derived from these modules, and
                   a Java class responsible for the communication with the
                   device.";
                leaf ned-id {
                  tailf:info
                    "The CLI NED identity";
                  // NCS patched to string, due to LSA partial NED
                  type string;
                  mandatory true;
                  description
                    "The identity that identifies the CLI NED.  All
                     devices of type 'cli' that are configured with
                     this 'ned-id' are handled by this compontent's 'NedCli'
                     Java class.";
                }
                leaf java-class-name {
                  tailf:info
                    "Name of the Java class that implements the NED";
                  type string;
                  mandatory true;
                  description
                    "The name of the Java class that implements the
                     interface 'NedCli'.";
                }
              }
              container generic {
                tailf:info
                  "Generic NED";
                description
                  "A Generic NED typically consists of YANG models for the
                   device, Java classes derived from these modules, and
                   a Java class responsible for the communication with the
                   device.";
                leaf ned-id {
                  tailf:info
                    "The Generic NED identity";
                  // NCS patched to string, due to LSA partial NED
                  type string;
                  mandatory true;
                  description
                    "The identity that identifies the Generic NED.  All
                     devices of type 'generic' that are configured with
                     this 'ned-id' are handled by this component's 'NedGeneric'
                     Java class.";
                }
                leaf java-class-name {
                  tailf:info
                    "Name of the Java class that implements the NED";
                  type string;
                  mandatory true;
                  description
                    "The name of the Java class that implements the
                     interface 'NedGeneric'.";
                }
              }
            }
            container device {
              tailf:info
                "NED device type information";
              leaf vendor {
                tailf:info
                  "Vendor name";
                type string;
                mandatory true;
                description
                  "Free-form string, used for documentation purposes.";
              }
              leaf product-family {
                tailf:info
                  "Product family";
                type string;
                description
                  "The product-specific family of products supported by this
                   NED.

                   In some cases, this could be as generic as 'ios', if the
                   NED works with any ios release.  In other cases it could
                   be as specific as 'ios-11.4' if it works only with ios
                   release 11.4.  And in some cases, it would be some middle
                   ground, e.g., 'ios-11' or 'ios-11+'.";
              }
            }
            list option {
              tailf:info
                "NED specific options";
              key "name";
              description
                "A list of options to configure the behavior of this NED.
                 Available options are:

                  ordered-diff (for generic NEDs),
                     Order the operations sent the NED such that
                     dependencies are taken into account, ie if a
                     list element is deleted and there are leafref
                     references to the instance, order the leafref
                     in front of the delete of the instance.

                  show-tag (for CLI NEDs)
                     If set the NED will only ask for one top-tag in
                     the show() callback instead of invoking the show()
                     callback once for each top-tag. Many NEDs return
                     the entire configuration in one go and are only
                     interested in one show() invocation. The common
                     workaround is to only return when the show() command
                     is invoked with a specific top-tag, and return the
                     empty string for the rest. With this option set
                     there will only be one show() invocation.

                  allow-abbrevs (for CLI NEDs)
                     When set abbreviated commands are allowed to be
                     sent in the response to the show() callback. Devices
                     typically do not generate abbreviated commands and
                     setting the above option may introduce ambiguity in
                     the parsing.

                  show-partial
                    Set if the NED supports partial show.
                ";
              leaf name {
                tailf:info
                  "Option name";
                type string;
              }
              leaf value {
                tailf:info
                  "Option value";
                type string;
              }
            }
          }
        }
        case upgrade {
          description
            "An upgrade component is used to migrate data for packages
             where the YANG data model has changed and the automatic
             CDB upgrade is not sufficient. The upgrade component
             consists of either a Java class with a main method or a
             Python class with an upgrade method, that is expected to
             run one time only.";
          container upgrade {
            tailf:info
              "Upgrade component information";
            choice type {
              mandatory true;
              case java {
                leaf java-class-name {
                  tailf:info
                    "Name of the Java class that implements
                     the data migration";
                  type string;
                  description
                    "The name of the Java class that implements a main method
                     which will migrate data.";
                }
              }
              case python {
                leaf python-class-name {
                  tailf:info
                    "Name of the Python class that implements
                     the data migration";
                  type string;
                  description
                    "Name of the Python class that implements an upgrade
                     method which will migrate data.";
                }
              }
            }
          }
        }
        case callback {
          description
            "A data-provider can be used to implement NCS,
             services, external data providers, etc.";
          container callback {
            tailf:info
              "Callback component";
            leaf-list java-class-name {
              tailf:info
                "Java classes that implement the callback";
              type string;
              min-elements 1;
              description
                "The name of the Java class that is annotated with one of
                 the callback annotations 'ServiceCallback', 'ActionCallback',
                 'AuthCallback', 'DataCallback', 'DBCallback',
                 'SnmpInformResponseCallback', 'TransCallback',
                 'TransValidateCallback', or 'ValidateCallback'.";
            }
          }
        }
        case application {
          description
            "An application is a generic type with some
             Java code, and a Java class that is instantiated by NCS.";
          container application {
            tailf:info
              "Application component";
            choice type {
              mandatory true;
              case java {
                description
                  "Java application";
                leaf java-class-name {
                  tailf:info
                    "Java class that implements the application";
                  type string;
                  mandatory true;
                  description
                    "The name of the Java class that implements the
                     interface 'com.tailf.ncs.ApplicationComponent'.";
                }
              }
              case python {
                description
                  "Python application";
                leaf python-class-name {
                  tailf:info
                    "Python class that implements the application";
                  type string;
                  mandatory true;
                  description
                    "The name of the Python class that will be started by NCS.

                     An empty string here indicates a Python Library,
                     i.e., no code will be invoked by NCS. However, other
                     packages may depend on this package, thus getting the
                     PYTHONPATH setup to point to this package.";
                }
              }
            }
            leaf start-phase {
              tailf:info
                "NCS start phase where the package is instantiated";
              type enumeration {
                enum "phase1";
                enum "phase2";
              }
              default "phase2";
              description
                "The start phase where the package is instantiated.";
            }
          }
        }
      }
    }
  }

  grouping live_ncs_package-meta-data {
    description
      "This grouping describes meta-data for a NCS package.

       A NCS package has the following file structure:

         <package-name>/package-meta-data.xml
                        load-dir/
                        cdb/
                        shared-jar/
                        private-jar/
                        erlang-lib/
                        python/
                        webui/
                        templates/
                        scripts/
                        src/
                        doc/
                        netsim/

       The package-meta-data.xml file contains a top-level element
       'ncs-package' in the namespace defined by this module, which
       behaves as if defined as:

         container ncs-package {
           uses package-meta-data;
         }

       The optional 'load-dir' directory is appended to the
       'load-path' of NCS.  It contains fxs files and ccl files
       etc. It can also contain .xml files, which will be loaded by
       CDB during init and upgrade (i.e. these files can be used to
       include inital CDB data needed by the package).

       The optional 'shared-jar' directory contains jar files with
       Java code that is shared among all packages. Once loaded, this
       code cannot be modified without reloading all jar files for all
       packages.

       The optional 'private-jar' directory contains jar files with
       Java code that are loaded by a package-spefic class loader.
       Thus, this code is not available from other packages.  By
       putting for example the code for a specific service in a
       private jar, NCS can dynamically upgrade the service without
       affecting any other service.

       The optional 'erlang-lib' directory contains Erlang
       applications.

       The optional 'python' directory contains Python code for the
       component.

       The optional 'webui' directory contains webui customization
       files.

       The optional 'templates' directory contains templates for
       template-based services.";

    typedef version {
      type live_ncs_package-version;
      description
        "The version is a sequence of numbers and words, separated by '.'
         or '-'.  When NCS compares a version string, it parses the string
         into the sequence of numbers and words, and compares each component
         individually.";
    }
    leaf name {
      tailf:info
        "A unique name, used to identify the package";
      type string;
      // NCS drop mandatory statement
      description
        "A unique name, used to identify the package.";
    }
    leaf package-version {
      tailf:info
        "The version of the package";
      type version;
      // NCS drop mandatory statement
      description
        "The version of the package. An NCS customer that modifies a package
         is encouraged to add its own info to this string, e.g.
           1.2-acme-1
           1.2-acme-2";
    }
    leaf description {
      tailf:info
        "Free-form text describing the package";
      type string;
      description
        "Free-form text describing the package.";
    }
    leaf-list ncs-min-version {
      tailf:info
        "Minimum NCS versions, one per NCS major,  required by this package";
      type version;
      description
        "Minimum NCS versions, one per NCS major, required by this package.";
    }
    container python-package {
      tailf:info
        "Python specific data.";
      presence "Python specific package data";
      leaf vm-name {
        type string;
        description
          "A Python package will per default run in a seperate Python VM.
           This Python VM will get a symbolic name (for reference from
           within NCS) which per default is the package 'name'.

           However, by setting 'vm-name', its value will be used as as
           the symbolic name for the Python VM started. This will
           cause packages with the same 'vm-name' to run in the same
           Python VM.";
      }
    }
    leaf directory {
      tailf:info
        "The path to the directory of the package";
      type string;
      description
        "The path to the directory of the package.";
    }
    leaf-list templates {
      tailf:info
        "The templates defined by this package";
      type string;
      description
        "The templates defined by this package.";
    }
    leaf template-loading-mode {
      type enumeration {
        enum "strict";
        enum "relaxed";
      }
      description
        "This leaf indicates whether the templates in this package are
         interpreted in strict mode or relaxed mode. It is unset if the package
         has no templates.

         Strict mode means we report all schema-related errors in templates
         that can be identified at load time (such as unknown namespace, schema
         ambiguity or unknown ned-id). Strict mode is applid when there are no
         supported-ned-ids declared or when all of the supported-ned-ids are
         loaded.

         If the package declares supported-ned-ids, but some of them are not
         recognized, then we assume relaxed mode as we will not be able to
         identify some of the schema-related errors, for example we might need
         to skip over tags in unknown namespaces because they might belong
         to the missing ned-ids that the package supports, but that are
         currently not loaded in the runtime system.

         It is important that the package developer tests the package with
         all the supported-ned-ids loaded, i.e. in strict mode, as it helps
         catch errors that may be ignored in relaxed mode.";
    }
    leaf-list supported-ned-id {
      tailf:info
        "The list of ned-ids supported by this package";
      type union {
        // NCS patched to string, due to LSA partial NED
        type string;
        type string;
      }
      description
        "Templates defined by this package will be applied in the scope of
         this list of ned-ids. Trying to apply a template defined by this
         package to a device with a different ned-id will result at runtime
         error. If no supported-ned-id is defined, then no such restrictions
         are placed on this package's templates, however it may lead to a
         situation where loading an additional NED can prevent the package
         defining the template from loading by making a template ambiguous.

         This parameter has no effect for packages that define no templates.";
    }
    list required-package {
      tailf:info
        "A list of packages required by this package";
      key "name";
      description
        "A list of packages required by this package.  NCS will not
         load any package with missing dependencies.";
      leaf name {
        tailf:info
          "Required package name";
        type string;
      }
      leaf min-version {
        tailf:info
          "Required package minimum version";
        type version;
        description
          "Minimum version required by this package.";
      }
    }
    list component {
      tailf:info
        "Package components";
      key "name";
      leaf name {
        tailf:info
          "Component name";
        type string;
        description
          "A unique name, used to identify the component within
           the package.";
      }
      leaf description {
        tailf:info
          "Free-form text describing the component";
        type string;
        description
          "Free-form text describing the component.";
      }
      leaf entitlement-tag {
        tailf:info
          "Entitlement tag for Smart Licensing.";
        type string;
        description
          "Identifies the component for Smart Licensing.";
      }
      choice type {
        // NCS drop mandatory statement
        case ned {
          description
            "A NED package typically contains the YANG models for
             the device, and Java classes derived from these modules.
             The Java classes are delivered as 'shared' jar files, which
             makes them available for Java services and other Java code
             to use.";
          container ned {
            tailf:info
              "NED component";
            choice ned-type {
              // NCS drop mandatory statement
              container netconf {
                tailf:info
                  "NETCONF NED";
                description
                  "A NETCONF NED typically consists of the YANG modules
                   for the device, and Java classes derived from these
                   modules.";
                leaf ned-id {
                  tailf:info
                    "The NETCONF NED identity";
                  // NCS patched to string, due to LSA partial NED
                  type string;
                  // NCS drop mandatory statement
                  description
                    "The identity that identifies the NETCONF NED. If
                     let empty it is just a plain NETCONF NED.";
                }
              }
              container snmp {
                tailf:info
                  "SNMP NED";
                description
                  "An SNMP NED typically consists of the MIB modules
                   for the device, YANG modules derived from the MIBs, and
                   Java classes derived from these models.";
                leaf ned-id {
                  tailf:info
                    "The SNMP NED identity";
                  // NCS patched to string, due to LSA partial NED
                  type string;
                  description
                    "The identity that identifies the SNMP NED.";
                }
              }
              container cli {
                tailf:info
                  "CLI NED";
                description
                  "A CLI NED typically consists of YANG models for the
                   device, Java classes derived from these modules, and
                   a Java class responsible for the communication with the
                   device.";
                leaf ned-id {
                  tailf:info
                    "The CLI NED identity";
                  // NCS patched to string, due to LSA partial NED
                  type string;
                  // NCS drop mandatory statement
                  description
                    "The identity that identifies the CLI NED.  All
                     devices of type 'cli' that are configured with
                     this 'ned-id' are handled by this compontent's 'NedCli'
                     Java class.";
                }
                leaf java-class-name {
                  tailf:info
                    "Name of the Java class that implements the NED";
                  type string;
                  // NCS drop mandatory statement
                  description
                    "The name of the Java class that implements the
                     interface 'NedCli'.";
                }
              }
              container generic {
                tailf:info
                  "Generic NED";
                description
                  "A Generic NED typically consists of YANG models for the
                   device, Java classes derived from these modules, and
                   a Java class responsible for the communication with the
                   device.";
                leaf ned-id {
                  tailf:info
                    "The Generic NED identity";
                  // NCS patched to string, due to LSA partial NED
                  type string;
                  // NCS drop mandatory statement
                  description
                    "The identity that identifies the Generic NED.  All
                     devices of type 'generic' that are configured with
                     this 'ned-id' are handled by this component's 'NedGeneric'
                     Java class.";
                }
                leaf java-class-name {
                  tailf:info
                    "Name of the Java class that implements the NED";
                  type string;
                  // NCS drop mandatory statement
                  description
                    "The name of the Java class that implements the
                     interface 'NedGeneric'.";
                }
              }
            }
            container device {
              tailf:info
                "NED device type information";
              leaf vendor {
                tailf:info
                  "Vendor name";
                type string;
                // NCS drop mandatory statement
                description
                  "Free-form string, used for documentation purposes.";
              }
              leaf product-family {
                tailf:info
                  "Product family";
                type string;
                description
                  "The product-specific family of products supported by this
                   NED.

                   In some cases, this could be as generic as 'ios', if the
                   NED works with any ios release.  In other cases it could
                   be as specific as 'ios-11.4' if it works only with ios
                   release 11.4.  And in some cases, it would be some middle
                   ground, e.g., 'ios-11' or 'ios-11+'.";
              }
            }
            list option {
              tailf:info
                "NED specific options";
              key "name";
              description
                "A list of options to configure the behavior of this NED.
                 Available options are:

                  ordered-diff (for generic NEDs),
                     Order the operations sent the NED such that
                     dependencies are taken into account, ie if a
                     list element is deleted and there are leafref
                     references to the instance, order the leafref
                     in front of the delete of the instance.

                  show-tag (for CLI NEDs)
                     If set the NED will only ask for one top-tag in
                     the show() callback instead of invoking the show()
                     callback once for each top-tag. Many NEDs return
                     the entire configuration in one go and are only
                     interested in one show() invocation. The common
                     workaround is to only return when the show() command
                     is invoked with a specific top-tag, and return the
                     empty string for the rest. With this option set
                     there will only be one show() invocation.

                  allow-abbrevs (for CLI NEDs)
                     When set abbreviated commands are allowed to be
                     sent in the response to the show() callback. Devices
                     typically do not generate abbreviated commands and
                     setting the above option may introduce ambiguity in
                     the parsing.

                  show-partial
                    Set if the NED supports partial show.
                ";
              leaf name {
                tailf:info
                  "Option name";
                type string;
              }
              leaf value {
                tailf:info
                  "Option value";
                type string;
              }
            }
          }
        }
        case upgrade {
          description
            "An upgrade component is used to migrate data for packages
             where the YANG data model has changed and the automatic
             CDB upgrade is not sufficient. The upgrade component
             consists of either a Java class with a main method or a
             Python class with an upgrade method, that is expected to
             run one time only.";
          container upgrade {
            tailf:info
              "Upgrade component information";
            choice type {
              // NCS drop mandatory statement
              case java {
                leaf java-class-name {
                  tailf:info
                    "Name of the Java class that implements
                     the data migration";
                  type string;
                  description
                    "The name of the Java class that implements a main method
                     which will migrate data.";
                }
              }
              case python {
                leaf python-class-name {
                  tailf:info
                    "Name of the Python class that implements
                     the data migration";
                  type string;
                  description
                    "Name of the Python class that implements an upgrade
                     method which will migrate data.";
                }
              }
            }
          }
        }
        case callback {
          description
            "A data-provider can be used to implement NCS,
             services, external data providers, etc.";
          container callback {
            tailf:info
              "Callback component";
            leaf-list java-class-name {
              tailf:info
                "Java classes that implement the callback";
              type string;
              // NCS drop min-elements statement
              description
                "The name of the Java class that is annotated with one of
                 the callback annotations 'ServiceCallback', 'ActionCallback',
                 'AuthCallback', 'DataCallback', 'DBCallback',
                 'SnmpInformResponseCallback', 'TransCallback',
                 'TransValidateCallback', or 'ValidateCallback'.";
            }
          }
        }
        case application {
          description
            "An application is a generic type with some
             Java code, and a Java class that is instantiated by NCS.";
          container application {
            tailf:info
              "Application component";
            choice type {
              // NCS drop mandatory statement
              case java {
                description
                  "Java application";
                leaf java-class-name {
                  tailf:info
                    "Java class that implements the application";
                  type string;
                  // NCS drop mandatory statement
                  description
                    "The name of the Java class that implements the
                     interface 'com.tailf.ncs.ApplicationComponent'.";
                }
              }
              case python {
                description
                  "Python application";
                leaf python-class-name {
                  tailf:info
                    "Python class that implements the application";
                  type string;
                  // NCS drop mandatory statement
                  description
                    "The name of the Python class that will be started by NCS.

                     An empty string here indicates a Python Library,
                     i.e., no code will be invoked by NCS. However, other
                     packages may depend on this package, thus getting the
                     PYTHONPATH setup to point to this package.";
                }
              }
            }
            leaf start-phase {
              tailf:info
                "NCS start phase where the package is instantiated";
              type enumeration {
                enum "phase1";
                enum "phase2";
              }
              // NCS drop default statement
              description
                "The start phase where the package is instantiated.";
            }
          }
        }
      }
    }
  }

  grouping package-meta-data {
    description
      "This grouping describes meta-data for a NCS package.

       A NCS package has the following file structure:

         <package-name>/package-meta-data.xml
                        load-dir/
                        cdb/
                        shared-jar/
                        private-jar/
                        erlang-lib/
                        python/
                        webui/
                        templates/
                        scripts/
                        src/
                        doc/
                        netsim/

       The package-meta-data.xml file contains a top-level element
       'ncs-package' in the namespace defined by this module, which
       behaves as if defined as:

         container ncs-package {
           uses package-meta-data;
         }

       The optional 'load-dir' directory is appended to the
       'load-path' of NCS.  It contains fxs files and ccl files
       etc. It can also contain .xml files, which will be loaded by
       CDB during init and upgrade (i.e. these files can be used to
       include inital CDB data needed by the package).

       The optional 'shared-jar' directory contains jar files with
       Java code that is shared among all packages. Once loaded, this
       code cannot be modified without reloading all jar files for all
       packages.

       The optional 'private-jar' directory contains jar files with
       Java code that are loaded by a package-spefic class loader.
       Thus, this code is not available from other packages.  By
       putting for example the code for a specific service in a
       private jar, NCS can dynamically upgrade the service without
       affecting any other service.

       The optional 'erlang-lib' directory contains Erlang
       applications.

       The optional 'python' directory contains Python code for the
       component.

       The optional 'webui' directory contains webui customization
       files.

       The optional 'templates' directory contains templates for
       template-based services.";

    typedef version {
      type package-version;
      description
        "The version is a sequence of numbers and words, separated by '.'
         or '-'.  When NCS compares a version string, it parses the string
         into the sequence of numbers and words, and compares each component
         individually.";
    }
    leaf name {
      tailf:info
        "A unique name, used to identify the package";
      type string;
      mandatory true;
      description
        "A unique name, used to identify the package.";
    }
    leaf package-version {
      tailf:info
        "The version of the package";
      type version;
      mandatory true;
      description
        "The version of the package. An NCS customer that modifies a package
         is encouraged to add its own info to this string, e.g.
           1.2-acme-1
           1.2-acme-2";
    }
    leaf description {
      tailf:info
        "Free-form text describing the package";
      type string;
      description
        "Free-form text describing the package.";
    }
    leaf-list ncs-min-version {
      tailf:info
        "Minimum NCS versions, one per NCS major,  required by this package";
      type version;
      description
        "Minimum NCS versions, one per NCS major, required by this package.";
    }
    container python-package {
      tailf:info
        "Python specific data.";
      presence "Python specific package data";
      leaf vm-name {
        type string;
        description
          "A Python package will per default run in a seperate Python VM.
           This Python VM will get a symbolic name (for reference from
           within NCS) which per default is the package 'name'.

           However, by setting 'vm-name', its value will be used as as
           the symbolic name for the Python VM started. This will
           cause packages with the same 'vm-name' to run in the same
           Python VM.";
      }
    }
    leaf directory {
      tailf:info
        "The path to the directory of the package";
      type string;
      description
        "The path to the directory of the package.";
    }
    leaf-list templates {
      tailf:info
        "The templates defined by this package";
      type string;
      description
        "The templates defined by this package.";
    }
    leaf template-loading-mode {
      type enumeration {
        enum "strict";
        enum "relaxed";
      }
      description
        "This leaf indicates whether the templates in this package are
         interpreted in strict mode or relaxed mode. It is unset if the package
         has no templates.

         Strict mode means we report all schema-related errors in templates
         that can be identified at load time (such as unknown namespace, schema
         ambiguity or unknown ned-id). Strict mode is applid when there are no
         supported-ned-ids declared or when all of the supported-ned-ids are
         loaded.

         If the package declares supported-ned-ids, but some of them are not
         recognized, then we assume relaxed mode as we will not be able to
         identify some of the schema-related errors, for example we might need
         to skip over tags in unknown namespaces because they might belong
         to the missing ned-ids that the package supports, but that are
         currently not loaded in the runtime system.

         It is important that the package developer tests the package with
         all the supported-ned-ids loaded, i.e. in strict mode, as it helps
         catch errors that may be ignored in relaxed mode.";
    }
    leaf-list supported-ned-id {
      tailf:info
        "The list of ned-ids supported by this package";
      type union {
        // NCS patched to string, due to LSA partial NED
        type string;
        type string;
      }
      description
        "Templates defined by this package will be applied in the scope of
         this list of ned-ids. Trying to apply a template defined by this
         package to a device with a different ned-id will result at runtime
         error. If no supported-ned-id is defined, then no such restrictions
         are placed on this package's templates, however it may lead to a
         situation where loading an additional NED can prevent the package
         defining the template from loading by making a template ambiguous.

         This parameter has no effect for packages that define no templates.";
    }
    list required-package {
      tailf:info
        "A list of packages required by this package";
      key "name";
      description
        "A list of packages required by this package.  NCS will not
         load any package with missing dependencies.";
      leaf name {
        tailf:info
          "Required package name";
        type string;
      }
      leaf min-version {
        tailf:info
          "Required package minimum version";
        type version;
        description
          "Minimum version required by this package.";
      }
    }
    list component {
      tailf:info
        "Package components";
      key "name";
      leaf name {
        tailf:info
          "Component name";
        type string;
        description
          "A unique name, used to identify the component within
           the package.";
      }
      leaf description {
        tailf:info
          "Free-form text describing the component";
        type string;
        description
          "Free-form text describing the component.";
      }
      leaf entitlement-tag {
        tailf:info
          "Entitlement tag for Smart Licensing.";
        type string;
        description
          "Identifies the component for Smart Licensing.";
      }
      choice type {
        mandatory true;
        case ned {
          description
            "A NED package typically contains the YANG models for
             the device, and Java classes derived from these modules.
             The Java classes are delivered as 'shared' jar files, which
             makes them available for Java services and other Java code
             to use.";
          container ned {
            tailf:info
              "NED component";
            choice ned-type {
              mandatory true;
              container netconf {
                tailf:info
                  "NETCONF NED";
                description
                  "A NETCONF NED typically consists of the YANG modules
                   for the device, and Java classes derived from these
                   modules.";
                leaf ned-id {
                  tailf:info
                    "The NETCONF NED identity";
                  // NCS patched to string, due to LSA partial NED
                  type string;
                  mandatory false;
                  description
                    "The identity that identifies the NETCONF NED. If
                     let empty it is just a plain NETCONF NED.";
                }
              }
              container snmp {
                tailf:info
                  "SNMP NED";
                description
                  "An SNMP NED typically consists of the MIB modules
                   for the device, YANG modules derived from the MIBs, and
                   Java classes derived from these models.";
                leaf ned-id {
                  tailf:info
                    "The SNMP NED identity";
                  // NCS patched to string, due to LSA partial NED
                  type string;
                  description
                    "The identity that identifies the SNMP NED.";
                }
              }
              container cli {
                tailf:info
                  "CLI NED";
                description
                  "A CLI NED typically consists of YANG models for the
                   device, Java classes derived from these modules, and
                   a Java class responsible for the communication with the
                   device.";
                leaf ned-id {
                  tailf:info
                    "The CLI NED identity";
                  // NCS patched to string, due to LSA partial NED
                  type string;
                  mandatory true;
                  description
                    "The identity that identifies the CLI NED.  All
                     devices of type 'cli' that are configured with
                     this 'ned-id' are handled by this compontent's 'NedCli'
                     Java class.";
                }
                leaf java-class-name {
                  tailf:info
                    "Name of the Java class that implements the NED";
                  type string;
                  mandatory true;
                  description
                    "The name of the Java class that implements the
                     interface 'NedCli'.";
                }
              }
              container generic {
                tailf:info
                  "Generic NED";
                description
                  "A Generic NED typically consists of YANG models for the
                   device, Java classes derived from these modules, and
                   a Java class responsible for the communication with the
                   device.";
                leaf ned-id {
                  tailf:info
                    "The Generic NED identity";
                  // NCS patched to string, due to LSA partial NED
                  type string;
                  mandatory true;
                  description
                    "The identity that identifies the Generic NED.  All
                     devices of type 'generic' that are configured with
                     this 'ned-id' are handled by this component's 'NedGeneric'
                     Java class.";
                }
                leaf java-class-name {
                  tailf:info
                    "Name of the Java class that implements the NED";
                  type string;
                  mandatory true;
                  description
                    "The name of the Java class that implements the
                     interface 'NedGeneric'.";
                }
              }
            }
            container device {
              tailf:info
                "NED device type information";
              leaf vendor {
                tailf:info
                  "Vendor name";
                type string;
                mandatory true;
                description
                  "Free-form string, used for documentation purposes.";
              }
              leaf product-family {
                tailf:info
                  "Product family";
                type string;
                description
                  "The product-specific family of products supported by this
                   NED.

                   In some cases, this could be as generic as 'ios', if the
                   NED works with any ios release.  In other cases it could
                   be as specific as 'ios-11.4' if it works only with ios
                   release 11.4.  And in some cases, it would be some middle
                   ground, e.g., 'ios-11' or 'ios-11+'.";
              }
            }
            list option {
              tailf:info
                "NED specific options";
              key "name";
              description
                "A list of options to configure the behavior of this NED.
                 Available options are:

                  ordered-diff (for generic NEDs),
                     Order the operations sent the NED such that
                     dependencies are taken into account, ie if a
                     list element is deleted and there are leafref
                     references to the instance, order the leafref
                     in front of the delete of the instance.

                  show-tag (for CLI NEDs)
                     If set the NED will only ask for one top-tag in
                     the show() callback instead of invoking the show()
                     callback once for each top-tag. Many NEDs return
                     the entire configuration in one go and are only
                     interested in one show() invocation. The common
                     workaround is to only return when the show() command
                     is invoked with a specific top-tag, and return the
                     empty string for the rest. With this option set
                     there will only be one show() invocation.

                  allow-abbrevs (for CLI NEDs)
                     When set abbreviated commands are allowed to be
                     sent in the response to the show() callback. Devices
                     typically do not generate abbreviated commands and
                     setting the above option may introduce ambiguity in
                     the parsing.

                  show-partial
                    Set if the NED supports partial show.
                ";
              leaf name {
                tailf:info
                  "Option name";
                type string;
              }
              leaf value {
                tailf:info
                  "Option value";
                type string;
              }
            }
          }
        }
        case upgrade {
          description
            "An upgrade component is used to migrate data for packages
             where the YANG data model has changed and the automatic
             CDB upgrade is not sufficient. The upgrade component
             consists of either a Java class with a main method or a
             Python class with an upgrade method, that is expected to
             run one time only.";
          container upgrade {
            tailf:info
              "Upgrade component information";
            choice type {
              mandatory true;
              case java {
                leaf java-class-name {
                  tailf:info
                    "Name of the Java class that implements
                     the data migration";
                  type string;
                  description
                    "The name of the Java class that implements a main method
                     which will migrate data.";
                }
              }
              case python {
                leaf python-class-name {
                  tailf:info
                    "Name of the Python class that implements
                     the data migration";
                  type string;
                  description
                    "Name of the Python class that implements an upgrade
                     method which will migrate data.";
                }
              }
            }
          }
        }
        case callback {
          description
            "A data-provider can be used to implement NCS,
             services, external data providers, etc.";
          container callback {
            tailf:info
              "Callback component";
            leaf-list java-class-name {
              tailf:info
                "Java classes that implement the callback";
              type string;
              min-elements 1;
              description
                "The name of the Java class that is annotated with one of
                 the callback annotations 'ServiceCallback', 'ActionCallback',
                 'AuthCallback', 'DataCallback', 'DBCallback',
                 'SnmpInformResponseCallback', 'TransCallback',
                 'TransValidateCallback', or 'ValidateCallback'.";
            }
          }
        }
        case application {
          description
            "An application is a generic type with some
             Java code, and a Java class that is instantiated by NCS.";
          container application {
            tailf:info
              "Application component";
            choice type {
              mandatory true;
              case java {
                description
                  "Java application";
                leaf java-class-name {
                  tailf:info
                    "Java class that implements the application";
                  type string;
                  mandatory true;
                  description
                    "The name of the Java class that implements the
                     interface 'com.tailf.ncs.ApplicationComponent'.";
                }
              }
              case python {
                description
                  "Python application";
                leaf python-class-name {
                  tailf:info
                    "Python class that implements the application";
                  type string;
                  mandatory true;
                  description
                    "The name of the Python class that will be started by NCS.

                     An empty string here indicates a Python Library,
                     i.e., no code will be invoked by NCS. However, other
                     packages may depend on this package, thus getting the
                     PYTHONPATH setup to point to this package.";
                }
              }
            }
            leaf start-phase {
              tailf:info
                "NCS start phase where the package is instantiated";
              type enumeration {
                enum "phase1";
                enum "phase2";
              }
              default "phase2";
              description
                "The start phase where the package is instantiated.";
            }
          }
        }
      }
    }
  }

  augment "/ncs-internal:devices/ncs-internal:device/ncs-internal:config" {
    // NCS drop config false container packages
  }
  augment "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status" {
    container packages {
      tailf:ncs-device-type "netconf";
      tailf:display-when "not(../../ncs-internal:module) or ../../ncs-internal:module[ncs-internal:name='tailf-ncs'] or (../../ncs-internal:live-status-protocol[not(ncs-internal:capability)]) or (../../ncs-internal:live-status-protocol/ncs-internal:capability/ncs-internal:module[.='tailf-ncs'])";
      tailf:info
        "Installed packages";
      description
        "Lists all installed NCS packages.";
      // NCS drop tailf:callpoint
      list package {
        tailf:info
          "Show installed packages";
        key "name";
        // NCS expand uses statement

        typedef version {
          type live_ncs_package-version;
          description
            "The version is a sequence of numbers and words, separated by '.'
             or '-'.  When NCS compares a version string, it parses the string
             into the sequence of numbers and words, and compares each component
             individually.";
        }
        leaf name {
          tailf:info
            "A unique name, used to identify the package";
          type string;
          // NCS drop mandatory statement
          description
            "A unique name, used to identify the package.";
          // NCS drop tailf:cli-allow-range
        }
        leaf package-version {
          tailf:info
            "The version of the package";
          type version;
          // NCS drop mandatory statement
          description
            "The version of the package. An NCS customer that modifies a package
             is encouraged to add its own info to this string, e.g.
               1.2-acme-1
               1.2-acme-2";
        }
        leaf description {
          tailf:info
            "Free-form text describing the package";
          type string;
          description
            "Free-form text describing the package.";
        }
        leaf-list ncs-min-version {
          tailf:info
            "Minimum NCS versions, one per NCS major,  required by this package";
          type version;
          description
            "Minimum NCS versions, one per NCS major, required by this package.";
        }
        container python-package {
          tailf:info
            "Python specific data.";
          presence "Python specific package data";
          leaf vm-name {
            type string;
            description
              "A Python package will per default run in a seperate Python VM.
               This Python VM will get a symbolic name (for reference from
               within NCS) which per default is the package 'name'.

               However, by setting 'vm-name', its value will be used as as
               the symbolic name for the Python VM started. This will
               cause packages with the same 'vm-name' to run in the same
               Python VM.";
          }
        }
        leaf directory {
          tailf:info
            "The path to the directory of the package";
          type string;
          description
            "The path to the directory of the package.";
        }
        leaf-list templates {
          tailf:info
            "The templates defined by this package";
          type string;
          description
            "The templates defined by this package.";
        }
        leaf template-loading-mode {
          type enumeration {
            enum "strict";
            enum "relaxed";
          }
          description
            "This leaf indicates whether the templates in this package are
             interpreted in strict mode or relaxed mode. It is unset if the package
             has no templates.

             Strict mode means we report all schema-related errors in templates
             that can be identified at load time (such as unknown namespace, schema
             ambiguity or unknown ned-id). Strict mode is applid when there are no
             supported-ned-ids declared or when all of the supported-ned-ids are
             loaded.

             If the package declares supported-ned-ids, but some of them are not
             recognized, then we assume relaxed mode as we will not be able to
             identify some of the schema-related errors, for example we might need
             to skip over tags in unknown namespaces because they might belong
             to the missing ned-ids that the package supports, but that are
             currently not loaded in the runtime system.

             It is important that the package developer tests the package with
             all the supported-ned-ids loaded, i.e. in strict mode, as it helps
             catch errors that may be ignored in relaxed mode.";
        }
        leaf-list supported-ned-id {
          tailf:info
            "The list of ned-ids supported by this package";
          type union {
            // NCS patched to string, due to LSA partial NED
            type string;
            type string;
          }
          description
            "Templates defined by this package will be applied in the scope of
             this list of ned-ids. Trying to apply a template defined by this
             package to a device with a different ned-id will result at runtime
             error. If no supported-ned-id is defined, then no such restrictions
             are placed on this package's templates, however it may lead to a
             situation where loading an additional NED can prevent the package
             defining the template from loading by making a template ambiguous.

             This parameter has no effect for packages that define no templates.";
        }
        list required-package {
          tailf:info
            "A list of packages required by this package";
          key "name";
          description
            "A list of packages required by this package.  NCS will not
             load any package with missing dependencies.";
          leaf name {
            tailf:info
              "Required package name";
            type string;
            // NCS drop tailf:cli-allow-range
          }
          leaf min-version {
            tailf:info
              "Required package minimum version";
            type version;
            description
              "Minimum version required by this package.";
          }
        }
        list component {
          tailf:info
            "Package components";
          key "name";
          leaf name {
            tailf:info
              "Component name";
            type string;
            description
              "A unique name, used to identify the component within
               the package.";
            // NCS drop tailf:cli-allow-range
          }
          leaf description {
            tailf:info
              "Free-form text describing the component";
            type string;
            description
              "Free-form text describing the component.";
          }
          leaf entitlement-tag {
            tailf:info
              "Entitlement tag for Smart Licensing.";
            type string;
            description
              "Identifies the component for Smart Licensing.";
          }
          choice type {
            // NCS drop mandatory statement
            case ned {
              description
                "A NED package typically contains the YANG models for
                 the device, and Java classes derived from these modules.
                 The Java classes are delivered as 'shared' jar files, which
                 makes them available for Java services and other Java code
                 to use.";
              container ned {
                tailf:info
                  "NED component";
                choice ned-type {
                  // NCS drop mandatory statement
                  container netconf {
                    tailf:info
                      "NETCONF NED";
                    description
                      "A NETCONF NED typically consists of the YANG modules
                       for the device, and Java classes derived from these
                       modules.";
                    leaf ned-id {
                      tailf:info
                        "The NETCONF NED identity";
                      // NCS patched to string, due to LSA partial NED
                      type string;
                      // NCS drop mandatory statement
                      description
                        "The identity that identifies the NETCONF NED. If
                         let empty it is just a plain NETCONF NED.";
                    }
                  }
                  container snmp {
                    tailf:info
                      "SNMP NED";
                    description
                      "An SNMP NED typically consists of the MIB modules
                       for the device, YANG modules derived from the MIBs, and
                       Java classes derived from these models.";
                    leaf ned-id {
                      tailf:info
                        "The SNMP NED identity";
                      // NCS patched to string, due to LSA partial NED
                      type string;
                      description
                        "The identity that identifies the SNMP NED.";
                    }
                  }
                  container cli {
                    tailf:info
                      "CLI NED";
                    description
                      "A CLI NED typically consists of YANG models for the
                       device, Java classes derived from these modules, and
                       a Java class responsible for the communication with the
                       device.";
                    leaf ned-id {
                      tailf:info
                        "The CLI NED identity";
                      // NCS patched to string, due to LSA partial NED
                      type string;
                      // NCS drop mandatory statement
                      description
                        "The identity that identifies the CLI NED.  All
                         devices of type 'cli' that are configured with
                         this 'ned-id' are handled by this compontent's 'NedCli'
                         Java class.";
                    }
                    leaf java-class-name {
                      tailf:info
                        "Name of the Java class that implements the NED";
                      type string;
                      // NCS drop mandatory statement
                      description
                        "The name of the Java class that implements the
                         interface 'NedCli'.";
                    }
                  }
                  container generic {
                    tailf:info
                      "Generic NED";
                    description
                      "A Generic NED typically consists of YANG models for the
                       device, Java classes derived from these modules, and
                       a Java class responsible for the communication with the
                       device.";
                    leaf ned-id {
                      tailf:info
                        "The Generic NED identity";
                      // NCS patched to string, due to LSA partial NED
                      type string;
                      // NCS drop mandatory statement
                      description
                        "The identity that identifies the Generic NED.  All
                         devices of type 'generic' that are configured with
                         this 'ned-id' are handled by this component's 'NedGeneric'
                         Java class.";
                    }
                    leaf java-class-name {
                      tailf:info
                        "Name of the Java class that implements the NED";
                      type string;
                      // NCS drop mandatory statement
                      description
                        "The name of the Java class that implements the
                         interface 'NedGeneric'.";
                    }
                  }
                }
                container device {
                  tailf:info
                    "NED device type information";
                  leaf vendor {
                    tailf:info
                      "Vendor name";
                    type string;
                    // NCS drop mandatory statement
                    description
                      "Free-form string, used for documentation purposes.";
                  }
                  leaf product-family {
                    tailf:info
                      "Product family";
                    type string;
                    description
                      "The product-specific family of products supported by this
                       NED.

                       In some cases, this could be as generic as 'ios', if the
                       NED works with any ios release.  In other cases it could
                       be as specific as 'ios-11.4' if it works only with ios
                       release 11.4.  And in some cases, it would be some middle
                       ground, e.g., 'ios-11' or 'ios-11+'.";
                  }
                }
                list option {
                  tailf:info
                    "NED specific options";
                  key "name";
                  description
                    "A list of options to configure the behavior of this NED.
                     Available options are:

                      ordered-diff (for generic NEDs),
                         Order the operations sent the NED such that
                         dependencies are taken into account, ie if a
                         list element is deleted and there are leafref
                         references to the instance, order the leafref
                         in front of the delete of the instance.

                      show-tag (for CLI NEDs)
                         If set the NED will only ask for one top-tag in
                         the show() callback instead of invoking the show()
                         callback once for each top-tag. Many NEDs return
                         the entire configuration in one go and are only
                         interested in one show() invocation. The common
                         workaround is to only return when the show() command
                         is invoked with a specific top-tag, and return the
                         empty string for the rest. With this option set
                         there will only be one show() invocation.

                      allow-abbrevs (for CLI NEDs)
                         When set abbreviated commands are allowed to be
                         sent in the response to the show() callback. Devices
                         typically do not generate abbreviated commands and
                         setting the above option may introduce ambiguity in
                         the parsing.

                      show-partial
                        Set if the NED supports partial show.
                    ";
                  leaf name {
                    tailf:info
                      "Option name";
                    type string;
                    // NCS drop tailf:cli-allow-range
                  }
                  leaf value {
                    tailf:info
                      "Option value";
                    type string;
                  }
                }
              }
            }
            case upgrade {
              description
                "An upgrade component is used to migrate data for packages
                 where the YANG data model has changed and the automatic
                 CDB upgrade is not sufficient. The upgrade component
                 consists of either a Java class with a main method or a
                 Python class with an upgrade method, that is expected to
                 run one time only.";
              container upgrade {
                tailf:info
                  "Upgrade component information";
                choice type {
                  // NCS drop mandatory statement
                  case java {
                    leaf java-class-name {
                      tailf:info
                        "Name of the Java class that implements
                         the data migration";
                      type string;
                      description
                        "The name of the Java class that implements a main method
                         which will migrate data.";
                    }
                  }
                  case python {
                    leaf python-class-name {
                      tailf:info
                        "Name of the Python class that implements
                         the data migration";
                      type string;
                      description
                        "Name of the Python class that implements an upgrade
                         method which will migrate data.";
                    }
                  }
                }
              }
            }
            case callback {
              description
                "A data-provider can be used to implement NCS,
                 services, external data providers, etc.";
              container callback {
                tailf:info
                  "Callback component";
                leaf-list java-class-name {
                  tailf:info
                    "Java classes that implement the callback";
                  type string;
                  // NCS drop min-elements statement
                  description
                    "The name of the Java class that is annotated with one of
                     the callback annotations 'ServiceCallback', 'ActionCallback',
                     'AuthCallback', 'DataCallback', 'DBCallback',
                     'SnmpInformResponseCallback', 'TransCallback',
                     'TransValidateCallback', or 'ValidateCallback'.";
                }
              }
            }
            case application {
              description
                "An application is a generic type with some
                 Java code, and a Java class that is instantiated by NCS.";
              container application {
                tailf:info
                  "Application component";
                choice type {
                  // NCS drop mandatory statement
                  case java {
                    description
                      "Java application";
                    leaf java-class-name {
                      tailf:info
                        "Java class that implements the application";
                      type string;
                      // NCS drop mandatory statement
                      description
                        "The name of the Java class that implements the
                         interface 'com.tailf.ncs.ApplicationComponent'.";
                    }
                  }
                  case python {
                    description
                      "Python application";
                    leaf python-class-name {
                      tailf:info
                        "Python class that implements the application";
                      type string;
                      // NCS drop mandatory statement
                      description
                        "The name of the Python class that will be started by NCS.

                         An empty string here indicates a Python Library,
                         i.e., no code will be invoked by NCS. However, other
                         packages may depend on this package, thus getting the
                         PYTHONPATH setup to point to this package.";
                    }
                  }
                }
                leaf start-phase {
                  tailf:info
                    "NCS start phase where the package is instantiated";
                  type enumeration {
                    enum "phase1";
                    enum "phase2";
                  }
                  // NCS drop default statement
                  description
                    "The start phase where the package is instantiated.";
                }
              }
            }
          }
        }
        tailf:action redeploy {
          tailf:actionpoint ncsproxy {
            tailf:internal;
          }
          tailf:info
            "Redeploy a single package's code";
          // NCS drop tailf:actionpoint
          description
            "Redeploy a single package. This means that Java code contained
             in the private-jar directory, templates belonging to this package,
             Python code and webui customizations will be reloaded if they are
             found to be different from those currently loaded in NSO. Note
             that if YANG modules, Java code in shared-jar directory or
             package-meta-data.xml has been changed, it is necessary to use
             the /packages/reload action.";
          input;
          output {
            leaf result {
              description
                "This leaf indicates whether the package's oper-status is 'up'
                 after the redeploy operation.";
              type boolean;
            }
          }
        }
        container build-info {
          description
            "Detailed build/revision info for the package";
          leaf date {
            type string;
          }
          leaf file {
            type string;
          }
          leaf arch {
            type string;
          }
          leaf java {
            description
              "Details about the Java version used to build the package";
            type string;
          }
          leaf python {
            description
              "Details about the Python version used to build the package";
            type string;
          }
          leaf erlang {
            description
              "Details about the Erlang version used to build the package";
            type string;
          }
          container package {
            description
              "Revision info for the package";
            leaf name {
              type string;
            }
            leaf version {
              type string;
            }
            leaf ref {
              type string;
            }
            leaf sha1 {
              type string;
            }
          }
          container ncs {
            description
              "Revision info for the NCS used to build the package";
            leaf version {
              type string;
            }
            leaf sha1 {
              type string;
            }
          }
          container dev-support {
            description
              "Revision info for the support libs
               used to build the package";
            leaf version {
              type string;
            }
            leaf branch {
              type string;
            }
            leaf sha1 {
              type string;
            }
          }
        }
        container oper-status {
          tailf:info
            "The operational status of the package";
          choice status {
            // NCS drop mandatory statement
            leaf up {
              type empty;
              description
                "The package has all its dependencies fulfilled, and
                 has been loaded by NCS.";
            }
            leaf program-code-error {
              type empty;
              description
                "The package has a program code related error.
                 Any error message will be appended to 'error-info'.";
            }
            leaf java-uninitialized {
              type empty;
              description
                "The package's Java classes have not yet been loaded and
                 initialized.";
            }
            leaf python-uninitialized {
              type empty;
              description
                "The package's Python classes have not yet been loaded and
                 initialized.";
            }
            leaf bad-ncs-version {
              type empty;
              description
                "The package requires a later NCS version than what is
                 currently running.";
            }
            container missing-dependency {
              description
                "The package requires another package, which is not
                 installed, or is installed with a too small version.";
              leaf package-name {
                type string;
                // NCS drop mandatory statement
                description
                  "The name of the required package.";
              }
              leaf package-version {
                type string;
                description
                  "The version of the required package.";
              }
            }
            leaf circular-dependency {
              type empty;
              description
                "A circular dependency loop involving this package was
                 detected.";
            }
            leaf package-meta-data-error {
              type empty;
              description
                "Could not parse the package meta data.";
            }
            leaf file-load-error {
              type empty;
              description
                "Failed to load some file in the package.";
            }
          }
          leaf error-info {
            type string;
            description
              "Contains additional information, if available, when the
               status is not equal to 'up'.";
          }
        }
      }
      tailf:action reload {
        tailf:actionpoint ncsproxy {
          tailf:internal;
        }
        tailf:info
          "Reload all packages";
        // NCS drop tailf:actionpoint
        tailf:cli-operational-mode;
        description
          "Reloads all packages. This means that all parts of all packages
           will be copied to NCS' private directory, reloaded, and restarted.";
        input {
          leaf max-wait-time {
            tailf:info
              "Max time in seconds to wait for transactions to close";
            type uint32 {
              range "0..4294967";
            }
            units "seconds";
            default "10";
            description
              "When a reload includes updated YANG code (.fxs files) or
               CLI specification files (.ccl files), NCS needs to run
               a data model upgrade procedure. This requires that all
               transactions are closed, in particular that users having
               CLI sessions in configure mode must exit to operational
               mode. The 'max-wait-time' is the maximum time to wait for
               this to complete.";
          }
          leaf timeout-action {
            tailf:info
              "Action taken when max-wait-time is reached";
            type enumeration {
              enum "fail" {
                tailf:info
                  "Package reload is canceled";
              }
              enum "kill" {
                tailf:info
                  "Open transactions are forcibly terminated";
              }
            }
            default "fail";
            description
              "If 'max-wait-time' is reached with transactions still open,
               the reload will be canceled if 'timeout-action' is 'fail'.
               If 'timeout-action' is 'kill', any remaining transactions
               will instead be forcibly terminated, and the reload will
               proceed.";
          }
          leaf force {
            tailf:info
              "Ignore warnings.";
            description
              "If this parameter is not given, then the action may abort if
               some dangerous operations need to be performed, such as removal of
               the whole namespace. By using this parameter the operator
               acknowledges this, and allows to proceed with the dangerous
               operations.";
            type empty;
          }
        }
        output {
          list reload-result {
            key "package";
            leaf package {
              type leafref {
                path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/packages/package/name" {
                  tailf:xpath-root 3;
                }
              }
            }
            leaf result {
              type boolean;
              description
                "true if package was successfully loaded";
            }
            leaf info {
              type string;
              description
                "If present, contains additional information about the result.";
            }
          }
        }
      }
    }
  }
  augment "/ncs-internal:devices/ncs-internal:template/ncs-internal:ned-id/ncs-internal:config" {
    // NCS drop config false container packages
  }
}
