submodule tailf-ncs-devices {
  // Generated by yanger -t ncs
  tailf:mount-id "cisco-nso-nc-5.6:cisco-nso-nc-5.6";

  yang-version 1.1;
  belongs-to tailf-ncs {
    prefix ncs;
  }

  import ietf-inet-types {
    prefix inet;
  }
  import ietf-yang-types {
    prefix yang;
  }
  import ietf-yang-schema-mount {
    prefix yangmnt;
  }
  import tailf-common {
    prefix tailf;
  }
  import tailf-ncs-ned {
    prefix ned;
  }
  include tailf-ncs-common;
  include tailf-ncs-cluster;
  include tailf-ncs-ssh;
  import tailf-ncs-internal-mount {
    prefix ncs-internal;
  }

  organization
    "Tail-f Systems";
  description
    "This submodule contains a collection of YANG definitions for
     configuring and monitoring managed devices in NCS.

     Copyright 2012-2021 Cisco Systems, Inc.
     All rights reserved.
     Permission is hereby granted to redistribute this file without
     modification.";

  revision 2021-09-02 {
    description
      "Released as part of NCS-5.6.

       Non-backwards-compatible changes have been introduced.

       Added /devices/commit-queue/queue-item/retry action.

       Removed /devices/device/remote-node and
       /devices/commit-queue/waiting-for/cluster-node leaf.

       Removed 'no-remote' leaf from disconnect and clear-trace
       actions.

       Added container 'dry-run' and the
       'ncs-hidden-commit-params' grouping to the
       apply-template action input parameters.

       Added container 'dry-run' and the
       'ncs-hidden-commit-params' grouping to the
       /devices/device/load-native-config action input parameters.

       Changed name of leaf 'name' to 'device' in
       /devices/commit-queue/completed/queue-item/remote-queue-item.

       Removed tailf:hidden annotation in
       /devices/commit-queue/completed/queue-item/remote-queue-item.

       Added and changed the tailf:display-groups annotation for nodes
       below /devices/commit-queue.

       Removed enum 'not-master' in
       /devices/device/netconf-notifications/subscription/failure-reason.

       Added /devices/device/notifications container.

       Deprecated /devices/device/netconf-notifications container.

       Added enum 'session-limit-exceeded' to
       /devices/device/netconf-notifications/subscription/failure-reason.

       Added action /devices/template/ned-id/copy.

       Added typedef commit-queue-item-event-status.

       Added trace-id leaf to ncs-commit-queue-progress-event notification.

       Added 'ssh-algorithms' configuration to the device-profile-parameters
       grouping and live-status-protocol container.

       Added 'suppress-positive-result' leaf to the migrate action
       input parameters.

       Updated the description of the 'affected-services' leaf in the
       migrate action output parameters.

       Removed the 'affected-services-with-changes' leaf in the
       migrate action output parameters.

       Moved the 'migrate-result' grouping in the output parameters
       of the migrate action for /devices and /devices/device-group/ned-id.

       Made 'old-ned-id' leaf mandatory in the migrate action for /devices.";
  }
  revision 2020-11-26 {
    description
      "Released as part of NCS-5.5.

       Added container 'lsa' to 'device-profile-parameters' grouping.

       Added leaf 'no-overwrite' to container 'lsa'
       in 'device-profile-parameters' grouping.

       Added cq-user-info to the commit queue item and made cq-username
       obsolete.

       Added leaf 'trace-id' to 'ncs-commit-params' grouping.

       Added 'session-limits' configuration to
       device-profile-parameters grouping.

       Obsoleted /devices/device/remote-node leaf.";
  }
  revision 2020-09-10 {
    description
      "Released as part of NCS-5.4.1.

       Removed min-elements for device parameter in
       /devices/commit-queue/add-lock action.";
  }
  revision 2020-06-25 {
    description
      "Released as part of NCS-5.4.

       Non-backwards-compatible changes have been introduced.

       Removed 'lsa-additional-ned-id'.

       Added action /devices/apply-template.

       Removed default value for sync/timeout-choice under
       'commit-queue-basic-options' grouping.

       Added default value for
       /devices/global-settings/commit-queue/sync/timeout-choice.
       Added default value for sync/timeout-choice parameter in
       /devices/commit-queue/add-lock action.";
  }
  revision 2020-02-20 {
    description
      "Released as part of NCS-5.3.1.

       Removed default values for connect-retries settings under
       'device-profile-parameters' grouping.

       Added default value for
       /devices/global-settings/connect-retries/attempts and
       /devices/global-settings/connect-retries/timeout.";
  }
  revision 2019-11-28 {
    description
      "Released as part of NCS-5.3.

       Added 'trace-output' to 'device-profile-parameters'.

       Added 'ned-id' parameter to /devices/device/delete-config action.

       Added 'lsa-additional-ned-id' parameter to /devices/device/migrate
       action.

       Add same-secondary-password to use the password of the NSO user as a
       secondary password.

       Changed grouping remote-user-remote-auth:
        remote-password was changed from tailf:aes-cfb-128-encrypted-string
        to tailf:aes-256-cfb-128-encrypted-string.

       Deprecated /devices/device/remote-node leaf.

       Added enum 'read-only' to
       /devices/device/netconf-notifications/subscription/failure-reason.

       Obsoleted enum 'not-master' in
       /devices/device/netconf-notifications/subscription/failure-reason.";
  }
  revision 2019-06-27 {
    description
      "Released as part of NCS-5.2.

       Added container 'commit-queue/unlock' to grouping ncs-commit-params.";
  }
  revision 2019-05-16 {
    description
      "Released as part of NCS-5.1.1.

       Updated the description for the sync-from 'verbose' parameter.";
  }
  revision 2019-04-09 {
    description
      "Released as part of NCS-5.1.

       Changed grouping wait-for-lock:
        Added new top level choice wait-for-lock-choice with choices of
        no-wait-for-lock and wait-for-lock. The
        wait-for-lock choice remains the same.

       Added 'wait-for-lock' choice under
       'device-profile-parameters'
       grouping.

       Added /devices/device/device-type/snmp/ned-id.

       Made /devices/device/device-type/netconf/ned-id mandatory and
       removed the default value.

       Made the choice for /devices/device/device-type mandatory.

       Made the container for all device-types non-presence:
         /devices/device/device-type/netconf
         /devices/device/device-type/generic
         /devices/device/device-type/cli
         /devices/device/device-type/snmp

       Changed grouping remote-user-remote-auth:
         Added choice login-credentials with two cases as:
           stored: that containes ald structure.
           callback: that introduces new mechanism to define an action
             to retrieve remote authentication credentials.
         Added leaf callback-node
         Added leaf action-name

       Added groupings authgroup-callback-input-params,
                       authgroup-callback-output-params
       to enforce structure of a callback action's input and output.

       Added enum 'config-locked' to /devices/device/state/admin-state.

       Added groupings connect-grouping-extended,
                       sync-to-grouping-extended,
                       sync-from-grouping-extended,
                       disconnect-grouping-extended,
                       check-sync-grouping-extended,
                       check-yang-modules-grouping-extended,
                       fetch-ssh-host-keys-grouping-extended,
                       disconnect-grouping-specific
       to be able to device compile the tailf-ncs module.

       Changed /devices/device/address-choice case lsa-device/lsa-remote-node
       must expression to use derived-from-or-self function.

       Added leaf /devices/global-settings/commit-queue/async and
       container /devices/global-settings/commit-queue/sync.

       Added 'ned-keep-alive' settings under 'device-profile-parameters'
       grouping.

       Added /devices/commit-queue/queue-item/services.

       Changed /devices/device/address-choice case lsa-device/lsa-remote-node
       must expression to use derived-from-or-self function.

       Added list /devices/device/device-type/lsa-additional-ned-id for
       lsa devices that have service packages compiled with other ned-ids.

       Moved /devices/device-group/rpc to /devices/device-group/ned-id/rpc.

       Added action /devices/migrate and /devices/device/migrate.

       Replaced /devices/device-module with /devices/ned-ids/ned-id.

       Updated 'add-capability' with 'ned-id' parameter, and refer to
       the /devices/ned-ids/ned-id list to find modules.

       Removed /devices/commit-queue/qitem/cq-invalid.

       Added action /devices/device/load-native-config.

       Added additional 'verbose' parameter to sync-from action.

       Removed leaf /devices/device/state/last-module-id, refer to
         /devices/device/state/last-modules-state/ncsyanglib:module-set-id
         to find the same information.";
  }
  revision 2019-03-07 {
    description
      "Released as part of NCS-4.7.3.

       Added enum 'call-home' to /devices/device/state/admin-state.

       Added enum 'call-home' to
       /devices/device/netconf-notifications/subscription/failure-reason.

       Added leaf /devices/device/local-user.";
  }
  revision 2018-06-21 {
    description
      "Released as part of NCS-4.7.

       Changed type of /devices/device-group/device-name leaf-list from
       type leafref to type string.

       Added leaf 'commit-queue/error-option' to grouping ncs-commit-params.

       Added leaf /devices/global-settings/commit-queue/error-option.

       Added leaf /devices/global-settings/commit-queue/check-integrity.

       Removed /devices/global-settings/commit-queue/error-recovery.

       Added container 'commit-queue' and leaf 'no-out-of-sync-check' to
       /devices/commit-queue/completed/queue-item/rollback/input/.

       Added /devices/device/lsa-remote-node.";
  }
  revision 2018-04-19 {
    description
      "Released as part of NCS-4.6.1.

       Added force parameter to prune and delete actions under
       /devices/commit-queue and /devices/commit-queue/queue-item.

       Renamed leaf num-affected-queue-items to num-matched-queue-items
       in /devices/commit-queue/prune action.

       Removed leaf /devices/commit-queue/queue-item/kilo-bytes-size.";
  }
  revision 2018-03-01 {
    description
      "Released as part of NCS-4.6.

       Added connect-retries settings under
       'device-profile-parameters' grouping.

       Renamed leaf connection-failure-reconnect-timer to retry-timeout
       and connection-failure-reconnect-retries to retry-attempts under
       /devices/global-settings/commit-queue.

       Added additional preserve parameter to scp-from/scp-to action.

       Added use-junos-rollback parameter to ned-settings container.

       Added an enum 'same-pass' to
       /devices/device/netconf-notifications/subscription/failure-reason.

       Changed the default value for
       /devices/global-settings/ssh-keep-alive/count to 3.

       Added enum 'completed' and enum 'failed' to commit-queue/status leaf
       in ncs-commit-result grouping.

       Added list /commit-queue/failed-device in ncs-commit-result grouping.

       Added enum 'completed' and enum 'failed' to
       /devices/commit-queue/queue-item/wait-until-completed/output/result.

       Removed leaf /devices/commit-queue/completed/queue-item/succeeded
       and /devices/commit-queue/completed/purge/input/succeeded.

       Added leaf /devices/commit-queue/completed/queue-item/status
       and /devices/commit-queue/completed/purge/input/status.";
  }
  revision 2017-09-28 {
    description
      "Released as part of NCS-4.5.

       Changed /devices/device/netconf-notifications/subscription/status from
       internal callpoint to actual cdb operational data and made status default
       to 'connecting'.

       Added /devices/commit-queue/queue-item/failed.

       Removed deprecated status on
       /devices/global-settings/commit-queue/error-recovery/mode.";
  }
  revision 2017-08-31 {
    description
      "Released as part of NCS-4.4.3.

       Made /devices/device/platform operational data persistent.

       Added serial-number to /devices/device/platform container.";
  }
  revision 2017-06-14 {
    description
      "Released as part of NCS-4.4.2.

       Added action 'wait-until-completed' to
       /devices/commit-queue/queue-item.

       Added /devices/commit-queue/completed.

       Added 'wait-for-lock' container under 'check-sync' and
       'sync-from' actions.";
  }
  revision 2017-04-27 {
    description
      "Released as part of NCS-4.4.1.

       Added 'partial-sync-from' action under /devices.";
  }
  revision 2017-03-16 {
    description
      "Released as part of NCS-4.4.

       Added /devices/device-group/rpc.

       Added 'copy-capabilities', 'find-capabilities' and 'add-capability'
       actions under /devices/device. Added 'remove' action under
       /devices/device/capability.

       Added list 'capabilities-profile' under /devices/profiles.

       Added /devices/device/no-overwrite.

       Added range to all config leafs specifying time.

       Added default values to pool-max-sessions and idle-time
       under /devices/global-settings/session-pool.

       Removed identity 'netconf' and changed default ned-id for
       netconf devices from 'netconf' to 'ned:netconf'.

       Made leafs no-overwrite and no-out-of-sync-check in
       grouping ncs-commit-params cases in a choice.

       Added /devices/device/last-changed,
       /devices/commit-queue/device-chgset, and
       /devices/commit-queue/qitem/cq-invalid.

       The type of /devices/commit-queue/qitem/cq-data leaf changed from
       type string to type binary.";
  }
  revision 2016-11-24 {
    description
      "Released as part of NCS-4.3.

       Added /devices/device/active-settings.

       Removed the three different deprecated 'sync' actions
       all/group/device.

       Added additional dry-run parameter to sync-from action.
       Added additional output formats to sync-to dry-run
       parameter.

       Added actions 'scp-to' and 'scp-from' to /devices/device.

       Added ned-id to NETCONF device
       /devices/device/device-type/netconf/ned-id.

       Added use-lsa and no-lsa commit parameters.

       Added use-lsa and no-lsa settings under
       'device-profile-parameters' grouping.";
  }
  revision 2016-11-17 {
    description
      "Released as part of NCS-4.2.2.

       Added leaf connection-failure-reconnect-retries to container
       /devices/global-settings/commit-queue";
  }
  revision 2016-05-26 {
    description
      "Released as part of NCS-4.2.

       Added /devices/device/netconf-notifications/subscription/store-in-cdb.

       Renamed input parameter from supress-positive-result to
       suppress-positive-result for the following actions:

         /devices/check-sync
         /devices/device-group/check-sync
         /devices/check-yang-modules
         /devices/device-group/check-yang-modules
         /devices/connect
         /devices/device-group/connect
         /devices/sync
         /devices/device-group/sync
         /devices/sync-from
         /devices/device-group/sync-from
         /devices/sync-to
         /devices/device-group/sync-to

       Renamed leaf-list /devices/device/module/features to feature
       Renamed leaf-list /devices/device/module/deviations to deviation

       Added container 'commit-queue' to
       device-profile-parameters grouping.

       Added container 'commit-queue' to devices.";
  }
  revision 2016-01-21 {
    description
      "Released as part of NCS-4.1.1.

       Removed default for /devices/device/ssh-keep-alive/interval.
       Added default for /devices/global-settings/ssh-keep-alive/interval.

       Removed default for /devices/device/ssh-keep-alive/count.
       Added default for /devices/global-settings/ssh-keep-alive/count.";
  }
  revision 2015-11-24 {
    description
      "Released as part of NCS-4.1.

       Added 'candidate-startup' as device transaction mode.

       Added 'session-pool' configuration to
       device-profile-parameters grouping.

       Added 'session-pool' operational data container to devices.

       Moved /devices/global-settings/out-of-sync-commit-behaviour leaf
       to device-profile-parameters grouping.";
  }
  revision 2015-10-02 {
    description
      "Released as part of NCS-4.0.2.

       Added /devices/device/ssh-keep-alive/interval.

       Added /devices/device/ssh-keep-alive/count.";
  }
  revision 2015-06-16 {
    description
      "Released as part of NCS-4.0.

       Added /devices/device/platform container for vendor specific
       operational data like operating system, version etc.

       Added /devices/global-settings/atomic.

       Added action 'set-atomic-behaviour' to /devices/commit-queue.

       Added action 'set-atomic-behaviour' to
       /devices/commit-queue/queue-item.";
  }
  revision 2015-03-19 {
    description
      "Released as part of NCS-3.4.

       Changed /devices/device/netconf-notifications/subscription/local-user
         from config:false to config:true and made it mandatory.";
  }
  revision 2014-11-19 {
    description
      "Released as part of NCS-3.3.

       Changed input and output of /devices/device/apply-template and
         /devices/device-group/apply-template. New optional input
         parameters are: 'suppress-positive-result' and
         'accept-empty-capabilities'. The output is now structured
         with separate result for each affected device.

       Added grouping commit-queue-options.

       Changed the grouping ncs-commit-params.
         Added container commit-queue which uses commit-queue-options.
         'async-commit-queue' has changed to 'commit-queue/async',
         'sync-commit-queue' has changed to 'commit-queue/sync' and
         'bypass-commit-queue' has changed to 'commit-queue/bypass'.
         Added the leaf 'commit-queue/tag'. Added the container
         'commit-queue/lock'.

       Changed the grouping ncs-commit-result.
         Added the leaf 'commit-queue/tag'.

       Changed the name of
         /devices/commit-queues to /devices/commit-queue.

       Changed names of actions in /devices/commit-queue. The action
         'clear-queue' has changed to 'clear'.
         The action 'prune-queue' has changed to 'prune'. The input
         parameter has changed from 'devices' to 'device'.

         The action 'wait-queue-empty' has changed
         to 'wait-until-empty'. The default for 'wait-queue-empty' has
         changed and is now 'infinity'.

       Added action 'add-lock' to /devices/commit-queue.

       Changes in list /devices/commit-queue/queue-item/:
         Changed data type of leaf 'id' from int64 to uint64.
         Added leaf 'tag'.
         Change name of leaf-list 'done' to 'completed'
         Added list 'remote-queue-item' for remote queue items.
         Removed action 'run'.
         Added actions 'lock' and 'unlock'.
         Added action 'prune'.

       Added ncs-commit-queue-progress-event notification.";
  }
  revision 2014-06-30 {
    description
      "Released as part of NCS-3.2.

       Added grouping ncs-commit-params.

       Added use of grouping ssh-host-keys from submodule tailf-ncs-ssh,
         creating /devices/device/ssh.

       Added /devices/device/fetch-ssh-host-keys
         and /devices/device-group/fetch-ssh-host-keys actions.

       Replaced leaf public-key in grouping remote-user-remote-auth with use
         of grouping public-key-auth from submodule tailf-ncs-ssh,
         affecting /devices/authgroups/group/default-map/public-key
         and /devices/authgroups/group/umap/public-key.

       Added use of grouping ssh-host-keys from submodule tailf-ncs-ssh,
         creating /devices/device/ssh.

       Added /devices/device/disconnect.

       Changed the /device/commit-queue/wating-for to a list, in order to
         handle remote nodes.

       Added an enum 'locked' to
         /devices/device/netconf-notifications/subscription/failure-reason.

       Changed the name of
         /devices/commit-queues/queue-item/connection-failures to
         transient-errors.";
  }
  revision 2014-05-20 {
    description
      "Released as part of NCS-3.1.1.1.

       Changed the names of some /devices/commit-queues/queue-item/status
         enumeration.";
  }
  revision 2014-04-02 {
    description
      "Released as part of NCS-3.1.

       Added /devices/global-settings/commit-retries.
       Added /devices/global-settings/ned-settings.
       Added /devices/profiles.
       Added /devices/device/device-profile.
       Added /devices/device/ned-settings.";
  }
  revision 2013-11-12 {
    description
      "Released as part of NCS-3.0.

       Added grouping check-yang-modules-grouping and its use
       in devices and device-groups.

       Added grouping check-yang-modules-result and its use
       in devices and device-groups.

       Added action check-yang-modules to device.";
  }
  revision 2013-06-18 {
    description
      "Released as part of NCS-2.3.

       Added /device/device/location and
        /device/device-group/location.

       Deprecated the 3 different sync actions all/group/device and
         replaced them with two new actions sync-to and sync-from.
         The sync-to action has an additional dry-run parameter.";
  }
  revision 2013-03-12 {
    description
      "Released as part of NCS-2.2.

       Made /devices/device/device-type mandatory.
       Added /devices/commit-queues.
       Added /devices/global-settings/out-of-sync-commit-behaviour.";
  }
  revision 2012-11-13 {
    description
      "Released as part of NCS-2.1.

       Removed /devices/device/connection.";
  }
  revision 2012-08-30 {
    description
      "Released as part of NCS-2.0.

       Added /devices/device-group/member.

       Added /devices/device/live-status-protocol.
       Added /devices/device/connect-timeout.
       Added /devices/device/read-timeout.
       Added /devices/device/write-timeout.";
  }

  typedef ncs_template_oper-state {
    type string;
  }

  typedef ncs_template_oper-state-error-tag {
    type string;
  }

  typedef ncs_template_admin-state {
    type string;
  }

  typedef ncs_template_snmp-security-level {
    type string;
    reference
      "RFC3411: An Architecture for Describing SNMP Management
                Frameworks";
  }

  typedef ncs_template_snmp-version {
    type string;
  }

  typedef ncs_template_partial-sync-from-path {
    type string;
    description
      "Path expression used to represent a special
       data node instance identifier string.

       A partial-sync-from-path value is an unrestricted
       YANG instance-identifier expression. All the same rules as
       an instance-identifier apply except if the last component
       of the path represents a YANG list then predicates for
       this list's keys are optional. It is still mandatory to specify
       predicates for keys for the intermediate lists.

       Namespace prefixes used in this path expression must match
       prefixes specified in the corresponding YANG modules.";
  }

  typedef ncs_template_commit-queue-item-event-status {
    type string;
  }

  typedef ncs_rpc_notif_oper-state {
    type enumeration {
      enum "enabled" {
        tailf:code-name "oper_enabled";
        description
          "The device is operational.";
      }
      enum "disabled" {
        tailf:code-name "oper_disabled";
        description
          "The device is not operational.";
      }
      enum "unknown" {
        tailf:code-name "oper_unknown";
        description
          "The state of the device is unknown.";
      }
    }
  }

  typedef ncs_rpc_notif_oper-state-error-tag {
    type enumeration {
      enum "noconnection" {
        description
          "Cannot connect to the configured ip and port.";
      }
      enum "locked" {
        description
          "Administratively locked.";
      }
      enum "revision-error" {
        description
          "The device has a newer revision of a model than NCS can handle.";
      }
      enum "badconfig" {
        description
          "The device is misconfigured in some way";
      }
    }
  }

  typedef ncs_rpc_notif_admin-state {
    type enumeration {
      enum "locked" {
        description
          "When a device is administratively locked, it is not possible
           to modify its configuration, and no changes are ever
           pushed to the device.";
        tailf:code-name "adm_locked";
        tailf:info
          "Device is locked for config and southbound traffic";
      }
      enum "unlocked" {
        description
          "Device is assumed to be operational.
           All changes are attempted to be sent southbound.";
        tailf:code-name "adm_unlocked";
        tailf:info
          "Device is open for config and southbound traffic";
      }
      enum "southbound-locked" {
        description
          "It is possible to configure the device, but
           no changes are sent to the device. Useful admin mode
           when pre provisioning devices. This is the default
           when a new device is created.";
        tailf:info
          "Device is locked for southbound traffic";
      }
      enum "config-locked" {
        description
          "It is possible to send live-status commands or RPCs
           but it is not possible to modify the configuration
           of the device.";
        tailf:info
          "Device is locked for config";
      }
      enum "call-home" {
        description
          "It is only possible to modify the configuration of the
           device when a TCP connection is initiated from the device
           (a call home).";
        tailf:info
          "Southbound traffic can only be initiated when the
           device calls home";
      }
    }
  }

  typedef ncs_rpc_notif_snmp-security-level {
    type enumeration {
      enum "no-auth-no-priv" {
        value 1;
      }
      enum "auth-no-priv" {
        value 2;
      }
      enum "auth-priv" {
        value 3;
      }
    }
    reference
      "RFC3411: An Architecture for Describing SNMP Management
                Frameworks";
  }

  typedef ncs_rpc_notif_snmp-version {
    type enumeration {
      enum "v1";
      enum "v2c";
      enum "v3";
    }
  }

  typedef ncs_rpc_notif_partial-sync-from-path {
    type yang:xpath1.0;
    tailf:info
      "Path to pull from the network";
    description
      "Path expression used to represent a special
       data node instance identifier string.

       A partial-sync-from-path value is an unrestricted
       YANG instance-identifier expression. All the same rules as
       an instance-identifier apply except if the last component
       of the path represents a YANG list then predicates for
       this list's keys are optional. It is still mandatory to specify
       predicates for keys for the intermediate lists.

       Namespace prefixes used in this path expression must match
       prefixes specified in the corresponding YANG modules.";
  }

  typedef ncs_rpc_notif_commit-queue-item-event-status {
    type enumeration {
      enum "waiting" {
        description
          "The queue item is waiting to run. Another item, ahead of
           this item, is preventing this item from being processed.";
        tailf:code-name "cq_event_waiting";
      }
      enum "executing" {
        description
          "The queue item is currently executing at the head of the
           commit queue.";
        tailf:code-name "cq_event_executing";
      }
      enum "locked" {
        description
          "This queue item has been locked and waits to be unlocked.";
        tailf:code-name "cq_event_locked";
      }
      enum "completed" {
        description
          "The queue item was successfully completed.";
        tailf:code-name "cq_event_completed";
      }
      enum "failed" {
        description
          "The queue item ended with a failing status.";
        tailf:code-name "cq_event_failed";
      }
      enum "deleted" {
        description
          "The queue item was deleted from the queue.";
        tailf:code-name "cq_event_deleted";
      }
    }
  }

  typedef live_ncs_oper-state {
    type enumeration {
      enum "enabled" {
        tailf:code-name "oper_enabled";
        description
          "The device is operational.";
      }
      enum "disabled" {
        tailf:code-name "oper_disabled";
        description
          "The device is not operational.";
      }
      enum "unknown" {
        tailf:code-name "oper_unknown";
        description
          "The state of the device is unknown.";
      }
    }
  }

  typedef live_ncs_oper-state-error-tag {
    type enumeration {
      enum "noconnection" {
        description
          "Cannot connect to the configured ip and port.";
      }
      enum "locked" {
        description
          "Administratively locked.";
      }
      enum "revision-error" {
        description
          "The device has a newer revision of a model than NCS can handle.";
      }
      enum "badconfig" {
        description
          "The device is misconfigured in some way";
      }
    }
  }

  typedef live_ncs_admin-state {
    type enumeration {
      enum "locked" {
        description
          "When a device is administratively locked, it is not possible
           to modify its configuration, and no changes are ever
           pushed to the device.";
        tailf:code-name "adm_locked";
        tailf:info
          "Device is locked for config and southbound traffic";
      }
      enum "unlocked" {
        description
          "Device is assumed to be operational.
           All changes are attempted to be sent southbound.";
        tailf:code-name "adm_unlocked";
        tailf:info
          "Device is open for config and southbound traffic";
      }
      enum "southbound-locked" {
        description
          "It is possible to configure the device, but
           no changes are sent to the device. Useful admin mode
           when pre provisioning devices. This is the default
           when a new device is created.";
        tailf:info
          "Device is locked for southbound traffic";
      }
      enum "config-locked" {
        description
          "It is possible to send live-status commands or RPCs
           but it is not possible to modify the configuration
           of the device.";
        tailf:info
          "Device is locked for config";
      }
      enum "call-home" {
        description
          "It is only possible to modify the configuration of the
           device when a TCP connection is initiated from the device
           (a call home).";
        tailf:info
          "Southbound traffic can only be initiated when the
           device calls home";
      }
    }
  }

  typedef live_ncs_snmp-security-level {
    type enumeration {
      enum "no-auth-no-priv" {
        value 1;
      }
      enum "auth-no-priv" {
        value 2;
      }
      enum "auth-priv" {
        value 3;
      }
    }
    reference
      "RFC3411: An Architecture for Describing SNMP Management
                Frameworks";
  }

  typedef live_ncs_snmp-version {
    type enumeration {
      enum "v1";
      enum "v2c";
      enum "v3";
    }
  }

  typedef live_ncs_partial-sync-from-path {
    type yang:xpath1.0;
    tailf:info
      "Path to pull from the network";
    description
      "Path expression used to represent a special
       data node instance identifier string.

       A partial-sync-from-path value is an unrestricted
       YANG instance-identifier expression. All the same rules as
       an instance-identifier apply except if the last component
       of the path represents a YANG list then predicates for
       this list's keys are optional. It is still mandatory to specify
       predicates for keys for the intermediate lists.

       Namespace prefixes used in this path expression must match
       prefixes specified in the corresponding YANG modules.";
  }

  typedef live_ncs_commit-queue-item-event-status {
    type enumeration {
      enum "waiting" {
        description
          "The queue item is waiting to run. Another item, ahead of
           this item, is preventing this item from being processed.";
        tailf:code-name "cq_event_waiting";
      }
      enum "executing" {
        description
          "The queue item is currently executing at the head of the
           commit queue.";
        tailf:code-name "cq_event_executing";
      }
      enum "locked" {
        description
          "This queue item has been locked and waits to be unlocked.";
        tailf:code-name "cq_event_locked";
      }
      enum "completed" {
        description
          "The queue item was successfully completed.";
        tailf:code-name "cq_event_completed";
      }
      enum "failed" {
        description
          "The queue item ended with a failing status.";
        tailf:code-name "cq_event_failed";
      }
      enum "deleted" {
        description
          "The queue item was deleted from the queue.";
        tailf:code-name "cq_event_deleted";
      }
    }
  }

  typedef oper-state {
    type enumeration {
      enum "enabled" {
        tailf:code-name "oper_enabled";
        description
          "The device is operational.";
      }
      enum "disabled" {
        tailf:code-name "oper_disabled";
        description
          "The device is not operational.";
      }
      enum "unknown" {
        tailf:code-name "oper_unknown";
        description
          "The state of the device is unknown.";
      }
    }
  }

  typedef oper-state-error-tag {
    type enumeration {
      enum "noconnection" {
        description
          "Cannot connect to the configured ip and port.";
      }
      enum "locked" {
        description
          "Administratively locked.";
      }
      enum "revision-error" {
        description
          "The device has a newer revision of a model than NCS can handle.";
      }
      enum "badconfig" {
        description
          "The device is misconfigured in some way";
      }
    }
  }

  typedef admin-state {
    type enumeration {
      enum "locked" {
        description
          "When a device is administratively locked, it is not possible
           to modify its configuration, and no changes are ever
           pushed to the device.";
        tailf:code-name "adm_locked";
        tailf:info
          "Device is locked for config and southbound traffic";
      }
      enum "unlocked" {
        description
          "Device is assumed to be operational.
           All changes are attempted to be sent southbound.";
        tailf:code-name "adm_unlocked";
        tailf:info
          "Device is open for config and southbound traffic";
      }
      enum "southbound-locked" {
        description
          "It is possible to configure the device, but
           no changes are sent to the device. Useful admin mode
           when pre provisioning devices. This is the default
           when a new device is created.";
        tailf:info
          "Device is locked for southbound traffic";
      }
      enum "config-locked" {
        description
          "It is possible to send live-status commands or RPCs
           but it is not possible to modify the configuration
           of the device.";
        tailf:info
          "Device is locked for config";
      }
      enum "call-home" {
        description
          "It is only possible to modify the configuration of the
           device when a TCP connection is initiated from the device
           (a call home).";
        tailf:info
          "Southbound traffic can only be initiated when the
           device calls home";
      }
    }
  }

  typedef snmp-security-level {
    type enumeration {
      enum "no-auth-no-priv" {
        value 1;
      }
      enum "auth-no-priv" {
        value 2;
      }
      enum "auth-priv" {
        value 3;
      }
    }
    reference
      "RFC3411: An Architecture for Describing SNMP Management
                Frameworks";
  }

  typedef snmp-version {
    type enumeration {
      enum "v1";
      enum "v2c";
      enum "v3";
    }
  }

  typedef partial-sync-from-path {
    type yang:xpath1.0;
    tailf:info
      "Path to pull from the network";
    description
      "Path expression used to represent a special
       data node instance identifier string.

       A partial-sync-from-path value is an unrestricted
       YANG instance-identifier expression. All the same rules as
       an instance-identifier apply except if the last component
       of the path represents a YANG list then predicates for
       this list's keys are optional. It is still mandatory to specify
       predicates for keys for the intermediate lists.

       Namespace prefixes used in this path expression must match
       prefixes specified in the corresponding YANG modules.";
  }

  typedef commit-queue-item-event-status {
    type enumeration {
      enum "waiting" {
        description
          "The queue item is waiting to run. Another item, ahead of
           this item, is preventing this item from being processed.";
        tailf:code-name "cq_event_waiting";
      }
      enum "executing" {
        description
          "The queue item is currently executing at the head of the
           commit queue.";
        tailf:code-name "cq_event_executing";
      }
      enum "locked" {
        description
          "This queue item has been locked and waits to be unlocked.";
        tailf:code-name "cq_event_locked";
      }
      enum "completed" {
        description
          "The queue item was successfully completed.";
        tailf:code-name "cq_event_completed";
      }
      enum "failed" {
        description
          "The queue item ended with a failing status.";
        tailf:code-name "cq_event_failed";
      }
      enum "deleted" {
        description
          "The queue item was deleted from the queue.";
        tailf:code-name "cq_event_deleted";
      }
    }
  }

  grouping ncs_template_oper-state {
    // NCS drop config false leaf 'oper-state'
    // NCS drop config false leaf 'oper-state-error-tag'
    // NCS drop config false leaf 'oper-state-hash'
  }

  grouping ncs_template_ncs-commit-params {
    leaf no-revision-drop {
      type empty;
      description
        "This flags means that NCS will not run its data model revision
         algorithm, which requires all participating managed devices
         to have all parts of the data models for all data contained
         in this transaction. Thus, this flag forces NCS to never
         silently drop any data set operations towards a device.";
    }
    leaf no-networking {
      type empty;
      description
        "Do not send any data to the devices. Even if the transaction
         manipulates data below /devices/device/config, nothing will
         be sent to the managed devices. This is a way to manipulate
         CDB in NCS without generating any southbound traffic.";
    }
    choice choice-sync-check {
      case no-overwrite {
        leaf no-overwrite {
          type empty;
          description
            "This flags means that NCS will check that the data that
             should be modified has not changed on the device compared
             to NCS's view of the data. This is a fine-granular sync check;
             NCS verifies that NCS and the device is in sync regarding
             the data that will be modified. If they are not in sync,
             the transaction is aborted.";
        }
      }
      case no-out-of-sync-check {
        leaf no-out-of-sync-check {
          type empty;
          description
            "Continue with the transaction even if NCS detects that a device's
             configuration is out of sync. The device's sync state is assumed
             to be unknown after such commit and the stored transaction id
             value is cleared";
        }
      }
    }
    container commit-queue {
      presence "Commit through the commit queue";
      leaf tag {
        type string;
        description
          "User defined opaque tag.
           The tag is present in all notifications and events
           sent referencing the specific queue item.";
      }
      uses ncs_template_commit-queue-options;
      leaf error-option {
        type string;
        description
          "The error option to use. Depending on the selected error option
           NCS will store the reverse of the original transaction intent
           to be able to undo the transaction changes and get back to the
           previous state. This data is stored in the
           /devices/commit-queue/completed tree from where it can
           be viewed and invoked with the rollback action. When invoked
           the data will be removed.";
      }
      container unlock {
        presence "Unlock queue item";
        choice choice-unlock-id {
          leaf id {
            type string;
            description
              "Unique id identifying a queue item. If locked, this
               item will be unlocked in the commit phase.";
          }
          leaf tag {
            type string;
            description
              "User defined opaque tag. If locked, this
               item will be unlocked in the commit phase.";
          }
        }
      }
    }
    choice choice-lsa {
      case use-lsa {
        leaf use-lsa {
          type empty;
          description
            "Force handling of the LSA nodes as such. This flag tells
             NCS to propagate applicable commit flags and actions
             to the LSA nodes without applying them on the upper
             NCS node itself. The commit flags affected are
             'dry-run', 'no-networking', 'no-out-of-sync-check',
             'no-overwrite' and 'no-revision-drop'.";
        }
      }
      case no-lsa {
        leaf no-lsa {
          type empty;
          description
            "Do not handle any of the LSA nodes as such. These nodes
             will be handled as any other device.";
        }
      }
    }
    leaf-list wait-device {
      // NCS patched for predictable order
      ordered-by user;
      type string;
      description
        "Take device locks before entering transaction critical section. The
         device locks here should be understood to be internal locks in NSO, so
         the device itself is not locked. If the device locks are held by
         someone else, wait for them to become available. The timeout applied
         in this case is the same as used to wait for the transaction lock.

         Normally the device locks are taken automatically inside the
         transaction critical section, because in a typical service transaction
         we do not know the affected devices before the service code is
         executed. When taking the device locks inside transaction critical
         section, it is not possible to wait for lock, so in case the lock is
         not available the transaction is aborted.

         This parameter allows to specify the devices expected to be
         affected by the transaction so they can be pre-locked before entering
         the transaction critical section. This allows to wait for device
         locks. This is useful in cases when other actions holding the device
         lock may be on-going at the same time and the desired behaviour is
         to wait for these actions to complete rather than abort the
         transaction. Examples of such actions are: sync-from,
         partial-sync-from, check-sync, sync-to, compare-config.

         Similarly, when used with a commit through commit queue, this
         parameter allows to wait for queue items with block-others flag. For
         example, a queue item with block-others flag is created by actions
         such as sync-from and partial-sync-from.

         If the transaction involves other devices than specified by this
         parameter, then the lock still needs to be taken on these additional
         devices, which is done inside transaction critical section and may
         fail if the device lock for the additional devices is already held
         by someone else.";
    }
    leaf trace-id {
      type string;
      description
        "Use the provided trace id as part of the log messages emitted while
         processing.

         If no trace id is given, NSO is going to generate and assign a trace
         id to the processing.";
    }
  }

  grouping ncs_template_ncs-hidden-commit-params {
    // NCS expand uses statement
    leaf no-revision-drop {
      type empty;
      description
        "This flags means that NCS will not run its data model revision
         algorithm, which requires all participating managed devices
         to have all parts of the data models for all data contained
         in this transaction. Thus, this flag forces NCS to never
         silently drop any data set operations towards a device.";
      tailf:hidden "programmatic-interface";
    }
    leaf no-networking {
      type empty;
      description
        "Do not send any data to the devices. Even if the transaction
         manipulates data below /devices/device/config, nothing will
         be sent to the managed devices. This is a way to manipulate
         CDB in NCS without generating any southbound traffic.";
      tailf:hidden "programmatic-interface";
    }
    choice choice-sync-check {
      case no-overwrite {
        leaf no-overwrite {
          type empty;
          description
            "This flags means that NCS will check that the data that
             should be modified has not changed on the device compared
             to NCS's view of the data. This is a fine-granular sync check;
             NCS verifies that NCS and the device is in sync regarding
             the data that will be modified. If they are not in sync,
             the transaction is aborted.";
          tailf:hidden "programmatic-interface";
        }
      }
      case no-out-of-sync-check {
        leaf no-out-of-sync-check {
          type empty;
          description
            "Continue with the transaction even if NCS detects that a device's
             configuration is out of sync. The device's sync state is assumed
             to be unknown after such commit and the stored transaction id
             value is cleared";
          tailf:hidden "programmatic-interface";
        }
      }
    }
    container commit-queue {
      presence "Commit through the commit queue";
      leaf tag {
        type string;
        description
          "User defined opaque tag.
           The tag is present in all notifications and events
           sent referencing the specific queue item.";
      }
      uses ncs_template_commit-queue-options;
      leaf error-option {
        type string;
        description
          "The error option to use. Depending on the selected error option
           NCS will store the reverse of the original transaction intent
           to be able to undo the transaction changes and get back to the
           previous state. This data is stored in the
           /devices/commit-queue/completed tree from where it can
           be viewed and invoked with the rollback action. When invoked
           the data will be removed.";
      }
      container unlock {
        presence "Unlock queue item";
        choice choice-unlock-id {
          leaf id {
            type string;
            description
              "Unique id identifying a queue item. If locked, this
               item will be unlocked in the commit phase.";
          }
          leaf tag {
            type string;
            description
              "User defined opaque tag. If locked, this
               item will be unlocked in the commit phase.";
          }
        }
      }
      tailf:hidden "programmatic-interface";
    }
    choice choice-lsa {
      case use-lsa {
        leaf use-lsa {
          type empty;
          description
            "Force handling of the LSA nodes as such. This flag tells
             NCS to propagate applicable commit flags and actions
             to the LSA nodes without applying them on the upper
             NCS node itself. The commit flags affected are
             'dry-run', 'no-networking', 'no-out-of-sync-check',
             'no-overwrite' and 'no-revision-drop'.";
          tailf:hidden "programmatic-interface";
        }
      }
      case no-lsa {
        leaf no-lsa {
          type empty;
          description
            "Do not handle any of the LSA nodes as such. These nodes
             will be handled as any other device.";
          tailf:hidden "programmatic-interface";
        }
      }
    }
    leaf-list wait-device {
      // NCS patched for predictable order
      ordered-by user;
      type string;
      description
        "Take device locks before entering transaction critical section. The
         device locks here should be understood to be internal locks in NSO, so
         the device itself is not locked. If the device locks are held by
         someone else, wait for them to become available. The timeout applied
         in this case is the same as used to wait for the transaction lock.

         Normally the device locks are taken automatically inside the
         transaction critical section, because in a typical service transaction
         we do not know the affected devices before the service code is
         executed. When taking the device locks inside transaction critical
         section, it is not possible to wait for lock, so in case the lock is
         not available the transaction is aborted.

         This parameter allows to specify the devices expected to be
         affected by the transaction so they can be pre-locked before entering
         the transaction critical section. This allows to wait for device
         locks. This is useful in cases when other actions holding the device
         lock may be on-going at the same time and the desired behaviour is
         to wait for these actions to complete rather than abort the
         transaction. Examples of such actions are: sync-from,
         partial-sync-from, check-sync, sync-to, compare-config.

         Similarly, when used with a commit through commit queue, this
         parameter allows to wait for queue items with block-others flag. For
         example, a queue item with block-others flag is created by actions
         such as sync-from and partial-sync-from.

         If the transaction involves other devices than specified by this
         parameter, then the lock still needs to be taken on these additional
         devices, which is done inside transaction critical section and may
         fail if the device lock for the additional devices is already held
         by someone else.";
      tailf:hidden "programmatic-interface";
    }
    leaf trace-id {
      type string;
      description
        "Use the provided trace id as part of the log messages emitted while
         processing.

         If no trace id is given, NSO is going to generate and assign a trace
         id to the processing.";
      tailf:hidden "programmatic-interface";
    }
  }

  grouping ncs_template_ncs-commit-result {
    container commit-queue {
      leaf id {
        type string;
        description
          "This leaf is returned if 'commit-queue/async' or
           'commit-queue/sync' was given in the input parameters.";
      }
      leaf status {
        type string;
      }
      list failed-device {
        // NCS patched for predictable order
        ordered-by user;
        key "name";
        leaf name {
          type string;
        }
        leaf reason {
          type string;
          description
            "The error for this failing device.";
        }
        description
          "The devices which failed for this queue item.";
      }
    }
  }

  grouping ncs_template_dry-run-xml {
    container result-xml {
      description
        "Display all changes in the whole data model. The
         changes will be displayed in NETCONF XML edit-config format,
         i.e., the edit-config that would be applied locally (at NCS)
         to get a config that is equal to that of the managed device.";
      container local-node {
        anyxml data;
      }
      list lsa-node {
        // NCS patched for predictable order
        ordered-by user;
        leaf name {
          type string;
        }
        anyxml data;
      }
    }
  }

  grouping ncs_template_dry-run-cli {
    container cli {
      description
        "Display all changes in the whole data model. The
         changes will be displayed in CLI curly bracket format.";
      container local-node {
        leaf data {
          type string;
        }
      }
      list lsa-node {
        // NCS patched for predictable order
        ordered-by user;
        leaf name {
          type string;
        }
        leaf data {
          type string;
        }
      }
    }
  }

  grouping ncs_template_dry-run-native {
    container native {
      description
        "Display only changes under /devices/device/config. The
         changes will be displayed in native device format.";
      list device {
        // NCS patched for predictable order
        ordered-by user;
        key "name";
        leaf name {
          type string;
        }
        leaf data {
          type string;
        }
      }
    }
  }

  grouping ncs_template_commit-queue-item-status {
    leaf status {
      type string;
    }
  }

  grouping ncs_template_connect-grouping;

  grouping ncs_template_connect-grouping-extended;

  grouping ncs_template_connect-result {
    description
      "Common result data from a 'connect' action.";
    leaf result {
      type string;
    }
    leaf info {
      type string;
      description
        "If present, contains additional information about the result.";
    }
  }

  grouping ncs_template_check-sync-grouping;

  grouping ncs_template_check-sync-grouping-extended;

  grouping ncs_template_check-sync-result {
    description
      "Common result data from a 'check-sync' action.";
    leaf result {
      type string;
    }
    leaf info {
      type string;
      description
        "If present, contains additional information about the result.";
    }
  }

  grouping ncs_template_sync-to-grouping;

  grouping ncs_template_sync-to-grouping-extended;

  grouping ncs_template_sync-to-result {
    description
      "Common result data from a 'sync-to' action.";
    choice outformat {
      leaf result {
        type string;
      }
      anyxml result-xml;
      leaf cli {
        type string;
      }
      leaf native {
        type string;
      }
    }
    leaf info {
      type string;
      description
        "If present, contains additional information about the result.";
    }
  }

  grouping ncs_template_sync-from-grouping;

  grouping ncs_template_sync-from-grouping-extended;

  grouping ncs_template_sync-from-output {
    list sync-result {
      // NCS patched for predictable order
      ordered-by user;
      key "device";
      leaf device {
        type string;
      }
      uses ncs_template_sync-result;
    }
  }

  grouping ncs_template_sync-result {
    description
      "Common result data from a 'sync' action.";
    choice outformat {
      leaf result {
        type string;
      }
      anyxml result-xml;
      leaf cli {
        type string;
      }
    }
    leaf info {
      type string;
      description
        "If present, contains additional information about the result.";
    }
  }

  grouping ncs_template_wait-for-lock {
    choice wait-for-lock-choice {
      description
        "Wait for device lock setting.";
      leaf no-wait-for-lock {
        type empty;
        description
          "The action can't be performed while the device is being
           committed to (or waiting in the commit queue). This is to avoid
           getting inconsistent data when reading the configuration.
           This specifies that the action should not wait for device lock,
           instead, it should immediately fail if the device is being locked.";
      }
      container wait-for-lock {
        presence "Wait for device lock.";
        description
          "The action can't be performed while the device is being
           committed to (or waiting in the commit queue). This is to avoid
           getting inconsistent data when reading the configuration.
           This specifies a timeout to wait for a device lock to be placed
           in the commit queue. The lock will be automatically released once
           the action has been executed.";
        choice timeout-choice {
          // NCS drop default statement
          leaf timeout {
            type string;
            units "seconds";
            description
              "Specifies a maximum number of seconds to wait for the
               device to be locked.";
          }
          leaf infinity {
            description
              "Wait infinitely for the lock, this is the default.";
            type empty;
          }
        }
      }
    }
  }

  grouping ncs_template_disconnect-grouping;

  grouping ncs_template_disconnect-grouping-specific;

  grouping ncs_template_disconnect-grouping-extended;

  grouping ncs_template_check-yang-modules-grouping;

  grouping ncs_template_check-yang-modules-grouping-extended;

  grouping ncs_template_check-yang-modules-result {
    description
      "Common result data from a 'check-yang-modules' action.";
    choice compat-res {
      case silent {
        description
          "Present in non-verbose mode.";
        leaf compatible {
          type string;
          description
            "Reporting if a device is revision compatible true/false
             in non-verbose mode.";
        }
      }
      case verbose {
        list module {
          // NCS patched for predictable order
          ordered-by user;
          description
            "In verbose mode, this is the list of the supported modules for
             a device which are reported as capabilities.";
          key "name";
          leaf name {
            type string;
            description
              "YANG module";
          }
          leaf status {
            description
              "Compatibility status for the YANG module.";
            type string;
          }
          leaf device-revision {
            type string;
            description
              "Live device reported revision for the module";
          }
          leaf ncs-revision {
            type string;
            description
              "NCS loaded YANG module revision";
          }
        }
      }
    }
  }

  grouping ncs_template_fetch-ssh-host-keys-grouping;

  grouping ncs_template_fetch-ssh-host-keys-grouping-extended;

  grouping ncs_template_apply-template-grouping;

  grouping ncs_template_apply-template-grouping-extended;

  grouping ncs_template_migrate-grouping;

  grouping ncs_template_migrate-grouping-extended;

  grouping ncs_template_migrate-result {
    list modified-path {
      // NCS patched for predictable order
      ordered-by user;
      leaf path {
        description
          "The path below /devices/device/config that has been modified.";
        type string;
      }
      leaf info {
        description
          "Description of what has changed on the path.";
        type string;
      }
    }
    leaf-list affected-services {
      // NCS patched for predictable order
      ordered-by user;
      description
        "The service instances/points that are affected by the data
         model changes on the migrated device.";
      type string;
    }
  }

  grouping ncs_template_location {
    container location {
      description
        "Physical location of devices in the group";
      leaf name {
        type string;
        description
          "An arbitrary name of the location.";
      }
      leaf latitude {
        type string;
        units "decimal degrees";
        description
          "The latitude according to WGS-84, in decimal degrees.";
      }
      leaf longitude {
        type string;
        units "decimal degrees";
        description
          "The longitude according to WGS-84, in decimal degrees.";
      }
      leaf altitude {
        type string;
        units "meters";
        description
          "The altitude according to WGS-84, in meters.";
      }
    }
  }

  grouping ncs_template_queue-item-status {
    leaf status {
      type string;
      description
        "What is NCS currently doing with this queue item.
         If the status is idle, it means that the item is waiting
         for another queue item where one of the devices is
         not running, i.e., it's not possible to connect to that
         device.";
    }
  }

  grouping ncs_template_commit-queue-basic-options {
    choice operation-mode {
      leaf async {
        type empty;
        description
          "Commit the transaction data asynchronously to the commit queue.
           This flag is useful when some device is non-operational or
           has data waiting in the commit queue.

           The operation returns successfully if the transaction data has
           been successfully placed in the queue. The leaf
           'commit-queue/id' is set as the queue identifier and the
           leaf 'commit-queue/status' is set to 'async' in the result.";
      }
      container sync {
        presence "Commit through the commit queue and wait for completion";
        description
          "Commit the transaction data synchronously to the commit queue.

           The operation does not return until the transaction data has
           been sent to all devices, or a timeout occurs. The leaf
           'commit-queue/id' is set as the queue identifier and the
           leaf 'commit-queue/status' is set to 'completed', 'failed',
           'deleted' or 'timeout' dependent of the outcome.

           If no device is involved in the transaction, the operation
           returns directly.";
        choice timeout-choice {
          leaf timeout {
            type string;
            units "seconds";
            description
              "Specifies a maximum number of seconds to wait for the
               transaction to be committed. If the timer expires, the
               transaction is kept in the commit-queue, and the operation
               returns successfully. The leaf 'commit-queue/status'
               is set to 'timeout', and the leaf 'commit-queue/id' is
               set to the queue identifier in the result.";
          }
          leaf infinity {
            description
              "Wait infinitely for the transaction to be committed.";
            type empty;
          }
        }
      }
      // NCS drop default statement
    }
  }

  grouping ncs_template_commit-queue-options {
    uses ncs_template_commit-queue-basic-options {
      augment "operation-mode" {
        leaf bypass {
          type empty;
          description
            "This flag means that if
             /devices/commit-queue/enabled-by-default is 'true' the
             data in this transaction will bypass the commit queue.
             The data will be written directly to the devices.";
        }
      }
    }
    leaf block-others {
      type empty;
      description
        "The resulting queue item will block subsequent queue items,
         which use any of the devices in this queue item, from
         being queued.";
    }
    leaf lock {
      type empty;
      description
        "Place a lock on the resulting queue item. The queue
         item will not be processed until it has been unlocked,
         see the actions 'unlock' and 'lock' in
         /devices/commit-queue/queue-item'.

         No following queue items, using the same devices, will be
         allowed to execute as long as the lock is in place.";
    }
    leaf atomic {
      type string;
      description
        "Sets the atomic behaviour of the resulting queue item.
         If this is set to false, the devices contained in the
         resulting queue item can start executing if the same devices
         in other non-atomic queue items ahead of it in the queue are
         completed. If set to true, the atomic integrity of the
         queue item is preserved.";
    }
  }

  grouping ncs_template_authgroup-callback-input-params {
    description
      "When /devices/authgroups/group/[name]/umap/[local-user]/callback-node
       and /devices/authgroups/group/[name]/umap/[local-user]/action-name
       is set, the action that is defined by action-name in the specified
       callback-node must use this grouping as input parameters.";
    leaf local-user {
      type string;
    }
    leaf authgroup {
      type string;
    }
    leaf device {
      type string;
    }
  }

  grouping ncs_template_authgroup-callback-output-params {
    description
      "When /devices/authgroups/group/[name]/umap/[local-user]/callback-node
       and /devices/authgroups/group/[name]/umap/[local-user]/action-name
       is set, the action that is defined by action-name in the specified
       callback-node must use this grouping as output parameters.";
    leaf remote-user {
      type string;
    }
    leaf remote-password {
      type string;
    }
    leaf remote-secondary-password {
      type string;
    }
  }

  grouping ncs_template_notifications {
    list subscription {
      // NCS patched for predictable order
      ordered-by user;
      key "name";
      description
        "A list of our notification subscriptions for this managed device.";
      leaf name {
        type string;
        description
          "Each subscription must have a unique name.";
      }
      leaf stream {
        type string;
        // NCS drop mandatory statement
        description
          "The name of the notification stream this subscription
           refers to.";
      }
      choice filter {
        description
          "Optional element, if not set, no filters are applied.";
        case xpath {
          leaf xpath {
            type string;
          }
        }
        case subtree {
          leaf subtree {
            type string;
          }
        }
      }
      leaf local-user {
        type string;
        // NCS drop mandatory statement
        description
          "The local user is used when setting up a device
           connection.";
      }
      leaf store-in-cdb {
        type string;
        // NCS drop default statement
        description
          "Indicate whether notifications should be stored as
           operational data in CDB.

           When notifications are generated at a high rate,
           storage consumes lots of resources. In cases like that,
           consider using the device-notification event stream
           instead.";
      }
      leaf utilize-replay {
        type string;
        // NCS drop default statement
        description
          "If the device supports replay, should NCS attempt to use that
           when connecting to the device.";
      }
      leaf reconnect-interval {
        type string;
        units "seconds";
        // NCS drop default statement
        description
          "If the device is non operational, with which
           interval (in seconds) shall NCS attempt to re-establish
           the subscription.";
      }
      // NCS drop config false leaf status
      // NCS drop config false leaf 'failure-reason'
      // NCS drop config false leaf 'error-info'
    }
    // NCS drop config false list stream
    // NCS drop config false list 'notification-name'
    container received-notifications {
      leaf max-size {
        type string;
        // NCS drop default statement
        description
          "Max size of the list of received notifications.
           When the maximum size is reached, the oldest
           received notification is purged.";
      }
      // NCS drop config false leaf 'clear-time'
      // NCS drop config false list notification
    }
  }

  grouping ncs_rpc_notif_oper-state {
    leaf oper-state {
      type ncs_rpc_notif_oper-state;
      default "unknown";
      config false;
      tailf:info
        "The actual operational state of the device.";
      // NCS drop tailf:cdb-oper
    }
    leaf oper-state-error-tag {
      type ncs_rpc_notif_oper-state-error-tag;
      config false;
      tailf:info
        "Additional error information if the device is disabled.";
      // NCS drop tailf:cdb-oper
    }
    // NCS drop fully hidden leaf 'oper-state-hash'
  }

  grouping ncs_rpc_notif_ncs-commit-params {
    leaf no-revision-drop {
      type empty;
      description
        "This flags means that NCS will not run its data model revision
         algorithm, which requires all participating managed devices
         to have all parts of the data models for all data contained
         in this transaction. Thus, this flag forces NCS to never
         silently drop any data set operations towards a device.";
    }
    leaf no-networking {
      type empty;
      description
        "Do not send any data to the devices. Even if the transaction
         manipulates data below /devices/device/config, nothing will
         be sent to the managed devices. This is a way to manipulate
         CDB in NCS without generating any southbound traffic.";
    }
    choice choice-sync-check {
      case no-overwrite {
        leaf no-overwrite {
          type empty;
          description
            "This flags means that NCS will check that the data that
             should be modified has not changed on the device compared
             to NCS's view of the data. This is a fine-granular sync check;
             NCS verifies that NCS and the device is in sync regarding
             the data that will be modified. If they are not in sync,
             the transaction is aborted.";
        }
      }
      case no-out-of-sync-check {
        leaf no-out-of-sync-check {
          type empty;
          description
            "Continue with the transaction even if NCS detects that a device's
             configuration is out of sync. The device's sync state is assumed
             to be unknown after such commit and the stored transaction id
             value is cleared";
        }
      }
    }
    container commit-queue {
      presence "Commit through the commit queue";
      leaf tag {
        type string;
        description
          "User defined opaque tag.
           The tag is present in all notifications and events
           sent referencing the specific queue item.";
      }
      uses ncs_rpc_notif_commit-queue-options;
      leaf error-option {
        type enumeration {
          enum "continue-on-error" {
            description
              "The commit queue will continue on errors. No rollback data
               will be created. This is the preferred choice when
               re-deploying a service as a re-deploy doesn't have a
               transaction intent.";
          }
          enum "rollback-on-error" {
            description
              "The commit queue items will roll back on errors. The commit
               queue will place a lock on the failed queue item, thus
               blocking other queue items with overlapping devices to be
               executed. The rollback action will then automatically be
               invoked when the failed queue item has finished its execution.
               The lock is removed as part of the rollback.";
          }
          enum "stop-on-error" {
            description
              "The commit queue will place a lock on the failed queue item,
               thus blocking other queue items with overlapping devices to
               be executed. The lock must then either manually be released
               or the rollback action under
               /devices/commit-queue/completed be invoked.";
          }
        }
        description
          "The error option to use. Depending on the selected error option
           NCS will store the reverse of the original transaction intent
           to be able to undo the transaction changes and get back to the
           previous state. This data is stored in the
           /devices/commit-queue/completed tree from where it can
           be viewed and invoked with the rollback action. When invoked
           the data will be removed.";
      }
      container unlock {
        presence "Unlock queue item";
        choice choice-unlock-id {
          leaf id {
            type uint64;
            description
              "Unique id identifying a queue item. If locked, this
               item will be unlocked in the commit phase.";
          }
          leaf tag {
            type string;
            description
              "User defined opaque tag. If locked, this
               item will be unlocked in the commit phase.";
          }
        }
      }
    }
    choice choice-lsa {
      case use-lsa {
        leaf use-lsa {
          type empty;
          description
            "Force handling of the LSA nodes as such. This flag tells
             NCS to propagate applicable commit flags and actions
             to the LSA nodes without applying them on the upper
             NCS node itself. The commit flags affected are
             'dry-run', 'no-networking', 'no-out-of-sync-check',
             'no-overwrite' and 'no-revision-drop'.";
        }
      }
      case no-lsa {
        leaf no-lsa {
          type empty;
          description
            "Do not handle any of the LSA nodes as such. These nodes
             will be handled as any other device.";
        }
      }
    }
    leaf-list wait-device {
      type string;
      description
        "Take device locks before entering transaction critical section. The
         device locks here should be understood to be internal locks in NSO, so
         the device itself is not locked. If the device locks are held by
         someone else, wait for them to become available. The timeout applied
         in this case is the same as used to wait for the transaction lock.

         Normally the device locks are taken automatically inside the
         transaction critical section, because in a typical service transaction
         we do not know the affected devices before the service code is
         executed. When taking the device locks inside transaction critical
         section, it is not possible to wait for lock, so in case the lock is
         not available the transaction is aborted.

         This parameter allows to specify the devices expected to be
         affected by the transaction so they can be pre-locked before entering
         the transaction critical section. This allows to wait for device
         locks. This is useful in cases when other actions holding the device
         lock may be on-going at the same time and the desired behaviour is
         to wait for these actions to complete rather than abort the
         transaction. Examples of such actions are: sync-from,
         partial-sync-from, check-sync, sync-to, compare-config.

         Similarly, when used with a commit through commit queue, this
         parameter allows to wait for queue items with block-others flag. For
         example, a queue item with block-others flag is created by actions
         such as sync-from and partial-sync-from.

         If the transaction involves other devices than specified by this
         parameter, then the lock still needs to be taken on these additional
         devices, which is done inside transaction critical section and may
         fail if the device lock for the additional devices is already held
         by someone else.";
    }
    leaf trace-id {
      type string {
        length "1..64";
      }
      description
        "Use the provided trace id as part of the log messages emitted while
         processing.

         If no trace id is given, NSO is going to generate and assign a trace
         id to the processing.";
    }
  }

  grouping ncs_rpc_notif_ncs-hidden-commit-params {
    // NCS expand uses statement
    leaf no-revision-drop {
      type empty;
      description
        "This flags means that NCS will not run its data model revision
         algorithm, which requires all participating managed devices
         to have all parts of the data models for all data contained
         in this transaction. Thus, this flag forces NCS to never
         silently drop any data set operations towards a device.";
      tailf:hidden "programmatic-interface";
    }
    leaf no-networking {
      type empty;
      description
        "Do not send any data to the devices. Even if the transaction
         manipulates data below /devices/device/config, nothing will
         be sent to the managed devices. This is a way to manipulate
         CDB in NCS without generating any southbound traffic.";
      tailf:hidden "programmatic-interface";
    }
    choice choice-sync-check {
      case no-overwrite {
        leaf no-overwrite {
          type empty;
          description
            "This flags means that NCS will check that the data that
             should be modified has not changed on the device compared
             to NCS's view of the data. This is a fine-granular sync check;
             NCS verifies that NCS and the device is in sync regarding
             the data that will be modified. If they are not in sync,
             the transaction is aborted.";
          tailf:hidden "programmatic-interface";
        }
      }
      case no-out-of-sync-check {
        leaf no-out-of-sync-check {
          type empty;
          description
            "Continue with the transaction even if NCS detects that a device's
             configuration is out of sync. The device's sync state is assumed
             to be unknown after such commit and the stored transaction id
             value is cleared";
          tailf:hidden "programmatic-interface";
        }
      }
    }
    container commit-queue {
      presence "Commit through the commit queue";
      leaf tag {
        type string;
        description
          "User defined opaque tag.
           The tag is present in all notifications and events
           sent referencing the specific queue item.";
      }
      uses ncs_rpc_notif_commit-queue-options;
      leaf error-option {
        type enumeration {
          enum "continue-on-error" {
            description
              "The commit queue will continue on errors. No rollback data
               will be created. This is the preferred choice when
               re-deploying a service as a re-deploy doesn't have a
               transaction intent.";
          }
          enum "rollback-on-error" {
            description
              "The commit queue items will roll back on errors. The commit
               queue will place a lock on the failed queue item, thus
               blocking other queue items with overlapping devices to be
               executed. The rollback action will then automatically be
               invoked when the failed queue item has finished its execution.
               The lock is removed as part of the rollback.";
          }
          enum "stop-on-error" {
            description
              "The commit queue will place a lock on the failed queue item,
               thus blocking other queue items with overlapping devices to
               be executed. The lock must then either manually be released
               or the rollback action under
               /devices/commit-queue/completed be invoked.";
          }
        }
        description
          "The error option to use. Depending on the selected error option
           NCS will store the reverse of the original transaction intent
           to be able to undo the transaction changes and get back to the
           previous state. This data is stored in the
           /devices/commit-queue/completed tree from where it can
           be viewed and invoked with the rollback action. When invoked
           the data will be removed.";
      }
      container unlock {
        presence "Unlock queue item";
        choice choice-unlock-id {
          leaf id {
            type uint64;
            description
              "Unique id identifying a queue item. If locked, this
               item will be unlocked in the commit phase.";
          }
          leaf tag {
            type string;
            description
              "User defined opaque tag. If locked, this
               item will be unlocked in the commit phase.";
          }
        }
      }
      tailf:hidden "programmatic-interface";
    }
    choice choice-lsa {
      case use-lsa {
        leaf use-lsa {
          type empty;
          description
            "Force handling of the LSA nodes as such. This flag tells
             NCS to propagate applicable commit flags and actions
             to the LSA nodes without applying them on the upper
             NCS node itself. The commit flags affected are
             'dry-run', 'no-networking', 'no-out-of-sync-check',
             'no-overwrite' and 'no-revision-drop'.";
          tailf:hidden "programmatic-interface";
        }
      }
      case no-lsa {
        leaf no-lsa {
          type empty;
          description
            "Do not handle any of the LSA nodes as such. These nodes
             will be handled as any other device.";
          tailf:hidden "programmatic-interface";
        }
      }
    }
    leaf-list wait-device {
      type string;
      description
        "Take device locks before entering transaction critical section. The
         device locks here should be understood to be internal locks in NSO, so
         the device itself is not locked. If the device locks are held by
         someone else, wait for them to become available. The timeout applied
         in this case is the same as used to wait for the transaction lock.

         Normally the device locks are taken automatically inside the
         transaction critical section, because in a typical service transaction
         we do not know the affected devices before the service code is
         executed. When taking the device locks inside transaction critical
         section, it is not possible to wait for lock, so in case the lock is
         not available the transaction is aborted.

         This parameter allows to specify the devices expected to be
         affected by the transaction so they can be pre-locked before entering
         the transaction critical section. This allows to wait for device
         locks. This is useful in cases when other actions holding the device
         lock may be on-going at the same time and the desired behaviour is
         to wait for these actions to complete rather than abort the
         transaction. Examples of such actions are: sync-from,
         partial-sync-from, check-sync, sync-to, compare-config.

         Similarly, when used with a commit through commit queue, this
         parameter allows to wait for queue items with block-others flag. For
         example, a queue item with block-others flag is created by actions
         such as sync-from and partial-sync-from.

         If the transaction involves other devices than specified by this
         parameter, then the lock still needs to be taken on these additional
         devices, which is done inside transaction critical section and may
         fail if the device lock for the additional devices is already held
         by someone else.";
      tailf:hidden "programmatic-interface";
    }
    leaf trace-id {
      type string {
        length "1..64";
      }
      description
        "Use the provided trace id as part of the log messages emitted while
         processing.

         If no trace id is given, NSO is going to generate and assign a trace
         id to the processing.";
      tailf:hidden "programmatic-interface";
    }
  }

  grouping ncs_rpc_notif_ncs-commit-result {
    container commit-queue {
      leaf id {
        type string;
        description
          "This leaf is returned if 'commit-queue/async' or
           'commit-queue/sync' was given in the input parameters.";
      }
      leaf status {
        type enumeration {
          enum "async" {
            description
              "The queue item was successfully created.";
            tailf:code-name "commit_cq_async";
          }
          enum "completed" {
            description
              "The queue item was successfully completed.";
            tailf:code-name "commit_cq_completed";
          }
          enum "timeout" {
            description
              "The timer expired before the queue item was completed.";
            tailf:code-name "commit_cq_timeout";
          }
          enum "deleted" {
            description
              "The queue item was deleted from the queue.";
            tailf:code-name "commit_cq_deleted";
          }
          enum "failed" {
            description
              "The queue item failed.";
            tailf:code-name "commit_cq_failed";
          }
        }
      }
      list failed-device {
        key "name";
        leaf name {
          type string;
        }
        leaf reason {
          type string;
          description
            "The error for this failing device.";
        }
        description
          "The devices which failed for this queue item.";
      }
    }
  }

  grouping ncs_rpc_notif_dry-run-xml {
    container result-xml {
      description
        "Display all changes in the whole data model. The
         changes will be displayed in NETCONF XML edit-config format,
         i.e., the edit-config that would be applied locally (at NCS)
         to get a config that is equal to that of the managed device.";
      container local-node {
        anyxml data;
      }
      list lsa-node {
        leaf name {
          type string;
        }
        anyxml data;
      }
    }
  }

  grouping ncs_rpc_notif_dry-run-cli {
    container cli {
      description
        "Display all changes in the whole data model. The
         changes will be displayed in CLI curly bracket format.";
      container local-node {
        leaf data {
          tailf:cli-preformatted;
          type string;
        }
      }
      list lsa-node {
        leaf name {
          type string;
        }
        leaf data {
          tailf:cli-preformatted;
          type string;
        }
      }
    }
  }

  grouping ncs_rpc_notif_dry-run-native {
    container native {
      description
        "Display only changes under /devices/device/config. The
         changes will be displayed in native device format.";
      list device {
        key "name";
        leaf name {
          type string;
        }
        leaf data {
          tailf:cli-preformatted;
          type string;
        }
      }
    }
  }

  grouping ncs_rpc_notif_commit-queue-item-status {
    leaf status {
      // NCS drop tailf:display-groups
      type enumeration {
        enum "completed" {
          description
            "The queue item was successfully completed.";
          tailf:code-name "cq_item_completed";
        }
        enum "deleted" {
          description
            "The queue item was deleted from the queue.";
          tailf:code-name "cq_item_deleted";
        }
        enum "failed" {
          description
            "The queue item failed.";
          tailf:code-name "cq_item_failed";
        }
      }
    }
  }

  grouping ncs_rpc_notif_connect-grouping {
    // NCS drop tailf:action
  }

  grouping ncs_rpc_notif_connect-grouping-extended {
    // NCS drop tailf:action
  }

  grouping ncs_rpc_notif_connect-result {
    description
      "Common result data from a 'connect' action.";
    leaf result {
      type boolean;
    }
    leaf info {
      type string;
      description
        "If present, contains additional information about the result.";
    }
  }

  grouping ncs_rpc_notif_check-sync-grouping {
    // NCS drop tailf:action
  }

  grouping ncs_rpc_notif_check-sync-grouping-extended {
    // NCS drop tailf:action
  }

  grouping ncs_rpc_notif_check-sync-result {
    description
      "Common result data from a 'check-sync' action.";
    leaf result {
      type enumeration {
        enum "unknown" {
          description
            "NCS has no record, probably because no
             sync actions has been executed towards the device
             or it was cleared after a no-out-of-sync-check commit.
             This is also the initial state for a device.";
        }
        enum "locked" {
          tailf:code-name "sync_locked";
          description
            "The device is administratively locked, meaning that NCS
             cannot talk to it.";
        }
        enum "in-sync" {
          tailf:code-name "in-sync-result";
          description
            "The configuration on the device is in sync with NCS.";
        }
        enum "out-of-sync" {
          description
            "The device configuration is known to be out of sync, i.e.,
             it has been reconfigured out of band.";
        }
        enum "unsupported" {
          description
            "The device doesn't have any mechanism to do a cheap
             check-sync, or this mechanism has been disabled.";
        }
        enum "error" {
          tailf:code-name "sync-error";
          description
            "An error occurred when NCS tried to check the sync status.
             The leaf 'info' contains additional information.";
        }
      }
    }
    leaf info {
      type string;
      description
        "If present, contains additional information about the result.";
    }
  }

  grouping ncs_rpc_notif_sync-to-grouping {
    // NCS drop tailf:action
  }

  grouping ncs_rpc_notif_sync-to-grouping-extended {
    // NCS drop tailf:action
  }

  grouping ncs_rpc_notif_sync-to-result {
    description
      "Common result data from a 'sync-to' action.";
    choice outformat {
      leaf result {
        type boolean;
      }
      anyxml result-xml;
      leaf cli {
        tailf:cli-preformatted;
        type string;
      }
      leaf native {
        tailf:cli-preformatted;
        type string;
      }
    }
    leaf info {
      type string;
      description
        "If present, contains additional information about the result.";
    }
  }

  grouping ncs_rpc_notif_sync-from-grouping {
    // NCS drop tailf:action
  }

  grouping ncs_rpc_notif_sync-from-grouping-extended {
    // NCS drop tailf:action
  }

  grouping ncs_rpc_notif_sync-from-output {
    list sync-result {
      key "device";
      leaf device {
        type string;
      }
      uses ncs_rpc_notif_sync-result;
    }
  }

  grouping ncs_rpc_notif_sync-result {
    description
      "Common result data from a 'sync' action.";
    choice outformat {
      leaf result {
        type boolean;
      }
      anyxml result-xml;
      leaf cli {
        tailf:cli-preformatted;
        type string;
      }
    }
    leaf info {
      type string;
      description
        "If present, contains additional information about the result.";
    }
  }

  grouping ncs_rpc_notif_wait-for-lock {
    choice wait-for-lock-choice {
      description
        "Wait for device lock setting.";
      leaf no-wait-for-lock {
        type empty;
        description
          "The action can't be performed while the device is being
           committed to (or waiting in the commit queue). This is to avoid
           getting inconsistent data when reading the configuration.
           This specifies that the action should not wait for device lock,
           instead, it should immediately fail if the device is being locked.";
      }
      container wait-for-lock {
        presence "Wait for device lock.";
        description
          "The action can't be performed while the device is being
           committed to (or waiting in the commit queue). This is to avoid
           getting inconsistent data when reading the configuration.
           This specifies a timeout to wait for a device lock to be placed
           in the commit queue. The lock will be automatically released once
           the action has been executed.";
        choice timeout-choice {
          default "infinity";
          leaf timeout {
            type uint32 {
              range "0..4294967";
            }
            units "seconds";
            description
              "Specifies a maximum number of seconds to wait for the
               device to be locked.";
          }
          leaf infinity {
            description
              "Wait infinitely for the lock, this is the default.";
            type empty;
          }
        }
      }
    }
  }

  grouping ncs_rpc_notif_disconnect-grouping {
    // NCS drop tailf:action
  }

  grouping ncs_rpc_notif_disconnect-grouping-specific {
    // NCS drop tailf:action
  }

  grouping ncs_rpc_notif_disconnect-grouping-extended {
    // NCS drop tailf:action
  }

  grouping ncs_rpc_notif_check-yang-modules-grouping {
    // NCS drop tailf:action
  }

  grouping ncs_rpc_notif_check-yang-modules-grouping-extended {
    // NCS drop tailf:action
  }

  grouping ncs_rpc_notif_check-yang-modules-result {
    description
      "Common result data from a 'check-yang-modules' action.";
    choice compat-res {
      case silent {
        description
          "Present in non-verbose mode.";
        leaf compatible {
          type boolean;
          description
            "Reporting if a device is revision compatible true/false
             in non-verbose mode.";
        }
      }
      case verbose {
        list module {
          description
            "In verbose mode, this is the list of the supported modules for
             a device which are reported as capabilities.";
          key "name";
          leaf name {
            type string;
            description
              "YANG module";
          }
          leaf status {
            description
              "Compatibility status for the YANG module.";
            type enumeration {
              enum "supported" {
                tailf:code-name "module-supported";
                description
                  "Implies that NCS has loaded the yang module with
                   the same revision or a revision of newer date.";
              }
              enum "unsupported" {
                tailf:code-name "module-unsupported";
                description
                  "Implies that NCS has loaded the yang module but the
                   revision is to old.";
              }
              enum "not-loaded" {
                tailf:code-name "module-not-loaded";
                description
                  "Implies that NCS has not loaded the yang module.";
              }
              enum "unknown" {
                tailf:code-name "module-unknown";
                description
                  "that NCS has loaded the module but the revision
                   information was not available for comparison.";
              }
            }
          }
          leaf device-revision {
            type string;
            description
              "Live device reported revision for the module";
          }
          leaf ncs-revision {
            type string;
            description
              "NCS loaded YANG module revision";
          }
        }
      }
    }
  }

  grouping ncs_rpc_notif_fetch-ssh-host-keys-grouping {
    // NCS drop tailf:action
  }

  grouping ncs_rpc_notif_fetch-ssh-host-keys-grouping-extended {
    // NCS drop tailf:action
  }

  grouping ncs_rpc_notif_apply-template-grouping {
    // NCS drop tailf:action
  }

  grouping ncs_rpc_notif_apply-template-grouping-extended {
    // NCS drop tailf:action
  }

  grouping ncs_rpc_notif_migrate-grouping {
    // NCS drop tailf:action
  }

  grouping ncs_rpc_notif_migrate-grouping-extended {
    // NCS drop tailf:action
  }

  grouping ncs_rpc_notif_migrate-result {
    list modified-path {
      leaf path {
        description
          "The path below /devices/device/config that has been modified.";
        type yang:xpath1.0;
      }
      leaf info {
        description
          "Description of what has changed on the path.";
        type string;
      }
    }
    leaf-list affected-services {
      description
        "The service instances/points that are affected by the data
         model changes on the migrated device.";
      type string;
    }
  }

  grouping ncs_rpc_notif_location {
    container location {
      description
        "Physical location of devices in the group";
      leaf name {
        type string;
        description
          "An arbitrary name of the location.";
      }
      leaf latitude {
        type decimal64 {
          range "-90..90";
          fraction-digits 6;
        }
        units "decimal degrees";
        description
          "The latitude according to WGS-84, in decimal degrees.";
      }
      leaf longitude {
        type decimal64 {
          range "-180..180";
          fraction-digits 6;
        }
        units "decimal degrees";
        description
          "The longitude according to WGS-84, in decimal degrees.";
      }
      leaf altitude {
        type int32;
        units "meters";
        description
          "The altitude according to WGS-84, in meters.";
      }
    }
  }

  grouping ncs_rpc_notif_queue-item-status {
    leaf status {
      // NCS drop tailf:display-groups
      type enumeration {
        enum "waiting" {
          description
            "The queue item is waiting to run.  This state means
             that there is some other item in the queue, ahead of this item.";
        }
        enum "executing" {
          description
            "The queue item is currently executing.

             Transient errors might be present. These errors occur when NCS
             fails to communicate with some of the devices. The errors are
             shown in the 'transient-errors' leaf-list.

             Retries will take place at intervals a specified in
             /devices/global-settings/commit-queue/retry-timeout.

             Examples of transient errors are connection failures
             and that the changes are rejected due to the device
             being locked.

             Transient errors are potentially bad, since the queue might
             grow if new items are added, waiting for the same device.";
        }
        enum "locked" {
          description
            "This queue item is locked and will not be processed until it has
             been unlocked, see the action
             '/devices/commit-queue/queue-item/unlock'.

             A locked queue-item will block all subsequent queue-items
             which are using any device in the locked queue item.";
          tailf:code-name "qi_locked";
        }
        enum "blocked" {
          description
            "The queue item is waiting in the queue, and some other
             queue item ahead of this item is in state 'locked' or 'executing'
             with transient errors.";
        }
        enum "waiting-not-master" {
          description
            "HA is enabled, but we have not yet entered the master
             state, no provisioning can be done through the commit
             queue unless we are master.";
        }
        enum "locked-not-master" {
          description
            "HA is enabled, but we have not yet entered the master
             state, no provisioning can be done through the commit
             queue unless we are master.";
        }
        enum "blocked-not-master" {
          description
            "HA is enabled, but we have not yet entered the master
             state, no provisioning can be done through the commit
             queue unless we are master.";
        }
      }
      description
        "What is NCS currently doing with this queue item.
         If the status is idle, it means that the item is waiting
         for another queue item where one of the devices is
         not running, i.e., it's not possible to connect to that
         device.";
    }
  }

  grouping ncs_rpc_notif_commit-queue-basic-options {
    choice operation-mode {
      leaf async {
        type empty;
        description
          "Commit the transaction data asynchronously to the commit queue.
           This flag is useful when some device is non-operational or
           has data waiting in the commit queue.

           The operation returns successfully if the transaction data has
           been successfully placed in the queue. The leaf
           'commit-queue/id' is set as the queue identifier and the
           leaf 'commit-queue/status' is set to 'async' in the result.";
      }
      container sync {
        presence "Commit through the commit queue and wait for completion";
        description
          "Commit the transaction data synchronously to the commit queue.

           The operation does not return until the transaction data has
           been sent to all devices, or a timeout occurs. The leaf
           'commit-queue/id' is set as the queue identifier and the
           leaf 'commit-queue/status' is set to 'completed', 'failed',
           'deleted' or 'timeout' dependent of the outcome.

           If no device is involved in the transaction, the operation
           returns directly.";
        choice timeout-choice {
          leaf timeout {
            type uint32 {
              range "0..4294967";
            }
            units "seconds";
            description
              "Specifies a maximum number of seconds to wait for the
               transaction to be committed. If the timer expires, the
               transaction is kept in the commit-queue, and the operation
               returns successfully. The leaf 'commit-queue/status'
               is set to 'timeout', and the leaf 'commit-queue/id' is
               set to the queue identifier in the result.";
          }
          leaf infinity {
            description
              "Wait infinitely for the transaction to be committed.";
            type empty;
          }
        }
      }
      default "async";
    }
  }

  grouping ncs_rpc_notif_commit-queue-options {
    uses ncs_rpc_notif_commit-queue-basic-options {
      augment "operation-mode" {
        leaf bypass {
          type empty;
          description
            "This flag means that if
             /devices/commit-queue/enabled-by-default is 'true' the
             data in this transaction will bypass the commit queue.
             The data will be written directly to the devices.";
        }
      }
    }
    leaf block-others {
      type empty;
      description
        "The resulting queue item will block subsequent queue items,
         which use any of the devices in this queue item, from
         being queued.";
    }
    leaf lock {
      type empty;
      description
        "Place a lock on the resulting queue item. The queue
         item will not be processed until it has been unlocked,
         see the actions 'unlock' and 'lock' in
         /devices/commit-queue/queue-item'.

         No following queue items, using the same devices, will be
         allowed to execute as long as the lock is in place.";
    }
    leaf atomic {
      type boolean;
      description
        "Sets the atomic behaviour of the resulting queue item.
         If this is set to false, the devices contained in the
         resulting queue item can start executing if the same devices
         in other non-atomic queue items ahead of it in the queue are
         completed. If set to true, the atomic integrity of the
         queue item is preserved.";
    }
  }

  grouping ncs_rpc_notif_authgroup-callback-input-params {
    description
      "When /devices/authgroups/group/[name]/umap/[local-user]/callback-node
       and /devices/authgroups/group/[name]/umap/[local-user]/action-name
       is set, the action that is defined by action-name in the specified
       callback-node must use this grouping as input parameters.";
    leaf local-user {
      type string;
    }
    leaf authgroup {
      type string;
    }
    leaf device {
      type string;
    }
  }

  grouping ncs_rpc_notif_authgroup-callback-output-params {
    description
      "When /devices/authgroups/group/[name]/umap/[local-user]/callback-node
       and /devices/authgroups/group/[name]/umap/[local-user]/action-name
       is set, the action that is defined by action-name in the specified
       callback-node must use this grouping as output parameters.";
    leaf remote-user {
      type string;
    }
    leaf remote-password {
      type string;
    }
    leaf remote-secondary-password {
      type string;
    }
  }

  grouping ncs_rpc_notif_notifications {
    list subscription {
      tailf:info
        "List of subscriptions";
      key "name";
      description
        "A list of our notification subscriptions for this managed device.";
      leaf name {
        type string;
        description
          "Each subscription must have a unique name.";
      }
      leaf stream {
        tailf:info
          "The notification stream name";
        type string;
        mandatory true;
        description
          "The name of the notification stream this subscription
           refers to.";
      }
      choice filter {
        description
          "Optional element, if not set, no filters are applied.";
        case xpath {
          leaf xpath {
            tailf:info
              "XPath filter for the notifications";
            type yang:xpath1.0;
          }
        }
        case subtree {
          leaf subtree {
            tailf:info
              "Subtree filter for the notifications";
            type string;
          }
        }
      }
      leaf local-user {
        type string;
        mandatory true;
        description
          "The local user is used when setting up a device
           connection.";
      }
      leaf store-in-cdb {
        tailf:info
          "Store notifications in CDB";
        type boolean;
        default "true";
        description
          "Indicate whether notifications should be stored as
           operational data in CDB.

           When notifications are generated at a high rate,
           storage consumes lots of resources. In cases like that,
           consider using the device-notification event stream
           instead.";
      }
      leaf utilize-replay {
        tailf:info
          "Use replay when connecting to the device";
        type boolean;
        default "true";
        description
          "If the device supports replay, should NCS attempt to use that
           when connecting to the device.";
      }
      leaf reconnect-interval {
        tailf:info
          "Interval for re-establishing the subscription";
        type uint32 {
          range "0..4294967";
        }
        units "seconds";
        default "60";
        description
          "If the device is non operational, with which
           interval (in seconds) shall NCS attempt to re-establish
           the subscription.";
      }
      leaf status {
        type enumeration {
          enum "running" {
            description
              "The subscription is established and NCS should
               be receiving notifications.";
          }
          enum "connecting" {
            description
              "Attempting to establish the subscription.";
          }
          enum "failed" {
            tailf:code-name "notif-failed";
            description
              "The subscription has failed.  Unless the failure is
               in the connection establishing, i.e., connect
               failed, there will be no automatic re-connect.";
          }
        }
        config false;
        default "connecting";
        description
          "Is this subscription currently running.";
      }
      leaf failure-reason {
        type enumeration {
          enum "connection-refused" {
            description
              "Failed to connect to the device.";
          }
          enum "connection-timeout" {
            description
              "Timeout when connecting to the device.";
          }
          enum "session" {
            description
              "Failed to establish session.";
          }
          enum "subscribe" {
            description
              "The device rejected our subscription attempt.";
          }
          enum "xml" {
            tailf:code-name "notif-xml";
            description
              "NCS received XML that could not be parsed.";
          }
          enum "internal" {
            description
              "Internal NCS error.";
          }
          enum "disconnected" {
            description
              "Manually disconnected.";
          }
          enum "closed" {
            tailf:code-name "notif-closed";
            description
              "Server closed its end.";
          }
          enum "locked" {
            tailf:code-name "notif-locked";
            value 9;
            description
              "No subscriptions allowed towards devices that are
               locked or southbound locked.";
          }
          enum "auth-failed" {
            value 10;
            description
              "Device authentication failed.";
          }
          enum "same-pass" {
            tailf:code-name "notif-same-pass";
            value 11;
            description
              "Subscription is not allowed when 'same-pass' option is
               configured for authentication.";
          }
          enum "call-home" {
            tailf:code-name "notif-call-home";
            value 12;
            description
              "Subscription is not allowed until a call
               home connection has been established.";
          }
          enum "read-only" {
            tailf:code-name "notif-read-only";
            value 13;
            description
              "Subscription is not allowed until read-only
               mode is disabled and/or the mode of the HA node has
               changed.";
          }
          enum "session-limit-exceeded" {
            tailf:code-name "notif-session-limit-exceeded";
            value 14;
            description
              "The session limit has been exceeded.";
          }
        }
        config false;
        description
          "If there is a problem with this subscription
           this leaf indicates what the problem is.";
        // NCS drop tailf:callpoint
      }
      leaf error-info {
        type string;
        config false;
        description
          "Contains additional information, if available, when the
           status is not equal to 'running'.";
        // NCS drop tailf:callpoint
      }
      // NCS drop tailf:action
      // NCS drop tailf:action
      // NCS drop tailf:action
    }
    list stream {
      key "name";
      config false;
      description
        "A list of the notification streams provided by the device.
         NCS reads this list in realtime.";
      // NCS drop tailf:callpoint
      leaf name {
        type string;
        description
          "The name of the the stream.";
      }
      leaf description {
        type string;
        description
          "A textual description of the stream.";
      }
      leaf replay-support {
        type boolean;
        description
          "An indication of whether or not event replay
           is available on this stream.";
      }
      leaf replay-log-creation-time {
        type yang:date-and-time;
        description
          "The timestamp of the creation of the log used to support
           the replay function on this stream. Note that this might
           be earlier then the earliest available notification in the
           log. This object is updated if the log resets for some
           reason.";
      }
      leaf replay-log-aged-time {
        type yang:date-and-time;
        description
          "The timestamp of the last notification aged out of the log.";
      }
    }
    list notification-name {
      key "name";
      config false;
      description
        "List of all names of notifications defined by this device.";
      // NCS drop tailf:callpoint
      leaf name {
        type string;
        description
          "The XML tag of the notification name.";
      }
      leaf uri {
        type string;
        description
          "The XML namespace uri for this notification.";
      }
    }
    container received-notifications {
      leaf max-size {
        type int32;
        default "200";
        description
          "Max size of the list of received notifications.
           When the maximum size is reached, the oldest
           received notification is purged.";
      }
      leaf clear-time {
        type yang:date-and-time;
        config false;
        // NCS drop tailf:cdb-oper
        description
          "When were notifications last cleared.";
      }
      // NCS drop tailf:action
      list notification {
        key "event-time sequence-no";
        config false;
        description
          "A list of received notifications from the device.
           The list is a circular list, with a maximum size.
           When a new notification is added to the list, the oldest
           entry is purged.";
        // NCS drop tailf:cdb-oper
        leaf event-time {
          type yang:date-and-time;
          description
            "The time the event was generated at the device.";
        }
        leaf sequence-no {
          type int32;
        }
        leaf user {
          type string;
          description
            "User name of the user that created the subscription
             that made this notification end up here.";
        }
        leaf subscription {
          type string;
          description
            "The name of the subscription that made this
             notification end up here.";
        }
        leaf stream {
          type string;
          description
            "The name of the stream this notification belongs to.";
        }
        leaf received-time {
          type yang:date-and-time;
          description
            "The time the event was received at NCS.";
        }
        container data {
          // NCS drop tailf:mount-point
          description
            "This container is automatically augmented with notifications
             from the managed device. Whenever a device module
             that contains notifications is compiled, the device
             specific notifications end up here, as a container
             with the same name as the device notification.";
        }
      }
    }
  }

  grouping live_ncs_oper-state {
    leaf oper-state {
      type live_ncs_oper-state;
      // NCS drop default statement
      tailf:info
        "The actual operational state of the device.";
      // NCS drop tailf:cdb-oper
    }
    leaf oper-state-error-tag {
      type live_ncs_oper-state-error-tag;
      tailf:info
        "Additional error information if the device is disabled.";
      // NCS drop tailf:cdb-oper
    }
    // NCS drop fully hidden leaf 'oper-state-hash'
  }

  grouping live_ncs_ncs-commit-params {
    leaf no-revision-drop {
      type empty;
      description
        "This flags means that NCS will not run its data model revision
         algorithm, which requires all participating managed devices
         to have all parts of the data models for all data contained
         in this transaction. Thus, this flag forces NCS to never
         silently drop any data set operations towards a device.";
    }
    leaf no-networking {
      type empty;
      description
        "Do not send any data to the devices. Even if the transaction
         manipulates data below /devices/device/config, nothing will
         be sent to the managed devices. This is a way to manipulate
         CDB in NCS without generating any southbound traffic.";
    }
    choice choice-sync-check {
      case no-overwrite {
        leaf no-overwrite {
          type empty;
          description
            "This flags means that NCS will check that the data that
             should be modified has not changed on the device compared
             to NCS's view of the data. This is a fine-granular sync check;
             NCS verifies that NCS and the device is in sync regarding
             the data that will be modified. If they are not in sync,
             the transaction is aborted.";
        }
      }
      case no-out-of-sync-check {
        leaf no-out-of-sync-check {
          type empty;
          description
            "Continue with the transaction even if NCS detects that a device's
             configuration is out of sync. The device's sync state is assumed
             to be unknown after such commit and the stored transaction id
             value is cleared";
        }
      }
    }
    container commit-queue {
      presence "Commit through the commit queue";
      leaf tag {
        type string;
        description
          "User defined opaque tag.
           The tag is present in all notifications and events
           sent referencing the specific queue item.";
      }
      uses live_ncs_commit-queue-options;
      leaf error-option {
        type enumeration {
          enum "continue-on-error" {
            description
              "The commit queue will continue on errors. No rollback data
               will be created. This is the preferred choice when
               re-deploying a service as a re-deploy doesn't have a
               transaction intent.";
          }
          enum "rollback-on-error" {
            description
              "The commit queue items will roll back on errors. The commit
               queue will place a lock on the failed queue item, thus
               blocking other queue items with overlapping devices to be
               executed. The rollback action will then automatically be
               invoked when the failed queue item has finished its execution.
               The lock is removed as part of the rollback.";
          }
          enum "stop-on-error" {
            description
              "The commit queue will place a lock on the failed queue item,
               thus blocking other queue items with overlapping devices to
               be executed. The lock must then either manually be released
               or the rollback action under
               /devices/commit-queue/completed be invoked.";
          }
        }
        description
          "The error option to use. Depending on the selected error option
           NCS will store the reverse of the original transaction intent
           to be able to undo the transaction changes and get back to the
           previous state. This data is stored in the
           /devices/commit-queue/completed tree from where it can
           be viewed and invoked with the rollback action. When invoked
           the data will be removed.";
      }
      container unlock {
        presence "Unlock queue item";
        choice choice-unlock-id {
          leaf id {
            type uint64;
            description
              "Unique id identifying a queue item. If locked, this
               item will be unlocked in the commit phase.";
          }
          leaf tag {
            type string;
            description
              "User defined opaque tag. If locked, this
               item will be unlocked in the commit phase.";
          }
        }
      }
    }
    choice choice-lsa {
      case use-lsa {
        leaf use-lsa {
          type empty;
          description
            "Force handling of the LSA nodes as such. This flag tells
             NCS to propagate applicable commit flags and actions
             to the LSA nodes without applying them on the upper
             NCS node itself. The commit flags affected are
             'dry-run', 'no-networking', 'no-out-of-sync-check',
             'no-overwrite' and 'no-revision-drop'.";
        }
      }
      case no-lsa {
        leaf no-lsa {
          type empty;
          description
            "Do not handle any of the LSA nodes as such. These nodes
             will be handled as any other device.";
        }
      }
    }
    leaf-list wait-device {
      type leafref {
        path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/ncs:devices/ncs:device/ncs:name" {
          tailf:xpath-root 3;
        }
      }
      description
        "Take device locks before entering transaction critical section. The
         device locks here should be understood to be internal locks in NSO, so
         the device itself is not locked. If the device locks are held by
         someone else, wait for them to become available. The timeout applied
         in this case is the same as used to wait for the transaction lock.

         Normally the device locks are taken automatically inside the
         transaction critical section, because in a typical service transaction
         we do not know the affected devices before the service code is
         executed. When taking the device locks inside transaction critical
         section, it is not possible to wait for lock, so in case the lock is
         not available the transaction is aborted.

         This parameter allows to specify the devices expected to be
         affected by the transaction so they can be pre-locked before entering
         the transaction critical section. This allows to wait for device
         locks. This is useful in cases when other actions holding the device
         lock may be on-going at the same time and the desired behaviour is
         to wait for these actions to complete rather than abort the
         transaction. Examples of such actions are: sync-from,
         partial-sync-from, check-sync, sync-to, compare-config.

         Similarly, when used with a commit through commit queue, this
         parameter allows to wait for queue items with block-others flag. For
         example, a queue item with block-others flag is created by actions
         such as sync-from and partial-sync-from.

         If the transaction involves other devices than specified by this
         parameter, then the lock still needs to be taken on these additional
         devices, which is done inside transaction critical section and may
         fail if the device lock for the additional devices is already held
         by someone else.";
    }
    leaf trace-id {
      type string {
        length "1..64";
      }
      description
        "Use the provided trace id as part of the log messages emitted while
         processing.

         If no trace id is given, NSO is going to generate and assign a trace
         id to the processing.";
    }
  }

  grouping live_ncs_ncs-hidden-commit-params {
    // NCS expand uses statement
    leaf no-revision-drop {
      type empty;
      description
        "This flags means that NCS will not run its data model revision
         algorithm, which requires all participating managed devices
         to have all parts of the data models for all data contained
         in this transaction. Thus, this flag forces NCS to never
         silently drop any data set operations towards a device.";
      tailf:hidden "programmatic-interface";
    }
    leaf no-networking {
      type empty;
      description
        "Do not send any data to the devices. Even if the transaction
         manipulates data below /devices/device/config, nothing will
         be sent to the managed devices. This is a way to manipulate
         CDB in NCS without generating any southbound traffic.";
      tailf:hidden "programmatic-interface";
    }
    choice choice-sync-check {
      case no-overwrite {
        leaf no-overwrite {
          type empty;
          description
            "This flags means that NCS will check that the data that
             should be modified has not changed on the device compared
             to NCS's view of the data. This is a fine-granular sync check;
             NCS verifies that NCS and the device is in sync regarding
             the data that will be modified. If they are not in sync,
             the transaction is aborted.";
          tailf:hidden "programmatic-interface";
        }
      }
      case no-out-of-sync-check {
        leaf no-out-of-sync-check {
          type empty;
          description
            "Continue with the transaction even if NCS detects that a device's
             configuration is out of sync. The device's sync state is assumed
             to be unknown after such commit and the stored transaction id
             value is cleared";
          tailf:hidden "programmatic-interface";
        }
      }
    }
    container commit-queue {
      presence "Commit through the commit queue";
      leaf tag {
        type string;
        description
          "User defined opaque tag.
           The tag is present in all notifications and events
           sent referencing the specific queue item.";
      }
      uses live_ncs_commit-queue-options;
      leaf error-option {
        type enumeration {
          enum "continue-on-error" {
            description
              "The commit queue will continue on errors. No rollback data
               will be created. This is the preferred choice when
               re-deploying a service as a re-deploy doesn't have a
               transaction intent.";
          }
          enum "rollback-on-error" {
            description
              "The commit queue items will roll back on errors. The commit
               queue will place a lock on the failed queue item, thus
               blocking other queue items with overlapping devices to be
               executed. The rollback action will then automatically be
               invoked when the failed queue item has finished its execution.
               The lock is removed as part of the rollback.";
          }
          enum "stop-on-error" {
            description
              "The commit queue will place a lock on the failed queue item,
               thus blocking other queue items with overlapping devices to
               be executed. The lock must then either manually be released
               or the rollback action under
               /devices/commit-queue/completed be invoked.";
          }
        }
        description
          "The error option to use. Depending on the selected error option
           NCS will store the reverse of the original transaction intent
           to be able to undo the transaction changes and get back to the
           previous state. This data is stored in the
           /devices/commit-queue/completed tree from where it can
           be viewed and invoked with the rollback action. When invoked
           the data will be removed.";
      }
      container unlock {
        presence "Unlock queue item";
        choice choice-unlock-id {
          leaf id {
            type uint64;
            description
              "Unique id identifying a queue item. If locked, this
               item will be unlocked in the commit phase.";
          }
          leaf tag {
            type string;
            description
              "User defined opaque tag. If locked, this
               item will be unlocked in the commit phase.";
          }
        }
      }
      tailf:hidden "programmatic-interface";
    }
    choice choice-lsa {
      case use-lsa {
        leaf use-lsa {
          type empty;
          description
            "Force handling of the LSA nodes as such. This flag tells
             NCS to propagate applicable commit flags and actions
             to the LSA nodes without applying them on the upper
             NCS node itself. The commit flags affected are
             'dry-run', 'no-networking', 'no-out-of-sync-check',
             'no-overwrite' and 'no-revision-drop'.";
          tailf:hidden "programmatic-interface";
        }
      }
      case no-lsa {
        leaf no-lsa {
          type empty;
          description
            "Do not handle any of the LSA nodes as such. These nodes
             will be handled as any other device.";
          tailf:hidden "programmatic-interface";
        }
      }
    }
    leaf-list wait-device {
      type leafref {
        path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/ncs:devices/ncs:device/ncs:name" {
          tailf:xpath-root 3;
        }
      }
      description
        "Take device locks before entering transaction critical section. The
         device locks here should be understood to be internal locks in NSO, so
         the device itself is not locked. If the device locks are held by
         someone else, wait for them to become available. The timeout applied
         in this case is the same as used to wait for the transaction lock.

         Normally the device locks are taken automatically inside the
         transaction critical section, because in a typical service transaction
         we do not know the affected devices before the service code is
         executed. When taking the device locks inside transaction critical
         section, it is not possible to wait for lock, so in case the lock is
         not available the transaction is aborted.

         This parameter allows to specify the devices expected to be
         affected by the transaction so they can be pre-locked before entering
         the transaction critical section. This allows to wait for device
         locks. This is useful in cases when other actions holding the device
         lock may be on-going at the same time and the desired behaviour is
         to wait for these actions to complete rather than abort the
         transaction. Examples of such actions are: sync-from,
         partial-sync-from, check-sync, sync-to, compare-config.

         Similarly, when used with a commit through commit queue, this
         parameter allows to wait for queue items with block-others flag. For
         example, a queue item with block-others flag is created by actions
         such as sync-from and partial-sync-from.

         If the transaction involves other devices than specified by this
         parameter, then the lock still needs to be taken on these additional
         devices, which is done inside transaction critical section and may
         fail if the device lock for the additional devices is already held
         by someone else.";
      tailf:hidden "programmatic-interface";
    }
    leaf trace-id {
      type string {
        length "1..64";
      }
      description
        "Use the provided trace id as part of the log messages emitted while
         processing.

         If no trace id is given, NSO is going to generate and assign a trace
         id to the processing.";
      tailf:hidden "programmatic-interface";
    }
  }

  grouping live_ncs_ncs-commit-result {
    container commit-queue {
      leaf id {
        type leafref {
          path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/ncs:devices/ncs:commit-queue/ncs:queue-item/ncs:id" {
            tailf:xpath-root 3;
          }
        }
        description
          "This leaf is returned if 'commit-queue/async' or
           'commit-queue/sync' was given in the input parameters.";
      }
      leaf status {
        type enumeration {
          enum "async" {
            description
              "The queue item was successfully created.";
            tailf:code-name "commit_cq_async";
          }
          enum "completed" {
            description
              "The queue item was successfully completed.";
            tailf:code-name "commit_cq_completed";
          }
          enum "timeout" {
            description
              "The timer expired before the queue item was completed.";
            tailf:code-name "commit_cq_timeout";
          }
          enum "deleted" {
            description
              "The queue item was deleted from the queue.";
            tailf:code-name "commit_cq_deleted";
          }
          enum "failed" {
            description
              "The queue item failed.";
            tailf:code-name "commit_cq_failed";
          }
        }
      }
      list failed-device {
        key "name";
        leaf name {
          type leafref {
            path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/ncs:devices/ncs:device/ncs:name" {
              tailf:xpath-root 3;
            }
          }
        }
        leaf reason {
          type string;
          description
            "The error for this failing device.";
        }
        description
          "The devices which failed for this queue item.";
      }
    }
  }

  grouping live_ncs_dry-run-xml {
    container result-xml {
      description
        "Display all changes in the whole data model. The
         changes will be displayed in NETCONF XML edit-config format,
         i.e., the edit-config that would be applied locally (at NCS)
         to get a config that is equal to that of the managed device.";
      container local-node {
        anyxml data;
      }
      list lsa-node {
        leaf name {
          type string;
        }
        anyxml data;
      }
    }
  }

  grouping live_ncs_dry-run-cli {
    container cli {
      description
        "Display all changes in the whole data model. The
         changes will be displayed in CLI curly bracket format.";
      container local-node {
        leaf data {
          tailf:cli-preformatted;
          type string;
        }
      }
      list lsa-node {
        leaf name {
          type string;
        }
        leaf data {
          tailf:cli-preformatted;
          type string;
        }
      }
    }
  }

  grouping live_ncs_dry-run-native {
    container native {
      description
        "Display only changes under /devices/device/config. The
         changes will be displayed in native device format.";
      list device {
        key "name";
        leaf name {
          type string;
        }
        leaf data {
          tailf:cli-preformatted;
          type string;
        }
      }
    }
  }

  grouping live_ncs_commit-queue-item-status {
    leaf status {
      // NCS drop tailf:display-groups
      type enumeration {
        enum "completed" {
          description
            "The queue item was successfully completed.";
          tailf:code-name "cq_item_completed";
        }
        enum "deleted" {
          description
            "The queue item was deleted from the queue.";
          tailf:code-name "cq_item_deleted";
        }
        enum "failed" {
          description
            "The queue item failed.";
          tailf:code-name "cq_item_failed";
        }
      }
    }
  }

  grouping live_ncs_connect-grouping {
    tailf:action connect {
      tailf:actionpoint ncsproxy {
        tailf:internal;
      }
      description
        "Set up sessions to all unlocked devices.";
      tailf:info
        "Set up sessions to all unlocked devices";
      // NCS drop tailf:actionpoint
      input {
        leaf suppress-positive-result {
          type empty;
          description
            "Use this additional parameter to only return
             devices that failed to connect.";
        }
        leaf override-southbound-locked {
          type empty;
          description
            "When a device is southbound locked, all southbound communication
             is turned off. This flag overrides this for connection
             attempts. Thus, this is a way to update the capabilities
             including revision information for a managed device although
             the device is southbound locked";
        }
      }
      output {
        list connect-result {
          key "device";
          leaf device {
            type leafref {
              path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/device/name" {
                tailf:xpath-root 3;
              }
            }
          }
          uses live_ncs_connect-result;
        }
      }
    }
  }

  grouping live_ncs_connect-grouping-extended {
    tailf:action connect {
      tailf:actionpoint ncsproxy {
        tailf:internal;
      }
      description
        "Set up sessions to all unlocked devices.";
      tailf:info
        "Set up sessions to all unlocked devices";
      // NCS drop tailf:actionpoint
      input {
        leaf suppress-positive-result {
          type empty;
          description
            "Use this additional parameter to only return
             devices that failed to connect.";
        }
        leaf override-southbound-locked {
          type empty;
          description
            "When a device is southbound locked, all southbound communication
             is turned off. This flag overrides this for connection
             attempts. Thus, this is a way to update the capabilities
             including revision information for a managed device although
             the device is southbound locked";
        }
        leaf-list device {
          tailf:info
            "Only connect to these devices.";
          type leafref {
            path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/device/name" {
              tailf:xpath-root 3;
            }
          }
        }
      }
      output {
        list connect-result {
          key "device";
          leaf device {
            type leafref {
              path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/device/name" {
                tailf:xpath-root 3;
              }
            }
          }
          uses live_ncs_connect-result;
        }
      }
    }
  }

  grouping live_ncs_connect-result {
    description
      "Common result data from a 'connect' action.";
    leaf result {
      type boolean;
    }
    leaf info {
      type string;
      description
        "If present, contains additional information about the result.";
    }
  }

  grouping live_ncs_check-sync-grouping {
    tailf:action check-sync {
      tailf:actionpoint ncsproxy {
        tailf:internal;
      }
      description
        "Check if the NCS copy of the device configurations is in sync
         with the actual device configurations, using device-specific
         mechanisms. This operation is usually cheap as it only
         compares a signature of the configuration from the
         device rather than comparing the entire configuration.

         Depending on the device the signature is implemented as a
         transaction-id, timestamp, hash-sum or not at all.
         The capability must be supported by the corresponding
         NED. The output might say unsupported, and then the only way
         to perform this would be to do a full 'compare-config' command.

         As some NEDs implements the signature as an hash-sum
         of the entire configuration, this operation might for
         some devices be just as expensive as performing a full
         compare-config command.

         If the wait-for-lock parameter is not given, the wait-for-lock
         device setting is going to be used.";
      tailf:info
        "Check if the NCS config is in sync with the device";
      // NCS drop tailf:actionpoint
      input {
        leaf suppress-positive-result {
          type empty;
          description
            "Use this additional parameter to only return
             devices not in sync.";
        }
        uses live_ncs_wait-for-lock;
      }
      output {
        list sync-result {
          key "device";
          leaf device {
            type leafref {
              path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/device/name" {
                tailf:xpath-root 3;
              }
            }
          }
          uses live_ncs_check-sync-result;
        }
      }
    }
  }

  grouping live_ncs_check-sync-grouping-extended {
    tailf:action check-sync {
      tailf:actionpoint ncsproxy {
        tailf:internal;
      }
      description
        "Check if the NCS copy of the device configurations is in sync
         with the actual device configurations, using device-specific
         mechanisms. This operation is usually cheap as it only
         compares a signature of the configuration from the
         device rather than comparing the entire configuration.

         Depending on the device the signature is implemented as a
         transaction-id, timestamp, hash-sum or not at all.
         The capability must be supported by the corresponding
         NED. The output might say unsupported, and then the only way
         to perform this would be to do a full 'compare-config' command.

         As some NEDs implements the signature as an hash-sum
         of the entire configuration, this operation might for
         some devices be just as expensive as performing a full
         compare-config command.

         If the wait-for-lock parameter is not given, the wait-for-lock
         device setting is going to be used.";
      tailf:info
        "Check if the NCS config is in sync with the device";
      // NCS drop tailf:actionpoint
      input {
        leaf suppress-positive-result {
          type empty;
          description
            "Use this additional parameter to only return
             devices not in sync.";
        }
        uses live_ncs_wait-for-lock;
        leaf-list device {
          tailf:info
            "Only check-sync these devices.";
          type leafref {
            path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/device/name" {
              tailf:xpath-root 3;
            }
          }
        }
      }
      output {
        list sync-result {
          key "device";
          leaf device {
            type leafref {
              path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/device/name" {
                tailf:xpath-root 3;
              }
            }
          }
          uses live_ncs_check-sync-result;
        }
      }
    }
  }

  grouping live_ncs_check-sync-result {
    description
      "Common result data from a 'check-sync' action.";
    leaf result {
      type enumeration {
        enum "unknown" {
          description
            "NCS has no record, probably because no
             sync actions has been executed towards the device
             or it was cleared after a no-out-of-sync-check commit.
             This is also the initial state for a device.";
        }
        enum "locked" {
          tailf:code-name "sync_locked";
          description
            "The device is administratively locked, meaning that NCS
             cannot talk to it.";
        }
        enum "in-sync" {
          tailf:code-name "in-sync-result";
          description
            "The configuration on the device is in sync with NCS.";
        }
        enum "out-of-sync" {
          description
            "The device configuration is known to be out of sync, i.e.,
             it has been reconfigured out of band.";
        }
        enum "unsupported" {
          description
            "The device doesn't have any mechanism to do a cheap
             check-sync, or this mechanism has been disabled.";
        }
        enum "error" {
          tailf:code-name "sync-error";
          description
            "An error occurred when NCS tried to check the sync status.
             The leaf 'info' contains additional information.";
        }
      }
    }
    leaf info {
      type string;
      description
        "If present, contains additional information about the result.";
    }
  }

  grouping live_ncs_sync-to-grouping {
    tailf:action sync-to {
      tailf:actionpoint ncsproxy {
        tailf:internal;
      }
      description
        "Synchronize the configuration by pushing to all unlocked devices.

         By default, NCS pushes a minimal diff to the devices.  The
         diff is calculated by reading the configuration from the
         devices and comparing with the configuration in NCS.

         For NETCONF devices, NCS can optionally replace the
         configuration on the devices by sending its own configuration
         without calculating the diff.  Note that NCS will send an
         <edit-config> with the 'replace' option in this case.  This
         means that configuration subtrees that NCS does not know
         about are not replaced.

         If the dry-run option is used, NCS will just report what it
         will do do instead of doing it.

         If the wait-for-lock parameter is not given, the wait-for-lock
         device setting is going to be used.";
      tailf:info
        "Synchronize the config by pushing to the devices";
      // NCS drop tailf:actionpoint
      input {
        leaf suppress-positive-result {
          type empty;
          description
            "Use this additional parameter to only return
             devices that failed to sync.";
        }
        leaf mode {
          type enumeration {
            enum "replace";
          }
          description
            "For NETCONF devices, replace the device configurations
             with the NCS configurations, instead of sending the diff.

             Cannot be used with non-NETCONF devices.";
        }
        container dry-run {
          presence "";
          leaf outformat {
            type live_ncs_outformat3;
            description
              "Report what would be done towards the device, without
               actually doing anything.";
          }
        }
        uses live_ncs_wait-for-lock;
      }
      output {
        list sync-result {
          key "device";
          leaf device {
            type leafref {
              path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/device/name" {
                tailf:xpath-root 3;
              }
            }
          }
          uses live_ncs_sync-to-result;
        }
      }
    }
  }

  grouping live_ncs_sync-to-grouping-extended {
    tailf:action sync-to {
      tailf:actionpoint ncsproxy {
        tailf:internal;
      }
      description
        "Synchronize the configuration by pushing to all unlocked devices.

         By default, NCS pushes a minimal diff to the devices.  The
         diff is calculated by reading the configuration from the
         devices and comparing with the configuration in NCS.

         For NETCONF devices, NCS can optionally replace the
         configuration on the devices by sending its own configuration
         without calculating the diff.  Note that NCS will send an
         <edit-config> with the 'replace' option in this case.  This
         means that configuration subtrees that NCS does not know
         about are not replaced.

         If the dry-run option is used, NCS will just report what it
         will do do instead of doing it.

         If the wait-for-lock parameter is not given, the wait-for-lock
         device setting is going to be used.";
      tailf:info
        "Synchronize the config by pushing to the devices";
      // NCS drop tailf:actionpoint
      input {
        leaf suppress-positive-result {
          type empty;
          description
            "Use this additional parameter to only return
             devices that failed to sync.";
        }
        leaf mode {
          type enumeration {
            enum "replace";
          }
          description
            "For NETCONF devices, replace the device configurations
             with the NCS configurations, instead of sending the diff.

             Cannot be used with non-NETCONF devices.";
        }
        container dry-run {
          presence "";
          leaf outformat {
            type live_ncs_outformat3;
            description
              "Report what would be done towards the device, without
               actually doing anything.";
          }
        }
        uses live_ncs_wait-for-lock;
        leaf-list device {
          tailf:info
            "Only sync to these devices.";
          type leafref {
            path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/device/name" {
              tailf:xpath-root 3;
            }
          }
        }
      }
      output {
        list sync-result {
          key "device";
          leaf device {
            type leafref {
              path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/device/name" {
                tailf:xpath-root 3;
              }
            }
          }
          uses live_ncs_sync-to-result;
        }
      }
    }
  }

  grouping live_ncs_sync-to-result {
    description
      "Common result data from a 'sync-to' action.";
    choice outformat {
      leaf result {
        type boolean;
      }
      anyxml result-xml;
      leaf cli {
        tailf:cli-preformatted;
        type string;
      }
      leaf native {
        tailf:cli-preformatted;
        type string;
      }
    }
    leaf info {
      type string;
      description
        "If present, contains additional information about the result.";
    }
  }

  grouping live_ncs_sync-from-grouping {
    tailf:action sync-from {
      tailf:actionpoint ncsproxy {
        tailf:internal;
      }
      description
        "Synchronize the configuration by pulling from all unlocked
         devices.

         If the wait-for-lock parameter is not given, the wait-for-lock
         device setting is going to be used.";
      tailf:info
        "Synchronize the config by pulling from the devices";
      // NCS drop tailf:actionpoint
      input {
        leaf suppress-positive-result {
          type empty;
          description
            "Use this additional parameter to only return
             devices that failed to sync.";
        }
        container dry-run {
          presence "";
          leaf outformat {
            type live_ncs_outformat2;
            description
              "Report what would be done towards CDB, without
               actually doing anything.";
          }
        }
        leaf verbose {
          type empty;
          description
            "Use this to show additional parse information if supported
             by the NED.";
        }
        uses live_ncs_wait-for-lock;
      }
      output {
        uses live_ncs_sync-from-output;
      }
    }
  }

  grouping live_ncs_sync-from-grouping-extended {
    tailf:action sync-from {
      tailf:actionpoint ncsproxy {
        tailf:internal;
      }
      description
        "Synchronize the configuration by pulling from all unlocked
         devices.

         If the wait-for-lock parameter is not given, the wait-for-lock
         device setting is going to be used.";
      tailf:info
        "Synchronize the config by pulling from the devices";
      // NCS drop tailf:actionpoint
      input {
        leaf suppress-positive-result {
          type empty;
          description
            "Use this additional parameter to only return
             devices that failed to sync.";
        }
        container dry-run {
          presence "";
          leaf outformat {
            type live_ncs_outformat2;
            description
              "Report what would be done towards CDB, without
               actually doing anything.";
          }
        }
        leaf verbose {
          type empty;
          description
            "Use this to show additional parse information if supported
             by the NED.";
        }
        uses live_ncs_wait-for-lock;
        leaf-list device {
          tailf:info
            "Only sync from these devices.";
          type leafref {
            path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/device/name" {
              tailf:xpath-root 3;
            }
          }
        }
      }
      output {
        uses live_ncs_sync-from-output;
      }
    }
  }

  grouping live_ncs_sync-from-output {
    list sync-result {
      key "device";
      leaf device {
        type leafref {
          path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/device/name" {
            tailf:xpath-root 3;
          }
        }
      }
      uses live_ncs_sync-result;
    }
  }

  grouping live_ncs_sync-result {
    description
      "Common result data from a 'sync' action.";
    choice outformat {
      leaf result {
        type boolean;
      }
      anyxml result-xml;
      leaf cli {
        tailf:cli-preformatted;
        type string;
      }
    }
    leaf info {
      type string;
      description
        "If present, contains additional information about the result.";
    }
  }

  grouping live_ncs_wait-for-lock {
    choice wait-for-lock-choice {
      description
        "Wait for device lock setting.";
      leaf no-wait-for-lock {
        type empty;
        description
          "The action can't be performed while the device is being
           committed to (or waiting in the commit queue). This is to avoid
           getting inconsistent data when reading the configuration.
           This specifies that the action should not wait for device lock,
           instead, it should immediately fail if the device is being locked.";
      }
      container wait-for-lock {
        presence "Wait for device lock.";
        description
          "The action can't be performed while the device is being
           committed to (or waiting in the commit queue). This is to avoid
           getting inconsistent data when reading the configuration.
           This specifies a timeout to wait for a device lock to be placed
           in the commit queue. The lock will be automatically released once
           the action has been executed.";
        choice timeout-choice {
          // NCS drop default statement
          leaf timeout {
            type uint32 {
              range "0..4294967";
            }
            units "seconds";
            description
              "Specifies a maximum number of seconds to wait for the
               device to be locked.";
          }
          leaf infinity {
            description
              "Wait infinitely for the lock, this is the default.";
            type empty;
          }
        }
      }
    }
  }

  grouping live_ncs_disconnect-grouping {
    tailf:action disconnect {
      tailf:actionpoint ncsproxy {
        tailf:internal;
      }
      description
        "Close all sessions to all devices.";
      tailf:info
        "Close all sessions to all devices";
      // NCS drop tailf:actionpoint
      input;
    }
  }

  grouping live_ncs_disconnect-grouping-specific {
    tailf:action disconnect {
      tailf:actionpoint ncsproxy {
        tailf:internal;
      }
      description
        "Close all sessions to the device.";
      tailf:info
        "Close all sessions to the device";
      // NCS drop tailf:actionpoint
      input;
    }
  }

  grouping live_ncs_disconnect-grouping-extended {
    tailf:action disconnect {
      tailf:actionpoint ncsproxy {
        tailf:internal;
      }
      description
        "Close all sessions to all devices.";
      tailf:info
        "Close all sessions to all devices";
      // NCS drop tailf:actionpoint
    }
  }

  grouping live_ncs_check-yang-modules-grouping {
    tailf:action check-yang-modules {
      tailf:actionpoint ncsproxy {
        tailf:internal;
      }
      description
        "Check if the device YANG modules loaded by NCS
         have revisions that are compatible with the ones reported
         by the devices.";
      tailf:info
        "Check if NCS and the devices have compatible YANG modules";
      // NCS drop tailf:actionpoint
      input {
        leaf verbose {
          type empty;
          description
            "Use this to show additional compatibility info.";
        }
        leaf suppress-positive-result {
          type empty;
          description
            "Use this to only return devices that have incompatible
             modules.";
        }
      }
      output {
        list device {
          key "name";
          leaf name {
            type leafref {
              path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/device/name" {
                tailf:xpath-root 3;
              }
            }
            description
              "Device for which a revision compatibility
               check has been performed.";
          }
          uses live_ncs_check-yang-modules-result;
        }
      }
    }
  }

  grouping live_ncs_check-yang-modules-grouping-extended {
    tailf:action check-yang-modules {
      tailf:actionpoint ncsproxy {
        tailf:internal;
      }
      description
        "Check if the device YANG modules loaded by NCS
         have revisions that are compatible with the ones reported
         by the devices.";
      tailf:info
        "Check if NCS and the devices have compatible YANG modules";
      // NCS drop tailf:actionpoint
      input {
        leaf verbose {
          type empty;
          description
            "Use this to show additional compatibility info.";
        }
        leaf suppress-positive-result {
          type empty;
          description
            "Use this to only return devices that have incompatible
             modules.";
        }
        leaf-list device {
          tailf:info
            "Specification of devices for which a module revision
             compatibility check should be performed.";
          type leafref {
            path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/device/name" {
              tailf:xpath-root 3;
            }
          }
        }
      }
      output {
        list device {
          key "name";
          leaf name {
            type leafref {
              path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/device/name" {
                tailf:xpath-root 3;
              }
            }
            description
              "Device for which a revision compatibility
               check has been performed.";
          }
          uses live_ncs_check-yang-modules-result;
        }
      }
    }
  }

  grouping live_ncs_check-yang-modules-result {
    description
      "Common result data from a 'check-yang-modules' action.";
    choice compat-res {
      case silent {
        description
          "Present in non-verbose mode.";
        leaf compatible {
          type boolean;
          description
            "Reporting if a device is revision compatible true/false
             in non-verbose mode.";
        }
      }
      case verbose {
        list module {
          description
            "In verbose mode, this is the list of the supported modules for
             a device which are reported as capabilities.";
          key "name";
          leaf name {
            type string;
            description
              "YANG module";
          }
          leaf status {
            description
              "Compatibility status for the YANG module.";
            type enumeration {
              enum "supported" {
                tailf:code-name "module-supported";
                description
                  "Implies that NCS has loaded the yang module with
                   the same revision or a revision of newer date.";
              }
              enum "unsupported" {
                tailf:code-name "module-unsupported";
                description
                  "Implies that NCS has loaded the yang module but the
                   revision is to old.";
              }
              enum "not-loaded" {
                tailf:code-name "module-not-loaded";
                description
                  "Implies that NCS has not loaded the yang module.";
              }
              enum "unknown" {
                tailf:code-name "module-unknown";
                description
                  "that NCS has loaded the module but the revision
                   information was not available for comparison.";
              }
            }
          }
          leaf device-revision {
            type string;
            description
              "Live device reported revision for the module";
          }
          leaf ncs-revision {
            type string;
            description
              "NCS loaded YANG module revision";
          }
        }
      }
    }
  }

  grouping live_ncs_fetch-ssh-host-keys-grouping {
    tailf:action fetch-ssh-host-keys {
      tailf:actionpoint ncsproxy {
        tailf:internal;
      }
      tailf:info
        "Retrieve SSH host keys from all devices";
      description
        "Retrieve the SSH host keys from all devices, or all devices in the
         given device group, and store them in each device's ssh/host-key
         list. Successfully retrieved new or updated keys are always
         committed by the action.";
      // NCS drop tailf:actionpoint
      input {
        leaf suppress-positive-result {
          tailf:info
            "Only return result if key retrieval failed";
          type empty;
          description
            "If this optional parameter is included, results are only
             returned for devices where key retrieval failed.";
        }
        leaf suppress-unchanged-result {
          tailf:info
            "Do not return result if keys are unchanged";
          type empty;
          description
            "If this optional parameter is included, no results are returned
             for devices which have the same keys as those already known.";
        }
        leaf suppress-fingerprints {
          tailf:info
            "Do not return key fingerprints";
          type empty;
          description
            "If this optional parameter is included, key fingerprints are
             not included in the results.";
        }
      }
      output {
        list fetch-result {
          description
            "This is a list of key retrieval results, each entry pertains
             to one device.";
          key "device";
          leaf device {
            type leafref {
              path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/device/name" {
                tailf:xpath-root 3;
              }
            }
            description
              "The name of the device.";
          }
          uses live_ncs_fetch-ssh-host-keys-result;
        }
      }
    }
  }

  grouping live_ncs_fetch-ssh-host-keys-grouping-extended {
    tailf:action fetch-ssh-host-keys {
      tailf:actionpoint ncsproxy {
        tailf:internal;
      }
      tailf:info
        "Retrieve SSH host keys from all devices";
      description
        "Retrieve the SSH host keys from all devices, or all devices in the
         given device group, and store them in each device's ssh/host-key
         list. Successfully retrieved new or updated keys are always
         committed by the action.";
      // NCS drop tailf:actionpoint
      input {
        leaf suppress-positive-result {
          tailf:info
            "Only return result if key retrieval failed";
          type empty;
          description
            "If this optional parameter is included, results are only
             returned for devices where key retrieval failed.";
        }
        leaf suppress-unchanged-result {
          tailf:info
            "Do not return result if keys are unchanged";
          type empty;
          description
            "If this optional parameter is included, no results are returned
             for devices which have the same keys as those already known.";
        }
        leaf suppress-fingerprints {
          tailf:info
            "Do not return key fingerprints";
          type empty;
          description
            "If this optional parameter is included, key fingerprints are
             not included in the results.";
        }
        leaf-list device {
          tailf:info
            "Only fetch host keys from these devices.";
          type leafref {
            path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/device/name" {
              tailf:xpath-root 3;
            }
          }
        }
      }
      output {
        list fetch-result {
          description
            "This is a list of key retrieval results, each entry pertains
             to one device.";
          key "device";
          leaf device {
            type leafref {
              path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/device/name" {
                tailf:xpath-root 3;
              }
            }
            description
              "The name of the device.";
          }
          uses live_ncs_fetch-ssh-host-keys-result;
        }
      }
    }
  }

  grouping live_ncs_apply-template-grouping {
    tailf:action apply-template {
      tailf:actionpoint ncsproxy {
        tailf:internal;
      }
      tailf:info
        "Take a named template and apply it here";
      description
        "Take a named template and apply its configuration here.

         This action will behave differently depending on if it is
         invoked with a transaction or not. When invoked with a
         transaction (such as via the CLI) it will apply the
         template to it and leave it to the user to commit or
         revert the resulting changes. If invoked without a
         transaction (for example when invoked via RESTCONF),
         the action will automatically create one and commit the
         resulting changes. An error will be returned and the
         transaction aborted if the template failed to apply
         on any of the devices.

         This grouping is used inside managed devices, and in
         device groups.";
      tailf:cli-configure-mode;
      // NCS drop tailf:actionpoint
      input {
        leaf template-name {
          type leafref {
            path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/template/name" {
              tailf:xpath-root 3;
            }
          }
          mandatory true;
        }
        list variable {
          key "name";
          leaf name {
            tailf:cli-completion-actionpoint template-variable;
            type string {
              tailf:info
                "The name of the XPath variable as used in the template";
            }
            mandatory true;
          }
          leaf value {
            type union {
              type string {
                tailf:info
                  "quoted;;some text enclosed in single quotes. This
                   is an XPath string.";
              }
              type string {
                tailf:info
                  "number;;some integer or float number. This is an XPath
                   number.";
              }
              type yang:xpath1.0 {
                tailf:info
                  "node set;;an XPath expression resulting in a node set";
              }
            }
            mandatory true;
          }
        }
        leaf suppress-positive-result {
          tailf:info
            "Only return result if some error occurred";
          type empty;
          description
            "If this optional parameter is included, results are only
             returned for devices where some error occurred.";
        }
        leaf accept-empty-capabilities {
          tailf:info
            "Apply template to devices with no capabilities known";
          type empty;
          description
            "If this optional parameter is included, the template
             is applied to devices even if the capability of the device
             is unknown.";
        }
        container dry-run {
          tailf:hidden "programmatic-interface";
          presence "";
          leaf outformat {
            type live_ncs_outformat3;
          }
        }
        uses live_ncs_ncs-hidden-commit-params;
      }
      output {
        list apply-template-result {
          key "device";
          leaf device {
            type leafref {
              path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/device/name" {
                tailf:xpath-root 3;
              }
            }
          }
          leaf result {
            type enumeration {
              enum "ok" {
                tailf:code-name "apply_template_ok";
                description
                  "The template was applied with success";
              }
              enum "no-capabilities" {
                tailf:code-name "apply_template_no_capabilities";
                description
                  "One or more of the affected devices has no known
                   capabilities. This occures when NCS has not synced
                   from the device";
              }
              enum "no-namespace" {
                tailf:code-name "apply_template_no_namespace";
                description
                  "One or more of the affected devices has no matching
                   namespace in the template.";
              }
            }
          }
          leaf info {
            type string;
            description
              "If present, contains additional information
               about the result.";
          }
        }
        choice outformat {
          case case-xml {
            uses live_ncs_dry-run-xml;
          }
          case case-cli {
            uses live_ncs_dry-run-cli;
          }
          case case-native {
            uses live_ncs_dry-run-native;
          }
        }
        uses live_ncs_ncs-commit-result;
      }
    }
  }

  grouping live_ncs_apply-template-grouping-extended {
    tailf:action apply-template {
      tailf:actionpoint ncsproxy {
        tailf:internal;
      }
      tailf:info
        "Take a named template and apply it here";
      description
        "Take a named template and apply its configuration here.

         This action will behave differently depending on if it is
         invoked with a transaction or not. When invoked with a
         transaction (such as via the CLI) it will apply the
         template to it and leave it to the user to commit or
         revert the resulting changes. If invoked without a
         transaction (for example when invoked via RESTCONF),
         the action will automatically create one and commit the
         resulting changes. An error will be returned and the
         transaction aborted if the template failed to apply
         on any of the devices.";
      tailf:cli-configure-mode;
      // NCS drop tailf:actionpoint
      input {
        leaf template-name {
          type leafref {
            path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/template/name" {
              tailf:xpath-root 3;
            }
          }
          mandatory true;
        }
        list variable {
          key "name";
          leaf name {
            tailf:cli-completion-actionpoint template-variable;
            type string {
              tailf:info
                "The name of the XPath variable as used in the template";
            }
            mandatory true;
          }
          leaf value {
            type union {
              type string {
                tailf:info
                  "quoted;;some text enclosed in single quotes. This
                   is an XPath string.";
              }
              type string {
                tailf:info
                  "number;;some integer or float number. This is an XPath
                   number.";
              }
              type yang:xpath1.0 {
                tailf:info
                  "node set;;an XPath expression resulting in a node set";
              }
            }
            mandatory true;
          }
        }
        leaf suppress-positive-result {
          tailf:info
            "Only return result if some error occurred";
          type empty;
          description
            "If this optional parameter is included, results are only
             returned for devices where some error occurred.";
        }
        leaf accept-empty-capabilities {
          tailf:info
            "Apply template to devices with no capabilities known";
          type empty;
          description
            "If this optional parameter is included, the template
             is applied to devices even if the capability of the device
             is unknown.";
        }
        leaf-list device {
          tailf:info
            "Only apply template configuration to these devices.";
          type leafref {
            path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/device/name" {
              tailf:xpath-root 3;
            }
          }
          min-elements 1;
        }
        container dry-run {
          tailf:hidden "programmatic-interface";
          presence "";
          leaf outformat {
            type live_ncs_outformat3;
          }
        }
        uses live_ncs_ncs-hidden-commit-params;
      }
      output {
        list apply-template-result {
          key "device";
          leaf device {
            type leafref {
              path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/device/name" {
                tailf:xpath-root 3;
              }
            }
          }
          leaf result {
            type enumeration {
              enum "ok" {
                tailf:code-name "apply_template_ok";
                description
                  "The template was applied with success";
              }
              enum "no-capabilities" {
                tailf:code-name "apply_template_no_capabilities";
                description
                  "One or more of the affected devices has no known
                   capabilities. This occures when NCS has not synced
                   from the device";
              }
              enum "no-namespace" {
                tailf:code-name "apply_template_no_namespace";
                description
                  "One or more of the affected devices has no matching
                   namespace in the template.";
              }
            }
          }
          leaf info {
            type string;
            description
              "If present, contains additional information
               about the result.";
          }
        }
        choice outformat {
          case case-xml {
            uses live_ncs_dry-run-xml;
          }
          case case-cli {
            uses live_ncs_dry-run-cli;
          }
          case case-native {
            uses live_ncs_dry-run-native;
          }
        }
        uses live_ncs_ncs-commit-result;
      }
    }
  }

  grouping live_ncs_migrate-grouping {
    tailf:action migrate {
      tailf:actionpoint ncsproxy {
        tailf:internal;
      }
      description
        "Change the NED identity and migrate all data. Reads and commits
         the actual device configuration as a side-effect.

         The action reports what paths have been modified and the services
         affected by those changes.

         If the wait-for-lock parameter is not given, the wait-for-lock
         device setting is going to be used.";
      tailf:info
        "Migrate the devices to a new NED type";
      // NCS drop tailf:actionpoint
      input {
        leaf new-ned-id {
          tailf:info
            "The new NED Identity";
          // NCS patched to string, due to LSA partial NED
          type string;
          mandatory true;
        }
        leaf no-networking {
          type empty;
          description
            "Do not generate any southbound traffic towards the
             devices. Use the device configuration in CDB.";
        }
        choice display-mode {
          case display-result {
            leaf dry-run {
              type empty;
            }
            leaf verbose {
              tailf:info
                "Report all service instances";
              description
                "Report all service instances instead of just the
                 service points.";
              type empty;
            }
          }
          leaf suppress-positive-result {
            tailf:info
              "Only return result if some error occurred";
            type empty;
            description
              "If this optional parameter is included, result is only
               returned if an error occurs.";
          }
        }
        uses live_ncs_wait-for-lock;
      }
      output {
        list migrate-result {
          key "device";
          leaf device {
            type leafref {
              path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/device/name" {
                tailf:xpath-root 3;
              }
            }
          }
          leaf result {
            type boolean;
          }
          leaf info {
            type string;
            description
              "If present, contains additional information about the result.";
          }
        }
        uses live_ncs_migrate-result;
      }
    }
  }

  grouping live_ncs_migrate-grouping-extended {
    tailf:action migrate {
      tailf:actionpoint ncsproxy {
        tailf:internal;
      }
      description
        "Change the NED identity and migrate all data. Reads and commits
         the actual device configuration as a side-effect.

         The action reports what paths have been modified and the services
         affected by those changes.

         If the wait-for-lock parameter is not given, the wait-for-lock
         device setting is going to be used.";
      tailf:info
        "Migrate the matching devices to a new NED type";
      // NCS drop tailf:actionpoint
      input {
        leaf new-ned-id {
          tailf:info
            "The new NED identity";
          // NCS patched to string, due to LSA partial NED
          type string;
          mandatory true;
        }
        leaf old-ned-id {
          tailf:info
            "Only migrate devices with this NED identity";
          description
            "Only migrate devices with this NED identity.";
          // NCS patched to string, due to LSA partial NED
          type string;
          mandatory true;
        }
        leaf-list device {
          tailf:info
            "Only migrate these devices.";
          description
            "Only migrate these devices. Devices that are configured
             with NED identities that doesn't match the old-ned-id
             will be ignored.";
          type leafref {
            path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/device/name" {
              tailf:xpath-root 3;
            }
          }
        }
        leaf no-networking {
          type empty;
          description
            "Do not generate any southbound traffic towards the
             devices. Use the device configuration in CDB.";
        }
        choice display-mode {
          case display-result {
            leaf dry-run {
              type empty;
            }
            leaf verbose {
              tailf:info
                "Report all service instances";
              description
                "Report all service instances instead of just the
                 service points.";
              type empty;
            }
          }
          leaf suppress-positive-result {
            tailf:info
              "Only return result if some error occurred";
            type empty;
            description
              "If this optional parameter is included, result is only
               returned if an error occurs.";
          }
        }
        uses live_ncs_wait-for-lock;
      }
      output {
        list migrate-result {
          key "device";
          leaf device {
            type leafref {
              path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/device/name" {
                tailf:xpath-root 3;
              }
            }
          }
          leaf result {
            type boolean;
          }
          leaf info {
            type string;
            description
              "If present, contains additional information about the result.";
          }
        }
        uses live_ncs_migrate-result;
      }
    }
  }

  grouping live_ncs_migrate-result {
    list modified-path {
      leaf path {
        description
          "The path below /devices/device/config that has been modified.";
        type yang:xpath1.0;
      }
      leaf info {
        description
          "Description of what has changed on the path.";
        type string;
      }
    }
    leaf-list affected-services {
      description
        "The service instances/points that are affected by the data
         model changes on the migrated device.";
      type string;
    }
  }

  grouping live_ncs_location {
    container location {
      description
        "Physical location of devices in the group";
      leaf name {
        type string;
        description
          "An arbitrary name of the location.";
      }
      leaf latitude {
        type decimal64 {
          range "-90..90";
          fraction-digits 6;
        }
        units "decimal degrees";
        description
          "The latitude according to WGS-84, in decimal degrees.";
      }
      leaf longitude {
        type decimal64 {
          range "-180..180";
          fraction-digits 6;
        }
        units "decimal degrees";
        description
          "The longitude according to WGS-84, in decimal degrees.";
      }
      leaf altitude {
        type int32;
        units "meters";
        description
          "The altitude according to WGS-84, in meters.";
      }
    }
  }

  grouping live_ncs_queue-item-status {
    leaf status {
      // NCS drop tailf:display-groups
      type enumeration {
        enum "waiting" {
          description
            "The queue item is waiting to run.  This state means
             that there is some other item in the queue, ahead of this item.";
        }
        enum "executing" {
          description
            "The queue item is currently executing.

             Transient errors might be present. These errors occur when NCS
             fails to communicate with some of the devices. The errors are
             shown in the 'transient-errors' leaf-list.

             Retries will take place at intervals a specified in
             /devices/global-settings/commit-queue/retry-timeout.

             Examples of transient errors are connection failures
             and that the changes are rejected due to the device
             being locked.

             Transient errors are potentially bad, since the queue might
             grow if new items are added, waiting for the same device.";
        }
        enum "locked" {
          description
            "This queue item is locked and will not be processed until it has
             been unlocked, see the action
             '/devices/commit-queue/queue-item/unlock'.

             A locked queue-item will block all subsequent queue-items
             which are using any device in the locked queue item.";
          tailf:code-name "qi_locked";
        }
        enum "blocked" {
          description
            "The queue item is waiting in the queue, and some other
             queue item ahead of this item is in state 'locked' or 'executing'
             with transient errors.";
        }
        enum "waiting-not-master" {
          description
            "HA is enabled, but we have not yet entered the master
             state, no provisioning can be done through the commit
             queue unless we are master.";
        }
        enum "locked-not-master" {
          description
            "HA is enabled, but we have not yet entered the master
             state, no provisioning can be done through the commit
             queue unless we are master.";
        }
        enum "blocked-not-master" {
          description
            "HA is enabled, but we have not yet entered the master
             state, no provisioning can be done through the commit
             queue unless we are master.";
        }
      }
      description
        "What is NCS currently doing with this queue item.
         If the status is idle, it means that the item is waiting
         for another queue item where one of the devices is
         not running, i.e., it's not possible to connect to that
         device.";
    }
  }

  grouping live_ncs_commit-queue-basic-options {
    choice operation-mode {
      leaf async {
        type empty;
        description
          "Commit the transaction data asynchronously to the commit queue.
           This flag is useful when some device is non-operational or
           has data waiting in the commit queue.

           The operation returns successfully if the transaction data has
           been successfully placed in the queue. The leaf
           'commit-queue/id' is set as the queue identifier and the
           leaf 'commit-queue/status' is set to 'async' in the result.";
      }
      container sync {
        presence "Commit through the commit queue and wait for completion";
        description
          "Commit the transaction data synchronously to the commit queue.

           The operation does not return until the transaction data has
           been sent to all devices, or a timeout occurs. The leaf
           'commit-queue/id' is set as the queue identifier and the
           leaf 'commit-queue/status' is set to 'completed', 'failed',
           'deleted' or 'timeout' dependent of the outcome.

           If no device is involved in the transaction, the operation
           returns directly.";
        choice timeout-choice {
          leaf timeout {
            type uint32 {
              range "0..4294967";
            }
            units "seconds";
            description
              "Specifies a maximum number of seconds to wait for the
               transaction to be committed. If the timer expires, the
               transaction is kept in the commit-queue, and the operation
               returns successfully. The leaf 'commit-queue/status'
               is set to 'timeout', and the leaf 'commit-queue/id' is
               set to the queue identifier in the result.";
          }
          leaf infinity {
            description
              "Wait infinitely for the transaction to be committed.";
            type empty;
          }
        }
      }
      // NCS drop default statement
    }
  }

  grouping live_ncs_commit-queue-options {
    uses live_ncs_commit-queue-basic-options {
      augment "operation-mode" {
        leaf bypass {
          type empty;
          description
            "This flag means that if
             /devices/commit-queue/enabled-by-default is 'true' the
             data in this transaction will bypass the commit queue.
             The data will be written directly to the devices.";
        }
      }
    }
    leaf block-others {
      type empty;
      description
        "The resulting queue item will block subsequent queue items,
         which use any of the devices in this queue item, from
         being queued.";
    }
    leaf lock {
      type empty;
      description
        "Place a lock on the resulting queue item. The queue
         item will not be processed until it has been unlocked,
         see the actions 'unlock' and 'lock' in
         /devices/commit-queue/queue-item'.

         No following queue items, using the same devices, will be
         allowed to execute as long as the lock is in place.";
    }
    leaf atomic {
      type boolean;
      description
        "Sets the atomic behaviour of the resulting queue item.
         If this is set to false, the devices contained in the
         resulting queue item can start executing if the same devices
         in other non-atomic queue items ahead of it in the queue are
         completed. If set to true, the atomic integrity of the
         queue item is preserved.";
    }
  }

  grouping live_ncs_authgroup-callback-input-params {
    description
      "When /devices/authgroups/group/[name]/umap/[local-user]/callback-node
       and /devices/authgroups/group/[name]/umap/[local-user]/action-name
       is set, the action that is defined by action-name in the specified
       callback-node must use this grouping as input parameters.";
    leaf local-user {
      type string;
    }
    leaf authgroup {
      type string;
    }
    leaf device {
      type string;
    }
  }

  grouping live_ncs_authgroup-callback-output-params {
    description
      "When /devices/authgroups/group/[name]/umap/[local-user]/callback-node
       and /devices/authgroups/group/[name]/umap/[local-user]/action-name
       is set, the action that is defined by action-name in the specified
       callback-node must use this grouping as output parameters.";
    leaf remote-user {
      type string;
    }
    leaf remote-password {
      type string;
    }
    leaf remote-secondary-password {
      type string;
    }
  }

  grouping live_ncs_notifications {
    list subscription {
      tailf:info
        "List of subscriptions";
      key "name";
      description
        "A list of our notification subscriptions for this managed device.";
      leaf name {
        type string;
        description
          "Each subscription must have a unique name.";
      }
      leaf stream {
        tailf:info
          "The notification stream name";
        type string;
        // NCS drop mandatory statement
        description
          "The name of the notification stream this subscription
           refers to.";
      }
      choice filter {
        description
          "Optional element, if not set, no filters are applied.";
        case xpath {
          leaf xpath {
            tailf:info
              "XPath filter for the notifications";
            type yang:xpath1.0;
          }
        }
        case subtree {
          leaf subtree {
            tailf:info
              "Subtree filter for the notifications";
            type string;
          }
        }
      }
      leaf local-user {
        type string;
        // NCS drop mandatory statement
        description
          "The local user is used when setting up a device
           connection.";
      }
      leaf store-in-cdb {
        tailf:info
          "Store notifications in CDB";
        type boolean;
        // NCS drop default statement
        description
          "Indicate whether notifications should be stored as
           operational data in CDB.

           When notifications are generated at a high rate,
           storage consumes lots of resources. In cases like that,
           consider using the device-notification event stream
           instead.";
      }
      leaf utilize-replay {
        tailf:info
          "Use replay when connecting to the device";
        type boolean;
        // NCS drop default statement
        description
          "If the device supports replay, should NCS attempt to use that
           when connecting to the device.";
      }
      leaf reconnect-interval {
        tailf:info
          "Interval for re-establishing the subscription";
        type uint32 {
          range "0..4294967";
        }
        units "seconds";
        // NCS drop default statement
        description
          "If the device is non operational, with which
           interval (in seconds) shall NCS attempt to re-establish
           the subscription.";
      }
      leaf status {
        type enumeration {
          enum "running" {
            description
              "The subscription is established and NCS should
               be receiving notifications.";
          }
          enum "connecting" {
            description
              "Attempting to establish the subscription.";
          }
          enum "failed" {
            tailf:code-name "notif-failed";
            description
              "The subscription has failed.  Unless the failure is
               in the connection establishing, i.e., connect
               failed, there will be no automatic re-connect.";
          }
        }
        // NCS drop default statement
        description
          "Is this subscription currently running.";
      }
      leaf failure-reason {
        type enumeration {
          enum "connection-refused" {
            description
              "Failed to connect to the device.";
          }
          enum "connection-timeout" {
            description
              "Timeout when connecting to the device.";
          }
          enum "session" {
            description
              "Failed to establish session.";
          }
          enum "subscribe" {
            description
              "The device rejected our subscription attempt.";
          }
          enum "xml" {
            tailf:code-name "notif-xml";
            description
              "NCS received XML that could not be parsed.";
          }
          enum "internal" {
            description
              "Internal NCS error.";
          }
          enum "disconnected" {
            description
              "Manually disconnected.";
          }
          enum "closed" {
            tailf:code-name "notif-closed";
            description
              "Server closed its end.";
          }
          enum "locked" {
            tailf:code-name "notif-locked";
            value 9;
            description
              "No subscriptions allowed towards devices that are
               locked or southbound locked.";
          }
          enum "auth-failed" {
            value 10;
            description
              "Device authentication failed.";
          }
          enum "same-pass" {
            tailf:code-name "notif-same-pass";
            value 11;
            description
              "Subscription is not allowed when 'same-pass' option is
               configured for authentication.";
          }
          enum "call-home" {
            tailf:code-name "notif-call-home";
            value 12;
            description
              "Subscription is not allowed until a call
               home connection has been established.";
          }
          enum "read-only" {
            tailf:code-name "notif-read-only";
            value 13;
            description
              "Subscription is not allowed until read-only
               mode is disabled and/or the mode of the HA node has
               changed.";
          }
          enum "session-limit-exceeded" {
            tailf:code-name "notif-session-limit-exceeded";
            value 14;
            description
              "The session limit has been exceeded.";
          }
        }
        description
          "If there is a problem with this subscription
           this leaf indicates what the problem is.";
        // NCS drop tailf:callpoint
      }
      leaf error-info {
        type string;
        description
          "Contains additional information, if available, when the
           status is not equal to 'running'.";
        // NCS drop tailf:callpoint
      }
      tailf:action reconnect {
        tailf:actionpoint ncsproxy {
          tailf:internal;
        }
        tailf:info
          "Attempt to reconnect this subscription";
        description
          "Attempt to reconnect this subscription.";
        // NCS drop tailf:actionpoint
      }
      tailf:action disconnect {
        tailf:actionpoint ncsproxy {
          tailf:internal;
        }
        tailf:info
          "Disconnect this subscription if connected";
        description
          "Disconnect this subscription if connected.";
        // NCS drop tailf:actionpoint
      }
      tailf:action replay {
        tailf:actionpoint ncsproxy {
          tailf:internal;
        }
        tailf:info
          "Replay (missed) notifications from the device";
        description
          "Ask the device to replay all notifications for this
           subscription.  Optionally if a timestamp is given, all
           notifications newer than the provided timestamp are
           requested.";
        // NCS drop tailf:actionpoint
        input {
          leaf from-date-time {
            type yang:date-and-time;
          }
        }
      }
    }
    list stream {
      key "name";
      description
        "A list of the notification streams provided by the device.
         NCS reads this list in realtime.";
      // NCS drop tailf:callpoint
      leaf name {
        type string;
        description
          "The name of the the stream.";
      }
      leaf description {
        type string;
        description
          "A textual description of the stream.";
      }
      leaf replay-support {
        type boolean;
        description
          "An indication of whether or not event replay
           is available on this stream.";
      }
      leaf replay-log-creation-time {
        type yang:date-and-time;
        description
          "The timestamp of the creation of the log used to support
           the replay function on this stream. Note that this might
           be earlier then the earliest available notification in the
           log. This object is updated if the log resets for some
           reason.";
      }
      leaf replay-log-aged-time {
        type yang:date-and-time;
        description
          "The timestamp of the last notification aged out of the log.";
      }
    }
    list notification-name {
      key "name";
      description
        "List of all names of notifications defined by this device.";
      // NCS drop tailf:callpoint
      leaf name {
        type string;
        description
          "The XML tag of the notification name.";
      }
      leaf uri {
        type string;
        description
          "The XML namespace uri for this notification.";
      }
    }
    container received-notifications {
      leaf max-size {
        type int32;
        // NCS drop default statement
        description
          "Max size of the list of received notifications.
           When the maximum size is reached, the oldest
           received notification is purged.";
      }
      leaf clear-time {
        type yang:date-and-time;
        // NCS drop tailf:cdb-oper
        description
          "When were notifications last cleared.";
      }
      tailf:action clear {
        tailf:actionpoint ncsproxy {
          tailf:internal;
        }
        description
          "Delete all received notifications from the
           'notification' list.";
        // NCS drop tailf:actionpoint
      }
      list notification {
        key "event-time sequence-no";
        description
          "A list of received notifications from the device.
           The list is a circular list, with a maximum size.
           When a new notification is added to the list, the oldest
           entry is purged.";
        // NCS drop tailf:cdb-oper
        leaf event-time {
          type yang:date-and-time;
          description
            "The time the event was generated at the device.";
        }
        leaf sequence-no {
          type int32;
        }
        leaf user {
          type string;
          description
            "User name of the user that created the subscription
             that made this notification end up here.";
        }
        leaf subscription {
          type string;
          description
            "The name of the subscription that made this
             notification end up here.";
        }
        leaf stream {
          type string;
          description
            "The name of the stream this notification belongs to.";
        }
        leaf received-time {
          type yang:date-and-time;
          description
            "The time the event was received at NCS.";
        }
        container data {
          // NCS drop tailf:mount-point
          description
            "This container is automatically augmented with notifications
             from the managed device. Whenever a device module
             that contains notifications is compiled, the device
             specific notifications end up here, as a container
             with the same name as the device notification.";
        }
      }
    }
  }

  grouping oper-state {
    // NCS drop config false leaf 'oper-state'
    // NCS drop config false leaf 'oper-state-error-tag'
    // NCS drop config false leaf 'oper-state-hash'
  }

  grouping ncs-commit-params {
    leaf no-revision-drop {
      type empty;
      description
        "This flags means that NCS will not run its data model revision
         algorithm, which requires all participating managed devices
         to have all parts of the data models for all data contained
         in this transaction. Thus, this flag forces NCS to never
         silently drop any data set operations towards a device.";
    }
    leaf no-networking {
      type empty;
      description
        "Do not send any data to the devices. Even if the transaction
         manipulates data below /devices/device/config, nothing will
         be sent to the managed devices. This is a way to manipulate
         CDB in NCS without generating any southbound traffic.";
    }
    choice choice-sync-check {
      case no-overwrite {
        leaf no-overwrite {
          type empty;
          description
            "This flags means that NCS will check that the data that
             should be modified has not changed on the device compared
             to NCS's view of the data. This is a fine-granular sync check;
             NCS verifies that NCS and the device is in sync regarding
             the data that will be modified. If they are not in sync,
             the transaction is aborted.";
        }
      }
      case no-out-of-sync-check {
        leaf no-out-of-sync-check {
          type empty;
          description
            "Continue with the transaction even if NCS detects that a device's
             configuration is out of sync. The device's sync state is assumed
             to be unknown after such commit and the stored transaction id
             value is cleared";
        }
      }
    }
    container commit-queue {
      presence "Commit through the commit queue";
      leaf tag {
        type string;
        description
          "User defined opaque tag.
           The tag is present in all notifications and events
           sent referencing the specific queue item.";
      }
      uses commit-queue-options;
      leaf error-option {
        type enumeration {
          enum "continue-on-error" {
            description
              "The commit queue will continue on errors. No rollback data
               will be created. This is the preferred choice when
               re-deploying a service as a re-deploy doesn't have a
               transaction intent.";
          }
          enum "rollback-on-error" {
            description
              "The commit queue items will roll back on errors. The commit
               queue will place a lock on the failed queue item, thus
               blocking other queue items with overlapping devices to be
               executed. The rollback action will then automatically be
               invoked when the failed queue item has finished its execution.
               The lock is removed as part of the rollback.";
          }
          enum "stop-on-error" {
            description
              "The commit queue will place a lock on the failed queue item,
               thus blocking other queue items with overlapping devices to
               be executed. The lock must then either manually be released
               or the rollback action under
               /devices/commit-queue/completed be invoked.";
          }
        }
        description
          "The error option to use. Depending on the selected error option
           NCS will store the reverse of the original transaction intent
           to be able to undo the transaction changes and get back to the
           previous state. This data is stored in the
           /devices/commit-queue/completed tree from where it can
           be viewed and invoked with the rollback action. When invoked
           the data will be removed.";
      }
      container unlock {
        presence "Unlock queue item";
        choice choice-unlock-id {
          leaf id {
            type uint64;
            description
              "Unique id identifying a queue item. If locked, this
               item will be unlocked in the commit phase.";
          }
          leaf tag {
            type string;
            description
              "User defined opaque tag. If locked, this
               item will be unlocked in the commit phase.";
          }
        }
      }
    }
    choice choice-lsa {
      case use-lsa {
        leaf use-lsa {
          type empty;
          description
            "Force handling of the LSA nodes as such. This flag tells
             NCS to propagate applicable commit flags and actions
             to the LSA nodes without applying them on the upper
             NCS node itself. The commit flags affected are
             'dry-run', 'no-networking', 'no-out-of-sync-check',
             'no-overwrite' and 'no-revision-drop'.";
        }
      }
      case no-lsa {
        leaf no-lsa {
          type empty;
          description
            "Do not handle any of the LSA nodes as such. These nodes
             will be handled as any other device.";
        }
      }
    }
    leaf-list wait-device {
      type leafref {
        path "/ncs-internal:devices/ncs-internal:device/ncs-internal:config/ncs:devices/ncs:device/ncs:name" {
          tailf:xpath-root 3;
        }
      }
      description
        "Take device locks before entering transaction critical section. The
         device locks here should be understood to be internal locks in NSO, so
         the device itself is not locked. If the device locks are held by
         someone else, wait for them to become available. The timeout applied
         in this case is the same as used to wait for the transaction lock.

         Normally the device locks are taken automatically inside the
         transaction critical section, because in a typical service transaction
         we do not know the affected devices before the service code is
         executed. When taking the device locks inside transaction critical
         section, it is not possible to wait for lock, so in case the lock is
         not available the transaction is aborted.

         This parameter allows to specify the devices expected to be
         affected by the transaction so they can be pre-locked before entering
         the transaction critical section. This allows to wait for device
         locks. This is useful in cases when other actions holding the device
         lock may be on-going at the same time and the desired behaviour is
         to wait for these actions to complete rather than abort the
         transaction. Examples of such actions are: sync-from,
         partial-sync-from, check-sync, sync-to, compare-config.

         Similarly, when used with a commit through commit queue, this
         parameter allows to wait for queue items with block-others flag. For
         example, a queue item with block-others flag is created by actions
         such as sync-from and partial-sync-from.

         If the transaction involves other devices than specified by this
         parameter, then the lock still needs to be taken on these additional
         devices, which is done inside transaction critical section and may
         fail if the device lock for the additional devices is already held
         by someone else.";
    }
    leaf trace-id {
      type string {
        length "1..64";
      }
      description
        "Use the provided trace id as part of the log messages emitted while
         processing.

         If no trace id is given, NSO is going to generate and assign a trace
         id to the processing.";
    }
  }

  grouping ncs-hidden-commit-params {
    // NCS expand uses statement
    leaf no-revision-drop {
      type empty;
      description
        "This flags means that NCS will not run its data model revision
         algorithm, which requires all participating managed devices
         to have all parts of the data models for all data contained
         in this transaction. Thus, this flag forces NCS to never
         silently drop any data set operations towards a device.";
      tailf:hidden "programmatic-interface";
    }
    leaf no-networking {
      type empty;
      description
        "Do not send any data to the devices. Even if the transaction
         manipulates data below /devices/device/config, nothing will
         be sent to the managed devices. This is a way to manipulate
         CDB in NCS without generating any southbound traffic.";
      tailf:hidden "programmatic-interface";
    }
    choice choice-sync-check {
      case no-overwrite {
        leaf no-overwrite {
          type empty;
          description
            "This flags means that NCS will check that the data that
             should be modified has not changed on the device compared
             to NCS's view of the data. This is a fine-granular sync check;
             NCS verifies that NCS and the device is in sync regarding
             the data that will be modified. If they are not in sync,
             the transaction is aborted.";
          tailf:hidden "programmatic-interface";
        }
      }
      case no-out-of-sync-check {
        leaf no-out-of-sync-check {
          type empty;
          description
            "Continue with the transaction even if NCS detects that a device's
             configuration is out of sync. The device's sync state is assumed
             to be unknown after such commit and the stored transaction id
             value is cleared";
          tailf:hidden "programmatic-interface";
        }
      }
    }
    container commit-queue {
      presence "Commit through the commit queue";
      leaf tag {
        type string;
        description
          "User defined opaque tag.
           The tag is present in all notifications and events
           sent referencing the specific queue item.";
      }
      uses commit-queue-options;
      leaf error-option {
        type enumeration {
          enum "continue-on-error" {
            description
              "The commit queue will continue on errors. No rollback data
               will be created. This is the preferred choice when
               re-deploying a service as a re-deploy doesn't have a
               transaction intent.";
          }
          enum "rollback-on-error" {
            description
              "The commit queue items will roll back on errors. The commit
               queue will place a lock on the failed queue item, thus
               blocking other queue items with overlapping devices to be
               executed. The rollback action will then automatically be
               invoked when the failed queue item has finished its execution.
               The lock is removed as part of the rollback.";
          }
          enum "stop-on-error" {
            description
              "The commit queue will place a lock on the failed queue item,
               thus blocking other queue items with overlapping devices to
               be executed. The lock must then either manually be released
               or the rollback action under
               /devices/commit-queue/completed be invoked.";
          }
        }
        description
          "The error option to use. Depending on the selected error option
           NCS will store the reverse of the original transaction intent
           to be able to undo the transaction changes and get back to the
           previous state. This data is stored in the
           /devices/commit-queue/completed tree from where it can
           be viewed and invoked with the rollback action. When invoked
           the data will be removed.";
      }
      container unlock {
        presence "Unlock queue item";
        choice choice-unlock-id {
          leaf id {
            type uint64;
            description
              "Unique id identifying a queue item. If locked, this
               item will be unlocked in the commit phase.";
          }
          leaf tag {
            type string;
            description
              "User defined opaque tag. If locked, this
               item will be unlocked in the commit phase.";
          }
        }
      }
      tailf:hidden "programmatic-interface";
    }
    choice choice-lsa {
      case use-lsa {
        leaf use-lsa {
          type empty;
          description
            "Force handling of the LSA nodes as such. This flag tells
             NCS to propagate applicable commit flags and actions
             to the LSA nodes without applying them on the upper
             NCS node itself. The commit flags affected are
             'dry-run', 'no-networking', 'no-out-of-sync-check',
             'no-overwrite' and 'no-revision-drop'.";
          tailf:hidden "programmatic-interface";
        }
      }
      case no-lsa {
        leaf no-lsa {
          type empty;
          description
            "Do not handle any of the LSA nodes as such. These nodes
             will be handled as any other device.";
          tailf:hidden "programmatic-interface";
        }
      }
    }
    leaf-list wait-device {
      type leafref {
        path "/ncs-internal:devices/ncs-internal:device/ncs-internal:config/ncs:devices/ncs:device/ncs:name" {
          tailf:xpath-root 3;
        }
      }
      description
        "Take device locks before entering transaction critical section. The
         device locks here should be understood to be internal locks in NSO, so
         the device itself is not locked. If the device locks are held by
         someone else, wait for them to become available. The timeout applied
         in this case is the same as used to wait for the transaction lock.

         Normally the device locks are taken automatically inside the
         transaction critical section, because in a typical service transaction
         we do not know the affected devices before the service code is
         executed. When taking the device locks inside transaction critical
         section, it is not possible to wait for lock, so in case the lock is
         not available the transaction is aborted.

         This parameter allows to specify the devices expected to be
         affected by the transaction so they can be pre-locked before entering
         the transaction critical section. This allows to wait for device
         locks. This is useful in cases when other actions holding the device
         lock may be on-going at the same time and the desired behaviour is
         to wait for these actions to complete rather than abort the
         transaction. Examples of such actions are: sync-from,
         partial-sync-from, check-sync, sync-to, compare-config.

         Similarly, when used with a commit through commit queue, this
         parameter allows to wait for queue items with block-others flag. For
         example, a queue item with block-others flag is created by actions
         such as sync-from and partial-sync-from.

         If the transaction involves other devices than specified by this
         parameter, then the lock still needs to be taken on these additional
         devices, which is done inside transaction critical section and may
         fail if the device lock for the additional devices is already held
         by someone else.";
      tailf:hidden "programmatic-interface";
    }
    leaf trace-id {
      type string {
        length "1..64";
      }
      description
        "Use the provided trace id as part of the log messages emitted while
         processing.

         If no trace id is given, NSO is going to generate and assign a trace
         id to the processing.";
      tailf:hidden "programmatic-interface";
    }
  }

  grouping ncs-commit-result {
    container commit-queue {
      leaf id {
        type leafref {
          path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/ncs:devices/ncs:commit-queue/ncs:queue-item/ncs:id" {
            tailf:xpath-root 2;
          }
        }
        description
          "This leaf is returned if 'commit-queue/async' or
           'commit-queue/sync' was given in the input parameters.";
      }
      leaf status {
        type enumeration {
          enum "async" {
            description
              "The queue item was successfully created.";
            tailf:code-name "commit_cq_async";
          }
          enum "completed" {
            description
              "The queue item was successfully completed.";
            tailf:code-name "commit_cq_completed";
          }
          enum "timeout" {
            description
              "The timer expired before the queue item was completed.";
            tailf:code-name "commit_cq_timeout";
          }
          enum "deleted" {
            description
              "The queue item was deleted from the queue.";
            tailf:code-name "commit_cq_deleted";
          }
          enum "failed" {
            description
              "The queue item failed.";
            tailf:code-name "commit_cq_failed";
          }
        }
      }
      list failed-device {
        key "name";
        leaf name {
          type leafref {
            path "/ncs-internal:devices/ncs-internal:device/ncs-internal:config/ncs:devices/ncs:device/ncs:name" {
              tailf:xpath-root 3;
            }
          }
        }
        leaf reason {
          type string;
          description
            "The error for this failing device.";
        }
        description
          "The devices which failed for this queue item.";
      }
    }
  }

  grouping dry-run-xml {
    container result-xml {
      description
        "Display all changes in the whole data model. The
         changes will be displayed in NETCONF XML edit-config format,
         i.e., the edit-config that would be applied locally (at NCS)
         to get a config that is equal to that of the managed device.";
      container local-node {
        anyxml data;
      }
      list lsa-node {
        leaf name {
          type string;
        }
        anyxml data;
      }
    }
  }

  grouping dry-run-cli {
    container cli {
      description
        "Display all changes in the whole data model. The
         changes will be displayed in CLI curly bracket format.";
      container local-node {
        leaf data {
          tailf:cli-preformatted;
          type string;
        }
      }
      list lsa-node {
        leaf name {
          type string;
        }
        leaf data {
          tailf:cli-preformatted;
          type string;
        }
      }
    }
  }

  grouping dry-run-native {
    container native {
      description
        "Display only changes under /devices/device/config. The
         changes will be displayed in native device format.";
      list device {
        key "name";
        leaf name {
          type string;
        }
        leaf data {
          tailf:cli-preformatted;
          type string;
        }
      }
    }
  }

  grouping commit-queue-item-status {
    leaf status {
      // NCS drop tailf:display-groups
      type enumeration {
        enum "completed" {
          description
            "The queue item was successfully completed.";
          tailf:code-name "cq_item_completed";
        }
        enum "deleted" {
          description
            "The queue item was deleted from the queue.";
          tailf:code-name "cq_item_deleted";
        }
        enum "failed" {
          description
            "The queue item failed.";
          tailf:code-name "cq_item_failed";
        }
      }
    }
  }

  grouping connect-grouping {
    tailf:action connect {
      tailf:actionpoint ncsproxy {
        tailf:internal;
      }
      description
        "Set up sessions to all unlocked devices.";
      tailf:info
        "Set up sessions to all unlocked devices";
      // NCS drop tailf:actionpoint
      input {
        leaf suppress-positive-result {
          type empty;
          description
            "Use this additional parameter to only return
             devices that failed to connect.";
        }
        leaf override-southbound-locked {
          type empty;
          description
            "When a device is southbound locked, all southbound communication
             is turned off. This flag overrides this for connection
             attempts. Thus, this is a way to update the capabilities
             including revision information for a managed device although
             the device is southbound locked";
        }
      }
      output {
        list connect-result {
          key "device";
          leaf device {
            type leafref {
              path "/ncs-internal:devices/ncs-internal:device/ncs-internal:config/devices/device/name" {
                tailf:xpath-root 3;
              }
            }
          }
          uses connect-result;
        }
      }
    }
  }

  grouping connect-grouping-extended {
    tailf:action connect {
      tailf:actionpoint ncsproxy {
        tailf:internal;
      }
      description
        "Set up sessions to all unlocked devices.";
      tailf:info
        "Set up sessions to all unlocked devices";
      // NCS drop tailf:actionpoint
      input {
        leaf suppress-positive-result {
          type empty;
          description
            "Use this additional parameter to only return
             devices that failed to connect.";
        }
        leaf override-southbound-locked {
          type empty;
          description
            "When a device is southbound locked, all southbound communication
             is turned off. This flag overrides this for connection
             attempts. Thus, this is a way to update the capabilities
             including revision information for a managed device although
             the device is southbound locked";
        }
        leaf-list device {
          tailf:info
            "Only connect to these devices.";
          type leafref {
            path "/ncs-internal:devices/ncs-internal:device/ncs-internal:config/devices/device/name" {
              tailf:xpath-root 3;
            }
          }
        }
      }
      output {
        list connect-result {
          key "device";
          leaf device {
            type leafref {
              path "/ncs-internal:devices/ncs-internal:device/ncs-internal:config/devices/device/name" {
                tailf:xpath-root 3;
              }
            }
          }
          uses connect-result;
        }
      }
    }
  }

  grouping connect-result {
    description
      "Common result data from a 'connect' action.";
    leaf result {
      type boolean;
    }
    leaf info {
      type string;
      description
        "If present, contains additional information about the result.";
    }
  }

  grouping check-sync-grouping {
    tailf:action check-sync {
      tailf:actionpoint ncsproxy {
        tailf:internal;
      }
      description
        "Check if the NCS copy of the device configurations is in sync
         with the actual device configurations, using device-specific
         mechanisms. This operation is usually cheap as it only
         compares a signature of the configuration from the
         device rather than comparing the entire configuration.

         Depending on the device the signature is implemented as a
         transaction-id, timestamp, hash-sum or not at all.
         The capability must be supported by the corresponding
         NED. The output might say unsupported, and then the only way
         to perform this would be to do a full 'compare-config' command.

         As some NEDs implements the signature as an hash-sum
         of the entire configuration, this operation might for
         some devices be just as expensive as performing a full
         compare-config command.

         If the wait-for-lock parameter is not given, the wait-for-lock
         device setting is going to be used.";
      tailf:info
        "Check if the NCS config is in sync with the device";
      // NCS drop tailf:actionpoint
      input {
        leaf suppress-positive-result {
          type empty;
          description
            "Use this additional parameter to only return
             devices not in sync.";
        }
        uses wait-for-lock;
      }
      output {
        list sync-result {
          key "device";
          leaf device {
            type leafref {
              path "/ncs-internal:devices/ncs-internal:device/ncs-internal:config/devices/device/name" {
                tailf:xpath-root 3;
              }
            }
          }
          uses check-sync-result;
        }
      }
    }
  }

  grouping check-sync-grouping-extended {
    tailf:action check-sync {
      tailf:actionpoint ncsproxy {
        tailf:internal;
      }
      description
        "Check if the NCS copy of the device configurations is in sync
         with the actual device configurations, using device-specific
         mechanisms. This operation is usually cheap as it only
         compares a signature of the configuration from the
         device rather than comparing the entire configuration.

         Depending on the device the signature is implemented as a
         transaction-id, timestamp, hash-sum or not at all.
         The capability must be supported by the corresponding
         NED. The output might say unsupported, and then the only way
         to perform this would be to do a full 'compare-config' command.

         As some NEDs implements the signature as an hash-sum
         of the entire configuration, this operation might for
         some devices be just as expensive as performing a full
         compare-config command.

         If the wait-for-lock parameter is not given, the wait-for-lock
         device setting is going to be used.";
      tailf:info
        "Check if the NCS config is in sync with the device";
      // NCS drop tailf:actionpoint
      input {
        leaf suppress-positive-result {
          type empty;
          description
            "Use this additional parameter to only return
             devices not in sync.";
        }
        uses wait-for-lock;
        leaf-list device {
          tailf:info
            "Only check-sync these devices.";
          type leafref {
            path "/ncs-internal:devices/ncs-internal:device/ncs-internal:config/devices/device/name" {
              tailf:xpath-root 3;
            }
          }
        }
      }
      output {
        list sync-result {
          key "device";
          leaf device {
            type leafref {
              path "/ncs-internal:devices/ncs-internal:device/ncs-internal:config/devices/device/name" {
                tailf:xpath-root 3;
              }
            }
          }
          uses check-sync-result;
        }
      }
    }
  }

  grouping check-sync-result {
    description
      "Common result data from a 'check-sync' action.";
    leaf result {
      type enumeration {
        enum "unknown" {
          description
            "NCS has no record, probably because no
             sync actions has been executed towards the device
             or it was cleared after a no-out-of-sync-check commit.
             This is also the initial state for a device.";
        }
        enum "locked" {
          tailf:code-name "sync_locked";
          description
            "The device is administratively locked, meaning that NCS
             cannot talk to it.";
        }
        enum "in-sync" {
          tailf:code-name "in-sync-result";
          description
            "The configuration on the device is in sync with NCS.";
        }
        enum "out-of-sync" {
          description
            "The device configuration is known to be out of sync, i.e.,
             it has been reconfigured out of band.";
        }
        enum "unsupported" {
          description
            "The device doesn't have any mechanism to do a cheap
             check-sync, or this mechanism has been disabled.";
        }
        enum "error" {
          tailf:code-name "sync-error";
          description
            "An error occurred when NCS tried to check the sync status.
             The leaf 'info' contains additional information.";
        }
      }
    }
    leaf info {
      type string;
      description
        "If present, contains additional information about the result.";
    }
  }

  grouping sync-to-grouping {
    tailf:action sync-to {
      tailf:actionpoint ncsproxy {
        tailf:internal;
      }
      description
        "Synchronize the configuration by pushing to all unlocked devices.

         By default, NCS pushes a minimal diff to the devices.  The
         diff is calculated by reading the configuration from the
         devices and comparing with the configuration in NCS.

         For NETCONF devices, NCS can optionally replace the
         configuration on the devices by sending its own configuration
         without calculating the diff.  Note that NCS will send an
         <edit-config> with the 'replace' option in this case.  This
         means that configuration subtrees that NCS does not know
         about are not replaced.

         If the dry-run option is used, NCS will just report what it
         will do do instead of doing it.

         If the wait-for-lock parameter is not given, the wait-for-lock
         device setting is going to be used.";
      tailf:info
        "Synchronize the config by pushing to the devices";
      // NCS drop tailf:actionpoint
      input {
        leaf suppress-positive-result {
          type empty;
          description
            "Use this additional parameter to only return
             devices that failed to sync.";
        }
        leaf mode {
          type enumeration {
            enum "replace";
          }
          description
            "For NETCONF devices, replace the device configurations
             with the NCS configurations, instead of sending the diff.

             Cannot be used with non-NETCONF devices.";
        }
        container dry-run {
          presence "";
          leaf outformat {
            type outformat3;
            description
              "Report what would be done towards the device, without
               actually doing anything.";
          }
        }
        uses wait-for-lock;
      }
      output {
        list sync-result {
          key "device";
          leaf device {
            type leafref {
              path "/ncs-internal:devices/ncs-internal:device/ncs-internal:config/devices/device/name" {
                tailf:xpath-root 3;
              }
            }
          }
          uses sync-to-result;
        }
      }
    }
  }

  grouping sync-to-grouping-extended {
    tailf:action sync-to {
      tailf:actionpoint ncsproxy {
        tailf:internal;
      }
      description
        "Synchronize the configuration by pushing to all unlocked devices.

         By default, NCS pushes a minimal diff to the devices.  The
         diff is calculated by reading the configuration from the
         devices and comparing with the configuration in NCS.

         For NETCONF devices, NCS can optionally replace the
         configuration on the devices by sending its own configuration
         without calculating the diff.  Note that NCS will send an
         <edit-config> with the 'replace' option in this case.  This
         means that configuration subtrees that NCS does not know
         about are not replaced.

         If the dry-run option is used, NCS will just report what it
         will do do instead of doing it.

         If the wait-for-lock parameter is not given, the wait-for-lock
         device setting is going to be used.";
      tailf:info
        "Synchronize the config by pushing to the devices";
      // NCS drop tailf:actionpoint
      input {
        leaf suppress-positive-result {
          type empty;
          description
            "Use this additional parameter to only return
             devices that failed to sync.";
        }
        leaf mode {
          type enumeration {
            enum "replace";
          }
          description
            "For NETCONF devices, replace the device configurations
             with the NCS configurations, instead of sending the diff.

             Cannot be used with non-NETCONF devices.";
        }
        container dry-run {
          presence "";
          leaf outformat {
            type outformat3;
            description
              "Report what would be done towards the device, without
               actually doing anything.";
          }
        }
        uses wait-for-lock;
        leaf-list device {
          tailf:info
            "Only sync to these devices.";
          type leafref {
            path "/ncs-internal:devices/ncs-internal:device/ncs-internal:config/devices/device/name" {
              tailf:xpath-root 3;
            }
          }
        }
      }
      output {
        list sync-result {
          key "device";
          leaf device {
            type leafref {
              path "/ncs-internal:devices/ncs-internal:device/ncs-internal:config/devices/device/name" {
                tailf:xpath-root 3;
              }
            }
          }
          uses sync-to-result;
        }
      }
    }
  }

  grouping sync-to-result {
    description
      "Common result data from a 'sync-to' action.";
    choice outformat {
      leaf result {
        type boolean;
      }
      anyxml result-xml;
      leaf cli {
        tailf:cli-preformatted;
        type string;
      }
      leaf native {
        tailf:cli-preformatted;
        type string;
      }
    }
    leaf info {
      type string;
      description
        "If present, contains additional information about the result.";
    }
  }

  grouping sync-from-grouping {
    tailf:action sync-from {
      tailf:actionpoint ncsproxy {
        tailf:internal;
      }
      description
        "Synchronize the configuration by pulling from all unlocked
         devices.

         If the wait-for-lock parameter is not given, the wait-for-lock
         device setting is going to be used.";
      tailf:info
        "Synchronize the config by pulling from the devices";
      // NCS drop tailf:actionpoint
      input {
        leaf suppress-positive-result {
          type empty;
          description
            "Use this additional parameter to only return
             devices that failed to sync.";
        }
        container dry-run {
          presence "";
          leaf outformat {
            type outformat2;
            description
              "Report what would be done towards CDB, without
               actually doing anything.";
          }
        }
        leaf verbose {
          type empty;
          description
            "Use this to show additional parse information if supported
             by the NED.";
        }
        uses wait-for-lock;
      }
      output {
        uses sync-from-output;
      }
    }
  }

  grouping sync-from-grouping-extended {
    tailf:action sync-from {
      tailf:actionpoint ncsproxy {
        tailf:internal;
      }
      description
        "Synchronize the configuration by pulling from all unlocked
         devices.

         If the wait-for-lock parameter is not given, the wait-for-lock
         device setting is going to be used.";
      tailf:info
        "Synchronize the config by pulling from the devices";
      // NCS drop tailf:actionpoint
      input {
        leaf suppress-positive-result {
          type empty;
          description
            "Use this additional parameter to only return
             devices that failed to sync.";
        }
        container dry-run {
          presence "";
          leaf outformat {
            type outformat2;
            description
              "Report what would be done towards CDB, without
               actually doing anything.";
          }
        }
        leaf verbose {
          type empty;
          description
            "Use this to show additional parse information if supported
             by the NED.";
        }
        uses wait-for-lock;
        leaf-list device {
          tailf:info
            "Only sync from these devices.";
          type leafref {
            path "/ncs-internal:devices/ncs-internal:device/ncs-internal:config/devices/device/name" {
              tailf:xpath-root 3;
            }
          }
        }
      }
      output {
        uses sync-from-output;
      }
    }
  }

  grouping sync-from-output {
    list sync-result {
      key "device";
      leaf device {
        type leafref {
          path "/ncs-internal:devices/ncs-internal:device/ncs-internal:config/devices/device/name" {
            tailf:xpath-root 3;
          }
        }
      }
      uses sync-result;
    }
  }

  grouping sync-result {
    description
      "Common result data from a 'sync' action.";
    choice outformat {
      leaf result {
        type boolean;
      }
      anyxml result-xml;
      leaf cli {
        tailf:cli-preformatted;
        type string;
      }
    }
    leaf info {
      type string;
      description
        "If present, contains additional information about the result.";
    }
  }

  grouping wait-for-lock {
    choice wait-for-lock-choice {
      description
        "Wait for device lock setting.";
      leaf no-wait-for-lock {
        type empty;
        description
          "The action can't be performed while the device is being
           committed to (or waiting in the commit queue). This is to avoid
           getting inconsistent data when reading the configuration.
           This specifies that the action should not wait for device lock,
           instead, it should immediately fail if the device is being locked.";
      }
      container wait-for-lock {
        presence "Wait for device lock.";
        description
          "The action can't be performed while the device is being
           committed to (or waiting in the commit queue). This is to avoid
           getting inconsistent data when reading the configuration.
           This specifies a timeout to wait for a device lock to be placed
           in the commit queue. The lock will be automatically released once
           the action has been executed.";
        choice timeout-choice {
          default "infinity";
          leaf timeout {
            type uint32 {
              range "0..4294967";
            }
            units "seconds";
            description
              "Specifies a maximum number of seconds to wait for the
               device to be locked.";
          }
          leaf infinity {
            description
              "Wait infinitely for the lock, this is the default.";
            type empty;
          }
        }
      }
    }
  }

  grouping disconnect-grouping {
    tailf:action disconnect {
      tailf:actionpoint ncsproxy {
        tailf:internal;
      }
      description
        "Close all sessions to all devices.";
      tailf:info
        "Close all sessions to all devices";
      // NCS drop tailf:actionpoint
      input;
    }
  }

  grouping disconnect-grouping-specific {
    tailf:action disconnect {
      tailf:actionpoint ncsproxy {
        tailf:internal;
      }
      description
        "Close all sessions to the device.";
      tailf:info
        "Close all sessions to the device";
      // NCS drop tailf:actionpoint
      input;
    }
  }

  grouping disconnect-grouping-extended {
    tailf:action disconnect {
      tailf:actionpoint ncsproxy {
        tailf:internal;
      }
      description
        "Close all sessions to all devices.";
      tailf:info
        "Close all sessions to all devices";
      // NCS drop tailf:actionpoint
    }
  }

  grouping check-yang-modules-grouping {
    tailf:action check-yang-modules {
      tailf:actionpoint ncsproxy {
        tailf:internal;
      }
      description
        "Check if the device YANG modules loaded by NCS
         have revisions that are compatible with the ones reported
         by the devices.";
      tailf:info
        "Check if NCS and the devices have compatible YANG modules";
      // NCS drop tailf:actionpoint
      input {
        leaf verbose {
          type empty;
          description
            "Use this to show additional compatibility info.";
        }
        leaf suppress-positive-result {
          type empty;
          description
            "Use this to only return devices that have incompatible
             modules.";
        }
      }
      output {
        list device {
          key "name";
          leaf name {
            type leafref {
              path "/ncs-internal:devices/ncs-internal:device/ncs-internal:config/devices/device/name" {
                tailf:xpath-root 3;
              }
            }
            description
              "Device for which a revision compatibility
               check has been performed.";
          }
          uses check-yang-modules-result;
        }
      }
    }
  }

  grouping check-yang-modules-grouping-extended {
    tailf:action check-yang-modules {
      tailf:actionpoint ncsproxy {
        tailf:internal;
      }
      description
        "Check if the device YANG modules loaded by NCS
         have revisions that are compatible with the ones reported
         by the devices.";
      tailf:info
        "Check if NCS and the devices have compatible YANG modules";
      // NCS drop tailf:actionpoint
      input {
        leaf verbose {
          type empty;
          description
            "Use this to show additional compatibility info.";
        }
        leaf suppress-positive-result {
          type empty;
          description
            "Use this to only return devices that have incompatible
             modules.";
        }
        leaf-list device {
          tailf:info
            "Specification of devices for which a module revision
             compatibility check should be performed.";
          type leafref {
            path "/ncs-internal:devices/ncs-internal:device/ncs-internal:config/devices/device/name" {
              tailf:xpath-root 3;
            }
          }
        }
      }
      output {
        list device {
          key "name";
          leaf name {
            type leafref {
              path "/ncs-internal:devices/ncs-internal:device/ncs-internal:config/devices/device/name" {
                tailf:xpath-root 3;
              }
            }
            description
              "Device for which a revision compatibility
               check has been performed.";
          }
          uses check-yang-modules-result;
        }
      }
    }
  }

  grouping check-yang-modules-result {
    description
      "Common result data from a 'check-yang-modules' action.";
    choice compat-res {
      case silent {
        description
          "Present in non-verbose mode.";
        leaf compatible {
          type boolean;
          description
            "Reporting if a device is revision compatible true/false
             in non-verbose mode.";
        }
      }
      case verbose {
        list module {
          description
            "In verbose mode, this is the list of the supported modules for
             a device which are reported as capabilities.";
          key "name";
          leaf name {
            type string;
            description
              "YANG module";
          }
          leaf status {
            description
              "Compatibility status for the YANG module.";
            type enumeration {
              enum "supported" {
                tailf:code-name "module-supported";
                description
                  "Implies that NCS has loaded the yang module with
                   the same revision or a revision of newer date.";
              }
              enum "unsupported" {
                tailf:code-name "module-unsupported";
                description
                  "Implies that NCS has loaded the yang module but the
                   revision is to old.";
              }
              enum "not-loaded" {
                tailf:code-name "module-not-loaded";
                description
                  "Implies that NCS has not loaded the yang module.";
              }
              enum "unknown" {
                tailf:code-name "module-unknown";
                description
                  "that NCS has loaded the module but the revision
                   information was not available for comparison.";
              }
            }
          }
          leaf device-revision {
            type string;
            description
              "Live device reported revision for the module";
          }
          leaf ncs-revision {
            type string;
            description
              "NCS loaded YANG module revision";
          }
        }
      }
    }
  }

  grouping fetch-ssh-host-keys-grouping {
    tailf:action fetch-ssh-host-keys {
      tailf:actionpoint ncsproxy {
        tailf:internal;
      }
      tailf:info
        "Retrieve SSH host keys from all devices";
      description
        "Retrieve the SSH host keys from all devices, or all devices in the
         given device group, and store them in each device's ssh/host-key
         list. Successfully retrieved new or updated keys are always
         committed by the action.";
      // NCS drop tailf:actionpoint
      input {
        leaf suppress-positive-result {
          tailf:info
            "Only return result if key retrieval failed";
          type empty;
          description
            "If this optional parameter is included, results are only
             returned for devices where key retrieval failed.";
        }
        leaf suppress-unchanged-result {
          tailf:info
            "Do not return result if keys are unchanged";
          type empty;
          description
            "If this optional parameter is included, no results are returned
             for devices which have the same keys as those already known.";
        }
        leaf suppress-fingerprints {
          tailf:info
            "Do not return key fingerprints";
          type empty;
          description
            "If this optional parameter is included, key fingerprints are
             not included in the results.";
        }
      }
      output {
        list fetch-result {
          description
            "This is a list of key retrieval results, each entry pertains
             to one device.";
          key "device";
          leaf device {
            type leafref {
              path "/ncs-internal:devices/ncs-internal:device/ncs-internal:config/devices/device/name" {
                tailf:xpath-root 3;
              }
            }
            description
              "The name of the device.";
          }
          uses fetch-ssh-host-keys-result;
        }
      }
    }
  }

  grouping fetch-ssh-host-keys-grouping-extended {
    tailf:action fetch-ssh-host-keys {
      tailf:actionpoint ncsproxy {
        tailf:internal;
      }
      tailf:info
        "Retrieve SSH host keys from all devices";
      description
        "Retrieve the SSH host keys from all devices, or all devices in the
         given device group, and store them in each device's ssh/host-key
         list. Successfully retrieved new or updated keys are always
         committed by the action.";
      // NCS drop tailf:actionpoint
      input {
        leaf suppress-positive-result {
          tailf:info
            "Only return result if key retrieval failed";
          type empty;
          description
            "If this optional parameter is included, results are only
             returned for devices where key retrieval failed.";
        }
        leaf suppress-unchanged-result {
          tailf:info
            "Do not return result if keys are unchanged";
          type empty;
          description
            "If this optional parameter is included, no results are returned
             for devices which have the same keys as those already known.";
        }
        leaf suppress-fingerprints {
          tailf:info
            "Do not return key fingerprints";
          type empty;
          description
            "If this optional parameter is included, key fingerprints are
             not included in the results.";
        }
        leaf-list device {
          tailf:info
            "Only fetch host keys from these devices.";
          type leafref {
            path "/ncs-internal:devices/ncs-internal:device/ncs-internal:config/devices/device/name" {
              tailf:xpath-root 3;
            }
          }
        }
      }
      output {
        list fetch-result {
          description
            "This is a list of key retrieval results, each entry pertains
             to one device.";
          key "device";
          leaf device {
            type leafref {
              path "/ncs-internal:devices/ncs-internal:device/ncs-internal:config/devices/device/name" {
                tailf:xpath-root 3;
              }
            }
            description
              "The name of the device.";
          }
          uses fetch-ssh-host-keys-result;
        }
      }
    }
  }

  grouping apply-template-grouping {
    tailf:action apply-template {
      tailf:actionpoint ncsproxy {
        tailf:internal;
      }
      tailf:info
        "Take a named template and apply it here";
      description
        "Take a named template and apply its configuration here.

         This action will behave differently depending on if it is
         invoked with a transaction or not. When invoked with a
         transaction (such as via the CLI) it will apply the
         template to it and leave it to the user to commit or
         revert the resulting changes. If invoked without a
         transaction (for example when invoked via RESTCONF),
         the action will automatically create one and commit the
         resulting changes. An error will be returned and the
         transaction aborted if the template failed to apply
         on any of the devices.

         This grouping is used inside managed devices, and in
         device groups.";
      tailf:cli-configure-mode;
      // NCS drop tailf:actionpoint
      input {
        leaf template-name {
          type leafref {
            path "/ncs-internal:devices/ncs-internal:device/ncs-internal:config/devices/template/name" {
              tailf:xpath-root 3;
            }
          }
          mandatory true;
        }
        list variable {
          key "name";
          leaf name {
            tailf:cli-completion-actionpoint template-variable;
            type string {
              tailf:info
                "The name of the XPath variable as used in the template";
            }
            mandatory true;
          }
          leaf value {
            type union {
              type string {
                tailf:info
                  "quoted;;some text enclosed in single quotes. This
                   is an XPath string.";
              }
              type string {
                tailf:info
                  "number;;some integer or float number. This is an XPath
                   number.";
              }
              type yang:xpath1.0 {
                tailf:info
                  "node set;;an XPath expression resulting in a node set";
              }
            }
            mandatory true;
          }
        }
        leaf suppress-positive-result {
          tailf:info
            "Only return result if some error occurred";
          type empty;
          description
            "If this optional parameter is included, results are only
             returned for devices where some error occurred.";
        }
        leaf accept-empty-capabilities {
          tailf:info
            "Apply template to devices with no capabilities known";
          type empty;
          description
            "If this optional parameter is included, the template
             is applied to devices even if the capability of the device
             is unknown.";
        }
        container dry-run {
          tailf:hidden "programmatic-interface";
          presence "";
          leaf outformat {
            type outformat3;
          }
        }
        uses ncs-hidden-commit-params;
      }
      output {
        list apply-template-result {
          key "device";
          leaf device {
            type leafref {
              path "/ncs-internal:devices/ncs-internal:device/ncs-internal:config/devices/device/name" {
                tailf:xpath-root 3;
              }
            }
          }
          leaf result {
            type enumeration {
              enum "ok" {
                tailf:code-name "apply_template_ok";
                description
                  "The template was applied with success";
              }
              enum "no-capabilities" {
                tailf:code-name "apply_template_no_capabilities";
                description
                  "One or more of the affected devices has no known
                   capabilities. This occures when NCS has not synced
                   from the device";
              }
              enum "no-namespace" {
                tailf:code-name "apply_template_no_namespace";
                description
                  "One or more of the affected devices has no matching
                   namespace in the template.";
              }
            }
          }
          leaf info {
            type string;
            description
              "If present, contains additional information
               about the result.";
          }
        }
        choice outformat {
          case case-xml {
            uses dry-run-xml;
          }
          case case-cli {
            uses dry-run-cli;
          }
          case case-native {
            uses dry-run-native;
          }
        }
        uses ncs-commit-result;
      }
    }
  }

  grouping apply-template-grouping-extended {
    tailf:action apply-template {
      tailf:actionpoint ncsproxy {
        tailf:internal;
      }
      tailf:info
        "Take a named template and apply it here";
      description
        "Take a named template and apply its configuration here.

         This action will behave differently depending on if it is
         invoked with a transaction or not. When invoked with a
         transaction (such as via the CLI) it will apply the
         template to it and leave it to the user to commit or
         revert the resulting changes. If invoked without a
         transaction (for example when invoked via RESTCONF),
         the action will automatically create one and commit the
         resulting changes. An error will be returned and the
         transaction aborted if the template failed to apply
         on any of the devices.";
      tailf:cli-configure-mode;
      // NCS drop tailf:actionpoint
      input {
        leaf template-name {
          type leafref {
            path "/ncs-internal:devices/ncs-internal:device/ncs-internal:config/devices/template/name" {
              tailf:xpath-root 3;
            }
          }
          mandatory true;
        }
        list variable {
          key "name";
          leaf name {
            tailf:cli-completion-actionpoint template-variable;
            type string {
              tailf:info
                "The name of the XPath variable as used in the template";
            }
            mandatory true;
          }
          leaf value {
            type union {
              type string {
                tailf:info
                  "quoted;;some text enclosed in single quotes. This
                   is an XPath string.";
              }
              type string {
                tailf:info
                  "number;;some integer or float number. This is an XPath
                   number.";
              }
              type yang:xpath1.0 {
                tailf:info
                  "node set;;an XPath expression resulting in a node set";
              }
            }
            mandatory true;
          }
        }
        leaf suppress-positive-result {
          tailf:info
            "Only return result if some error occurred";
          type empty;
          description
            "If this optional parameter is included, results are only
             returned for devices where some error occurred.";
        }
        leaf accept-empty-capabilities {
          tailf:info
            "Apply template to devices with no capabilities known";
          type empty;
          description
            "If this optional parameter is included, the template
             is applied to devices even if the capability of the device
             is unknown.";
        }
        leaf-list device {
          tailf:info
            "Only apply template configuration to these devices.";
          type leafref {
            path "/ncs-internal:devices/ncs-internal:device/ncs-internal:config/devices/device/name" {
              tailf:xpath-root 3;
            }
          }
          min-elements 1;
        }
        container dry-run {
          tailf:hidden "programmatic-interface";
          presence "";
          leaf outformat {
            type outformat3;
          }
        }
        uses ncs-hidden-commit-params;
      }
      output {
        list apply-template-result {
          key "device";
          leaf device {
            type leafref {
              path "/ncs-internal:devices/ncs-internal:device/ncs-internal:config/devices/device/name" {
                tailf:xpath-root 3;
              }
            }
          }
          leaf result {
            type enumeration {
              enum "ok" {
                tailf:code-name "apply_template_ok";
                description
                  "The template was applied with success";
              }
              enum "no-capabilities" {
                tailf:code-name "apply_template_no_capabilities";
                description
                  "One or more of the affected devices has no known
                   capabilities. This occures when NCS has not synced
                   from the device";
              }
              enum "no-namespace" {
                tailf:code-name "apply_template_no_namespace";
                description
                  "One or more of the affected devices has no matching
                   namespace in the template.";
              }
            }
          }
          leaf info {
            type string;
            description
              "If present, contains additional information
               about the result.";
          }
        }
        choice outformat {
          case case-xml {
            uses dry-run-xml;
          }
          case case-cli {
            uses dry-run-cli;
          }
          case case-native {
            uses dry-run-native;
          }
        }
        uses ncs-commit-result;
      }
    }
  }

  grouping migrate-grouping {
    tailf:action migrate {
      tailf:actionpoint ncsproxy {
        tailf:internal;
      }
      description
        "Change the NED identity and migrate all data. Reads and commits
         the actual device configuration as a side-effect.

         The action reports what paths have been modified and the services
         affected by those changes.

         If the wait-for-lock parameter is not given, the wait-for-lock
         device setting is going to be used.";
      tailf:info
        "Migrate the devices to a new NED type";
      // NCS drop tailf:actionpoint
      input {
        leaf new-ned-id {
          tailf:info
            "The new NED Identity";
          // NCS patched to string, due to LSA partial NED
          type string;
          mandatory true;
        }
        leaf no-networking {
          type empty;
          description
            "Do not generate any southbound traffic towards the
             devices. Use the device configuration in CDB.";
        }
        choice display-mode {
          case display-result {
            leaf dry-run {
              type empty;
            }
            leaf verbose {
              tailf:info
                "Report all service instances";
              description
                "Report all service instances instead of just the
                 service points.";
              type empty;
            }
          }
          leaf suppress-positive-result {
            tailf:info
              "Only return result if some error occurred";
            type empty;
            description
              "If this optional parameter is included, result is only
               returned if an error occurs.";
          }
        }
        uses wait-for-lock;
      }
      output {
        list migrate-result {
          key "device";
          leaf device {
            type leafref {
              path "/ncs-internal:devices/ncs-internal:device/ncs-internal:config/devices/device/name" {
                tailf:xpath-root 3;
              }
            }
          }
          leaf result {
            type boolean;
          }
          leaf info {
            type string;
            description
              "If present, contains additional information about the result.";
          }
        }
        uses migrate-result;
      }
    }
  }

  grouping migrate-grouping-extended {
    tailf:action migrate {
      tailf:actionpoint ncsproxy {
        tailf:internal;
      }
      description
        "Change the NED identity and migrate all data. Reads and commits
         the actual device configuration as a side-effect.

         The action reports what paths have been modified and the services
         affected by those changes.

         If the wait-for-lock parameter is not given, the wait-for-lock
         device setting is going to be used.";
      tailf:info
        "Migrate the matching devices to a new NED type";
      // NCS drop tailf:actionpoint
      input {
        leaf new-ned-id {
          tailf:info
            "The new NED identity";
          // NCS patched to string, due to LSA partial NED
          type string;
          mandatory true;
        }
        leaf old-ned-id {
          tailf:info
            "Only migrate devices with this NED identity";
          description
            "Only migrate devices with this NED identity.";
          // NCS patched to string, due to LSA partial NED
          type string;
          mandatory true;
        }
        leaf-list device {
          tailf:info
            "Only migrate these devices.";
          description
            "Only migrate these devices. Devices that are configured
             with NED identities that doesn't match the old-ned-id
             will be ignored.";
          type leafref {
            path "/ncs-internal:devices/ncs-internal:device/ncs-internal:config/devices/device/name" {
              tailf:xpath-root 3;
            }
          }
        }
        leaf no-networking {
          type empty;
          description
            "Do not generate any southbound traffic towards the
             devices. Use the device configuration in CDB.";
        }
        choice display-mode {
          case display-result {
            leaf dry-run {
              type empty;
            }
            leaf verbose {
              tailf:info
                "Report all service instances";
              description
                "Report all service instances instead of just the
                 service points.";
              type empty;
            }
          }
          leaf suppress-positive-result {
            tailf:info
              "Only return result if some error occurred";
            type empty;
            description
              "If this optional parameter is included, result is only
               returned if an error occurs.";
          }
        }
        uses wait-for-lock;
      }
      output {
        list migrate-result {
          key "device";
          leaf device {
            type leafref {
              path "/ncs-internal:devices/ncs-internal:device/ncs-internal:config/devices/device/name" {
                tailf:xpath-root 3;
              }
            }
          }
          leaf result {
            type boolean;
          }
          leaf info {
            type string;
            description
              "If present, contains additional information about the result.";
          }
        }
        uses migrate-result;
      }
    }
  }

  grouping migrate-result {
    list modified-path {
      leaf path {
        description
          "The path below /devices/device/config that has been modified.";
        type yang:xpath1.0;
      }
      leaf info {
        description
          "Description of what has changed on the path.";
        type string;
      }
    }
    leaf-list affected-services {
      description
        "The service instances/points that are affected by the data
         model changes on the migrated device.";
      type string;
    }
  }

  grouping location {
    container location {
      description
        "Physical location of devices in the group";
      leaf name {
        type string;
        description
          "An arbitrary name of the location.";
      }
      leaf latitude {
        type decimal64 {
          range "-90..90";
          fraction-digits 6;
        }
        units "decimal degrees";
        description
          "The latitude according to WGS-84, in decimal degrees.";
      }
      leaf longitude {
        type decimal64 {
          range "-180..180";
          fraction-digits 6;
        }
        units "decimal degrees";
        description
          "The longitude according to WGS-84, in decimal degrees.";
      }
      leaf altitude {
        type int32;
        units "meters";
        description
          "The altitude according to WGS-84, in meters.";
      }
    }
  }

  grouping queue-item-status {
    leaf status {
      // NCS drop tailf:display-groups
      type enumeration {
        enum "waiting" {
          description
            "The queue item is waiting to run.  This state means
             that there is some other item in the queue, ahead of this item.";
        }
        enum "executing" {
          description
            "The queue item is currently executing.

             Transient errors might be present. These errors occur when NCS
             fails to communicate with some of the devices. The errors are
             shown in the 'transient-errors' leaf-list.

             Retries will take place at intervals a specified in
             /devices/global-settings/commit-queue/retry-timeout.

             Examples of transient errors are connection failures
             and that the changes are rejected due to the device
             being locked.

             Transient errors are potentially bad, since the queue might
             grow if new items are added, waiting for the same device.";
        }
        enum "locked" {
          description
            "This queue item is locked and will not be processed until it has
             been unlocked, see the action
             '/devices/commit-queue/queue-item/unlock'.

             A locked queue-item will block all subsequent queue-items
             which are using any device in the locked queue item.";
          tailf:code-name "qi_locked";
        }
        enum "blocked" {
          description
            "The queue item is waiting in the queue, and some other
             queue item ahead of this item is in state 'locked' or 'executing'
             with transient errors.";
        }
        enum "waiting-not-master" {
          description
            "HA is enabled, but we have not yet entered the master
             state, no provisioning can be done through the commit
             queue unless we are master.";
        }
        enum "locked-not-master" {
          description
            "HA is enabled, but we have not yet entered the master
             state, no provisioning can be done through the commit
             queue unless we are master.";
        }
        enum "blocked-not-master" {
          description
            "HA is enabled, but we have not yet entered the master
             state, no provisioning can be done through the commit
             queue unless we are master.";
        }
      }
      description
        "What is NCS currently doing with this queue item.
         If the status is idle, it means that the item is waiting
         for another queue item where one of the devices is
         not running, i.e., it's not possible to connect to that
         device.";
    }
  }

  grouping commit-queue-basic-options {
    choice operation-mode {
      leaf async {
        type empty;
        description
          "Commit the transaction data asynchronously to the commit queue.
           This flag is useful when some device is non-operational or
           has data waiting in the commit queue.

           The operation returns successfully if the transaction data has
           been successfully placed in the queue. The leaf
           'commit-queue/id' is set as the queue identifier and the
           leaf 'commit-queue/status' is set to 'async' in the result.";
      }
      container sync {
        presence "Commit through the commit queue and wait for completion";
        description
          "Commit the transaction data synchronously to the commit queue.

           The operation does not return until the transaction data has
           been sent to all devices, or a timeout occurs. The leaf
           'commit-queue/id' is set as the queue identifier and the
           leaf 'commit-queue/status' is set to 'completed', 'failed',
           'deleted' or 'timeout' dependent of the outcome.

           If no device is involved in the transaction, the operation
           returns directly.";
        choice timeout-choice {
          leaf timeout {
            type uint32 {
              range "0..4294967";
            }
            units "seconds";
            description
              "Specifies a maximum number of seconds to wait for the
               transaction to be committed. If the timer expires, the
               transaction is kept in the commit-queue, and the operation
               returns successfully. The leaf 'commit-queue/status'
               is set to 'timeout', and the leaf 'commit-queue/id' is
               set to the queue identifier in the result.";
          }
          leaf infinity {
            description
              "Wait infinitely for the transaction to be committed.";
            type empty;
          }
        }
      }
      default "async";
    }
  }

  grouping commit-queue-options {
    uses commit-queue-basic-options {
      augment "operation-mode" {
        leaf bypass {
          type empty;
          description
            "This flag means that if
             /devices/commit-queue/enabled-by-default is 'true' the
             data in this transaction will bypass the commit queue.
             The data will be written directly to the devices.";
        }
      }
    }
    leaf block-others {
      type empty;
      description
        "The resulting queue item will block subsequent queue items,
         which use any of the devices in this queue item, from
         being queued.";
    }
    leaf lock {
      type empty;
      description
        "Place a lock on the resulting queue item. The queue
         item will not be processed until it has been unlocked,
         see the actions 'unlock' and 'lock' in
         /devices/commit-queue/queue-item'.

         No following queue items, using the same devices, will be
         allowed to execute as long as the lock is in place.";
    }
    leaf atomic {
      type boolean;
      description
        "Sets the atomic behaviour of the resulting queue item.
         If this is set to false, the devices contained in the
         resulting queue item can start executing if the same devices
         in other non-atomic queue items ahead of it in the queue are
         completed. If set to true, the atomic integrity of the
         queue item is preserved.";
    }
  }

  grouping authgroup-callback-input-params {
    description
      "When /devices/authgroups/group/[name]/umap/[local-user]/callback-node
       and /devices/authgroups/group/[name]/umap/[local-user]/action-name
       is set, the action that is defined by action-name in the specified
       callback-node must use this grouping as input parameters.";
    leaf local-user {
      type string;
    }
    leaf authgroup {
      type string;
    }
    leaf device {
      type string;
    }
  }

  grouping authgroup-callback-output-params {
    description
      "When /devices/authgroups/group/[name]/umap/[local-user]/callback-node
       and /devices/authgroups/group/[name]/umap/[local-user]/action-name
       is set, the action that is defined by action-name in the specified
       callback-node must use this grouping as output parameters.";
    leaf remote-user {
      type string;
    }
    leaf remote-password {
      type string;
    }
    leaf remote-secondary-password {
      type string;
    }
  }

  grouping notifications {
    list subscription {
      tailf:info
        "List of subscriptions";
      key "name";
      description
        "A list of our notification subscriptions for this managed device.";
      leaf name {
        type string;
        description
          "Each subscription must have a unique name.";
      }
      leaf stream {
        tailf:info
          "The notification stream name";
        type string;
        mandatory true;
        description
          "The name of the notification stream this subscription
           refers to.";
      }
      choice filter {
        description
          "Optional element, if not set, no filters are applied.";
        case xpath {
          leaf xpath {
            tailf:info
              "XPath filter for the notifications";
            type yang:xpath1.0;
          }
        }
        case subtree {
          leaf subtree {
            tailf:info
              "Subtree filter for the notifications";
            type string;
          }
        }
      }
      leaf local-user {
        type string;
        mandatory true;
        description
          "The local user is used when setting up a device
           connection.";
      }
      leaf store-in-cdb {
        tailf:info
          "Store notifications in CDB";
        type boolean;
        default "true";
        description
          "Indicate whether notifications should be stored as
           operational data in CDB.

           When notifications are generated at a high rate,
           storage consumes lots of resources. In cases like that,
           consider using the device-notification event stream
           instead.";
      }
      leaf utilize-replay {
        tailf:info
          "Use replay when connecting to the device";
        type boolean;
        default "true";
        description
          "If the device supports replay, should NCS attempt to use that
           when connecting to the device.";
      }
      leaf reconnect-interval {
        tailf:info
          "Interval for re-establishing the subscription";
        type uint32 {
          range "0..4294967";
        }
        units "seconds";
        default "60";
        description
          "If the device is non operational, with which
           interval (in seconds) shall NCS attempt to re-establish
           the subscription.";
      }
      // NCS drop config false leaf status
      // NCS drop config false leaf 'failure-reason'
      // NCS drop config false leaf 'error-info'
      tailf:action reconnect {
        tailf:actionpoint ncsproxy {
          tailf:internal;
        }
        tailf:info
          "Attempt to reconnect this subscription";
        description
          "Attempt to reconnect this subscription.";
        // NCS drop tailf:actionpoint
      }
      tailf:action disconnect {
        tailf:actionpoint ncsproxy {
          tailf:internal;
        }
        tailf:info
          "Disconnect this subscription if connected";
        description
          "Disconnect this subscription if connected.";
        // NCS drop tailf:actionpoint
      }
      tailf:action replay {
        tailf:actionpoint ncsproxy {
          tailf:internal;
        }
        tailf:info
          "Replay (missed) notifications from the device";
        description
          "Ask the device to replay all notifications for this
           subscription.  Optionally if a timestamp is given, all
           notifications newer than the provided timestamp are
           requested.";
        // NCS drop tailf:actionpoint
        input {
          leaf from-date-time {
            type yang:date-and-time;
          }
        }
      }
    }
    // NCS drop config false list stream
    // NCS drop config false list 'notification-name'
    container received-notifications {
      leaf max-size {
        type int32;
        default "200";
        description
          "Max size of the list of received notifications.
           When the maximum size is reached, the oldest
           received notification is purged.";
      }
      // NCS drop config false leaf 'clear-time'
      tailf:action clear {
        tailf:actionpoint ncsproxy {
          tailf:internal;
        }
        description
          "Delete all received notifications from the
           'notification' list.";
        // NCS drop tailf:actionpoint
      }
      // NCS drop config false list notification
    }
  }

  augment "/ncs-internal:devices/ncs-internal:device/ncs-internal:notifications/ncs-internal:received-notifications/ncs-internal:notification/ncs-internal:data" {
    container ncs-commit-queue-progress-event {
      presence "";
      config false;
      description
        "Generated for state changes in the internal NCS commit queue.";
      leaf id {
        type string;
        description
          "This value represents the queue item id in the commit queue.
           The leafref is valid in the NCS which produced the event.";
      }
      leaf tag {
        type string;
        description
          "Opaque tag set in the commit. The leafref is valid in the NCS which
           produced the event.";
      }
      leaf state {
        type ncs_rpc_notif_commit-queue-item-event-status;
      }
      list completed-services {
        description
          "For a notification with state 'completed' or 'failed'
           this list contains all services that have been completed.
           A service has completed if all its device modifications
           have been successfully completed. ";
        key "name";
        leaf name {
          type string;
        }
        leaf-list completed-devices {
          description
            "This leaf-list contains all completed devices for this service.
             A device is completed when its device modifications are pushed
             to the network.";
          type string;
        }
      }
      list failed-services {
        description
          "For a notification with state 'completed' or 'failed'
           this list contains all services that have failed.
           A service has failed if any of its device modifications
           have failed. ";
        key "name";
        leaf name {
          type string;
        }
        leaf-list completed-devices {
          description
            "This leaf-list contains all completed devices for this service.
             A device is completed when its device modifications are pushed
             to the network.";
          type string;
        }
        leaf-list failed-devices {
          description
            "This leaf-list contains all devices which failed
             in the commit queue for this service.";
          type string;
        }
      }
      list completed-devices {
        key "name";
        description
          "In the case of 'executing' notification type. This list contains the
           devices that has successfully finished since the previous executing
           notification for this commit queue item.";
        leaf name {
          type string;
          description
            "The name of a completed device.";
        }
      }
      list transient-devices {
        key "name";
        description
          "In the case of a 'executing' notification, this list contains the
           devices for which a transient (temporary) error has occured.
           This list will be empty for all other notification types.";
        leaf name {
          type string;
          description
            "The name of a transient device.";
        }
      }
      list failed-devices {
        key "name";
        description
          "In the case of a 'executing' notification, this list contains all the
           currently known failed devices.
           For a 'failed' notification this list contains all failed devices.
           In the case of a 'deleted' notification that is emitted as a result of
           a prune action this list will contain the devices that are deleted.
           This list is empty in all other cases.";
        leaf name {
          type string;
          description
            "The name of a failed device.";
        }
        leaf reason {
          type string;
          description
            "A string representing the error for this failing device.";
        }
      }
      leaf trace-id {
        type string;
        description
          "The trace id assigned to the commit.";
      }
    }
  }
  augment "/ncs-internal:devices/ncs-internal:device/ncs-internal:netconf-notifications/ncs-internal:received-notifications/ncs-internal:notification/ncs-internal:data" {
    container ncs-commit-queue-progress-event {
      presence "";
      config false;
      description
        "Generated for state changes in the internal NCS commit queue.";
      leaf id {
        type string;
        description
          "This value represents the queue item id in the commit queue.
           The leafref is valid in the NCS which produced the event.";
      }
      leaf tag {
        type string;
        description
          "Opaque tag set in the commit. The leafref is valid in the NCS which
           produced the event.";
      }
      leaf state {
        type ncs_rpc_notif_commit-queue-item-event-status;
      }
      list completed-services {
        description
          "For a notification with state 'completed' or 'failed'
           this list contains all services that have been completed.
           A service has completed if all its device modifications
           have been successfully completed. ";
        key "name";
        leaf name {
          type string;
        }
        leaf-list completed-devices {
          description
            "This leaf-list contains all completed devices for this service.
             A device is completed when its device modifications are pushed
             to the network.";
          type string;
        }
      }
      list failed-services {
        description
          "For a notification with state 'completed' or 'failed'
           this list contains all services that have failed.
           A service has failed if any of its device modifications
           have failed. ";
        key "name";
        leaf name {
          type string;
        }
        leaf-list completed-devices {
          description
            "This leaf-list contains all completed devices for this service.
             A device is completed when its device modifications are pushed
             to the network.";
          type string;
        }
        leaf-list failed-devices {
          description
            "This leaf-list contains all devices which failed
             in the commit queue for this service.";
          type string;
        }
      }
      list completed-devices {
        key "name";
        description
          "In the case of 'executing' notification type. This list contains the
           devices that has successfully finished since the previous executing
           notification for this commit queue item.";
        leaf name {
          type string;
          description
            "The name of a completed device.";
        }
      }
      list transient-devices {
        key "name";
        description
          "In the case of a 'executing' notification, this list contains the
           devices for which a transient (temporary) error has occured.
           This list will be empty for all other notification types.";
        leaf name {
          type string;
          description
            "The name of a transient device.";
        }
      }
      list failed-devices {
        key "name";
        description
          "In the case of a 'executing' notification, this list contains all the
           currently known failed devices.
           For a 'failed' notification this list contains all failed devices.
           In the case of a 'deleted' notification that is emitted as a result of
           a prune action this list will contain the devices that are deleted.
           This list is empty in all other cases.";
        leaf name {
          type string;
          description
            "The name of a failed device.";
        }
        leaf reason {
          type string;
          description
            "A string representing the error for this failing device.";
        }
      }
      leaf trace-id {
        type string;
        description
          "The trace id assigned to the commit.";
      }
    }
  }
  augment "/ncs-internal:devices/ncs-internal:device/ncs-internal:config" {
    container devices {
      tailf:ncs-device-type "netconf";
      tailf:display-when "not(../../ncs-internal:module) or ../../ncs-internal:module[ncs-internal:name='tailf-ncs']";
      tailf:info
        "The managed devices and device communication settings";
      uses connect-grouping-extended;
      uses sync-to-grouping-extended;
      uses sync-from-grouping-extended;
      uses disconnect-grouping-extended;
      uses check-sync-grouping-extended;
      uses check-yang-modules-grouping-extended;
      uses fetch-ssh-host-keys-grouping-extended;
      uses migrate-grouping-extended;
      uses apply-template-grouping-extended;
      tailf:action clear-trace {
        tailf:actionpoint ncsproxy {
          tailf:internal;
        }
        description
          "Clear all trace files for all active traces for all managed
           devices.";
        tailf:info
          "Clear all trace files";
        // NCS drop tailf:actionpoint
      }
      tailf:action partial-sync-from {
        tailf:actionpoint ncsproxy {
          tailf:internal;
        }
        description
          "Synchronize parts of the devices' configuration by pulling from
           the network.

           If the wait-for-lock parameter is not given, the wait-for-lock
           device setting is going to be used.";
        // NCS drop tailf:actionpoint
        input {
          leaf-list path {
            type partial-sync-from-path;
            description
              "A list of paths to fetch. Any path pointing to a subtree outside
               /devices/device/config will be ignored.";
          }
          leaf suppress-positive-result {
            type empty;
            description
              "Use this additional parameter to only return
               devices that failed to sync.";
          }
          uses wait-for-lock;
        }
        output {
          uses sync-from-output;
        }
      }

      grouping timeouts {
        description
          "Timeouts used when communicating with a managed device.";
        leaf connect-timeout {
          tailf:info
            "Timeout in seconds for new connections";
          type uint32 {
            range "1..4294967";
          }
          units "seconds";
          description
            "The timeout in seconds for new connections to managed
             devices.";
        }
        leaf read-timeout {
          tailf:info
            "Timeout in seconds used when reading data";
          type uint32 {
            range "1..4294967";
          }
          units "seconds";
          description
            "The timeout in seconds used when reading data from a
             managed device.";
        }
        leaf write-timeout {
          tailf:info
            "Timeout in seconds used when writing data";
          type uint32 {
            range "1..4294967";
          }
          units "seconds";
          description
            "The timeout in seconds used when writing data to a
             managed device.";
        }
      }

      grouping device-profile-parameters {
        description
          "A set of parameters to use when communicating with a device.

           These parameters can be set on:

             o  global-settings
             o  device-profile
             o  device

           If a parameter is set on the device, its value is used.
           Otherwise, if the paramater is set in the device's
           device-profile, its value is used.  Otherwise, the global
           setting is used, if set.  Otherwise, the value used depends on
           the NED type.";
        uses timeouts;
        // NCS expand uses statement
        choice wait-for-lock-choice {
          leaf no-wait-for-lock {
            type empty;
            description
              "The action can't be performed while the device is being
               committed to (or waiting in the commit queue). This is to avoid
               getting inconsistent data when reading the configuration.
               This specifies that the action should not wait for device lock,
               instead, it should immediately fail if the device is being locked.";
          }
          container wait-for-lock {
            presence "Wait for device lock.";
            description
              "The action can't be performed while the device is being
               committed to (or waiting in the commit queue). This is to avoid
               getting inconsistent data when reading the configuration.
               This specifies a timeout to wait for a device lock to be placed
               in the commit queue. The lock will be automatically released once
               the action has been executed.";
            choice timeout-choice {
              default "infinity";
              leaf timeout {
                type uint32 {
                  range "0..4294967";
                }
                units "seconds";
                description
                  "Specifies a maximum number of seconds to wait for the
                   device to be locked.";
              }
              leaf infinity {
                description
                  "Wait infinitely for the lock, this is the default.";
                type empty;
              }
            }
          }
          description
            "When an action accepting the wait-for-lock parameter is
             called without providing the wait-for-lock parameter, the
             wait-for-lock-choice device setting is going to be used.";
        }
        container ssh-keep-alive {
          description
            "Controls SSH keep alive settings when communicating from this
             node to devices.";
          tailf:info
            "Controls SSH keep alive settings";
          leaf interval {
            type uint32 {
              range "0..4294967";
            }
            units "seconds";
            description
              "Seconds between SSH keep alive activity.";
          }
          leaf count {
            type uint8;
            description
              "Number of intervals to fail before failing the connection.";
          }
        }
        container ssh-algorithms {
          description
            "Supported (allowed) algorithms that should be used during
             SSH algorithm negotiations.";
          uses ssh-algorithms;
        }
        container ned-keep-alive {
          description
            "Controls NED keep alive settings when communicating from this
             node to devices. The keep alive settings can be configured for
             NSO to periodically perform activity to keep the session open.
             This is useful when for example CLI sessions have low idle timeouts.
             These settings only take effect if the NED actually implements
             this callback.";
          tailf:info
            "Controls NED keep alive settings";
          leaf interval {
            type uint32 {
              range "0..4294967";
            }
            units "seconds";
            description
              "Seconds between NED keep alive activity.";
          }
          leaf count {
            type uint8;
            description
              "Number of intervals to fail before failing the connection.";
          }
        }
        container connect-retries {
          tailf:info
            "Retry connect on transient errors";
          description
            "Settings for how to retry connecting if the device returns
             a transient failure.";
          leaf attempts {
            type uint8;
            tailf:info
              "Number of retries before giving up";
            description
              "Number of attempts to retry the connect before giving up.

               Setting this to 0 means that the connect fails
               immediately if the device returns a failure.";
          }
          leaf timeout {
            type uint32 {
              range "0..4294967";
            }
            units "seconds";
            tailf:info
              "Wait time in seconds between retries";
            description
              "Specifies the timeout in seconds between retries.";
          }
        }
        leaf trace {
          tailf:info
            "Trace the southbound communication to devices";
          type trace-flag;
          description
            "Controls southbound traffic trace to managed devices.";
        }
        leaf trace-output {
          tailf:info
            "Trace data output mode.";
          type trace-output;
          description
            "Controls how trace data is stored.";
        }
        container ned-settings {
          tailf:info
            "Control which device capabilities NCS uses";
          description
            "When communicating with a device, NCS adapts its behavior
             to the capabilities of the device.  When writing to the device,
             NCS uses the capabilities that give most control, and minimal
             risk of network inconsistencies.  The parameters in this
             container can be used to tweak NCS's behavior.  These parameters
             must be used with care.";
          leaf use-confirmed-commit {
            tailf:info
              "Control usage of confirmed commit";
            type boolean;
            description
              "Controls if NCS should use confirmed commit towards the
               device.  This setting has no effect if the device does
               not advertise support for confirmed-commit.

               If no value is configured, the default depends on the NED
               type.  The NETCONF NED by default uses confirmed commit if
               it is advertised.";
          }
          leaf use-validate {
            tailf:info
              "Control usage of validate";
            type boolean;
            description
              "Controls if NCS should use explicit validation towards the
               device.  This setting has no effect if the device does
               not advertise support for validate.

               It can be useful to disable validate in order to increase
               performance, since when validate is used, the device must
               validate the changes twice; at validate, and at commit.

               The advantage of using validate is that if the changes are
               sent to N devices, and validated on all of them, if one
               device fails the validation step, nothing has been committed
               to any device, and the transaction can easily be aborted.

               Without validate, NCS will commit on all N devices, and if
               one fails the commit due to a validation error, NCS has
               to undo the changes on the other devices.

               If no value is configured, the default depends on the NED
               type.  The NETCONF NED by default uses validate if
               it is advertised.";
          }
          leaf use-startup {
            tailf:info
              "Control usage of the startup datastore";
            type boolean;
            description
              "Controls if NCS should invoke the copy-running-to-startup
               operation towards the device.  This setting has no effect
               if the device does not advertise support for startup.

               It can be useful to disable this operation in order to
               increase performance, in the case that this is an
               expensive operation on the device.  It should be noted
               that in this case, the device will not have all changes
               persistently stored.  This can be combined with a job
               that performs this operation periodically, e.g., once an
               hour.

               If no value is configured, the default depends on the NED
               type.  The NETCONF NED by default uses startup if
               it is advertised.";
          }
          leaf use-transaction-id {
            tailf:info
              "Control usage of fetching the transaction id";
            type boolean;
            description
              "For some devices, getting the transaction id can be a costly
               operation.  If it is disabled, NCS will not be able to
               detect situations where NCS and the device are out of
               sync.

               If no value is configured, the default depends on the NED
               type.  The NETCONF NED by default reads the transaction id,
               if it knows how to get it from the device.";
          }
          leaf use-private-candidate {
            tailf:info
              "Control usage of the private candidate";
            type boolean;
            description
              "If the device supports the concept of a private
               candidate, NCS can use it instead of the normal, shared
               candidate.

               This option can be useful if there are other management
               applications other than NCS configuring the devices, and
               these other applications also use private candidates.

               If no value is configured, the default depends on the NED
               type.  The NETCONF NED by default does not use a private
               candidate.  For NETCONF, this option currently has effect
               only for Juniper devices running Junos.";
          }
          leaf use-junos-rollback {
            tailf:info
              "If set to true use device rollback as a revert strategy.";
            type boolean;
            description
              "Use the latest rollback instead of computing and sending a reverse
               diff when other device in the transaction has failed in commit and
               the configuration on successful devices needs to be reverted.

               Using rollback involves less communication overhead with the
               device but the rollback functionality might not be supported by
               all device software versions.

               This option has effect only for Juniper devices running Junos.";
          }
        }
        container commit-queue {
          tailf:info
            "Control settings for the commit queue";
          leaf enabled-by-default {
            type boolean;
            description
              "If this leaf is set, all commits for this device will by
               default go through the commit queue.";
          }
        }
        container session-limits {
          tailf:info
            "Parameters for limiting concurrent access to the device.";
          leaf max-sessions {
            type union {
              type enumeration {
                enum "unlimited";
              }
              type uint32 {
                range "1..max";
              }
            }
            description
              "Puts a limit to the total number of concurrent sessions
               allowed for the device. The label 'unlimited' implies that no
               upper limit exists for this device.";
          }
        }
        container session-pool {
          tailf:info
            "Control how sessions to related devices can be pooled.";
          description
            "NCS uses NED sessions when performing transactions, actions
             etc towards a device. When such a task is completed the NED
             session can either be closed or pooled.

             Pooling a NED session means that the session to the
             device is kept open for a configurable amount of
             time. During this time the session can be re-used for a new
             task. Thus the pooling concept exists to reduce the number
             of new connections needed towards a device that is often
             used.

             By default NCS uses pooling for all device types except
             SNMP. Normally there is no need to change the default
             values.";
          leaf max-sessions {
            type union {
              type enumeration {
                enum "unlimited";
              }
              type uint32;
            }
            description
              "Controls the maximum number of open sessions in the pool for
               a specific device. When this threshold is exceeded the oldest
               session in the pool will be closed.
               A Zero value will imply that pooling is disabled for
               this specific device. The label 'unlimited' implies that no
               upper limit exists for this specific device";
          }
          leaf idle-time {
            tailf:info
              "The maximum time that a session is kept open in the pool";
            type uint32 {
              range "1..4294967";
            }
            units "seconds";
            description
              "The maximum time that a session is kept open in the pool.
               If the session is not requested and used before the
               idle-time has expired, the session is closed.
               If no idle-time is set the default is 30 seconds.";
          }
        }
        container no-overwrite {
          tailf:info
            "Control settings for no-overwrite sync check";
          leaf enabled-by-default {
            type boolean;
            description
              "If this leaf is set, all commits for this device will by
               default make a no-overwrite sync check.";
          }
        }
        container lsa {
          description
            "Control settings that apply to the communication between this node
             and the LSA node the setting applies to. These settings do not
             propagate further in the LSA cluster and are ignored if set on a
             device that is not an LSA node.";
          container no-overwrite {
            description
              "Control settings for no-overwrite sync check between
               nodes in LSA cluster";
            leaf enabled-by-default {
              type boolean;
              description
                "If this leaf is set, all commits for this LSA node will by
                 default make a no-overwrite sync check.";
            }
          }
        }
        leaf out-of-sync-commit-behaviour {
          type enumeration {
            enum "reject";
            enum "accept";
          }
          description
            "Specifies the behaviour of a commit operation involving a
             device that is out of sync with NCS. Value accept assumes that
             the device's sync state is unknown and it is cleared on commit.
             The default behaviour is to reject such commits.";
        }
        choice choice-lsa {
          leaf use-lsa {
            type empty;
            description
              "Handle the LSA nodes as such. This is the default.";
          }
          leaf no-lsa {
            type empty;
            description
              "Do not handle any of the LSA nodes as such. These nodes
               will be handled as any other device. This has the same
               result as adding the commit flag 'no-lsa' to every commit.";
          }
          default "use-lsa";
        }
      }

      grouping capability-module-grouping {
        list capability {
          key "uri";
          leaf uri {
            tailf:cli-allow-range;
            type string;
          }
          leaf revision {
            type string;
          }
          leaf module {
            type string;
          }
          leaf-list feature {
            type string;
          }
          leaf-list deviation {
            type string;
          }
        }
        list module {
          key "name";
          leaf name {
            type string;
          }
          leaf revision {
            type string;
          }
          leaf-list feature {
            type string;
          }
          leaf-list deviation {
            type string;
          }
        }
        tailf:action copy-capabilities {
          tailf:actionpoint ncsproxy {
            tailf:internal;
          }
          description
            "Note: this action overwrites existing list of capabilities.

             This action copies the list of capabilities and the list of modules
             from another device or profile. When used on a device, this action
             is only intended to be used for pre-provisioning: it is not possible
             to override capabilities and modules provided by the
             NED implementation using this action.";
          // NCS drop tailf:actionpoint
          input {
            choice from-where {
              leaf from-device {
                type leafref {
                  path "/ncs-internal:devices/ncs-internal:device/ncs-internal:config/devices/device/name" {
                    tailf:xpath-root 3;
                  }
                }
              }
              leaf from-profile {
                type leafref {
                  path "/ncs-internal:devices/ncs-internal:device/ncs-internal:config/devices/profiles/capabilities-profile/name" {
                    tailf:xpath-root 3;
                  }
                }
              }
              mandatory true;
            }
          }
        }
      }
      container global-settings {
        tailf:info
          "Global settings for all managed devices.";
        description
          "Global settings for all managed devices. Some of these
           settings can be overridden per managed device.";
        uses device-profile-parameters {
          refine "wait-for-lock-choice" {
            description
              "By default all actions accepting the wait-for-lock parameter will
               not wait for lock if the wait-for-lock parameter was not given.";
            default "no-wait-for-lock";
          }
          refine "connect-timeout" {
            default "20";
          }
          refine "read-timeout" {
            default "20";
          }
          refine "write-timeout" {
            default "20";
          }
          refine "ssh-keep-alive/interval" {
            default "20";
          }
          refine "ssh-keep-alive/count" {
            default "3";
          }
          refine "ssh-algorithms/public-key" {
            default "ssh-ed25519";
            default "ecdsa-sha2-nistp256";
            default "ecdsa-sha2-nistp384";
            default "ecdsa-sha2-nistp521";
            default "rsa-sha2-512";
            default "rsa-sha2-256";
          }
          refine "ssh-algorithms/kex" {
            default "curve25519-sha256";
            default "curve25519-sha256@libssh.org";
            default "ecdh-sha2-nistp256";
            default "ecdh-sha2-nistp384";
            default "curve448-sha512";
            default "ecdh-sha2-nistp521";
            default "diffie-hellman-group15-sha512";
            default "diffie-hellman-group16-sha512";
            default "diffie-hellman-group14-sha256";
            default "diffie-hellman-group14-sha1";
          }
          refine "ssh-algorithms/mac" {
            default "AEAD_AES_128_GCM";
            default "AEAD_AES_256_GCM";
            default "hmac-sha2-512-etm@openssh.com";
            default "hmac-sha2-256-etm@openssh.com";
            default "hmac-sha2-512";
            default "hmac-sha2-256";
            default "hmac-sha1";
          }
          refine "ssh-algorithms/cipher" {
            default "aes128-gcm@openssh.com";
            default "AEAD_AES_128_GCM";
            default "chacha20-poly1305@openssh.com";
            default "aes256-gcm@openssh.com";
            default "AEAD_AES_256_GCM";
            default "aes128-ctr";
            default "aes192-ctr";
            default "aes256-ctr";
          }
          refine "ssh-algorithms/compression" {
            default "none";
            default "zlib";
            default "zlib@openssh.com";
          }
          refine "ssh-algorithms/dh-group/min-size" {
            default "1024";
          }
          refine "ssh-algorithms/dh-group/preferred-size" {
            default "2048";
          }
          refine "ssh-algorithms/dh-group/max-size" {
            default "8192";
          }
          refine "ned-keep-alive/count" {
            default "3";
          }
          refine "connect-retries/attempts" {
            default "0";
          }
          refine "connect-retries/timeout" {
            default "3";
          }
          refine "trace" {
            default "false";
          }
          refine "trace-output" {
            default "file";
          }
          refine "ned-settings/use-junos-rollback" {
            default "false";
          }
          refine "no-overwrite/enabled-by-default" {
            default "false";
          }
          refine "lsa/no-overwrite/enabled-by-default" {
            default "false";
          }
          refine "out-of-sync-commit-behaviour" {
            default "reject";
          }
          refine "session-limits/max-sessions" {
            default "unlimited";
          }
          augment "session-limits" {
            description
              "Parameters for limiting concurrent access to devices.";
            container connect-rate {
              leaf burst {
                type union {
                  type enumeration {
                    enum "unlimited";
                  }
                  type uint32 {
                    range "1..max";
                  }
                }
                default "unlimited";
                description
                  "The number of concurrent connect attempts allowed.
                   For example, the devices managed by NSO talk to the same
                   server for authentication which can only handle a limited
                   number of connections at a time. Then we can limit
                   the concurrency of connect attempts with this setting.";
              }
            }
            leaf max-wait-time {
              tailf:info
                "Max time in seconds to wait for device to be available.";
              type union {
                type enumeration {
                  enum "unlimited";
                }
                type uint32 {
                  range "0..max";
                }
              }
              units "seconds";
              default "10";
              description
                "Max time in seconds to wait for a device being available
                 to connect. When the maximum time is reached an error
                 is returned. Setting this to 0 means that the error is
                 returned immediately.";
            }
          }
          refine "session-pool/idle-time" {
            default "30";
          }
          augment "session-pool" {
            leaf pool-max-sessions {
              type union {
                type enumeration {
                  enum "unlimited";
                }
                type uint32;
              }
              default "200";
              description
                "Controls the grand total session count in the pool.
                 Independently on how different devices are pooled the grand
                 total session count can never exceed this value.
                 A zero value will imply that pooling is disabled for all devices.
                 The value 'unlimited' implies that no upper limit exists for
                 the number open sessions in the pool";
            }
          }
          refine "commit-queue/enabled-by-default" {
            default "false";
          }
          augment "commit-queue" {
            // NCS expand uses statement
            choice operation-mode {
              leaf async {
                type empty;
                description
                  "Commit the transaction data asynchronously to the commit queue.
                   This flag is useful when some device is non-operational or
                   has data waiting in the commit queue.

                   The operation returns successfully if the transaction data has
                   been successfully placed in the queue. The leaf
                   'commit-queue/id' is set as the queue identifier and the
                   leaf 'commit-queue/status' is set to 'async' in the result.";
              }
              container sync {
                presence "Commit through the commit queue and wait for completion";
                description
                  "Commit the transaction data synchronously to the commit queue.

                   The operation does not return until the transaction data has
                   been sent to all devices, or a timeout occurs. The leaf
                   'commit-queue/id' is set as the queue identifier and the
                   leaf 'commit-queue/status' is set to 'completed', 'failed',
                   'deleted' or 'timeout' dependent of the outcome.

                   If no device is involved in the transaction, the operation
                   returns directly.";
                choice timeout-choice {
                  leaf timeout {
                    type uint32 {
                      range "0..4294967";
                    }
                    units "seconds";
                    description
                      "Specifies a maximum number of seconds to wait for the
                       transaction to be committed. If the timer expires, the
                       transaction is kept in the commit-queue, and the operation
                       returns successfully. The leaf 'commit-queue/status'
                       is set to 'timeout', and the leaf 'commit-queue/id' is
                       set to the queue identifier in the result.";
                  }
                  leaf infinity {
                    description
                      "Wait infinitely for the transaction to be committed.";
                    type empty;
                  }
                  default "infinity";
                }
              }
              default "async";
            }
            leaf atomic {
              type boolean;
              default "true";
              description
                "This leaf sets the atomic behaviour of all new queue items
                 in the commit queue. If these are set to false, the devices
                 contained in these queue items can start executing if the
                 same devices in other non-atomic queue items ahead of it
                 in the queue are completed. If set to true, the atomic
                 integrity of these queue items are preserved.";
            }
            leaf retry-attempts {
              type union {
                type uint32 {
                  range "0..max";
                }
                type enumeration {
                  enum "unlimited";
                }
              }
              default "unlimited";
              tailf:info
                "Number of retries before giving up";
              description
                "Number of attempts to process the device in
                 the queue item if it returns a transient error.
                 For example, if NCS fails to connect to the device
                 or take a lock on it.

                 Setting this to 0 means that the queue item fails
                 immediately even on transient errors.";
            }
            leaf retry-timeout {
              type uint32 {
                range "0..4294967";
              }
              units "seconds";
              default "30";
              tailf:info
                "Wait time in seconds between retries";
              description
                "Specifies the timeout in seconds between retries.
                 This is not applicable for devices where
                 /devices/device/state/admin-state = 'call-home'.
                 These devices will wait until a TCP connection
                 is established from the NETCONF server.";
            }
            leaf check-integrity {
              tailf:info
                "Safeguard device and service integrity";
              type boolean;
              default "true";
              description
                "To guarantee service integrity NCS checks for
                 overlapping service or device modifications when committing
                 with the commit queue. These checks can be bypassed by
                 setting the leaf to false. This could potentially
                 commit changes that are not deployed to the network if a
                 queue item with overlapping data failed ahead in the
                 queue. The benefit of doing so is increased throughput.";
            }
            leaf error-option {
              type enumeration {
                enum "continue-on-error" {
                  description
                    "The commit queue will continue on errors. No rollback data
                     will be created. This is the preferred choice when
                     re-deploying a service as a re-deploy doesn't have a
                     transaction intent.";
                }
                enum "rollback-on-error" {
                  description
                    "The commit queue items will roll back on errors. The commit
                     queue will place a lock on the failed queue item, thus
                     blocking other queue items with overlapping devices to be
                     executed. The rollback action will then automatically be
                     invoked when the failed queue item has finished its
                     execution. The lock is removed as part of the rollback.";
                }
                enum "stop-on-error" {
                  description
                    "The commit queue will place a lock on the failed queue item,
                     thus blocking other queue items with overlapping devices to
                     be executed. The lock must then either manually be released
                     or the rollback action under
                     /devices/commit-queue/completed be invoked.";
                }
              }
              default "continue-on-error";
              description
                "The error option to use. Depending on the selected error option
                 NCS will store the reverse of the original transaction intent
                 to be able to undo the transaction changes and get back to the
                 previous state. This data is stored in the
                 /devices/device/commit-queue/completed tree from where it can
                 be viewed and invoked with the rollback action. When invoked
                 the data will be removed.";
            }
          }
        }
        container commit-retries {
          tailf:info
            "Retry commits on transient errors";
          description
            "Settings for how to retry commits if some device returns
             a transient error. For example, if NCS fails to take a
             lock on a device, it can retry after a short time.";
          leaf attempts {
            type uint8;
            default "5";
            tailf:info
              "Number of retries before giving up";
            description
              "Number of attempts to retry the commit before giving up.

               Setting this to 0 means that the transaction fails
               immediately even on transient errors.";
          }
          leaf timeout {
            type uint32 {
              range "0..4294967";
            }
            units "seconds";
            default "3";
            tailf:info
              "Wait time in seconds between retries";
            description
              "Specifies the timeout in seconds between retries.";
          }
        }
        leaf trace-dir {
          tailf:info
            "The directory where trace files are stored";
          type string;
          default ".";
          description
            "Specifies the directory where southbound traffic trace log files
             to managed devices are stored.

             The trace files are called <type>-<device-name>.trace
             where <type> is one of 'netconf', 'snmp', or 'ned', depending on
             the type of the managed device.";
        }
        leaf report-multiple-errors {
          type boolean;
          default "false";
          description
            "By default, when the NCS device manager commits data
             southbound and when there are errors, we only report
             the first error to the operator, this flag makes NCS
             report all errors reported by managed devices";
        }
      }
      container profiles {
        tailf:info
          "Device profile parameters";
        list profile {
          tailf:info
            "Parameters for a device profile";
          key "name";
          leaf name {
            tailf:info
              "The name of the device profile";
            type string;
          }
          uses device-profile-parameters;
        }
        list capabilities-profile {
          key "name";
          leaf name {
            tailf:info
              "The name of the device profile";
            type string;
          }
          uses capability-module-grouping;
        }
      }
      container authgroups {
        tailf:info
          "Authentication for managed devices";
        description
          "Named authgroups are used to decide how to map a local NCS user to
           remote authentication credentials on a managed device.

           The list 'group' is used for NETCONF and CLI managed devices.

           The list 'snmp-group' is used for SNMP managed devices.";
        list group {
          tailf:info
            "Authentication settings for a group of devices";
          key "name";
          description
            "When NCS connects to a managed device, it locates the
             authgroup configured for that device.  Then NCS looks up
             the local NCS user name in the 'umap' list.  If an entry is
             found, the credentials configured is used when
             authenticating to the managed device.

             If no entry is found in the 'umap' list, the credentials
             configured in 'default-map' are used.

             If no 'default-map' has been configured, and the local NCS
             user name is not found in the 'umap' list, the connection
             to the managed device fails.";

          grouping remote-user-remote-auth {
            description
              "Remote authentication credentials.";
            choice login-credentials {
              mandatory true;
              case stored {
                choice remote-user {
                  mandatory true;
                  leaf same-user {
                    tailf:info
                      "Use the local NCS user name as the remote user
                       name";
                    type empty;
                    description
                      "If this leaf exists, the name of the local NCS user is used
                       as the remote user name.";
                  }
                  leaf remote-name {
                    tailf:info
                      "Specify device user name";
                    type string;
                    description
                      "Remote user name.";
                  }
                }
                choice remote-auth {
                  mandatory true;
                  leaf same-pass {
                    tailf:info
                      "Use the local NCS password as the remote
                       password";
                    type empty;
                    description
                      "If this leaf exists, the password used by the local user
                       when logging in to NCS is used as the remote password.";
                  }
                  leaf remote-password {
                    tailf:ned-ignore-compare-config;
                    tailf:info
                      "Specify the remote password";
                    tailf:suppress-echo true;
                    type tailf:aes-256-cfb-128-encrypted-string;
                    description
                      "Remote password.";
                  }
                  case public-key {
                    uses public-key-auth;
                  }
                }
                choice remote-secondary-auth {
                  leaf same-secondary-password {
                    tailf:info
                      "Use the local NCS password as the remote
                       secondary password";
                    type empty;
                    description
                      "If this leaf exists, the password used by the local user
                       when logging in to NCS is used as the remote secondary
                       password.";
                  }
                  leaf remote-secondary-password {
                    tailf:ned-ignore-compare-config;
                    tailf:info
                      "Second password for configuration";
                    tailf:suppress-echo true;
                    type tailf:aes-256-cfb-128-encrypted-string;
                    description
                      "Some CLI based devices require a second
                       additional password to enter config mode";
                  }
                }
              }
              case callback {
                leaf callback-node {
                  description
                    "Invoke a standalone action to retrieve login credentials for
                     managed devices on the 'callback-node' instance.

                     The 'action-name' action is invoked on the callback node that
                     is specified by an instance identifer.";
                  mandatory true;
                  // NCS patched to string, due to LSA partial NED
                  type string;
                }
                leaf action-name {
                  description
                    "The action to call when a notification is received.

                     The action must use 'authgroup-callback-input-params'
                     grouping for input and 'authgroup-callback-output-params'
                     grouping for output from tailf-ncs-devices.yang.";
                  type yang:yang-identifier;
                  mandatory true;
                  // NCS drop tailf:validate
                }
              }
            }
          }
          leaf name {
            tailf:info
              "The name of the authgroup";
            type string;
            description
              "The name of the authgroup.";
          }
          container default-map {
            presence "Map unknown users";
            description
              "If an authgroup has a default-map, it is used if a local
               NCS user is not found in the umap list.";
            tailf:info
              "Remote authentication parameters for users not in umap";
            uses remote-user-remote-auth;
          }
          list umap {
            key "local-user";
            description
              "The umap is a list with the local NCS user name as key.
               It maps the local NCS user name to remote authentication
               credentials.";
            tailf:info
              "Map NCS users to remote authentication parameters";
            leaf local-user {
              type string;
              description
                "The local NCS user name.";
            }
            uses remote-user-remote-auth;
          }
        }
        list snmp-group {
          tailf:info
            "SNMP authentication groups";
          key "name";
          description
            "When NCS connects to a managed device over SNMP, it locates
             the snmp-group configured for that device.  Then NCS looks
             up the local NCS user name in the 'umap' list.  If an entry
             is found, the credentials configured is used when
             authenticating to the managed device.

             If no entry is found in the 'umap' list, or credentials for
             the requested SNMP version has not been configured, the
             credentials configured in 'default-map' are used.

             If no 'default-map' has been configured, and the local NCS
             user name is not found in the 'umap' list, the connection
             to the managed device fails.";

          grouping key {
            choice key-type {
              leaf same-password {
                tailf:info
                  "Use the local NCS password to create a localized key";
                type empty;
                description
                  "Use the local NCS password as the password
                   used by NCS to create a localized key, as described
                   in RFC 3414.";
              }
              leaf remote-password {
                tailf:ned-ignore-compare-config;
                tailf:suppress-echo true;
                type tailf:aes-256-cfb-128-encrypted-string;
                description
                  "If this leaf is set, NCS uses its value to create
                   a localized key, as described in RFC 3414.";
                tailf:info
                  "Explicit password";
              }
              leaf key {
                type tailf:hex-list;
                description
                  "Non-localized key specified as a list of
                   colon-separated hexa-decimal octets.  NCS localizes
                   this key for a device before it is used, as described
                   in RFC 3414.";
                tailf:info
                  "Explicit non-localized key";
              }
            }
          }

          grouping remote-snmp-credentials {
            description
              "Remote SNMP credentials.";
            choice community {
              leaf community-name {
                type string;
                description
                  "A community name that can be represented as a
                   YANG string.";
                tailf:info
                  "Community name as a string";
              }
              leaf community-binary-name {
                type binary;
                description
                  "A community name represented as a binary value.";
                tailf:info
                  "Community name as a binary value";
              }
            }
            container usm {
              presence "enables usm";
              tailf:info
                "USM parameters";
              choice remote-user {
                mandatory true;
                leaf same-user {
                  type empty;
                  description
                    "Use the local NCS user name as the remote USM user name.";
                  tailf:info
                    "Use current user's local name as USM user name";
                }
                leaf remote-name {
                  type string {
                    length "1..32";
                  }
                  description
                    "Remote USM user name.";
                  reference "SNMP-USER-BASED-SM-MIB.usmUserName";
                  tailf:info
                    "Explicit USM user name";
                }
              }
              leaf security-level {
                type snmp-security-level;
                mandatory true;
                must ". = 'no-auth-no-priv' or ../auth" {
                  tailf:xpath-root 3;
                  error-message "when security-level indicates authentication, the auth parameters must be set.";
                  tailf:dependency "../auth";
                }
                must "(. = 'auth-priv' and ../priv) or (. != 'auth-priv')" {
                  tailf:xpath-root 3;
                  error-message "when security-level indicates privacy, the priv parameters must be set.";
                  tailf:dependency "../priv";
                }
                tailf:info
                  "SNMP security level";
              }
              container auth {
                presence "enables authentication";
                tailf:info
                  "SNMP authentication parameters";
                choice protocol {
                  mandatory true;
                  reference "SNMP-USER-BASED-SM-MIB.usmUserAuthProtocol";
                  container md5 {
                    uses key;
                    reference "SNMP-USER-BASED-SM-MIB.usmHMACMD5AuthProtocol";
                  }
                  container sha {
                    uses key;
                    reference "SNMP-USER-BASED-SM-MIB.usmHMACSHAAuthProtocol";
                  }
                }
              }
              container priv {
                presence "enables privacy";
                tailf:info
                  "SNMP privacy parameters";
                must '../auth' {
                  tailf:xpath-root 3;
                  error-message "when privacy is used, authentication must also be used";
                }
                choice protocol {
                  mandatory true;
                  reference "SNMP-USER-BASED-SM-MIB.usmUserPrivProtocol";
                  container des {
                    uses key;
                    reference "SNMP-USER-BASED-SM-MIB.usmDESPrivProtocol";
                  }
                  container aes {
                    uses key;
                    reference "SNMP-USM-AES-MIB.usmAesCfb128Protocol";
                  }
                }
              }
            }
          }
          leaf name {
            tailf:info
              "The name of the snmp authgroup";
            type string;
            description
              "The name of the snmp authgroup.";
          }
          container default-map {
            presence "Map unknown users";
            description
              "If an snmp auth group has a default-map, it is used if a
               local NCS user is not found in the umap list.";
            tailf:info
              "Remote authentication parameters for users not in umap";
            uses remote-snmp-credentials;
          }
          list umap {
            key "local-user";
            description
              "The umap is a list with the local NCS user name as key.
               It maps the local NCS user name to remote authentication
               credentials.";
            tailf:info
              "Map NCS users to remote authentication parameters";
            leaf local-user {
              type string;
              description
                "The local NCS user name.";
            }
            uses remote-snmp-credentials;
          }
        }
      }
      list template {
        tailf:info
          "Named configuration templates for devices";
        key "name";
        description
          "This list is used to define named template configurations that
           can be used to either instantiate the configuration for new
           devices, or to apply snippets of configurations to existing
           devices.

           A template is applied by invoking the 'apply-template' action
           in a device-group or in a device.

           When template is applied, the nodes in the template are by
           default merged with the nodes in the target device.  This
           behaviour can be changed by using tags:

           If a list or container node in the template contains a tag
           with the value 'replace', the template application will
           change from merge to replace for this node.

           Otherwise, if a list or container node in the template
           contains a tag with the value 'nocreate', the template
           application will never create this node or anything below it;
           it will only modify existing containers and list entries.

           Otherwise, if a node in the template contains a tag with the
           value 'delete', the template application will delete this
           node from the device, if it exists.";
        leaf name {
          type string;
          description
            "The name of a specific template configuration.";
        }
        list ned-id {
          key "id";
          leaf id {
            // NCS patched to string, due to LSA partial NED
            type string;
          }
          container config {
            // NCS drop tailf:mount-point
            tailf:cli-add-mode;
            tailf:cli-expose-ns-prefix;
            description
              "This container is augmented with data models from the devices.";
          }
          tailf:action copy {
            tailf:actionpoint ncsproxy {
              tailf:internal;
            }
            description
              "Copy the template to a new NED identity.

               The action will ignore schema-related errors and instead report
               the paths that failed to be copied in the action output.";
            tailf:info
              "Copy the template to new NED identity";
            tailf:cli-configure-mode;
            // NCS drop tailf:actionpoint
            input {
              leaf ned-id {
                mandatory true;
                tailf:info
                  "The NED identity the template should be copied to";
                // NCS patched to string, due to LSA partial NED
                type string;
              }
            }
            output {
              list failed {
                tailf:code-name "failedx";
                key "path";
                leaf path {
                  type yang:xpath1.0;
                }
                description
                  "Paths that failed to be copied due to schema differences.";
              }
            }
          }
        }
        container config {
          tailf:cli-add-mode;
          tailf:cli-expose-ns-prefix;
          description
            "Just to support releases prior to 4.5. Will be deprecated";
        }
      }
      list device-group {
        tailf:info
          "Groups of devices";
        key "name";
        leaf name {
          type string;
        }
        description
          "A named group of devices, some actions can be
           applied to an entire  group of devices, for example
           apply-template, and the sync actions.";
        // NCS drop tailf:validate
        uses location {
          description
            "Location of the device group.  These nodes are expected to be
             configured by the operator, typically by using a map application
             in e.g., the Web UI.";
        }
        leaf-list device-name {
          tailf:info
            "Device within group";
          tailf:non-strict-leafref {
            path "/ncs-internal:devices/ncs-internal:device/ncs-internal:config/devices/device/name" {
              tailf:xpath-root 3;
            }
          }
          type string;
          // NCS drop tailf:validate
        }
        leaf-list device-group {
          tailf:info
            "Group within group";
          type leafref {
            path "/ncs-internal:devices/ncs-internal:device/ncs-internal:config/devices/device-group/name" {
              tailf:xpath-root 3;
            }
          }
          description
            "A list of device groups contained in this device group.

             Recursive definitions are not valid.";
        }
        // NCS drop config false leaf-list member
        // NCS drop config false list 'ned-id'
        uses connect-grouping;
        uses sync-to-grouping;
        uses sync-from-grouping;
        uses check-sync-grouping;
        uses check-yang-modules-grouping;
        uses fetch-ssh-host-keys-grouping;
        uses apply-template-grouping;
      }
      list mib-group {
        tailf:info
          "A list of named groups of MIBs";
        key "name";
        description
          "A list of named groups of MIBs.

           This list is used so that SNMP devices can refer to collections
           of MIBs, instead of having to refer to individual MIBs.

           For example, an operator can configure one MIB group per
           device model.";
        // NCS drop tailf:validate
        leaf name {
          type string;
          description
            "An arbitrary name of the MIB group.";
        }
        leaf-list mib-module {
          tailf:info
            "MIB module names or name prefixes";
          type string;
          description
            "A list of MIB module names or MIB module name prefixes in
             this MIB group.

             The string is either exactly matches a MIB module, e.g.,
             'SNMPv2-MIB', or a prefix followed by a wildcard, e.g.,
             'SNMP-*'.  Such a prefix matches all MIB modules with names
             starting by 'SNMP-'.";
        }
        leaf-list mib-group {
          tailf:info
            "A list of MIB groups contained in this MIB group";
          type leafref {
            path "/ncs-internal:devices/ncs-internal:device/ncs-internal:config/devices/mib-group/name" {
              tailf:xpath-root 3;
            }
          }
          description
            "A list of MIB groups contained in this MIB group.

             Recursive definitions are not valid.";
        }
      }
      list device {
        tailf:info
          "The list of managed devices";
        key "name";
        description
          "This list contains all devices managed by NCS.";
        leaf name {
          tailf:info
            "A string uniquely identifying the managed device";
          tailf:cli-allow-range;
          type string;
          description
            "A string uniquely identifying the managed device.";
        }
        must "address or lsa-remote-node or ./state/admin-state = 'call-home'" {
          tailf:xpath-root 3;
          error-message "Either address or lsa-remote-node must be configured or the admin-state indicate call-home.";
          tailf:dependency "ncs:address";
          tailf:dependency "ncs:lsa-remote-node";
          tailf:dependency "ncs:state/admin-state";
        }
        // NCS drop config false leaf 'last-changed'
        choice address-choice {
          case device {
            leaf address {
              tailf:info
                "IP address or host name for the management interface";
              tailf:cli-min-column-width 50;
              type inet:host;
              description
                "IP address or host name for the management interface on
                 the device.";
            }
            leaf port {
              tailf:info
                "Port for the management interface";
              type inet:port-number;
              description
                "Port for the management interface on the device. If this leaf
                 is not configured, NCS will use a default value based on the
                 type of device. For example, a NETCONF device uses port 830,
                 a CLI device over SSH uses port 22, and an SNMP device uses
                 port 161.";
            }
          }
          case lsa-device {
            leaf lsa-remote-node {
              // NCS drop when statement
              type leafref {
                path "/ncs-internal:devices/ncs-internal:device/ncs-internal:config/cluster/remote-node/name" {
                  tailf:xpath-root 3;
                }
              }
              description
                "Setting lsa-remote-node indicates that this device is the same
                 as the cluster node. When set the address and port of the
                 cluster node is used for this device.";
            }
          }
        }
        leaf local-user {
          type string;
          description
            "The local user is used when setting up a device
             connection for call home connections.";
        }
        uses ssh-connection-config;
        leaf description {
          tailf:info
            "Free form textual description";
          type string;
          description
            "Free form text describing the device.";
        }
        uses location {
          description
            "Location of the device.  These nodes are expected to be
             configured by the operator, typically by using a map application
             in e.g., the Web UI.";
        }

        grouping ne-type {
          leaf authgroup {
            tailf:info
              "Authentication credentials for the device";
            type leafref {
              path "/ncs-internal:devices/ncs-internal:device/ncs-internal:config/devices/authgroups/group/name" {
                tailf:xpath-root 3;
              }
            }
            description
              "The authentication credentials used when connecting
               to this managed device.

               This leaf must be set for NETCONF and CLI devices, and
               may be used by generic NEDs, if applicable.";
          }
          container device-type {
            tailf:info
              "Management protocol for the device";
            choice ne-type {
              case netconf {
                container netconf {
                  must '../../authgroup' {
                    tailf:xpath-root 3;
                    error-message "A NETCONF device must have a authgroup.";
                    tailf:dependency "../../authgroup";
                  }
                  leaf ned-id {
                    tailf:info
                      "The NED Identity";
                    // NCS patched to string, due to LSA partial NED
                    type string;
                    // NCS drop tailf:callpoint
                    // NCS drop tailf:validate
                    mandatory true;
                  }
                }
              }
              case generic {
                container generic {
                  tailf:info
                    "Use a generic NED to talk to the device";
                  leaf ned-id {
                    tailf:info
                      "The NED Identity";
                    // NCS patched to string, due to LSA partial NED
                    type string;
                    // NCS drop tailf:callpoint
                    // NCS drop tailf:validate
                    mandatory true;
                  }
                }
              }
              case cli {
                container cli {
                  tailf:info
                    "Use CLI to communicate with the device";
                  must '../../authgroup' {
                    tailf:xpath-root 3;
                    error-message "A CLI device must have a authgroup.";
                    tailf:dependency "../../authgroup";
                  }
                  leaf ned-id {
                    tailf:info
                      "The NED Identity";
                    // NCS patched to string, due to LSA partial NED
                    type string;
                    // NCS drop tailf:callpoint
                    // NCS drop tailf:validate
                    mandatory true;
                  }
                  leaf protocol {
                    tailf:info
                      "The CLI protocol";
                    type enumeration {
                      enum "telnet";
                      enum "ssh";
                    }
                    default "ssh";
                  }
                }
              }
              case snmp {
                container snmp {
                  leaf version {
                    type snmp-version;
                    mandatory true;
                    tailf:info
                      "SNMP version to use";
                  }
                  leaf context-name {
                    when "../version = 'v3'" {
                      tailf:xpath-root 3;
                    }
                    type string;
                    default "";
                    description
                      "The SNMP context name to use when communicating
                       with the device.  If an SNMP engine supports multiple
                       contexts, each context must be handled as a separate
                       managed-device in NCS.";
                    reference "RFC 3411: Architecture for SNMP Management Frameworks";
                    tailf:info
                      "SNMP context to use";
                  }
                  leaf ned-id {
                    tailf:info
                      "The NED Identity";
                    // NCS patched to string, due to LSA partial NED
                    type string;
                    mandatory true;
                  }
                  leaf snmp-authgroup {
                    type leafref {
                      path "/ncs-internal:devices/ncs-internal:device/ncs-internal:config/devices/authgroups/snmp-group/name" {
                        tailf:xpath-root 3;
                      }
                    }
                    mandatory true;
                    tailf:info
                      "Name of an SNMP authgroup";
                  }
                  leaf retries {
                    type uint8;
                    default "3";
                    description
                      "Specifies the number of retries to be used when sending
                       a request.";
                    tailf:info
                      "Number of times a request is resent";
                  }
                  leaf timeout {
                    type uint32 {
                      range "0..4294967";
                    }
                    units "seconds";
                    default "1";
                    description
                      "Specifies the timeout in seconds between retries.";
                    tailf:info
                      "Wait time in seconds between retries";
                  }
                  leaf-list mib-group {
                    tailf:info
                      "A list of MIB groups implemented by the device";
                    type leafref {
                      path "/ncs-internal:devices/ncs-internal:device/ncs-internal:config/devices/mib-group/name" {
                        tailf:xpath-root 3;
                      }
                    }
                    description
                      "A list of MIB groups implemented by the device.

                       In SNMP, there is no generic, automatic way to
                       figure out which MIBs an agent implements.  Thus,
                       this list can be used to inform NCS which MIBs the
                       device implements.

                       If this list is empty, NCS assumes that the device
                       implements all MIBs known to NCS.

                       The MIBs NCS thinks the device implements are
                       listed in /devices/module.  These
                       modules are used by NCS to control what data can
                       be configured under /devices/device/config,
                       and what data is shown in
                       /devices/device/live-status.";
                  }
                }
              }
            }
          }
        }
        // NCS expand uses statement
        leaf authgroup {
          tailf:info
            "Authentication credentials for the device";
          type leafref {
            path "/ncs-internal:devices/ncs-internal:device/ncs-internal:config/devices/authgroups/group/name" {
              tailf:xpath-root 3;
            }
          }
          description
            "The authentication credentials used when connecting
             to this managed device.

             This leaf must be set for NETCONF and CLI devices, and
             may be used by generic NEDs, if applicable.";
        }
        container device-type {
          tailf:info
            "Management protocol for the device";
          choice ne-type {
            case netconf {
              container netconf {
                must '../../authgroup' {
                  tailf:xpath-root 3;
                  error-message "A NETCONF device must have a authgroup.";
                  tailf:dependency "../../authgroup";
                }
                leaf ned-id {
                  tailf:info
                    "The NED Identity";
                  // NCS patched to string, due to LSA partial NED
                  type string;
                  // NCS drop tailf:callpoint
                  // NCS drop tailf:validate
                  mandatory true;
                }
              }
            }
            case generic {
              container generic {
                tailf:info
                  "Use a generic NED to talk to the device";
                leaf ned-id {
                  tailf:info
                    "The NED Identity";
                  // NCS patched to string, due to LSA partial NED
                  type string;
                  // NCS drop tailf:callpoint
                  // NCS drop tailf:validate
                  mandatory true;
                }
              }
            }
            case cli {
              container cli {
                tailf:info
                  "Use CLI to communicate with the device";
                must '../../authgroup' {
                  tailf:xpath-root 3;
                  error-message "A CLI device must have a authgroup.";
                  tailf:dependency "../../authgroup";
                }
                leaf ned-id {
                  tailf:info
                    "The NED Identity";
                  // NCS patched to string, due to LSA partial NED
                  type string;
                  // NCS drop tailf:callpoint
                  // NCS drop tailf:validate
                  mandatory true;
                }
                leaf protocol {
                  tailf:info
                    "The CLI protocol";
                  type enumeration {
                    enum "telnet";
                    enum "ssh";
                  }
                  default "ssh";
                }
              }
            }
            case snmp {
              container snmp {
                leaf version {
                  type snmp-version;
                  mandatory true;
                  tailf:info
                    "SNMP version to use";
                }
                leaf context-name {
                  when "../version = 'v3'" {
                    tailf:xpath-root 3;
                  }
                  type string;
                  default "";
                  description
                    "The SNMP context name to use when communicating
                     with the device.  If an SNMP engine supports multiple
                     contexts, each context must be handled as a separate
                     managed-device in NCS.";
                  reference "RFC 3411: Architecture for SNMP Management Frameworks";
                  tailf:info
                    "SNMP context to use";
                }
                leaf ned-id {
                  tailf:info
                    "The NED Identity";
                  // NCS patched to string, due to LSA partial NED
                  type string;
                  mandatory true;
                }
                leaf snmp-authgroup {
                  type leafref {
                    path "/ncs-internal:devices/ncs-internal:device/ncs-internal:config/devices/authgroups/snmp-group/name" {
                      tailf:xpath-root 3;
                    }
                  }
                  mandatory true;
                  tailf:info
                    "Name of an SNMP authgroup";
                }
                leaf retries {
                  type uint8;
                  default "3";
                  description
                    "Specifies the number of retries to be used when sending
                     a request.";
                  tailf:info
                    "Number of times a request is resent";
                }
                leaf timeout {
                  type uint32 {
                    range "0..4294967";
                  }
                  units "seconds";
                  default "1";
                  description
                    "Specifies the timeout in seconds between retries.";
                  tailf:info
                    "Wait time in seconds between retries";
                }
                leaf-list mib-group {
                  tailf:info
                    "A list of MIB groups implemented by the device";
                  type leafref {
                    path "/ncs-internal:devices/ncs-internal:device/ncs-internal:config/devices/mib-group/name" {
                      tailf:xpath-root 3;
                    }
                  }
                  description
                    "A list of MIB groups implemented by the device.

                     In SNMP, there is no generic, automatic way to
                     figure out which MIBs an agent implements.  Thus,
                     this list can be used to inform NCS which MIBs the
                     device implements.

                     If this list is empty, NCS assumes that the device
                     implements all MIBs known to NCS.

                     The MIBs NCS thinks the device implements are
                     listed in /devices/module.  These
                     modules are used by NCS to control what data can
                     be configured under /devices/device/config,
                     and what data is shown in
                     /devices/device/live-status.";
                }
              }
            }
          }
          must 'netconf or generic or cli or snmp' {
            tailf:xpath-root 3;
            error-message "must configure one of: snmp, cli, generic, netconf";
            tailf:dependency "ncs:netconf";
            tailf:dependency "ncs:generic";
            tailf:dependency "ncs:cli";
            tailf:dependency "ncs:snmp";
          }
        }
        tailf:action migrate {
          tailf:actionpoint ncsproxy {
            tailf:internal;
          }
          description
            "Change the NED identity and migrate all data. Reads and commits
             the actual device configuration as a side-effect.

             The action reports what paths have been modified and the services
             affected by those changes.

             If the wait-for-lock parameter is not given, the wait-for-lock
             device setting is going to be used.";
          tailf:info
            "Migrate the device to a new NED type";
          // NCS drop tailf:actionpoint
          input {
            leaf new-ned-id {
              mandatory true;
              tailf:info
                "The new NED Identity";
              // NCS patched to string, due to LSA partial NED
              type string;
            }
            leaf no-networking {
              type empty;
              description
                "Do not generate any southbound traffic towards the
                 device. Use the device configuration in CDB.";
            }
            choice display-mode {
              case display-result {
                leaf dry-run {
                  type empty;
                }
                leaf verbose {
                  tailf:info
                    "Report all service instances";
                  description
                    "Report all service instances instead of just the
                     service points.";
                  type empty;
                }
              }
              leaf suppress-positive-result {
                tailf:info
                  "Only return result if some error occurred";
                type empty;
                description
                  "If this optional parameter is included, result is only
                   returned if an error occurs.";
              }
            }
            uses wait-for-lock;
          }
          output {
            uses migrate-result;
          }
        }
        leaf device-profile {
          type leafref {
            path "/ncs-internal:devices/ncs-internal:device/ncs-internal:config/devices/profiles/profile/name" {
              tailf:xpath-root 3;
            }
          }
        }
        uses device-profile-parameters {
          augment "commit-queue" {
            // NCS drop config false leaf 'queue-length'
            // NCS drop config false list 'waiting-for'
          }
        }
        // NCS drop config false container 'active-settings'
        list live-status-protocol {
          tailf:info
            "Additional protocols for the live-tree (read-only)";
          key "name";
          description
            "It is possible to have additional NEDs speaking
             southbound to the managed device for the device's
             'live-status' tree.

             All configuration data must be handled by one NED, but
             multiple NEDs can be used for the 'live-status' tree.

             For example a CLI NED can be used for 'show routes'
             and the SNMP NED for some additional MIBs";
          leaf name {
            type string;
          }
          leaf address {
            tailf:info
              "IP Address for the management interface";
            type inet:host;
            description
              "IP address or host name for the management interface on
               the device. If omitted the same address as configured for
               this device will be used.";
          }
          leaf port {
            tailf:info
              "Port for the management interface";
            type inet:port-number;
            description
              "Port for the management interface on the device.  If this leaf
               is not configured, NCS will use a default value based on
               the type of device.  For example, a NETCONF device uses
               port 830, a CLI device over SSH uses port 22, and an SNMP
               device uses port 161.";
          }
          container ssh {
            presence "protocol-specific ssh host keys";
            tailf:info
              "SSH host key configuration";
            tailf:code-name "ssh_container";
            description
              "SSH host keys for this protocol. If not present, the host keys
               configured for this device will be used.";
            uses ssh-host-keys;
          }
          container ssh-algorithms {
            tailf:info
              "SSH algorithms configuration";
            description
              "Supported (allowed) algorithms that should be used during
               SSH algorithm negotiations. If a specific algorithm type
               is not present, the algorithms configured for this device
               will be used.";
            uses ssh-algorithms;
          }
          // NCS expand uses statement
          leaf authgroup {
            tailf:info
              "Authentication credentials for the device";
            type leafref {
              path "/ncs-internal:devices/ncs-internal:device/ncs-internal:config/devices/authgroups/group/name" {
                tailf:xpath-root 3;
              }
            }
            description
              "The authentication credentials used when connecting
               to this managed device.

               This leaf must be set for NETCONF and CLI devices, and
               may be used by generic NEDs, if applicable.";
          }
          container device-type {
            tailf:info
              "Management protocol for the device";
            choice ne-type {
              case netconf {
                container netconf {
                  must '../../authgroup' {
                    tailf:xpath-root 3;
                    error-message "A NETCONF device must have a authgroup.";
                    tailf:dependency "../../authgroup";
                  }
                  leaf ned-id {
                    tailf:info
                      "The NED Identity";
                    // NCS patched to string, due to LSA partial NED
                    type string;
                    // NCS drop tailf:callpoint
                    // NCS drop tailf:validate
                    mandatory true;
                  }
                }
              }
              case generic {
                container generic {
                  tailf:info
                    "Use a generic NED to talk to the device";
                  leaf ned-id {
                    tailf:info
                      "The NED Identity";
                    // NCS patched to string, due to LSA partial NED
                    type string;
                    // NCS drop tailf:callpoint
                    // NCS drop tailf:validate
                    mandatory true;
                  }
                }
              }
              case cli {
                container cli {
                  tailf:info
                    "Use CLI to communicate with the device";
                  must '../../authgroup' {
                    tailf:xpath-root 3;
                    error-message "A CLI device must have a authgroup.";
                    tailf:dependency "../../authgroup";
                  }
                  leaf ned-id {
                    tailf:info
                      "The NED Identity";
                    // NCS patched to string, due to LSA partial NED
                    type string;
                    // NCS drop tailf:callpoint
                    // NCS drop tailf:validate
                    mandatory true;
                  }
                  leaf protocol {
                    tailf:info
                      "The CLI protocol";
                    type enumeration {
                      enum "telnet";
                      enum "ssh";
                    }
                    default "ssh";
                  }
                }
              }
              case snmp {
                container snmp {
                  leaf version {
                    type snmp-version;
                    mandatory true;
                    tailf:info
                      "SNMP version to use";
                  }
                  leaf context-name {
                    when "../version = 'v3'" {
                      tailf:xpath-root 3;
                    }
                    type string;
                    default "";
                    description
                      "The SNMP context name to use when communicating
                       with the device.  If an SNMP engine supports multiple
                       contexts, each context must be handled as a separate
                       managed-device in NCS.";
                    reference "RFC 3411: Architecture for SNMP Management Frameworks";
                    tailf:info
                      "SNMP context to use";
                  }
                  leaf ned-id {
                    tailf:info
                      "The NED Identity";
                    // NCS patched to string, due to LSA partial NED
                    type string;
                    mandatory true;
                  }
                  leaf snmp-authgroup {
                    type leafref {
                      path "/ncs-internal:devices/ncs-internal:device/ncs-internal:config/devices/authgroups/snmp-group/name" {
                        tailf:xpath-root 3;
                      }
                    }
                    mandatory true;
                    tailf:info
                      "Name of an SNMP authgroup";
                  }
                  leaf retries {
                    type uint8;
                    default "3";
                    description
                      "Specifies the number of retries to be used when sending
                       a request.";
                    tailf:info
                      "Number of times a request is resent";
                  }
                  leaf timeout {
                    type uint32 {
                      range "0..4294967";
                    }
                    units "seconds";
                    default "1";
                    description
                      "Specifies the timeout in seconds between retries.";
                    tailf:info
                      "Wait time in seconds between retries";
                  }
                  leaf-list mib-group {
                    tailf:info
                      "A list of MIB groups implemented by the device";
                    type leafref {
                      path "/ncs-internal:devices/ncs-internal:device/ncs-internal:config/devices/mib-group/name" {
                        tailf:xpath-root 3;
                      }
                    }
                    description
                      "A list of MIB groups implemented by the device.

                       In SNMP, there is no generic, automatic way to
                       figure out which MIBs an agent implements.  Thus,
                       this list can be used to inform NCS which MIBs the
                       device implements.

                       If this list is empty, NCS assumes that the device
                       implements all MIBs known to NCS.

                       The MIBs NCS thinks the device implements are
                       listed in /devices/module.  These
                       modules are used by NCS to control what data can
                       be configured under /devices/device/config,
                       and what data is shown in
                       /devices/device/live-status.";
                  }
                }
              }
            }
            must 'netconf or generic or cli or snmp' {
              tailf:xpath-root 3;
              error-message "must configure one of: snmp, cli, generic, netconf";
              tailf:dependency "ncs:netconf";
              tailf:dependency "ncs:generic";
              tailf:dependency "ncs:cli";
              tailf:dependency "ncs:snmp";
            }
          }
          // NCS drop config false container state
          // NCS drop config false list capability
        }
        container state {
          tailf:info
            "Show states for the device";
          uses oper-state;
          // NCS drop config false leaf 'transaction-mode'
          // NCS drop config false leaf 'last-transaction-id'
          // NCS drop config false container 'last-modules-state'
          leaf admin-state {
            must "(. = 'call-home' and ../../local-user and ../../device-type/netconf) or (. != 'call-home')" {
              tailf:xpath-root 3;
              error-message "when admin-state indicates call-home the device-type must indicate netconf and the local-user must be set.";
              tailf:dependency "../../local-user";
              tailf:dependency "../../device-type/netconf";
            }
            tailf:info
              "Controls configuration and southbound communication";
            type admin-state;
            default "southbound-locked";
          }
          leaf admin-state-description {
            type string;
            description
              "Reason for the admin state.";
          }
        }
        container source {
          tailf:info
            "How the device was added to NCS";
          leaf added-by-user {
            type string;
          }
          leaf context {
            type string;
          }
          leaf when {
            type yang:date-and-time;
          }
          leaf from-ip {
            type inet:ip-address;
          }
          leaf source {
            type string;
            reference "TMF518 NRB Network Resource Basics";
          }
        }
        uses capability-module-grouping {
          // NCS drop config false refine capability
          // NCS drop config false refine module
          augment "capability" {
            tailf:action remove {
              tailf:actionpoint ncsproxy {
                tailf:internal;
              }
              description
                "This action removes a capability from the list of capabilities.
                 If leaf module is set then corresponding module is attempted to
                 be removed from the list of modules for this device. This action
                 is only intended to be used for pre-provisioning: it is not
                 possible to override capabilities and modules provided by the
                 NED implementation using this action.";
              // NCS drop tailf:actionpoint
            }
          }
        }
        tailf:action find-capabilities {
          tailf:actionpoint ncsproxy {
            tailf:internal;
          }
          description
            "This action overwrites existing list of capabilities.

             This action is only intended to be used for
             pre-provisioning: it is not possible to override
             capabilities and modules provided by the NED implementation
             using this action.

             This action populates the list of capabilities based on the
             configured ned-id for the device, if possible.  NCS will
             look up the package corresponding to the ned-id and add all
             the modules from these packages to the list of device
             capabilities and list of modules.  It is the responsibility
             of the caller to verify that the automatically populated
             list of capabilities matches actual device capabilities.
             The list of capabilities can then be fine-tuned using
             add-capability and capability/remove actions.

             Currently this approach works only for CLI and generic
             devices.";
          // NCS drop tailf:actionpoint
          output {
            leaf result {
              description
                "The result indicates whether any new capabilities have
                 been found and saved for this device.";
              type boolean;
            }
          }
        }
        tailf:action add-capability {
          tailf:actionpoint ncsproxy {
            tailf:internal;
          }
          description
            "This action adds a capability to the list of capabilities.

             This action is only intended to be used for
             pre-provisioning.  It is not possible to override
             capabilities and modules provided by the NED implementation
             using this action.

             If a uri is specified, then it is parsed as a YANG
             capability string, and module, revision, feature and
             deviation parameters are derived from the string.

             If a module is specified, then the namespace is looked up
             in the list of loaded namespaces and a capability string is
             constructed automatically.  If a module is specified and
             the attempt to look it up failed, then the action does
             nothing.

             If a module is specified or can be derived from the
             capability string, then the module is also added/replaced
             in the list of modules.";
          // NCS drop tailf:actionpoint
          input {
            choice capability-input {
              mandatory true;
              case capability-uri {
                leaf uri {
                  type string;
                }
              }
              case capability-parameters {
                leaf ned-id {
                  // NCS drop tailf-common:non-strict-leafref statement
                  // NCS patched to string, due to LSA partial NED
                  type string;
                }
                leaf module {
                  // NCS drop tailf-common:non-strict-leafref statement
                  type string;
                  mandatory true;
                }
                leaf revision {
                  // NCS drop tailf-common:non-strict-leafref statement
                  type string;
                }
                leaf-list feature {
                  type string;
                }
                leaf-list deviation {
                  type string;
                }
              }
            }
          }
        }
        // NCS drop config false container platform
        uses apply-template-grouping;
        tailf:action instantiate-from-other-device {
          tailf:actionpoint ncsproxy {
            tailf:internal;
          }
          description
            "Instantiate the configuration for the device as a copy of the
             configuration of some other already working device.";
          tailf:info
            "Instantiate the config for the device from existing device";
          tailf:cli-configure-mode;
          // NCS drop tailf:actionpoint
          input {
            leaf device-name {
              type leafref {
                path "/ncs-internal:devices/ncs-internal:device/ncs-internal:config/devices/device/name" {
                  tailf:xpath-root 3;
                }
              }
            }
          }
        }
        tailf:action compare-config {
          tailf:actionpoint ncsproxy {
            tailf:internal;
          }
          description
            "Retrieve the config from the device and compare
             to the NCS locally stored copy.

             If the wait-for-lock parameter is not given, the wait-for-lock
             device setting is going to be used.";
          tailf:info
            "Compare the actual device config with the NCS copy";
          // NCS drop tailf:actionpoint
          input {
            leaf outformat {
              type outformat2;
            }
            uses wait-for-lock;
          }
          output {
            choice compare-result {
              leaf diff {
                type string;
              }
              leaf info {
                type string;
                description
                  "If present, contains additional information about the result.";
              }
            }
          }
        }
        tailf:action sync-from {
          tailf:actionpoint ncsproxy {
            tailf:internal;
          }
          description
            "Synchronize the NCS copy of the device configuration by
             reading the actual device configuration. The change will be
             immediately committed to NCS.

             If the wait-for-lock parameter is not given, the wait-for-lock
             device setting is going to be used.";
          tailf:info
            "Synchronize the config by pulling from the device";
          // NCS drop tailf:actionpoint
          input {
            container dry-run {
              presence "";
              leaf outformat {
                type outformat2;
                description
                  "Report what would be done towards CDB, without
                   actually doing anything.";
              }
            }
            leaf verbose {
              type empty;
              description
                "Use this to show additional parse information if supported
                 by the NED.";
            }
            uses wait-for-lock;
          }
          output {
            uses sync-result;
          }
        }
        tailf:action sync-to {
          tailf:actionpoint ncsproxy {
            tailf:internal;
          }
          description
            "Synchronize the device configuration by pushing NCS copy
             to the device.

             NCS pushes a minimal diff to the device. The
             diff is calculated by reading the configuration from the
             device and comparing with the configuration in NCS.

             For a NETCONF device, NCS can optionally replace the
             configuration on the device by sending its own
             configuration without calculating the diff.  Note that NCS
             will send an <edit-config> with the 'replace' option in
             this case.  This means that configuration subtrees that NCS
             does not know about are not replaced.

             If the dry-run option is used, the action simply
             reports (in different formats) what it would do.

             If the wait-for-lock parameter is not given, the wait-for-lock
             device setting is going to be used.";
          tailf:info
            "Synchronize the config by pushing to the device";
          // NCS drop tailf:actionpoint
          input {
            leaf mode {
              status deprecated;
              tailf:info
                "DEPRECATED - use sync-to default behaviour instead";
              type enumeration {
                enum "replace";
              }
              description
                "For a NETCONF device, replace the device configurations
                 with the NCS configurations, instead of sending the diff.

                 Cannot be used with a non-NETCONF device.

                 This leaf is deprecated. Use sync-to default behaviour
                 instead.";
            }
            container dry-run {
              presence "";
              leaf outformat {
                type outformat3;
                description
                  "Report what would be done towards the device, without
                   actually doing anything.";
              }
            }
            uses wait-for-lock;
          }
          output {
            uses sync-to-result;
          }
        }
        tailf:action check-sync {
          tailf:actionpoint ncsproxy {
            tailf:internal;
          }
          description
            "Check if the NCS copy of the device configuration is in sync
             with the actual device configuration, using device-specific
             mechanisms. This operation is usually cheap as it only
             compares a signature of the configuration from the
             device rather than comparing the entire configuration.

             Depending on the device the signature is implemented as a
             transaction-id, timestamp, hash-sum or not at all.
             The capability must be supported by the corresponding
             NED. The output might say unsupported, and then the only way
             to perform this would be to do a full 'compare-config' command.

             As some NEDs implements the signature as an hash-sum
             of the entire configuration, this operation might for
             some devices be just as expensive as performing a full
             compare-config command.

             If the wait-for-lock parameter is not given, the wait-for-lock
             device setting is going to be used.";
          tailf:info
            "Check if the NCS config is in sync with the device";
          // NCS drop tailf:actionpoint
          input {
            uses wait-for-lock;
          }
          output {
            uses check-sync-result;
          }
        }
        tailf:action check-yang-modules {
          tailf:actionpoint ncsproxy {
            tailf:internal;
          }
          description
            "Check if the device YANG modules loaded by NCS
             have revisions that are compatible with the ones reported
             by the device.";
          tailf:info
            "Check if NCS and the device have compatible YANG modules";
          // NCS drop tailf:actionpoint
          input {
            leaf verbose {
              type empty;
              description
                "Use this to show additional compatibility info.";
            }
          }
          output {
            uses check-yang-modules-result;
          }
        }
        tailf:action connect {
          tailf:actionpoint ncsproxy {
            tailf:internal;
          }
          description
            "Set up a session to the unlocked device.";
          tailf:info
            "Connect to the device";
          // NCS drop tailf:actionpoint
          input {
            leaf override-southbound-locked {
              type empty;
              description
                "When a device is southbound locked, all southbound
                 communication is turned off. This flag overrides the
                 southbound lock for connection attempts. Thus, this
                 is a way to update the capabilities including revision
                 information for a managed device although the device
                 is southbound locked.";
            }
          }
          output {
            uses connect-result;
          }
        }
        uses disconnect-grouping-specific;
        tailf:action ping {
          tailf:actionpoint ncsproxy {
            tailf:internal;
          }
          description
            "ICMP ping the device.";
          tailf:info
            "ICMP ping the device";
          // NCS drop tailf:actionpoint
          output {
            leaf result {
              type string;
            }
          }
        }
        tailf:action delete-config {
          tailf:actionpoint ncsproxy {
            tailf:internal;
          }
          description
            "Delete the device configuration in NCS without executing
             the corresponding delete on the managed device.";
          tailf:info
            "Delete the config in NCS without deleting it on the device";
          // NCS drop tailf:actionpoint
          input {
            leaf ned-id {
              tailf:info
                "The NED Identity for which configuration will be
                 deleted";
              // NCS patched to string, due to LSA partial NED
              type string;
            }
          }
        }
        tailf:action scp-to {
          tailf:actionpoint ncsproxy {
            tailf:internal;
          }
          description
            "Secure copy file to the device.";
          tailf:info
            "Secure copy file to the device";
          // NCS drop tailf:actionpoint
          input {
            leaf local-file {
              tailf:info
                "Name of the file in the local filesystem.";
              type string;
              mandatory true;
            }
            leaf remote-file {
              tailf:info
                "Name of the file on the device.";
              type string;
              default ".";
            }
            leaf port {
              tailf:info
                "Port to connect to on the device";
              type inet:port-number;
              description
                "Specifies the port to connect to on the device.
                 If this leaf is not configured, NCS will use the port for the
                 management interface of the device.";
            }
            leaf preserve {
              type empty;
              description
                "Preserves modification times, access times, and modes
                 from the original file. This is not always supported by the
                 device.";
            }
          }
          output;
        }
        tailf:action scp-from {
          tailf:actionpoint ncsproxy {
            tailf:internal;
          }
          description
            "Secure copy file from the device.";
          tailf:info
            "Secure copy file to the device";
          // NCS drop tailf:actionpoint
          input {
            leaf local-file {
              tailf:info
                "Name of the file in the local filesystem.";
              type string;
              default ".";
            }
            leaf remote-file {
              tailf:info
                "Name of the file on the device.";
              type string;
              mandatory true;
            }
            leaf port {
              tailf:info
                "Port to connect to on the device";
              type inet:port-number;
              description
                "Specifies the port to connect to on the device.
                 If this leaf is not configured, NCS will use the port for the
                 management interface of the device.";
            }
            leaf preserve {
              type empty;
              description
                "Preserves modification times, access times, and modes
                 from the original file. This is not always supported by the
                 device.";
            }
          }
          output;
        }
        tailf:action load-native-config {
          tailf:actionpoint ncsproxy {
            tailf:internal;
          }
          tailf:display-when "../device-type/cli or ../device-type/generic or ../device-type/netconf" {
            tailf:xpath-root 3;
          }
          description
            "Load configuration data in native format into the transaction.
             This action is only applicable for devices with
             NETCONF, CLI and generic NEDs.

             By default the behaviour is to merge the configuration
             that is applied. This can be changed by setting the mode option
             to replace. This will replace the entire device configuration.

             This action will behave differently depending on if it is
             invoked with a transaction or not. When invoked with a
             transaction (such as via the CLI) it will load the
             configuration into it and leave it to the user to commit
             or revert the resulting changes. If invoked without a
             transaction (for example when invoked via RESTCONF),
             the action will automatically create one and commit
             the resulting changes.";
          tailf:info
            "Load configuration data in native format";
          tailf:cli-configure-mode;
          // NCS drop tailf:actionpoint
          input {
            choice source {
              leaf file {
                type string;
                description
                  "Name of file with configuration data in native format
                   in the local filesystem. If the device is remote
                   the file must exists in the local filesystem of the
                   remote node.";
              }
              leaf data {
                type string;
                tailf:cli-multi-line-prompt;
                description
                  "Configuration data in native format. If loading
                   XML the data must be a valid XML document,
                   either with a single namespace or wrapped in a
                   config node with the http://tail-f.com/ns/config/1.0
                   namespace.";
              }
              mandatory true;
            }
            leaf mode {
              type enumeration {
                enum "merge" {
                  tailf:code-name "load_native_merge";
                  description
                    "Merge with the existing device configuration.";
                }
                enum "replace" {
                  tailf:code-name "load_native_replace";
                  description
                    "Replace the entire device configuration.";
                }
              }
              default "merge";
              description
                "Merge or replace the configuration. The default behaviour
                 is to merge.";
            }
            container dry-run {
              tailf:hidden "programmatic-interface";
              presence "";
              leaf outformat {
                type outformat3;
              }
            }
            uses ncs-hidden-commit-params;
            leaf verbose {
              type empty;
              description
                "Use this to show additional parse information if supported
                 by the NED.";
            }
          }
          output {
            choice outformat {
              case case-xml {
                uses dry-run-xml;
              }
              case case-cli {
                uses dry-run-cli;
              }
              case case-native {
                uses dry-run-native;
              }
            }
            uses ncs-commit-result;
            leaf info {
              type string;
              description
                "If present, contains additional information about the result.";
            }
          }
        }
        container config {
          tailf:cli-add-mode;
          tailf:cli-expose-ns-prefix;
          tailf:info
            "NCS copy of the device configuration";
          description
            "This container is used to mount configuration data nodes
             from the device's data models.

             This is where NCS's copy of the device configuration is stored.

             This container defines a mount point as defined in 'YANG
             Schema Mount' (draft-ietf-netmod-schema-mount-10).  This
             means that NCS maintains a config false instantiation of
             the YANG library under this container, which can be read by a
             client to learn the data model (schema) for the device.";
        }
        // NCS drop config false container 'live-status'
        container rpc {
          // NCS drop tailf:mount-point
          tailf:info
            "RPCs from the device";
          description
            "This container is augmented with top-level rpcs
             from the device's data models.

             The rpcs are augments as tailf:actions.  This makes it possible
             to invoke rpcs on the devices through the NCS data model.";
        }
        container notifications {
          when '../device-type/netconf or ../device-type/generic or ../device-type/cli' {
            tailf:xpath-root 3;
          }
          tailf:info
            "Notifications from the device";
          description
            "Event notification support using NETCONF or
             protocols implemented by the NED.";
          reference "RFC 5277 - NETCONF Event Notifications";
          // NCS expand uses statement
          list subscription {
            tailf:info
              "List of subscriptions";
            key "name";
            description
              "A list of our notification subscriptions for this managed device.";
            leaf name {
              type string;
              description
                "Each subscription must have a unique name.";
            }
            leaf stream {
              tailf:info
                "The notification stream name";
              type string;
              mandatory true;
              description
                "The name of the notification stream this subscription
                 refers to.";
            }
            choice filter {
              description
                "Optional element, if not set, no filters are applied.";
              case xpath {
                leaf xpath {
                  tailf:info
                    "XPath filter for the notifications";
                  type yang:xpath1.0;
                }
              }
              case subtree {
                leaf subtree {
                  tailf:info
                    "Subtree filter for the notifications";
                  type string;
                }
              }
            }
            leaf local-user {
              type string;
              mandatory true;
              description
                "The local user is used when setting up a device
                 connection.";
            }
            leaf store-in-cdb {
              tailf:info
                "Store notifications in CDB";
              type boolean;
              default "true";
              description
                "Indicate whether notifications should be stored as
                 operational data in CDB.

                 When notifications are generated at a high rate,
                 storage consumes lots of resources. In cases like that,
                 consider using the device-notification event stream
                 instead.";
            }
            leaf utilize-replay {
              tailf:info
                "Use replay when connecting to the device";
              type boolean;
              default "true";
              description
                "If the device supports replay, should NCS attempt to use that
                 when connecting to the device.";
            }
            leaf reconnect-interval {
              tailf:info
                "Interval for re-establishing the subscription";
              type uint32 {
                range "0..4294967";
              }
              units "seconds";
              default "60";
              description
                "If the device is non operational, with which
                 interval (in seconds) shall NCS attempt to re-establish
                 the subscription.";
            }
            // NCS drop config false leaf status
            // NCS drop config false leaf 'failure-reason'
            // NCS drop config false leaf 'error-info'
            tailf:action reconnect {
              tailf:actionpoint ncsproxy {
                tailf:internal;
              }
              tailf:info
                "Attempt to reconnect this subscription";
              description
                "Attempt to reconnect this subscription.";
              // NCS drop tailf:actionpoint
            }
            tailf:action disconnect {
              tailf:actionpoint ncsproxy {
                tailf:internal;
              }
              tailf:info
                "Disconnect this subscription if connected";
              description
                "Disconnect this subscription if connected.";
              // NCS drop tailf:actionpoint
            }
            tailf:action replay {
              tailf:actionpoint ncsproxy {
                tailf:internal;
              }
              tailf:info
                "Replay (missed) notifications from the device";
              description
                "Ask the device to replay all notifications for this
                 subscription.  Optionally if a timestamp is given, all
                 notifications newer than the provided timestamp are
                 requested.";
              // NCS drop tailf:actionpoint
              input {
                leaf from-date-time {
                  type yang:date-and-time;
                }
              }
            }
            must 'not(../../netconf-notifications/subscription[name=current()/name])' {
              tailf:xpath-root 3;
              error-message "already configured";
              tailf:dependency "./name";
              tailf:dependency "../../netconf-notifications/subscription";
              tailf:dependency "../../netconf-notifications/subscription/name";
            }
          }
          // NCS drop config false list stream
          // NCS drop config false list 'notification-name'
          container received-notifications {
            leaf max-size {
              type int32;
              default "200";
              description
                "Max size of the list of received notifications.
                 When the maximum size is reached, the oldest
                 received notification is purged.";
            }
            // NCS drop config false leaf 'clear-time'
            tailf:action clear {
              tailf:actionpoint ncsproxy {
                tailf:internal;
              }
              description
                "Delete all received notifications from the
                 'notification' list.";
              // NCS drop tailf:actionpoint
            }
            // NCS drop config false list notification
          }
        }
        container netconf-notifications {
          when '../device-type/netconf' {
            tailf:xpath-root 3;
          }
          tailf:info
            "NETCONF notifications from the device";
          description
            "NETCONF notification support. This container is
             deprecated and will be removed in a future release.
             Use /devices/device/notifications instead.";
          reference "RFC 5277 - NETCONF Event Notifications";
          status deprecated;
          // NCS expand uses statement
          list subscription {
            tailf:info
              "List of subscriptions";
            key "name";
            description
              "A list of our notification subscriptions for this managed device.";
            leaf name {
              type string;
              description
                "Each subscription must have a unique name.";
            }
            leaf stream {
              tailf:info
                "The notification stream name";
              type string;
              mandatory true;
              description
                "The name of the notification stream this subscription
                 refers to.";
            }
            choice filter {
              description
                "Optional element, if not set, no filters are applied.";
              case xpath {
                leaf xpath {
                  tailf:info
                    "XPath filter for the notifications";
                  type yang:xpath1.0;
                }
              }
              case subtree {
                leaf subtree {
                  tailf:info
                    "Subtree filter for the notifications";
                  type string;
                }
              }
            }
            leaf local-user {
              type string;
              mandatory true;
              description
                "The local user is used when setting up a device
                 connection.";
            }
            leaf store-in-cdb {
              tailf:info
                "Store notifications in CDB";
              type boolean;
              default "true";
              description
                "Indicate whether notifications should be stored as
                 operational data in CDB.

                 When notifications are generated at a high rate,
                 storage consumes lots of resources. In cases like that,
                 consider using the device-notification event stream
                 instead.";
            }
            leaf utilize-replay {
              tailf:info
                "Use replay when connecting to the device";
              type boolean;
              default "true";
              description
                "If the device supports replay, should NCS attempt to use that
                 when connecting to the device.";
            }
            leaf reconnect-interval {
              tailf:info
                "Interval for re-establishing the subscription";
              type uint32 {
                range "0..4294967";
              }
              units "seconds";
              default "60";
              description
                "If the device is non operational, with which
                 interval (in seconds) shall NCS attempt to re-establish
                 the subscription.";
            }
            // NCS drop config false leaf status
            // NCS drop config false leaf 'failure-reason'
            // NCS drop config false leaf 'error-info'
            tailf:action reconnect {
              tailf:actionpoint ncsproxy {
                tailf:internal;
              }
              tailf:info
                "Attempt to reconnect this subscription";
              description
                "Attempt to reconnect this subscription.";
              // NCS drop tailf:actionpoint
            }
            tailf:action disconnect {
              tailf:actionpoint ncsproxy {
                tailf:internal;
              }
              tailf:info
                "Disconnect this subscription if connected";
              description
                "Disconnect this subscription if connected.";
              // NCS drop tailf:actionpoint
            }
            tailf:action replay {
              tailf:actionpoint ncsproxy {
                tailf:internal;
              }
              tailf:info
                "Replay (missed) notifications from the device";
              description
                "Ask the device to replay all notifications for this
                 subscription.  Optionally if a timestamp is given, all
                 notifications newer than the provided timestamp are
                 requested.";
              // NCS drop tailf:actionpoint
              input {
                leaf from-date-time {
                  type yang:date-and-time;
                }
              }
            }
            must 'not(../../notifications/subscription[name=current()/name])' {
              tailf:xpath-root 3;
              error-message "already configured";
              tailf:dependency "./name";
              tailf:dependency "../../notifications/subscription";
              tailf:dependency "../../notifications/subscription/name";
            }
          }
          // NCS drop config false list stream
          // NCS drop config false list 'notification-name'
          container received-notifications {
            leaf max-size {
              type int32;
              default "200";
              description
                "Max size of the list of received notifications.
                 When the maximum size is reached, the oldest
                 received notification is purged.";
            }
            // NCS drop config false leaf 'clear-time'
            tailf:action clear {
              tailf:actionpoint ncsproxy {
                tailf:internal;
              }
              description
                "Delete all received notifications from the
                 'notification' list.";
              // NCS drop tailf:actionpoint
            }
            // NCS drop config false list notification
          }
        }
        // NCS drop config false leaf-list 'service-list'
      }
      // NCS drop config false container 'ned-ids'
      // NCS drop config false container 'commit-queue'
      // NCS drop config false container 'session-pool'
    }
  }
  augment "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status" {
    container devices {
      tailf:ncs-device-type "netconf";
      tailf:display-when "not(../../ncs-internal:module) or ../../ncs-internal:module[ncs-internal:name='tailf-ncs'] or (../../ncs-internal:live-status-protocol[not(ncs-internal:capability)]) or (../../ncs-internal:live-status-protocol/ncs-internal:capability/ncs-internal:module[.='tailf-ncs'])";
      tailf:info
        "The managed devices and device communication settings";
      uses live_ncs_connect-grouping-extended;
      uses live_ncs_sync-to-grouping-extended;
      uses live_ncs_sync-from-grouping-extended;
      uses live_ncs_disconnect-grouping-extended;
      uses live_ncs_check-sync-grouping-extended;
      uses live_ncs_check-yang-modules-grouping-extended;
      uses live_ncs_fetch-ssh-host-keys-grouping-extended;
      uses live_ncs_migrate-grouping-extended;
      uses live_ncs_apply-template-grouping-extended;
      tailf:action clear-trace {
        tailf:actionpoint ncsproxy {
          tailf:internal;
        }
        description
          "Clear all trace files for all active traces for all managed
           devices.";
        tailf:info
          "Clear all trace files";
        // NCS drop tailf:actionpoint
      }
      tailf:action partial-sync-from {
        tailf:actionpoint ncsproxy {
          tailf:internal;
        }
        description
          "Synchronize parts of the devices' configuration by pulling from
           the network.

           If the wait-for-lock parameter is not given, the wait-for-lock
           device setting is going to be used.";
        // NCS drop tailf:actionpoint
        input {
          leaf-list path {
            type live_ncs_partial-sync-from-path;
            description
              "A list of paths to fetch. Any path pointing to a subtree outside
               /devices/device/config will be ignored.";
          }
          leaf suppress-positive-result {
            type empty;
            description
              "Use this additional parameter to only return
               devices that failed to sync.";
          }
          uses live_ncs_wait-for-lock;
        }
        output {
          uses live_ncs_sync-from-output;
        }
      }

      grouping timeouts {
        description
          "Timeouts used when communicating with a managed device.";
        leaf connect-timeout {
          tailf:info
            "Timeout in seconds for new connections";
          type uint32 {
            range "1..4294967";
          }
          units "seconds";
          description
            "The timeout in seconds for new connections to managed
             devices.";
        }
        leaf read-timeout {
          tailf:info
            "Timeout in seconds used when reading data";
          type uint32 {
            range "1..4294967";
          }
          units "seconds";
          description
            "The timeout in seconds used when reading data from a
             managed device.";
        }
        leaf write-timeout {
          tailf:info
            "Timeout in seconds used when writing data";
          type uint32 {
            range "1..4294967";
          }
          units "seconds";
          description
            "The timeout in seconds used when writing data to a
             managed device.";
        }
      }

      grouping device-profile-parameters {
        description
          "A set of parameters to use when communicating with a device.

           These parameters can be set on:

             o  global-settings
             o  device-profile
             o  device

           If a parameter is set on the device, its value is used.
           Otherwise, if the paramater is set in the device's
           device-profile, its value is used.  Otherwise, the global
           setting is used, if set.  Otherwise, the value used depends on
           the NED type.";
        uses timeouts;
        // NCS expand uses statement
        choice wait-for-lock-choice {
          leaf no-wait-for-lock {
            type empty;
            description
              "The action can't be performed while the device is being
               committed to (or waiting in the commit queue). This is to avoid
               getting inconsistent data when reading the configuration.
               This specifies that the action should not wait for device lock,
               instead, it should immediately fail if the device is being locked.";
          }
          container wait-for-lock {
            presence "Wait for device lock.";
            description
              "The action can't be performed while the device is being
               committed to (or waiting in the commit queue). This is to avoid
               getting inconsistent data when reading the configuration.
               This specifies a timeout to wait for a device lock to be placed
               in the commit queue. The lock will be automatically released once
               the action has been executed.";
            choice timeout-choice {
              // NCS drop default statement
              leaf timeout {
                type uint32 {
                  range "0..4294967";
                }
                units "seconds";
                description
                  "Specifies a maximum number of seconds to wait for the
                   device to be locked.";
              }
              leaf infinity {
                description
                  "Wait infinitely for the lock, this is the default.";
                type empty;
              }
            }
          }
          description
            "When an action accepting the wait-for-lock parameter is
             called without providing the wait-for-lock parameter, the
             wait-for-lock-choice device setting is going to be used.";
        }
        container ssh-keep-alive {
          description
            "Controls SSH keep alive settings when communicating from this
             node to devices.";
          tailf:info
            "Controls SSH keep alive settings";
          leaf interval {
            type uint32 {
              range "0..4294967";
            }
            units "seconds";
            description
              "Seconds between SSH keep alive activity.";
          }
          leaf count {
            type uint8;
            description
              "Number of intervals to fail before failing the connection.";
          }
        }
        container ssh-algorithms {
          description
            "Supported (allowed) algorithms that should be used during
             SSH algorithm negotiations.";
          uses live_ncs_ssh-algorithms;
        }
        container ned-keep-alive {
          description
            "Controls NED keep alive settings when communicating from this
             node to devices. The keep alive settings can be configured for
             NSO to periodically perform activity to keep the session open.
             This is useful when for example CLI sessions have low idle timeouts.
             These settings only take effect if the NED actually implements
             this callback.";
          tailf:info
            "Controls NED keep alive settings";
          leaf interval {
            type uint32 {
              range "0..4294967";
            }
            units "seconds";
            description
              "Seconds between NED keep alive activity.";
          }
          leaf count {
            type uint8;
            description
              "Number of intervals to fail before failing the connection.";
          }
        }
        container connect-retries {
          tailf:info
            "Retry connect on transient errors";
          description
            "Settings for how to retry connecting if the device returns
             a transient failure.";
          leaf attempts {
            type uint8;
            tailf:info
              "Number of retries before giving up";
            description
              "Number of attempts to retry the connect before giving up.

               Setting this to 0 means that the connect fails
               immediately if the device returns a failure.";
          }
          leaf timeout {
            type uint32 {
              range "0..4294967";
            }
            units "seconds";
            tailf:info
              "Wait time in seconds between retries";
            description
              "Specifies the timeout in seconds between retries.";
          }
        }
        leaf trace {
          tailf:info
            "Trace the southbound communication to devices";
          type live_ncs_trace-flag;
          description
            "Controls southbound traffic trace to managed devices.";
        }
        leaf trace-output {
          tailf:info
            "Trace data output mode.";
          type live_ncs_trace-output;
          description
            "Controls how trace data is stored.";
        }
        container ned-settings {
          tailf:info
            "Control which device capabilities NCS uses";
          description
            "When communicating with a device, NCS adapts its behavior
             to the capabilities of the device.  When writing to the device,
             NCS uses the capabilities that give most control, and minimal
             risk of network inconsistencies.  The parameters in this
             container can be used to tweak NCS's behavior.  These parameters
             must be used with care.";
          leaf use-confirmed-commit {
            tailf:info
              "Control usage of confirmed commit";
            type boolean;
            description
              "Controls if NCS should use confirmed commit towards the
               device.  This setting has no effect if the device does
               not advertise support for confirmed-commit.

               If no value is configured, the default depends on the NED
               type.  The NETCONF NED by default uses confirmed commit if
               it is advertised.";
          }
          leaf use-validate {
            tailf:info
              "Control usage of validate";
            type boolean;
            description
              "Controls if NCS should use explicit validation towards the
               device.  This setting has no effect if the device does
               not advertise support for validate.

               It can be useful to disable validate in order to increase
               performance, since when validate is used, the device must
               validate the changes twice; at validate, and at commit.

               The advantage of using validate is that if the changes are
               sent to N devices, and validated on all of them, if one
               device fails the validation step, nothing has been committed
               to any device, and the transaction can easily be aborted.

               Without validate, NCS will commit on all N devices, and if
               one fails the commit due to a validation error, NCS has
               to undo the changes on the other devices.

               If no value is configured, the default depends on the NED
               type.  The NETCONF NED by default uses validate if
               it is advertised.";
          }
          leaf use-startup {
            tailf:info
              "Control usage of the startup datastore";
            type boolean;
            description
              "Controls if NCS should invoke the copy-running-to-startup
               operation towards the device.  This setting has no effect
               if the device does not advertise support for startup.

               It can be useful to disable this operation in order to
               increase performance, in the case that this is an
               expensive operation on the device.  It should be noted
               that in this case, the device will not have all changes
               persistently stored.  This can be combined with a job
               that performs this operation periodically, e.g., once an
               hour.

               If no value is configured, the default depends on the NED
               type.  The NETCONF NED by default uses startup if
               it is advertised.";
          }
          leaf use-transaction-id {
            tailf:info
              "Control usage of fetching the transaction id";
            type boolean;
            description
              "For some devices, getting the transaction id can be a costly
               operation.  If it is disabled, NCS will not be able to
               detect situations where NCS and the device are out of
               sync.

               If no value is configured, the default depends on the NED
               type.  The NETCONF NED by default reads the transaction id,
               if it knows how to get it from the device.";
          }
          leaf use-private-candidate {
            tailf:info
              "Control usage of the private candidate";
            type boolean;
            description
              "If the device supports the concept of a private
               candidate, NCS can use it instead of the normal, shared
               candidate.

               This option can be useful if there are other management
               applications other than NCS configuring the devices, and
               these other applications also use private candidates.

               If no value is configured, the default depends on the NED
               type.  The NETCONF NED by default does not use a private
               candidate.  For NETCONF, this option currently has effect
               only for Juniper devices running Junos.";
          }
          leaf use-junos-rollback {
            tailf:info
              "If set to true use device rollback as a revert strategy.";
            type boolean;
            description
              "Use the latest rollback instead of computing and sending a reverse
               diff when other device in the transaction has failed in commit and
               the configuration on successful devices needs to be reverted.

               Using rollback involves less communication overhead with the
               device but the rollback functionality might not be supported by
               all device software versions.

               This option has effect only for Juniper devices running Junos.";
          }
        }
        container commit-queue {
          tailf:info
            "Control settings for the commit queue";
          leaf enabled-by-default {
            type boolean;
            description
              "If this leaf is set, all commits for this device will by
               default go through the commit queue.";
          }
        }
        container session-limits {
          tailf:info
            "Parameters for limiting concurrent access to the device.";
          leaf max-sessions {
            type union {
              type enumeration {
                enum "unlimited";
              }
              type uint32 {
                range "1..max";
              }
            }
            description
              "Puts a limit to the total number of concurrent sessions
               allowed for the device. The label 'unlimited' implies that no
               upper limit exists for this device.";
          }
        }
        container session-pool {
          tailf:info
            "Control how sessions to related devices can be pooled.";
          description
            "NCS uses NED sessions when performing transactions, actions
             etc towards a device. When such a task is completed the NED
             session can either be closed or pooled.

             Pooling a NED session means that the session to the
             device is kept open for a configurable amount of
             time. During this time the session can be re-used for a new
             task. Thus the pooling concept exists to reduce the number
             of new connections needed towards a device that is often
             used.

             By default NCS uses pooling for all device types except
             SNMP. Normally there is no need to change the default
             values.";
          leaf max-sessions {
            type union {
              type enumeration {
                enum "unlimited";
              }
              type uint32;
            }
            description
              "Controls the maximum number of open sessions in the pool for
               a specific device. When this threshold is exceeded the oldest
               session in the pool will be closed.
               A Zero value will imply that pooling is disabled for
               this specific device. The label 'unlimited' implies that no
               upper limit exists for this specific device";
          }
          leaf idle-time {
            tailf:info
              "The maximum time that a session is kept open in the pool";
            type uint32 {
              range "1..4294967";
            }
            units "seconds";
            description
              "The maximum time that a session is kept open in the pool.
               If the session is not requested and used before the
               idle-time has expired, the session is closed.
               If no idle-time is set the default is 30 seconds.";
          }
        }
        container no-overwrite {
          tailf:info
            "Control settings for no-overwrite sync check";
          leaf enabled-by-default {
            type boolean;
            description
              "If this leaf is set, all commits for this device will by
               default make a no-overwrite sync check.";
          }
        }
        container lsa {
          description
            "Control settings that apply to the communication between this node
             and the LSA node the setting applies to. These settings do not
             propagate further in the LSA cluster and are ignored if set on a
             device that is not an LSA node.";
          container no-overwrite {
            description
              "Control settings for no-overwrite sync check between
               nodes in LSA cluster";
            leaf enabled-by-default {
              type boolean;
              description
                "If this leaf is set, all commits for this LSA node will by
                 default make a no-overwrite sync check.";
            }
          }
        }
        leaf out-of-sync-commit-behaviour {
          type enumeration {
            enum "reject";
            enum "accept";
          }
          description
            "Specifies the behaviour of a commit operation involving a
             device that is out of sync with NCS. Value accept assumes that
             the device's sync state is unknown and it is cleared on commit.
             The default behaviour is to reject such commits.";
        }
        choice choice-lsa {
          leaf use-lsa {
            type empty;
            description
              "Handle the LSA nodes as such. This is the default.";
          }
          leaf no-lsa {
            type empty;
            description
              "Do not handle any of the LSA nodes as such. These nodes
               will be handled as any other device. This has the same
               result as adding the commit flag 'no-lsa' to every commit.";
          }
          // NCS drop default statement
        }
      }

      grouping capability-module-grouping {
        list capability {
          key "uri";
          leaf uri {
            // NCS drop tailf:cli-allow-range
            type string;
          }
          leaf revision {
            type string;
          }
          leaf module {
            type string;
          }
          leaf-list feature {
            type string;
          }
          leaf-list deviation {
            type string;
          }
        }
        list module {
          key "name";
          leaf name {
            type string;
          }
          leaf revision {
            type string;
          }
          leaf-list feature {
            type string;
          }
          leaf-list deviation {
            type string;
          }
        }
        tailf:action copy-capabilities {
          tailf:actionpoint ncsproxy {
            tailf:internal;
          }
          description
            "Note: this action overwrites existing list of capabilities.

             This action copies the list of capabilities and the list of modules
             from another device or profile. When used on a device, this action
             is only intended to be used for pre-provisioning: it is not possible
             to override capabilities and modules provided by the
             NED implementation using this action.";
          // NCS drop tailf:actionpoint
          input {
            choice from-where {
              leaf from-device {
                type leafref {
                  path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/device/name" {
                    tailf:xpath-root 3;
                  }
                }
              }
              leaf from-profile {
                type leafref {
                  path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/profiles/capabilities-profile/name" {
                    tailf:xpath-root 3;
                  }
                }
              }
              mandatory true;
            }
          }
        }
      }
      container global-settings {
        tailf:info
          "Global settings for all managed devices.";
        description
          "Global settings for all managed devices. Some of these
           settings can be overridden per managed device.";
        uses device-profile-parameters {
          refine "wait-for-lock-choice" {
            description
              "By default all actions accepting the wait-for-lock parameter will
               not wait for lock if the wait-for-lock parameter was not given.";
            // NCS drop default statement
          }
          refine "connect-timeout" {
            // NCS drop default statement
          }
          refine "read-timeout" {
            // NCS drop default statement
          }
          refine "write-timeout" {
            // NCS drop default statement
          }
          refine "ssh-keep-alive/interval" {
            // NCS drop default statement
          }
          refine "ssh-keep-alive/count" {
            // NCS drop default statement
          }
          refine "ssh-algorithms/public-key" {
            // NCS drop default statement
            // NCS drop default statement
            // NCS drop default statement
            // NCS drop default statement
            // NCS drop default statement
            // NCS drop default statement
          }
          refine "ssh-algorithms/kex" {
            // NCS drop default statement
            // NCS drop default statement
            // NCS drop default statement
            // NCS drop default statement
            // NCS drop default statement
            // NCS drop default statement
            // NCS drop default statement
            // NCS drop default statement
            // NCS drop default statement
            // NCS drop default statement
          }
          refine "ssh-algorithms/mac" {
            // NCS drop default statement
            // NCS drop default statement
            // NCS drop default statement
            // NCS drop default statement
            // NCS drop default statement
            // NCS drop default statement
            // NCS drop default statement
          }
          refine "ssh-algorithms/cipher" {
            // NCS drop default statement
            // NCS drop default statement
            // NCS drop default statement
            // NCS drop default statement
            // NCS drop default statement
            // NCS drop default statement
            // NCS drop default statement
            // NCS drop default statement
          }
          refine "ssh-algorithms/compression" {
            // NCS drop default statement
            // NCS drop default statement
            // NCS drop default statement
          }
          refine "ssh-algorithms/dh-group/min-size" {
            // NCS drop default statement
          }
          refine "ssh-algorithms/dh-group/preferred-size" {
            // NCS drop default statement
          }
          refine "ssh-algorithms/dh-group/max-size" {
            // NCS drop default statement
          }
          refine "ned-keep-alive/count" {
            // NCS drop default statement
          }
          refine "connect-retries/attempts" {
            // NCS drop default statement
          }
          refine "connect-retries/timeout" {
            // NCS drop default statement
          }
          refine "trace" {
            // NCS drop default statement
          }
          refine "trace-output" {
            // NCS drop default statement
          }
          refine "ned-settings/use-junos-rollback" {
            // NCS drop default statement
          }
          refine "no-overwrite/enabled-by-default" {
            // NCS drop default statement
          }
          refine "lsa/no-overwrite/enabled-by-default" {
            // NCS drop default statement
          }
          refine "out-of-sync-commit-behaviour" {
            // NCS drop default statement
          }
          refine "session-limits/max-sessions" {
            // NCS drop default statement
          }
          augment "session-limits" {
            description
              "Parameters for limiting concurrent access to devices.";
            container connect-rate {
              leaf burst {
                type union {
                  type enumeration {
                    enum "unlimited";
                  }
                  type uint32 {
                    range "1..max";
                  }
                }
                // NCS drop default statement
                description
                  "The number of concurrent connect attempts allowed.
                   For example, the devices managed by NSO talk to the same
                   server for authentication which can only handle a limited
                   number of connections at a time. Then we can limit
                   the concurrency of connect attempts with this setting.";
              }
            }
            leaf max-wait-time {
              tailf:info
                "Max time in seconds to wait for device to be available.";
              type union {
                type enumeration {
                  enum "unlimited";
                }
                type uint32 {
                  range "0..max";
                }
              }
              units "seconds";
              // NCS drop default statement
              description
                "Max time in seconds to wait for a device being available
                 to connect. When the maximum time is reached an error
                 is returned. Setting this to 0 means that the error is
                 returned immediately.";
            }
          }
          refine "session-pool/idle-time" {
            // NCS drop default statement
          }
          augment "session-pool" {
            leaf pool-max-sessions {
              type union {
                type enumeration {
                  enum "unlimited";
                }
                type uint32;
              }
              // NCS drop default statement
              description
                "Controls the grand total session count in the pool.
                 Independently on how different devices are pooled the grand
                 total session count can never exceed this value.
                 A zero value will imply that pooling is disabled for all devices.
                 The value 'unlimited' implies that no upper limit exists for
                 the number open sessions in the pool";
            }
          }
          refine "commit-queue/enabled-by-default" {
            // NCS drop default statement
          }
          augment "commit-queue" {
            // NCS expand uses statement
            choice operation-mode {
              leaf async {
                type empty;
                description
                  "Commit the transaction data asynchronously to the commit queue.
                   This flag is useful when some device is non-operational or
                   has data waiting in the commit queue.

                   The operation returns successfully if the transaction data has
                   been successfully placed in the queue. The leaf
                   'commit-queue/id' is set as the queue identifier and the
                   leaf 'commit-queue/status' is set to 'async' in the result.";
              }
              container sync {
                presence "Commit through the commit queue and wait for completion";
                description
                  "Commit the transaction data synchronously to the commit queue.

                   The operation does not return until the transaction data has
                   been sent to all devices, or a timeout occurs. The leaf
                   'commit-queue/id' is set as the queue identifier and the
                   leaf 'commit-queue/status' is set to 'completed', 'failed',
                   'deleted' or 'timeout' dependent of the outcome.

                   If no device is involved in the transaction, the operation
                   returns directly.";
                choice timeout-choice {
                  leaf timeout {
                    type uint32 {
                      range "0..4294967";
                    }
                    units "seconds";
                    description
                      "Specifies a maximum number of seconds to wait for the
                       transaction to be committed. If the timer expires, the
                       transaction is kept in the commit-queue, and the operation
                       returns successfully. The leaf 'commit-queue/status'
                       is set to 'timeout', and the leaf 'commit-queue/id' is
                       set to the queue identifier in the result.";
                  }
                  leaf infinity {
                    description
                      "Wait infinitely for the transaction to be committed.";
                    type empty;
                  }
                  // NCS drop default statement
                }
              }
              // NCS drop default statement
            }
            leaf atomic {
              type boolean;
              // NCS drop default statement
              description
                "This leaf sets the atomic behaviour of all new queue items
                 in the commit queue. If these are set to false, the devices
                 contained in these queue items can start executing if the
                 same devices in other non-atomic queue items ahead of it
                 in the queue are completed. If set to true, the atomic
                 integrity of these queue items are preserved.";
            }
            leaf retry-attempts {
              type union {
                type uint32 {
                  range "0..max";
                }
                type enumeration {
                  enum "unlimited";
                }
              }
              // NCS drop default statement
              tailf:info
                "Number of retries before giving up";
              description
                "Number of attempts to process the device in
                 the queue item if it returns a transient error.
                 For example, if NCS fails to connect to the device
                 or take a lock on it.

                 Setting this to 0 means that the queue item fails
                 immediately even on transient errors.";
            }
            leaf retry-timeout {
              type uint32 {
                range "0..4294967";
              }
              units "seconds";
              // NCS drop default statement
              tailf:info
                "Wait time in seconds between retries";
              description
                "Specifies the timeout in seconds between retries.
                 This is not applicable for devices where
                 /devices/device/state/admin-state = 'call-home'.
                 These devices will wait until a TCP connection
                 is established from the NETCONF server.";
            }
            leaf check-integrity {
              tailf:info
                "Safeguard device and service integrity";
              type boolean;
              // NCS drop default statement
              description
                "To guarantee service integrity NCS checks for
                 overlapping service or device modifications when committing
                 with the commit queue. These checks can be bypassed by
                 setting the leaf to false. This could potentially
                 commit changes that are not deployed to the network if a
                 queue item with overlapping data failed ahead in the
                 queue. The benefit of doing so is increased throughput.";
            }
            leaf error-option {
              type enumeration {
                enum "continue-on-error" {
                  description
                    "The commit queue will continue on errors. No rollback data
                     will be created. This is the preferred choice when
                     re-deploying a service as a re-deploy doesn't have a
                     transaction intent.";
                }
                enum "rollback-on-error" {
                  description
                    "The commit queue items will roll back on errors. The commit
                     queue will place a lock on the failed queue item, thus
                     blocking other queue items with overlapping devices to be
                     executed. The rollback action will then automatically be
                     invoked when the failed queue item has finished its
                     execution. The lock is removed as part of the rollback.";
                }
                enum "stop-on-error" {
                  description
                    "The commit queue will place a lock on the failed queue item,
                     thus blocking other queue items with overlapping devices to
                     be executed. The lock must then either manually be released
                     or the rollback action under
                     /devices/commit-queue/completed be invoked.";
                }
              }
              // NCS drop default statement
              description
                "The error option to use. Depending on the selected error option
                 NCS will store the reverse of the original transaction intent
                 to be able to undo the transaction changes and get back to the
                 previous state. This data is stored in the
                 /devices/device/commit-queue/completed tree from where it can
                 be viewed and invoked with the rollback action. When invoked
                 the data will be removed.";
            }
          }
        }
        container commit-retries {
          tailf:info
            "Retry commits on transient errors";
          description
            "Settings for how to retry commits if some device returns
             a transient error. For example, if NCS fails to take a
             lock on a device, it can retry after a short time.";
          leaf attempts {
            type uint8;
            // NCS drop default statement
            tailf:info
              "Number of retries before giving up";
            description
              "Number of attempts to retry the commit before giving up.

               Setting this to 0 means that the transaction fails
               immediately even on transient errors.";
          }
          leaf timeout {
            type uint32 {
              range "0..4294967";
            }
            units "seconds";
            // NCS drop default statement
            tailf:info
              "Wait time in seconds between retries";
            description
              "Specifies the timeout in seconds between retries.";
          }
        }
        leaf trace-dir {
          tailf:info
            "The directory where trace files are stored";
          type string;
          // NCS drop default statement
          description
            "Specifies the directory where southbound traffic trace log files
             to managed devices are stored.

             The trace files are called <type>-<device-name>.trace
             where <type> is one of 'netconf', 'snmp', or 'ned', depending on
             the type of the managed device.";
        }
        leaf report-multiple-errors {
          type boolean;
          // NCS drop default statement
          description
            "By default, when the NCS device manager commits data
             southbound and when there are errors, we only report
             the first error to the operator, this flag makes NCS
             report all errors reported by managed devices";
        }
      }
      container profiles {
        tailf:info
          "Device profile parameters";
        list profile {
          tailf:info
            "Parameters for a device profile";
          key "name";
          leaf name {
            tailf:info
              "The name of the device profile";
            type string;
          }
          uses device-profile-parameters;
        }
        list capabilities-profile {
          key "name";
          leaf name {
            tailf:info
              "The name of the device profile";
            type string;
          }
          uses capability-module-grouping;
        }
      }
      container authgroups {
        tailf:info
          "Authentication for managed devices";
        description
          "Named authgroups are used to decide how to map a local NCS user to
           remote authentication credentials on a managed device.

           The list 'group' is used for NETCONF and CLI managed devices.

           The list 'snmp-group' is used for SNMP managed devices.";
        list group {
          tailf:info
            "Authentication settings for a group of devices";
          key "name";
          description
            "When NCS connects to a managed device, it locates the
             authgroup configured for that device.  Then NCS looks up
             the local NCS user name in the 'umap' list.  If an entry is
             found, the credentials configured is used when
             authenticating to the managed device.

             If no entry is found in the 'umap' list, the credentials
             configured in 'default-map' are used.

             If no 'default-map' has been configured, and the local NCS
             user name is not found in the 'umap' list, the connection
             to the managed device fails.";

          grouping remote-user-remote-auth {
            description
              "Remote authentication credentials.";
            choice login-credentials {
              // NCS drop mandatory statement
              case stored {
                choice remote-user {
                  // NCS drop mandatory statement
                  leaf same-user {
                    tailf:info
                      "Use the local NCS user name as the remote user
                       name";
                    type empty;
                    description
                      "If this leaf exists, the name of the local NCS user is used
                       as the remote user name.";
                  }
                  leaf remote-name {
                    tailf:info
                      "Specify device user name";
                    type string;
                    description
                      "Remote user name.";
                  }
                }
                choice remote-auth {
                  // NCS drop mandatory statement
                  leaf same-pass {
                    tailf:info
                      "Use the local NCS password as the remote
                       password";
                    type empty;
                    description
                      "If this leaf exists, the password used by the local user
                       when logging in to NCS is used as the remote password.";
                  }
                  leaf remote-password {
                    tailf:info
                      "Specify the remote password";
                    tailf:suppress-echo true;
                    type tailf:aes-256-cfb-128-encrypted-string;
                    description
                      "Remote password.";
                  }
                  case public-key {
                    uses live_ncs_public-key-auth;
                  }
                }
                choice remote-secondary-auth {
                  leaf same-secondary-password {
                    tailf:info
                      "Use the local NCS password as the remote
                       secondary password";
                    type empty;
                    description
                      "If this leaf exists, the password used by the local user
                       when logging in to NCS is used as the remote secondary
                       password.";
                  }
                  leaf remote-secondary-password {
                    tailf:info
                      "Second password for configuration";
                    tailf:suppress-echo true;
                    type tailf:aes-256-cfb-128-encrypted-string;
                    description
                      "Some CLI based devices require a second
                       additional password to enter config mode";
                  }
                }
              }
              case callback {
                leaf callback-node {
                  description
                    "Invoke a standalone action to retrieve login credentials for
                     managed devices on the 'callback-node' instance.

                     The 'action-name' action is invoked on the callback node that
                     is specified by an instance identifer.";
                  // NCS drop mandatory statement
                  // NCS patched to string, due to LSA partial NED
                  type string;
                }
                leaf action-name {
                  description
                    "The action to call when a notification is received.

                     The action must use 'authgroup-callback-input-params'
                     grouping for input and 'authgroup-callback-output-params'
                     grouping for output from tailf-ncs-devices.yang.";
                  type yang:yang-identifier;
                  // NCS drop mandatory statement
                  // NCS drop tailf:validate
                }
              }
            }
          }
          leaf name {
            tailf:info
              "The name of the authgroup";
            type string;
            description
              "The name of the authgroup.";
          }
          container default-map {
            presence "Map unknown users";
            description
              "If an authgroup has a default-map, it is used if a local
               NCS user is not found in the umap list.";
            tailf:info
              "Remote authentication parameters for users not in umap";
            uses remote-user-remote-auth;
          }
          list umap {
            key "local-user";
            description
              "The umap is a list with the local NCS user name as key.
               It maps the local NCS user name to remote authentication
               credentials.";
            tailf:info
              "Map NCS users to remote authentication parameters";
            leaf local-user {
              type string;
              description
                "The local NCS user name.";
            }
            uses remote-user-remote-auth;
          }
        }
        list snmp-group {
          tailf:info
            "SNMP authentication groups";
          key "name";
          description
            "When NCS connects to a managed device over SNMP, it locates
             the snmp-group configured for that device.  Then NCS looks
             up the local NCS user name in the 'umap' list.  If an entry
             is found, the credentials configured is used when
             authenticating to the managed device.

             If no entry is found in the 'umap' list, or credentials for
             the requested SNMP version has not been configured, the
             credentials configured in 'default-map' are used.

             If no 'default-map' has been configured, and the local NCS
             user name is not found in the 'umap' list, the connection
             to the managed device fails.";

          grouping key {
            choice key-type {
              leaf same-password {
                tailf:info
                  "Use the local NCS password to create a localized key";
                type empty;
                description
                  "Use the local NCS password as the password
                   used by NCS to create a localized key, as described
                   in RFC 3414.";
              }
              leaf remote-password {
                tailf:suppress-echo true;
                type tailf:aes-256-cfb-128-encrypted-string;
                description
                  "If this leaf is set, NCS uses its value to create
                   a localized key, as described in RFC 3414.";
                tailf:info
                  "Explicit password";
              }
              leaf key {
                type tailf:hex-list;
                description
                  "Non-localized key specified as a list of
                   colon-separated hexa-decimal octets.  NCS localizes
                   this key for a device before it is used, as described
                   in RFC 3414.";
                tailf:info
                  "Explicit non-localized key";
              }
            }
          }

          grouping remote-snmp-credentials {
            description
              "Remote SNMP credentials.";
            choice community {
              leaf community-name {
                type string;
                description
                  "A community name that can be represented as a
                   YANG string.";
                tailf:info
                  "Community name as a string";
              }
              leaf community-binary-name {
                type binary;
                description
                  "A community name represented as a binary value.";
                tailf:info
                  "Community name as a binary value";
              }
            }
            container usm {
              presence "enables usm";
              tailf:info
                "USM parameters";
              choice remote-user {
                // NCS drop mandatory statement
                leaf same-user {
                  type empty;
                  description
                    "Use the local NCS user name as the remote USM user name.";
                  tailf:info
                    "Use current user's local name as USM user name";
                }
                leaf remote-name {
                  type string {
                    length "1..32";
                  }
                  description
                    "Remote USM user name.";
                  reference "SNMP-USER-BASED-SM-MIB.usmUserName";
                  tailf:info
                    "Explicit USM user name";
                }
              }
              leaf security-level {
                type live_ncs_snmp-security-level;
                // NCS drop mandatory statement
                // NCS drop must statement
                // NCS drop must statement
                tailf:info
                  "SNMP security level";
              }
              container auth {
                presence "enables authentication";
                tailf:info
                  "SNMP authentication parameters";
                choice protocol {
                  // NCS drop mandatory statement
                  reference "SNMP-USER-BASED-SM-MIB.usmUserAuthProtocol";
                  container md5 {
                    uses key;
                    reference "SNMP-USER-BASED-SM-MIB.usmHMACMD5AuthProtocol";
                  }
                  container sha {
                    uses key;
                    reference "SNMP-USER-BASED-SM-MIB.usmHMACSHAAuthProtocol";
                  }
                }
              }
              container priv {
                presence "enables privacy";
                tailf:info
                  "SNMP privacy parameters";
                // NCS drop must statement
                choice protocol {
                  // NCS drop mandatory statement
                  reference "SNMP-USER-BASED-SM-MIB.usmUserPrivProtocol";
                  container des {
                    uses key;
                    reference "SNMP-USER-BASED-SM-MIB.usmDESPrivProtocol";
                  }
                  container aes {
                    uses key;
                    reference "SNMP-USM-AES-MIB.usmAesCfb128Protocol";
                  }
                }
              }
            }
          }
          leaf name {
            tailf:info
              "The name of the snmp authgroup";
            type string;
            description
              "The name of the snmp authgroup.";
          }
          container default-map {
            presence "Map unknown users";
            description
              "If an snmp auth group has a default-map, it is used if a
               local NCS user is not found in the umap list.";
            tailf:info
              "Remote authentication parameters for users not in umap";
            uses remote-snmp-credentials;
          }
          list umap {
            key "local-user";
            description
              "The umap is a list with the local NCS user name as key.
               It maps the local NCS user name to remote authentication
               credentials.";
            tailf:info
              "Map NCS users to remote authentication parameters";
            leaf local-user {
              type string;
              description
                "The local NCS user name.";
            }
            uses remote-snmp-credentials;
          }
        }
      }
      list template {
        tailf:info
          "Named configuration templates for devices";
        key "name";
        description
          "This list is used to define named template configurations that
           can be used to either instantiate the configuration for new
           devices, or to apply snippets of configurations to existing
           devices.

           A template is applied by invoking the 'apply-template' action
           in a device-group or in a device.

           When template is applied, the nodes in the template are by
           default merged with the nodes in the target device.  This
           behaviour can be changed by using tags:

           If a list or container node in the template contains a tag
           with the value 'replace', the template application will
           change from merge to replace for this node.

           Otherwise, if a list or container node in the template
           contains a tag with the value 'nocreate', the template
           application will never create this node or anything below it;
           it will only modify existing containers and list entries.

           Otherwise, if a node in the template contains a tag with the
           value 'delete', the template application will delete this
           node from the device, if it exists.";
        leaf name {
          type string;
          description
            "The name of a specific template configuration.";
        }
        list ned-id {
          key "id";
          leaf id {
            // NCS patched to string, due to LSA partial NED
            type string;
          }
          container config {
            // NCS drop tailf:mount-point
            // NCS drop tailf:cli-add-mode
            // NCS drop tailf:cli-expose-ns-prefix
            description
              "This container is augmented with data models from the devices.";
          }
          tailf:action copy {
            tailf:actionpoint ncsproxy {
              tailf:internal;
            }
            description
              "Copy the template to a new NED identity.

               The action will ignore schema-related errors and instead report
               the paths that failed to be copied in the action output.";
            tailf:info
              "Copy the template to new NED identity";
            tailf:cli-configure-mode;
            // NCS drop tailf:actionpoint
            input {
              leaf ned-id {
                mandatory true;
                tailf:info
                  "The NED identity the template should be copied to";
                // NCS patched to string, due to LSA partial NED
                type string;
              }
            }
            output {
              list failed {
                tailf:code-name "failedx";
                key "path";
                leaf path {
                  type yang:xpath1.0;
                }
                description
                  "Paths that failed to be copied due to schema differences.";
              }
            }
          }
        }
        container config {
          // NCS drop tailf:cli-add-mode
          // NCS drop tailf:cli-expose-ns-prefix
          description
            "Just to support releases prior to 4.5. Will be deprecated";
        }
      }
      list device-group {
        tailf:info
          "Groups of devices";
        key "name";
        leaf name {
          type string;
        }
        description
          "A named group of devices, some actions can be
           applied to an entire  group of devices, for example
           apply-template, and the sync actions.";
        // NCS drop tailf:validate
        uses live_ncs_location {
          description
            "Location of the device group.  These nodes are expected to be
             configured by the operator, typically by using a map application
             in e.g., the Web UI.";
        }
        leaf-list device-name {
          tailf:info
            "Device within group";
          tailf:non-strict-leafref {
            path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/device/name" {
              tailf:xpath-root 3;
            }
          }
          type string;
          // NCS drop tailf:validate
        }
        leaf-list device-group {
          tailf:info
            "Group within group";
          type leafref {
            path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/device-group/name" {
              tailf:xpath-root 3;
            }
          }
          description
            "A list of device groups contained in this device group.

             Recursive definitions are not valid.";
        }
        leaf-list member {
          tailf:info
            "Flattened list of all members";
          type leafref {
            path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/device/name" {
              tailf:xpath-root 3;
            }
          }
          description
            "The current members of the device-group. This is a flat list
             of all the devices in the group.";
          // NCS drop tailf:callpoint
        }
        list ned-id {
          key "id";
          leaf id {
            // NCS patched to string, due to LSA partial NED
            type string;
          }
          container rpc {
            // NCS drop tailf:mount-point
            tailf:info
              "RPCs from the device's";
            description
              "This container is augmented with top-level rpcs
               from the device's data models.

               The rpcs are augments as tailf:actions. This makes it possible
               to invoke rpcs on the devices through the NCS data model.";
          }
          description
            "This list contains the ned-ids set on the devices included in
             this device group.";
          // NCS drop tailf:callpoint
          uses live_ncs_migrate-grouping;
        }
        uses live_ncs_connect-grouping;
        uses live_ncs_sync-to-grouping;
        uses live_ncs_sync-from-grouping;
        uses live_ncs_check-sync-grouping;
        uses live_ncs_check-yang-modules-grouping;
        uses live_ncs_fetch-ssh-host-keys-grouping;
        uses live_ncs_apply-template-grouping;
      }
      list mib-group {
        tailf:info
          "A list of named groups of MIBs";
        key "name";
        description
          "A list of named groups of MIBs.

           This list is used so that SNMP devices can refer to collections
           of MIBs, instead of having to refer to individual MIBs.

           For example, an operator can configure one MIB group per
           device model.";
        // NCS drop tailf:validate
        leaf name {
          type string;
          description
            "An arbitrary name of the MIB group.";
        }
        leaf-list mib-module {
          tailf:info
            "MIB module names or name prefixes";
          type string;
          description
            "A list of MIB module names or MIB module name prefixes in
             this MIB group.

             The string is either exactly matches a MIB module, e.g.,
             'SNMPv2-MIB', or a prefix followed by a wildcard, e.g.,
             'SNMP-*'.  Such a prefix matches all MIB modules with names
             starting by 'SNMP-'.";
        }
        leaf-list mib-group {
          tailf:info
            "A list of MIB groups contained in this MIB group";
          type leafref {
            path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/mib-group/name" {
              tailf:xpath-root 3;
            }
          }
          description
            "A list of MIB groups contained in this MIB group.

             Recursive definitions are not valid.";
        }
      }
      list device {
        tailf:info
          "The list of managed devices";
        key "name";
        description
          "This list contains all devices managed by NCS.";
        leaf name {
          tailf:info
            "A string uniquely identifying the managed device";
          // NCS drop tailf:cli-allow-range
          type string;
          description
            "A string uniquely identifying the managed device.";
        }
        // NCS drop must statement
        // NCS drop fully hidden leaf 'last-changed'
        choice address-choice {
          case device {
            leaf address {
              tailf:info
                "IP address or host name for the management interface";
              // NCS drop tailf:cli-min-column-width
              type inet:host;
              description
                "IP address or host name for the management interface on
                 the device.";
            }
            leaf port {
              tailf:info
                "Port for the management interface";
              type inet:port-number;
              description
                "Port for the management interface on the device. If this leaf
                 is not configured, NCS will use a default value based on the
                 type of device. For example, a NETCONF device uses port 830,
                 a CLI device over SSH uses port 22, and an SNMP device uses
                 port 161.";
            }
          }
          case lsa-device {
            leaf lsa-remote-node {
              // NCS drop when statement
              type leafref {
                path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/cluster/remote-node/name" {
                  tailf:xpath-root 3;
                }
              }
              description
                "Setting lsa-remote-node indicates that this device is the same
                 as the cluster node. When set the address and port of the
                 cluster node is used for this device.";
            }
          }
        }
        leaf local-user {
          type string;
          description
            "The local user is used when setting up a device
             connection for call home connections.";
        }
        uses live_ncs_ssh-connection-config;
        leaf description {
          tailf:info
            "Free form textual description";
          type string;
          description
            "Free form text describing the device.";
        }
        uses live_ncs_location {
          description
            "Location of the device.  These nodes are expected to be
             configured by the operator, typically by using a map application
             in e.g., the Web UI.";
        }

        grouping ne-type {
          leaf authgroup {
            tailf:info
              "Authentication credentials for the device";
            type leafref {
              path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/authgroups/group/name" {
                tailf:xpath-root 3;
              }
            }
            description
              "The authentication credentials used when connecting
               to this managed device.

               This leaf must be set for NETCONF and CLI devices, and
               may be used by generic NEDs, if applicable.";
          }
          container device-type {
            tailf:info
              "Management protocol for the device";
            choice ne-type {
              case netconf {
                container netconf {
                  // NCS drop must statement
                  leaf ned-id {
                    tailf:info
                      "The NED Identity";
                    // NCS patched to string, due to LSA partial NED
                    type string;
                    // NCS drop tailf:callpoint
                    // NCS drop tailf:validate
                    // NCS drop mandatory statement
                  }
                }
              }
              case generic {
                container generic {
                  tailf:info
                    "Use a generic NED to talk to the device";
                  leaf ned-id {
                    tailf:info
                      "The NED Identity";
                    // NCS patched to string, due to LSA partial NED
                    type string;
                    // NCS drop tailf:callpoint
                    // NCS drop tailf:validate
                    // NCS drop mandatory statement
                  }
                }
              }
              case cli {
                container cli {
                  tailf:info
                    "Use CLI to communicate with the device";
                  // NCS drop must statement
                  leaf ned-id {
                    tailf:info
                      "The NED Identity";
                    // NCS patched to string, due to LSA partial NED
                    type string;
                    // NCS drop tailf:callpoint
                    // NCS drop tailf:validate
                    // NCS drop mandatory statement
                  }
                  leaf protocol {
                    tailf:info
                      "The CLI protocol";
                    type enumeration {
                      enum "telnet";
                      enum "ssh";
                    }
                    // NCS drop default statement
                  }
                }
              }
              case snmp {
                container snmp {
                  leaf version {
                    type live_ncs_snmp-version;
                    // NCS drop mandatory statement
                    tailf:info
                      "SNMP version to use";
                  }
                  leaf context-name {
                    // NCS drop when statement
                    type string;
                    // NCS drop default statement
                    description
                      "The SNMP context name to use when communicating
                       with the device.  If an SNMP engine supports multiple
                       contexts, each context must be handled as a separate
                       managed-device in NCS.";
                    reference "RFC 3411: Architecture for SNMP Management Frameworks";
                    tailf:info
                      "SNMP context to use";
                  }
                  leaf ned-id {
                    tailf:info
                      "The NED Identity";
                    // NCS patched to string, due to LSA partial NED
                    type string;
                    // NCS drop mandatory statement
                  }
                  leaf snmp-authgroup {
                    type leafref {
                      path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/authgroups/snmp-group/name" {
                        tailf:xpath-root 3;
                      }
                    }
                    // NCS drop mandatory statement
                    tailf:info
                      "Name of an SNMP authgroup";
                  }
                  leaf retries {
                    type uint8;
                    // NCS drop default statement
                    description
                      "Specifies the number of retries to be used when sending
                       a request.";
                    tailf:info
                      "Number of times a request is resent";
                  }
                  leaf timeout {
                    type uint32 {
                      range "0..4294967";
                    }
                    units "seconds";
                    // NCS drop default statement
                    description
                      "Specifies the timeout in seconds between retries.";
                    tailf:info
                      "Wait time in seconds between retries";
                  }
                  leaf-list mib-group {
                    tailf:info
                      "A list of MIB groups implemented by the device";
                    type leafref {
                      path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/mib-group/name" {
                        tailf:xpath-root 3;
                      }
                    }
                    description
                      "A list of MIB groups implemented by the device.

                       In SNMP, there is no generic, automatic way to
                       figure out which MIBs an agent implements.  Thus,
                       this list can be used to inform NCS which MIBs the
                       device implements.

                       If this list is empty, NCS assumes that the device
                       implements all MIBs known to NCS.

                       The MIBs NCS thinks the device implements are
                       listed in /devices/module.  These
                       modules are used by NCS to control what data can
                       be configured under /devices/device/config,
                       and what data is shown in
                       /devices/device/live-status.";
                  }
                }
              }
            }
          }
        }
        // NCS expand uses statement
        leaf authgroup {
          tailf:info
            "Authentication credentials for the device";
          type leafref {
            path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/authgroups/group/name" {
              tailf:xpath-root 3;
            }
          }
          description
            "The authentication credentials used when connecting
             to this managed device.

             This leaf must be set for NETCONF and CLI devices, and
             may be used by generic NEDs, if applicable.";
        }
        container device-type {
          tailf:info
            "Management protocol for the device";
          choice ne-type {
            case netconf {
              container netconf {
                // NCS drop must statement
                leaf ned-id {
                  tailf:info
                    "The NED Identity";
                  // NCS patched to string, due to LSA partial NED
                  type string;
                  // NCS drop tailf:callpoint
                  // NCS drop tailf:validate
                  // NCS drop mandatory statement
                }
              }
            }
            case generic {
              container generic {
                tailf:info
                  "Use a generic NED to talk to the device";
                leaf ned-id {
                  tailf:info
                    "The NED Identity";
                  // NCS patched to string, due to LSA partial NED
                  type string;
                  // NCS drop tailf:callpoint
                  // NCS drop tailf:validate
                  // NCS drop mandatory statement
                }
              }
            }
            case cli {
              container cli {
                tailf:info
                  "Use CLI to communicate with the device";
                // NCS drop must statement
                leaf ned-id {
                  tailf:info
                    "The NED Identity";
                  // NCS patched to string, due to LSA partial NED
                  type string;
                  // NCS drop tailf:callpoint
                  // NCS drop tailf:validate
                  // NCS drop mandatory statement
                }
                leaf protocol {
                  tailf:info
                    "The CLI protocol";
                  type enumeration {
                    enum "telnet";
                    enum "ssh";
                  }
                  // NCS drop default statement
                }
              }
            }
            case snmp {
              container snmp {
                leaf version {
                  type live_ncs_snmp-version;
                  // NCS drop mandatory statement
                  tailf:info
                    "SNMP version to use";
                }
                leaf context-name {
                  // NCS drop when statement
                  type string;
                  // NCS drop default statement
                  description
                    "The SNMP context name to use when communicating
                     with the device.  If an SNMP engine supports multiple
                     contexts, each context must be handled as a separate
                     managed-device in NCS.";
                  reference "RFC 3411: Architecture for SNMP Management Frameworks";
                  tailf:info
                    "SNMP context to use";
                }
                leaf ned-id {
                  tailf:info
                    "The NED Identity";
                  // NCS patched to string, due to LSA partial NED
                  type string;
                  // NCS drop mandatory statement
                }
                leaf snmp-authgroup {
                  type leafref {
                    path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/authgroups/snmp-group/name" {
                      tailf:xpath-root 3;
                    }
                  }
                  // NCS drop mandatory statement
                  tailf:info
                    "Name of an SNMP authgroup";
                }
                leaf retries {
                  type uint8;
                  // NCS drop default statement
                  description
                    "Specifies the number of retries to be used when sending
                     a request.";
                  tailf:info
                    "Number of times a request is resent";
                }
                leaf timeout {
                  type uint32 {
                    range "0..4294967";
                  }
                  units "seconds";
                  // NCS drop default statement
                  description
                    "Specifies the timeout in seconds between retries.";
                  tailf:info
                    "Wait time in seconds between retries";
                }
                leaf-list mib-group {
                  tailf:info
                    "A list of MIB groups implemented by the device";
                  type leafref {
                    path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/mib-group/name" {
                      tailf:xpath-root 3;
                    }
                  }
                  description
                    "A list of MIB groups implemented by the device.

                     In SNMP, there is no generic, automatic way to
                     figure out which MIBs an agent implements.  Thus,
                     this list can be used to inform NCS which MIBs the
                     device implements.

                     If this list is empty, NCS assumes that the device
                     implements all MIBs known to NCS.

                     The MIBs NCS thinks the device implements are
                     listed in /devices/module.  These
                     modules are used by NCS to control what data can
                     be configured under /devices/device/config,
                     and what data is shown in
                     /devices/device/live-status.";
                }
              }
            }
          }
          // NCS drop must statement
        }
        tailf:action migrate {
          tailf:actionpoint ncsproxy {
            tailf:internal;
          }
          description
            "Change the NED identity and migrate all data. Reads and commits
             the actual device configuration as a side-effect.

             The action reports what paths have been modified and the services
             affected by those changes.

             If the wait-for-lock parameter is not given, the wait-for-lock
             device setting is going to be used.";
          tailf:info
            "Migrate the device to a new NED type";
          // NCS drop tailf:actionpoint
          input {
            leaf new-ned-id {
              mandatory true;
              tailf:info
                "The new NED Identity";
              // NCS patched to string, due to LSA partial NED
              type string;
            }
            leaf no-networking {
              type empty;
              description
                "Do not generate any southbound traffic towards the
                 device. Use the device configuration in CDB.";
            }
            choice display-mode {
              case display-result {
                leaf dry-run {
                  type empty;
                }
                leaf verbose {
                  tailf:info
                    "Report all service instances";
                  description
                    "Report all service instances instead of just the
                     service points.";
                  type empty;
                }
              }
              leaf suppress-positive-result {
                tailf:info
                  "Only return result if some error occurred";
                type empty;
                description
                  "If this optional parameter is included, result is only
                   returned if an error occurs.";
              }
            }
            uses live_ncs_wait-for-lock;
          }
          output {
            uses live_ncs_migrate-result;
          }
        }
        leaf device-profile {
          type leafref {
            path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/profiles/profile/name" {
              tailf:xpath-root 3;
            }
          }
        }
        uses device-profile-parameters {
          augment "commit-queue" {
            leaf queue-length {
              type int32;
              description
                "The number of queue items that contain the device.";
              // NCS drop tailf:callpoint
            }
            list waiting-for {
              description
                "A list of devices in the queue that the device is waiting
                 for in order to execute.";
              // NCS drop tailf:callpoint
              leaf device {
                type leafref {
                  path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/device/name" {
                    tailf:xpath-root 3;
                  }
                }
              }
            }
          }
        }
        container active-settings {
          tailf:info
            "Show all active settings for the device";
          description
            "The active set of parameters used when communicating with
             the device.";
          // NCS drop tailf:callpoint
          uses device-profile-parameters;
        }
        list live-status-protocol {
          tailf:info
            "Additional protocols for the live-tree (read-only)";
          key "name";
          description
            "It is possible to have additional NEDs speaking
             southbound to the managed device for the device's
             'live-status' tree.

             All configuration data must be handled by one NED, but
             multiple NEDs can be used for the 'live-status' tree.

             For example a CLI NED can be used for 'show routes'
             and the SNMP NED for some additional MIBs";
          leaf name {
            type string;
          }
          leaf address {
            tailf:info
              "IP Address for the management interface";
            type inet:host;
            description
              "IP address or host name for the management interface on
               the device. If omitted the same address as configured for
               this device will be used.";
          }
          leaf port {
            tailf:info
              "Port for the management interface";
            type inet:port-number;
            description
              "Port for the management interface on the device.  If this leaf
               is not configured, NCS will use a default value based on
               the type of device.  For example, a NETCONF device uses
               port 830, a CLI device over SSH uses port 22, and an SNMP
               device uses port 161.";
          }
          container ssh {
            presence "protocol-specific ssh host keys";
            tailf:info
              "SSH host key configuration";
            tailf:code-name "ssh_container";
            description
              "SSH host keys for this protocol. If not present, the host keys
               configured for this device will be used.";
            uses live_ncs_ssh-host-keys;
          }
          container ssh-algorithms {
            tailf:info
              "SSH algorithms configuration";
            description
              "Supported (allowed) algorithms that should be used during
               SSH algorithm negotiations. If a specific algorithm type
               is not present, the algorithms configured for this device
               will be used.";
            uses live_ncs_ssh-algorithms;
          }
          // NCS expand uses statement
          leaf authgroup {
            tailf:info
              "Authentication credentials for the device";
            type leafref {
              path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/authgroups/group/name" {
                tailf:xpath-root 3;
              }
            }
            description
              "The authentication credentials used when connecting
               to this managed device.

               This leaf must be set for NETCONF and CLI devices, and
               may be used by generic NEDs, if applicable.";
          }
          container device-type {
            tailf:info
              "Management protocol for the device";
            choice ne-type {
              case netconf {
                container netconf {
                  // NCS drop must statement
                  leaf ned-id {
                    tailf:info
                      "The NED Identity";
                    // NCS patched to string, due to LSA partial NED
                    type string;
                    // NCS drop tailf:callpoint
                    // NCS drop tailf:validate
                    // NCS drop mandatory statement
                  }
                }
              }
              case generic {
                container generic {
                  tailf:info
                    "Use a generic NED to talk to the device";
                  leaf ned-id {
                    tailf:info
                      "The NED Identity";
                    // NCS patched to string, due to LSA partial NED
                    type string;
                    // NCS drop tailf:callpoint
                    // NCS drop tailf:validate
                    // NCS drop mandatory statement
                  }
                }
              }
              case cli {
                container cli {
                  tailf:info
                    "Use CLI to communicate with the device";
                  // NCS drop must statement
                  leaf ned-id {
                    tailf:info
                      "The NED Identity";
                    // NCS patched to string, due to LSA partial NED
                    type string;
                    // NCS drop tailf:callpoint
                    // NCS drop tailf:validate
                    // NCS drop mandatory statement
                  }
                  leaf protocol {
                    tailf:info
                      "The CLI protocol";
                    type enumeration {
                      enum "telnet";
                      enum "ssh";
                    }
                    // NCS drop default statement
                  }
                }
              }
              case snmp {
                container snmp {
                  leaf version {
                    type live_ncs_snmp-version;
                    // NCS drop mandatory statement
                    tailf:info
                      "SNMP version to use";
                  }
                  leaf context-name {
                    // NCS drop when statement
                    type string;
                    // NCS drop default statement
                    description
                      "The SNMP context name to use when communicating
                       with the device.  If an SNMP engine supports multiple
                       contexts, each context must be handled as a separate
                       managed-device in NCS.";
                    reference "RFC 3411: Architecture for SNMP Management Frameworks";
                    tailf:info
                      "SNMP context to use";
                  }
                  leaf ned-id {
                    tailf:info
                      "The NED Identity";
                    // NCS patched to string, due to LSA partial NED
                    type string;
                    // NCS drop mandatory statement
                  }
                  leaf snmp-authgroup {
                    type leafref {
                      path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/authgroups/snmp-group/name" {
                        tailf:xpath-root 3;
                      }
                    }
                    // NCS drop mandatory statement
                    tailf:info
                      "Name of an SNMP authgroup";
                  }
                  leaf retries {
                    type uint8;
                    // NCS drop default statement
                    description
                      "Specifies the number of retries to be used when sending
                       a request.";
                    tailf:info
                      "Number of times a request is resent";
                  }
                  leaf timeout {
                    type uint32 {
                      range "0..4294967";
                    }
                    units "seconds";
                    // NCS drop default statement
                    description
                      "Specifies the timeout in seconds between retries.";
                    tailf:info
                      "Wait time in seconds between retries";
                  }
                  leaf-list mib-group {
                    tailf:info
                      "A list of MIB groups implemented by the device";
                    type leafref {
                      path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/mib-group/name" {
                        tailf:xpath-root 3;
                      }
                    }
                    description
                      "A list of MIB groups implemented by the device.

                       In SNMP, there is no generic, automatic way to
                       figure out which MIBs an agent implements.  Thus,
                       this list can be used to inform NCS which MIBs the
                       device implements.

                       If this list is empty, NCS assumes that the device
                       implements all MIBs known to NCS.

                       The MIBs NCS thinks the device implements are
                       listed in /devices/module.  These
                       modules are used by NCS to control what data can
                       be configured under /devices/device/config,
                       and what data is shown in
                       /devices/device/live-status.";
                  }
                }
              }
            }
            // NCS drop must statement
          }
          container state {
            tailf:info
              "Operational State for the live protocol";
            // NCS drop tailf:cdb-oper
            uses live_ncs_oper-state;
          }
          list capability {
            tailf:info
              "List of capabillities supported by the device";
            key "uri";
            description
              "This is a list of the capabilities supported by the device.
               when additional NEDs have been configured in the live tree.
               This list is thus the result of those extra stats NEDs.
               This list is populated the first time NCS connects to the
               device.  Not dependant on local-user.";
            // NCS drop tailf:cdb-oper
            leaf uri {
              tailf:info
                "Capability URI";
              type string;
            }
            leaf revision {
              tailf:info
                "Capability revision";
              type string;
            }
            leaf module {
              tailf:info
                "Capability module";
              type string;
            }
            leaf-list feature {
              tailf:info
                "Capability features";
              type string;
            }
            leaf-list deviation {
              tailf:info
                "Capability deviations";
              type string;
            }
          }
        }
        container state {
          tailf:info
            "Show states for the device";
          uses live_ncs_oper-state;
          leaf transaction-mode {
            type enumeration {
              enum "start-trans-running" {
                description
                  "NETCONF devices that support the Tail-f capability
                   http://tail-f.com/ns/netconf/transactions/1.0 and
                   :writable-running.";
              }
              enum "lock-reset-candidate" {
                description
                  "NETCONF devices that support :candidate and
                   :writable-running.";
              }
              enum "lock-candidate" {
                description
                  "NETCONF devices that support :candidate but not
                   :writable-running.";
              }
              enum "startup" {
                description
                  "NETCONF devices with :writable-running and :startup.";
              }
              enum "running-only" {
                description
                  "NETCONF devices with :writable-running only.";
              }
              enum "private-candidate" {
                description
                  "NETCONF devices that support the concept of a private
                   candidate.  There is no standard capability for this,
                   but some devices support it.";
              }
              enum "ned" {
                tailf:code-name "transmode-ned";
                description
                  "The transaction is controlled by a Network Equipment
                   Driver.  The exact transaction mode depends on the type
                   of the NED.";
              }
              enum "candidate-startup" {
                description
                  "NETCONF devices with :candidate and :startup.";
              }
            }
            description
              "Describes which transaction mode NCS has choosen for
               NETCONF traffic towards the device.";
            // NCS drop tailf:cdb-oper
          }
          leaf last-transaction-id {
            type string;
            description
              "If the device supports the tailf-netconf-monitoring module,
               NCS keeps track of this string when reconfiguring a
               device, making it possible to cheeply check if a device
               has been reconfigured out of band.

               This value gets intialized when NCS syncs towards a device,
               and is then subsequently updated with each commit.";
            // NCS drop tailf:cdb-oper
          }
          container last-modules-state {
            // NCS drop tailf:cdb-oper
            description
              "If the device supports the ietf-yang-library module, NCS
               stores a copy of the YANG library advertised on the device,
               to avoid reading the module list at every connect.";
          }
          leaf admin-state {
            // NCS drop must statement
            tailf:info
              "Controls configuration and southbound communication";
            type live_ncs_admin-state;
            // NCS drop default statement
          }
          leaf admin-state-description {
            type string;
            description
              "Reason for the admin state.";
          }
        }
        container source {
          tailf:info
            "How the device was added to NCS";
          leaf added-by-user {
            type string;
          }
          leaf context {
            type string;
          }
          leaf when {
            type yang:date-and-time;
          }
          leaf from-ip {
            type inet:ip-address;
          }
          leaf source {
            type string;
            reference "TMF518 NRB Network Resource Basics";
          }
        }
        uses capability-module-grouping {
          refine "capability" {
            tailf:info
              "A list of capabilities supported by the device";
            description
              "This is a list of the capabilities supported by the device.

               This list is populated the first time NCS connects to the
               device.  Not dependent on local-user.

               This list is not populated if the device doesn't
               advertise any known YANG modules, unless it is a NETCONF
               device with ned-id 'tailf-ncs-ned:netconf'.  By setting
               the ned-id to 'tailf-ncs-ned:netconf' it is possible to
               connect to a device, inspect its capabilities, and then pick
               a suitable ned-id based on the capabilities it advertises.

               For a NETCONF device, this list contains all capabilities
               announced in the <hello> message, and all YANG modules
               announced as implemented by the YANG library, if it is
               implemented on the device.";
            // NCS drop tailf:cdb-oper
          }
          refine "module" {
            description
              "This is a list of the YANG modules implemented by the device
               that are also supported by the NED for the device.

               This list is populated the first time NCS connects to the
               device.";
            // NCS drop tailf:cdb-oper
          }
          augment "capability" {
            tailf:action remove {
              tailf:actionpoint ncsproxy {
                tailf:internal;
              }
              description
                "This action removes a capability from the list of capabilities.
                 If leaf module is set then corresponding module is attempted to
                 be removed from the list of modules for this device. This action
                 is only intended to be used for pre-provisioning: it is not
                 possible to override capabilities and modules provided by the
                 NED implementation using this action.";
              // NCS drop tailf:actionpoint
            }
          }
        }
        tailf:action find-capabilities {
          tailf:actionpoint ncsproxy {
            tailf:internal;
          }
          description
            "This action overwrites existing list of capabilities.

             This action is only intended to be used for
             pre-provisioning: it is not possible to override
             capabilities and modules provided by the NED implementation
             using this action.

             This action populates the list of capabilities based on the
             configured ned-id for the device, if possible.  NCS will
             look up the package corresponding to the ned-id and add all
             the modules from these packages to the list of device
             capabilities and list of modules.  It is the responsibility
             of the caller to verify that the automatically populated
             list of capabilities matches actual device capabilities.
             The list of capabilities can then be fine-tuned using
             add-capability and capability/remove actions.

             Currently this approach works only for CLI and generic
             devices.";
          // NCS drop tailf:actionpoint
          output {
            leaf result {
              description
                "The result indicates whether any new capabilities have
                 been found and saved for this device.";
              type boolean;
            }
          }
        }
        tailf:action add-capability {
          tailf:actionpoint ncsproxy {
            tailf:internal;
          }
          description
            "This action adds a capability to the list of capabilities.

             This action is only intended to be used for
             pre-provisioning.  It is not possible to override
             capabilities and modules provided by the NED implementation
             using this action.

             If a uri is specified, then it is parsed as a YANG
             capability string, and module, revision, feature and
             deviation parameters are derived from the string.

             If a module is specified, then the namespace is looked up
             in the list of loaded namespaces and a capability string is
             constructed automatically.  If a module is specified and
             the attempt to look it up failed, then the action does
             nothing.

             If a module is specified or can be derived from the
             capability string, then the module is also added/replaced
             in the list of modules.";
          // NCS drop tailf:actionpoint
          input {
            choice capability-input {
              mandatory true;
              case capability-uri {
                leaf uri {
                  type string;
                }
              }
              case capability-parameters {
                leaf ned-id {
                  tailf:non-strict-leafref {
                    path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/ned-ids/ned-id/id" {
                      tailf:xpath-root 3;
                    }
                  }
                  // NCS patched to string, due to LSA partial NED
                  type string;
                }
                leaf module {
                  tailf:non-strict-leafref {
                    path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/ned-ids/ned-id[id = current()/../ned-id]/module/name" {
                      tailf:xpath-root 3;
                    }
                  }
                  type string;
                  mandatory true;
                }
                leaf revision {
                  tailf:non-strict-leafref {
                    path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/ned-ids/ned-id[id = current()/../ned-id]/module[name = current()/../module]/revision" {
                      tailf:xpath-root 3;
                    }
                  }
                  type string;
                }
                leaf-list feature {
                  type string;
                }
                leaf-list deviation {
                  type string;
                }
              }
            }
          }
        }
        container platform {
          // NCS drop tailf:cdb-oper
          description
            "Contains vendor-specific information for
             identifying the system platform.

             NEDs MAY augment this container with more device-specific
             nodes.";
          leaf name {
            type string;
            description
              "The name of the system platform, for example,
               'ios', 'ios-xr', or 'open-wrt'.";
          }
          leaf version {
            type string;
            description
              "The current version of the system platform.  The format
               of this string is vendor-specific.";
          }
          leaf model {
            type string;
            description
              "The name of the product model.  For example: if the device
               comes in different types of hardware it may refer to the
               hardware model or if the NED supports several different
               platforms the model may refer to a product family.";
          }
          leaf serial-number {
            type string;
            description
              "Serial number of the device.";
          }
        }
        uses live_ncs_apply-template-grouping;
        tailf:action instantiate-from-other-device {
          tailf:actionpoint ncsproxy {
            tailf:internal;
          }
          description
            "Instantiate the configuration for the device as a copy of the
             configuration of some other already working device.";
          tailf:info
            "Instantiate the config for the device from existing device";
          tailf:cli-configure-mode;
          // NCS drop tailf:actionpoint
          input {
            leaf device-name {
              type leafref {
                path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/device/name" {
                  tailf:xpath-root 3;
                }
              }
            }
          }
        }
        tailf:action compare-config {
          tailf:actionpoint ncsproxy {
            tailf:internal;
          }
          description
            "Retrieve the config from the device and compare
             to the NCS locally stored copy.

             If the wait-for-lock parameter is not given, the wait-for-lock
             device setting is going to be used.";
          tailf:info
            "Compare the actual device config with the NCS copy";
          // NCS drop tailf:actionpoint
          input {
            leaf outformat {
              type live_ncs_outformat2;
            }
            uses live_ncs_wait-for-lock;
          }
          output {
            choice compare-result {
              leaf diff {
                type string;
              }
              leaf info {
                type string;
                description
                  "If present, contains additional information about the result.";
              }
            }
          }
        }
        tailf:action sync-from {
          tailf:actionpoint ncsproxy {
            tailf:internal;
          }
          description
            "Synchronize the NCS copy of the device configuration by
             reading the actual device configuration. The change will be
             immediately committed to NCS.

             If the wait-for-lock parameter is not given, the wait-for-lock
             device setting is going to be used.";
          tailf:info
            "Synchronize the config by pulling from the device";
          // NCS drop tailf:actionpoint
          input {
            container dry-run {
              presence "";
              leaf outformat {
                type live_ncs_outformat2;
                description
                  "Report what would be done towards CDB, without
                   actually doing anything.";
              }
            }
            leaf verbose {
              type empty;
              description
                "Use this to show additional parse information if supported
                 by the NED.";
            }
            uses live_ncs_wait-for-lock;
          }
          output {
            uses live_ncs_sync-result;
          }
        }
        tailf:action sync-to {
          tailf:actionpoint ncsproxy {
            tailf:internal;
          }
          description
            "Synchronize the device configuration by pushing NCS copy
             to the device.

             NCS pushes a minimal diff to the device. The
             diff is calculated by reading the configuration from the
             device and comparing with the configuration in NCS.

             For a NETCONF device, NCS can optionally replace the
             configuration on the device by sending its own
             configuration without calculating the diff.  Note that NCS
             will send an <edit-config> with the 'replace' option in
             this case.  This means that configuration subtrees that NCS
             does not know about are not replaced.

             If the dry-run option is used, the action simply
             reports (in different formats) what it would do.

             If the wait-for-lock parameter is not given, the wait-for-lock
             device setting is going to be used.";
          tailf:info
            "Synchronize the config by pushing to the device";
          // NCS drop tailf:actionpoint
          input {
            leaf mode {
              status deprecated;
              tailf:info
                "DEPRECATED - use sync-to default behaviour instead";
              type enumeration {
                enum "replace";
              }
              description
                "For a NETCONF device, replace the device configurations
                 with the NCS configurations, instead of sending the diff.

                 Cannot be used with a non-NETCONF device.

                 This leaf is deprecated. Use sync-to default behaviour
                 instead.";
            }
            container dry-run {
              presence "";
              leaf outformat {
                type live_ncs_outformat3;
                description
                  "Report what would be done towards the device, without
                   actually doing anything.";
              }
            }
            uses live_ncs_wait-for-lock;
          }
          output {
            uses live_ncs_sync-to-result;
          }
        }
        tailf:action check-sync {
          tailf:actionpoint ncsproxy {
            tailf:internal;
          }
          description
            "Check if the NCS copy of the device configuration is in sync
             with the actual device configuration, using device-specific
             mechanisms. This operation is usually cheap as it only
             compares a signature of the configuration from the
             device rather than comparing the entire configuration.

             Depending on the device the signature is implemented as a
             transaction-id, timestamp, hash-sum or not at all.
             The capability must be supported by the corresponding
             NED. The output might say unsupported, and then the only way
             to perform this would be to do a full 'compare-config' command.

             As some NEDs implements the signature as an hash-sum
             of the entire configuration, this operation might for
             some devices be just as expensive as performing a full
             compare-config command.

             If the wait-for-lock parameter is not given, the wait-for-lock
             device setting is going to be used.";
          tailf:info
            "Check if the NCS config is in sync with the device";
          // NCS drop tailf:actionpoint
          input {
            uses live_ncs_wait-for-lock;
          }
          output {
            uses live_ncs_check-sync-result;
          }
        }
        tailf:action check-yang-modules {
          tailf:actionpoint ncsproxy {
            tailf:internal;
          }
          description
            "Check if the device YANG modules loaded by NCS
             have revisions that are compatible with the ones reported
             by the device.";
          tailf:info
            "Check if NCS and the device have compatible YANG modules";
          // NCS drop tailf:actionpoint
          input {
            leaf verbose {
              type empty;
              description
                "Use this to show additional compatibility info.";
            }
          }
          output {
            uses live_ncs_check-yang-modules-result;
          }
        }
        tailf:action connect {
          tailf:actionpoint ncsproxy {
            tailf:internal;
          }
          description
            "Set up a session to the unlocked device.";
          tailf:info
            "Connect to the device";
          // NCS drop tailf:actionpoint
          input {
            leaf override-southbound-locked {
              type empty;
              description
                "When a device is southbound locked, all southbound
                 communication is turned off. This flag overrides the
                 southbound lock for connection attempts. Thus, this
                 is a way to update the capabilities including revision
                 information for a managed device although the device
                 is southbound locked.";
            }
          }
          output {
            uses live_ncs_connect-result;
          }
        }
        uses live_ncs_disconnect-grouping-specific;
        tailf:action ping {
          tailf:actionpoint ncsproxy {
            tailf:internal;
          }
          description
            "ICMP ping the device.";
          tailf:info
            "ICMP ping the device";
          // NCS drop tailf:actionpoint
          output {
            leaf result {
              type string;
            }
          }
        }
        tailf:action delete-config {
          tailf:actionpoint ncsproxy {
            tailf:internal;
          }
          description
            "Delete the device configuration in NCS without executing
             the corresponding delete on the managed device.";
          tailf:info
            "Delete the config in NCS without deleting it on the device";
          // NCS drop tailf:actionpoint
          input {
            leaf ned-id {
              tailf:info
                "The NED Identity for which configuration will be
                 deleted";
              // NCS patched to string, due to LSA partial NED
              type string;
            }
          }
        }
        tailf:action scp-to {
          tailf:actionpoint ncsproxy {
            tailf:internal;
          }
          description
            "Secure copy file to the device.";
          tailf:info
            "Secure copy file to the device";
          // NCS drop tailf:actionpoint
          input {
            leaf local-file {
              tailf:info
                "Name of the file in the local filesystem.";
              type string;
              mandatory true;
            }
            leaf remote-file {
              tailf:info
                "Name of the file on the device.";
              type string;
              default ".";
            }
            leaf port {
              tailf:info
                "Port to connect to on the device";
              type inet:port-number;
              description
                "Specifies the port to connect to on the device.
                 If this leaf is not configured, NCS will use the port for the
                 management interface of the device.";
            }
            leaf preserve {
              type empty;
              description
                "Preserves modification times, access times, and modes
                 from the original file. This is not always supported by the
                 device.";
            }
          }
          output;
        }
        tailf:action scp-from {
          tailf:actionpoint ncsproxy {
            tailf:internal;
          }
          description
            "Secure copy file from the device.";
          tailf:info
            "Secure copy file to the device";
          // NCS drop tailf:actionpoint
          input {
            leaf local-file {
              tailf:info
                "Name of the file in the local filesystem.";
              type string;
              default ".";
            }
            leaf remote-file {
              tailf:info
                "Name of the file on the device.";
              type string;
              mandatory true;
            }
            leaf port {
              tailf:info
                "Port to connect to on the device";
              type inet:port-number;
              description
                "Specifies the port to connect to on the device.
                 If this leaf is not configured, NCS will use the port for the
                 management interface of the device.";
            }
            leaf preserve {
              type empty;
              description
                "Preserves modification times, access times, and modes
                 from the original file. This is not always supported by the
                 device.";
            }
          }
          output;
        }
        tailf:action load-native-config {
          tailf:actionpoint ncsproxy {
            tailf:internal;
          }
          tailf:display-when "../device-type/cli or ../device-type/generic or ../device-type/netconf" {
            tailf:xpath-root 3;
          }
          description
            "Load configuration data in native format into the transaction.
             This action is only applicable for devices with
             NETCONF, CLI and generic NEDs.

             By default the behaviour is to merge the configuration
             that is applied. This can be changed by setting the mode option
             to replace. This will replace the entire device configuration.

             This action will behave differently depending on if it is
             invoked with a transaction or not. When invoked with a
             transaction (such as via the CLI) it will load the
             configuration into it and leave it to the user to commit
             or revert the resulting changes. If invoked without a
             transaction (for example when invoked via RESTCONF),
             the action will automatically create one and commit
             the resulting changes.";
          tailf:info
            "Load configuration data in native format";
          tailf:cli-configure-mode;
          // NCS drop tailf:actionpoint
          input {
            choice source {
              leaf file {
                type string;
                description
                  "Name of file with configuration data in native format
                   in the local filesystem. If the device is remote
                   the file must exists in the local filesystem of the
                   remote node.";
              }
              leaf data {
                type string;
                tailf:cli-multi-line-prompt;
                description
                  "Configuration data in native format. If loading
                   XML the data must be a valid XML document,
                   either with a single namespace or wrapped in a
                   config node with the http://tail-f.com/ns/config/1.0
                   namespace.";
              }
              mandatory true;
            }
            leaf mode {
              type enumeration {
                enum "merge" {
                  tailf:code-name "load_native_merge";
                  description
                    "Merge with the existing device configuration.";
                }
                enum "replace" {
                  tailf:code-name "load_native_replace";
                  description
                    "Replace the entire device configuration.";
                }
              }
              default "merge";
              description
                "Merge or replace the configuration. The default behaviour
                 is to merge.";
            }
            container dry-run {
              tailf:hidden "programmatic-interface";
              presence "";
              leaf outformat {
                type live_ncs_outformat3;
              }
            }
            uses live_ncs_ncs-hidden-commit-params;
            leaf verbose {
              type empty;
              description
                "Use this to show additional parse information if supported
                 by the NED.";
            }
          }
          output {
            choice outformat {
              case case-xml {
                uses live_ncs_dry-run-xml;
              }
              case case-cli {
                uses live_ncs_dry-run-cli;
              }
              case case-native {
                uses live_ncs_dry-run-native;
              }
            }
            uses live_ncs_ncs-commit-result;
            leaf info {
              type string;
              description
                "If present, contains additional information about the result.";
            }
          }
        }
        container config {
          // NCS drop tailf:cli-add-mode
          // NCS drop tailf:cli-expose-ns-prefix
          tailf:info
            "NCS copy of the device configuration";
          description
            "This container is used to mount configuration data nodes
             from the device's data models.

             This is where NCS's copy of the device configuration is stored.

             This container defines a mount point as defined in 'YANG
             Schema Mount' (draft-ietf-netmod-schema-mount-10).  This
             means that NCS maintains a config false instantiation of
             the YANG library under this container, which can be read by a
             client to learn the data model (schema) for the device.";
        }
        container live-status {
          tailf:info
            "Status data fetched from the device";
          description
            "This container is used to mount state data nodes from the
             device's data models.

             All data models from the device are mounted as config
             false data.  Thus this container contains both the state
             and running configuration on the device.  Whenever data in
             this tree is accessed, NCS will retrieve data from the
             device in real time.

             The purpose is to expose state data from the managed devices in
             the NCS data tree.

             This container defines a mount point as defined in 'YANG
             Schema Mount' (draft-ietf-netmod-schema-mount-10).  This
             means that NCS maintains a config false instantiation of
             the YANG library under this container, which can be read by a
             client to learn the data model (schema) for the device.";
          // NCS drop tailf:callpoint
        }
        container rpc {
          // NCS drop tailf:mount-point
          tailf:info
            "RPCs from the device";
          description
            "This container is augmented with top-level rpcs
             from the device's data models.

             The rpcs are augments as tailf:actions.  This makes it possible
             to invoke rpcs on the devices through the NCS data model.";
        }
        container notifications {
          // NCS drop when statement
          tailf:info
            "Notifications from the device";
          description
            "Event notification support using NETCONF or
             protocols implemented by the NED.";
          reference "RFC 5277 - NETCONF Event Notifications";
          // NCS expand uses statement
          list subscription {
            tailf:info
              "List of subscriptions";
            key "name";
            description
              "A list of our notification subscriptions for this managed device.";
            leaf name {
              type string;
              description
                "Each subscription must have a unique name.";
            }
            leaf stream {
              tailf:info
                "The notification stream name";
              type string;
              // NCS drop mandatory statement
              description
                "The name of the notification stream this subscription
                 refers to.";
            }
            choice filter {
              description
                "Optional element, if not set, no filters are applied.";
              case xpath {
                leaf xpath {
                  tailf:info
                    "XPath filter for the notifications";
                  type yang:xpath1.0;
                }
              }
              case subtree {
                leaf subtree {
                  tailf:info
                    "Subtree filter for the notifications";
                  type string;
                }
              }
            }
            leaf local-user {
              type string;
              // NCS drop mandatory statement
              description
                "The local user is used when setting up a device
                 connection.";
            }
            leaf store-in-cdb {
              tailf:info
                "Store notifications in CDB";
              type boolean;
              // NCS drop default statement
              description
                "Indicate whether notifications should be stored as
                 operational data in CDB.

                 When notifications are generated at a high rate,
                 storage consumes lots of resources. In cases like that,
                 consider using the device-notification event stream
                 instead.";
            }
            leaf utilize-replay {
              tailf:info
                "Use replay when connecting to the device";
              type boolean;
              // NCS drop default statement
              description
                "If the device supports replay, should NCS attempt to use that
                 when connecting to the device.";
            }
            leaf reconnect-interval {
              tailf:info
                "Interval for re-establishing the subscription";
              type uint32 {
                range "0..4294967";
              }
              units "seconds";
              // NCS drop default statement
              description
                "If the device is non operational, with which
                 interval (in seconds) shall NCS attempt to re-establish
                 the subscription.";
            }
            leaf status {
              type enumeration {
                enum "running" {
                  description
                    "The subscription is established and NCS should
                     be receiving notifications.";
                }
                enum "connecting" {
                  description
                    "Attempting to establish the subscription.";
                }
                enum "failed" {
                  tailf:code-name "notif-failed";
                  description
                    "The subscription has failed.  Unless the failure is
                     in the connection establishing, i.e., connect
                     failed, there will be no automatic re-connect.";
                }
              }
              // NCS drop default statement
              description
                "Is this subscription currently running.";
            }
            leaf failure-reason {
              type enumeration {
                enum "connection-refused" {
                  description
                    "Failed to connect to the device.";
                }
                enum "connection-timeout" {
                  description
                    "Timeout when connecting to the device.";
                }
                enum "session" {
                  description
                    "Failed to establish session.";
                }
                enum "subscribe" {
                  description
                    "The device rejected our subscription attempt.";
                }
                enum "xml" {
                  tailf:code-name "notif-xml";
                  description
                    "NCS received XML that could not be parsed.";
                }
                enum "internal" {
                  description
                    "Internal NCS error.";
                }
                enum "disconnected" {
                  description
                    "Manually disconnected.";
                }
                enum "closed" {
                  tailf:code-name "notif-closed";
                  description
                    "Server closed its end.";
                }
                enum "locked" {
                  tailf:code-name "notif-locked";
                  value 9;
                  description
                    "No subscriptions allowed towards devices that are
                     locked or southbound locked.";
                }
                enum "auth-failed" {
                  value 10;
                  description
                    "Device authentication failed.";
                }
                enum "same-pass" {
                  tailf:code-name "notif-same-pass";
                  value 11;
                  description
                    "Subscription is not allowed when 'same-pass' option is
                     configured for authentication.";
                }
                enum "call-home" {
                  tailf:code-name "notif-call-home";
                  value 12;
                  description
                    "Subscription is not allowed until a call
                     home connection has been established.";
                }
                enum "read-only" {
                  tailf:code-name "notif-read-only";
                  value 13;
                  description
                    "Subscription is not allowed until read-only
                     mode is disabled and/or the mode of the HA node has
                     changed.";
                }
                enum "session-limit-exceeded" {
                  tailf:code-name "notif-session-limit-exceeded";
                  value 14;
                  description
                    "The session limit has been exceeded.";
                }
              }
              description
                "If there is a problem with this subscription
                 this leaf indicates what the problem is.";
              // NCS drop tailf:callpoint
            }
            leaf error-info {
              type string;
              description
                "Contains additional information, if available, when the
                 status is not equal to 'running'.";
              // NCS drop tailf:callpoint
            }
            tailf:action reconnect {
              tailf:actionpoint ncsproxy {
                tailf:internal;
              }
              tailf:info
                "Attempt to reconnect this subscription";
              description
                "Attempt to reconnect this subscription.";
              // NCS drop tailf:actionpoint
            }
            tailf:action disconnect {
              tailf:actionpoint ncsproxy {
                tailf:internal;
              }
              tailf:info
                "Disconnect this subscription if connected";
              description
                "Disconnect this subscription if connected.";
              // NCS drop tailf:actionpoint
            }
            tailf:action replay {
              tailf:actionpoint ncsproxy {
                tailf:internal;
              }
              tailf:info
                "Replay (missed) notifications from the device";
              description
                "Ask the device to replay all notifications for this
                 subscription.  Optionally if a timestamp is given, all
                 notifications newer than the provided timestamp are
                 requested.";
              // NCS drop tailf:actionpoint
              input {
                leaf from-date-time {
                  type yang:date-and-time;
                }
              }
            }
            // NCS drop must statement
          }
          list stream {
            key "name";
            description
              "A list of the notification streams provided by the device.
               NCS reads this list in realtime.";
            // NCS drop tailf:callpoint
            leaf name {
              type string;
              description
                "The name of the the stream.";
            }
            leaf description {
              type string;
              description
                "A textual description of the stream.";
            }
            leaf replay-support {
              type boolean;
              description
                "An indication of whether or not event replay
                 is available on this stream.";
            }
            leaf replay-log-creation-time {
              type yang:date-and-time;
              description
                "The timestamp of the creation of the log used to support
                 the replay function on this stream. Note that this might
                 be earlier then the earliest available notification in the
                 log. This object is updated if the log resets for some
                 reason.";
            }
            leaf replay-log-aged-time {
              type yang:date-and-time;
              description
                "The timestamp of the last notification aged out of the log.";
            }
          }
          list notification-name {
            key "name";
            description
              "List of all names of notifications defined by this device.";
            // NCS drop tailf:callpoint
            leaf name {
              type string;
              description
                "The XML tag of the notification name.";
            }
            leaf uri {
              type string;
              description
                "The XML namespace uri for this notification.";
            }
          }
          container received-notifications {
            leaf max-size {
              type int32;
              // NCS drop default statement
              description
                "Max size of the list of received notifications.
                 When the maximum size is reached, the oldest
                 received notification is purged.";
            }
            leaf clear-time {
              type yang:date-and-time;
              // NCS drop tailf:cdb-oper
              description
                "When were notifications last cleared.";
            }
            tailf:action clear {
              tailf:actionpoint ncsproxy {
                tailf:internal;
              }
              description
                "Delete all received notifications from the
                 'notification' list.";
              // NCS drop tailf:actionpoint
            }
            list notification {
              key "event-time sequence-no";
              description
                "A list of received notifications from the device.
                 The list is a circular list, with a maximum size.
                 When a new notification is added to the list, the oldest
                 entry is purged.";
              // NCS drop tailf:cdb-oper
              leaf event-time {
                type yang:date-and-time;
                description
                  "The time the event was generated at the device.";
              }
              leaf sequence-no {
                type int32;
              }
              leaf user {
                type string;
                description
                  "User name of the user that created the subscription
                   that made this notification end up here.";
              }
              leaf subscription {
                type string;
                description
                  "The name of the subscription that made this
                   notification end up here.";
                // NCS drop must statement
              }
              leaf stream {
                type string;
                description
                  "The name of the stream this notification belongs to.";
              }
              leaf received-time {
                type yang:date-and-time;
                description
                  "The time the event was received at NCS.";
              }
              container data {
                // NCS drop tailf:mount-point
                description
                  "This container is automatically augmented with notifications
                   from the managed device. Whenever a device module
                   that contains notifications is compiled, the device
                   specific notifications end up here, as a container
                   with the same name as the device notification.";
              }
            }
          }
        }
        container netconf-notifications {
          // NCS drop when statement
          tailf:info
            "NETCONF notifications from the device";
          description
            "NETCONF notification support. This container is
             deprecated and will be removed in a future release.
             Use /devices/device/notifications instead.";
          reference "RFC 5277 - NETCONF Event Notifications";
          status deprecated;
          // NCS expand uses statement
          list subscription {
            tailf:info
              "List of subscriptions";
            key "name";
            description
              "A list of our notification subscriptions for this managed device.";
            leaf name {
              type string;
              description
                "Each subscription must have a unique name.";
            }
            leaf stream {
              tailf:info
                "The notification stream name";
              type string;
              // NCS drop mandatory statement
              description
                "The name of the notification stream this subscription
                 refers to.";
            }
            choice filter {
              description
                "Optional element, if not set, no filters are applied.";
              case xpath {
                leaf xpath {
                  tailf:info
                    "XPath filter for the notifications";
                  type yang:xpath1.0;
                }
              }
              case subtree {
                leaf subtree {
                  tailf:info
                    "Subtree filter for the notifications";
                  type string;
                }
              }
            }
            leaf local-user {
              type string;
              // NCS drop mandatory statement
              description
                "The local user is used when setting up a device
                 connection.";
            }
            leaf store-in-cdb {
              tailf:info
                "Store notifications in CDB";
              type boolean;
              // NCS drop default statement
              description
                "Indicate whether notifications should be stored as
                 operational data in CDB.

                 When notifications are generated at a high rate,
                 storage consumes lots of resources. In cases like that,
                 consider using the device-notification event stream
                 instead.";
            }
            leaf utilize-replay {
              tailf:info
                "Use replay when connecting to the device";
              type boolean;
              // NCS drop default statement
              description
                "If the device supports replay, should NCS attempt to use that
                 when connecting to the device.";
            }
            leaf reconnect-interval {
              tailf:info
                "Interval for re-establishing the subscription";
              type uint32 {
                range "0..4294967";
              }
              units "seconds";
              // NCS drop default statement
              description
                "If the device is non operational, with which
                 interval (in seconds) shall NCS attempt to re-establish
                 the subscription.";
            }
            leaf status {
              type enumeration {
                enum "running" {
                  description
                    "The subscription is established and NCS should
                     be receiving notifications.";
                }
                enum "connecting" {
                  description
                    "Attempting to establish the subscription.";
                }
                enum "failed" {
                  tailf:code-name "notif-failed";
                  description
                    "The subscription has failed.  Unless the failure is
                     in the connection establishing, i.e., connect
                     failed, there will be no automatic re-connect.";
                }
              }
              // NCS drop default statement
              description
                "Is this subscription currently running.";
            }
            leaf failure-reason {
              type enumeration {
                enum "connection-refused" {
                  description
                    "Failed to connect to the device.";
                }
                enum "connection-timeout" {
                  description
                    "Timeout when connecting to the device.";
                }
                enum "session" {
                  description
                    "Failed to establish session.";
                }
                enum "subscribe" {
                  description
                    "The device rejected our subscription attempt.";
                }
                enum "xml" {
                  tailf:code-name "notif-xml";
                  description
                    "NCS received XML that could not be parsed.";
                }
                enum "internal" {
                  description
                    "Internal NCS error.";
                }
                enum "disconnected" {
                  description
                    "Manually disconnected.";
                }
                enum "closed" {
                  tailf:code-name "notif-closed";
                  description
                    "Server closed its end.";
                }
                enum "locked" {
                  tailf:code-name "notif-locked";
                  value 9;
                  description
                    "No subscriptions allowed towards devices that are
                     locked or southbound locked.";
                }
                enum "auth-failed" {
                  value 10;
                  description
                    "Device authentication failed.";
                }
                enum "same-pass" {
                  tailf:code-name "notif-same-pass";
                  value 11;
                  description
                    "Subscription is not allowed when 'same-pass' option is
                     configured for authentication.";
                }
                enum "call-home" {
                  tailf:code-name "notif-call-home";
                  value 12;
                  description
                    "Subscription is not allowed until a call
                     home connection has been established.";
                }
                enum "read-only" {
                  tailf:code-name "notif-read-only";
                  value 13;
                  description
                    "Subscription is not allowed until read-only
                     mode is disabled and/or the mode of the HA node has
                     changed.";
                }
                enum "session-limit-exceeded" {
                  tailf:code-name "notif-session-limit-exceeded";
                  value 14;
                  description
                    "The session limit has been exceeded.";
                }
              }
              description
                "If there is a problem with this subscription
                 this leaf indicates what the problem is.";
              // NCS drop tailf:callpoint
            }
            leaf error-info {
              type string;
              description
                "Contains additional information, if available, when the
                 status is not equal to 'running'.";
              // NCS drop tailf:callpoint
            }
            tailf:action reconnect {
              tailf:actionpoint ncsproxy {
                tailf:internal;
              }
              tailf:info
                "Attempt to reconnect this subscription";
              description
                "Attempt to reconnect this subscription.";
              // NCS drop tailf:actionpoint
            }
            tailf:action disconnect {
              tailf:actionpoint ncsproxy {
                tailf:internal;
              }
              tailf:info
                "Disconnect this subscription if connected";
              description
                "Disconnect this subscription if connected.";
              // NCS drop tailf:actionpoint
            }
            tailf:action replay {
              tailf:actionpoint ncsproxy {
                tailf:internal;
              }
              tailf:info
                "Replay (missed) notifications from the device";
              description
                "Ask the device to replay all notifications for this
                 subscription.  Optionally if a timestamp is given, all
                 notifications newer than the provided timestamp are
                 requested.";
              // NCS drop tailf:actionpoint
              input {
                leaf from-date-time {
                  type yang:date-and-time;
                }
              }
            }
            // NCS drop must statement
          }
          list stream {
            key "name";
            description
              "A list of the notification streams provided by the device.
               NCS reads this list in realtime.";
            // NCS drop tailf:callpoint
            leaf name {
              type string;
              description
                "The name of the the stream.";
            }
            leaf description {
              type string;
              description
                "A textual description of the stream.";
            }
            leaf replay-support {
              type boolean;
              description
                "An indication of whether or not event replay
                 is available on this stream.";
            }
            leaf replay-log-creation-time {
              type yang:date-and-time;
              description
                "The timestamp of the creation of the log used to support
                 the replay function on this stream. Note that this might
                 be earlier then the earliest available notification in the
                 log. This object is updated if the log resets for some
                 reason.";
            }
            leaf replay-log-aged-time {
              type yang:date-and-time;
              description
                "The timestamp of the last notification aged out of the log.";
            }
          }
          list notification-name {
            key "name";
            description
              "List of all names of notifications defined by this device.";
            // NCS drop tailf:callpoint
            leaf name {
              type string;
              description
                "The XML tag of the notification name.";
            }
            leaf uri {
              type string;
              description
                "The XML namespace uri for this notification.";
            }
          }
          container received-notifications {
            leaf max-size {
              type int32;
              // NCS drop default statement
              description
                "Max size of the list of received notifications.
                 When the maximum size is reached, the oldest
                 received notification is purged.";
            }
            leaf clear-time {
              type yang:date-and-time;
              // NCS drop tailf:cdb-oper
              description
                "When were notifications last cleared.";
            }
            tailf:action clear {
              tailf:actionpoint ncsproxy {
                tailf:internal;
              }
              description
                "Delete all received notifications from the
                 'notification' list.";
              // NCS drop tailf:actionpoint
            }
            list notification {
              key "event-time sequence-no";
              description
                "A list of received notifications from the device.
                 The list is a circular list, with a maximum size.
                 When a new notification is added to the list, the oldest
                 entry is purged.";
              // NCS drop tailf:cdb-oper
              leaf event-time {
                type yang:date-and-time;
                description
                  "The time the event was generated at the device.";
              }
              leaf sequence-no {
                type int32;
              }
              leaf user {
                type string;
                description
                  "User name of the user that created the subscription
                   that made this notification end up here.";
              }
              leaf subscription {
                type string;
                description
                  "The name of the subscription that made this
                   notification end up here.";
                // NCS drop must statement
              }
              leaf stream {
                type string;
                description
                  "The name of the stream this notification belongs to.";
              }
              leaf received-time {
                type yang:date-and-time;
                description
                  "The time the event was received at NCS.";
              }
              container data {
                // NCS drop tailf:mount-point
                description
                  "This container is automatically augmented with notifications
                   from the managed device. Whenever a device module
                   that contains notifications is compiled, the device
                   specific notifications end up here, as a container
                   with the same name as the device notification.";
              }
            }
          }
        }
        leaf-list service-list {
          tailf:info
            "Show services that use this device";
          type string;
          description
            "A list of services that use this device.";
          // NCS drop tailf:callpoint
        }
      }
      container ned-ids {
        // NCS drop tailf:callpoint
        list ned-id {
          key "id";
          tailf:info
            "List installed NED ids";
          leaf id {
            // NCS patched to string, due to LSA partial NED
            type string;
          }
          list module {
            key "name";
            tailf:info
              "List YANG modules provided by the NED id";
            leaf name {
              type string;
              tailf:info
                "The module name";
            }
            leaf revision {
              type string;
              tailf:info
                "The module revision";
            }
            leaf namespace {
              type string;
              tailf:info
                "The module namespace";
            }
          }
        }
      }
      container commit-queue {
        tailf:info
          "List of queued and completed commits";
        // NCS drop tailf:display-groups
        // NCS drop tailf:cdb-oper
        tailf:action clear {
          tailf:actionpoint ncsproxy {
            tailf:internal;
          }
          description
            "Delete all items in the queue except locks taken by the system.
             This makes all queued devices in the commit queue out of sync.";
          tailf:info
            "Clear the entire queue";
          // NCS drop tailf:actionpoint
          output {
            leaf num-deleted-queue-items {
              type uint32;
            }
          }
        }
        tailf:action prune {
          tailf:actionpoint ncsproxy {
            tailf:internal;
          }
          description
            "Prune the portions of all queue items that contain
             any of the devices in the input. This is a useful action to
             run when a device has been taken off-line. When we do that
             we want to ensure that no queue item remain for that
             device, possibly blocking the queue. Devices which are
             currently being committed to will not be pruned, unless the
             'force' option is used. Atomic queue items will
             not be affected, unless all devices in it are pruned.";
          tailf:info
            "Prune portions of all queue items in the queue";
          // NCS drop tailf:actionpoint
          input {
            leaf-list device {
              type leafref {
                path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/device/name" {
                  tailf:xpath-root 3;
                }
              }
            }
            leaf force {
              type empty;
              description
                "Will brutally kill an ongoing commit. This could
                 leave the devices in a bad state. It is not recommended in
                 any normal use case.";
            }
          }
          output {
            leaf num-matched-queue-items {
              type uint32;
              description
                "Queue items that contained any of the devices in the input.";
            }
            leaf num-deleted-queue-items {
              type uint32;
              description
                "Queue items that were finally deleted because
                 nothing remained.";
            }
          }
        }
        tailf:action set-atomic-behaviour {
          tailf:actionpoint ncsproxy {
            tailf:internal;
          }
          description
            "Sets the atomic behaviour of all queue items.
             If these are set to false, the devices contained in these
             queue items can start executing if the same devices in
             other non-atomic queue items ahead of it in the queue are
             completed. If set to true, the atomic integrity of these
             queue items are preserved.";
          tailf:info
            "Set the atomic behaviour of all queue items";
          // NCS drop tailf:actionpoint
          input {
            leaf atomic {
              type boolean;
              mandatory true;
            }
          }
          output {
            leaf num-affected-queue-items {
              type uint32;
              description
                "Queue items that have changed atomic behaviour.";
            }
          }
        }
        tailf:action wait-until-empty {
          tailf:actionpoint ncsproxy {
            tailf:internal;
          }
          description
            "Wait at most 'timeout' seconds for the commit queue
             to become empty. Useful action when we script towards
             NCS, usually combined with locking NCS exclusively.

             If no parameter is given, the action waits indefinitely.";
          tailf:info
            "Wait for the commit queue to become empty";
          // NCS drop tailf:actionpoint
          input {
            choice timeout-choice {
              default "infinity";
              leaf timeout {
                type uint32 {
                  range "0..4294967";
                }
                units "seconds";
              }
              leaf infinity {
                type empty;
              }
            }
          }
          output {
            leaf result {
              type enumeration {
                enum "empty" {
                  description
                    "Returned if the queue is empty.";
                }
                enum "timeout" {
                  description
                    "Returned if the timer expired before the queue became
                     empty.";
                  tailf:code-name "wait_timeout";
                }
              }
            }
          }
        }
        tailf:action add-lock {
          tailf:actionpoint ncsproxy {
            tailf:internal;
          }
          description
            "Add a locked queue item to the commit queue.";
          tailf:info
            "Add a lock for devices in the queue";
          // NCS drop tailf:actionpoint
          input {
            leaf tag {
              type string;
              description
                "User defined opaque tag.
                 The tag is present in all notifications and events
                 sent referencing the specific queue item.";
            }
            // NCS expand uses statement
            choice operation-mode {
              leaf async {
                type empty;
                description
                  "Add the lock asynchronously to the commit queue";
              }
              container sync {
                presence "Commit through the commit queue and wait for completion";
                choice timeout-choice {
                  leaf timeout {
                    type uint32 {
                      range "0..4294967";
                    }
                    units "seconds";
                    description
                      "Specifies a maximum number of seconds to wait for the
                       transaction to be committed. If the timer expires, the
                       transaction is kept in the commit-queue, and the operation
                       returns successfully. The leaf 'commit-queue/status'
                       is set to 'timeout', and the leaf 'commit-queue/id' is
                       set to the queue identifier in the result.";
                  }
                  leaf infinity {
                    description
                      "Wait infinitely for the transaction to be committed.";
                    type empty;
                  }
                  default "infinity";
                }
                description
                  "Add the lock synchronously. Block until the lock
                   has been successfully placed in the commit queue and
                   no other queue items, using any of the devices, are
                   ahead in the queue.";
              }
              default "async";
            }
            leaf block-others {
              type empty;
              description
                "The lock will block other items, using any of the devices
                 in the lock, to enter the commit queue.";
            }
            leaf-list device {
              type string;
              tailf:non-strict-leafref {
                path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/device/name" {
                  tailf:xpath-root 3;
                }
              }
            }
          }
          output {
            leaf commit-queue-id {
              type uint64;
              description
                "The operation was successful, the lock is now in place.
                 To unlock the queue item see the action
                 /devices/commit-queue/queue-item/unlock.";
            }
            leaf result {
              type enumeration {
                enum "timeout" {
                  tailf:code-name "cq_add_lock_timeout";
                  description
                    "A timeout occurred, the lock is not in place, the
                     operation was not successful.";
                }
                enum "failed" {
                  tailf:code-name "cq_add_lock_failed";
                  description
                    "The queue item was manually unlocked or deleted, the
                     devices are not locked, the operation was not
                     successful";
                }
              }
            }
          }
        }
        list queue-item {
          // NCS drop tailf:display-groups
          tailf:info
            "An item in the commit queue";
          // NCS drop tailf:callpoint
          key "id";
          leaf id {
            type uint64;
            description
              "Unique id identifying a queue item.";
          }
          leaf tag {
            // NCS drop tailf:display-groups
            type string;
            description
              "Opaque string set at commit time. The 'tag' will be present in
               progress events sent about a queue item.";
          }
          leaf age {
            // NCS drop tailf:display-groups
            type uint32;
            units "seconds";
            description
              "The age in seconds of this queue item. How long time
               has this item been in the queue.";
          }
          uses live_ncs_queue-item-status;
          leaf-list devices {
            // NCS drop tailf:display-groups
            type leafref {
              path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/device/name" {
                tailf:xpath-root 3;
              }
            }
            description
              "The names of the devices that are part of this queue
               item.";
          }
          leaf-list services {
            // NCS drop tailf:display-groups
            description
              "The service instances that are part of this queue item.";
            type string;
          }
          leaf-list waiting-for {
            // NCS drop tailf:display-groups
            type leafref {
              path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/device/name" {
                tailf:xpath-root 3;
              }
            }
            description
              "If this queue item's status is 'waiting', 'blocked' or
               'locked', this leaf-list contains the devices the queue
               item is waiting for in order to execute.";
          }
          leaf-list transient-errors {
            // NCS drop tailf:display-groups
            type leafref {
              path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/device/name" {
                tailf:xpath-root 3;
              }
            }
            description
              "This leaf-list contains devices with transient errors,
               e.g., connection problems or a locked device.  These
               devices can possibly block other queue items from being
               processed.";
          }
          leaf-list completed {
            // NCS drop tailf:display-groups
            type leafref {
              path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/device/name" {
                tailf:xpath-root 3;
              }
            }
            description
              "The devices which were completed for this queue item.
               A device is completed when its device modifications
               are pushed to the network.";
          }
          list failed {
            // NCS drop tailf:display-groups
            tailf:code-name "failedx";
            key "name";
            leaf name {
              type leafref {
                path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/device/name" {
                  tailf:xpath-root 3;
                }
              }
            }
            leaf reason {
              // NCS drop tailf:display-groups
              type string;
              description
                "The error for this failing device.";
            }
            description
              "The devices which are failed for this queue item.";
          }
          list remote-queue-item {
            // NCS drop tailf:display-groups
            key "device";
            leaf device {
              type leafref {
                path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/device/name" {
                  tailf:xpath-root 3;
                }
              }
              description
                "Parts of the queue-item has been distributed to this
                 NSO device. This is only present when using LSA.";
            }
            leaf id {
              // NCS drop tailf:display-groups
              type uint64;
              description
                "The id of the queue-item on the NSO device.";
            }
          }
          leaf is-atomic {
            // NCS drop tailf:display-groups
            type boolean;
            description
              "Whether the queue item runs atomic or not.";
          }
          list modification {
            // NCS drop tailf:display-groups
            key "device";
            description
              "A detailed view of the queued modifications.";
            leaf device {
              type leafref {
                path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/device/name" {
                  tailf:xpath-root 3;
                }
              }
              description
                "Name of the device.";
            }
            leaf data {
              // NCS drop tailf:display-groups
              type string;
              description
                "Textual description of data queued to be sent.";
              tailf:cli-preformatted;
            }
            leaf local-user {
              // NCS drop tailf:display-groups
              type string;
              description
                "Name of local NCS user that commited this data.";
            }
          }
          tailf:action delete {
            tailf:actionpoint ncsproxy {
              tailf:internal;
            }
            description
              "Delete this queue item. This will make the devices out-of-sync
               with NCS since the devices will never receive the configuration
               changes committed to NCS. Any error-option set for the queue item
               will also be disregarded. Locks taken by the system will not be
               deleted by default, unless pending (not yet granted).";
            tailf:info
              "Delete this queue item";
            // NCS drop tailf:actionpoint
            input {
              leaf force {
                type empty;
                description
                  "Will brutally kill an ongoing commit. This could
                   leave the devices in a bad state. If used on a sentinel,
                   it allows to delete a lock taken by the system, however
                   deleting such a lock will result in unpredictable behaviour
                   since actions that are normally not allowed to run in
                   parallel will be able to do that.
                   It is not recommended in any normal use case.";
              }
            }
          }
          tailf:action lock {
            tailf:actionpoint ncsproxy {
              tailf:internal;
            }
            description
              "Put a lock on this queue item. This can only be performed
               when the queue item has status 'waiting' or 'blocked'.
               A lock can also be placed on a queue-item at commit time
               through the commit parameter 'commit-queue/lock'.";
            // NCS drop tailf:actionpoint
          }
          tailf:action unlock {
            tailf:actionpoint ncsproxy {
              tailf:internal;
            }
            description
              "Unlock this queue item. For a queue item with status 'locked'
               the status will change to 'waiting', for all other statuses this
               action is ignored.";
            // NCS drop tailf:actionpoint
            input {
              // NCS drop fully hidden leaf atomic
            }
          }
          tailf:action prune {
            tailf:actionpoint ncsproxy {
              tailf:internal;
            }
            description
              "Prune a queue item that contain any of the devices in
               the input. The devices will be removed from the queue item.
               If no devices remain, the queue item will be deleted.
               If the queue item was part of a service transaction the
               service will be flagged as failed. Devices which are
               currently being committed to will not be pruned, unless
               the 'force' option is used. Atomic queue items will
               not be affected, unless all devices in it are pruned.";
            tailf:info
              "Prune a queue item";
            // NCS drop tailf:actionpoint
            input {
              leaf-list device {
                type leafref {
                  path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/device/name" {
                    tailf:xpath-root 3;
                  }
                }
              }
              leaf force {
                type empty;
                description
                  "Will brutally kill an ongoing commit. This could
                   leave the devices in a bad state. It is not recommended
                   in any normal use case.";
              }
            }
          }
          tailf:action set-atomic-behaviour {
            tailf:actionpoint ncsproxy {
              tailf:internal;
            }
            description
              "Sets the atomic behaviour of this queue item.
               If this is set to false, the devices contained in this
               queue item can start executing if the same devices in
               other non-atomic queue items ahead of it in the queue are
               completed. If set to true, the atomic integrity of the
               queue item is preserved.";
            tailf:info
              "Set the atomic behaviour of this queue item";
            // NCS drop tailf:actionpoint
            input {
              leaf atomic {
                type boolean;
                mandatory true;
              }
            }
          }
          tailf:action retry {
            tailf:actionpoint ncsproxy {
              tailf:internal;
            }
            description
              "Retry devices with transient errors instead of waiting
               for the automatic retry attempt.";
            tailf:info
              "Retry devices with transient errors";
            // NCS drop tailf:actionpoint
            input {
              leaf-list device {
                type leafref {
                  path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/device/name" {
                    tailf:xpath-root 3;
                  }
                }
              }
            }
          }
          tailf:action wait-until-completed {
            tailf:actionpoint ncsproxy {
              tailf:internal;
            }
            description
              "Wait at most 'timeout' seconds for the queue item
               to be completed. Useful action when we script towards NCS.

               If no parameter is given, the action waits indefinitely.";
            tailf:info
              "Wait for the queue item to be completed";
            // NCS drop tailf:actionpoint
            input {
              choice timeout-choice {
                default "infinity";
                leaf timeout {
                  type uint32 {
                    range "0..4294967";
                  }
                  units "seconds";
                }
                leaf infinity {
                  type empty;
                }
              }
            }
            output {
              leaf result {
                type enumeration {
                  enum "completed" {
                    description
                      "The queue item was successfully completed.";
                    tailf:code-name "wait_cq_completed";
                  }
                  enum "timeout" {
                    description
                      "The timer expired before the queue item was completed.";
                    tailf:code-name "wait_cq_timeout";
                  }
                  enum "failed" {
                    description
                      "The queue item failed.";
                    tailf:code-name "wait_cq_failed";
                  }
                  enum "deleted" {
                    description
                      "The queue item was deleted from the queue.";
                    tailf:code-name "wait_cq_deleted";
                  }
                }
              }
            }
          }
        }
        container completed {
          tailf:info
            "List of completed commits";
          // NCS drop tailf:display-groups
          tailf:action purge {
            tailf:actionpoint ncsproxy {
              tailf:internal;
            }
            tailf:info
              "Remove completed queue items";
            // NCS drop tailf:actionpoint
            description
              "This action requests to delete items from the queue-item
               list according to the supplied criteria.";
            input {
              uses live_ncs_commit-queue-item-status;
              container older-than {
                presence "Age specification";
                description
                  "Matches the 'when' leaf in the queue item.";
                choice age-spec {
                  case seconds {
                    leaf seconds {
                      type uint16;
                    }
                  }
                  case minutes {
                    leaf minutes {
                      type uint16;
                    }
                  }
                  case hours {
                    leaf hours {
                      type uint16;
                    }
                  }
                  case days {
                    leaf days {
                      type uint16;
                    }
                  }
                  case weeks {
                    leaf weeks {
                      type uint16;
                    }
                  }
                }
              }
            }
            output {
              leaf num-deleted-queue-items {
                type uint32;
                description
                  "Queue items that were deleted.";
              }
            }
          }
          list queue-item {
            // NCS drop tailf:display-groups
            tailf:info
              "A completed item from the commit queue";
            key "id";
            leaf id {
              type uint64;
              description
                "Unique id identifying a queue item.";
            }
            leaf tag {
              // NCS drop tailf:display-groups
              type string;
              description
                "Opaque string set at commit time.";
            }
            leaf when {
              // NCS drop tailf:display-groups
              type yang:date-and-time;
              description
                "When the queue item was completed.";
            }
            uses live_ncs_commit-queue-item-status;
            leaf-list devices {
              // NCS drop tailf:display-groups
              type string;
              tailf:non-strict-leafref {
                path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/device/name" {
                  tailf:xpath-root 3;
                }
              }
              description
                "The names of the devices that was part of this queue
                 item.";
            }
            leaf-list completed {
              // NCS drop tailf:display-groups
              type string;
              tailf:non-strict-leafref {
                path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/device/name" {
                  tailf:xpath-root 3;
                }
              }
              description
                "The devices which were completed for this queue item.
                 A device is completed when its device modifications
                 are pushed to the network.";
            }
            list failed {
              // NCS drop tailf:display-groups
              tailf:code-name "failedx";
              key "name";
              leaf name {
                type string;
                tailf:non-strict-leafref {
                  path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/device/name" {
                    tailf:xpath-root 3;
                  }
                }
              }
              leaf reason {
                // NCS drop tailf:display-groups
                type string;
                description
                  "The error for this failing device.";
              }
              description
                "The devices which failed for this queue item.";
            }
            leaf-list completed-services {
              // NCS drop tailf:display-groups
              description
                "The services that have been completed. A service has
                 completed if all its device modifications have been
                 successfully completed.";
              type string;
            }
            leaf-list failed-services {
              // NCS drop tailf:display-groups
              description
                "The services that have failed. A service has failed
                 if any of its device modifications have failed.";
              type string;
            }
            list remote-queue-item {
              // NCS drop tailf:display-groups
              key "device";
              leaf device {
                type string;
                tailf:non-strict-leafref {
                  path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/device/name" {
                    tailf:xpath-root 3;
                  }
                }
                description
                  "Parts of the queue-item has been distributed to this
                   NSO device. This is only present when using LSA.";
              }
              leaf id {
                // NCS drop tailf:display-groups
                type uint64;
                description
                  "The id of the queue-item used on the NSO device.";
              }
            }
            // NCS drop fully hidden leaf 'reverse-chgset'
            leaf rollback-data {
              // NCS drop tailf:display-groups
              tailf:cli-preformatted;
              // NCS drop tailf:callpoint
              description
                "The reverse of the original configuration data which
                 resulted in this commit queue item.";
              type string;
            }
            tailf:action rollback {
              tailf:actionpoint ncsproxy {
                tailf:internal;
              }
              tailf:display-when "../reverse-chgset" {
                tailf:xpath-root 3;
              }
              // NCS drop tailf:actionpoint
              description
                "Rollback the original configuration data. This is the
                 reverse of the output of original-data.";
              input {
                container dry-run {
                  presence "";
                  leaf outformat {
                    type live_ncs_outformat3;
                  }
                }
                leaf no-out-of-sync-check {
                  type empty;
                  description
                    "Continue with the transaction even if NCS detects that
                     a device's configuration is out of sync. The device's
                     sync state is assumed to be unknown after such commit
                     and the stored transaction id value is cleared";
                }
                container commit-queue {
                  presence "Commit through the commit queue";
                  uses live_ncs_commit-queue-options;
                }
              }
              output {
                choice outformat {
                  case case-xml {
                    uses live_ncs_dry-run-xml;
                  }
                  case case-cli {
                    uses live_ncs_dry-run-cli;
                  }
                  case case-native {
                    uses live_ncs_dry-run-native;
                  }
                }
                uses live_ncs_ncs-commit-result;
              }
            }
            tailf:action delete {
              tailf:actionpoint ncsproxy {
                tailf:internal;
              }
              // NCS drop tailf:actionpoint
              description
                "Delete this queue item.";
            }
          }
        }
        // NCS drop fully hidden list 'device-chgset'
        // NCS drop fully hidden list qitem
      }
      container session-pool {
        tailf:info
          "List of pooled NED sessions";
        // NCS drop tailf:display-groups
        tailf:action close {
          tailf:actionpoint ncsproxy {
            tailf:internal;
          }
          description
            "Close all sessions in the session pool.";
          tailf:info
            "Close all sessions in the session pool";
          // NCS drop tailf:actionpoint
        }
        list pooled-device {
          // NCS drop tailf:display-groups
          tailf:info
            "A pooled device in the session pool";
          // NCS drop tailf:callpoint
          key "device";
          leaf device {
            type leafref {
              path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/devices/device/name" {
                tailf:xpath-root 3;
              }
            }
            description
              "Name of the device.";
          }
          leaf device-type {
            type string;
            description
              "Device type";
          }
          leaf sessions {
            type uint32;
            description
              "Number of pooled sessions";
          }
          leaf max-sessions {
            type string;
            description
              "Max sessions in pool for this device.";
          }
          leaf idle-time {
            type uint32;
            description
              "The maximum idle-time for sessions in pool for this device.";
          }
          tailf:action close {
            tailf:actionpoint ncsproxy {
              tailf:internal;
            }
            description
              "Close all pooled sessions in the session pool
               for this device.";
            tailf:info
              "Close pooled sessions for this device";
            // NCS drop tailf:actionpoint
          }
        }
      }
    }
  }
  augment "/ncs-internal:devices/ncs-internal:template/ncs-internal:ned-id/ncs-internal:config" {
    container devices {
      uses ncs_template_connect-grouping-extended;
      uses ncs_template_sync-to-grouping-extended;
      uses ncs_template_sync-from-grouping-extended;
      uses ncs_template_disconnect-grouping-extended;
      uses ncs_template_check-sync-grouping-extended;
      uses ncs_template_check-yang-modules-grouping-extended;
      uses ncs_template_fetch-ssh-host-keys-grouping-extended;
      uses ncs_template_migrate-grouping-extended;
      uses ncs_template_apply-template-grouping-extended;

      grouping timeouts {
        description
          "Timeouts used when communicating with a managed device.";
        leaf connect-timeout {
          type string;
          units "seconds";
          description
            "The timeout in seconds for new connections to managed
             devices.";
        }
        leaf read-timeout {
          type string;
          units "seconds";
          description
            "The timeout in seconds used when reading data from a
             managed device.";
        }
        leaf write-timeout {
          type string;
          units "seconds";
          description
            "The timeout in seconds used when writing data to a
             managed device.";
        }
      }

      grouping device-profile-parameters {
        description
          "A set of parameters to use when communicating with a device.

           These parameters can be set on:

             o  global-settings
             o  device-profile
             o  device

           If a parameter is set on the device, its value is used.
           Otherwise, if the paramater is set in the device's
           device-profile, its value is used.  Otherwise, the global
           setting is used, if set.  Otherwise, the value used depends on
           the NED type.";
        uses timeouts;
        // NCS expand uses statement
        choice wait-for-lock-choice {
          leaf no-wait-for-lock {
            type empty;
            description
              "The action can't be performed while the device is being
               committed to (or waiting in the commit queue). This is to avoid
               getting inconsistent data when reading the configuration.
               This specifies that the action should not wait for device lock,
               instead, it should immediately fail if the device is being locked.";
          }
          container wait-for-lock {
            presence "Wait for device lock.";
            description
              "The action can't be performed while the device is being
               committed to (or waiting in the commit queue). This is to avoid
               getting inconsistent data when reading the configuration.
               This specifies a timeout to wait for a device lock to be placed
               in the commit queue. The lock will be automatically released once
               the action has been executed.";
            choice timeout-choice {
              // NCS drop default statement
              leaf timeout {
                type string;
                units "seconds";
                description
                  "Specifies a maximum number of seconds to wait for the
                   device to be locked.";
              }
              leaf infinity {
                description
                  "Wait infinitely for the lock, this is the default.";
                type empty;
              }
            }
          }
          description
            "When an action accepting the wait-for-lock parameter is
             called without providing the wait-for-lock parameter, the
             wait-for-lock-choice device setting is going to be used.";
        }
        container ssh-keep-alive {
          description
            "Controls SSH keep alive settings when communicating from this
             node to devices.";
          leaf interval {
            type string;
            units "seconds";
            description
              "Seconds between SSH keep alive activity.";
          }
          leaf count {
            type string;
            description
              "Number of intervals to fail before failing the connection.";
          }
        }
        container ssh-algorithms {
          description
            "Supported (allowed) algorithms that should be used during
             SSH algorithm negotiations.";
          uses ncs_template_ssh-algorithms;
        }
        container ned-keep-alive {
          description
            "Controls NED keep alive settings when communicating from this
             node to devices. The keep alive settings can be configured for
             NSO to periodically perform activity to keep the session open.
             This is useful when for example CLI sessions have low idle timeouts.
             These settings only take effect if the NED actually implements
             this callback.";
          leaf interval {
            type string;
            units "seconds";
            description
              "Seconds between NED keep alive activity.";
          }
          leaf count {
            type string;
            description
              "Number of intervals to fail before failing the connection.";
          }
        }
        container connect-retries {
          description
            "Settings for how to retry connecting if the device returns
             a transient failure.";
          leaf attempts {
            type string;
            description
              "Number of attempts to retry the connect before giving up.

               Setting this to 0 means that the connect fails
               immediately if the device returns a failure.";
          }
          leaf timeout {
            type string;
            units "seconds";
            description
              "Specifies the timeout in seconds between retries.";
          }
        }
        leaf trace {
          type ncs_template_trace-flag;
          description
            "Controls southbound traffic trace to managed devices.";
        }
        leaf trace-output {
          type ncs_template_trace-output;
          description
            "Controls how trace data is stored.";
        }
        container ned-settings {
          description
            "When communicating with a device, NCS adapts its behavior
             to the capabilities of the device.  When writing to the device,
             NCS uses the capabilities that give most control, and minimal
             risk of network inconsistencies.  The parameters in this
             container can be used to tweak NCS's behavior.  These parameters
             must be used with care.";
          leaf use-confirmed-commit {
            type string;
            description
              "Controls if NCS should use confirmed commit towards the
               device.  This setting has no effect if the device does
               not advertise support for confirmed-commit.

               If no value is configured, the default depends on the NED
               type.  The NETCONF NED by default uses confirmed commit if
               it is advertised.";
          }
          leaf use-validate {
            type string;
            description
              "Controls if NCS should use explicit validation towards the
               device.  This setting has no effect if the device does
               not advertise support for validate.

               It can be useful to disable validate in order to increase
               performance, since when validate is used, the device must
               validate the changes twice; at validate, and at commit.

               The advantage of using validate is that if the changes are
               sent to N devices, and validated on all of them, if one
               device fails the validation step, nothing has been committed
               to any device, and the transaction can easily be aborted.

               Without validate, NCS will commit on all N devices, and if
               one fails the commit due to a validation error, NCS has
               to undo the changes on the other devices.

               If no value is configured, the default depends on the NED
               type.  The NETCONF NED by default uses validate if
               it is advertised.";
          }
          leaf use-startup {
            type string;
            description
              "Controls if NCS should invoke the copy-running-to-startup
               operation towards the device.  This setting has no effect
               if the device does not advertise support for startup.

               It can be useful to disable this operation in order to
               increase performance, in the case that this is an
               expensive operation on the device.  It should be noted
               that in this case, the device will not have all changes
               persistently stored.  This can be combined with a job
               that performs this operation periodically, e.g., once an
               hour.

               If no value is configured, the default depends on the NED
               type.  The NETCONF NED by default uses startup if
               it is advertised.";
          }
          leaf use-transaction-id {
            type string;
            description
              "For some devices, getting the transaction id can be a costly
               operation.  If it is disabled, NCS will not be able to
               detect situations where NCS and the device are out of
               sync.

               If no value is configured, the default depends on the NED
               type.  The NETCONF NED by default reads the transaction id,
               if it knows how to get it from the device.";
          }
          leaf use-private-candidate {
            type string;
            description
              "If the device supports the concept of a private
               candidate, NCS can use it instead of the normal, shared
               candidate.

               This option can be useful if there are other management
               applications other than NCS configuring the devices, and
               these other applications also use private candidates.

               If no value is configured, the default depends on the NED
               type.  The NETCONF NED by default does not use a private
               candidate.  For NETCONF, this option currently has effect
               only for Juniper devices running Junos.";
          }
          leaf use-junos-rollback {
            type string;
            description
              "Use the latest rollback instead of computing and sending a reverse
               diff when other device in the transaction has failed in commit and
               the configuration on successful devices needs to be reverted.

               Using rollback involves less communication overhead with the
               device but the rollback functionality might not be supported by
               all device software versions.

               This option has effect only for Juniper devices running Junos.";
          }
        }
        container commit-queue {
          leaf enabled-by-default {
            type string;
            description
              "If this leaf is set, all commits for this device will by
               default go through the commit queue.";
          }
        }
        container session-limits {
          leaf max-sessions {
            type string;
            description
              "Puts a limit to the total number of concurrent sessions
               allowed for the device. The label 'unlimited' implies that no
               upper limit exists for this device.";
          }
        }
        container session-pool {
          description
            "NCS uses NED sessions when performing transactions, actions
             etc towards a device. When such a task is completed the NED
             session can either be closed or pooled.

             Pooling a NED session means that the session to the
             device is kept open for a configurable amount of
             time. During this time the session can be re-used for a new
             task. Thus the pooling concept exists to reduce the number
             of new connections needed towards a device that is often
             used.

             By default NCS uses pooling for all device types except
             SNMP. Normally there is no need to change the default
             values.";
          leaf max-sessions {
            type string;
            description
              "Controls the maximum number of open sessions in the pool for
               a specific device. When this threshold is exceeded the oldest
               session in the pool will be closed.
               A Zero value will imply that pooling is disabled for
               this specific device. The label 'unlimited' implies that no
               upper limit exists for this specific device";
          }
          leaf idle-time {
            type string;
            units "seconds";
            description
              "The maximum time that a session is kept open in the pool.
               If the session is not requested and used before the
               idle-time has expired, the session is closed.
               If no idle-time is set the default is 30 seconds.";
          }
        }
        container no-overwrite {
          leaf enabled-by-default {
            type string;
            description
              "If this leaf is set, all commits for this device will by
               default make a no-overwrite sync check.";
          }
        }
        container lsa {
          description
            "Control settings that apply to the communication between this node
             and the LSA node the setting applies to. These settings do not
             propagate further in the LSA cluster and are ignored if set on a
             device that is not an LSA node.";
          container no-overwrite {
            description
              "Control settings for no-overwrite sync check between
               nodes in LSA cluster";
            leaf enabled-by-default {
              type string;
              description
                "If this leaf is set, all commits for this LSA node will by
                 default make a no-overwrite sync check.";
            }
          }
        }
        leaf out-of-sync-commit-behaviour {
          type string;
          description
            "Specifies the behaviour of a commit operation involving a
             device that is out of sync with NCS. Value accept assumes that
             the device's sync state is unknown and it is cleared on commit.
             The default behaviour is to reject such commits.";
        }
        choice choice-lsa {
          leaf use-lsa {
            type empty;
            description
              "Handle the LSA nodes as such. This is the default.";
          }
          leaf no-lsa {
            type empty;
            description
              "Do not handle any of the LSA nodes as such. These nodes
               will be handled as any other device. This has the same
               result as adding the commit flag 'no-lsa' to every commit.";
          }
          // NCS drop default statement
        }
      }

      grouping capability-module-grouping {
        list capability {
          // NCS patched for predictable order
          ordered-by user;
          key "uri";
          leaf uri {
            type string;
          }
          leaf revision {
            type string;
          }
          leaf module {
            type string;
          }
          leaf-list feature {
            // NCS patched for predictable order
            ordered-by user;
            type string;
          }
          leaf-list deviation {
            // NCS patched for predictable order
            ordered-by user;
            type string;
          }
        }
        list module {
          // NCS patched for predictable order
          ordered-by user;
          key "name";
          leaf name {
            type string;
          }
          leaf revision {
            type string;
          }
          leaf-list feature {
            // NCS patched for predictable order
            ordered-by user;
            type string;
          }
          leaf-list deviation {
            // NCS patched for predictable order
            ordered-by user;
            type string;
          }
        }
      }
      container global-settings {
        description
          "Global settings for all managed devices. Some of these
           settings can be overridden per managed device.";
        uses device-profile-parameters {
          refine "wait-for-lock-choice" {
            description
              "By default all actions accepting the wait-for-lock parameter will
               not wait for lock if the wait-for-lock parameter was not given.";
            // NCS drop default statement
          }
          refine "connect-timeout" {
            // NCS drop default statement
          }
          refine "read-timeout" {
            // NCS drop default statement
          }
          refine "write-timeout" {
            // NCS drop default statement
          }
          refine "ssh-keep-alive/interval" {
            // NCS drop default statement
          }
          refine "ssh-keep-alive/count" {
            // NCS drop default statement
          }
          refine "ssh-algorithms/public-key" {
            // NCS drop default statement
            // NCS drop default statement
            // NCS drop default statement
            // NCS drop default statement
            // NCS drop default statement
            // NCS drop default statement
          }
          refine "ssh-algorithms/kex" {
            // NCS drop default statement
            // NCS drop default statement
            // NCS drop default statement
            // NCS drop default statement
            // NCS drop default statement
            // NCS drop default statement
            // NCS drop default statement
            // NCS drop default statement
            // NCS drop default statement
            // NCS drop default statement
          }
          refine "ssh-algorithms/mac" {
            // NCS drop default statement
            // NCS drop default statement
            // NCS drop default statement
            // NCS drop default statement
            // NCS drop default statement
            // NCS drop default statement
            // NCS drop default statement
          }
          refine "ssh-algorithms/cipher" {
            // NCS drop default statement
            // NCS drop default statement
            // NCS drop default statement
            // NCS drop default statement
            // NCS drop default statement
            // NCS drop default statement
            // NCS drop default statement
            // NCS drop default statement
          }
          refine "ssh-algorithms/compression" {
            // NCS drop default statement
            // NCS drop default statement
            // NCS drop default statement
          }
          refine "ssh-algorithms/dh-group/min-size" {
            // NCS drop default statement
          }
          refine "ssh-algorithms/dh-group/preferred-size" {
            // NCS drop default statement
          }
          refine "ssh-algorithms/dh-group/max-size" {
            // NCS drop default statement
          }
          refine "ned-keep-alive/count" {
            // NCS drop default statement
          }
          refine "connect-retries/attempts" {
            // NCS drop default statement
          }
          refine "connect-retries/timeout" {
            // NCS drop default statement
          }
          refine "trace" {
            // NCS drop default statement
          }
          refine "trace-output" {
            // NCS drop default statement
          }
          refine "ned-settings/use-junos-rollback" {
            // NCS drop default statement
          }
          refine "no-overwrite/enabled-by-default" {
            // NCS drop default statement
          }
          refine "lsa/no-overwrite/enabled-by-default" {
            // NCS drop default statement
          }
          refine "out-of-sync-commit-behaviour" {
            // NCS drop default statement
          }
          refine "session-limits/max-sessions" {
            // NCS drop default statement
          }
          augment "session-limits" {
            description
              "Parameters for limiting concurrent access to devices.";
            container connect-rate {
              leaf burst {
                type string;
                // NCS drop default statement
                description
                  "The number of concurrent connect attempts allowed.
                   For example, the devices managed by NSO talk to the same
                   server for authentication which can only handle a limited
                   number of connections at a time. Then we can limit
                   the concurrency of connect attempts with this setting.";
              }
            }
            leaf max-wait-time {
              type string;
              units "seconds";
              // NCS drop default statement
              description
                "Max time in seconds to wait for a device being available
                 to connect. When the maximum time is reached an error
                 is returned. Setting this to 0 means that the error is
                 returned immediately.";
            }
          }
          refine "session-pool/idle-time" {
            // NCS drop default statement
          }
          augment "session-pool" {
            leaf pool-max-sessions {
              type string;
              // NCS drop default statement
              description
                "Controls the grand total session count in the pool.
                 Independently on how different devices are pooled the grand
                 total session count can never exceed this value.
                 A zero value will imply that pooling is disabled for all devices.
                 The value 'unlimited' implies that no upper limit exists for
                 the number open sessions in the pool";
            }
          }
          refine "commit-queue/enabled-by-default" {
            // NCS drop default statement
          }
          augment "commit-queue" {
            // NCS expand uses statement
            choice operation-mode {
              leaf async {
                type empty;
                description
                  "Commit the transaction data asynchronously to the commit queue.
                   This flag is useful when some device is non-operational or
                   has data waiting in the commit queue.

                   The operation returns successfully if the transaction data has
                   been successfully placed in the queue. The leaf
                   'commit-queue/id' is set as the queue identifier and the
                   leaf 'commit-queue/status' is set to 'async' in the result.";
              }
              container sync {
                presence "Commit through the commit queue and wait for completion";
                description
                  "Commit the transaction data synchronously to the commit queue.

                   The operation does not return until the transaction data has
                   been sent to all devices, or a timeout occurs. The leaf
                   'commit-queue/id' is set as the queue identifier and the
                   leaf 'commit-queue/status' is set to 'completed', 'failed',
                   'deleted' or 'timeout' dependent of the outcome.

                   If no device is involved in the transaction, the operation
                   returns directly.";
                choice timeout-choice {
                  leaf timeout {
                    type string;
                    units "seconds";
                    description
                      "Specifies a maximum number of seconds to wait for the
                       transaction to be committed. If the timer expires, the
                       transaction is kept in the commit-queue, and the operation
                       returns successfully. The leaf 'commit-queue/status'
                       is set to 'timeout', and the leaf 'commit-queue/id' is
                       set to the queue identifier in the result.";
                  }
                  leaf infinity {
                    description
                      "Wait infinitely for the transaction to be committed.";
                    type empty;
                  }
                  // NCS drop default statement
                }
              }
              // NCS drop default statement
            }
            leaf atomic {
              type string;
              // NCS drop default statement
              description
                "This leaf sets the atomic behaviour of all new queue items
                 in the commit queue. If these are set to false, the devices
                 contained in these queue items can start executing if the
                 same devices in other non-atomic queue items ahead of it
                 in the queue are completed. If set to true, the atomic
                 integrity of these queue items are preserved.";
            }
            leaf retry-attempts {
              type string;
              // NCS drop default statement
              description
                "Number of attempts to process the device in
                 the queue item if it returns a transient error.
                 For example, if NCS fails to connect to the device
                 or take a lock on it.

                 Setting this to 0 means that the queue item fails
                 immediately even on transient errors.";
            }
            leaf retry-timeout {
              type string;
              units "seconds";
              // NCS drop default statement
              description
                "Specifies the timeout in seconds between retries.
                 This is not applicable for devices where
                 /devices/device/state/admin-state = 'call-home'.
                 These devices will wait until a TCP connection
                 is established from the NETCONF server.";
            }
            leaf check-integrity {
              type string;
              // NCS drop default statement
              description
                "To guarantee service integrity NCS checks for
                 overlapping service or device modifications when committing
                 with the commit queue. These checks can be bypassed by
                 setting the leaf to false. This could potentially
                 commit changes that are not deployed to the network if a
                 queue item with overlapping data failed ahead in the
                 queue. The benefit of doing so is increased throughput.";
            }
            leaf error-option {
              type string;
              // NCS drop default statement
              description
                "The error option to use. Depending on the selected error option
                 NCS will store the reverse of the original transaction intent
                 to be able to undo the transaction changes and get back to the
                 previous state. This data is stored in the
                 /devices/device/commit-queue/completed tree from where it can
                 be viewed and invoked with the rollback action. When invoked
                 the data will be removed.";
            }
          }
        }
        container commit-retries {
          description
            "Settings for how to retry commits if some device returns
             a transient error. For example, if NCS fails to take a
             lock on a device, it can retry after a short time.";
          leaf attempts {
            type string;
            // NCS drop default statement
            description
              "Number of attempts to retry the commit before giving up.

               Setting this to 0 means that the transaction fails
               immediately even on transient errors.";
          }
          leaf timeout {
            type string;
            units "seconds";
            // NCS drop default statement
            description
              "Specifies the timeout in seconds between retries.";
          }
        }
        leaf trace-dir {
          type string;
          // NCS drop default statement
          description
            "Specifies the directory where southbound traffic trace log files
             to managed devices are stored.

             The trace files are called <type>-<device-name>.trace
             where <type> is one of 'netconf', 'snmp', or 'ned', depending on
             the type of the managed device.";
        }
        leaf report-multiple-errors {
          type string;
          // NCS drop default statement
          description
            "By default, when the NCS device manager commits data
             southbound and when there are errors, we only report
             the first error to the operator, this flag makes NCS
             report all errors reported by managed devices";
        }
      }
      container profiles {
        list profile {
          // NCS patched for predictable order
          ordered-by user;
          key "name";
          leaf name {
            type string;
          }
          uses device-profile-parameters;
        }
        list capabilities-profile {
          // NCS patched for predictable order
          ordered-by user;
          key "name";
          leaf name {
            type string;
          }
          uses capability-module-grouping;
        }
      }
      container authgroups {
        description
          "Named authgroups are used to decide how to map a local NCS user to
           remote authentication credentials on a managed device.

           The list 'group' is used for NETCONF and CLI managed devices.

           The list 'snmp-group' is used for SNMP managed devices.";
        list group {
          // NCS patched for predictable order
          ordered-by user;
          key "name";
          description
            "When NCS connects to a managed device, it locates the
             authgroup configured for that device.  Then NCS looks up
             the local NCS user name in the 'umap' list.  If an entry is
             found, the credentials configured is used when
             authenticating to the managed device.

             If no entry is found in the 'umap' list, the credentials
             configured in 'default-map' are used.

             If no 'default-map' has been configured, and the local NCS
             user name is not found in the 'umap' list, the connection
             to the managed device fails.";

          grouping remote-user-remote-auth {
            description
              "Remote authentication credentials.";
            choice login-credentials {
              // NCS drop mandatory statement
              case stored {
                choice remote-user {
                  // NCS drop mandatory statement
                  leaf same-user {
                    type empty;
                    description
                      "If this leaf exists, the name of the local NCS user is used
                       as the remote user name.";
                  }
                  leaf remote-name {
                    type string;
                    description
                      "Remote user name.";
                  }
                }
                choice remote-auth {
                  // NCS drop mandatory statement
                  leaf same-pass {
                    type empty;
                    description
                      "If this leaf exists, the password used by the local user
                       when logging in to NCS is used as the remote password.";
                  }
                  leaf remote-password {
                    type string;
                    description
                      "Remote password.";
                  }
                  case public-key {
                    uses ncs_template_public-key-auth;
                  }
                }
                choice remote-secondary-auth {
                  leaf same-secondary-password {
                    type empty;
                    description
                      "If this leaf exists, the password used by the local user
                       when logging in to NCS is used as the remote secondary
                       password.";
                  }
                  leaf remote-secondary-password {
                    type string;
                    description
                      "Some CLI based devices require a second
                       additional password to enter config mode";
                  }
                }
              }
              case callback {
                leaf callback-node {
                  description
                    "Invoke a standalone action to retrieve login credentials for
                     managed devices on the 'callback-node' instance.

                     The 'action-name' action is invoked on the callback node that
                     is specified by an instance identifer.";
                  // NCS drop mandatory statement
                  type string;
                }
                leaf action-name {
                  description
                    "The action to call when a notification is received.

                     The action must use 'authgroup-callback-input-params'
                     grouping for input and 'authgroup-callback-output-params'
                     grouping for output from tailf-ncs-devices.yang.";
                  type string;
                  // NCS drop mandatory statement
                }
              }
            }
          }
          leaf name {
            type string;
            description
              "The name of the authgroup.";
          }
          container default-map {
            presence "Map unknown users";
            description
              "If an authgroup has a default-map, it is used if a local
               NCS user is not found in the umap list.";
            uses remote-user-remote-auth;
          }
          list umap {
            // NCS patched for predictable order
            ordered-by user;
            key "local-user";
            description
              "The umap is a list with the local NCS user name as key.
               It maps the local NCS user name to remote authentication
               credentials.";
            leaf local-user {
              type string;
              description
                "The local NCS user name.";
            }
            uses remote-user-remote-auth;
          }
        }
        list snmp-group {
          // NCS patched for predictable order
          ordered-by user;
          key "name";
          description
            "When NCS connects to a managed device over SNMP, it locates
             the snmp-group configured for that device.  Then NCS looks
             up the local NCS user name in the 'umap' list.  If an entry
             is found, the credentials configured is used when
             authenticating to the managed device.

             If no entry is found in the 'umap' list, or credentials for
             the requested SNMP version has not been configured, the
             credentials configured in 'default-map' are used.

             If no 'default-map' has been configured, and the local NCS
             user name is not found in the 'umap' list, the connection
             to the managed device fails.";

          grouping key {
            choice key-type {
              leaf same-password {
                type empty;
                description
                  "Use the local NCS password as the password
                   used by NCS to create a localized key, as described
                   in RFC 3414.";
              }
              leaf remote-password {
                type string;
                description
                  "If this leaf is set, NCS uses its value to create
                   a localized key, as described in RFC 3414.";
              }
              leaf key {
                type string;
                description
                  "Non-localized key specified as a list of
                   colon-separated hexa-decimal octets.  NCS localizes
                   this key for a device before it is used, as described
                   in RFC 3414.";
              }
            }
          }

          grouping remote-snmp-credentials {
            description
              "Remote SNMP credentials.";
            choice community {
              leaf community-name {
                type string;
                description
                  "A community name that can be represented as a
                   YANG string.";
              }
              leaf community-binary-name {
                type string;
                description
                  "A community name represented as a binary value.";
              }
            }
            container usm {
              presence "enables usm";
              choice remote-user {
                // NCS drop mandatory statement
                leaf same-user {
                  type empty;
                  description
                    "Use the local NCS user name as the remote USM user name.";
                }
                leaf remote-name {
                  type string;
                  description
                    "Remote USM user name.";
                  reference "SNMP-USER-BASED-SM-MIB.usmUserName";
                }
              }
              leaf security-level {
                type ncs_template_snmp-security-level;
                // NCS drop mandatory statement
                // NCS drop must statement
                // NCS drop must statement
              }
              container auth {
                presence "enables authentication";
                choice protocol {
                  // NCS drop mandatory statement
                  reference "SNMP-USER-BASED-SM-MIB.usmUserAuthProtocol";
                  container md5 {
                    uses key;
                    reference "SNMP-USER-BASED-SM-MIB.usmHMACMD5AuthProtocol";
                  }
                  container sha {
                    uses key;
                    reference "SNMP-USER-BASED-SM-MIB.usmHMACSHAAuthProtocol";
                  }
                }
              }
              container priv {
                presence "enables privacy";
                // NCS drop must statement
                choice protocol {
                  // NCS drop mandatory statement
                  reference "SNMP-USER-BASED-SM-MIB.usmUserPrivProtocol";
                  container des {
                    uses key;
                    reference "SNMP-USER-BASED-SM-MIB.usmDESPrivProtocol";
                  }
                  container aes {
                    uses key;
                    reference "SNMP-USM-AES-MIB.usmAesCfb128Protocol";
                  }
                }
              }
            }
          }
          leaf name {
            type string;
            description
              "The name of the snmp authgroup.";
          }
          container default-map {
            presence "Map unknown users";
            description
              "If an snmp auth group has a default-map, it is used if a
               local NCS user is not found in the umap list.";
            uses remote-snmp-credentials;
          }
          list umap {
            // NCS patched for predictable order
            ordered-by user;
            key "local-user";
            description
              "The umap is a list with the local NCS user name as key.
               It maps the local NCS user name to remote authentication
               credentials.";
            leaf local-user {
              type string;
              description
                "The local NCS user name.";
            }
            uses remote-snmp-credentials;
          }
        }
      }
      list template {
        // NCS patched for predictable order
        ordered-by user;
        key "name";
        description
          "This list is used to define named template configurations that
           can be used to either instantiate the configuration for new
           devices, or to apply snippets of configurations to existing
           devices.

           A template is applied by invoking the 'apply-template' action
           in a device-group or in a device.

           When template is applied, the nodes in the template are by
           default merged with the nodes in the target device.  This
           behaviour can be changed by using tags:

           If a list or container node in the template contains a tag
           with the value 'replace', the template application will
           change from merge to replace for this node.

           Otherwise, if a list or container node in the template
           contains a tag with the value 'nocreate', the template
           application will never create this node or anything below it;
           it will only modify existing containers and list entries.

           Otherwise, if a node in the template contains a tag with the
           value 'delete', the template application will delete this
           node from the device, if it exists.";
        leaf name {
          type string;
          description
            "The name of a specific template configuration.";
        }
        list ned-id {
          // NCS patched for predictable order
          ordered-by user;
          key "id";
          leaf id {
            type string;
          }
          container config {
            description
              "This container is augmented with data models from the devices.";
          }
        }
        container config {
          description
            "Just to support releases prior to 4.5. Will be deprecated";
        }
      }
      list device-group {
        // NCS patched for predictable order
        ordered-by user;
        key "name";
        leaf name {
          type string;
        }
        description
          "A named group of devices, some actions can be
           applied to an entire  group of devices, for example
           apply-template, and the sync actions.";
        uses ncs_template_location {
          description
            "Location of the device group.  These nodes are expected to be
             configured by the operator, typically by using a map application
             in e.g., the Web UI.";
        }
        leaf-list device-name {
          // NCS patched for predictable order
          ordered-by user;
          type string;
        }
        leaf-list device-group {
          // NCS patched for predictable order
          ordered-by user;
          type string;
          description
            "A list of device groups contained in this device group.

             Recursive definitions are not valid.";
        }
        // NCS drop config false leaf-list member
        // NCS drop config false list 'ned-id'
        uses ncs_template_connect-grouping;
        uses ncs_template_sync-to-grouping;
        uses ncs_template_sync-from-grouping;
        uses ncs_template_check-sync-grouping;
        uses ncs_template_check-yang-modules-grouping;
        uses ncs_template_fetch-ssh-host-keys-grouping;
        uses ncs_template_apply-template-grouping;
      }
      list mib-group {
        // NCS patched for predictable order
        ordered-by user;
        key "name";
        description
          "A list of named groups of MIBs.

           This list is used so that SNMP devices can refer to collections
           of MIBs, instead of having to refer to individual MIBs.

           For example, an operator can configure one MIB group per
           device model.";
        leaf name {
          type string;
          description
            "An arbitrary name of the MIB group.";
        }
        leaf-list mib-module {
          // NCS patched for predictable order
          ordered-by user;
          type string;
          description
            "A list of MIB module names or MIB module name prefixes in
             this MIB group.

             The string is either exactly matches a MIB module, e.g.,
             'SNMPv2-MIB', or a prefix followed by a wildcard, e.g.,
             'SNMP-*'.  Such a prefix matches all MIB modules with names
             starting by 'SNMP-'.";
        }
        leaf-list mib-group {
          // NCS patched for predictable order
          ordered-by user;
          type string;
          description
            "A list of MIB groups contained in this MIB group.

             Recursive definitions are not valid.";
        }
      }
      list device {
        // NCS patched for predictable order
        ordered-by user;
        key "name";
        description
          "This list contains all devices managed by NCS.";
        leaf name {
          type string;
          description
            "A string uniquely identifying the managed device.";
        }
        // NCS drop must statement
        // NCS drop config false leaf 'last-changed'
        choice address-choice {
          case device {
            leaf address {
              type string;
              description
                "IP address or host name for the management interface on
                 the device.";
            }
            leaf port {
              type string;
              description
                "Port for the management interface on the device. If this leaf
                 is not configured, NCS will use a default value based on the
                 type of device. For example, a NETCONF device uses port 830,
                 a CLI device over SSH uses port 22, and an SNMP device uses
                 port 161.";
            }
          }
          case lsa-device {
            leaf lsa-remote-node {
              // NCS drop when statement
              type string;
              description
                "Setting lsa-remote-node indicates that this device is the same
                 as the cluster node. When set the address and port of the
                 cluster node is used for this device.";
            }
          }
        }
        leaf local-user {
          type string;
          description
            "The local user is used when setting up a device
             connection for call home connections.";
        }
        uses ncs_template_ssh-connection-config;
        leaf description {
          type string;
          description
            "Free form text describing the device.";
        }
        uses ncs_template_location {
          description
            "Location of the device.  These nodes are expected to be
             configured by the operator, typically by using a map application
             in e.g., the Web UI.";
        }

        grouping ne-type {
          leaf authgroup {
            type string;
            description
              "The authentication credentials used when connecting
               to this managed device.

               This leaf must be set for NETCONF and CLI devices, and
               may be used by generic NEDs, if applicable.";
          }
          container device-type {
            choice ne-type {
              case netconf {
                container netconf {
                  // NCS drop must statement
                  leaf ned-id {
                    type string;
                    // NCS drop mandatory statement
                  }
                }
              }
              case generic {
                container generic {
                  leaf ned-id {
                    type string;
                    // NCS drop mandatory statement
                  }
                }
              }
              case cli {
                container cli {
                  // NCS drop must statement
                  leaf ned-id {
                    type string;
                    // NCS drop mandatory statement
                  }
                  leaf protocol {
                    type string;
                    // NCS drop default statement
                  }
                }
              }
              case snmp {
                container snmp {
                  leaf version {
                    type ncs_template_snmp-version;
                    // NCS drop mandatory statement
                  }
                  leaf context-name {
                    // NCS drop when statement
                    type string;
                    // NCS drop default statement
                    description
                      "The SNMP context name to use when communicating
                       with the device.  If an SNMP engine supports multiple
                       contexts, each context must be handled as a separate
                       managed-device in NCS.";
                    reference "RFC 3411: Architecture for SNMP Management Frameworks";
                  }
                  leaf ned-id {
                    type string;
                    // NCS drop mandatory statement
                  }
                  leaf snmp-authgroup {
                    type string;
                    // NCS drop mandatory statement
                  }
                  leaf retries {
                    type string;
                    // NCS drop default statement
                    description
                      "Specifies the number of retries to be used when sending
                       a request.";
                  }
                  leaf timeout {
                    type string;
                    units "seconds";
                    // NCS drop default statement
                    description
                      "Specifies the timeout in seconds between retries.";
                  }
                  leaf-list mib-group {
                    // NCS patched for predictable order
                    ordered-by user;
                    type string;
                    description
                      "A list of MIB groups implemented by the device.

                       In SNMP, there is no generic, automatic way to
                       figure out which MIBs an agent implements.  Thus,
                       this list can be used to inform NCS which MIBs the
                       device implements.

                       If this list is empty, NCS assumes that the device
                       implements all MIBs known to NCS.

                       The MIBs NCS thinks the device implements are
                       listed in /devices/module.  These
                       modules are used by NCS to control what data can
                       be configured under /devices/device/config,
                       and what data is shown in
                       /devices/device/live-status.";
                  }
                }
              }
            }
          }
        }
        // NCS expand uses statement
        leaf authgroup {
          type string;
          description
            "The authentication credentials used when connecting
             to this managed device.

             This leaf must be set for NETCONF and CLI devices, and
             may be used by generic NEDs, if applicable.";
        }
        container device-type {
          choice ne-type {
            case netconf {
              container netconf {
                // NCS drop must statement
                leaf ned-id {
                  type string;
                  // NCS drop mandatory statement
                }
              }
            }
            case generic {
              container generic {
                leaf ned-id {
                  type string;
                  // NCS drop mandatory statement
                }
              }
            }
            case cli {
              container cli {
                // NCS drop must statement
                leaf ned-id {
                  type string;
                  // NCS drop mandatory statement
                }
                leaf protocol {
                  type string;
                  // NCS drop default statement
                }
              }
            }
            case snmp {
              container snmp {
                leaf version {
                  type ncs_template_snmp-version;
                  // NCS drop mandatory statement
                }
                leaf context-name {
                  // NCS drop when statement
                  type string;
                  // NCS drop default statement
                  description
                    "The SNMP context name to use when communicating
                     with the device.  If an SNMP engine supports multiple
                     contexts, each context must be handled as a separate
                     managed-device in NCS.";
                  reference "RFC 3411: Architecture for SNMP Management Frameworks";
                }
                leaf ned-id {
                  type string;
                  // NCS drop mandatory statement
                }
                leaf snmp-authgroup {
                  type string;
                  // NCS drop mandatory statement
                }
                leaf retries {
                  type string;
                  // NCS drop default statement
                  description
                    "Specifies the number of retries to be used when sending
                     a request.";
                }
                leaf timeout {
                  type string;
                  units "seconds";
                  // NCS drop default statement
                  description
                    "Specifies the timeout in seconds between retries.";
                }
                leaf-list mib-group {
                  // NCS patched for predictable order
                  ordered-by user;
                  type string;
                  description
                    "A list of MIB groups implemented by the device.

                     In SNMP, there is no generic, automatic way to
                     figure out which MIBs an agent implements.  Thus,
                     this list can be used to inform NCS which MIBs the
                     device implements.

                     If this list is empty, NCS assumes that the device
                     implements all MIBs known to NCS.

                     The MIBs NCS thinks the device implements are
                     listed in /devices/module.  These
                     modules are used by NCS to control what data can
                     be configured under /devices/device/config,
                     and what data is shown in
                     /devices/device/live-status.";
                }
              }
            }
          }
          // NCS drop must statement
        }
        leaf device-profile {
          type string;
        }
        uses device-profile-parameters {
          augment "commit-queue" {
            // NCS drop config false leaf 'queue-length'
            // NCS drop config false list 'waiting-for'
          }
        }
        // NCS drop config false container 'active-settings'
        list live-status-protocol {
          // NCS patched for predictable order
          ordered-by user;
          key "name";
          description
            "It is possible to have additional NEDs speaking
             southbound to the managed device for the device's
             'live-status' tree.

             All configuration data must be handled by one NED, but
             multiple NEDs can be used for the 'live-status' tree.

             For example a CLI NED can be used for 'show routes'
             and the SNMP NED for some additional MIBs";
          leaf name {
            type string;
          }
          leaf address {
            type string;
            description
              "IP address or host name for the management interface on
               the device. If omitted the same address as configured for
               this device will be used.";
          }
          leaf port {
            type string;
            description
              "Port for the management interface on the device.  If this leaf
               is not configured, NCS will use a default value based on
               the type of device.  For example, a NETCONF device uses
               port 830, a CLI device over SSH uses port 22, and an SNMP
               device uses port 161.";
          }
          container ssh {
            presence "protocol-specific ssh host keys";
            tailf:code-name "ssh_container";
            description
              "SSH host keys for this protocol. If not present, the host keys
               configured for this device will be used.";
            uses ncs_template_ssh-host-keys;
          }
          container ssh-algorithms {
            description
              "Supported (allowed) algorithms that should be used during
               SSH algorithm negotiations. If a specific algorithm type
               is not present, the algorithms configured for this device
               will be used.";
            uses ncs_template_ssh-algorithms;
          }
          // NCS expand uses statement
          leaf authgroup {
            type string;
            description
              "The authentication credentials used when connecting
               to this managed device.

               This leaf must be set for NETCONF and CLI devices, and
               may be used by generic NEDs, if applicable.";
          }
          container device-type {
            choice ne-type {
              case netconf {
                container netconf {
                  // NCS drop must statement
                  leaf ned-id {
                    type string;
                    // NCS drop mandatory statement
                  }
                }
              }
              case generic {
                container generic {
                  leaf ned-id {
                    type string;
                    // NCS drop mandatory statement
                  }
                }
              }
              case cli {
                container cli {
                  // NCS drop must statement
                  leaf ned-id {
                    type string;
                    // NCS drop mandatory statement
                  }
                  leaf protocol {
                    type string;
                    // NCS drop default statement
                  }
                }
              }
              case snmp {
                container snmp {
                  leaf version {
                    type ncs_template_snmp-version;
                    // NCS drop mandatory statement
                  }
                  leaf context-name {
                    // NCS drop when statement
                    type string;
                    // NCS drop default statement
                    description
                      "The SNMP context name to use when communicating
                       with the device.  If an SNMP engine supports multiple
                       contexts, each context must be handled as a separate
                       managed-device in NCS.";
                    reference "RFC 3411: Architecture for SNMP Management Frameworks";
                  }
                  leaf ned-id {
                    type string;
                    // NCS drop mandatory statement
                  }
                  leaf snmp-authgroup {
                    type string;
                    // NCS drop mandatory statement
                  }
                  leaf retries {
                    type string;
                    // NCS drop default statement
                    description
                      "Specifies the number of retries to be used when sending
                       a request.";
                  }
                  leaf timeout {
                    type string;
                    units "seconds";
                    // NCS drop default statement
                    description
                      "Specifies the timeout in seconds between retries.";
                  }
                  leaf-list mib-group {
                    // NCS patched for predictable order
                    ordered-by user;
                    type string;
                    description
                      "A list of MIB groups implemented by the device.

                       In SNMP, there is no generic, automatic way to
                       figure out which MIBs an agent implements.  Thus,
                       this list can be used to inform NCS which MIBs the
                       device implements.

                       If this list is empty, NCS assumes that the device
                       implements all MIBs known to NCS.

                       The MIBs NCS thinks the device implements are
                       listed in /devices/module.  These
                       modules are used by NCS to control what data can
                       be configured under /devices/device/config,
                       and what data is shown in
                       /devices/device/live-status.";
                  }
                }
              }
            }
            // NCS drop must statement
          }
          // NCS drop config false container state
          // NCS drop config false list capability
        }
        container state {
          uses ncs_template_oper-state;
          // NCS drop config false leaf 'transaction-mode'
          // NCS drop config false leaf 'last-transaction-id'
          // NCS drop config false container 'last-modules-state'
          leaf admin-state {
            // NCS drop must statement
            type ncs_template_admin-state;
            // NCS drop default statement
          }
          leaf admin-state-description {
            type string;
            description
              "Reason for the admin state.";
          }
        }
        container source {
          leaf added-by-user {
            type string;
          }
          leaf context {
            type string;
          }
          leaf when {
            type string;
          }
          leaf from-ip {
            type string;
          }
          leaf source {
            type string;
            reference "TMF518 NRB Network Resource Basics";
          }
        }
        uses capability-module-grouping {
          // NCS drop config false refine capability
          // NCS drop config false refine module
          augment "capability";
        }
        // NCS drop config false container platform
        uses ncs_template_apply-template-grouping;
        uses ncs_template_disconnect-grouping-specific;
        container config {
          description
            "This container is used to mount configuration data nodes
             from the device's data models.

             This is where NCS's copy of the device configuration is stored.

             This container defines a mount point as defined in 'YANG
             Schema Mount' (draft-ietf-netmod-schema-mount-10).  This
             means that NCS maintains a config false instantiation of
             the YANG library under this container, which can be read by a
             client to learn the data model (schema) for the device.";
        }
        // NCS drop config false container 'live-status'
        container rpc {
          description
            "This container is augmented with top-level rpcs
             from the device's data models.

             The rpcs are augments as tailf:actions.  This makes it possible
             to invoke rpcs on the devices through the NCS data model.";
        }
        container notifications {
          // NCS drop when statement
          description
            "Event notification support using NETCONF or
             protocols implemented by the NED.";
          reference "RFC 5277 - NETCONF Event Notifications";
          // NCS expand uses statement
          list subscription {
            // NCS patched for predictable order
            ordered-by user;
            key "name";
            description
              "A list of our notification subscriptions for this managed device.";
            leaf name {
              type string;
              description
                "Each subscription must have a unique name.";
            }
            leaf stream {
              type string;
              // NCS drop mandatory statement
              description
                "The name of the notification stream this subscription
                 refers to.";
            }
            choice filter {
              description
                "Optional element, if not set, no filters are applied.";
              case xpath {
                leaf xpath {
                  type string;
                }
              }
              case subtree {
                leaf subtree {
                  type string;
                }
              }
            }
            leaf local-user {
              type string;
              // NCS drop mandatory statement
              description
                "The local user is used when setting up a device
                 connection.";
            }
            leaf store-in-cdb {
              type string;
              // NCS drop default statement
              description
                "Indicate whether notifications should be stored as
                 operational data in CDB.

                 When notifications are generated at a high rate,
                 storage consumes lots of resources. In cases like that,
                 consider using the device-notification event stream
                 instead.";
            }
            leaf utilize-replay {
              type string;
              // NCS drop default statement
              description
                "If the device supports replay, should NCS attempt to use that
                 when connecting to the device.";
            }
            leaf reconnect-interval {
              type string;
              units "seconds";
              // NCS drop default statement
              description
                "If the device is non operational, with which
                 interval (in seconds) shall NCS attempt to re-establish
                 the subscription.";
            }
            // NCS drop config false leaf status
            // NCS drop config false leaf 'failure-reason'
            // NCS drop config false leaf 'error-info'
            // NCS drop must statement
          }
          // NCS drop config false list stream
          // NCS drop config false list 'notification-name'
          container received-notifications {
            leaf max-size {
              type string;
              // NCS drop default statement
              description
                "Max size of the list of received notifications.
                 When the maximum size is reached, the oldest
                 received notification is purged.";
            }
            // NCS drop config false leaf 'clear-time'
            // NCS drop config false list notification
          }
        }
        container netconf-notifications {
          // NCS drop when statement
          description
            "NETCONF notification support. This container is
             deprecated and will be removed in a future release.
             Use /devices/device/notifications instead.";
          reference "RFC 5277 - NETCONF Event Notifications";
          status deprecated;
          // NCS expand uses statement
          list subscription {
            // NCS patched for predictable order
            ordered-by user;
            key "name";
            description
              "A list of our notification subscriptions for this managed device.";
            leaf name {
              type string;
              description
                "Each subscription must have a unique name.";
            }
            leaf stream {
              type string;
              // NCS drop mandatory statement
              description
                "The name of the notification stream this subscription
                 refers to.";
            }
            choice filter {
              description
                "Optional element, if not set, no filters are applied.";
              case xpath {
                leaf xpath {
                  type string;
                }
              }
              case subtree {
                leaf subtree {
                  type string;
                }
              }
            }
            leaf local-user {
              type string;
              // NCS drop mandatory statement
              description
                "The local user is used when setting up a device
                 connection.";
            }
            leaf store-in-cdb {
              type string;
              // NCS drop default statement
              description
                "Indicate whether notifications should be stored as
                 operational data in CDB.

                 When notifications are generated at a high rate,
                 storage consumes lots of resources. In cases like that,
                 consider using the device-notification event stream
                 instead.";
            }
            leaf utilize-replay {
              type string;
              // NCS drop default statement
              description
                "If the device supports replay, should NCS attempt to use that
                 when connecting to the device.";
            }
            leaf reconnect-interval {
              type string;
              units "seconds";
              // NCS drop default statement
              description
                "If the device is non operational, with which
                 interval (in seconds) shall NCS attempt to re-establish
                 the subscription.";
            }
            // NCS drop config false leaf status
            // NCS drop config false leaf 'failure-reason'
            // NCS drop config false leaf 'error-info'
            // NCS drop must statement
          }
          // NCS drop config false list stream
          // NCS drop config false list 'notification-name'
          container received-notifications {
            leaf max-size {
              type string;
              // NCS drop default statement
              description
                "Max size of the list of received notifications.
                 When the maximum size is reached, the oldest
                 received notification is purged.";
            }
            // NCS drop config false leaf 'clear-time'
            // NCS drop config false list notification
          }
        }
        // NCS drop config false leaf-list 'service-list'
      }
      // NCS drop config false container 'ned-ids'
      // NCS drop config false container 'commit-queue'
      // NCS drop config false container 'session-pool'
    }
  }
}
