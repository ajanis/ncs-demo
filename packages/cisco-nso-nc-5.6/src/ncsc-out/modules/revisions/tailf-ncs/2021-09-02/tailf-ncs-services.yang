submodule tailf-ncs-services {
  // Generated by yanger -t ncs
  tailf:mount-id "cisco-nso-nc-5.6:cisco-nso-nc-5.6";

  yang-version 1.1;
  belongs-to tailf-ncs {
    prefix ncs;
  }

  import tailf-common {
    prefix tailf;
  }
  import ietf-yang-types {
    prefix yang;
  }
  include tailf-ncs-common;
  include tailf-ncs-customers;
  include tailf-ncs-devices;
  include tailf-ncs-log;
  import tailf-ncs-internal-mount {
    prefix ncs-internal;
  }

  organization
    "Tail-f Systems";
  description
    "This submodule contains a collection of YANG definitions for
     configuring and monitoring services in NCS.

     Copyright 2012-2021 Cisco Systems, Inc.
     All rights reserved.
     Permission is hereby granted to redistribute this file without
     modification.";

  revision 2021-09-02 {
    description
      "Released as part of NCS-5.6.

       Non-backwards-compatible changes have been introduced.

       Updated showing data modifications from get-modifications

       Removed service leaf-list 'device-list'.

       Removed the action /services/commit-dry-run.

       Added /services/global-settings/service-callback-timeout.

       Obsoleted the commit-queue-failed enum for
       commit-queue/queue-item/status leaf in the service-commit-queue
       grouping. Use failed enum instead.

       Removed commit-queue/queue-item/no-of-impacted-services leaf
       in the service-commit-queue grouping.

       Added service-commit-queue-event notification.

       Added /services/commit-queue-notifications container.";
  }
  revision 2020-11-26 {
    description
      "Released as part of NCS-5.5.

       Added 'wait-for-lock' grouping to 'deep-check-sync' input.";
  }
  revision 2020-06-25 {
    description
      "Released as part of NCS-5.4.

       Marked service leaf-list 'device-list' obsolete, use service
       'modified' and 'directly-modified' instead.

       Marked the action /services/commit-dry-run as obsolete,
       use 'commit dry-run' instead.

       Added plan-location to the service-data.";
  }
  revision 2020-02-20 {
    description
      "Released as part of NCS-5.3.1.

       Changed the type of transaction-hook ncs-rfs-service-hook from
       subtree to node.";
  }
  revision 2019-04-09 {
    description
      "Released as part of NCS-5.1.

       Added ned-id-list in the service's private data.";
  }
  revision 2018-06-21 {
    description
      "Released as part of NCS-4.7.

       Added 'sync' empty leaf to 'reactive-re-deploy' input.

       Added 'ncs-commit-result' grouping to 'reactive-re-deploy' output.";
  }
  revision 2018-03-01 {
    description
      "Released as part of NCS-4.6.

       Renamed all 'dryrun' groupings to 'dry-run'.";
  }
  revision 2017-11-30 {
    description
      "Released as part of NCS-4.5.2.

       Added new option 'reverse' to 'commit-dry-run' action.";
  }
  revision 2017-09-28 {
    description
      "Released as part of NCS-4.5.

       Removed 'ncs-commit-result' grouping from 'reactive-re-deploy'
       output.";
  }
  revision 2017-03-16 {
    description
      "Released as part of NCS-4.4.

       Corrected description for
       commit-queue/queue-item/failed-device/config-data in grouping
       service-commit-queue.";
  }
  revision 2016-11-24 {
    description
      "Released as part of NCS-4.3.

       Added additional dry-run parameter to un-deploy action.

       Added grouping service-get-modifications to share the
       get-modifications action between services and nano-services.

       Added lsa-service-list in the service's private data to
       keep track of services on a remote NCS node in LSA architecture
       this service has touched.

       Changed output format for the following actions: re-deploy,
       un-deploy, check-sync, deep-check-sync, get-modifications and
       commit-dry-run in order to be able to present changes associated
       with remote LSA nodes and services residing at these nodes.

       Added 'lsa-services' leaf-list under 'modified' and 'directly-modified'
       that shows references to LSA services this service has touched.

       Removed leaf 'device-modifications' that was deprecated in NCS-3.0.

       Changed model of commit-queue for a service to be a list
       of queue-items. Replaced action 'clear' by action 'admin-clear' and
       and action 'purge' by action 'delete'. Added an action 'clear'
       which deletes the whole list of queue-items.";
  }
  revision 2016-05-26 {
    description
      "Released as part of NCS-4.2.

       Added service action 'touch'.

       Renamed input parameter from supress-positive-result to
       suppress-positive-result for the /services/check-sync action

       Added parameter 'reconcile' to service action 're-deploy'.

       Added suppress-positive-result input parameter to check-sync and
       deep-check-sync actions under service-data grouping

       Changed the output format for 'check-sync', 'deep-check-sync',
       're-deploy' and 'commit-dry-run' to be consistent.";
  }
  revision 2015-11-24 {
    description
      "Released as part of NCS-4.1.

       Added service private data:
       'private/device-list' and 'private/service-list'.

       Added parameters, 'shallow' and 'deep'  to service action
       'check-sync'.

       Added parameters, 'shallow' and 'deep'  to service action
       're-deploy'.

       Added parameters, 'shallow' and 'deep'  to service action
       'get-modifications'.

       Added service 'modified' and 'directly-modified'.

       Deprecated service leaf-list 'device-list', use service
       'modified' and 'directly-modified' instead.

       Added grouping service-reactive-re-deploy and the use hereof.";
  }
  revision 2015-03-19 {
    description
      "Released as part of NCS-3.4.

       Minor description enhancements.";
  }
  revision 2014-12-10 {
    description
      "Released as part of NCS-3.3.1.

       Changed the service's commit-queue status 'failed-admin-cleared'
       to 'admin-cleared' and added new state 'commit-queue-failed'.";
  }
  revision 2014-11-19 {
    description
      "Released as part of NCS-3.3.

       Changed data type of 'commit-queue/queue-item' from int64
       to uint64.";
  }
  revision 2014-06-30 {
    description
      "Released as part of NCS-3.2.

       Use ncs-commit-* groupings in re-deploy and un-deploy.

       Changed a service's commit-queue/status enumeration to match
         the enumeration in /devices/device/commit-queue/status.

       Changed a service's commit-queue/failed-devices from a leaf-list
         to a list, and added some info.";
  }
  revision 2014-05-20 {
    description
      "Released as part of NCS-3.1.1.1.

       Added no-overwrite to un-deploy and re-deploy.

       Changed the names of the status leaf in the commit-queue stats
         container, in order to align with the status in
         /devices/commit-queues/queue-item/status.";
  }
  revision 2014-05-08 {
    description
      "Released as part of NCS-3.1.1.

       Added addtional fields in the commit-queue stats container with
       information about the error returned by the device, including
       the entire configuration data which was rejected";
  }
  revision 2014-04-02 {
    description
      "Released as part of NCS-3.1.";
  }
  revision 2013-11-12 {
    description
      "Released as part of NCS-3.0.

       Removed use of grouping service-data-no-hook in list /services/service.

       Removed callpoint ncs-rfs-service-case-hook in list /services/service.

       Removed action self-test in list /services/service.

       Removed leaf action-opaque from grouping service-data-no-hook/private.

       Removed leaf data-opaque from grouping service-data-no-hook/private.

       Removed grouping service-data-no-hook and introduced parts in grouping
         service-data.

       Removed YANG extension service-template-name and grouping
         service-template-data.

       Renamed the output container 'xml' in 'check-sync' and 're-deploy'
         to 'result-xml'.  The name 'xml' is illegal in YANG.  Also, changed
         the resulting leaf 'data' to anyxml 'data'.

       Added an action 'get-modifications' that returns the modifications
         a service introduced, in CLI and XML format.

       Added leaf /services/global-settings/collect-forward-diff.";
  }
  revision 2013-06-18 {
    description
      "Released as part of NCS-2.3.

       Added YANG extensions servicepoint and grouping service-data, to be
         used by service data models.

       Removed fastmap and extended support for customer facing services.

       Deprecated the action /services/commit-dry-run.  Use
         commit dry-run in the CLI instead.

       Removed the actions /services/fastmap/disable and enable.  Use
         commit no-fastmap in the CLI instead.

       Removed /services/status-summary operational data container.

       Removed /services/service/uses-service.

       Removed /services/services/used-by-cust-service operational data
       Removed /services/services/service-status operational data
       Since these only could hold information for a subset of services.";
  }
  revision 2013-03-12 {
    description
      "Released as part of NCS-2.2.

       Added native format to /services/commit-dry-run.
       Added YANG extension service-template-name and grouping
         service-template-data.";
  }
  revision 2012-08-30 {
    description
      "Released as part of NCS-2.0.";
  }

  grouping ncs_template_service-data {
    description
      "Use this grouping together with ncs:servicepoint
       in order to get the common definitions for a service
       implemented by a callback function.";
    uses ncs_template_service-check-sync;
    uses ncs_template_service-deep-check-sync;
    uses ncs_template_service-re-deploy;
    uses ncs_template_service-reactive-re-deploy;
    uses ncs_template_service-touch;
    uses ncs_template_service-impacted-devices;
    uses ncs_template_service-un-deploy;
    uses ncs_template_service-customer-service;
    uses ncs_template_service-commit-queue;
    uses ncs_template_service-private-data;
    uses ncs_template_service-plan-location;
    uses ncs_template_log-data;
  }

  grouping ncs_template_service-plan-location {
    // NCS drop config false leaf 'plan-location'
  }

  grouping ncs_template_service-commit-queue {
    // NCS drop config false container 'commit-queue'
  }

  grouping ncs_template_service-un-deploy;

  grouping ncs_template_service-private-data {
    container private {
      ncs:ncs-service-private;
      description
        "NCS service related internal data stored here.";
      tailf:hidden "fastmap-private";
      // NCS drop fully hidden leaf 'diff-set'
      // NCS drop fully hidden leaf 'forward-diff-set'
      // NCS drop fully hidden leaf-list 'device-list'
      // NCS drop fully hidden leaf-list 'ned-id-list'
      // NCS drop fully hidden leaf-list 'service-list'
      // NCS drop fully hidden leaf-list 'lsa-service-list'
      container property-list {
        description
          "FASTMAP service instance data used by the service implementation.";
        list property {
          // NCS patched for predictable order
          ordered-by user;
          key "name";
          leaf name {
            type string;
          }
          leaf value {
            type string;
          }
        }
      }
      leaf re-deploy-counter {
        type string;
        // NCS drop default statement
      }
      // NCS drop fully hidden leaf 'latest-commit-params'
      // NCS drop fully hidden leaf 'latest-u-info'
    }
  }

  grouping ncs_template_service-check-sync;

  grouping ncs_template_service-deep-check-sync;

  grouping ncs_template_service-re-deploy;

  grouping ncs_template_service-reactive-re-deploy;

  grouping ncs_template_service-touch;

  grouping ncs_template_service-impacted-devices {
    // NCS drop config false container modified
    // NCS drop config false container 'directly-modified'
    uses ncs_template_service-get-modifications;
  }

  grouping ncs_template_service-get-modifications;

  grouping ncs_template_service-customer-service {
    // NCS drop config false leaf-list 'used-by-customer-service'
  }

  grouping ncs_template_service-depth {
    choice depth {
      leaf deep {
        type empty;
      }
      leaf shallow {
        type empty;
      }
      // NCS drop default statement
    }
  }

  grouping ncs_template_service-modifications-xml {
    container result-xml {
      container local-node {
        anyxml data;
      }
      list lsa-service {
        // NCS patched for predictable order
        ordered-by user;
        key "service-id";
        leaf service-id {
          type string;
        }
        anyxml data;
      }
    }
  }

  grouping ncs_template_service-modifications-cli {
    container cli {
      container local-node {
        leaf data {
          type string;
        }
      }
      list lsa-service {
        // NCS patched for predictable order
        ordered-by user;
        key "service-id";
        leaf service-id {
          type string;
        }
        leaf data {
          type string;
        }
      }
    }
  }

  grouping ncs_template_service-sync {
    container sync-result {
      container local-node {
        leaf in-sync {
          type string;
        }
      }
      list lsa-service {
        // NCS patched for predictable order
        ordered-by user;
        key "service-id";
        leaf service-id {
          type string;
        }
        leaf in-sync {
          type string;
        }
      }
    }
  }

  grouping ncs_template_choice-lsa-grouping {
    choice choice-lsa {
      leaf use-lsa {
        type empty;
        description
          "Force handling LSA nodes as such.";
      }
      leaf no-lsa {
        type empty;
        description
          "Do not handle any of the LSA nodes as such. These nodes
           will be handled as any other device.";
      }
    }
  }

  grouping ncs_rpc_notif_service-data {
    description
      "Use this grouping together with ncs:servicepoint
       in order to get the common definitions for a service
       implemented by a callback function.";
    // NCS drop tailf:callpoint
    uses ncs_rpc_notif_service-check-sync;
    uses ncs_rpc_notif_service-deep-check-sync;
    uses ncs_rpc_notif_service-re-deploy;
    uses ncs_rpc_notif_service-reactive-re-deploy;
    uses ncs_rpc_notif_service-touch;
    uses ncs_rpc_notif_service-impacted-devices;
    uses ncs_rpc_notif_service-un-deploy;
    uses ncs_rpc_notif_service-customer-service;
    uses ncs_rpc_notif_service-commit-queue;
    uses ncs_rpc_notif_service-private-data;
    uses ncs_rpc_notif_service-plan-location;
    uses ncs_rpc_notif_log-data;
  }

  grouping ncs_rpc_notif_service-plan-location {
    leaf plan-location {
      description
        "Location of the service plan.";
      tailf:info
        "Location of the service plan.";
      config false;
      // NCS drop tailf:callpoint
      // NCS patched to string, due to LSA partial NED
      type string;
    }
  }

  grouping ncs_rpc_notif_service-commit-queue {
    container commit-queue {
      config false;
      // NCS drop tailf:cdb-oper
      // NCS drop tailf:action
      list queue-item {
        key "id";
        leaf id {
          type uint64;
          description
            "If the queue item in the commit queue refers to this service
             this is the queue number.";
        }
        description
          "When a service is committed through the commit queue, these
           fields act as references regarding the state of this service
           instance. In the worst case scenario, a service instance is
           in the 'failed' state. This means that parts of the queued
           commit failed.

           If a service gets committed through the commit queue and the
           commit fails, the backpointers in the service data are
           followed and the affected service instances are updated and
           set to the 'failed' state.

           Depending on the nature of the failure, different techniques
           to reconcile the service can be used.

           - Make sure the commit queue is blocked to not interfere
             with the error recovery procedure.
             Do a sync-from on the non-completed device(s) and then
             re-deploy the failed service(s) with the
             'reconcile' option to reconcile original data,
             i.e., take control of that data. This option
             acknowledges other services controlling the same data.
             The reference count will indicate how many services control
             the data. Release any queue lock that was created.

           - Make sure the commit queue is blocked to not interfere
             with the error recovery procedure.
             Use un-deploy with the no-networking option on the
             service and then do sync-from on the non-completed
             device(s). Make sure the error is fixed and then
             re-deploy the failed service(s) with the
             'reconcile' option. Release any queue lock
             that was created.

           In the 'failed' state, these fields are reset if a new
           commit queue transaction is affecting this service, or
           the service is re-deployed, or these fields are deleted
           using the specific purge action.
           In other cases the 'failed' state will remain.";
        leaf status {
          // NCS drop tailf:callpoint
          type enumeration {
            enum "waiting" {
              description
                "This service was committed through the commit queue
                 and the data is in the queue, waiting to run.";
            }
            enum "executing" {
              description
                "The data for this service is currently executing at the
                 head of the commit queue.";
            }
            enum "blocking" {
              description
                "One or more of the devices for the transaction
                 of which this service instance is a part, exposes a
                 transient error. The queue item in the commit queue
                 remains there until the device becomes operational
                 or the queue is pruned.

                 Examples of transient errors are connection failures
                 and that if thre changes are rejected due to the device
                 being locked.

                 The status for the queue item, in
                 /devices/commit-queue/queue-item, contains details
                 about this state.";
            }
            enum "blocked" {
              description
                "The data for this service is waiting in the queue, and some
                 other queue item ahead of this item is in state 'blocking'.";
            }
            enum "failed" {
              description
                "The data for the transaction was not successfully
                 deployed on all devices. This service is is not
                 operational.

                 Details about the error can be found in the
                 'failed-device' list.

                 The queue item itself is removed from the
                 /devices/commit-queue/queue-item list when it fails.";
              tailf:code-name "service_failed";
            }
            enum "admin-cleared" {
              description
                "The queue item affecting this service has been administratively
                 cleared. Either directly by a clear action on this service
                 commit queue data, or indirectly because of a delete/prune
                 action directly on the commit queue queue-item.

                 In either case, device data for this service may or may not
                 have been deployed in the network.";
            }
            enum "commit-queue-failed" {
              status obsolete;
              description
                "The data for the transaction was not successfully
                 deployed on all devices. Since serveral services where modified
                 by this transaction, whether this service is operational or
                 not is indecisive.

                 Details about the error can be found in the
                 'failed-device' list.

                 The queue item itself is removed from the
                 /devices/commit-queue/queue-item list when it fails.

                 This enum is obsoleted. Used the failed enum instead.";
            }
          }
        }
        // NCS drop fully hidden leaf 'cleared-by-admin'
        list failed-device {
          description
            "If the 'status' leaf is 'failed', this list contains detailed
             information on the devices that were responsible for the
             error of the commit queue item.";
          key "name";
          leaf name {
            type string;
          }
          leaf time {
            type yang:date-and-time;
            description
              "Time when the failure occured.";
          }
          leaf config-data {
            description
              "The configuration data that was rejected by the device
               in XML format.";
            tailf:cli-preformatted;
            type string;
          }
          leaf error {
            description
              "The error returned by the device.";
            type string;
          }
        }
        // NCS drop tailf:action
        // NCS drop tailf:action
      }
    }
  }

  grouping ncs_rpc_notif_service-un-deploy {
    // NCS drop tailf:action
  }

  grouping ncs_rpc_notif_service-private-data {
    container private {
      ncs:ncs-service-private;
      description
        "NCS service related internal data stored here.";
      tailf:hidden "fastmap-private";
      // NCS drop fully hidden leaf 'diff-set'
      // NCS drop fully hidden leaf 'forward-diff-set'
      // NCS drop fully hidden leaf-list 'device-list'
      // NCS drop fully hidden leaf-list 'ned-id-list'
      // NCS drop fully hidden leaf-list 'service-list'
      // NCS drop fully hidden leaf-list 'lsa-service-list'
      container property-list {
        description
          "FASTMAP service instance data used by the service implementation.";
        list property {
          key "name";
          leaf name {
            type string;
          }
          leaf value {
            type string;
          }
        }
      }
      leaf re-deploy-counter {
        type int32;
        default "0";
      }
      // NCS drop fully hidden leaf 'latest-commit-params'
      // NCS drop fully hidden leaf 'latest-u-info'
    }
  }

  grouping ncs_rpc_notif_service-check-sync {
    // NCS drop tailf:action
  }

  grouping ncs_rpc_notif_service-deep-check-sync {
    // NCS drop tailf:action
  }

  grouping ncs_rpc_notif_service-re-deploy {
    // NCS drop tailf:action
  }

  grouping ncs_rpc_notif_service-reactive-re-deploy {
    // NCS drop tailf:action
  }

  grouping ncs_rpc_notif_service-touch {
    // NCS drop tailf:action
  }

  grouping ncs_rpc_notif_service-impacted-devices {
    container modified {
      config false;
      // NCS drop tailf:callpoint
      description
        "Devices and other services this service has modified directly or
         indirectly (through another service).";
      tailf:info
        "Devices and other services this service modified directly or
         indirectly.";
      leaf-list devices {
        tailf:info
          "Devices this service modified directly or indirectly";
        type string;
      }
      leaf-list services {
        tailf:info
          "Services this service modified directly or indirectly";
        // NCS patched to string, due to LSA partial NED
        type string;
      }
      leaf-list lsa-services {
        tailf:info
          "Services residing on remote LSA nodes this service
           has modified directly or indirectly.";
        // NCS patched to string, due to LSA partial NED
        type string;
      }
    }
    container directly-modified {
      config false;
      // NCS drop tailf:callpoint
      description
        "Devices and other services this service has explicitly
         modified.";
      tailf:info
        "Devices and other services this service has explicitly
         modified.";
      leaf-list devices {
        tailf:info
          "Devices this service has explicitly modified.";
        type string;
      }
      leaf-list services {
        tailf:info
          "Services this service has explicitly modified.";
        // NCS patched to string, due to LSA partial NED
        type string;
      }
      leaf-list lsa-services {
        tailf:info
          "Services residing on remote LSA nodes this service
           has explicitly modified.";
        // NCS patched to string, due to LSA partial NED
        type string;
      }
    }
    uses ncs_rpc_notif_service-get-modifications;
  }

  grouping ncs_rpc_notif_service-get-modifications {
    // NCS drop tailf:action
  }

  grouping ncs_rpc_notif_service-customer-service {
    leaf-list used-by-customer-service {
      tailf:info
        "Customer facing services using this service";
      type string;
      config false;
      // NCS drop tailf:callpoint
    }
  }

  grouping ncs_rpc_notif_service-depth {
    choice depth {
      leaf deep {
        type empty;
      }
      leaf shallow {
        type empty;
      }
      default "deep";
    }
  }

  grouping ncs_rpc_notif_service-modifications-xml {
    container result-xml {
      container local-node {
        anyxml data;
      }
      list lsa-service {
        key "service-id";
        leaf service-id {
          // NCS patched to string, due to LSA partial NED
          type string;
        }
        anyxml data;
      }
    }
  }

  grouping ncs_rpc_notif_service-modifications-cli {
    container cli {
      container local-node {
        leaf data {
          tailf:cli-preformatted;
          type string;
        }
      }
      list lsa-service {
        key "service-id";
        leaf service-id {
          // NCS patched to string, due to LSA partial NED
          type string;
        }
        leaf data {
          tailf:cli-preformatted;
          type string;
        }
      }
    }
  }

  grouping ncs_rpc_notif_service-sync {
    container sync-result {
      container local-node {
        leaf in-sync {
          type boolean;
        }
      }
      list lsa-service {
        key "service-id";
        leaf service-id {
          // NCS patched to string, due to LSA partial NED
          type string;
        }
        leaf in-sync {
          type boolean;
        }
      }
    }
  }

  grouping ncs_rpc_notif_choice-lsa-grouping {
    choice choice-lsa {
      leaf use-lsa {
        type empty;
        description
          "Force handling LSA nodes as such.";
      }
      leaf no-lsa {
        type empty;
        description
          "Do not handle any of the LSA nodes as such. These nodes
           will be handled as any other device.";
      }
    }
  }

  grouping live_ncs_service-data {
    description
      "Use this grouping together with ncs:servicepoint
       in order to get the common definitions for a service
       implemented by a callback function.";
    // NCS drop tailf:callpoint
    uses live_ncs_service-check-sync;
    uses live_ncs_service-deep-check-sync;
    uses live_ncs_service-re-deploy;
    uses live_ncs_service-reactive-re-deploy;
    uses live_ncs_service-touch;
    uses live_ncs_service-impacted-devices;
    uses live_ncs_service-un-deploy;
    uses live_ncs_service-customer-service;
    uses live_ncs_service-commit-queue;
    uses live_ncs_service-private-data;
    uses live_ncs_service-plan-location;
    uses live_ncs_log-data;
  }

  grouping live_ncs_service-plan-location {
    leaf plan-location {
      description
        "Location of the service plan.";
      tailf:info
        "Location of the service plan.";
      // NCS drop tailf:callpoint
      // NCS patched to string, due to LSA partial NED
      type string;
    }
  }

  grouping live_ncs_service-commit-queue {
    container commit-queue {
      // NCS drop tailf:cdb-oper
      tailf:action clear {
        tailf:actionpoint ncsproxy {
          tailf:internal;
        }
        description
          "Clear the service commit queue of all queue items.
           If this action is invoked for an queue-items which has other states
           than 'failed' those items migth later reappear since this service
           is then still affected by active commit queue transactions";
        // NCS drop tailf:actionpoint
      }
      list queue-item {
        key "id";
        leaf id {
          type uint64;
          description
            "If the queue item in the commit queue refers to this service
             this is the queue number.";
        }
        description
          "When a service is committed through the commit queue, these
           fields act as references regarding the state of this service
           instance. In the worst case scenario, a service instance is
           in the 'failed' state. This means that parts of the queued
           commit failed.

           If a service gets committed through the commit queue and the
           commit fails, the backpointers in the service data are
           followed and the affected service instances are updated and
           set to the 'failed' state.

           Depending on the nature of the failure, different techniques
           to reconcile the service can be used.

           - Make sure the commit queue is blocked to not interfere
             with the error recovery procedure.
             Do a sync-from on the non-completed device(s) and then
             re-deploy the failed service(s) with the
             'reconcile' option to reconcile original data,
             i.e., take control of that data. This option
             acknowledges other services controlling the same data.
             The reference count will indicate how many services control
             the data. Release any queue lock that was created.

           - Make sure the commit queue is blocked to not interfere
             with the error recovery procedure.
             Use un-deploy with the no-networking option on the
             service and then do sync-from on the non-completed
             device(s). Make sure the error is fixed and then
             re-deploy the failed service(s) with the
             'reconcile' option. Release any queue lock
             that was created.

           In the 'failed' state, these fields are reset if a new
           commit queue transaction is affecting this service, or
           the service is re-deployed, or these fields are deleted
           using the specific purge action.
           In other cases the 'failed' state will remain.";
        leaf status {
          // NCS drop tailf:callpoint
          type enumeration {
            enum "waiting" {
              description
                "This service was committed through the commit queue
                 and the data is in the queue, waiting to run.";
            }
            enum "executing" {
              description
                "The data for this service is currently executing at the
                 head of the commit queue.";
            }
            enum "blocking" {
              description
                "One or more of the devices for the transaction
                 of which this service instance is a part, exposes a
                 transient error. The queue item in the commit queue
                 remains there until the device becomes operational
                 or the queue is pruned.

                 Examples of transient errors are connection failures
                 and that if thre changes are rejected due to the device
                 being locked.

                 The status for the queue item, in
                 /devices/commit-queue/queue-item, contains details
                 about this state.";
            }
            enum "blocked" {
              description
                "The data for this service is waiting in the queue, and some
                 other queue item ahead of this item is in state 'blocking'.";
            }
            enum "failed" {
              description
                "The data for the transaction was not successfully
                 deployed on all devices. This service is is not
                 operational.

                 Details about the error can be found in the
                 'failed-device' list.

                 The queue item itself is removed from the
                 /devices/commit-queue/queue-item list when it fails.";
              tailf:code-name "service_failed";
            }
            enum "admin-cleared" {
              description
                "The queue item affecting this service has been administratively
                 cleared. Either directly by a clear action on this service
                 commit queue data, or indirectly because of a delete/prune
                 action directly on the commit queue queue-item.

                 In either case, device data for this service may or may not
                 have been deployed in the network.";
            }
            enum "commit-queue-failed" {
              status obsolete;
              description
                "The data for the transaction was not successfully
                 deployed on all devices. Since serveral services where modified
                 by this transaction, whether this service is operational or
                 not is indecisive.

                 Details about the error can be found in the
                 'failed-device' list.

                 The queue item itself is removed from the
                 /devices/commit-queue/queue-item list when it fails.

                 This enum is obsoleted. Used the failed enum instead.";
            }
          }
        }
        // NCS drop fully hidden leaf 'cleared-by-admin'
        list failed-device {
          description
            "If the 'status' leaf is 'failed', this list contains detailed
             information on the devices that were responsible for the
             error of the commit queue item.";
          key "name";
          leaf name {
            type leafref {
              path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/ncs:devices/ncs:device/ncs:name" {
                tailf:xpath-root 3;
              }
            }
          }
          leaf time {
            type yang:date-and-time;
            description
              "Time when the failure occured.";
          }
          leaf config-data {
            description
              "The configuration data that was rejected by the device
               in XML format.";
            tailf:cli-preformatted;
            type string;
          }
          leaf error {
            description
              "The error returned by the device.";
            type string;
          }
        }
        tailf:action admin-clear {
          tailf:actionpoint ncsproxy {
            tailf:internal;
          }
          description
            "Administratively clear this item.
             Information about failed devices will remain for this service.";
          // NCS drop tailf:actionpoint
        }
        tailf:action delete {
          tailf:actionpoint ncsproxy {
            tailf:internal;
          }
          description
            "Delete this item.
             If this action is invoked for an item which is in other states
             than 'failed' this data migth later reappear since this service
             is then still affected by an active commit queue transaction";
          // NCS drop tailf:actionpoint
        }
      }
    }
  }

  grouping live_ncs_service-un-deploy {
    tailf:action un-deploy {
      tailf:actionpoint ncsproxy {
        tailf:internal;
      }
      description
        "Undo the effects of the service instance but keep the
         service itself. The service can later be re-deployed. This is
         a means to deactivate a service, but keeping it in the system.";
      tailf:info
        "Undo the effects of the service";
      // NCS drop tailf:actionpoint
      input {
        container dry-run {
          presence "";
          leaf outformat {
            type live_ncs_outformat3;
          }
        }
        uses live_ncs_ncs-commit-params;
        leaf ignore-refcount {
          type empty;
          description
            "Unconditionally delete the device data created by the
             service, regardless of the refcount.";
        }
      }
      output {
        choice outformat {
          case case-xml {
            uses live_ncs_dry-run-xml;
          }
          case case-cli {
            uses live_ncs_dry-run-cli;
          }
          case case-native {
            uses live_ncs_dry-run-native;
          }
        }
        uses live_ncs_ncs-commit-result;
      }
    }
  }

  grouping live_ncs_service-private-data {
    container private {
      ncs:ncs-service-private;
      description
        "NCS service related internal data stored here.";
      tailf:hidden "fastmap-private";
      // NCS drop fully hidden leaf 'diff-set'
      // NCS drop fully hidden leaf 'forward-diff-set'
      // NCS drop fully hidden leaf-list 'device-list'
      // NCS drop fully hidden leaf-list 'ned-id-list'
      // NCS drop fully hidden leaf-list 'service-list'
      // NCS drop fully hidden leaf-list 'lsa-service-list'
      container property-list {
        description
          "FASTMAP service instance data used by the service implementation.";
        list property {
          key "name";
          leaf name {
            type string;
          }
          leaf value {
            type string;
          }
        }
      }
      leaf re-deploy-counter {
        type int32;
        // NCS drop default statement
      }
      // NCS drop fully hidden leaf 'latest-commit-params'
      // NCS drop fully hidden leaf 'latest-u-info'
    }
  }

  grouping live_ncs_service-check-sync {
    tailf:action check-sync {
      tailf:actionpoint ncsproxy {
        tailf:internal;
      }
      tailf:info
        "Check if device config is according to the service";
      description
        "Check if the service has been undermined, i.e., if the service
         was to be re-deployed, would it do anything. This action will
         invoke the FASTMAP code to create the change set that is compared
         to the existing data in CDB locally.

         If outformat is boolean, 'true' is returned if the service is
         in sync, i.e., a re-deploy would do nothing. If outformat is
         cli or xml, the changes that the service would do to the
         network if re-deployed are returned.";
      // NCS drop tailf:actionpoint
      input {
        leaf outformat {
          type live_ncs_outformat4;
          default "boolean";
        }
        // NCS expand uses statement
        choice depth {
          leaf deep {
            type empty;
          }
          leaf shallow {
            type empty;
          }
          default "deep";
        }
        leaf suppress-positive-result {
          type empty;
          tailf:info
            "Return list only contains negatives";
          description
            "Use this additional parameter to only return services that
             failed to sync.";
        }
        uses live_ncs_choice-lsa-grouping;
      }
      output {
        choice outformat {
          leaf in-sync {
            type boolean;
          }
          case case-xml {
            uses live_ncs_dry-run-xml;
          }
          case case-cli {
            uses live_ncs_dry-run-cli;
          }
          case case-native {
            uses live_ncs_dry-run-native;
          }
        }
      }
    }
  }

  grouping live_ncs_service-deep-check-sync {
    tailf:action deep-check-sync {
      tailf:actionpoint ncsproxy {
        tailf:internal;
      }
      tailf:info
        "Check if device config is according to the service";
      description
        "Check if the service has been undermined on the device itself.
         The action 'check-sync' compares the output of the service
         code to what is stored in CDB locally. This action retrieves the
         configuration from the devices touched by the service and compares
         the forward diff set of the service to the retrieved data. This
         is thus a fairly heavy weight operation. As opposed to the check-sync
         action that invokes the FASTMAP code, this action re-applies the
         forward diff-set. This is the same output you see when inspecting
         the 'get-modifications' operational field in the service instance.

         If the device is in sync with CDB, the output of this action
         is identical to the output of the cheaper check-sync action";
      // NCS drop tailf:actionpoint
      input {
        leaf outformat {
          type live_ncs_outformat-deep-check-sync;
          default "boolean";
        }
        leaf suppress-positive-result {
          type empty;
          tailf:info
            "Return list only contains negatives";
          description
            "Use this additional parameter to only return services that
             failed to sync.";
        }
        uses live_ncs_choice-lsa-grouping;
        uses live_ncs_wait-for-lock;
      }
      output {
        choice outformat {
          case case-xml {
            uses live_ncs_service-modifications-xml;
          }
          case case-cli {
            uses live_ncs_service-modifications-cli;
          }
          case case-sync {
            uses live_ncs_service-sync;
          }
        }
      }
    }
  }

  grouping live_ncs_service-re-deploy {
    tailf:action re-deploy {
      tailf:actionpoint ncsproxy {
        tailf:internal;
      }
      tailf:info
        "Run/Dry-run the service logic again";
      description
        "Run the service code again, possibly writing the changes of
         the service to the network once again.

         If the dry-run option is used,
         the action simply reports (in different formats) what it would do.

         Use the option 'reconcile' if the service should reconcile
         original data, i.e., take control of that data. This option
         acknowledges other services controlling the same data.";
      // NCS drop tailf:actionpoint
      input {
        container dry-run {
          presence "";
          leaf outformat {
            type live_ncs_outformat3;
          }
        }
        uses live_ncs_ncs-commit-params;
        // NCS expand uses statement
        choice depth {
          leaf deep {
            type empty;
          }
          leaf shallow {
            type empty;
          }
          default "deep";
        }
        container reconcile {
          description
            "Reconcile the service data. All data which existed before
             the service was created will now be owned by the service.
             The reference count will indicate how many services control
             the data. When the service is removed that data will also be
             removed. In technical terms the reference count will be
             decreased by one for everything which existed prior to the
             service.

             If manually configured data exists below in the configuration
             tree that data is kept unless the option
             'discard-non-service-config' is used.";
          presence "";
          choice c-non-service-config {
            leaf keep-non-service-config {
              type empty;
            }
            leaf discard-non-service-config {
              type empty;
            }
            default "keep-non-service-config";
          }
        }
      }
      output {
        choice outformat {
          case case-xml {
            uses live_ncs_dry-run-xml;
          }
          case case-cli {
            uses live_ncs_dry-run-cli;
          }
          case case-native {
            uses live_ncs_dry-run-native;
          }
        }
        uses live_ncs_ncs-commit-result;
      }
    }
  }

  grouping live_ncs_service-reactive-re-deploy {
    tailf:action reactive-re-deploy {
      tailf:actionpoint ncsproxy {
        tailf:internal;
      }
      tailf:info
        "Reactive re-deploy of service logic";
      description
        "This is a tailored re-deploy intended to be used in the reactive
         FASTMAP scenario. It differs from the ordinary re-deploy in that
         this action does not take any commit parameters.

         This action will re-deploy the services as an
         'shallow' depth re-deploy. It will be performed with the same
         user as the original commit. Also, the commit parameters will be
         identical to the latest commit involving this service.

         By default this action is asynchronous and returns nothing.";
      // NCS drop tailf:actionpoint
      input {
        leaf sync {
          description
            "By default the action is asynchronous, i.e. it does not wait for
             the service to be re-deployed. Use this leaf to get synchronous
             behaviour and block until the service re-deploy transaction is
             committed. It also means that the action will possibly return
             a commit result, such as commit queue id if any, or an
             error if the transaction failed.";
          type empty;
        }
      }
      output {
        uses live_ncs_ncs-commit-result;
      }
    }
  }

  grouping live_ncs_service-touch {
    tailf:action touch {
      tailf:actionpoint ncsproxy {
        tailf:internal;
      }
      tailf:info
        "Mark the service as changed";
      tailf:cli-configure-mode;
      description
        "This action marks the service as changed.

         Executing the action touch followed by a commit is the same as
         executing the action 're-deploy shallow'.

         By using the action 'touch' several re-deploys can be performed
         in the same transaction.";
      // NCS drop tailf:actionpoint
      input;
      output;
    }
  }

  grouping live_ncs_service-impacted-devices {
    container modified {
      // NCS drop tailf:callpoint
      description
        "Devices and other services this service has modified directly or
         indirectly (through another service).";
      tailf:info
        "Devices and other services this service modified directly or
         indirectly.";
      leaf-list devices {
        tailf:info
          "Devices this service modified directly or indirectly";
        type leafref {
          path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/ncs:devices/ncs:device/ncs:name" {
            tailf:xpath-root 3;
          }
        }
      }
      leaf-list services {
        tailf:info
          "Services this service modified directly or indirectly";
        // NCS patched to string, due to LSA partial NED
        type string;
      }
      leaf-list lsa-services {
        tailf:info
          "Services residing on remote LSA nodes this service
           has modified directly or indirectly.";
        // NCS patched to string, due to LSA partial NED
        type string;
      }
    }
    container directly-modified {
      // NCS drop tailf:callpoint
      description
        "Devices and other services this service has explicitly
         modified.";
      tailf:info
        "Devices and other services this service has explicitly
         modified.";
      leaf-list devices {
        tailf:info
          "Devices this service has explicitly modified.";
        type leafref {
          path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/ncs:devices/ncs:device/ncs:name" {
            tailf:xpath-root 3;
          }
        }
      }
      leaf-list services {
        tailf:info
          "Services this service has explicitly modified.";
        // NCS patched to string, due to LSA partial NED
        type string;
      }
      leaf-list lsa-services {
        tailf:info
          "Services residing on remote LSA nodes this service
           has explicitly modified.";
        // NCS patched to string, due to LSA partial NED
        type string;
      }
    }
    uses live_ncs_service-get-modifications;
  }

  grouping live_ncs_service-get-modifications {
    tailf:action get-modifications {
      tailf:actionpoint ncsproxy {
        tailf:internal;
      }
      tailf:info
        "Get the data this service created";
      description
        "Returns the data the service modified, either
         in CLI curly bracket format, or NETCONF XML edit-config format.
         The modifications are shown as if the service instance was the
         only instance that modifies the data.
         This data is only available if the parameter
         '/services/global-settings/collect-forward-diff' is set to true.

         If the parameter 'reverse' is given the modifications needed
         to 'reverse' the effect of the service is shown. The modifications
         are shown as if this service instance was the last service instance.
         This will be applied if the service is deleted. This data is always
         available.

         The parameter deep/shallow controls if the modifications shown
         are for this service only or for all modiefied services as well.";
      // NCS drop tailf:actionpoint
      input {
        leaf outformat {
          type live_ncs_outformat2;
        }
        leaf reverse {
          description
            "Show the modifications needed to 'reverse' the effect of
             the service.";
          type empty;
        }
        // NCS expand uses statement
        choice depth {
          leaf deep {
            type empty;
          }
          leaf shallow {
            type empty;
          }
          default "deep";
        }
        uses live_ncs_choice-lsa-grouping;
      }
      output {
        choice outformat {
          case case-xml {
            uses live_ncs_service-modifications-xml;
          }
          case case-cli {
            uses live_ncs_service-modifications-cli;
          }
        }
      }
    }
  }

  grouping live_ncs_service-customer-service {
    leaf-list used-by-customer-service {
      tailf:info
        "Customer facing services using this service";
      type leafref {
        path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/ncs:services/ncs:customer-service/ncs:object-id" {
          tailf:xpath-root 3;
        }
      }
      // NCS drop tailf:callpoint
    }
  }

  grouping live_ncs_service-depth {
    choice depth {
      leaf deep {
        type empty;
      }
      leaf shallow {
        type empty;
      }
      // NCS drop default statement
    }
  }

  grouping live_ncs_service-modifications-xml {
    container result-xml {
      container local-node {
        anyxml data;
      }
      list lsa-service {
        key "service-id";
        leaf service-id {
          // NCS patched to string, due to LSA partial NED
          type string;
        }
        anyxml data;
      }
    }
  }

  grouping live_ncs_service-modifications-cli {
    container cli {
      container local-node {
        leaf data {
          tailf:cli-preformatted;
          type string;
        }
      }
      list lsa-service {
        key "service-id";
        leaf service-id {
          // NCS patched to string, due to LSA partial NED
          type string;
        }
        leaf data {
          tailf:cli-preformatted;
          type string;
        }
      }
    }
  }

  grouping live_ncs_service-sync {
    container sync-result {
      container local-node {
        leaf in-sync {
          type boolean;
        }
      }
      list lsa-service {
        key "service-id";
        leaf service-id {
          // NCS patched to string, due to LSA partial NED
          type string;
        }
        leaf in-sync {
          type boolean;
        }
      }
    }
  }

  grouping live_ncs_choice-lsa-grouping {
    choice choice-lsa {
      leaf use-lsa {
        type empty;
        description
          "Force handling LSA nodes as such.";
      }
      leaf no-lsa {
        type empty;
        description
          "Do not handle any of the LSA nodes as such. These nodes
           will be handled as any other device.";
      }
    }
  }

  grouping service-data {
    description
      "Use this grouping together with ncs:servicepoint
       in order to get the common definitions for a service
       implemented by a callback function.";
    // NCS drop tailf:callpoint
    uses service-check-sync;
    uses service-deep-check-sync;
    uses service-re-deploy;
    uses service-reactive-re-deploy;
    uses service-touch;
    uses service-impacted-devices;
    uses service-un-deploy;
    uses service-customer-service;
    uses service-commit-queue;
    uses service-private-data;
    uses service-plan-location;
    uses log-data;
  }

  grouping service-plan-location {
    // NCS drop config false leaf 'plan-location'
  }

  grouping service-commit-queue {
    // NCS drop config false container 'commit-queue'
  }

  grouping service-un-deploy {
    tailf:action un-deploy {
      tailf:actionpoint ncsproxy {
        tailf:internal;
      }
      description
        "Undo the effects of the service instance but keep the
         service itself. The service can later be re-deployed. This is
         a means to deactivate a service, but keeping it in the system.";
      tailf:info
        "Undo the effects of the service";
      // NCS drop tailf:actionpoint
      input {
        container dry-run {
          presence "";
          leaf outformat {
            type outformat3;
          }
        }
        uses ncs-commit-params;
        leaf ignore-refcount {
          type empty;
          description
            "Unconditionally delete the device data created by the
             service, regardless of the refcount.";
        }
      }
      output {
        choice outformat {
          case case-xml {
            uses dry-run-xml;
          }
          case case-cli {
            uses dry-run-cli;
          }
          case case-native {
            uses dry-run-native;
          }
        }
        uses ncs-commit-result;
      }
    }
  }

  grouping service-private-data {
    container private {
      ncs:ncs-service-private;
      description
        "NCS service related internal data stored here.";
      tailf:hidden "fastmap-private";
      // NCS drop fully hidden leaf 'diff-set'
      // NCS drop fully hidden leaf 'forward-diff-set'
      // NCS drop fully hidden leaf-list 'device-list'
      // NCS drop fully hidden leaf-list 'ned-id-list'
      // NCS drop fully hidden leaf-list 'service-list'
      // NCS drop fully hidden leaf-list 'lsa-service-list'
      container property-list {
        description
          "FASTMAP service instance data used by the service implementation.";
        list property {
          key "name";
          leaf name {
            type string;
          }
          leaf value {
            type string;
          }
        }
      }
      leaf re-deploy-counter {
        type int32;
        default "0";
      }
      // NCS drop fully hidden leaf 'latest-commit-params'
      // NCS drop fully hidden leaf 'latest-u-info'
    }
  }

  grouping service-check-sync {
    tailf:action check-sync {
      tailf:actionpoint ncsproxy {
        tailf:internal;
      }
      tailf:info
        "Check if device config is according to the service";
      description
        "Check if the service has been undermined, i.e., if the service
         was to be re-deployed, would it do anything. This action will
         invoke the FASTMAP code to create the change set that is compared
         to the existing data in CDB locally.

         If outformat is boolean, 'true' is returned if the service is
         in sync, i.e., a re-deploy would do nothing. If outformat is
         cli or xml, the changes that the service would do to the
         network if re-deployed are returned.";
      // NCS drop tailf:actionpoint
      input {
        leaf outformat {
          type outformat4;
          default "boolean";
        }
        // NCS expand uses statement
        choice depth {
          leaf deep {
            type empty;
          }
          leaf shallow {
            type empty;
          }
          default "deep";
        }
        leaf suppress-positive-result {
          type empty;
          tailf:info
            "Return list only contains negatives";
          description
            "Use this additional parameter to only return services that
             failed to sync.";
        }
        uses choice-lsa-grouping;
      }
      output {
        choice outformat {
          leaf in-sync {
            type boolean;
          }
          case case-xml {
            uses dry-run-xml;
          }
          case case-cli {
            uses dry-run-cli;
          }
          case case-native {
            uses dry-run-native;
          }
        }
      }
    }
  }

  grouping service-deep-check-sync {
    tailf:action deep-check-sync {
      tailf:actionpoint ncsproxy {
        tailf:internal;
      }
      tailf:info
        "Check if device config is according to the service";
      description
        "Check if the service has been undermined on the device itself.
         The action 'check-sync' compares the output of the service
         code to what is stored in CDB locally. This action retrieves the
         configuration from the devices touched by the service and compares
         the forward diff set of the service to the retrieved data. This
         is thus a fairly heavy weight operation. As opposed to the check-sync
         action that invokes the FASTMAP code, this action re-applies the
         forward diff-set. This is the same output you see when inspecting
         the 'get-modifications' operational field in the service instance.

         If the device is in sync with CDB, the output of this action
         is identical to the output of the cheaper check-sync action";
      // NCS drop tailf:actionpoint
      input {
        leaf outformat {
          type outformat-deep-check-sync;
          default "boolean";
        }
        leaf suppress-positive-result {
          type empty;
          tailf:info
            "Return list only contains negatives";
          description
            "Use this additional parameter to only return services that
             failed to sync.";
        }
        uses choice-lsa-grouping;
        uses wait-for-lock;
      }
      output {
        choice outformat {
          case case-xml {
            uses service-modifications-xml;
          }
          case case-cli {
            uses service-modifications-cli;
          }
          case case-sync {
            uses service-sync;
          }
        }
      }
    }
  }

  grouping service-re-deploy {
    tailf:action re-deploy {
      tailf:actionpoint ncsproxy {
        tailf:internal;
      }
      tailf:info
        "Run/Dry-run the service logic again";
      description
        "Run the service code again, possibly writing the changes of
         the service to the network once again.

         If the dry-run option is used,
         the action simply reports (in different formats) what it would do.

         Use the option 'reconcile' if the service should reconcile
         original data, i.e., take control of that data. This option
         acknowledges other services controlling the same data.";
      // NCS drop tailf:actionpoint
      input {
        container dry-run {
          presence "";
          leaf outformat {
            type outformat3;
          }
        }
        uses ncs-commit-params;
        // NCS expand uses statement
        choice depth {
          leaf deep {
            type empty;
          }
          leaf shallow {
            type empty;
          }
          default "deep";
        }
        container reconcile {
          description
            "Reconcile the service data. All data which existed before
             the service was created will now be owned by the service.
             The reference count will indicate how many services control
             the data. When the service is removed that data will also be
             removed. In technical terms the reference count will be
             decreased by one for everything which existed prior to the
             service.

             If manually configured data exists below in the configuration
             tree that data is kept unless the option
             'discard-non-service-config' is used.";
          presence "";
          choice c-non-service-config {
            leaf keep-non-service-config {
              type empty;
            }
            leaf discard-non-service-config {
              type empty;
            }
            default "keep-non-service-config";
          }
        }
      }
      output {
        choice outformat {
          case case-xml {
            uses dry-run-xml;
          }
          case case-cli {
            uses dry-run-cli;
          }
          case case-native {
            uses dry-run-native;
          }
        }
        uses ncs-commit-result;
      }
    }
  }

  grouping service-reactive-re-deploy {
    tailf:action reactive-re-deploy {
      tailf:actionpoint ncsproxy {
        tailf:internal;
      }
      tailf:info
        "Reactive re-deploy of service logic";
      description
        "This is a tailored re-deploy intended to be used in the reactive
         FASTMAP scenario. It differs from the ordinary re-deploy in that
         this action does not take any commit parameters.

         This action will re-deploy the services as an
         'shallow' depth re-deploy. It will be performed with the same
         user as the original commit. Also, the commit parameters will be
         identical to the latest commit involving this service.

         By default this action is asynchronous and returns nothing.";
      // NCS drop tailf:actionpoint
      input {
        leaf sync {
          description
            "By default the action is asynchronous, i.e. it does not wait for
             the service to be re-deployed. Use this leaf to get synchronous
             behaviour and block until the service re-deploy transaction is
             committed. It also means that the action will possibly return
             a commit result, such as commit queue id if any, or an
             error if the transaction failed.";
          type empty;
        }
      }
      output {
        uses ncs-commit-result;
      }
    }
  }

  grouping service-touch {
    tailf:action touch {
      tailf:actionpoint ncsproxy {
        tailf:internal;
      }
      tailf:info
        "Mark the service as changed";
      tailf:cli-configure-mode;
      description
        "This action marks the service as changed.

         Executing the action touch followed by a commit is the same as
         executing the action 're-deploy shallow'.

         By using the action 'touch' several re-deploys can be performed
         in the same transaction.";
      // NCS drop tailf:actionpoint
      input;
      output;
    }
  }

  grouping service-impacted-devices {
    // NCS drop config false container modified
    // NCS drop config false container 'directly-modified'
    uses service-get-modifications;
  }

  grouping service-get-modifications {
    tailf:action get-modifications {
      tailf:actionpoint ncsproxy {
        tailf:internal;
      }
      tailf:info
        "Get the data this service created";
      description
        "Returns the data the service modified, either
         in CLI curly bracket format, or NETCONF XML edit-config format.
         The modifications are shown as if the service instance was the
         only instance that modifies the data.
         This data is only available if the parameter
         '/services/global-settings/collect-forward-diff' is set to true.

         If the parameter 'reverse' is given the modifications needed
         to 'reverse' the effect of the service is shown. The modifications
         are shown as if this service instance was the last service instance.
         This will be applied if the service is deleted. This data is always
         available.

         The parameter deep/shallow controls if the modifications shown
         are for this service only or for all modiefied services as well.";
      // NCS drop tailf:actionpoint
      input {
        leaf outformat {
          type outformat2;
        }
        leaf reverse {
          description
            "Show the modifications needed to 'reverse' the effect of
             the service.";
          type empty;
        }
        // NCS expand uses statement
        choice depth {
          leaf deep {
            type empty;
          }
          leaf shallow {
            type empty;
          }
          default "deep";
        }
        uses choice-lsa-grouping;
      }
      output {
        choice outformat {
          case case-xml {
            uses service-modifications-xml;
          }
          case case-cli {
            uses service-modifications-cli;
          }
        }
      }
    }
  }

  grouping service-customer-service {
    // NCS drop config false leaf-list 'used-by-customer-service'
  }

  grouping service-depth {
    choice depth {
      leaf deep {
        type empty;
      }
      leaf shallow {
        type empty;
      }
      default "deep";
    }
  }

  grouping service-modifications-xml {
    container result-xml {
      container local-node {
        anyxml data;
      }
      list lsa-service {
        key "service-id";
        leaf service-id {
          // NCS patched to string, due to LSA partial NED
          type string;
        }
        anyxml data;
      }
    }
  }

  grouping service-modifications-cli {
    container cli {
      container local-node {
        leaf data {
          tailf:cli-preformatted;
          type string;
        }
      }
      list lsa-service {
        key "service-id";
        leaf service-id {
          // NCS patched to string, due to LSA partial NED
          type string;
        }
        leaf data {
          tailf:cli-preformatted;
          type string;
        }
      }
    }
  }

  grouping service-sync {
    container sync-result {
      container local-node {
        leaf in-sync {
          type boolean;
        }
      }
      list lsa-service {
        key "service-id";
        leaf service-id {
          // NCS patched to string, due to LSA partial NED
          type string;
        }
        leaf in-sync {
          type boolean;
        }
      }
    }
  }

  grouping choice-lsa-grouping {
    choice choice-lsa {
      leaf use-lsa {
        type empty;
        description
          "Force handling LSA nodes as such.";
      }
      leaf no-lsa {
        type empty;
        description
          "Do not handle any of the LSA nodes as such. These nodes
           will be handled as any other device.";
      }
    }
  }

  augment "/ncs-internal:devices/ncs-internal:device/ncs-internal:notifications/ncs-internal:received-notifications/ncs-internal:notification/ncs-internal:data" {
    container service-commit-queue-event {
      presence "";
      config false;
      description
        "When a service is committed through the commit queue, this
         notification act as a reference regarding the state of the
         service.

         This notification is not sent unless the system has been
         configured to send the notification for the service type.";
      leaf service {
        // NCS patched to string, due to LSA partial NED
        type string;
        // NCS drop mandatory statement
        description
          "A reference to the service.";
      }
      leaf id {
        type uint64;
        // NCS drop mandatory statement
        description
          "If the queue item in the commit queue refers to this service
           this is the queue number.";
      }
      leaf tag {
        type string;
        description
          "Opaque tag set in the commit.";
      }
      leaf status {
        type ncs_rpc_notif_commit-queue-item-event-status;
        // NCS drop mandatory statement
      }
      leaf trace-id {
        type string;
        description
          "The trace id assigned to the commit.";
      }
    }
  }
  augment "/ncs-internal:devices/ncs-internal:device/ncs-internal:netconf-notifications/ncs-internal:received-notifications/ncs-internal:notification/ncs-internal:data" {
    container service-commit-queue-event {
      presence "";
      config false;
      description
        "When a service is committed through the commit queue, this
         notification act as a reference regarding the state of the
         service.

         This notification is not sent unless the system has been
         configured to send the notification for the service type.";
      leaf service {
        // NCS patched to string, due to LSA partial NED
        type string;
        // NCS drop mandatory statement
        description
          "A reference to the service.";
      }
      leaf id {
        type uint64;
        // NCS drop mandatory statement
        description
          "If the queue item in the commit queue refers to this service
           this is the queue number.";
      }
      leaf tag {
        type string;
        description
          "Opaque tag set in the commit.";
      }
      leaf status {
        type ncs_rpc_notif_commit-queue-item-event-status;
        // NCS drop mandatory statement
      }
      leaf trace-id {
        type string;
        description
          "The trace id assigned to the commit.";
      }
    }
  }
  augment "/ncs-internal:devices/ncs-internal:device/ncs-internal:config" {
    container services {
      tailf:ncs-device-type "netconf";
      tailf:display-when "not(../../ncs-internal:module) or ../../ncs-internal:module[ncs-internal:name='tailf-ncs']";
      tailf:info
        "The services managed by NCS";
      description
        "The services managed by NCS.";
      container global-settings {
        leaf collect-forward-diff {
          tailf:info
            "Toggle the collection of service data";
          description
            "When creating a service instance we can choose to also
             collect the forward diff.  I.e., remember what the service
             did.  This drives the formatting of the runtime statistics
             'get-modifications' for a service.  We always collect the
             reverse for a service instance, that is the basis for the
             FASTMAP algoritm.  This consumes quite a bit of extra
             memory per service instance, so if we have huge amounts of
             services it may be worthwhile to turn this off.";
          type boolean;
          default "false";
        }
        leaf service-callback-timeout {
          tailf:info
            "How long before a service callback will timeout";
          type int32;
          units "seconds";
          default "120";
          description
            "How long before a service callback, i.e. pre-modification,
             create and post-modification, will timeout.";
        }
      }
      tailf:action check-sync {
        tailf:actionpoint ncsproxy {
          tailf:internal;
        }
        tailf:info
          "Check if device configuration is according to the services";
        description
          "Check if any service has been undermined, i.e., if a service was
           to be re-deployed, would it do anything.";
        // NCS drop tailf:actionpoint
        input {
          leaf suppress-positive-result {
            type empty;
            tailf:info
              "Return list only contains negatives";
            description
              "Use this additional parameter to only return services that
               failed to sync.";
          }
          uses choice-lsa-grouping;
        }
        output {
          list sync-result {
            leaf service-id {
              type string;
            }
            leaf in-sync {
              type boolean;
            }
          }
        }
      }
      container properties {
        tailf:info
          "Properties used when creating services";
        description
          "This is a placeholder for where additional service properties
           can be augmented.";
      }
      list customer-service {
        tailf:info
          "Service that can be linked to customer";
        key "object-id";
        reference
          "TMForumPhaseVIII::SID Phase VIII::Service Domain::Service
             ABE::Customer Facing Service";
        leaf object-id {
          tailf:info
            "Customer facing service";
          type string;
          reference "Service ABE::objectId";
        }
        leaf reference {
          type string;
          reference "Service ABE::description";
        }
        leaf customer {
          tailf:info
            "The customer";
          type leafref {
            path "/ncs-internal:devices/ncs-internal:device/ncs-internal:config/ncs:customers/ncs:customer/ncs:id" {
              tailf:xpath-root 3;
            }
          }
          description
            "Customer for this service.";
        }
        list service {
          tailf:info
            "List of resource facing services";
          key "service-id";
          description
            "Resource facing services for this service.";
          leaf service-id {
            tailf:info
              "The resource facing service";
            // NCS patched to string, due to LSA partial NED
            type string;
            description
              "Must refer to a resource facing service instance.";
          }
        }
        container properties {
          tailf:info
            "Augmented properties for customer services";
          description
            "This container can be used whenever you want to extend the
             customer service properties with additional proprietary
             information.";
        }
      }
      list service {
        tailf:info
          "List of resource facing services";
        key "object-id";
        reference
          "TMForumPhaseVIII::SID Phase VIII::Service
             Domain::Service ABE::Resource Facing Service";
        leaf object-id {
          tailf:info
            "Unique service id";
          tailf:cli-allow-range;
          type string;
          reference "Service ABE::objectId";
        }
        leaf reference {
          type string;
          reference "Service ABE::description";
        }
        container properties {
          tailf:info
            "Additional service properties";
          description
            "This container can be used whenever you want to extend the
             resource service properties with additional proprietary
             information.";
        }
        container type {
          tailf:info
            "The service types";
          choice service-type-choice {
            description
              "This choice is augmented by service instances such
               as MPLS VPN.";
          }
        }
      }
      container logging {
        tailf:info
          "Configure service logging";
        leaf max-size {
          type union {
            type enumeration {
              enum "unlimited";
            }
            type uint32 {
              range "1 .. max";
            }
          }
          default "50";
          description
            "Max size of the list of log entries. When the maximum size
             is reached, the oldest log entry is purged.";
        }
        list logger {
          key "name";
          unique "service-type log-entry-level";
          description
            "NCS or user specific code may choose to populate a log entry
             to indicate important events associated with it.

             Each entry in this list holds one representation of a
             service logger. Log entries matching the given service type,
             log entry type and log entry level will be logged in the log
             container under the service type instance.";
          leaf name {
            type string;
            description
              "A unique identifier for this logger.";
          }
          leaf service-type {
            type tailf:node-instance-identifier;
            tailf:cli-completion-actionpoint servicepoints;
            description
              "The type of service. If not set, all service types are
               logged.";
          }
          leaf-list log-entry-type {
            description
              "The types of log entry to be logged. If not set, all
               log entry types are logged.";
            type log-entry-t;
          }
          leaf log-entry-level {
            description
              "Log level for this log entry type. Configuring this level
               will cause log entries of that level and those that are
               more specific to be logged.";
            type log-entry-level-t;
            mandatory true;
          }
          leaf max-size {
            type union {
              type enumeration {
                enum "unlimited";
              }
              type uint32 {
                range "1 .. max";
              }
            }
            description
              "Max size of the list of log entries. When the maximum size
               is reached, the oldest log entry is purged. If not set it
               defaults to /services/logging/max-size";
          }
        }
      }
      container commit-queue-notifications {
        description
          "Configuration to send service-commit-queue-event notifications.

           The built in stream 'service-state-changes' is used to send
           these notifications.";
        list subscription {
          key "name";
          unique "service-type";
          description
            "A list of our commit queue notification subscriptions.";
          leaf name {
            type string;
            description
              "A unique identifier for this subscription.";
          }
          leaf service-type {
            type tailf:node-instance-identifier;
            tailf:cli-completion-actionpoint servicepoints;
            description
              "The type of service. If not set, all service types are
               subscribed.";
          }
        }
      }
    }
  }
  augment "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status" {
    container services {
      tailf:ncs-device-type "netconf";
      tailf:display-when "not(../../ncs-internal:module) or ../../ncs-internal:module[ncs-internal:name='tailf-ncs'] or (../../ncs-internal:live-status-protocol[not(ncs-internal:capability)]) or (../../ncs-internal:live-status-protocol/ncs-internal:capability/ncs-internal:module[.='tailf-ncs'])";
      tailf:info
        "The services managed by NCS";
      description
        "The services managed by NCS.";
      container global-settings {
        leaf collect-forward-diff {
          tailf:info
            "Toggle the collection of service data";
          description
            "When creating a service instance we can choose to also
             collect the forward diff.  I.e., remember what the service
             did.  This drives the formatting of the runtime statistics
             'get-modifications' for a service.  We always collect the
             reverse for a service instance, that is the basis for the
             FASTMAP algoritm.  This consumes quite a bit of extra
             memory per service instance, so if we have huge amounts of
             services it may be worthwhile to turn this off.";
          type boolean;
          // NCS drop default statement
        }
        leaf service-callback-timeout {
          tailf:info
            "How long before a service callback will timeout";
          type int32;
          units "seconds";
          // NCS drop default statement
          description
            "How long before a service callback, i.e. pre-modification,
             create and post-modification, will timeout.";
        }
      }
      tailf:action check-sync {
        tailf:actionpoint ncsproxy {
          tailf:internal;
        }
        tailf:info
          "Check if device configuration is according to the services";
        description
          "Check if any service has been undermined, i.e., if a service was
           to be re-deployed, would it do anything.";
        // NCS drop tailf:actionpoint
        input {
          leaf suppress-positive-result {
            type empty;
            tailf:info
              "Return list only contains negatives";
            description
              "Use this additional parameter to only return services that
               failed to sync.";
          }
          uses live_ncs_choice-lsa-grouping;
        }
        output {
          list sync-result {
            leaf service-id {
              type string;
            }
            leaf in-sync {
              type boolean;
            }
          }
        }
      }
      container properties {
        tailf:info
          "Properties used when creating services";
        description
          "This is a placeholder for where additional service properties
           can be augmented.";
      }
      list customer-service {
        tailf:info
          "Service that can be linked to customer";
        key "object-id";
        reference
          "TMForumPhaseVIII::SID Phase VIII::Service Domain::Service
             ABE::Customer Facing Service";
        leaf object-id {
          tailf:info
            "Customer facing service";
          type string;
          reference "Service ABE::objectId";
        }
        leaf reference {
          type string;
          reference "Service ABE::description";
        }
        leaf customer {
          tailf:info
            "The customer";
          type leafref {
            path "/ncs-internal:devices/ncs-internal:device/ncs-internal:live-status/ncs:customers/ncs:customer/ncs:id" {
              tailf:xpath-root 3;
            }
          }
          description
            "Customer for this service.";
        }
        list service {
          tailf:info
            "List of resource facing services";
          key "service-id";
          description
            "Resource facing services for this service.";
          leaf service-id {
            tailf:info
              "The resource facing service";
            // NCS patched to string, due to LSA partial NED
            type string;
            description
              "Must refer to a resource facing service instance.";
          }
        }
        container properties {
          tailf:info
            "Augmented properties for customer services";
          description
            "This container can be used whenever you want to extend the
             customer service properties with additional proprietary
             information.";
        }
      }
      list service {
        tailf:info
          "List of resource facing services";
        key "object-id";
        reference
          "TMForumPhaseVIII::SID Phase VIII::Service
             Domain::Service ABE::Resource Facing Service";
        leaf object-id {
          tailf:info
            "Unique service id";
          // NCS drop tailf:cli-allow-range
          type string;
          reference "Service ABE::objectId";
        }
        leaf reference {
          type string;
          reference "Service ABE::description";
        }
        container properties {
          tailf:info
            "Additional service properties";
          description
            "This container can be used whenever you want to extend the
             resource service properties with additional proprietary
             information.";
        }
        container type {
          tailf:info
            "The service types";
          choice service-type-choice {
            description
              "This choice is augmented by service instances such
               as MPLS VPN.";
          }
        }
      }
      container logging {
        tailf:info
          "Configure service logging";
        leaf max-size {
          type union {
            type enumeration {
              enum "unlimited";
            }
            type uint32 {
              range "1 .. max";
            }
          }
          // NCS drop default statement
          description
            "Max size of the list of log entries. When the maximum size
             is reached, the oldest log entry is purged.";
        }
        list logger {
          key "name";
          unique "service-type log-entry-level";
          description
            "NCS or user specific code may choose to populate a log entry
             to indicate important events associated with it.

             Each entry in this list holds one representation of a
             service logger. Log entries matching the given service type,
             log entry type and log entry level will be logged in the log
             container under the service type instance.";
          leaf name {
            type string;
            description
              "A unique identifier for this logger.";
          }
          leaf service-type {
            type tailf:node-instance-identifier;
            // NCS drop tailf:cli-completion-actionpoint
            description
              "The type of service. If not set, all service types are
               logged.";
          }
          leaf-list log-entry-type {
            description
              "The types of log entry to be logged. If not set, all
               log entry types are logged.";
            type live_ncs_log-entry-t;
          }
          leaf log-entry-level {
            description
              "Log level for this log entry type. Configuring this level
               will cause log entries of that level and those that are
               more specific to be logged.";
            type live_ncs_log-entry-level-t;
            // NCS drop mandatory statement
          }
          leaf max-size {
            type union {
              type enumeration {
                enum "unlimited";
              }
              type uint32 {
                range "1 .. max";
              }
            }
            description
              "Max size of the list of log entries. When the maximum size
               is reached, the oldest log entry is purged. If not set it
               defaults to /services/logging/max-size";
          }
        }
      }
      container commit-queue-notifications {
        description
          "Configuration to send service-commit-queue-event notifications.

           The built in stream 'service-state-changes' is used to send
           these notifications.";
        list subscription {
          key "name";
          unique "service-type";
          description
            "A list of our commit queue notification subscriptions.";
          leaf name {
            type string;
            description
              "A unique identifier for this subscription.";
          }
          leaf service-type {
            type tailf:node-instance-identifier;
            // NCS drop tailf:cli-completion-actionpoint
            description
              "The type of service. If not set, all service types are
               subscribed.";
          }
        }
      }
    }
  }
  augment "/ncs-internal:devices/ncs-internal:template/ncs-internal:ned-id/ncs-internal:config" {
    container services {
      description
        "The services managed by NCS.";
      container global-settings {
        leaf collect-forward-diff {
          description
            "When creating a service instance we can choose to also
             collect the forward diff.  I.e., remember what the service
             did.  This drives the formatting of the runtime statistics
             'get-modifications' for a service.  We always collect the
             reverse for a service instance, that is the basis for the
             FASTMAP algoritm.  This consumes quite a bit of extra
             memory per service instance, so if we have huge amounts of
             services it may be worthwhile to turn this off.";
          type string;
          // NCS drop default statement
        }
        leaf service-callback-timeout {
          type string;
          units "seconds";
          // NCS drop default statement
          description
            "How long before a service callback, i.e. pre-modification,
             create and post-modification, will timeout.";
        }
      }
      container properties {
        description
          "This is a placeholder for where additional service properties
           can be augmented.";
      }
      list customer-service {
        // NCS patched for predictable order
        ordered-by user;
        key "object-id";
        reference
          "TMForumPhaseVIII::SID Phase VIII::Service Domain::Service
             ABE::Customer Facing Service";
        leaf object-id {
          type string;
          reference "Service ABE::objectId";
        }
        leaf reference {
          type string;
          reference "Service ABE::description";
        }
        leaf customer {
          type string;
          description
            "Customer for this service.";
        }
        list service {
          // NCS patched for predictable order
          ordered-by user;
          key "service-id";
          description
            "Resource facing services for this service.";
          leaf service-id {
            type string;
            description
              "Must refer to a resource facing service instance.";
          }
        }
        container properties {
          description
            "This container can be used whenever you want to extend the
             customer service properties with additional proprietary
             information.";
        }
      }
      list service {
        // NCS patched for predictable order
        ordered-by user;
        key "object-id";
        reference
          "TMForumPhaseVIII::SID Phase VIII::Service
             Domain::Service ABE::Resource Facing Service";
        leaf object-id {
          type string;
          reference "Service ABE::objectId";
        }
        leaf reference {
          type string;
          reference "Service ABE::description";
        }
        container properties {
          description
            "This container can be used whenever you want to extend the
             resource service properties with additional proprietary
             information.";
        }
        container type {
          choice service-type-choice {
            description
              "This choice is augmented by service instances such
               as MPLS VPN.";
          }
        }
      }
      container logging {
        leaf max-size {
          type string;
          // NCS drop default statement
          description
            "Max size of the list of log entries. When the maximum size
             is reached, the oldest log entry is purged.";
        }
        list logger {
          // NCS patched for predictable order
          ordered-by user;
          key "name";
          unique "service-type log-entry-level";
          description
            "NCS or user specific code may choose to populate a log entry
             to indicate important events associated with it.

             Each entry in this list holds one representation of a
             service logger. Log entries matching the given service type,
             log entry type and log entry level will be logged in the log
             container under the service type instance.";
          leaf name {
            type string;
            description
              "A unique identifier for this logger.";
          }
          leaf service-type {
            type string;
            description
              "The type of service. If not set, all service types are
               logged.";
          }
          leaf-list log-entry-type {
            // NCS patched for predictable order
            ordered-by user;
            description
              "The types of log entry to be logged. If not set, all
               log entry types are logged.";
            type ncs_template_log-entry-t;
          }
          leaf log-entry-level {
            description
              "Log level for this log entry type. Configuring this level
               will cause log entries of that level and those that are
               more specific to be logged.";
            type ncs_template_log-entry-level-t;
            // NCS drop mandatory statement
          }
          leaf max-size {
            type string;
            description
              "Max size of the list of log entries. When the maximum size
               is reached, the oldest log entry is purged. If not set it
               defaults to /services/logging/max-size";
          }
        }
      }
      container commit-queue-notifications {
        description
          "Configuration to send service-commit-queue-event notifications.

           The built in stream 'service-state-changes' is used to send
           these notifications.";
        list subscription {
          // NCS patched for predictable order
          ordered-by user;
          key "name";
          unique "service-type";
          description
            "A list of our commit queue notification subscriptions.";
          leaf name {
            type string;
            description
              "A unique identifier for this subscription.";
          }
          leaf service-type {
            type string;
            description
              "The type of service. If not set, all service types are
               subscribed.";
          }
        }
      }
    }
  }

  extension ncs-service-private {
    tailf:use-in "container";
    description
      "Used internally to mark service private data.";
  }

  extension lsa-service {
    tailf:use-in "list";
    tailf:use-in "container";
    tailf:substatement "description";
    description
      "This extension indicates that the node it appears on is
       the top node of an NCS service on a remote NCS node in
       LSA architecture.";
  }

  extension servicepoint {
    argument id {
      tailf:arg-type {
        type tailf:identifier;
      }
    }
    tailf:use-in "list";
    tailf:use-in "container";
    tailf:use-in "grouping";
    tailf:substatement "description";
    tailf:substatement "tailf:opaque";
    tailf:substatement "tailf:internal";
    description
      "This statement marks the list or container in which it appears
       to be used as service parameters for a service implemented
       by a callback in a data provider.";
  }
}
