// =========================================================================
//                          CISCO-NX NED
// =========================================================================

module tailf-ned-cisco-nx {
  namespace "http://tail-f.com/ned/cisco-nx";
  prefix nx;

  import tailf-common {
    prefix tailf;
  }

  import ietf-inet-types {
    prefix inet;
  }

  import cliparser-extensions-v11 {
    prefix cli;
  }

  // =========================================================================
  // REVISION
  // =========================================================================

  revision 2022-01-12 {
    description "version 5.22.8, see CHANGES";
  }

  cli:module-meta-data {
    cli:forced-when-eval-in-path "/interface/[^/]+/ipv6/(address|have-secondary-address)";
    nx:before-exit-configure;
  }

  // =========================================================================
  // TYPEDEF
  // =========================================================================

// NOTE: This is to be able to run yang with/without ypp
//#if (1 == 0)
  typedef NEDCOM_SECRET_TYPE {
    type string;
  }
//#endif

  typedef ip-mask {
    type string {
      pattern
        '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}'
        + '([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'
             + '/(([0-9])|([1-2][0-9])|(3[0-2]))';
    }
  }

  typedef mac-address-type {
    type union {
      type string {
        tailf:info "E.E.E;;MAC address (Option 1)";
        pattern "[0-9a-fA-F](\\.[0-9a-fA-F]){2}";
      }
      type string {
        tailf:info "EE-EE-EE-EE-EE-EE;;MAC address (Option 2)";
        pattern "[0-9a-fA-F]{2}(\\-[0-9a-fA-F]{2}){5}";
      }
      type string {
        tailf:info "EE:EE:EE:EE:EE:EE;;MAC address (Option 3)";
        pattern "[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}";
      }
      type string {
        tailf:info "EEEE.EEEE.EEEE;;MAC address (Option 4)";
        pattern "[0-9a-fA-F]{4}(\\.[0-9a-fA-F]{4}){2}";
      }
    }
  }

  typedef vlan-list-type {
    type uint16 {
      tailf:info "<1-4094>;;VLAN IDs of the allowed VLANs "
        +"when this port is in trunking mode";
      range "1..4094";
    }
  }

  typedef vrf-member-type {
    type union {
      type enumeration {
        enum "default" {
          tailf:info "Default VRF";
        }
        enum "management" {
          tailf:info "Management VRF";
        }
      }
      type string {
        tailf:info "WORD;;VRF name (Max Size 32)";
        length "1..32";
      }
    }
  }

  typedef dscp-type {
    type uint16 {
      tailf:info "<0-63>;;List of DSCP values";
      range "0..63";
    }
  }

  typedef dscp-value-type {
    type union {
      type uint8 {
        tailf:info "<0-63>;;Differentiated services codepoint value";
        range "0..63";
      }
      type enumeration {
        enum af11 {
          tailf:info "Match packets with AF11 dscp (001010)";
        }
        enum af12 {
          tailf:info "Match packets with AF12 dscp (001100)";
        }
        enum af13 {
          tailf:info "Match packets with AF13 dscp (001110)";
        }
        enum af21 {
          tailf:info "Match packets with AF21 dscp (010010)";
        }
        enum af22 {
          tailf:info "Match packets with AF22 dscp (010100)";
        }
        enum af23 {
          tailf:info "Match packets with AF23 dscp (010110)";
        }
        enum af31 {
          tailf:info "Match packets with AF31 dscp (011010)";
        }
        enum af32 {
          tailf:info "Match packets with AF32 dscp (011100)";
        }
        enum af33 {
          tailf:info "Match packets with AF33 dscp (011110)";
        }
        enum af41 {
          tailf:info "Match packets with AF41 dscp (100010)";
        }
        enum af42 {
          tailf:info "Match packets with AF42 dscp (100100)";
        }
        enum af43 {
          tailf:info "Match packets with AF43 dscp (100110)";
        }
        enum cs1 {
          tailf:info "Match packets with CS1(precedence 1) dscp (001000)";
        }
        enum cs2 {
          tailf:info "Match packets with CS2(precedence 2) dscp (010000)";
        }
        enum cs3 {
          tailf:info "Match packets with CS3(precedence 3) dscp (011000)";
        }
        enum cs4 {
          tailf:info "Match packets with CS4(precedence 4) dscp (100000)";
        }
        enum cs5 {
          tailf:info "Match packets with CS5(precedence 5) dscp (101000)";
        }
        enum cs6 {
          tailf:info "Match packets with CS6(precedence 6) dscp (110000)";
        }
        enum cs7 {
          tailf:info "Match packets with CS7(precedence 7) dscp (111000)";
        }
        enum default {
          tailf:info "Match packets with default dscp (000000)";
        }
        enum ef {
          tailf:info "Match packets with EF dscp (101110)";
        }
      }
    }
  }

  typedef precedence-type {
    type enumeration {
      enum critical {
        tailf:info "Match packets with critical precedence (5)";
      }
      enum flash {
        tailf:info "Match packets with flash precedence (3)";
      }
      enum flash-override {
        tailf:info "Match packets with flash override precedence (4)";
      }
      enum immediate {
        tailf:info "Match packets with immediate precedence (2)";
      }
      enum internet {
        tailf:info "Match packets with internetwork control precedence (6)";
      }
      enum network {
        tailf:info "Match packets with network control precedence (7)";
      }
      enum priority {
        tailf:info "Match packets with priority precedence (1)";
      }
      enum routine {
        tailf:info "Match packets with routine precedence (0)";
      }
    }
  }

  typedef class-name-type {
    type union {
      type enumeration {
        enum class-default {
          tailf:info "System default class matching otherwise "
            +"unclassified packet";
        }
      }
      type string {
        tailf:info "WORD;;Class map name (Max Size 64)";
        length "1..64";
      }
    }
  }

  typedef default-access-list-standard-id-type {
    type union {
      type uint8 {
        tailf:info "<1-99>;;IP Standard access list number";
        range "1..99";
      }
      type uint16 {
        tailf:info "<1300-1999>;;IP Standard expanded access list number";
        range "1300..1999";
      }
    }
  }

  typedef access-list-standard-id-type {
    type union {
      type default-access-list-standard-id-type;
      type string {
        tailf:info "WORD;;Standard access-list name";
      }
    }
  }

  typedef ospf-area-type {
    type union {
      type uint32 {
        tailf:info "<0-4294967295>;;OSPF area ID as a decimal value";
        range "0..4294967295";
      }
      type inet:ipv4-address {
        tailf:info "A.B.C.D;;OSPF area ID in IP address format";
      }
    }
  }

  typedef enable-type {
    type enumeration {
      enum "enable";
    }
  }

  typedef protocol-port-type {
    type union {
      type uint16 {
        tailf:info "<0-65535>;;Port number";
      }
      type enumeration {
        enum cmd {
          tailf:info "Remote commands (rcmd, 514)";
          value 514;
        }
        enum ftp-data {
          tailf:info "FTP data connections (20)";
          value 20;
        }
        enum ftp {
          tailf:info "File Transfer Protocol (21)";
          value 21;
        }
        enum telnet {
          tailf:info "Telnet (23)";
        }
        enum tacacs {
          tailf:info "TAC Access Control System (49)";
          value 49;
        }
        enum bootps {
          tailf:info "Bootstrap Protocol (BOOTP) server (67)";
          value 67;
        }
        enum bootpc {
          tailf:info "Bootstrap Protocol (BOOTP) client (68)";
          value 68;
        }
        enum tftp {
          tailf:info "Trivial File Transfer Protocol (69)";
          value 69;
        }
        enum ntp {
          tailf:info "Network Time Protocol (123)";
          value 123;
        }
        enum snmp {
          tailf:info "Simple Network Management Protocol (161)";
          value 161;
        }
        enum snmptrap {
          tailf:info "SNMP Traps (162)";
          value 162;
        }
        enum bgp {
          tailf:info "Border Gateway Protocol (179)";
          value 179;
        }
        enum pim-auto-rp {
          tailf:info "PIM Auto-RP (496)";
          value 496;
        }
        enum rip {
          tailf:info "Routing Information Protocol (router, in.routed, 520)";
          value 520;
        }
        enum smtp {
          tailf:info "Simple Mail Transport Protocol (25)";
        }
        enum domain {
          tailf:info "Domain Name Service (53)";
        }
        enum syslog {
          tailf:info "System Logger (514)";
        }
        enum netbios-ns {
          tailf:info "NETBIOS Name Service";
        }
        enum netbios-dgm {
          tailf:info "NETBIOS Datagram Service";
        }
        enum netbios-ss {
          tailf:info "NETBIOS Session Service";
        }
        enum time {
          tailf:info "Time (37)";
        }
        enum talk {
          tailf:info "Talk (517)";
        }
        enum biff {
          tailf:info "Biff (mail notification, comsat, 512)";
        }
        enum dnsix {
          tailf:info "DNSIX security protocol auditing (195)";
        }
        enum xdmcp {
          tailf:info "X Display Manager Control Protocol (177)";
        }
        enum who {
          tailf:info "Who service (rwho, 513)";
        }
        enum sunrpc {
          tailf:info "Sun Remote Procedure Call (111)";
        }
        enum nameserver {
          tailf:info "IEN116 name service (obsolete, 42)";
        }
        enum mobile-ip {
          tailf:info "Mobile IP registration (434)";
        }
        enum isakmp {
          tailf:info "Internet Security Association and Key Management Protocol (500)";
        }
        enum chargen {
          tailf:info "Character generator (19)";
        }
        enum daytime {
          tailf:info "Daytime (13)";
        }
        enum discard {
          tailf:info "Discard (9)";
        }
        enum drip {
          tailf:info "Dynamic Routing Information Protocol (3949)";
        }
        enum echo {
          tailf:info "Echo (7)";
        }
        enum exec {
          tailf:info "Exec (rsh, 512)";
        }
        enum finger {
          tailf:info "Finger (79)";
        }
        enum ident {
          tailf:info "Ident Protocol (113)";
        }
        enum non500-isakmp {
          tailf:info "Internet Security Association and Key Management Protocol (4500)";
        }
        enum hostname {
          tailf:info "NIC hostname server (101)";
        }
        enum irc {
          tailf:info "Internet Relay Chat (194)";
        }
        enum pop2 {
          tailf:info "Post Office Protocol v2 (109)";
        }
        enum pop3 {
          tailf:info "Post Office Protocol v3 (110)";
        }
        enum klogin {
          tailf:info "Kerberos login (543)";
        }
        enum kshell {
          tailf:info "Kerberos shell (544)";
        }
        enum login {
          tailf:info "Login (rlogin, 513)";
        }
        enum lpd {
          tailf:info "Printer service (515)";
        }
        enum uucp {
          tailf:info "Unix-to-Unix Copy Program (540)";
        }
        enum nntp {
          tailf:info "Network News Transport Protocol (119)";
        }
        enum whois {
          tailf:info "Nicname (43)";
        }
        enum www {
          tailf:info "World Wide Web (HTTP, 80)";
        }
        enum ssh {
          tailf:info "Secure SHell (22)";
        }
      }
    }
  }

  typedef word32 {
    type string {
      length "1..32";
    }
  }

  typedef word50 {
    type string {
      length "1..50";
    }
  }

  typedef asn-ip-type {
    type string {
      tailf:info "ASN2|4:NN or IPV4:NN";
      pattern '(([0-9]+)|((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'
                           +'\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]))):[0-9]+';
    }
  }

  typedef policy-map-name-type {
    type string {
      tailf:info "WORD;;Policy-map name (Max Size 40)";
      length "1..40";
    }
  }

  typedef asn-type {
    type union {
      type uint32 {
        tailf:info "<1-4294967295>;;Autonomous system number";
        range "1..4294967295";
      }
      type string {
        tailf:info "<1-65535>[.<0-65535>;;Autonomous system number";
        pattern "[0-9]+\\.[0-9]+";
      }
    }
  }

  typedef module-type {
    type enumeration {
      enum "f1" {
        tailf:info "Allow f1 modules for this VDC";
      }
      enum "f2" {
        tailf:info "Allow f2 modules for this VDC";
      }
      enum "f2e" {
        tailf:info "Allow f2e modules for this VDC";
      }
      enum "f3" {
        tailf:info "Allow f3 modules for this VDC";
      }
      enum "m1" {
        tailf:info "Allow m1 modules for this VDC";
      }
      enum "m1xl" {
        tailf:info "Allow m1xl modules for this VDC";
      }
      enum "m2xl" {
        tailf:info "Allow m2xl modules for this VDC";
      }
      enum "m3" {
        tailf:info "Allow m3 modules for this VDC";
      }
    }
  }

  typedef ospf-id-type {
    type union {
      type uint16 {
        range "1..65535";
        tailf:info "<1-65535>;;Process ID";
      }
      type string {
        tailf:info "WORD;;Process tag (Max Size 20)";
        length "1..20";
      }
    }
  }

  typedef loglevel-type {
    type uint8 {
      tailf:info "<0-7>;;0-emerg;1-alert;2-crit;3-err;4-warn;5-notif;6-inform;7-debug";
      range "0..7";
    }
  }

  typedef tcam-size-type {
    type uint32 {
      tailf:info "<0-2147483647>;;Enter tcam size";
      range "0..2147483647";
    }
  }

  typedef xfer-speed-type {
    type enumeration {
      enum bps {
        tailf:info "Bits per second";
      }
      enum kbps {
        tailf:info "Kilo Bits per second";
      }
      enum mbps {
        tailf:info "Mega Bits per second";
      }
      enum gbps {
        tailf:info "Giga Bits per second";
      }
      enum pps {
        tailf:info "Packets per second";
      }
    }
  }

  typedef burst-type {
    type enumeration {
      enum bytes {
        tailf:info "Bytes";
      }
      enum kbytes {
        tailf:info "Kilo bytes";
      }
      enum mbytes {
        tailf:info "Mega bytes";
      }
      enum ms {
        tailf:info "Milli second(s)";
      }
      enum us {
        tailf:info "Micro second(s)";
      }
      enum packets {
        tailf:info "Packets";
      }
    }
  }

  typedef comparison-type {
    type enumeration {
      enum eq {
        tailf:info "Equals";
      }
      enum ge {
        tailf:info "Greater or equal to";
      }
      enum gt {
        tailf:info "Greater than";
      }
      enum le {
        tailf:info "Less or equal to";
      }
      enum lt {
        tailf:info "Less than";
      }
      enum ne {
        tailf:info "Not equal to";
      }
    }
  }

  typedef user-role-type {
    type union {
      type enumeration {
        enum "network-admin" {
          tailf:info "System configured role";
        }
        enum "network-operator" {
          tailf:info "System configured role";
        }
        enum "priv-0" {
          tailf:info "Privilege role";
        }
        enum "priv-1" {
          tailf:info "Privilege role";
        }
        enum "priv-10" {
          tailf:info "Privilege role";
        }
        enum "priv-11" {
          tailf:info "Privilege role";
        }
        enum "priv-12" {
          tailf:info "Privilege role";
        }
        enum "priv-13" {
          tailf:info "Privilege role";
        }
        enum "priv-14" {
          tailf:info "Privilege role";
        }
        enum "priv-15" {
          tailf:info "Privilege role";
        }
        enum "priv-2" {
          tailf:info "Privilege role";
        }
        enum "priv-3" {
          tailf:info "Privilege role";
        }
        enum "priv-4" {
          tailf:info "Privilege role";
        }
        enum "priv-5" {
          tailf:info "Privilege role";
        }
        enum "priv-6" {
          tailf:info "Privilege role";
        }
        enum "priv-7" {
          tailf:info "Privilege role";
        }
        enum "priv-8" {
          tailf:info "Privilege role";
        }
        enum "priv-9" {
          tailf:info "Privilege role";
        }
        enum "san-admin" {
          tailf:info "System configured role";
        }
        enum "vdc-admin" {
          tailf:info "System configured role";
        }
        enum "vdc-operator" {
          tailf:info "System configured role";
        }
      }
      type string {
        tailf:info "WORD;;Enter the role name (Max Size 28)";
        length "1..28";
      }
    }
  }

  typedef short-month-type {
    type enumeration {
      enum Jan;
      enum Feb;
      enum Mar;
      enum Apr;
      enum May;
      enum Jun;
      enum Jul;
      enum Aug;
      enum Sep;
      enum Oct;
      enum Nov;
      enum Dec;
    }
  }

  typedef itu-t-option2-type {
    type enumeration {
      enum DUS { tailf:info "This signal should not be used for synchronization"; }
      enum EEC2 { tailf:info "ITU-T Option 2, Generation 1/2: Ethernet equipment clock"; }
      enum PROV { tailf:info "ITU-T Option 2, Generation 2: PROV"; }
      enum PRS { tailf:info "ITU-T Option 2, Generation 1/2: Primary reference source"; }
      enum PRTC { tailf:info "ITU-T Option 2, Generation 1/2: Primary reference timing clock"; }
      enum RES { tailf:info "ITU-T Option 2, Generation 1: RES"; }
      enum SMC { tailf:info "ITU-T Option 2, Generation 1/2: SONET clock self timed"; }
      enum ST2 { tailf:info "ITU-T Option 2, Generation 1/2: Stratum 2"; }
      enum ST3 { tailf:info "ITU-T Option 2, Generation 1/2: Stratum 3"; }
      enum ST3E { tailf:info "ITU-T Option 2, Generation 2: Stratum 3E"; }
      enum ST4 { tailf:info "ITU-T Option 2, Generation 1/2: Stratum 4 freerun"; }
      enum STU { tailf:info "ITU-T Option 2, Generation 1/2: Synchronized - traceability unknown"; }
      enum TNC { tailf:info "ITU-T Option 2, Generation 2: Transit node clock"; }
      enum eEEC { tailf:info "ITU-T Option 2, Generation 1/2: Enhanced ethernet equipment clock"; }
      enum ePRTC { tailf:info "ITU-T Option 2, Generation 1/2: Enhanced primary reference timing clock"; }
    }
  }


  // =========================================================================
  // GROUPING
  // =========================================================================

  grouping interface-switchport-trunk-grouping {
    container trunk {
      tailf:info "Set trunking characteristics of the interface";

      // interface * / switchport trunk native
      container native {
        tailf:info "Set trunking native characteristics when "
          +"interface is in trunking mode";
        container vlan {
          tailf:info "Set native VLAN when interface is in "
            +"trunking mode";
          leaf vlan-id {
            tailf:cli-drop-node-name;
            tailf:cli-full-command;
            tailf:cli-diff-delete-before "../../../../mode";
            tailf:cli-diff-set-after "../../../../mode";
            type uint16 {
              tailf:info "<1-3967,4048-4093>;;VLAN ID of the "
                +"native VLAN when this port is in "
                +"trunking mode";
              range "1..4095";
            }
          }
          leaf tag {
            tailf:info "Tag packets";
            tailf:cli-diff-dependency "../../../../mode";
            type empty;
          }
        }
      }
      // interface * / switchport trunk allowed
      container allowed {
        tailf:info "Set allowed VLAN characteristics when interface "+
          "is in trunking mode";
        // interface * / switchport trunk allowed vlan
        container vlan {
          tailf:info "Set allowed VLANs when interface is in trunking mode";
          tailf:cli-diff-dependency "../../../mode";
          // Note: The below extension handles add/remove keywords, also drops
          // 'add' when present in config on device (i.e. where device splits
          // range over multiple lines)
          nx:handle-allowed-vlan;
          choice vlan-choice {
            leaf none {
              tailf:info "No VLANs";
              type empty;
            }
            leaf-list ids {
              tailf:cli-drop-node-name;
              tailf:cli-range-list-syntax;
              type vlan-list-type;
            }
          }
        }
      }
    }
  }

  // interface Vethernet * / switchport
  // interface Ethernet * / switchport
  // interface port-channel * / switchport
  grouping interface-switchport-grouping {

    // interface * / no switchport
    container enable {
      tailf:cli-drop-node-name;
      leaf switchport {
        tailf:info "Enable switchport on interface";
        tailf:cli-full-no;
        tailf:cli-full-command;
        tailf:cli-boolean-no;
        cli:context-value-inject "dynamic" {
          when "/tailfned/inject-switchport-defaults='true' and not(contains(name, '.'))";
          cli:arguments "/tailfned/system-default-switchport";
        }
        type boolean;
      }
    }

    // interface * / switchport
    container switchport {
      tailf:info "Configure switchport parameters";
      tailf:cli-incomplete-no;
      tailf:cli-incomplete-command;
      // TODO:
      //        tailf:cli-diff-dependency "../../Ethernet[contains(name, '.') and contains(name, current()/../name)]" {
      //          tailf:cli-trigger-on-set;
      //        }

      // interface * / switchport mode
      choice mode-choice {
        leaf mode {
          tailf:info "Enter the port mode";
          tailf:cli-full-command;
          tailf:cli-no-value-on-delete;
          tailf:cli-trim-default;
          tailf:cli-diff-delete-before "../../enable/switchport";
          tailf:cli-diff-set-after "../../enable/switchport";
          default "access";
          type enumeration {
            enum "access" {
              tailf:code-name "mode_access";
              tailf:info "Port mode access";
            }
            // FIXME: Requires feature fex
            enum "fex-fabric" {
              tailf:info "Port mode FEX fabric";
            }
            enum "trunk" {
              tailf:code-name "mode_trunk";
              tailf:info "Port mode trunk";
            }
            enum "dot1q-tunnel" {
              tailf:info "Port mode dot1q tunnel";
            }
            enum "fabricpath" {
              tailf:info "Port mode fabricpath";
            }
          }
        }
        container private-vlan-mode {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          container mode {
            container private-vlan {
              tailf:info "Set the private VLAN configuration";
              tailf:cli-diff-delete-before "/nx:feature/private-vlan";
              choice mode-choice {
                leaf host {
                  tailf:info "Port mode pvlan host";
                  type empty;
                }
                leaf promiscuous {
                  tailf:info "Port mode pvlan promiscuous";
                  type empty;
                }
                leaf trunk {
                  tailf:info "Private-vlan trunk";
                  type enumeration {
                    enum promiscuous {
                      tailf:info "Port mode trunk promiscuous";
                    }
                    enum secondary {
                      tailf:info "Port mode trunk isolated";
                    }
                  }
                }
              }
            }
          }
        }
      }

      // interface * / switchport access
      container access {
        tailf:info "Set access mode characteristics of the "
          +"interface";
        leaf vlan {
          tailf:info "Set VLAN when interface is in access mode";
          tailf:cli-no-value-on-delete;
          type uint16 {
            tailf:info "<1-3967,4048-4093>;;VLAN ID of the "
              +"VLAN when this port is in access mode";
            range "1..4095";
          }
        }
      }

      // interface * / switchport block
      container block {
        tailf:info "Block specified outbound traffic for all VLANs";
        leaf multicast {
          tailf:info "Block mulitcast traffic";
          type empty;
        }
        leaf unicast {
          tailf:info "Block unknown unicast traffic";
          type empty;
        }
      }

      // interface * / switchport description
      leaf description {
        tailf:info "Enter description of maximum 80 characters";
        tailf:cli-multi-value;
        tailf:cli-no-value-on-delete;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE;;Description of maximum 80 characters";
          length "1..80";
        }
      }

      // interface * / switchport host
      // this leaf was removed, it's not config

      // interface * / switchport isolated
      leaf isolated {
        tailf:info "Disable loop-free detection.";
        tailf:cli-full-command;
        type empty;
      }

      // interface * / switchport monitor
      leaf monitor {
        tailf:info "Configures an interface as span-destination";
        tailf:cli-full-command;
        type empty;
      }

      // interface * / switchport trunk
      uses interface-switchport-trunk-grouping;

      leaf virtual-ethernet-bridge {
        tailf:info "Enable hair-pin forwarding";
        type empty;
      }

      container vlan {
        tailf:info "Set VLAN translation mapping";
        container mapping {
          tailf:info "VLAN translation mapping";
          leaf enable {
            tailf:info "Enable/disable VLAN translation";
            type empty;
          }
          list map {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-diff-dependency "../../../mode";
            key "from to";
            leaf from {
              type vlan-list-type;
            }
            leaf to {
              type vlan-list-type;
            }
          }
          list dot1q-map {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            tailf:cli-range-list-syntax;
            when "../../../mode = 'dot1q-tunnel' or ../../../mode = 'trunk'";
            tailf:cli-diff-dependency "../../../mode";
            key from;
            leaf from {
              tailf:cli-incomplete-command;
              type vlan-list-type;
            }
            leaf dot1q-tunnel {
              tailf:info "Selective dot1q-tunnel";
              tailf:cli-incomplete-command;
              type empty;
            }
            leaf to {
              tailf:cli-drop-node-name;
              tailf:cli-remove-before-change;
              type vlan-list-type;
            }
          }
        }
      }

      container private-vlan {
        tailf:info "Set the private VLAN configuration";
        tailf:cli-diff-delete-before "/nx:feature/private-vlan";
        tailf:cli-diff-delete-before "/nx:vlan/vlan-list/private-vlan";

        container association {
          tailf:info "Private vlan trunk association";
          list trunk {
            tailf:info "Private-vlan trunk secondary";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key primary;
            leaf primary {
              type uint16 {
                tailf:info "<1-3967>;;Primary VLAN ID";
              }
            }
            leaf secondary {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<1-3967>;;Secondary VLAN ID";
              }
            }
          }
        }
        container host-association {
          tailf:info "Set the private VLAN host association";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf primary {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<1-3967>;;Primary VLAN ID";
            }
          }
          leaf secondary {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<1-3967>;;Secondary VLAN ID";
            }
          }
        }
        container mapping {
          tailf:info "Set the private VLAN access/trunk promiscuous mapping";
          container primary-secondary {
            tailf:cli-drop-node-name;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf primary {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<1-3967>;;Primary VLAN ID";
              }
            }
            leaf-list secondarys {
              tailf:cli-drop-node-name;
              tailf:cli-range-list-syntax;
              type uint16 {
                tailf:info "<1-4094>;;Secondary VLAN IDs";
              }
            }
          }
          list trunk {
            tailf:info "Private-vlan trunk promiscuous";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key primary;
            leaf primary {
              type uint16 {
                tailf:info "<1-3967>;;Primary private VLAN";
              }
            }
            leaf-list secondarys {
              tailf:cli-drop-node-name;
              tailf:cli-range-list-syntax;
              type uint16 {
                tailf:info "<1-4094>;;Secondary VLAN IDs";
              }
            }
          }
        }
        container trunk {
          tailf:info "Set the private vlan trunking configuration";
          container native {
            tailf:info "Set the private vlan trunking native configuration";
            leaf vlan {
              tailf:info "VLAN status";
              type uint16 {
                tailf:info "<1-4094>;;VLAN IDs of the allowed VLANs when interface is in private-vlan trunking mode";
              }
            }
          }
          container allowed {
            leaf-list vlan {
              tailf:info "VLAN status";
              tailf:cli-range-list-syntax;
              tailf:cli-replace-all;
              type uint16 {
                tailf:info "<1-4094>;;VLAN IDs of the allowed VLANs when interface is in private-vlan trunking mode";
              }
            }
          }
        }
      }

      container port-security-enable {
        tailf:cli-drop-node-name;
        leaf port-security {
          tailf:info "Port security related command";
          tailf:cli-diff-dependency "/nx:feature/port-security";
          tailf:cli-full-command;
          type empty;
        }
      }

      container port-security {
        tailf:info "Port security related command";
        tailf:cli-diff-dependency "/nx:feature/port-security";
        container aging {
          tailf:info "Port-security aging commands";
          leaf time {
            tailf:info "Port-security aging time";
            default 0;
            type uint16 {
              tailf:info "<1-1440>;;Aging time in minutes. Enter a value between 1 and 1440";
            }
          }
          leaf type {
            tailf:info "Type of timers";
            default absolute;
            type enumeration {
              enum absolute { tailf:info "Absolute Timer"; }
              enum inactivity { tailf:info "Inactivity Timer"; }
            }
          }
        }
        leaf maximum {
          tailf:info "Max secure addresses";
          default 1;
          type uint16 {
            tailf:info "<1-1025>;;Maximum addresses 1 to 1025";
          }
        }
        list mac-address {
          tailf:info "MAC address";
          tailf:cli-suppress-mode;
          tailf:cli-diff-delete-before "../maximum";
          key address;
          leaf address {
            type mac-address-type;
          }
        }
        leaf violation {
          tailf:info "Security violation mode";
          default shutdown;
          type enumeration {
            enum protect { tailf:info "Security violation protect mode"; }
            enum restrict { tailf:info "Security violation restrict mode"; }
            enum shutdown { tailf:info "Security violation shutdown mode"; }
          }
        }
      }
    }
  }

  // interface fc * / switchport
  // interface san-port-channel * / switchport
  grouping interface-switchport2-grouping {

    // interface * / switchport
    container switchport {
      tailf:info "Configure switchport parameters";
      leaf "description" {
        tailf:info "Enter description of maximum 80 characters";
        tailf:cli-full-command;
        tailf:cli-multi-value;
        type string {
          length "1..80";
        }
      }
      leaf mode {
        tailf:info "Enter the port mode";
        tailf:cli-full-command;
        type enumeration {
          enum "E" {
            tailf:info "E mode";
          }
          enum "F" {
            tailf:info "F mode";
          }
          enum "SD" {
            tailf:info "SD mode";
          }
          enum "auto" {
            tailf:code-name "switchport-grouping_mode_auto";
            tailf:info "Auto mode";
          }
        }
      }

      leaf speed {
        tailf:info "Enter the port speed";
        tailf:cli-full-command;
        type enumeration {
          enum "1000" {
            tailf:code-name "switchport-grouping_1000";
            tailf:info "1000 Mbps speed";
          }
          enum "2000" {
            tailf:info "2000 Mbps speed";
          }
          enum "4000" {
            tailf:info "4000 Mbps speed";
          }
          enum "8000" {
            tailf:info "8000 Mbps speed";
          }
          enum "auto" {
            tailf:code-name "switchport-grouping_speed_auto";
            tailf:info "Auto negotiate speed";
          }
        }
      }
      container trunk {
        tailf:info "Configure trunking parameters on an interface";
        container allowed {
          tailf:info "Configure allowed list for interface(s)";
          leaf vsan {
            tailf:info "Configure allowed list for interface(s)";
            type string {
              tailf:info "<1-4093>;;VSAN id or range";
              pattern "[0-9]+(-[0-9]+)?";
            }
          }
        }
        leaf mode {
          tailf:info "Configure trunking mode";
          nx:delete-with "default";
          default on;
          type enumeration {
            enum auto {
              tailf:info "Trunk mode auto";
            }
            enum off {
              tailf:info "Trunk node off";
            }
            enum on {
              tailf:info "Trunk mode on";
            }
          }
        }
      }
    }
  }

  // interface Ethernet * /
  // interface port-channel * /
  // interface mgmt * /
  grouping interface-l2port-common-grouping {
    leaf speed {
      tailf:info "Enter the port speed";
      tailf:cli-full-command;
      default "auto";
      type enumeration {
        enum "10" {
          tailf:info "10Mb/s";
        }
        enum "100" {
          tailf:info "100Mb/s";
        }
        enum "1000" {
          tailf:info "1Gb/s";
        }
        enum "10000" {
          tailf:info "10Gb/s";
        }
        enum "40000" {
          tailf:info "40Gb/s";
        }
        enum "100000" {
          tailf:info "100Gb/s";
        }
        enum "auto" {
          tailf:info "Auto";
        }
      }
    }

    container negotiate {
      tailf:info "Configure link negotiation parameters";
      leaf auto {
        tailf:info "Configure auto-negotiation";
        tailf:cli-boolean-no;
        default true;
        type boolean;
      }
    }

    // interface * / duplex
    leaf duplex {
      tailf:info "Enter the port duplex mode";
      tailf:cli-full-command;
      type enumeration {
        enum "auto" {
          tailf:code-name "interface-port-channel-grouping-duplex_auto";
          tailf:info "Auto";
        }
        enum "full" {
          tailf:info "Full";
        }
        enum "half" {
          tailf:info "Half";
        }
      }
    }
  }

  grouping interface-common-grouping {

    // interface * / description
    leaf description {
      tailf:info "Enter description of maximum 254 characters";
      tailf:cli-full-command;
      tailf:cli-multi-value;
      tailf:cli-preformatted;
      tailf:cli-no-value-on-delete;
      nx:escape-backslash;
      type string {
        tailf:info "LINE;;Description of maximum 254 characters";
        length "1..254";
      }
    }

    // interface * / vrf
    container vrf {
      tailf:info "Configure VRF parameters";
      leaf member {
        tailf:info "Set interface's VRF membership";
        // Note: setting/resetting vrf flushes all l3 config on the interface
        // Use ned-setting 'vrf-member-l3-redeploy' to redeploy l3 settings after
        // vrf member is updated (currently on ethernet and vlan interfaces).
        tailf:cli-no-value-on-delete;
        tailf:non-strict-leafref {
          path "/nx:vrf/context/id";
        }
        type vrf-member-type;
      }
    }

    // interface * / logging
    container logging {
      tailf:info "Configure logging for interface";
      container event {
        tailf:info "Interface events";
        container port {
          tailf:info "Port level events";
          container linkstatus {
            tailf:alt-name "link-status";
            tailf:info "UPDOWN and CHANGE messages";
            presence "UPDOWN and CHANGE messages";
            leaf default {
              tailf:info "Use the global default value";
              type empty;
            }
          }
          container trunk-status {
            tailf:info "TRUNK status messages";
            presence "TRUNK status messages";
            leaf default {
              tailf:info "Use the global default value";
              type empty;
            }
          }
        }
      }
    }

    // interface * / ip
    container ip {
      tailf:info "Configure IP features";
      nx:data-category "layer3";
      tailf:cli-diff-delete-before "../vrf/member";
      // interface * / ip forward
      leaf forward {
        tailf:info "IP forward";
        tailf:cli-diff-dependency "../address" {
          tailf:cli-trigger-on-set;
        }
        type empty;
      }

      // interface * / ip access-group * in
      // interface * / ip access-group * out
      list access-group {
        tailf:info "Specify access control for packets";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key direction;
        leaf name {
          tailf:cli-prefix-key;
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;List name (Max Size 64)";
            length "1..64";
          }
        }
        leaf direction {
          type enumeration {
            enum "in" {
              tailf:info "Inbound packets";
            }
            enum "out" {
              tailf:info "Outbound packets";
            }
          }
        }
      }

      // interface * / ip address
      choice static-or-dynamic {
        case static {
          container address {
            tailf:info "Configure IP address on interface";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            tailf:cli-diff-dependency "../forward" {
              tailf:cli-trigger-on-set;
            }
            leaf ipaddr {
              tailf:cli-drop-node-name;
              tailf:cli-reset-container;
              type ip-mask {
                tailf:info "A.B.C.D/LEN;;IP prefix and network mask length "
                  +"in format x.x.x.x/m";
              }
            }
            // interface * / ip address * tag
            leaf tag {
              tailf:info "URIB route tag value for local/direct routes";
              type uint32 {
                tailf:info "<0-4294967295>;;Local/direct tag value";
                range "0..4294967295";
              }
            }
          }
          container secondary-addr {
            tailf:cli-drop-node-name;
            tailf:cli-diff-dependency "../address";
            tailf:cli-diff-delete-before "../address";
            list address {
              tailf:info "Configure IP address on interface";
              tailf:cli-suppress-mode;
              tailf:cli-compact-syntax;
              key "ipaddr secaddr";
              leaf ipaddr {
                type ip-mask {
                  tailf:info "A.B.C.D/LEN;;IP prefix and network mask length "
                    +"in format x.x.x.x/m";
                }
              }
              leaf secaddr {
                tailf:info "Configure additional IP addresses on interface";
                type enumeration {
                  enum "secondary";
                }
              }
              leaf tag {
                tailf:info "URIB route tag value for local/direct routes";
                default 0;
                type uint32 {
                  tailf:info "<0-4294967295>;;Local/direct tag value";
                  range "0..4294967295";
                }
              }
            }
          }
        }
        case dynamic {
          container addr-dhcp {
            tailf:cli-drop-node-name;
            container address {
              tailf:cli-incomplete-command;
              leaf dhcp {
                tailf:info "Configure IP address from a dhcp server";
                type empty;
              }
            }
          }
        }
      }

      // interface * / ip arp
      container arp {
        tailf:info "Configure ARP parameters";
        list address-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-incomplete-command;
          key address;
          leaf address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP address";
            }
          }
          leaf mac {
            tailf:cli-drop-node-name;
            tailf:cli-no-value-on-delete;
            tailf:cli-suppress-no;
            type mac-address-type;
          }
        }
        // interface * / ip arp timeout
        leaf timeout {
          tailf:info "ARP timeout";
          tailf:cli-no-value-on-delete;
          default "1500";
          type uint16 {
            tailf:info "60-28800;;Time-out value in seconds";
            range "60..28800";
          }
        }
        container gratuitous {
          tailf:info "Gratuitous";

          container hsrp {
            tailf:info "Hsrp";
            leaf duplicate {
              tailf:info "Duplicate address detection";
              tailf:cli-boolean-no;
              default true;
              type boolean;
            }
          }
          leaf request {
            tailf:info "Enable/Disable sending grat. arp request when duplicate address detected";
            tailf:cli-boolean-no;
            default true;
            type boolean;
          }
          leaf update {
            tailf:info "Enable/Disable arp cache updates for gratuitous arp";
            tailf:cli-boolean-no;
            default true;
            type boolean;
          }
        }
      }
      // interface * / ip dhcp
      container dhcp {
        tailf:info "Configure DHCP snooping or relay";
        // interface * / ip dhcp relay
        tailf:cli-diff-dependency "/nx:feature/dhcp";
        container relay {
          tailf:info "Enable DHCP relay agent";

          // interface * / ip dhcp relay subnet-broadcast
          leaf subnet-broadcast {
            tailf:info "Configure DHCP relay subnet-broadcast on interface";
            type empty;
          }

          // interface * / ip dhcp relay address
          list address {
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key id;
            leaf id {
              type inet:ipv4-address;
            }
            // interface * / ip dhcp relay address * use-vrf
            leaf use-vrf {
              tailf:info "Helper address VRF membership";
              //   use-vrf WORD|default|management
              default "default";
              type vrf-member-type;
            }
          }
          // interface * / ip dhcp relay information
          container information {
            tailf:info "Relay agent information option";
            leaf trusted {
              tailf:info "Enable relay trust on this interface";
              type empty;
            }
          }
          leaf source-interface {
            tailf:info "Configure source interface for DHCP relay";
            nx:case-insensitive-type;
            type string {
              tailf:info "<WORD>;;Interface name";
            }
          }
        }
        // interface * / ip dhcp smart-relay
        leaf smart-relay {
          tailf:info "Configure DHCP smart relay on interface";
          tailf:cli-full-command;
          type empty;
        }
        // interface * / ip dhcp snooping
        container snooping {
          tailf:info "DHCP Snooping";
          leaf trust {
            tailf:info "DHCP Snooping trust config";
            type empty;
          }
        }
      }

      // interface * / ip directed-broadcast
      leaf directed-broadcast {
        tailf:info "IP directed-broadcast";
        tailf:cli-full-command;
        tailf:cli-diff-set-after "../directed-broadcast-acl/directed-broadcast" {
          tailf:cli-when-target-delete;
        }
        type empty;
      }

      container directed-broadcast-acl {
        tailf:cli-incomplete-command;
        tailf:cli-drop-node-name;
        leaf directed-broadcast {
          tailf:info "IP directed-broadcast";
          tailf:cli-diff-delete-before "../../directed-broadcast" {
            tailf:cli-when-target-set;
          }
          type string {
            tailf:info "WORD;;ACL policy name (Max Size 63)";
          }
        }
      }

      // interface * / ip ospf
      container ospf {
        tailf:info "OSPF configuration commands";
        tailf:cli-diff-dependency "/nx:feature/ospf";

        // interface * / ip ospf authentication <CR>
        container authentication {
          tailf:info "Authentication on the interface";
          presence "Authentication on the interface";
          tailf:cli-delete-when-empty;
          // interface * / ip ospf authentication key-chain WORD <CR>
          leaf key-chain {
            tailf:info "Authentication password key-chain";
            type string {
              tailf:info "WORD;;Key-chain name (Max Size 63)";
              length "1..63";
            }
          }
          leaf authentication-type {
            tailf:cli-drop-node-name;
            type enumeration {
              // interface * / ip ospf authentication message-digest <CR>
              enum "message-digest" {
                tailf:info "Use message-digest authentication";
              }
              // interface * / ip ospf authentication null <CR>
              enum "null" {
                tailf:info "Use null(disable) authentication";
              }
            }
          }
        }

        // interface * / ip ospf authentication-key
        container authentication-key {
          tailf:info "Configure the authentication key for the interface";
          tailf:cli-sequence-commands;
          tailf:cli-compact-syntax;
          leaf encryption-type {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            tailf:cli-optional-in-sequence;
            nx:device-transformed-dependency;
            type enumeration {
              // interface * / ip ospf authentication-key 0
              enum "0" {
                tailf:info "Specifies an UNENCRYPTED "
                  +"authentication key will follow";
              }
              // interface * / ip ospf authentication-key 3
              enum "3" {
                tailf:info "Specifies an 3DES ENCRYPTED "
                  +"authentication key will follow";
              }
              // interface * / ip ospf authentication-key 7
              enum "7" {
                tailf:info "Specifies a Cisco type 7 ENCRYPTED "
                  +"authentication key will follow";
              }
            }
            default "0";
          }
          // interface * / ip ospf authentication-key 0|3|7 WORD <CR>
          leaf key {
            tailf:cli-drop-node-name;
            tailf:cli-disallow-value "0|3|7";
            nx:device-transformed-value;
            type NEDCOM_SECRET_TYPE {
              tailf:info "WORD;;The authentication key";
            }
          }
        }

        // interface * / ip ospf bfd <CR>
        leaf bfd {
          tailf:info "Enable BFD on interface";
          tailf:cli-diff-dependency "/nx:feature/bfd";
          type empty;
        }

        // interface * / ip ospf cost <1-65535> <CR>
        leaf cost {
          tailf:info "Cost associated with interface";
          type uint16 {
            tailf:info "<1-65535>;;Cost value";
            range "1..65535";
          }
        }

        // interface * / ip ospf dead-interval <1-262140> <CR>
        leaf dead-interval {
          tailf:info "Dead interval";
          type uint32 {
            tailf:info "<1-262140>;;(seconds)";
          }
          default "40";
        }

        // interface * / ip ospf hello-interval <1-65535> <CR>
        leaf hello-interval {
          tailf:info "Hello interval";
          type uint16 {
            tailf:info "<1-65535>;;(seconds)";
            range "1..65535";
          }
          default "10";
        }

        // interface * / ip ospf message-digest-key
        container message-digest-key {
          tailf:cli-sequence-commands;
          tailf:cli-compact-syntax;
          tailf:info "Message digest authentication password (key)";
          leaf key-id {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            tailf:cli-delete-container-on-delete;
            type uint8 {
              tailf:info "<1-255>;;Key ID";
              range "1..255";
            }
          }
          // interface * / ip ospf message-digest-key <1-255> md5
          leaf md5 {
            tailf:info "Use MD5 algorithm";
            tailf:cli-incomplete-command;
            type empty;
          }
          leaf encryption-type {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            tailf:cli-optional-in-sequence;
            nx:device-transformed-dependency;
            type enumeration {
              // interface * / ip ospf message-digest-key <1-255> md5 0
              enum "0" {
                tailf:info "Specifies an UNENCRYPTED "
                  +"ospf password (key) will follow";
              }
              // interface * / ip ospf message-digest-key <1-255> md5 3
              enum "3" {
                tailf:info "Specifies an 3DES ENCRYPTED "
                  +"ospf password (key) will follow";
              }
              // interface * / ip ospf message-digest-key <1-255> md5 7
              enum "7" {
                tailf:info "Specifies a Cisco type 7 ENCRYPTED "
                  +"ospf password (key) will follow";
              }
            }
          }
          // interface * / ip ospf message-digest-key <1-255> md5 0|3|7
          // WORD <CR>
          leaf key {
            tailf:cli-drop-node-name;
            nx:device-transformed-value;
            type NEDCOM_SECRET_TYPE {
              tailf:info "WORD;;The ospf password (key)";
            }
          }
        }

        // interface * / ip ospf mtu-ignore <CR>
        leaf mtu-ignore {
          tailf:info "Disable OSPF MTU mismatch detection";
          type empty;
        }

        // interface * / ip ospf network broadcast|point-to-point <CR>
        leaf network {
          tailf:info "Network type";
          type enumeration {
            enum "broadcast" {
              tailf:info "Specify OSPF broadcast multi-access network";
            }
            enum "point-to-point" {
              tailf:info "Specify OSPF point-to-point network";
            }
          }
        }

        // interface * / ip ospf passive-interface <CR>
        leaf passive-interface {
          tailf:info "Suppress routing updates on the interface";
          nx:tri-state-boolean;
          type boolean {
            tailf:info "true|false;;Enable/disable suppress updates";
          }
        }

        // interface * / ip ospf priority <0-255> <CR>
        leaf priority {
          tailf:info "Router priority";
          type uint8 {
            tailf:info "<0-255>;;Router priority";
            range "0..255";
          }
          default "1";
        }

        // interface * / ip ospf retransmit-interval <1-65535> <CR>
        leaf retransmit-interval {
          tailf:info "Packet retransmission interval";
          type uint16 {
            tailf:info "<1-65535>;;(seconds)";
          }
          default "5";
        }

        // interface * / ip ospf shutdown <CR>
        leaf shutdown {
          tailf:info "Shutdown ospf on this interface";
          type empty;
        }

        // interface * / ip ospf transmit-delay <1-450> <CR>
        leaf transmit-delay {
          tailf:info "Packet transmission delay";
          type uint16 {
            tailf:info "<1-450>;;(seconds)";
            range "1..450";
          }
          default "1";
        }
      }

      // interface * / ip port-unreachable
      leaf port-unreachable {
        tailf:info "Enable sending ICMP port-unreachable";
        tailf:cli-full-command;
        type empty;
      }

      // interface * / ip redirects
      leaf redirects {
        tailf:info "Send ICMP Redirect messages";
        tailf:cli-full-command;
        tailf:cli-boolean-no;
        tailf:cli-trim-default;
        default "true";
        type boolean;
      }

      // interface * / ip policy
      container policy {
        tailf:info "Configure PBR feature";
        leaf route-map {
          tailf:info "Route-map for PBR";
          tailf:cli-full-command;
          tailf:cli-remove-before-change;
          tailf:cli-diff-dependency "/nx:feature/pbr";
          tailf:non-strict-leafref {
            path "/nx:route-map/name";
          }
          type string {
            tailf:info "WORD;;Route-map name (Max Size 63)";
            length "1..63";
          }
        }
      }

      // interface * / ip unreachables
      leaf unreachables {
        tailf:info "Enable sending ICMP unreachables (other than "
          +"port-unreachable)";
        tailf:cli-full-command;
        type empty;
      }

      // interface * / ip port access-group *
      container port {
        tailf:info "Port policy";
        list access-group {
          tailf:info "Specify access control for packets";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key direction;
          leaf name {
            tailf:cli-prefix-key;
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;List name (Max Size 64)";
              length "1..64";
            }
          }
          leaf direction {
            type enumeration {
              enum "in" {
                tailf:info "Inbound packets";
              }
              enum "out" {
                tailf:info "Outbound packets";
              }
            }
          }
        }
      }

      // interface * / ip router
      container router {
        container ospf {
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf name {
            tailf:cli-drop-node-name;
            tailf:non-strict-leafref {
              path "/nx:router/ospf/id";
            }
            type ospf-id-type;
          }
          leaf area {
            type ospf-area-type;
          }
        }

        leaf isis {
          tailf:info "Intermediate System to Intermediate System (IS-IS)";
          tailf:non-strict-leafref {
            path "/nx:router/isis/id";
          }
          type string {
            tailf:info "WORD;;Process tag (Max Size 20)";
            length "1..20";
          }
        }

        list eigrp {
          tailf:info "Configure an EIGRP routing process on interface";
          tailf:cli-suppress-mode;
          tailf:cli-diff-dependency "/nx:feature/eigrp";
          key id;
          leaf id {
            tailf:info "WORD;;Process tag (Max Size 20)";
            type string {
              length "1..20";
            }
          }
        }
        leaf rip {
          tailf:info "Routing Information Protocol (RIP)";
          type string {
            tailf:info "WORD;;Process tag (Max Size 20)";
          }
        }
      }

      container rip {
        tailf:info "RIP configuration commands";
        list route-filter {
          tailf:info "RIP route filtering";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-compact-syntax;
          key direction;
          leaf direction {
            type enumeration {
              enum in { tailf:info "Inbound"; }
              enum out { tailf:info "Outbound"; }
            }
          }
          leaf type {
            tailf:cli-drop-node-name;
            tailf:cli-prefix-key;
            tailf:cli-incomplete-command;
            type enumeration {
              enum prefix-list { tailf:info "Prefix-list policy to constrain route filtering"; }
              enum route-map { tailf:info "Route-map policy to constrain route filtering"; }
            }
          }
          leaf name {
            tailf:cli-drop-node-name;
            tailf:cli-prefix-key;
            type string {
              tailf:info "WORD;;Prefix-list/route-map name";
            }
          }
        }
      }

      // interface * / ip pim
      uses interface-ip-pim-grouping {
        augment pim {
          // interface * / ip pim dr-delay
          leaf dr-delay {
            tailf:info "Configures delay for PIM DR election on interface";
            tailf:cli-no-value-on-delete;
            default "3";
            type uint16 {
              tailf:info "1-65535;;Delay value";
              range "1..65535";
            }
          }
          // interface * / ip pim hello-authentication
          container hello-authentication {
            tailf:info "Add AH header option to Hellos";
            // interface * / ip pim hello-authentication ah-md5
            container ah-md5 {
              tailf:info "Use MD5 HMAC";
              // interface * / ip pim hello-authentication ah-md5
              choice ah-md5-choice {
                // interface * / ip pim hello-authentication ah-md5 0
                leaf plain {
                  tailf:info "Specifies an UNENCRYPTED md5 authentication key w"
                    +"ill follow";
                  tailf:alt-name "0";
                  type string {
                    tailf:info "<string>;;UNENCRYPTED (cleartext) password";
                  }
                }
                // interface * / ip pim hello-authentication ah-md5 3
                leaf des3 {
                  tailf:info "Specifies an 3DES ENCRYPTED md5 authentication ke"
                    +"y will follow";
                  tailf:alt-name "3";
                  type string {
                    tailf:info "<string>;;3DES ENCRYPTED password";
                  }
                }
                // interface * / ip pim hello-authentication ah-md5 7
                leaf cisco_enc {
                  tailf:info "Specifies a Cisco type 7  ENCRYPTED md5 authentication key will follow";
                  tailf:alt-name "7";
                  type string {
                    tailf:info "<string>;;Cisco type 7 ENCRYPTED password";
                  }
                }
                // interface * / ip pim hello-authentication ah-md5 unencrypted
                leaf unencrypted {
                  tailf:cli-drop-node-name;
                  type string {
                    tailf:info "<string>;;The UNENCRYPTED (cleartext) md5 authe"
                      +"ntication key";
                  }
                }
              }
            }
          }
          // interface * / ip pim strict-rfc-compliant
          leaf strict-rfc-compliant {
            tailf:info "Dont process joins from unknown neighbors on this inter"
              +"face";
            type empty;
          }
          choice bfd-inst-choice {
            leaf bfd-instance {
              tailf:info "Configures BFD on interface";
              tailf:cli-diff-dependency "/nx:feature/bfd";
              tailf:cli-full-command;
              type empty;
            }
            container disable-bfd-instance {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              container bfd-instance {
                tailf:info "Configures BFD on interface";
                leaf disable {
                  tailf:info "Disable BFD on interface";
                  tailf:cli-diff-dependency "/nx:feature/bfd";
                  type empty;
                }
              }
            }
          }
        }
        refine pim {
          tailf:cli-diff-dependency "/nx:feature/pim";
        }
      }

      // interface * / ip igmp
      container igmp {
        tailf:info "IGMP interface configuration commands";
        container static-oif {
          tailf:info "Configures static oif for a multicast forwarding entry";
          cli:parse-alt-name "static-group";
          list multicast-group {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-diff-set-after "../route-map" {
              tailf:cli-when-target-delete;
            }
            key "address source";
            leaf address {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Multicast group IP address";
              }
            }
            leaf source {
              tailf:info "Configures source address for IGMPv3 (S,G) Channel";
              tailf:cli-expose-key-name;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Source IP address";
              }
            }
          }
          list multicast-group-nosrc {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-diff-set-after "../route-map" {
              tailf:cli-when-target-delete;
            }
            key "address";
            leaf address {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Multicast group IP address";
              }
            }
          }
          leaf route-map {
            tailf:info "Static group policy";
            tailf:cli-diff-delete-before "../multicast-group" {
              tailf:cli-when-target-set;
            }
            tailf:cli-diff-delete-before "../multicast-group-nosrc" {
              tailf:cli-when-target-set;
            }
            type string {
              tailf:info "WORD;;Route-map name (Max Size 63)";
              length "1..63";
            }
          }
        }

        leaf query-max-response-time {
          tailf:info "Configures MRT for query messages";
          tailf:cli-full-command;

          type uint8 {
            tailf:info "<1-25>;;Time in seconds";
            range "1..25";
          }
          default 10;
        }

        leaf query-interval {
          tailf:cli-diff-dependency "../query-max-response-time";
          tailf:info "Configures interval between Query transmission";
          tailf:cli-full-command;

          type uint16 {
            tailf:info "<1-18000>;;Interval in seconds";
            range "1..18000";
          }
          default 125;
        }

        leaf version {
          tailf:info "Configures IGMP version number for interface";
          type uint8 {
            tailf:info "<2-3>;;Version number value";
          }
        }

        container join-group {
          tailf:info "Configures local group membership for router";
          list multicast-source {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-diff-set-after "../route-map" {
              tailf:cli-when-target-delete;
            }
            key "address source";
            leaf address {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Multicast group IP address";
              }
            }
            leaf source {
              tailf:cli-expose-key-name;
              tailf:info "Configures source address for IGMPv3 (S,G) Channel";
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Source IP address";
              }
            }
          }
          list multicast {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-diff-set-after "../route-map" {
              tailf:cli-when-target-delete;
            }
            key address;
            leaf address {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Multicast group IP address";
              }
            }
          }
          leaf route-map {
            tailf:info "Join group policy";
            type string {
              tailf:info "WORD;;Route-map name (Max Size 63)";
            }
          }
        }
      }

      // interface * / ip nat
      leaf nat {
        tailf:info "NAT interface commands";
        when "/nx:feature/nat" {
          tailf:dependency "/nx:feature/nat";
        }
        type enumeration {
          enum inside {
            tailf:info "Inside interface for address translation";
          }
          enum outside {
            tailf:info "Outside interface for address translation";
          }
        }
      }

      // interface * / ip proxy-arp
      leaf proxy-arp {
        tailf:info "Configure proxy ARP";
        type empty;
      }

      // interface * / ip summary-address
      container summary-address {
        tailf:info "Configures IP-EIGRP summary address on interface";
        list eigrp {
          tailf:info "EIGRP interface configuration commands";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-diff-dependency "/nx:feature/eigrp";
          key "id addr";
          leaf id {
            tailf:info "WORD;;Process tag (Max Size 20)";
            tailf:non-strict-leafref {
              path "/nx:router/eigrp/id";
            }
            type string {
              length "1..20";
            }
          }
          leaf addr {
            type tailf:ipv4-address-and-prefix-length {
              tailf:info "A.B.C.D/LEN  IP prefix in slash format";
            }
          }
        }
      }

      // interface * / ip bandwidth
      container bandwidth {
        tailf:info "Set bandwidth for interface used in EIGRP metric calculation";
        uses eigrp-interface-config-list-grouping {
          augment eigrp {
            leaf bandwidth {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<1-2560000000>;;Bandwidth in kilobits";
              }
            }
          }
        }
      }

      // interface * / ip passive-interface
      container passive-interface {
        tailf:info "Suppress routing updates on an interface";
        uses eigrp-interface-config-list-grouping {
          augment eigrp {
            leaf suppress {
              tailf:cli-drop-node-name;
              nx:tri-state-boolean;
              type boolean {
                tailf:info "true|false;;Enable/disable suppress updates";
              }
            }
          }
        }
      }

      // interface * / ip delay
      container delay {
        tailf:info "Set delay for interface used in EIGRP metric calculation";
        uses eigrp-interface-config-list-grouping {
          augment eigrp {
            leaf delay {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<1-16777215>;;Throughput delay";
              }
            }
          }
        }
      }

      // interface * / ip distribute-list
      container distribute-list {
        tailf:info "Filter networks in routing updates";
        uses eigrp-route-or-prefix-list-grouping;
      }
      container hold-time {
        tailf:info "Configures IP-EIGRP hold time";
        tailf:cli-diff-dependency "/nx:feature/eigrp";
        uses eigrp-interface-config-list-grouping {
          augment eigrp {
            leaf down {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<1-65535>;;Seconds before neighbor is considered down";
              }
            }
          }
        }
      }
      container hello-interval {
        tailf:info "Configures IP-EIGRP hello interval";
        tailf:cli-diff-dependency "/nx:feature/eigrp";
        uses eigrp-interface-config-list-grouping {
          augment eigrp {
            leaf hello {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<1-65535>;;Seconds between hello transmissions";
              }
            }
          }
        }
      }
      container offset-list {
        tailf:info "Add or subtract offset from EIGRP metrics";
        tailf:cli-diff-dependency "/nx:feature/eigrp";
        uses eigrp-route-or-prefix-list-grouping {
          augment eigrp {
            leaf offset {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<0-2147483647>;;Offset";
              }
            }
          }
        }
      }
      uses eigrp-interface-config-list-grouping {
        augment eigrp {
          leaf shutdown {
            tailf:info "Shutdown EIGRP on this interface";
            type empty;
          }
        }
      }
      container verify {
        tailf:info "Configure Unicast Reverse Path Forwarding or IP Source Guard";
        container unicast {
          tailf:info "Unicast Reverse Path Forwarding";
          container source {
            tailf:info "Validation of source address";
            leaf reachable-via {
              tailf:info "Specify reachability check to apply to the source address";
              type enumeration {
                enum any { tailf:info "Source is reachable via any interface"; }
                enum rx { tailf:info "Source is reachable via interface on which packet was received"; }
              }
            }
          }
        }
        leaf source {
          tailf:info "IP Source Guard related commands";
          tailf:cli-diff-dependency "/nx:feature/dhcp";
          type enumeration {
            enum dhcp-snooping-vlan { tailf:info "Vlans on which snooping is enabled"; }
          }
        }
      }
    }

    // interface * / ipv6
    container ipv6 {
      tailf:info "Configure IPv6 features";
      nx:data-category "layer3";
      tailf:cli-diff-delete-before "../vrf/member";
      // interface * / ipv6 address
      // New(?) behaviour, arbitrary list, no "secondary" keyword
      container address {
        tailf:info "Configure IPv6 address on interface";
        when "not(/nx:tailfned/iface-vlan-ipv6-secondary)" {
          tailf:dependency "/nx:tailfned/iface-vlan-ipv6-secondary";
        }
        leaf dhcp {
          tailf:info "Configure IPv6 address from a dhcp server";
          type empty;
        }
        choice addr-or-linklocal {
          list addresses {
            tailf:cli-suppress-mode;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            tailf:cli-drop-node-name;
            tailf:cli-delete-when-empty;
            tailf:cli-remove-before-change;
            key addr;
            leaf addr {
              type tailf:ipv6-address-and-prefix-length {
                tailf:info "A:B::C:D/LEN;;IPv6 prefix format: xxxx:xxxx/ml, xxx"
                  +"x:xxxx::/ml, xxxx::xx/128";
              }
            }
            leaf eui64 {
              tailf:info "Configure Extended Unique Identifier for the low-order 64 bits";
              tailf:cli-optional-in-sequence;
              type empty;
            }
            leaf route-preference {
              tailf:info "U6RIB route preference for local/direct routes";
              tailf:cli-optional-in-sequence;
              type uint8 {
                tailf:info "<0-255>;;Local/direct route preference";
              }
            }
            leaf tag {
              tailf:info "U6RIB route tag value for local/direct routes";
              tailf:cli-optional-in-sequence;
              default 0;
              type uint32 {
                tailf:info "<0-4294967295>;;Local/direct tag value";
              }
            }
            leaf anycast {
              tailf:info "Configure IPv6 anycast address on interface";
              type empty;
            }
          }
          leaf use-link-local-only {
            tailf:info "Enable IPv6 on interface using only a single link-"
              +"local address";
            type empty;
          }
        }
      }
      container have-secondary-address {
        tailf:cli-drop-node-name;
        when "/nx:tailfned/iface-vlan-ipv6-secondary";
        container address {
          tailf:info "Configure IPv6 address on interface";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          choice addr-or-linklocal {
            case has-addr {
              leaf addr {
                tailf:cli-drop-node-name;
                tailf:cli-reset-container;
                type tailf:ipv6-address-and-prefix-length {
                  tailf:info "A:B::C:D/LEN;;IPv6 prefix format: xxxx:xxxx/ml, x"
                    +"xxx:xxxx::/ml, xxxx::xx/128";
                }
              }
              // interface * / ip address * tag
              leaf tag {
                tailf:info "URIB route tag value for local/direct routes";
                type uint32 {
                  tailf:info "<0-4294967295>;;Local/direct tag value";
                  range "0..4294967295";
                }
              }
            }
            case has-linklocal {
              leaf use-link-local-only {
                tailf:info "Enable IPv6 on interface using only a single link-"
                  +"local address";
                type empty;
              }
            }
          }
        }
        container secondary-addr {
          tailf:cli-drop-node-name;
          tailf:cli-diff-dependency "../address";
          list address {
            tailf:info "Configure IP address on interface";
            tailf:cli-suppress-mode;
            tailf:cli-compact-syntax;
            key "addr secaddr";
            leaf addr {
              type tailf:ipv6-address-and-prefix-length {
                tailf:info "A:B::C:D/LEN;;IPv6 prefix format: xxxx:xxxx/ml, xxx"
                  +"x:xxxx::/ml, xxxx::xx/128";
              }
            }
            leaf secaddr {
              tailf:info "Configure additional IP addresses on interface";
              type enumeration {
                enum "secondary";
              }
            }
          }
        }
      }

      // interface * / ipv6 link-local
      leaf link-local {
        tailf:info "Change format of link-local address";
        type inet:ipv6-address {
          tailf:info "A:B::C:D;;IPv6 address format: aaaa:bbbb:cccc:dddd:eeee:"
            +"ffff:gggg:hhhh, aaaa::bbbb";

        }
      }

      // interface * / ipv6 nd
      container nd {
        tailf:info "ICMPv6 Neighbor Discovery commands";
        // ipv6 nd managed-config-flag
        leaf managed-config-flag {
          tailf:info "Sent in RA messages, tells hosts to use stateful "
            +"address auto-configuration to obtain address information";
          type empty;
        }
        // ipv6 nd other-config-flag
        leaf other-config-flag {
          tailf:info "Sent in RA messages, tells hosts to use stateful "
            +"auto-configuration to obtain non-address related information";
          type empty;
        }
        // ipv6 nd prefix
        container prefix {
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          choice prefix-choice {
            leaf prefix {
              tailf:cli-drop-node-name;
              type tailf:ipv6-address-and-prefix-length {
                tailf:info "A:B::C:D/LEN;;IPv6 prefix format";
              }
            }
            leaf default {
              type empty;
            }
          }
          container valid-lifetime {
            tailf:cli-drop-node-name;
            tailf:cli-compact-syntax;
            tailf:cli-flatten-container;
            choice valid-lifetime-choice {
              leaf lifetime {
                tailf:cli-drop-node-name;
                type uint32;
              }
              leaf infinite {
                type empty;
              }
              leaf no-advertise {
                type empty;
              }
            }
          }
          container preferred-lifetime {
            tailf:cli-drop-node-name;
            tailf:cli-compact-syntax;
            tailf:cli-flatten-container;
            choice preferred-lifetime-choice {
              leaf lifetime {
                tailf:cli-drop-node-name;
                type uint32;
              }
              leaf infinite {
                type empty;
              }
            }
          }
          leaf no-autoconfig {
            tailf:cli-break-sequence-commands;
            type empty;
          }
          leaf no-onlink {
            type empty;
          }
          leaf off-link {
            type empty;
          }
        }
        // ipv6 nd suppress-ra
        leaf suppress-ra {
          tailf:info "Disable sending Router-Advertisement messages";
          type empty;
        }
        // ipv6 nd redirects
        leaf redirects {
          tailf:info "Enable sending ICMPv6 Redirect messages";
          tailf:cli-boolean-no;
          default true;
          type boolean;
        }
        leaf retrans-timer {
          tailf:info "Sent in RA messages, advertised time between NS messages";
          default 0;
          type uint16 {
            tailf:info "<0-4294967295>;;Time in milliseconds";
          }
        }
        leaf mtu {
          tailf:info "Sent in RA messages, tells hosts what MTU to use on this link";
          default 1500;
          type uint16 {
            tailf:info "<1280-65535>;;MTU in bytes";
          }
        }
        container ra-interval {
          tailf:info "Interval between sending Router-Advertisement messages";
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-compact-syntax;
          leaf interval {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<4-1800>;;Interval in seconds";
            }
          }
          leaf min {
            tailf:info "Minimum interval between sending RA messages";
            type uint16 {
              tailf:info "<3-1350>;;Interval in seconds";
            }
          }
        }
        leaf ra-lifetime {
          tailf:info "Sent in RA messages, Router Lifetime of a default router, 0 means this router will not be the default router";
          default 1800;
          type uint16 {
            tailf:info "<0-9000>;;Lifetime in seconds";
          }
        }
        container ra {
          tailf:info "Router Advertisement";
          leaf bootfile-url {
            tailf:info "Set boot-file-url option";
            type string {
              tailf:info "WORD;;Url for boot file (Max Size 128)";
            }
          }
          container dns {
            tailf:info "Domain Name System";
            container suppress-search-list {
              tailf:cli-drop-node-name;
              container search-list {
                tailf:info "DNS Search List";
                leaf suppress {
                  tailf:info "Disable sending DNSSL in Router-Advertisement messages";
                  tailf:cli-full-command;
                  type empty;
                }
              }
            }
            list search-list {
              tailf:info "DNS Search List";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              tailf:cli-compact-syntax;
              tailf:cli-diff-delete-before "../search-list" {
                tailf:cli-when-target-set;
              }
              unique "sequence";
              key name;
              leaf name {
                tailf:cli-disallow-value "suppress";
                tailf:cli-incomplete-command;
                type string {
                  tailf:info "WORD;;Configure DNS Search List to advertise in RA";
                }
              }
              leaf life-time {
                tailf:cli-drop-node-name;
                tailf:cli-optional-in-sequence;
                tailf:cli-remove-before-change;
                type union {
                  type uint32 {
                    tailf:info "<4-4294967295>;;Configure IPv6 DNS Search list life time";
                  }
                  type enumeration {
                    enum infinite {
                      tailf:info "Configure IPv6 DNS Search list life time with infinite";
                    }
                  }
                }
              }
              leaf sequence {
                tailf:info "Sequence of Search List";
                tailf:cli-remove-before-change;
                mandatory true;
                type uint32 {
                  tailf:info "<0-4294967295>;;Sequence number";
                }
              }
            }
            container suppress-server {
              tailf:cli-drop-node-name;
              container server {
                tailf:info "Domain Name System Server";
                leaf suppress {
                  tailf:info "Disable sending RDNSS in Router-Advertisement messages";
                  tailf:cli-full-command;
                  type empty;
                }
              }
            }
            list server {
              tailf:info "Domain Name System Server";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              tailf:cli-compact-syntax;
              tailf:cli-diff-delete-before "../server" {
                tailf:cli-when-target-set;
              }
              unique "sequence";
              key address;
              leaf address {
                tailf:cli-incomplete-command;
                type inet:ipv6-address {
                  tailf:info "A:B::C:D;;Configure IPv6 DNS Server address to advertise in RA";
                }
              }
              leaf life-time {
                tailf:cli-drop-node-name;
                tailf:cli-optional-in-sequence;
                tailf:cli-remove-before-change;
                type union {
                  type uint32 {
                    tailf:info "<4-4294967295>;;Configure IPv6 DNS Server life time";
                  }
                  type enumeration {
                    enum infinite {
                      tailf:info "Configure IPv6 DNS Server life time with infinite";
                    }
                  }
                }
              }
              leaf sequence {
                tailf:info "Sequence of server";
                tailf:cli-remove-before-change;
                mandatory true;
                type uint32 {
                  tailf:info "<0-4294967295>;;Sequence number";
                }
              }
            }
          }
          container route {
            tailf:info "Route Information Option in RFC 4191";
            leaf suppress {
              tailf:info "Disable sending Route Information Options in RA messages";
              type empty;
            }
          }
        }
      }

      // interface * / ipv6 neighbor
      container neighbor {
        tailf:info "Configure IPv6 address to layer-2 address mapping";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf address {
          tailf:cli-drop-node-name;
          type inet:ipv6-address {
            tailf:info "A:B::C:D;;IPv6 address format: aaaa:bbbb:cccc:dddd:"
              +"eeee:ffff:gggg:hhhh, aaaa::bbbb";
          }
        }
        leaf mac {
          tailf:cli-drop-node-name;
          type mac-address-type;
        }
      }

      // interface * / ipv6 redirects
      leaf redirects {
        tailf:info "Enable sending ICMPv6 Redirect messages";
        tailf:cli-full-command;
        tailf:cli-boolean-no;
        tailf:cli-trim-default;
        default "true";
        type boolean;
      }

      // interface * / ipv6 policy
      container policy {
        tailf:info "Configure PBR feature";
        leaf route-map {
          tailf:info "Route-map for PBR";
          tailf:cli-full-command;
          tailf:cli-remove-before-change;
          tailf:cli-diff-dependency "/nx:feature/pbr";
          tailf:non-strict-leafref {
            path "/nx:route-map/name";
          }
          type string {
            tailf:info "WORD;;Route-map name (Max Size 63)";
            length "1..63";
          }
        }
      }

      grouping traffic-filter-grouping {
        list traffic-filter {
          tailf:info "Specify access control for packets";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key direction;
          leaf name {
            tailf:cli-drop-node-name;
            tailf:cli-prefix-key;
            tailf:non-strict-leafref {
              path "/nx:ipv6/access-list/list-name/id";
            }
            type string {
              tailf:info "WORD;;List name (Max Size 64)";
              length "1..64";
            }
          }
          leaf direction {
            type enumeration {
              enum "in" {
                tailf:info "Inbound packets";
              }
              enum "out" {
                tailf:info "Outbound packets";
              }
            }
          }
        }
      }

      // interface * / ipv6 port
      container port {
        tailf:info "Port policy";
        // interface * / ipv6 port traffic-filter *
        uses traffic-filter-grouping;
      }

      // interface * / ipv6 traffic-filter *
      uses traffic-filter-grouping;

      // interface * / ipv6 router
      container router {
        tailf:info "Enable a routing process";
        container ospfv3 {
          tailf:info "OSPFv3 configuration commands";
          tailf:cli-sequence-commands;
          tailf:cli-compact-syntax;
          leaf name {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;Process tag (Max Size 20)";
              length "1..20";
            }
          }
          leaf area {
            tailf:info "Area associated with interface";
            type union {
              type uint32 {
                tailf:info "<0-4294967295>;;OSPFv3 area ID as a decimal format";
                range "0..4294967295";
              }
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;OSPFv3 area ID in IP address format";
              }
            }
          }
        }

        leaf isis {
          tailf:info "Intermediate System to Intermediate System (IS-IS)";
          type string {
            tailf:info "WORD;;Process tag (Max Size 20)";
            length "1..20";
          }
        }
      }

      uses interface-ip-pim-grouping {
        refine pim {
          tailf:cli-diff-dependency "/nx:feature/pim6";
        }
      }

      // interface * / ipv6 dhcp
      container dhcp {
        tailf:info "Configure DHCPv6 relay";
        tailf:cli-diff-dependency "/nx:feature/dhcp";
        container relay {
          tailf:info "Configure DHCPv6 relay agent";
          list address {
            tailf:info "Configure DHCPv6 server relay address";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            key "addr use-vrf";
            leaf addr {
              type inet:ipv6-address {
                tailf:info "A:B::C:D;;IPv6 server address";
              }
            }
            leaf use-vrf {
              tailf:cli-expose-key-name;
              tailf:key-default "default";
              nx:trim-default-on-delete;
              type vrf-member-type;
            }
          }
          leaf source-interface {
            tailf:info "Configure source interface for DHCPv6 relay";
            nx:case-insensitive-type;
            type string {
              pattern "(([Ee]thernet)|([Ll]oopback)|([Pp]ort-channel)|([Vv]lan)|([Bb]di))[0-9/\\.]+";
            }
          }
        }
      }

    }

    // interface * / ospfv3
    container ospfv3 {
      tailf:cli-diff-dependency "/nx:feature/ospfv3";
      tailf:info "OSPFv3 configuration commands";
      when "/nx:feature/ospfv3" {
        tailf:dependency "/nx:feature/ospfv3";
      }
      leaf cost {
        tailf:info "Cost associated with interface";
        type uint16 {
          tailf:info "<1-65535>;;Cost value";
          range "1..65535";
        }
      }
      leaf network {
        tailf:info "Network type";
        type enumeration {
          enum broadcast {
            tailf:info "Specify OSPF broadcast multi-access network";
          }
          enum point-to-point {
            tailf:info "Specify OSPF point-to-point network";
          }
        }
      }
      leaf passive-interface {
        tailf:info "Suppress routing updates on the interface";
        type boolean;
        tailf:cli-boolean-no;
      }
    }

    // interface * / isis
    container isis {
      tailf:info "IS-IS configuration commands";
      tailf:cli-diff-dependency "../ip/router/isis";
      tailf:cli-diff-dependency "/nx:feature/isis";
      // BUG in NSO, can't have when + default values below (e.g. in authentication-check below)
      // when "/nx:feature/isis" {
      //   tailf:dependency "/nx:feature/isis";
      // }

      // interface * / isis circuit-type
      leaf circuit-type {
        tailf:info "Configure circuit type for interface";
        type enumeration {
          enum level-1 {
            tailf:info "Level-1 only adjacencies are formed";
          }
          enum level-1-2 {
            tailf:info "Level-1-2 adjacencies are formed";
          }
          enum level-2 {
            tailf:info "Level-2 only adjacencies are formed";
          }
        }
      }

      // interface * / isis hello-padding
      leaf hello-padding {
        tailf:info "Pad IS-IS hello PDUs to full MTU";
        tailf:cli-boolean-no;
        default true;
        type boolean;
      }

      // interface * / isis metric *
      list metric {
        tailf:info "Configure the metric for interface";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key link-type;
        leaf default-metric {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type uint32 {
            tailf:info "<0-16777215>;;Default metric";
          }
        }
        leaf link-type {
          type enumeration {
            enum level-1 {
              tailf:info "Apply metric to level-1 links";
            }
            enum level-2 {
              tailf:info "Apply metric to level-2 links";
            }
          }
        }
      }

      container ipv6 {
        tailf:info "Configure metric for IPV6 topology";
        list metric {
          tailf:info "Configure metric for IPV6 topology";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key link-type;
          leaf default-metric {
            tailf:cli-drop-node-name;
            tailf:cli-prefix-key;
            type uint32 {
              tailf:info "<0-16777215>;;Default metric";
            }
          }
          leaf link-type {
            type enumeration {
              enum level-1 {
                tailf:info "Apply metric to level-1 links";
              }
              enum level-2 {
                tailf:info "Apply metric to level-2 links";
              }
            }
          }
        }
      }

      // interface * / isis passive-interface
      container passive-interface {
        tailf:info "Suppress IS-IS PDU";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf pdu-type {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type enumeration {
            enum level-1 {
              tailf:info "Suppress level-1 PDU";
            }
            enum level-1-2 {
              tailf:info "Suppress level-1 and level-2 PDU";
            }
            enum level-2 {
              tailf:info "Suppress level-2 PDU";
            }
          }
        }
        leaf suppress {
          tailf:cli-drop-node-name;
          nx:tri-state-boolean;
          type boolean {
            tailf:info "true|false;;Suppress or don't suppress PDU";
          }
        }
      }

      // Old syntax(?)
      leaf passive {
        type enumeration {
          enum level-1;
          enum level-1-2;
          enum level-2;
        }
      }

      // interface * / isis bfd
      choice bfd-choice {
        leaf bfd {
          tailf:cli-full-command;
          tailf:cli-diff-dependency "/nx:feature/bfd";
          when "/nx:feature/bfd" {
            tailf:dependency "/nx:feature/bfd";
          }
          tailf:info "Interface BFD configuration";
          type empty;
        }
        container bfd-disable {
          tailf:cli-drop-node-name;
          container bfd {
            tailf:cli-incomplete-no;
            tailf:info "Interface BFD configuration";
            leaf disable {
              tailf:info "Disable BFD on interface";
              tailf:cli-diff-dependency "/nx:feature/bfd";
              when "/nx:feature/bfd" {
                tailf:dependency "/nx:feature/bfd";
              }
              type empty;
            }
          }
        }
      }

      // interface * / isis network
      container network {
        tailf:info "Change interface medium to p2p";
        leaf point-to-point {
          tailf:info "Change interface medium to p2p";
          type empty;
        }
      }

      // interface * / isis authentication
      container authentication {
        tailf:info "Set hello authentication keychain";
        list key-chain {
          tailf:info "Set authentication keychain string";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          key type;
          leaf name {
            tailf:cli-drop-node-name;
            tailf:cli-prefix-key;
            type string {
              tailf:info "WORD;;Authentication keychain (Max Size 63)";
              length "1..63";
            }
          }
          leaf type {
            type enumeration {
              enum level-1 {
                tailf:info "Specify authentication keychain for level-1 IIHs";
              }
              enum level-2 {
                tailf:info "Specify authentication keychain for level-2 IIHs";
              }
            }
          }
        }
      }

      // interface * / isis authentication-check
      container authentication-check {
        tailf:info "Check authentication on received hellos";
        leaf level-1 {
          tailf:info "Configure authentication check for level-1 IIHs";
          tailf:cli-boolean-no;
          default "true";
          type boolean;
        }
        leaf level-2 {
          tailf:info "Configure authentication check for level-2 IIHs";
          tailf:cli-boolean-no;
          default "true";
          type boolean;
        }
      }

      // interface * / isis authentication-type
      list authentication-type {
        tailf:info "Set hello authentication type";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key type;
        leaf auth-format {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type enumeration {
            enum cleartext {
              tailf:info "Cleartext";
            }
            enum md5 {
              tailf:info "HMAC-MD5";
            }
          }
        }
        leaf type {
          type enumeration {
            enum level-1 {
              tailf:info "Specify authentication type for level-1 IIHs";
            }
            enum level-2 {
              tailf:info "Specify authentication type for level-2 IIHs";
            }
          }
        }
      }

      // interface * / isis hello-interval
      list hello-interval {
        tailf:info "Set Hello interval in seconds";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key link-type;
        leaf default-metric {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type uint16 {
            tailf:info "<1-65535>;;Hello interval value *Default value is 10";
            range "1..65535";
          }
          default 10;
        }
        leaf link-type {
          type enumeration {
            enum level-1 {
              tailf:info "Specify hello-interval for level-1 IIHs";
            }
            enum level-2 {
              tailf:info "Specify hello-interval for level-2 IIHs";
            }
          }
        }
      }

      leaf lsp-interval {
        tailf:info "Set LSP transmission interval";
        default 33;
        type uint16 {
          tailf:info "<10-65535>;;LSP transmission interval (milliseconds)";
        }
      }
    }
  }

  grouping interface-ip-flow-grouping {
    // interface * / ip flow
    container flow {
      tailf:info "NetFlow related commands";
      tailf:cli-diff-dependency "/nx:feature/netflow";
      list monitor {
        tailf:info "Apply a Flow Monitor to this interface";
        key direction;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-remove-before-change;
        leaf name {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          mandatory true;
          tailf:non-strict-leafref {
            path "/nx:flow/monitor/name";
          }
          type string {
            tailf:info "WORD;;Name of Flow Monitor (Max Size 63)";
          }
        }
        leaf direction {
          type enumeration {
            enum "input" {
              tailf:info "Apply Flow Monitor on input traffic";
            }
            enum "output" {
              tailf:info "Apply Flow Monitor on output traffic";
            }
          }
        }
        leaf sampler {
          tailf:info "Optional Sampler to apply to this Flow Monitor";
          tailf:non-strict-leafref {
            path "/nx:sampler/name";
          }
          type string {
            tailf:info "WORD;;Name of Sampler (Max Size 63)";
          }
        }
      }
    }
  }

  grouping interface-ip-pim-grouping {
    container pim {
      tailf:info "PIM interface configuration commands";
      // interface * / ip pim border
      leaf border {
        tailf:info "Configures interface to be a boundary of a PIM domain";
        type empty;
      }
      // interface * / ip pim dr-priority
      leaf dr-priority {
        tailf:info "Configures priority for PIM DR election on interface";
        tailf:cli-no-value-on-delete;
        default "1";
        type uint32 {
          tailf:info "1-4294967295;;Priority value";
          range "1..4294967295";
        }
      }
      // interface * / ip pim hello-interval
      leaf hello-interval {
        tailf:info "Configures the Hello interval for interface";
        tailf:cli-no-value-on-delete;
        default "30000";
        type uint32 {
          tailf:info "1-18724286;;Interval in milliseconds";
          range "1..18724286";
        }
      }
      // interface * / ip pim jp-policy
      list jp-policy {
        tailf:info "Specify policy for receiving Join-Prune messages";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        key direction;
        leaf direction {
          type enumeration {
            enum "in" {
              tailf:info "Inbound";
            }
            enum "out" {
              tailf:info "Outbound";
            }
          }
        }
        leaf prefix-list {
          tailf:info "Prefix List policy for static RP";
          tailf:cli-prefix-key;
          tailf:cli-optional-in-sequence;
          type empty;
        }
        leaf name {
          tailf:cli-drop-node-name;
          tailf:info "Route-map/prefix-list name (Max Size 63)";
          tailf:cli-prefix-key;
          mandatory true;
          type string {
            tailf:info "<string>;;Route-map name (Max Size 63)";
          }
        }
      }
      // interface * / ip pim neighbor-policy
      container neighbor-policy {
        tailf:info "Configures a neighbor policy for filtering adjacencies";
        // interface * / ip pim neighbor-policy
        choice neighbor-policy-choice {
          // interface * / ip pim neighbor-policy route-map-name
          leaf route-map-name {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "<string>;;Route-map name (Max Size 63)";
            }
          }
          // interface * / ip pim neighbor-policy prefix-list
          leaf prefix-list {
            tailf:info "Prefix List policy for neighbor";
            type string {
              tailf:info "<string>;;Prefix-list name (Max Size 63)";
            }
          }
        }
      }
      // interface * / ip pim sparse-mode
      leaf sparse-mode {
        tailf:info "Configures sparse-mode PIM on interface";
        type empty;
      }
    }
  }

  grouping base-bfd-grouping {
    container bfd {
      tailf:info "BFD commands";
      tailf:cli-diff-dependency "/nx:feature/bfd";
      grouping bfd-grouping {
        // interface * / bfd echo-rx-interval <CR>
        leaf echo-rx-interval {
          tailf:info "BFD session echo rx interval in milliseconds";
          tailf:cli-full-command;
          type uint16 {
            range "50..999";
          }
        }
        container session-interval {
          tailf:info "Configure BFD session interval parameters";
          tailf:cli-sequence-commands;
          tailf:cli-compact-syntax;
          tailf:cli-drop-node-name;
          leaf interval {
            tailf:info "TX interval in milliseconds";
            tailf:cli-incomplete-command;
            type uint16 {
              range "50..999";
            }
          }
          leaf min_rx {
            tailf:info "Minimum RX interval in milliseconds";
            tailf:cli-incomplete-command;
            type uint16 {
              range "50..999";
            }
          }
          leaf multiplier {
            tailf:info "Configure detect multiplier for bfd sessions";
            tailf:cli-full-command;
            type uint8 {
              range "1..50";
            }
          }
        }
        leaf echo {
          tailf:info "Configure Echo function for all address families";
          tailf:cli-boolean-no;
          default "true";
          type boolean;
        }
      }

      // bfd interval
      uses bfd-grouping;

      // bfd ipv4
      container ipv4 {
        tailf:info "Ipv4 sessions";
        uses bfd-grouping;
      }

      // bfd ipv6
      container ipv6 {
        tailf:info "Ipv6 sessions";
        uses bfd-grouping;
      }
    }
  }

  grouping interface-bfd-grouping {
    uses base-bfd-grouping {
      augment "bfd" {
        // interface * / bfd per-link
        leaf per-link {
          tailf:info "Run BFD sessions on each port-channel link";
          type empty;
        }
        container authentication {
          tailf:info "Configure BFD authentication parameters";
          container Keyed-SHA1 {
            tailf:info "Keyed-SHA1";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf key-id {
              tailf:info "Key ID to use in BFD frames";
              type uint8 {
                tailf:info "<1-255>;;Key ID value";
              }
            }
            leaf key-type {
              tailf:cli-drop-node-name;
              nx:device-transformed-dependency;
              type enumeration {
                enum hex-key {
                  tailf:info "HEX binary SHA1 secret";
                }
                enum key {
                  tailf:info "ASCII SHA1 secret";
                }
              }
            }
            leaf key {
              tailf:cli-drop-node-name;
              nx:device-transformed-value;
              type NEDCOM_SECRET_TYPE {
                tailf:info "WORD;;SHA1 secret value";
              }
            }
          }
        }
      }
    }
  }

  grouping interface-eth-pc-bfd-grouping {
    container enable-disable-bfd {
      tailf:cli-drop-node-name;
      leaf bfd {
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        default "true";
        type boolean;
      }
      container bfd-ip {
        tailf:cli-drop-node-name;
        container bfd {
          tailf:cli-incomplete-command;
          leaf ipv4 {
            tailf:cli-boolean-no;
            tailf:cli-full-command;
            default "true";
            type boolean;
          }
          leaf ipv6 {
            tailf:cli-boolean-no;
            tailf:cli-full-command;
            default "true";
            type boolean;
          }
        }
      }
    }
    uses interface-bfd-grouping;
  }

  // interface Vlan *
  // interface Bdi *
  grouping interface-vlan-grouping {
    uses interface-ether-and-vlan-grouping;

    // interface * / medium
    leaf medium {
      tailf:info "Configure interface medium mode";
      tailf:cli-full-command;
      default "broadcast";
      type enumeration {
        enum "broadcast" {
          tailf:code-name "medium_broadcast";
          tailf:info "Broadcast medium";
        }
        enum "p2p" {
          tailf:info "Point-to-Point medium";
        }
      }
    }

    leaf autostate {
      tailf:info "Enable or disable autostate for interface-vlan";
      tailf:cli-boolean-no;
      default true;
      type boolean;
    }

    // interface vlan * / carrier-delay
    container carrier-delay {
      tailf:info "Specify delay for interface transitions";
      choice delay-choice {
        default msec;
        // interface vlan * / carrier-delay delay-seconds
        leaf delay-seconds {
          tailf:info "Carrier Transitions delay seconds";
          tailf:cli-drop-node-name;
          tailf:cli-no-value-on-delete;
          type uint8 {
            tailf:info "0-60;;Carrier Transitions delay seconds";
            range "0..60";
          }
        }
        // interface vlan * / carrier-delay msec
        leaf msec {
          tailf:info "Carrier Transitions delay milliseconds";
          tailf:cli-no-name-on-delete;
          tailf:cli-no-value-on-delete;
          default 100;
          type uint16 {
            tailf:info "0-1000;;Carrier Transitions delay milliseconds";
            range "0..1000";
          }
        }
      }
    }

    leaf management {
      tailf:info "Allow in-band management access to VLAN Interface IP addres"
        +"s";
      tailf:cli-boolean-no;
      default false;
      type boolean;
    }

    // interface * / fabric
    container fabric {
      tailf:info "Fabric";
      nx:data-category "layer3";
      tailf:cli-diff-delete-before "../vrf/member";
      container forwarding {
        tailf:info "Fabric Forwarding Protocol: Host Mobility Manager (HMM)";
        leaf mode {
          tailf:info "Vinci specific Forwarding Modes";
          tailf:cli-diff-delete-before "/nx:fabric/forwarding/anycast-gateway-mac";
          type enumeration {
            enum "anycast-gateway";
          }
        }
      }
    }

    uses interface-vrrpv3-grouping;
  }

  grouping interface-vrrpv3-grouping {
    // interface * / vrrpv3 * address-family *
    list vrrpv3 {
      tailf:info "Configure VRRPv3 group parameters";
      when "../../../feature/vrrpv3" {
        tailf:dependency "../../../feature/vrrpv3";
      }
      tailf:cli-diff-dependency "/nx:feature/vrrpv3";
      tailf:cli-mode-name "config-if-vrrpv3-group";
      key "vr address-family";
      leaf vr {
        type uint8 {
          tailf:info "<1-255>;;VRRP Group ID";
          range "1..255";
        }
      }
      leaf address-family {
        tailf:info "IP address family";
        tailf:cli-expose-key-name;
        type enumeration {
          enum "ipv4" {
            tailf:info "IPv4";
          }
          enum "ipv6" {
            tailf:info "IPv6";
          }
        }
      }

      // interface * / vrrpv3 * address-family * / address *
      container address {
        tailf:info "IP address config";

        // interface * / vrrpv3 * address-family * / address * primary
        list ipv4-address-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-diff-delete-before "../ipv4-address-list";
          when "../../address-family = 'ipv4'" {
            tailf:dependency "../../address-family";
          }
          key "address type";
          leaf address {
            tailf:cli-incomplete-command;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IPv4 Address";
            }
          }
          leaf type {
            type enumeration {
              enum primary {
                tailf:info "Primary Address";
              }
              enum secondary {
                tailf:info "Secondary Address";
              }
            }
          }
        }

        // interface * / vrrpv3 * address-family * / address * secondary
        list ipv6-address-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-diff-delete-before "../ipv6-address-list";
          when "../../address-family = 'ipv6'" {
            tailf:dependency "../../address-family";
          }
          key address;
          leaf address {
            type inet:ipv6-address {
              tailf:info "A:B::C:D;;IPv6 Address";
            }
          }
          leaf primary {
            tailf:info "Primary Address";
            type empty;
          }
        }
      }

      // interface * / vrrpv3 * address-family * / preempt
      container preempt {
        tailf:info "Enable preemption of lower priority Master";

        container delay {
          tailf:info "Wait before preempting";

          leaf minimum {
            tailf:info "Delay at least this long";

            type uint16 {
              tailf:info "<0-3600>;;Seconds to delay";
              range "0..3600";
            }
            default 0;
          }
        }
      }

      // interface * / vrrpv3 * address-family * / priority
      leaf priority {
        tailf:info "Priority of this VRRP group";
        tailf:cli-full-command;

        type uint8 {
          tailf:info "<1-254>;;Priority level";
          range "1..254";
        }
        default 100;
      }
    }
  }

  // interface Ethernet *
  // interface Vethernet *
  // interface port-channel *
  // interface Vlan *
  grouping interface-ether-and-vlan-grouping {
    // interface * / bandwidth
    container bandwidth {
      tailf:info "Set bandwidth information parameter";
      container inherited {
        tailf:cli-drop-node-name;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        leaf inherit {
          tailf:info "Specify that bandwith is inherited";
          type empty;
        }
        leaf bandwidth {
          tailf:cli-drop-node-name;
          default 1000000;
          type uint32 {
            tailf:info "<1-400000000>;;Bandwidth in kilobits";
          }
        }
      }
      leaf bandwidth {
        tailf:cli-drop-node-name;
        default 1000000;
        type uint32 {
          tailf:info "<1-400000000>;;Bandwidth in kilobits";
        }
      }
    }

    // interface * / load-interval
    container load-interval {
      tailf:info "Specify interval for load calculation for an "
        +"interface";
      leaf interval {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<5-600>;;Load interval delay in seconds";
          range "5..600";
        }
      }
      list counter {
        tailf:info "Specify counter for this load interval";
        tailf:cli-incomplete-command;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key id;
        leaf id {
          type uint8 {
            tailf:info "<1-3>;;Specify counter for this load interval";
            range "1..3";
          }
        }
        leaf interval {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<5-600>;;Load interval delay in seconds";
          }
        }
      }
    }

    // interface * / mtu
    leaf mtu {
      tailf:info "Configure mtu for the port";
      tailf:cli-full-command;
      tailf:cli-diff-dependency "../../../system/jumbomtu";
      nx:trim-default-in-show {
        when "/tailfned/show-interface-all or /tailfned/true-mtu-values";
      }
      nx:delete-with "default" {
        when "/tailfned/show-interface-all or /tailfned/true-mtu-values";
      }
      default 1500;
      type uint16 {
        tailf:info "MTU size in bytes";
      }
    }

    // interface * / delay
    leaf delay {
      tailf:info "Specify interface throughput delay";
      tailf:cli-full-command;
      default 1;
      type uint32 {
        tailf:info "<1-16777215>;;Throughput delay (tens of "
          +"microseconds)";
        range "1..16777215";
      }
    }

    // interface * / mac-address
    leaf mac-address {
      tailf:info "Configure interface mac address";
      tailf:cli-full-command;
      type mac-address-type;
    }

    // interface * / hsrp
    container hsrp {
      when "../../../feature/hsrp";
      tailf:cli-diff-dependency "../../../feature/hsrp";
      leaf version {
        default 1;
        type uint16;
      }
      // interface * / hsrp delay
      container delay {
        tailf:info "HSRP initialisation delay";
        tailf:cli-compact-syntax;
        // interface * / hsrp minimum
        leaf minimum {
          tailf:info "Minimum delay";
          tailf:cli-no-value-on-delete;
          tailf:cli-no-name-on-delete;
          tailf:cli-reset-container;
          default 0;
          type uint16 {
            tailf:info "0-10000;;<0-10000> Delay in seconds";
            range "0..10000";
          }
        }
        // interface * / hsrp reload
        leaf reload {
          tailf:info "Delay after reload";
          tailf:cli-no-value-on-delete;
          tailf:cli-no-name-on-delete;
          tailf:cli-reset-container;
          default 0;
          type uint16 {
            tailf:info "0-10000;;<0-10000> Delay in seconds";
            range "0..10000";
          }
        }
      }
      // interface * / hsrp bfd
      leaf bfd {
        tailf:info "BFD protocol";
        tailf:cli-boolean-no;
        when "../../../../feature/bfd";
        tailf:cli-diff-dependency "../../../../feature/bfd";
        default "false";
        type boolean;
      }
      // interface * / hsrp mac-refresh
      leaf mac-refresh {
        tailf:info "Interface mac-refresh time";
        tailf:cli-no-value-on-delete;
        type uint16 {
          tailf:info "0-10000;;Timeout value (0-10000) in sec";
          range "0..10000";
        }
      }
      list hsrp-list {
        tailf:cli-drop-node-name;
        tailf:cli-diff-dependency "../version";
        tailf:cli-explicit-exit;
        tailf:cli-diff-delete-before "../../vrf/member";
        tailf:cli-diff-delete-before "../hsrp-list";

        key "id addr_type";
        leaf id {
          type uint16;
        }
        leaf addr_type {
          tailf:key-default "ipv4";
          type enumeration {
            enum ipv4 {
              tailf:info "Configure IP Version 4 group";
            }
            enum ipv6 {
              tailf:info "Configure IP Version 6 group";
            }
          }
        }
        container authentication {
          tailf:info "Authentication";
          choice text-or-md5 {
            leaf text {
              tailf:info "Plain text authentication string (Max Size 8)";
              type string {
                length "1..8";
              }
            }
            container md5 {
              choice chain-or-string {
                leaf key-chain {
                  tailf:info "Set key chain";
                  type string {
                    tailf:info "WORD;;Name of key-chain (Max Size 250)";
                    length "1..250";
                  }
                }
                leaf key-string {
                  tailf:info "Set key string";
                  type string {
                    tailf:info "WORD;;Key string (64 chars max) (Max Size 64)";
                  }
                }
              }
            }
          }
        }
        list ip {
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-diff-delete-before "../../hsrp-list/ip" {
            tailf:cli-when-target-create;
          }
          tailf:cli-diff-delete-before "../../../ip/address/ipaddr" {
            tailf:cli-when-target-set;
          }
          tailf:cli-diff-set-after "../../../ip/address/ipaddr" {
            tailf:cli-when-target-delete;
          }
          key address;
          leaf address {
            type union {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Virtual IP address";
              }
              type inet:ipv6-address {
                tailf:info "A:B::C:D;;Virtual IPV6 address";
              }
              type enumeration {
                enum autoconfig {
                  tailf:info "Obtain address using autoconfiguration";
                }
              }
            }
          }
          leaf secondary {
            tailf:info "Make this IP address a secondary virtual IP address";
            type empty;
          }
        }
        leaf mac-address {
          tailf:info "Virtual MAC address";
          type mac-address-type;
        }
        container timers {
          tailf:info "Hello and hold timers";
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-compact-syntax;
          choice hello-choice {
            leaf hello-msec {
              tailf:info "Specify hello interval in milliseconds";
              tailf:alt-name "msec";
              tailf:cli-incomplete-command;
              type uint16 {
                tailf:info "<250-999>;;Hello interval in milliseconds";
                range "250..999";
              }
            }
            leaf hello-seconds {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              // #if (NETSIM != "YES")
              default 3;
              // #endif
              type uint8 {
                tailf:info "<1-254>;;Hello time in seconds";
              }
            }
          }
          choice hold-choice {
            leaf hold-msec {
              tailf:info "Specify hold interval in milliseconds";
              tailf:alt-name "msec";
              type uint16 {
                tailf:info "<750-3000>;;Hold interval in milliseconds";
                range "750..3000";
              }
            }
            leaf hold-seconds {
              tailf:cli-drop-node-name;
              // #if (NETSIM != "YES")
              default 10;
              // #endif
              type uint8 {
                tailf:info "<3-255>;;Hold time in seconds";
              }
            }
          }
        }
        list track {
          tailf:info "Associates track object to HSRP group";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key id;
          leaf id {
            tailf:non-strict-leafref {
              path "/nx:track/id";
            }
            type uint16 {
              tailf:info "<1-512>;;Set the object number to the group";
            }
          }
          leaf decrement {
            tailf:info "<1-255>;;Set the value to decrement from priority";
            type uint8 {
              range "1..255";
            }
          }
        }

        container preempt {
          tailf:info "Overthrow lower priority Active routers";
          presence "true";
          container delay {
            tailf:info "Wait before preempting";
            tailf:cli-compact-syntax;
            leaf minimum {
              tailf:info "Delay at least this long";
              type uint16 {
                tailf:info "<0-3600>;;Number of seconds for minimum delay";
                range "0..3600";
              }
            }
            leaf reload {
              tailf:info "Delay after reload";
              type uint16 {
                tailf:info "<0-3600>;;Number of seconds for reload delay";
                range "0..3600";
              }
            }
            leaf sync {
              tailf:info "Wait for IP redundancy clients";
              type uint16 {
                tailf:info "<0-3600>;;Number of seconds for reload delay";
                range "0..3600";
              }
            }
          }
        }
        choice prio-choice {
          leaf priority {
            tailf:info "Priority level";
            tailf:cli-full-command;
            type uint8 {
              tailf:info "<0-255>;;Priority value";
            }
          }
          container prio-and-threshold {
            tailf:cli-drop-node-name;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf priority {
              tailf:info "Priority level";
              tailf:cli-incomplete-command;
              type uint8 {
                tailf:info "<0-255>;;Priority value";
              }
            }
            leaf forwarding-threshold {
              tailf:info "forwarding-threshold  Set forwarding threshold";
              tailf:cli-incomplete-command;
              type empty;
            }
            leaf lower {
              tailf:info "Set lower threshold value";
              tailf:cli-incomplete-command;
              type uint8 {
                tailf:info "<0-255>;;Lower threshold value";
              }
            }
            leaf upper {
              tailf:info "Set upper threshold value";
              type uint8 {
                tailf:info "<0-255>;;Upper threshold value";
              }
            }
          }
        }
        leaf name {
          tailf:info "Redundancy name string";
          type string {
            tailf:info "WORD;;Name string (Max Size 250)";
            length "1..250";
          }
        }
        leaf follow {
          tailf:info "Group to be followed";
          type string {
            tailf:info "WORD;;Master name string to follow (Max Size 250)";
          }
        }
      }
    }

    // interface * / vrrp *
    list vrrp {
      tailf:info "VRRP configuration commands";
      tailf:cli-diff-dependency "../../../feature/vrrp";
      when "../../../feature/vrrp" {
        tailf:dependency "../../../feature/vrrp";
      }
      key vr;
      leaf vr {
        type uint8 {
          tailf:info "<1-255>;;IPv4 VR group number";
          range "1..255";
        }
      }
      leaf address {
        tailf:info "Add an IP address to the vr";
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Ip address";
        }
      }
      leaf advertisement-interval {
        tailf:info "Set the time interval between advertisement";
        type uint8 {
          tailf:info "<1-255>;;Time interval (in seconds) between advertisement"
            +"s";
          range "1..255";
        }
      }

      container authentication {
        tailf:info "Select authentication method";

        choice authentication-choice {
          leaf word {
            tailf:cli-drop-node-name;
            tailf:cli-disallow-value "text";
            type string {
              tailf:info "text;;Set the authentication password (8 char max)";
              length "1..8";
            }
          }
          leaf text {
            tailf:info "Set the authentication password (8 char max)";
            type string {
              tailf:info "WORD;;(Max Size 8)";
              length "1..8";
            }
          }
        }
      }

      leaf preempt {
        tailf:info "Enable preemption of lower priority master";
        type empty;
      }
      container priority {
        tailf:info "Configure the vr priority";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf value {
          tailf:info "<1-254>;;Configure the vr priority";
          tailf:cli-drop-node-name;
          type uint8 {
            range "1..254";
          }
        }
        container forwarding-threshold {
          tailf:info "Set forwarding threshold";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-flatten-container;
          leaf lower {
            tailf:info "Set lower threshold value";
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<1-254>;;Lower threshold value";
              range "1..254";
            }
          }
          leaf upper {
            tailf:info "Set upper threshold value";
            tailf:cli-full-command;
            type uint8 {
              tailf:info "<1-254>;;Upper threshold value";
              range "1..254";
            }
          }
        }
      }
      leaf shutdown {
        tailf:info "Enable or disable a VR";
        tailf:cli-show-no;
        tailf:cli-full-command;
        type empty;
      }
      container track {
        tailf:info "Track the availability of another interface/object";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        choice track {
          case a {
            leaf interface {
              tailf:info "Select the tracked interface(Native tracking)";
              tailf:cli-incomplete-command;
              type string;
            }
            leaf priority {
              tailf:info "Vr priority used when the tracked interface is down";
              tailf:cli-full-command;
              type uint8 {
                tailf:info "<1-254>";
                range "1..254";
              }
            }
          }
          case b {
            leaf object {
              tailf:cli-drop-node-name;
              tailf:non-strict-leafref {
                path "/nx:track/id";
              }
              type uint16 {
                tailf:info "<1-500>;;Set the object number to the group";
                range "1..500";
              }
            }
            leaf decrement {
              tailf:info "Decrements priority when tracked object goes down";
              type uint8 {
                tailf:info "<1-254>;;Set the value to decrement from priority";
                range "1..254";
              }
            }
          }
        }
      }
    }

    // interface * / snmp
    container snmp {
      tailf:info "Modify SNMP interface parameters";
      container trap {
        tailf:info "Allow a specific SNMP trap";
        leaf link-status {
          tailf:info "Allow SNMP LINKUP and LINKDOWN traps";
          tailf:cli-boolean-no;
          default true;
          type boolean;
        }
      }
    }

    // interface * / evpn
    container evpn {
      tailf:info "VxLAN evpn feature";
      leaf multisite {
        tailf:info "VxLAN evpn multisite";
        tailf:cli-diff-delete-before "/nx:evpn-flat-syntax/evpn/multisite";
        type enumeration {
          enum dci-tracking {
            tailf:info "Dci interface tracking";
          }
          enum fabric-tracking {
            tailf:info "Fabric interface tracking";
          }
        }
      }
    }

    // interface * / mpls
    container mpls {
      tailf:info "MPLS configuration commands";
      container enable-ip {
        tailf:cli-drop-node-name;
        leaf ip {
          tailf:info "Enable IP over MPLS";
          tailf:cli-full-command;
          type empty;
        }
      }
      container ip {
        tailf:info "Enable IP over MPLS";
        tailf:cli-incomplete-command;
        leaf forwarding {
          tailf:info "Enable MPLS forwarding on the interface";
          tailf:cli-diff-dependency "/nx:feature/mpls/segment-routing";
          type empty;
        }
      }
    }

    // interface * / inherit
    container inherit {
      tailf:info "Inherit a port-profile";
      leaf port-profile {
        tailf:info "Inherit a port-profile";
        tailf:non-strict-leafref {
          path "/nx:port-profile/profiles/id";
        }
        tailf:cli-remove-before-change;
        type string {
          tailf:info "WORD;;Enter the name of the profile";
        }
      }
    }

  }

  grouping interface-phys-ethernet-grouping {
    // interface * / lacp
    container lacp {
      tailf:info "Set LACP parameters for the interface";
      tailf:cli-diff-dependency "../../../feature/lacp";
      // interface * / lacp port-priority
      leaf port-priority {
        tailf:info "Set LACP port priority";
        type uint16 {
          tailf:info "<1-65535>;;Enter port priority";
          range "1..65535";
        }
      }
      leaf rate {
        tailf:info "Configure rate at which LACP PDUs are sent by the peer switch";
        default normal;
        type enumeration {
          enum fast {
            tailf:info "Specifies that LACP control packets should be transmitted at the fast rate by the peer, once every 1 second";
          }
          enum normal {
            tailf:info "Specifies that LACP control packets should be transmitted at the normal rate by the peer, every 30 seconds after the link is bundled";
          }
        }
      }
    }

    // interface * / channel-group
    container channel-group {
      tailf:info "Configure port channel parameters";
      tailf:cli-diff-dependency "/nx:interface/port-channel";
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-compact-syntax;
      leaf id {
        tailf:cli-drop-node-name;
        tailf:cli-delete-container-on-delete;
        // TODO:
        //        tailf:cli-diff-dependency "../../switchport";
        type uint16 {
          tailf:info "<1-4096>;;Specify a port-channel number";
        }
      }
      leaf mode {
        tailf:info "Specify channeling mode";
        tailf:cli-no-name-on-delete;
        tailf:cli-no-value-on-delete;
        type enumeration {
          enum "active" {
            tailf:info "Set channeling mode to ACTIVE";
          }
          enum "on" {
            tailf:info "Set channeling mode to ON";
          }
          enum "passive" {
            tailf:code-name "mode_passive";
            tailf:info "Set channeling mode to PASSIVE";
          }
        }
      }
    }

    // interface * / beacon
    leaf beacon {
      tailf:info "Disable/enable the beacon for an interface";
      tailf:cli-full-command;
      type empty;
    }

    // interface * / link
    container link {
      tailf:info "Configure link";
      container debounce {
        tailf:info "Configure link debounce timer";
        presence "Configure link debounce timer";
        leaf time {
          tailf:info "Link debounce time";
          type uint16 {
            tailf:info "<0-5000>;;Timer value (in milliseconds)";
            range "0..5000";
          }
        }
        container link-up {
          tailf:info "Timer for the link-up event";
          leaf time {
            tailf:info "Link debounce time";
            type uint16 {
              tailf:info "<1000-10000>;;Timer value (in milliseconds)";
            }
          }
        }
      }
    }

    // interface Ethernet * / speed-group
    leaf speed-group {
      type enumeration {
        enum "10000" {
          tailf:info "10Gb/s";
        }
        enum "40000" {
          tailf:info "40Gb/s";
        }
      }
    }

    leaf fec {
      tailf:info "Forwarding error correction";
      type enumeration {
        enum auto {
          tailf:info "Enables the FEC feature based on the transceiver type.";
        }
        enum cl74 {
          tailf:info "Enable clause74 with 25G or 50G";
        }
        enum cl91 {
          tailf:info "Enable clause91 with 100G";
        }
        enum fc-fec {
          tailf:info "CL74(25/50G)";
        }
        enum rs-cons16 {
          tailf:info "RS FEC Consortium 1.6 (25G)";
        }
        enum rs-fec {
          tailf:info "CL91(100G) or Consortium 1.5 (25/50G)";
        }
        enum rs-ieee {
          tailf:info "RS FEC IEEE (25G)";
        }
        enum off {
          tailf:info "Turn FEC off";
        }
      }
    }

  }

  grouping mvr-cfg-grouping {
    list mvr-group {
      tailf:info "MVR config";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-remove-before-change;
      key address;
      leaf address {
        tailf:cli-suppress-range;
        type union {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Group IP Address";
          }
          type tailf:ipv4-address-and-prefix-length {
            tailf:info "A.B.C.D/LEN;;IP prefix and network mask length in format x.x.x.x/m";
          }
        }
      }
      leaf mask {
        tailf:cli-drop-node-name;
        when "not(contains(../address, '/'))" {
          tailf:dependency "../address";
        }
        tailf:cli-optional-in-sequence;
        type inet:ipv4-address {
          tailf:info "A.B.C.D  IP network mask in format m.m.m.m";
        }
      }
      leaf count {
        when "not(contains(../address, '/')) and not(../mask)" {
          tailf:dependency "../address";
          tailf:dependency "../mask";
        }
        tailf:cli-optional-in-sequence;
        tailf:info "Number of contiguous groups";
        type uint8 {
          tailf:info "<1-64>;;Number of contiguos groups";
        }
      }
      leaf vlan {
        tailf:info "Global default MVR vlan";
        type uint16 {
          tailf:info "<1-4094>;;Enter MVR Vlan";
        }
      }
    }
    leaf mvr-vlan {
      tailf:info "Interface MVR Config";
      type uint16 {
        tailf:info "<1-4094>;;Enter MVR Vlan";
      }
    }
  }

  // interface Ethernet *
  // interface Vethernet *
  // interface port-channel *
  grouping interface-ethernet-grouping {

    uses interface-ether-and-vlan-grouping {
      refine evpn {
        tailf:cli-diff-dependency "../enable/switchport";
      }
    }

    // interface * / medium
    leaf medium {
      tailf:info "Configure interface medium mode";
      tailf:cli-full-command;
      default "broadcast";
      when "not(../enable/switchport = 'true')";
      type enumeration {
        enum "broadcast" {
          tailf:code-name "medium_broadcast";
          tailf:info "Broadcast medium";
        }
        enum "p2p" {
          tailf:info "Point-to-Point medium";
        }
      }
    }

    // interface * / fex
    container fex {
      tailf:info "Configure FEX fabric";
      leaf associate {
        tailf:info "Associate the port to a FEX";
        tailf:non-strict-leafref {
          path "/nx:fex/id";
        }
        type uint8 {
          tailf:info "<100-199>;;FEX number";
          range "100..199";
        }
      }
    }

    // interface * / priority-flow-control
    container priority-flow-control {
      tailf:info "Enable/Disable PFC";
      leaf mode {
        tailf:info "PFC Mode";
        type enumeration {
          enum "auto" {
            tailf:code-name "prio_flow_control_auto";
            tailf:info "Set Auto Mode";
          }
          enum "off" {
            tailf:code-name "prio_flow_off";
            tailf:info "Force PFC to Off";
          }
          enum "on" {
            tailf:code-name "prio_flow_on";
            tailf:info "Force PFC to Of";
          }
        }
      }
    }

    // interface * / flowcontrol
    container flowcontrol {
      tailf:info "Configure interface flowcontrol";
      leaf receive {
        tailf:info "Receive pause frames";
        tailf:cli-full-command;
        nx:flowcontrol-delete-with-toggle;
        type enumeration {
          enum "off" {
            tailf:info "Receive OFF";
          }
          enum "on" {
            tailf:info "Receive ON";
          }
          enum desired {
            tailf:info "Receive desired";
          }
        }
      }
      leaf send {
        tailf:info "Send pause frames";
        tailf:cli-full-command;
        nx:flowcontrol-delete-with-toggle;
        type enumeration {
          enum "off" {
            tailf:info "Send OFF";
          }
          enum "on" {
            tailf:info "Send ON";
          }
          enum desired {
            tailf:info "Receive desired";
          }
        }
      }
    }

    // interface * / service
    container service {
      tailf:info "VNI Service command";
      tailf:cli-diff-dependency "../../../feature/vni";
      tailf:cli-diff-dependency "../../../encapsulation/profile";
      when "../../../feature/vni" {
        tailf:dependency "../../../feature/vni";
      }
      // interface * / service instance *
      list instance {
        tailf:info "VNI Service Instance Command";
        tailf:cli-incomplete-command;
        tailf:cli-sequence-commands;
        tailf:cli-compact-syntax;
        key service-id;
        leaf service-id {
          tailf:info "<1-4094>;;VNI Service Instance ID";
          tailf:cli-disallow-value "vni";
          tailf:cli-optional-in-sequence;
          tailf:key-default "__empty_key__";
          nx:trim-default-key;
          type union {
            type uint16 {
              tailf:info "<1-4094>;;VNI Service Instance ID";
              range "1..4094";
            }
            type string;
          }
        }
        // interface * / service instance * vni <CR>
        container vni {
          tailf:info "Virtual Network Identifier";
          presence "Virtual Network Identifier";
          tailf:cli-hide-in-submode;
          tailf:cli-flatten-container;
          // interface * / service instance * vni default <CR>
          leaf default {
            tailf:info "Default Service Instance";
            tailf:cli-remove-before-change;
            when "../../service-id = '__empty_key__'" {
              tailf:dependency "../../service-id";
            }
            type empty;
          }
        }
        // interface * / service instance * / shutdown
        leaf shutdown {
          tailf:info "No shutdown on VNI service instance";
          tailf:cli-break-sequence-commands;
          tailf:cli-full-command;
          tailf:cli-show-no;
          when "../service-id != '__empty_key__'" {
            tailf:dependency "../service-id";
          }
          type empty;
        }
        // interface * / service instance * vni * / description LINE
        // <CR>
        leaf description {
          tailf:info "Description of VNI service instance";
          tailf:cli-break-sequence-commands;
          tailf:cli-full-command;
          tailf:cli-multi-value;
          tailf:cli-preformatted;
          tailf:cli-no-value-on-delete;
          type string {
            tailf:info "LINE;;Description of maximum 80 characters "
              +"(Max Size 80)";
            length "1..80";
          }
        }
        // interface * / service instance * vni * / encapsulation
        container encapsulation {
          tailf:info "Encapsulation command under service instance";
          choice encapsulation-choice {
            // interface * / service instance * vni * / encapsulation
            // / dynamic
            container dynamic {
              tailf:info "Enable auto-configuration for this vsi";
              when "../../service-id = '__empty_key__'" {
                tailf:dependency "../../service-id";
              }
              choice dynamic-choice {
                // interface * / service instance * vni * /
                // encapsulation dynamic frame-snoop
                container frame-snoop {
                  tailf:info "Enable frame snooping auto-configuration "
                    +"for this vsi";
                  // interface * / service instance * vni * /
                  // encapsulation dynamic frame-snoop profile WORD <CR>
                  leaf profile {
                    tailf:info "Specify profile name";
                    tailf:cli-remove-before-change;
                    type leafref {
                      path "/nx:encapsulation/profile/vni/name";
                      tailf:info "WORD;;Profile name";
                    }
                  }
                }
                // interface * / service instance * vni * /
                // encapsulation / dynamic / vdp
                container vdp {
                  tailf:info "Enable VDP auto-configuration for this vsi";
                  presence "Enable VDP auto-configuration for this vsi";
                  // interface * / service instance * vni * /
                  // encapsulation dynamic vdp exception-list * <CR>
                  leaf-list exception-list {
                    tailf:info "Exclude VDP auto-configuration on "
                      +"certain vlans for this vsi";
                    tailf:cli-range-list-syntax;
                    tailf:cli-remove-before-change;
                    type uint16 {
                      tailf:info "<2-4095>;;Exception vlan id";
                    }
                  }
                }
              }
            }
            // interface * / service instance * vni * /
            // encapsulation profile
            container profile {
              tailf:info "Encapsulation Profile";
              tailf:cli-compact-syntax;
              tailf:cli-incomplete-command;
              tailf:cli-incomplete-no;
              tailf:cli-sequence-commands;
              leaf name {
                tailf:info "VNI Encapsulation Profile Name";
                tailf:cli-drop-node-name;
                tailf:cli-remove-before-change;
                tailf:cli-incomplete-command;
                tailf:cli-incomplete-no;
                type leafref {
                  path "/nx:encapsulation/profile/vni/name";
                  tailf:info "WORD;;VNI Encapsulation Profile Name "
                    +"(Max Size 128)";
                }
              }
              // interface * / service instance * vni * /
              leaf default {
                tailf:info "Encapsulation default under service instance";
                type empty;
              }
            }
            container dot1q-profile {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              tailf:cli-diff-dependency "../untagged" {
                tailf:cli-trigger-on-set;
              }
              list profile {
                tailf:info "Encapsulation Profile";
                tailf:cli-recursive-delete;
                tailf:cli-remove-before-change;
                tailf:cli-exit-command "!end-profile";
                // NOTE: This is a fake mode, handled in this extension
                nx:iface-encap-profile-dot1q;
                max-elements "1";
                key name;
                leaf name {
                  tailf:non-strict-leafref {
                    path "/nx:encapsulation/profile/vni/name";
                  }
                  type string {
                    tailf:info "WORD;;VNI Encapsulation Profile Name "
                      +"(Max Size 128)";
                    length "1..128";
                  }
                }
                list dot1q {
                  tailf:info "Dot1q";
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  key vlan-id;
                  leaf vlan-id {
                    tailf:non-strict-leafref {
                      path "/nx:encapsulation/profile/vni/dot1q/vlan-id";
                    }
                    type uint16 {
                      tailf:info "<2-4095>;;Encapsulation vlan id";
                      range "2..4095";
                    }
                  }
                }
              }
            }
          }
          container untagged {
            tailf:info "Untagged traffic";
            tailf:cli-diff-dependency "../dot1q-profile" {
              tailf:cli-trigger-on-set;
            }
            container dot1q {
              tailf:info "Untag dot1q";
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              tailf:cli-compact-syntax;
              leaf vlan-id {
                tailf:cli-drop-node-name;
                tailf:cli-remove-before-change;
                tailf:cli-incomplete-command;
                type uint16 {
                  tailf:info "<2-4095>;;Encapsulation vlan id";
                  range "2..4095";
                }
              }
              leaf vni {
                tailf:info "VNI corresponding to Untagged traffic";
                type uint32 {
                  tailf:info "<4096-16777215>;;Enter VN-Segment ID";
                  range "4096..16777215";
                }
              }
            }
          }
        }
      }
    }

    // interface * / service-policy
    container service-policy {
      tailf:info "Configure service policy for an interface";
      // interface * / service-policy type
      container type {
        tailf:info "Specify the type of this policy";
        // interface * / service-policy type qos
        container qos {
          tailf:info "Qos policy";
          // interface * / service-policy type qos input
          container input {
            tailf:info "Input Service Policy";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            tailf:cli-diff-delete-before "../../../../switchport/mode";
            tailf:cli-diff-set-after "../../../../switchport/mode";
            leaf name {
              tailf:cli-drop-node-name;
              tailf:cli-reset-container;
              tailf:non-strict-leafref {
                path "/nx:policy-map/type/qos/name";
              }
              type policy-map-name-type;
            }
            leaf no-stats {
              tailf:info "Disable statistics for this policy";
              type empty;
            }
          }
          // interface * / service-policy type qos output
          container output {
            tailf:info "Output Service Policy";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            tailf:cli-diff-delete-before "../../../../switchport/mode";
            tailf:cli-diff-set-after "../../../../switchport/mode";
            leaf name {
              tailf:cli-drop-node-name;
              tailf:cli-reset-container;
              tailf:non-strict-leafref {
                path "/nx:policy-map/type/qos/name";
              }
              type policy-map-name-type;
            }
            leaf no-stats {
              tailf:info "Disable statistics for this policy";
              type empty;
            }
          }
        }
        // interface * / service-policy type queuing
        container queuing {
          tailf:info "Queuing policy";
          // interface * / service-policy type queuing input
          container input {
            tailf:info "Input Service Policy";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf name {
              tailf:cli-drop-node-name;
              tailf:cli-reset-container;
              tailf:non-strict-leafref {
                path "/nx:policy-map/type/queuing/name";
              }
              type policy-map-name-type;
            }
            leaf no-stats {
              tailf:info "Disable statistics for this policy";
              type empty;
            }
          }
          // interface * / service-policy type queuing output
          container output {
            tailf:info "Output Service Policy";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf name {
              tailf:cli-drop-node-name;
              tailf:cli-reset-container;
              tailf:non-strict-leafref {
                path "/nx:policy-map/type/queuing/name";
              }
              type policy-map-name-type;
            }
            leaf no-stats {
              tailf:info "Disable statistics for this policy";
              type empty;
            }
          }
        }
        leaf network-qos {
          tailf:info "Network Qos policy";
          tailf:non-strict-leafref {
            path "/nx:policy-map/type/network-qos/name";
          }
          type policy-map-name-type;
        }
      }
    }

    // interface * / spanning-tree
    container spanning-tree {
      tailf:info "Spanning Tre Subsystem";
      // interface * / spanning-tree bpdufilter
      leaf bpdufilter {
        tailf:info "Don't send or receive BPDUs on this interface";
        tailf:cli-full-command;
        type enumeration {
          enum disable {
            tailf:code-name bdufilter_disable;
            tailf:info "Disable BPDU filtering for this "
            +"interface";
          }
          enum enable {
            tailf:code-name bdufilter_enable;
            tailf:info "Enable BPDU filtering for this "
            +"interface";
          }
        }
      }

      // interface * / spanning-tree bpduguard
      leaf bpduguard {
        tailf:info "Don't accept BPDUs on this interface";
        tailf:cli-full-command;
        type enumeration {
          enum "disable" {
            tailf:code-name "bduguard_disable";
            tailf:info "Disable BPDU Guard for this interface";
          }
          enum "enable" {
            tailf:code-name "bduguard_enable";
            tailf:info "Enable BPDU Guard for this interface";
          }
        }
      }

      // interface * / spanning-tree cost
      leaf cost {
        tailf:info "Change an interface's spanning tree port path cost";
        type union {
          type uint32 {
            tailf:info "<1-200000000>;;Port path cost";
            range "1..200000000";
          }
          type enumeration {
            enum auto {
              tailf:code-name spanning-tree-cost-type-auto;
              tailf:info "Determine cost based on media speed of this "
              +"interface";
            }
          }
        }
      }

      // interface * / spanning-tree guard
      leaf guard {
        tailf:info "Change an interface's spanning tree guard mode";
        tailf:cli-full-command;
        type enumeration {
          enum "loop" {
            tailf:info "Set guard mode to loop guard on "
              +"interface";
          }
          enum "none" {
            tailf:info "Set guard mode to none";
          }
          enum "root" {
            tailf:info "Set guard mode to root guard on "
              +"interface";
          }
        }
      }

      // interface * / spanning-tree link-type
      leaf link-type {
        tailf:info "Specify a link type for spanning tree tree "
          +"protocol use";
        tailf:cli-full-command;
        type enumeration {
          enum "auto" {
            tailf:code-name link_type_auto;
            tailf:info "Determine link type based on media "
              +"duplex of this interface";
          }
          enum "none" {
            tailf:info "Consider the interface as point-to-"
              +"point";
          }
          enum "root" {
            tailf:info "Consider the interface as shared";
          }
          enum point-to-point {
            tailf:info "Consider the interface as point-to-point";
          }
          enum shared {
            tailf:info "Consider the interface as shared";
          }
        }
      }

      // interface * / spanning-tree mst
      container mst {
        tailf:info "Multiple spanning tree configuration";
        // FIXME: fix range problem, check cost/port-priority
        // for example
        // spanning-tree mst 2,4 port-priority 0
        // spanning-tree mst 1,3 cost 10
        // spanning-tree mst 2 cost 100
        //
        // then doing
        // spanning-tree mst 2 cost 10
        //
        // spanning-tree mst 2,4 port-priority 0
        // spanning-tree mst 1-3 cost 10
        //
        // doing
        // spanning-tree mst 2 cost 100
        //
        // spanning-tree mst 2,4 port-priority 0
        // spanning-tree mst 1,3 cost 10
        // spanning-tree mst 2 cost 100
        //
        // doing
        // spanning-tree mst 1 port-priority 0
        // spanning-tree mst 3 port-priority 0
        // spanning-tree mst 2 port-priority 32
        //
        // spanning-tree mst 1,3-4 port-priority 0
        // spanning-tree mst 2 port-priority 32
        // spanning-tree mst 1,3 cost 10
        // spanning-tree mst 2 cost 100
        //
        // no spanning-tree mst 1 cost
        // no spanning-tree mst 1 port-priority
        list port {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key "range";
          leaf "range" {
            type string {
              tailf:info "<0-4094>;;MST instance list, example 0,2-4,6,8-12";
              pattern "\\d+(\\-\\d+)?(,\\d+(\\-\\d+)?)*";
            }
          }
          leaf cost {
            tailf:cli-full-command;
            tailf:info "Change an interface's spanning tree port path cost";
            type union {
              type uint32 {
                tailf:info "<1-200000000>;;Port path cost";
                range "1..200000000";
              }
              type enumeration {
                enum auto {
                  tailf:code-name mst_cost_type_auto;
                  tailf:info "Determine cost based on media speed of this "
                  +"interface";
                }
              }
            }
          }
          leaf port-priority {
            tailf:cli-full-command;
            tailf:info "Change an interface's spanning tree port priority";
            type uint8 {
              tailf:info "<0-240>;;Port priority in increments of 32";
              range "0..240";
            }
          }
        }
        leaf pre-standard {
          tailf:cli-full-command;
          tailf:info "Force pre-standard MST BPDU transmission on port";
          type empty;
        }
        container simulate {
          tailf:info "Enable spanning tree simulation";
          container pvst {
            tailf:info "Enable PVST simulation";
            presence "Enable PVST simulation";
            leaf disable {
              tailf:info "Disable PVST simulation on this interface";
              type empty;
            }
          }
        }
      }

      // interface * / spanning-tree port
      container port {
        tailf:info "Spanning tree port options";
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        leaf "type" {
          tailf:info "Specify a port type for spanning tree protocol use";
          type enumeration {
            enum edge {
              tailf:info "Consider the interface as edge "
              +"port (enable portfast)";
            }
            enum network {
              tailf:info "Consider the interface as inter-"
              +"switch link";
            }
            enum normal {
              tailf:info "Consider the interface as normal "
              +"spanning tree port";
            }
          }
        }
        leaf trunk {
          tailf:info "Consider the interface as edge port "
            +"(enable portfast) even in trunk mode";
          when "not(../type = 'normal')" {
            tailf:dependency "../type";
          }
          type empty;
        }
      }

      // interface * / spanning-tree port-priority
      leaf port-priority {
        tailf:info "Change an interface's spanning tree port "
          +"priority";
        type uint8 {
          tailf:info "<0-224>;;Port priority in increments of 32";
          range "0|32|64|96|128|160|192|224";
        }
      }

      list vlan {
        tailf:info "VLAN Switch Spanning Trees";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-range-list-syntax;
        key id;
        leaf id {
          type uint16 {
            tailf:info "<1-3967>;;Vlan range, Example: 1,3-5,7,9-11";
          }
        }
        leaf cost {
          tailf:info "Change an interface's spanning tree port path cost";
          type uint32 {
            tailf:info "<1-200000000>;;Port path cost";
          }
        }
        leaf port-priority {
          tailf:info "Change an interface's spanning tree port priority";
          type uint8 {
            tailf:info "<0-224>;;Spanning-tree port priority";
          }
        }
      }
    }

    // interface * / storm-control
    container storm-control {
      tailf:info "Configure Interface storm control";
      container broadcast {
        tailf:info "Broadcast";
        leaf level {
          tailf:info "Set allowed broadcast traffic level on this interface";
          tailf:cli-full-command;
          tailf:cli-diff-delete-before "../../unicast/level-pps/level" {
            tailf:cli-when-target-set;
          }
          tailf:cli-diff-delete-before "../../multicast/level-pps/level" {
            tailf:cli-when-target-set;
          }
          type decimal64 {
            fraction-digits 2;
            tailf:info "<0-100>;;Percentage";
            range "0..100";
          }
          default "100";
        }
        container level-pps {
          tailf:cli-drop-node-name;
          container level {
            tailf:cli-incomplete-command;
            leaf pps {
              tailf:info "Storm-control level is specified in packets per second";
              tailf:cli-diff-delete-before "../../../../broadcast/level" {
                tailf:cli-when-target-set;
              }
              tailf:cli-diff-set-after "../../../../unicast/level" {
                tailf:cli-when-target-delete;
              }
              tailf:cli-diff-set-after "../../../../multicast/level" {
                tailf:cli-when-target-delete;
              }
              type uint32 {
                tailf:info "<0-200000000>;;Enter the storm suppression level in pps";
              }
            }
          }
        }
      }
      container unicast {
        tailf:info "Unicast";
        leaf level {
          tailf:info "Set allowed unicast traffic level on this interface";
          tailf:cli-diff-delete-before "../../broadcast/level-pps/level" {
            tailf:cli-when-target-set;
          }
          tailf:cli-diff-delete-before "../../multicast/level-pps/level" {
            tailf:cli-when-target-set;
          }
          type decimal64 {
            fraction-digits 2;
            tailf:info "<0-100>;;Percentage";
            range "0..100";
          }
          default "100";
        }
        container level-pps {
          tailf:cli-drop-node-name;
          container level {
            tailf:cli-incomplete-command;
            leaf pps {
              tailf:info "Storm-control level is specified in packets per second";
              tailf:cli-diff-delete-before "../../../../broadcast/level" {
                tailf:cli-when-target-set;
              }
              tailf:cli-diff-delete-before "../../../../unicast/level" {
                tailf:cli-when-target-set;
              }
              tailf:cli-diff-set-after "../../../../multicast/level" {
                tailf:cli-when-target-delete;
              }
              type uint32 {
                tailf:info "<0-200000000>;;Enter the storm suppression level in pps";
              }
            }
          }
        }
      }
      container multicast {
        tailf:info "Multicast";
        leaf level {
          tailf:info "Set allowed multicast traffic level on this interface";
          tailf:cli-diff-delete-before "../../broadcast/level-pps/level" {
            tailf:cli-when-target-set;
          }
          tailf:cli-diff-delete-before "../../unicast/level-pps/level" {
            tailf:cli-when-target-set;
          }
          type decimal64 {
            fraction-digits 2;
            tailf:info "<0-100>;;Percentage";
            range "0..100";
          }
          default "100";
        }
        container level-pps {
          tailf:cli-drop-node-name;
          container level {
            tailf:cli-incomplete-command;
            leaf pps {
              tailf:info "Storm-control level is specified in packets per second";
              tailf:cli-diff-delete-before "../../../../broadcast/level" {
                tailf:cli-when-target-set;
              }
              tailf:cli-diff-delete-before "../../../../unicast/level" {
                tailf:cli-when-target-set;
              }
              tailf:cli-diff-delete-before "../../../../multicast/level" {
                tailf:cli-when-target-set;
              }
              type uint32 {
                tailf:info "<0-200000000>;;Enter the storm suppression level in pps";
              }
            }
          }
        }
      }
      container action {
        tailf:info "Action on storm control";
        leaf shutdown {
          tailf:info "Shutdown (Err-Disable) port";
          type empty;
        }
        leaf trap {
          tailf:info "Generate SNMP trap";
          type empty;
        }
      }

    }

    // interface * / mac
    container mac {
      tailf:info "MAC configuration commands";
      container port {
        tailf:info "Port policy";
        leaf access-group {
          tailf:info "Specify access control for packets";
          type string {
            tailf:info "WORD;;List name (Max Size 64)";
            length "1..64";
          }
        }
      }
    }

    leaf port-type {
      tailf:info "Identifies if port is fabric-facing or not";
      type string;
    }

    uses mvr-cfg-grouping;
    container mvr-type {
      tailf:info "MVR interface config";
      leaf receiver {
        tailf:info "Mvr receiver port";
        type empty;
      }
      leaf source {
        tailf:info "Mvr source port";
        type empty;
      }
    }
  }

  grouping ethernet-and-port-channel-grouping {
    // interface * / encapsulation
    container encapsulation {
      tailf:info "Set encapsulation type for an interface";
      when "contains(../name, '.')" {
        tailf:dependency "../name";
      }
      // interface * / encapsulation dot1Q
      container dot1Q {
        tailf:info "IEEE 802.1Q Virtual LAN";
        tailf:cli-sequence-commands;
        tailf:cli-compact-syntax;
        tailf:cli-case-insensitive;
        leaf vlan-id {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-4094>;;IEEE 802.1Q VLAN ID required";
            range "1..4094";
          }
        }
        leaf second-dot1q {
          tailf:info "Configure this subinterface as a 1Q-in-1Q subinterface";
          tailf:cli-optional-in-sequence;
          tailf:cli-full-command;
          type union {
            type enumeration {
              enum "any" {
                tailf:info "All Inner VLAN IDs not configured on another "
                  +"subinterface";
              }
            }
            type string {
              tailf:info ";;Second (inner) VLAN IDs e.g. "
                +"100,200-300,400,500-600";
            }
          }
        }
        leaf native {
          tailf:info "Make this as native vlan";
          type empty;
        }
      }
    }

    // interface * / untagged
    container untagged {
      tailf:info "Default to use for untagged packets on interface";
      leaf cos {
        tailf:info "IEEE 802.1Q class of service for QoS "
          +"classification";
        type uint8 {
          tailf:info "<0-7>;;COS value";
          range "0..7";
        }
      }
    }

    // interface * / vpc
    container vpc {
      tailf:info "Virtual Port Channel configuration";
      tailf:cli-diff-dependency "/nx:feature/vpc";
      tailf:cli-diff-dependency "/nx:vpc/domain";
      leaf port-channel-number {
        tailf:cli-drop-node-name;
        tailf:cli-remove-before-change;
        tailf:cli-diff-dependency "../peer-link" {
          tailf:cli-trigger-on-set;
        }
        type uint16 {
          tailf:info "<1-4096>;;Specify a Virtual Port Channel number";
        }
      }
      leaf peer-link {
        tailf:info "Specify if this link is used for peer communication";
        tailf:cli-diff-dependency "../port-channel-number" {
          tailf:cli-trigger-on-set;
        }
        type empty;
      }
      leaf orphan-port {
        tailf:info "Suspend a vPC port when the peer link of a vPC secondary"
          +" goes down";
        type enumeration {
          enum suspend;
        }
      }
    }

    // interface * / cts
    container cts {
      tailf:info "Config commands for CTS";
      tailf:cli-diff-dependency "/nx:feature/cts";
      //        dot1x   Use 802.1X for authentication and policy
      container manual {
        tailf:info "Supply local configuration for cts parameters";
        tailf:cli-add-mode;
        container policy {
          tailf:info "Enable and define policy to be applied";
          container dynamic {
            tailf:info "Apply to authorization server for policy";
            leaf identity {
              tailf:info "Specify identity of peer for authorization request";
              tailf:cli-diff-dependency "../../static/sgt" {
                tailf:cli-trigger-on-set;
              }
              type string {
                tailf:info "WORD;;Peer's device-id";
              }
            }
          }
          container static {
            tailf:info "Configure static policy";
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            tailf:cli-compact-syntax;
            leaf sgt {
              tailf:info "SGT tag for pkts from this device";
              tailf:cli-diff-dependency "../../dynamic/identity" {
                tailf:cli-trigger-on-set;
              }
              type uint16 {
                tailf:info "<2-65519>;;Sgt value input as decimal or hex. Allowed hex range <0x2-0xffef>";
              }
            }
            leaf trusted {
              tailf:info "Specify trust state of the link";
              type empty;
            }
          }
        }
      }
    }

  }

  grouping interface-port-channel-grouping {

    // interface * / lacp
    container lacp {
      tailf:info "Set LACP parameters for the interface";
      leaf graceful-convergence {
        tailf:info "Configure port-channel lacp graceful "
          +"convergence. Disable this only with lacp ports "
          +"connected to Non-Nexus peer. Disabling this with "
          +"Nexus peer can lead to port suspension";
        tailf:cli-boolean-no;
        default true;
        type boolean;
      }
      leaf suspend-individual {
        tailf:info "Configure lacp port-channel state. Enabling "
          +"this will cause lacp to put the port to suspend "
          +"instead of individual state in case it does not get "
          +"LACP BPDU from the peer ports in the port-channel";
        cli:context-value-inject "static" {
          cli:arguments "false";
          when "/tailfned/default-lacp-suspend-individual='false'";
        }
        tailf:cli-boolean-no;
        default true;
        type boolean;
      }
      leaf min-links {
        tailf:info "Configure the port-channel min-links";
        tailf:cli-diff-dependency "../max-bundle" {
          tailf:cli-trigger-on-set;
        }
        default 1;
        type uint8 {
          tailf:info "<1-16>;;Enter the min-link number";
        }
      }
      leaf max-bundle {
        tailf:info "Configure the port-channel max-bundle";
        tailf:cli-diff-dependency "../min-links" {
          tailf:cli-trigger-on-set;
        }
        type uint8 {
          tailf:info "<1-32>;;Enter the max-bundle number";
          range "1..32";
        }
      }
      leaf vpc-convergence {
        tailf:info "VPC convergence";
        tailf:cli-diff-dependency "/nx:feature/vpc";
        type empty;
      }
    }

    container port-channel {
      tailf:info "Configure port channel parameters";
      leaf min-links {
        tailf:info "Configure the port-channel min-links";
        type uint8 {
          tailf:info "<1-16>;;Enter the min-link number";
        }
      }
      container bfd {
        tailf:info "Enable BFD";
        leaf start {
          tailf:info "Start timer timeout value";
          type uint16 {
            tailf:info "<60-3600>;;BFD start timer timeout value in seconds (default off)";
          }
        }
        leaf destination {
          tailf:info "Configure IP address of BFD peer";
          tailf:cli-remove-before-change;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;BFD peer IPv4 address";
          }
        }
        leaf track-member-link {
          tailf:info "Enable per-member-link BFD on the port-channel interface";
          type empty;
        }
      }
    }

    // interface * / hardware
    container hardware {
      tailf:info "Hardware specific configuration";
      leaf multicast {
        tailf:info "Multicast traffic configuration";
        type enumeration {
          enum "hw-hash" {
            tailf:info "Use hardware hashing for multicast traffic "
              +"(default is software selection)";
          }
        }
      }
    }

    // interface * / link-state-trap
    leaf link-state-trap {
      tailf:info "Enable/disable link state change traps";
      tailf:cli-full-command;
      type empty;
    }

    // interface * / vem
    leaf vem {
      tailf:info "Virtual Ethernet Module";
      type uint16 {
        tailf:info "Enter VEM id";
      }
    }

    // interface * / ethernet-segment
    list ethernet-segment {
      tailf:info "Configure Ethernet-Segment";
      tailf:cli-diff-dependency "/nx:evpn-flat-syntax/evpn/esi/multihoming";
      max-elements "1";
      key es-id;
      leaf es-id {
        type uint32 {
          tailf:info "<1-16777215>;;Ethernet-segment number";
          range "1..16777215";
        }
      }

      leaf system-mac {
        tailf:info "Mac Address";
        type string {
          tailf:info "eeee.eeee.eeee;;Specify system mac address (Option 4)";
          pattern "[0-9a-f]{4}(\\.[0-9a-f]{4}){2}";
        }
      }
    }

  }

  grouping interface-nve-grouping {
    // interface * / auto-remap-replication-servers
    leaf auto-remap-replication-servers {
      tailf:info "Automatically re-map replication servers on "
        +"every replication server add";
      tailf:cli-full-command;
      type empty;
    }

    // interface * / description
    leaf description {
      tailf:info "Enter description of maximum 254 characters";
      tailf:cli-full-command;
      tailf:cli-multi-value;
      tailf:cli-preformatted;
      tailf:cli-no-value-on-delete;
      type string {
        tailf:info "LINE;;Description of maximum 254 characters";
        length "1..254";
      }
    }

    // interface * / host-reachability
    container host-reachability {
      tailf:info "Configure host reachability advertisement";
      tailf:cli-diff-delete-after "../global" {
        tailf:cli-when-target-delete;
      }
      leaf protocol {
        tailf:info "Control protocol to use";
        type enumeration {
          enum "bgp" {
            tailf:info "Border Gateway Protocol";
          }
          // enum controller {
          //   NOTE: need feature nxdb + controller <id>
          //   tailf:info "Controller";
          // }
          enum openflow {
            tailf:info "OpenFlow";
          }
          enum openflow-ir {
            tailf:info "OpenFlow-IR";
          }
        }
      }
    }

    container global {
      tailf:info "Global configurations for nve, inherited by VNIs";
      container ingress-replication {
        tailf:info "Configure ingress replication";
        leaf protocol {
          tailf:info "Control protocol to use";
          type enumeration {
            enum bgp { tailf:info "Border Gateway Protocol"; }
          }
        }
      }
      list mcast-group {
        tailf:info "NVE Multicast Group";
        tailf:cli-diff-set-after "../ingress-replication" {
          tailf:cli-when-target-delete;
        }
        tailf:cli-diff-delete-before "../ingress-replication" {
          tailf:cli-when-target-set;
        }
        tailf:cli-suppress-mode;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        key type;
        leaf mcast-addr {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          tailf:cli-no-value-on-delete;
          tailf:cli-remove-before-change;
          tailf:cli-prefix-key;
          type inet:ipv4-address {
            tailf:info "A.B.C.D  Multicast IP Prefix";
          }
        }
        leaf type {
          type enumeration {
            enum L2 { tailf:info "Global mcast-group <> for L2 VNIs"; }
            enum L3 { tailf:info "Global mcast-group <> for L3 VNIs"; }
          }
        }
      }
      leaf suppress-arp {
        tailf:info "Enable ARP suppression";
        type empty;
      }
    }

    // interface * / member
    container member {
      tailf:info "NVE VN-Segment Membership";
      list vni {
        tailf:info "vni;;Virtual Network Identifier";
        tailf:cli-diff-dependency "/nx:vlan/vlan-list/vn-segment";
        key id;
        leaf id {
          type union {
            type uint32 {
              tailf:info "<4096-16777215>;;Vni value";
            }
            type string {
              tailf:info "<4096-16777215>;;Vni range, Example: 5001-5008";
            }
          }
        }
        leaf associate-vrf {
          tailf:info "Associate vni with a vrf";
          tailf:cli-hide-in-submode;
          type empty;
        }
        leaf mcast-group {
          tailf:info "NVE Multicast Group";
          tailf:cli-remove-before-change;
          tailf:cli-diff-delete-before "../ingress-replication/protocol";
          type inet:ipv4-address;
        }
        leaf vrf {
          tailf:info "Virtual Router Context";
          tailf:cli-hide-in-submode;
          type leafref {
            path "/nx:vrf/context/id";
          }
        }
        container host-reachability {
          tailf:info "Configure host reachability advertisement";
          leaf protocol {
            tailf:info "Control protocol to use";
            type enumeration {
              enum "bgp" {
                tailf:info "Border Gateway Protocol";
              }
            }
          }
        }
        leaf suppress-arp {
          tailf:info "Enable ARP suppression";
          tailf:cli-diff-delete-before "../../../host-reachability/protocol";
          type empty;
        }
        leaf suppress-unknown-unicast {
          tailf:info "Enable Unknown Unicast flood suppression";
          type empty;
        }
        container ingress-replication {
          tailf:info "Configure ingress replication";
          container protocol {
            tailf:info "Control protocol to use";
            tailf:cli-diff-delete-before "../../mcast-group";
            leaf bgp {
              tailf:info "Border Gateway Protocol";
              tailf:cli-diff-delete-before "../static";
              type empty;
            }
            container static {
              tailf:info "Static End-point Configuration";
              tailf:cli-add-mode;
              tailf:cli-diff-delete-before "../bgp";
              presence "true";
              list peer-ip {
                tailf:cli-suppress-mode;
                key ip;
                leaf ip {
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D  Remote Peer IP Address";
                  }
                }
              }
            }
          }
        }
        container multisite {
          tailf:info "Multisite ingress replication";
          leaf ingress-replication {
            tailf:info "Configure ingress replication";
            type empty;
          }
        }
      }
    }

    // interface nve * / multisite
    container multisite {
      tailf:info "VxLAN Multisite";
      container border-gateway {
        tailf:info "VxLAN Multisite Border-gateway";
        leaf interface {
          tailf:info "NVE Multisite Border-gateway Interface";
          type string;
        }
      }
    }

    // interface nve * / overlay-encapsulation
    leaf overlay-encapsulation {
      tailf:info "NVE Overlay Encapsulation";
      type enumeration {
        enum vxlan {
          tailf:info "Encapsulation type VxLAN";
        }
        enum vxlan-with-tag {
          tailf:info "Encapsulation type vxlan-with-tag";
        }
      }
    }

    // interface * / remap-replication-servers
    leaf remap-replication-servers {
      tailf:info "Remap Replication servers to VNIs";
      tailf:cli-full-command;
      type empty;
    }

    // interface * / replication-server
    leaf replication-server {
      tailf:info "Configure a replication server";
      tailf:cli-full-command;
      type inet:ipv4-address;
    }

    // interface * / shutdown
    leaf shutdown {
      tailf:info "Enable/disable an interface";
      tailf:cli-full-command;
      tailf:cli-show-no;
      cli:context-value-inject "static";
      type empty;
    }

    // interface * / source-interface
    leaf source-interface {
      tailf:info "NVE Source-Interface";
      tailf:cli-diff-dependency "/nx:interface/loopback/name";
      tailf:cli-full-command;
      cli:shutdown-before-edit "../shutdown";
      type string {
        pattern "[Ll]oopback.*";
      }
    }

    container source-interface-cfg {
      tailf:cli-drop-node-name;
      // Triggers bug in default handling
      // when "../source-interface" {
      //   tailf:dependency "../../source-interface";
      // }
      container source-interface {
        tailf:info "NVE Source-Interface";
        leaf hold-down-time {
          tailf:info "Hold source loopback down time";
          tailf:cli-diff-delete-before "../../../source-interface" {
            tailf:cli-when-target-delete;
          }
          default 180;
          type uint16 {
            tailf:info "<1-1500>;;Time in seconds";
          }
        }
      }
    }

    // interface nve * / mcast-routing
    container mcast-routing {
      container override {
        tailf:info "Override source address of routed mcast packets";
        leaf source-interface {
          tailf:info "Source address of routed mcast packets";
          type string {
            pattern "[Ll]oopback.*";
          }
        }
      }
    }

    // interface nve * / advertise
    container advertise {
      tailf:info "Reachability advertisement";
      leaf virtual-rmac {
        tailf:info "Advertise virtual RMAC capability";
        type empty;
      }
    }

  }

  grouping interface-fc-and-san-grouping {

    // interface * / fcdomain
    container fcdomain {
      tailf:info "Configure fcdomain parameters";
      container rcf-reject {
        tailf:info "Configure the rcf-reject flag";
        leaf vsan {
          tailf:info "Specify the vsan range";
          type string {
            pattern "([0-9]+)(\\-[0-9]+)?";
            tailf:info "1-4093;; VSAN id range";
          }
        }
      }
    }

    // interface * / fspf
    container fspf {
      tailf:info "Configure FSPF parameters";
      container cost {
        tailf:info "Configure FSPF link cost";
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        leaf cost {
          tailf:cli-incomplete-command;
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "FSPF link cost";
            range "1..30000";
          }
        }
        leaf vsan {
          tailf:info "Enter VSAN";
          type string {
            pattern "([0-9]+)(\\-[0-9]+)?";
            tailf:info "1-4093;; VSAN id range";
          }
        }
      }
      container dead-interval {
        tailf:info "Configure FSPF dead interval";
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        leaf cost {
          tailf:cli-incomplete-command;
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "Dead interval (in sec)";
            range "2..65535";
          }
        }
        leaf vsan {
          tailf:info "Enter VSAN";
          type string {
            pattern "([0-9]+)(\\-[0-9]+)?";
            tailf:info "1-4093;; VSAN id range";
          }
        }
      }
      container hello-interval {
        tailf:info "Configure FSPF hello-interval";
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        leaf cost {
          tailf:cli-incomplete-command;
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "Hello interval (in sec)";
            range "1..65534";
          }
        }
        leaf vsan {
          tailf:info "Enter VSAN";
          type string {
            pattern "([0-9]+)(\\-[0-9]+)?";
            tailf:info "1-4093;; VSAN id range";
          }
        }
      }
      container passive {
        tailf:info "Enable/disable FSPF on the interface";
        leaf vsan {
          tailf:info "Enter VSAN";
          type string {
            pattern "([0-9]+)(\\-[0-9]+)?";
            tailf:info "1-4093;; VSAN id range";
          }
        }
      }
      container retransmit-interval {
        tailf:info "Configure FSPF retransmit interval";
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        leaf cost {
          tailf:cli-incomplete-command;
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "Retransmit interval (in sec)";
            range "1..65535";
          }
        }
        leaf vsan {
          tailf:info "Enter VSAN";
          type string {
            pattern "([0-9]+)(\\-[0-9]+)?";
            tailf:info "1-4093;; VSAN id range";
          }
        }
      }
    }

    // interface * / shutdown
    leaf shutdown {
      tailf:info "Enable/disable an interface";
      tailf:cli-full-command;
      tailf:cli-show-no;
      type empty;
    }
  }

  // grouping match-grouping
  // this model works well in NCS but may not be what you
  // want in a CLI since you would also want to support
  // typeing "class-map foo" without reqiering the type xx
  // prefix. However, this could easily be supported with
  // a clispec custom command.
  grouping match-grouping {
    container access-group {
      tailf:info "Access group";
      leaf-list name {
        tailf:info "Named Access List";
        tailf:cli-list-syntax;
        type string {
          length "1..64";
          tailf:info "WORD;;Access List name (Max Size 64)";
        }
      }
    }
    leaf-list cos {
      tailf:info "IEEE 802.1Q class of service";
      tailf:cli-range-list-syntax;
      type uint16 {
        tailf:info "<0-7>;;List of class-of-service values";
        range "0..7";
      }
    }
    leaf-list dscp {
      tailf:info "Match DSCP in IP(v4) and IPv6 packets";
      tailf:cli-range-list-syntax;
      type dscp-type;
    }
    container ip {
      tailf:info "IP";
      leaf-list rtp {
        tailf:cli-range-list-syntax;
        tailf:info "Real Time Protocol";
        type uint16 {
          tailf:info "<2000-65535>;;UDP port list that are using RTP";
          range "2000..65535";
        }
      }
    }
    leaf-list precedence {
      tailf:cli-full-command;
      tailf:cli-range-list-syntax;
      tailf:info "Precedence in IP(v4) and IPv6 packets";
      type uint8 {
        tailf:info "<0-7>;;List of precedence values";
        range "0..7";
      }
    }
    container protocol {
      tailf:info "Protocol";
      leaf arp {
        type empty;
        tailf:info "IP ARP";
      }
      leaf clns_es {
        type empty;
        tailf:info "ISO CLNS End System";
      }
      leaf clns_is {
        type empty;
        tailf:info "ISO CLNS Intermediate System";
      }
      leaf dhcp {
        type empty;
        tailf:info "Dynamic Host Configuration";
      }
      leaf ldp {
        type empty;
        tailf:info "Label Distribution Protocol";
      }
      leaf netbios {
        type empty;
        tailf:info "NetBIOS";
      }
    }
    container packet {
      tailf:info "Packet";
      leaf-list length {
        tailf:cli-range-list-syntax;
        tailf:info "Length of IP datagram";
        type uint16 {
          tailf:info "<1-9198>;;List of IP packet length";
          range "1..9198";
        }
      }
    }
  }

  grouping policy-map-police-action-grouping {
    choice conform-action {
      leaf drop {
        tailf:info "Drop the packet";
        type empty;
      }
      leaf transmit {
        tailf:info "Transmit the packet";
        type empty;
      }
    }
  }

  // policy-map type qos * / class *
  // policy-map type control-plane * / class *
  grouping policy-map-class-qos-grouping {
    container set {
      tailf:info "Set attribute";
      leaf cos {
        tailf:info "IEEE 802.1Q class of service";
        type uint8 {
          tailf:info "<0-7>;;802.1Q Class of Service value";
          range "0..7";
        }
      }
      leaf dscp {
        tailf:info "Set DSCP in IP(v4) and IPv6 packets";
        tailf:cli-full-command;
        type dscp-type;
      }
      leaf precedence {
        tailf:info "Precedence in IP(v4) and IPv6 packets";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<0-7>;;List of precedence values";
          range "0..7";
        }
      }
      leaf qos-group {
        tailf:info "QoS-group";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<0-7>;;List of qos-group values";
          range "0..7";
        }
      }
    }
    container police {
      tailf:info "Police";
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-compact-syntax;
      leaf cir {
        tailf:info "Specify committed information rate";
        tailf:cli-incomplete-command;
        type union {
          type uint64 {
            tailf:info "<0-80000000000>  Committed Information Rate in bps/kbps/mbps/gbps/pps";
          }
          type enumeration {
            enum percent {
              tailf:info "Specify rate as percentage of interface data-rate";
            }
          }
        }
      }
      leaf cir-percent {
        tailf:cli-drop-node-name;
        when "../cir = 'percent'" {
          tailf:dependency "../cir";
        }
        type uint8 {
          tailf:info "<1-100>;;Percentage";
        }
      }
      leaf cir-type {
        tailf:cli-drop-node-name;
        when "../cir != 'percent'" {
          tailf:dependency "../cir";
        }
        type xfer-speed-type;
      }
      leaf bc {
        tailf:info "Specify committed burst";
        type uint32 {
          tailf:info "<1-536870912>;;Committed Burst value in bytes/kbytes/mb"
            +"ytes/ms/us/packets";
        }
      }
      leaf bc-type {
        tailf:cli-drop-node-name;
        type burst-type;
      }
      container pir {
        tailf:cli-optional-in-sequence;
        tailf:cli-flatten-container;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        leaf value {
          tailf:cli-drop-node-name;
          type uint64 {
            tailf:info "<1-80000000000>;;Value of peak information rate";
            range "1..80000000000";
          }
        }
        leaf cir-type {
          tailf:cli-drop-node-name;
          type xfer-speed-type;
        }
        leaf be {
          tailf:info "Specify extended burst (for 1R3C meter)";
          type uint32 {
            tailf:info "<1-536870912>;;Value of extended burst in bytes/kbytes/mbytes/ms/us";
          }
        }
        leaf be-type {
          tailf:cli-drop-node-name;
          type burst-type;
        }
      }
      container conform {
        tailf:info "Specify a conform action";
        tailf:cli-flatten-container;
        uses policy-map-police-action-grouping;
      }
      container exceed {
        tailf:info "Specify a exceed action";
        tailf:cli-optional-in-sequence;
        tailf:cli-flatten-container;
        uses policy-map-police-action-grouping;
      }
      container violate {
        tailf:info "Specify a violate action";
        tailf:cli-flatten-container;
        uses policy-map-police-action-grouping;
      }
    }
  }

  grouping policy-map-class-network-qos-grouping {
    container class {
      tailf:info "Policy Criteria";
      container type {
        tailf:info "Specify the type class";
        list network-qos {
          tailf:info "Network Qos policy";
          tailf:cli-mode-name "config-pmap-nq-c";
          tailf:cli-diff-dependency "/nx:class-map/type/network-qos";
          key name;
          leaf name {
            type class-name-type;
            tailf:non-strict-leafref {
              path "/nx:class-map/type/network-qos/name";
            }
          }

          container dpp {
            tailf:info "Dynamic Packet Prioritization";
            leaf set-qos-group {
              tailf:info "QoS group to be mapped";
              type uint8 {
                tailf:info "<0-7>;;QoS Group Value";
              }
            }
          }

          leaf mtu {
            tailf:info "MTU for the CoS";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<1500-9216>;;MTU value";
              range "1500..9216";
            }
          }

          leaf multicast-optimize {
            tailf:info "Optimize multicast traffic distribution";
            tailf:cli-full-command;
            type empty;
          }

          container pause {
            tailf:info "PAUSE charecteristics (CBFC)";
            container no-drop {
              tailf:info "Enable no-drop for the CoS";
              presence "Enable no-drop for the CoS";
              tailf:cli-sequence-commands {
                tailf:cli-reset-all-siblings;
              }
              tailf:cli-compact-syntax;
              leaf buffer-size {
                tailf:info "Ingress buffer size in bytes";
                tailf:cli-optional-in-sequence;
                tailf:cli-incomplete-command;
                type uint32 {
                  tailf:info "<10240-490880>;;Ingress buffer of the "
                    +"no-drop class in bytes";
                  range "10240..490880";
                }
              }
              leaf pause-threshold {
                tailf:info "Buffer limit for pausing in bytes";
                tailf:cli-incomplete-command;
                when "../buffer-size" {
                  tailf:dependency "../buffer-size";
                }
                type uint32 {
                  tailf:info "<0-490880>;;Buffer limit at which"
                    +" the port pauses the peer";
                  range "0..490880";
                }
              }
              leaf resume-threshold {
                tailf:info "Buffer limit at which to resume in "
                  +"bytes";
                when "../buffer-size" {
                  tailf:dependency "../buffer-size";
                }
                type uint32 {
                  tailf:info "<0-490880>;;Buffer limit at which "
                    +"the port resumes the peer";
                  range "0..490880";
                }
              }
              leaf-list pfc-cos {
                tailf:info "Cos values to assert PFC on";
                tailf:cli-range-list-syntax;
                type uint8 {
                  tailf:info "<0-7>;;PFC COS bitmap";
                  range "0..7";
                }
              }
            }
          }

          container queue-limit {
            tailf:info "Configure queue size fo the class";
            tailf:cli-sequence-commands;
            tailf:cli-compact-syntax;
            leaf count {
              tailf:cli-incomplete-command;
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<20480-204800>;;Queue size in bytes";
                range "20480..204800";
              }
              must "../bytes";
            }
            // must be set if the count is set
            leaf bytes {
              tailf:info "Bytes";
              type empty;
            }
          }

          container set {
            tailf:info "Set attribute";
            leaf cos {
              tailf:info "IEEE 802.1Q class of service";
              type uint8 {
                tailf:info "<0-7>;;IEEE 802.1Q Class of Service value";
                range "0..7";
              }
            }
          }
        }
      }
    }
  }

  grouping policy-map-class-queuing-grouping {
    container class {
      tailf:info "Policy Criteria";
      container type {
        tailf:info "Specify the type of class";
        list queuing {
          tailf:info "Match on Queuing class";
          tailf:cli-mode-name "config-pmap-c-que";
          tailf:cli-diff-dependency "/nx:class-map/type/queuing";
          key name;
          leaf name {
            type class-name-type;
            tailf:non-strict-leafref {
              path "/nx:class-map/type/queuing/name";
            }
          }

          container afd {
            tailf:info "Configure AFD parameters";
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            tailf:cli-compact-syntax;
            leaf queue-desired {
              tailf:info "Specify Queue Desired for AFD";
              tailf:cli-incomplete-command;
              type uint32 {
                tailf:info "<1-52428800>;;Queue Desired value";
              }
            }
            leaf unit {
              tailf:cli-drop-node-name;
              type enumeration {
                enum bytes { tailf:info "Bytes"; }
                enum kbytes { tailf:info "Kilo bytes"; }
                enum mbytes { tailf:info "Mega bytes"; }
              }
            }
            leaf ecn {
              tailf:info "ECN";
              type empty;
            }
          }

          container bandwidth {
            tailf:info "Specify bandwidth for the class";
            container remaining {
              tailf:info "remaining  % of remaining bandwidth";
              leaf percent {
                tailf:info "Percentage of available bandwidth";
                type uint8 {
                  tailf:info "<0-100>;;Value in percentage";
                  range "0..100";
                }
              }
            }
            leaf percent {
              tailf:info "Percentage of available bandwidth";
              type uint8 {
                range "0..100";
                tailf:info "<0-100>;;Value in percentage";
              }
            }
          }

          container priority {
            tailf:info "Configure traffic class priority";
            leaf level {
              tailf:info "Specify level of priority";
              tailf:cli-full-command;
              type uint8 {
                tailf:info "<1-2>;;Value of level (1=hi 2=low)";
                range "1..2";
              }
            }
          }

          container queue-limit {
            tailf:info "Configure queue size for the class";
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            tailf:cli-compact-syntax;
            uses queue-limit-grouping;
          }

          container queue-limit-per-cos {
            tailf:cli-drop-node-name;
            list queue-limit {
              tailf:info "Configure queue size for the class";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              tailf:cli-compact-syntax;
              key cos;
              leaf cos {
                tailf:cli-expose-key-name;
                tailf:info "IEEE 802.1Q class of service";
                type uint8 {
                  tailf:info "<0-7>;;802.1Q Class of Service value";
                }
              }
              uses queue-limit-grouping;
            }
          }

          container shape {
            tailf:info "Shape";
            container average {
              tailf:info "Configure average shape rate";
              choice shape-type {
                case bit-rate {
                  leaf rate {
                    tailf:cli-drop-node-name;
                    must "../unit";
                    type uint32 {
                      tailf:info "<1-100000000000>;;Target bit rate";
                      range "1..1000000000";
                    }
                  }
                  leaf unit {
                    type enumeration {
                      enum bps {
                        tailf:info "Bits per second";
                      }
                      enum gbps {
                        tailf:info "Giga bits per second";
                      }
                      enum kbps {
                        tailf:info "Kilo bits per second";
                      }
                      enum mbps {
                        tailf:info "Mega bits per second";
                      }
                    }
                  }
                }
                case percent {
                  leaf percent {
                    tailf:info "Specify rate as percentage of interface data-rate";
                    type uint8 {
                      tailf:info "<1-100>;;Percentage";
                      range "1..100";
                    }
                  }
                }
              }
            }
          }

          container random-detect {
            tailf:info "Configure WRED parameters";
            container cos-based {
              tailf:info "Configure WRED parameters for cos-based mode";
              presence true;
            }
          }

          container random-detect-wred {
            tailf:cli-drop-node-name;
            choice threshold-choice {
              list random-detect {
                tailf:info "Configure WRED parameters";
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                tailf:cli-compact-syntax;
                key cos;
                leaf cos {
                  tailf:info "Parameters for each cos value";
                  tailf:cli-expose-key-name;
                  type uint8 {
                    tailf:info "<0-7>;;List of class-of-service values";
                  }
                }
                uses random-detect-grouping;
              }
              container random-detect-no-cos {
                tailf:cli-drop-node-name;
                container random-detect {
                  tailf:info "Configure WRED parameters";
                  tailf:cli-sequence-commands {
                    tailf:cli-reset-siblings;
                  }
                  tailf:cli-compact-syntax;
                  uses random-detect-grouping;
                  leaf drop-probability {
                    tailf:info "Drop Probability at Maximum Threshold";
                    type uint8 {
                      tailf:info "<0-100>;;Drop Probability Value";
                    }
                  }
                  leaf weight {
                    tailf:info "Queue length weight";
                    type uint8 {
                      tailf:info "<0-15>;;Queue length weight";
                    }
                  }
                }
              }
              container random-detect-threshold {
                tailf:cli-drop-node-name;
                container random-detect {
                  tailf:info "Configure WRED parameters";
                  container threshold {
                    tailf:info "Threshold";
                    tailf:cli-sequence-commands {
                      tailf:cli-reset-siblings;
                    }
                    tailf:cli-compact-syntax;
                    leaf type {
                      tailf:cli-drop-node-name;
                      type enumeration {
                        enum burst-optimized { tailf:info "Threshold optimized for bursty traffic"; }
                        enum mesh-optimized  { tailf:info "Threshold optimized for mesh traffic"; }
                      }
                    }
                    leaf ecn {
                      tailf:info "ECN";
                      type empty;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  grouping common-base-redistribute-grouping {

    container default-information {
      tailf:info "Control distribution of default information";
      container originate {
        tailf:info "Distribute a default route";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        presence true;
        leaf always {
          tailf:info "Always advertise default route";
          tailf:cli-optional-in-sequence;
          type empty;
        }
        leaf route-map {
          tailf:info "Route map reference";
          type string {
            tailf:info "WORD;;Route map name";
          }
        }
      }
    }

    container redistribute {
      tailf:info "Redistribute information from another routing protocol";
      grouping route-map-grouping {
        leaf route-map {
          tailf:info "Route-map applied to redistributed routes";
          type string {
            tailf:info "WORD;;Route-map name (Max Size 63)";
            length "1..63";
          }
        }
      }
      list bgp {
        tailf:info "Border Gateway Protocol (BGP)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key as-number;
        leaf as-number {
          type asn-type;
        }
        uses route-map-grouping;
      }
      container direct {
        tailf:info "Directly connected";
        uses route-map-grouping;
      }
      list eigrp {
        tailf:info "Enhanced Interior Gateway Protocol (EIGRP)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key tag;
        leaf tag {
          tailf:info "WORD;;Protocol Tag";
          type string;
        }
        uses route-map-grouping;
      }
      list isis {
        tailf:info "ISO Intermediate-to-Intermediate (IS-IS) ";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key tag;
        leaf tag {
          type string {
            tailf:info "WORD;;Protocol Tag";
          }
        }
        uses route-map-grouping;
      }
      container lisp {
        tailf:info "LISP EID-prefixes";
        uses route-map-grouping;
      }
      container maximum-prefix {
        tailf:info "Maximum number of prefixes redistributed to protocol";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        leaf max-number {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-65535>;;Maximum number of IP prefixes redistributed";
            range "1..65535";
          }
        }
        leaf threshold {
          tailf:cli-drop-node-name;
          tailf:cli-optional-in-sequence;
          type uint8 {
            tailf:info "<1-100>;;Threshold value (%) at which to generate a warning message *Default value is 75";
            range "1..100";
          }
        }
        choice warning-or-withdraw {
          case warning-only {
            leaf warning-only {
              tailf:info "Log a warning message when limit is exceeded";
              type empty;
            }
          }
          case withdraw {
            leaf withdraw {
              tailf:info "Withdraw all redistributed routes";
              type empty;
            }
            leaf retry {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint8 {
                tailf:info "<1-12>;;Number of times to retry to get the redistributed routes again";
                range "1..12";
              }
            }
          }
        }
        leaf timeout {
          tailf:cli-drop-node-name;
          when "../withdraw";
          type uint16 {
            tailf:info "<60-600>;;Timeout between each retries *Default value is 300";
          }
        }
      }
      list ospf {
        tailf:info "Open Shortest Path First (OSPFv2)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key tag;
        leaf tag {
          type string {
            tailf:info "WORD;;Protocol Tag";
          }
        }
        uses route-map-grouping;
      }
      list ospfv3 {
        tailf:info "Open Shortest Path First, version 3 (OSPFv3)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key tag;
        leaf tag {
          type string {
            tailf:info "WORD;;Source protocol Tag";
          }
        }
        uses route-map-grouping;
      }
      list rip {
        tailf:info "Routing Information Protocol (RIP)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key tag;
        leaf tag {
          type string {
            tailf:info "WORD;;Protocol Tag";
          }
        }
        uses route-map-grouping;
      }
      container static {
        tailf:info "Static";
        uses route-map-grouping;
      }
    }

    container table-map {
      tailf:info "Policy for filtering/modifying routes";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf name {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "WORD;;Route-map name (Max Size 63)";
          length "1..63";
        }
      }
      leaf filter {
        tailf:info "Selective route download";
        type empty;
      }
    }

  }

  grouping common-router-redistribute-grouping {

    uses common-base-redistribute-grouping {
      refine default-information/originate/always {
        tailf:cli-no-name-on-delete;
      }
      refine default-information/originate/route-map {
        tailf:cli-no-name-on-delete;
        tailf:cli-no-value-on-delete;
      }
    }

    leaf distance {
      tailf:info "Configure administrative distance";
      default 110;
      type uint32 {
        tailf:info "<1-255>;;Adminitrative distance value";
        range "1..255";
      }
    }

    leaf maximum-paths {
      tailf:info "Maximum paths per destination";
      default 8;
      type uint32 {
        tailf:info "<1-64>;;Number of paths";
      }
    }

  }

  grouping common-router-redistribute-grouping-rip {

    container redistribute {
      tailf:info "Redistribute information from another routing protocol";
      grouping route-map-grouping {
        leaf route-map {
          tailf:info "Route-map applied to redistributed routes";
          type string {
            tailf:info "WORD;;Route-map name (Max Size 63)";
            length "1..63";
          }
        }
      }
      list bgp {
        tailf:info "Border Gateway Protocol (BGP)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key as-number;
        leaf as-number {
          type asn-type;
        }
        uses route-map-grouping;
      }
      container direct {
        tailf:info "Directly connected";
        uses route-map-grouping;
      }
      list eigrp {
        tailf:info "Enhanced Interior Gateway Protocol (EIGRP)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key tag;
        leaf tag {
          type string {
            tailf:info "WORD;;Protocol Tag";
          }
        }
        uses route-map-grouping;
      }
      list isis {
        tailf:info "ISO Intermediate-to-Intermediate (IS-IS) ";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key tag;
        leaf tag {
          type string {
            tailf:info "WORD;;Protocol Tag";
          }
        }
        uses route-map-grouping;
      }
      container lisp {
        tailf:info "LISP EID-prefixes";
        uses route-map-grouping;
      }
      container maximum-prefix {
        tailf:info "Maximum number of prefixes redistributed to protocol";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        leaf max-number {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-65535>;;Maximum number of IP prefixes redistributed";
            range "1..65535";
          }
        }
        leaf threshold {
          tailf:cli-drop-node-name;
          tailf:cli-optional-in-sequence;
          type uint8 {
            tailf:info "<1-100>;;Threshold value (%) at which to generate a warning message *Default value is 75";
            range "1..100";
          }
        }
        choice warning-or-withdraw {
          case warning-only {
            leaf warning-only {
              tailf:info "Log a warning message when limit is exceeded";
              type empty;
            }
          }
          case withdraw {
            leaf withdraw {
              tailf:info "Withdraw all redistributed routes";
              type empty;
            }
            leaf retry {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint8 {
                tailf:info "<1-12>;;Number of times to retry to get the redistributed routes again";
                range "1..12";
              }
            }
          }
        }
        leaf timeout {
          tailf:cli-drop-node-name;
          when "../withdraw";
          type uint16 {
            tailf:info "<60-600>;;Timeout between each retries *Default value is 300";
          }
        }
      }
      list ospf {
        tailf:info "Open Shortest Path First (OSPFv2)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key tag;
        leaf tag {
          type string {
            tailf:info "WORD;;Protocol Tag";
          }
        }
        uses route-map-grouping;
      }
      list ospfv3 {
        tailf:info "Open Shortest Path First, version 3 (OSPFv3)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key tag;
        leaf tag {
          type string {
            tailf:info "WORD;;Source protocol Tag";
          }
        }
        uses route-map-grouping;
      }
      list rip {
        tailf:info "Routing Information Protocol (RIP)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key tag;
        leaf tag {
          type string {
            tailf:info "WORD;;Protocol Tag";
          }
        }
        uses route-map-grouping;
      }
      container static {
        tailf:info "Static";
        uses route-map-grouping;
      }
    }

    container default-information {
      tailf:info "RIP control distribution of default route";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf originate {
        tailf:info "RIP distribute a default route";
        type empty;
      }
      leaf always {
        tailf:info "Always advertise default route";
        tailf:cli-optional-in-sequence;
        type empty;
      }
      leaf route-map {
        tailf:info "Route map reference";
        type string {
          tailf:info "WORD;;Route map name";
        }
      }
    }

    leaf distance {
      tailf:info "Configure administrative distance";
      default 120;
      type uint32 {
        tailf:info "<1-255>;;Adminitrative distance value";
        range "1..255";
      }
    }

    leaf maximum-paths {
      tailf:info "Maximum paths per destination";
      default 16;
      type uint32 {
        tailf:info "<1-64>;;Number of paths";
      }
    }

    leaf default-metric {
      tailf:info "RIP default metric";
      default 1;
      type uint8 {
        tailf:info "<1-15>;;RIP metric value";
      }
    }

  }

  grouping ospfv3-address-family-grouping {
    container address-family {
      tailf:info "Configure an address-family";
      container ipv6 {
        tailf:info "Configure IPv6 address-family";
        container unicast {
          tailf:info "Configure IPv6 unicast address-family";
          tailf:cli-add-mode;

          uses common-router-redistribute-grouping;
          uses ospf-area-grouping;

          leaf default-metric {
            tailf:info "Set metric of redistributed routes";
            tailf:cli-full-command;
            type uint32 {
              range "0..4294967295";
              tailf:info "<0-4294967295>;;Default metric";
            }
          }

          list summary-address {
            tailf:info "Configure route summarization for redistribution";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key address;
            leaf address {
              type tailf:ipv6-address-and-prefix-length {
                tailf:info "A:B::C:D/LEN;;IPv6 prefix format: xxxx:xxxx/ml, xxxx:"
                  +"xxxx::/ml, xxxx::xx/128";
              }
            }
          }
        }
      }
    }
  }

  grouping ospf-area-grouping {
    list area {
      tailf:info "OSPF area parameters";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      nx:trim-empty-create;

      key id;
      leaf id {
        tailf:cli-suppress-range;
        type ospf-area-type;
      }

      container authentication {
        tailf:info "Enable authentication";
        presence "Enable authentication";
        leaf message-digest {
          tailf:info "Use message-digest authentication";
          type empty;
        }
      }
      leaf default-cost {
        tailf:info "Set the summary default-cost of a NSSA/stub area";
        tailf:cli-full-command;
        tailf:cli-no-value-on-delete;
        type uint32 {
          range "0..16777215";
          tailf:info "<0-16777215;;Stub's advertised external route metric";
        }
      }
      choice nssa-or-stub {
        container nssa {
          tailf:info "Specify a NSSA area";
          tailf:cli-compact-syntax;
          presence "Specify a NSSA area";
          nx:explicit-delete-when-empty;
          container default-information-originate {
            tailf:cli-flatten-container;
            tailf:info "Originate Type-7 default LSA into NSSA area";
            presence true;
            leaf route-map {
              tailf:info "Policy to control distribution of default route";
              type string {
                tailf:info "WORD;;A 'route-map' name (Max Size 63)";
                length "1..63";
              }
            }
          }
          leaf no-redistribution {
            tailf:info "Do not send redistributed LSAs into NSSA area";
            type empty;
          }
          leaf no-summary {
            tailf:info "Do not send summary LSAs into NSSA area";
            type empty;
          }
        }
        container stub {
          tailf:info "Specify a stub area";
          presence "Specify a stub area";
          nx:explicit-delete-when-empty;
          leaf no-summary {
            tailf:info "Prevent ABR from sending summary LSAs into stub area";
            tailf:cli-full-command;
            type empty;
          }
        }
      }
      container nssa-translate {
        tailf:cli-drop-node-name;
        container nssa {
          tailf:info "Specify a NSSA area";
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          container translate {
            tailf:info "Translate LSA";
            leaf type7 {
              tailf:info "From Type 7 to Type 5";
              type enumeration {
                enum suppress-fa {
                  tailf:info "Suppress forwarding address in translated LSAs";
                }
                enum supress-fa {
                  tailf:info "Suppress forwarding address in translated LSAs";
                }
                enum always {
                  tailf:info "Always translate LSAs";
                }
                enum never {
                  tailf:info "Never translate LSAs";
                }
              }
            }
          }
        }
      }
      container filter-list {
        tailf:info "Filter prefixes between OSPF areas";
        list route-map {
          tailf:info "Name of filter policy";
          tailf:cli-suppress-mode;
          key direction;
          leaf name {
            tailf:cli-prefix-key;
            tailf:cli-drop-node-name;
            type string {
              tailf:info "<string>;;Route-map name (Max Size 63)";
              length "1..63";
            }
          }
          leaf direction {
            type enumeration {
              enum in {
                tailf:info "Filter networks sent to this area";
              }
              enum out {
                tailf:info "Filter networks sent from this area";
              }
            }
          }
        }
      }
      list range {
        tailf:info "Summarize routes matching address/mask "
          +"(border routers only)";
        tailf:cli-suppress-mode;
        tailf:cli-compact-syntax;
        key ip;
        leaf ip {
          type tailf:ipv4-address-and-prefix-length {
            tailf:info "A.B.C.D/LEN;;IP prefix format: x.x.x.x/ml";
          }
        }
        leaf not-advertise {
          tailf:info "Suppress advertising the specified range";
          tailf:cli-no-name-on-delete;
          type empty;
        }
        leaf cost {
          tailf:info "User specified metric for this range";
          tailf:cli-no-name-on-delete;
          tailf:cli-no-value-on-delete;
          type uint32 {
            range "0..16777215";
            tailf:info "<0-16777215>;;Advertised metric for this range";
          }
        }
      }
      list sham-link {
        tailf:info "Define a sham link and its parameters";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "source dest";
        leaf source {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP addr associated with sham-link source";
          }
        }
        leaf dest {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP addr associated with "
              +"sham-link destination";
          }
        }
        leaf cost {
          tailf:info "Associate a cost with the sham-link";
          type uint16 {
            range "0..65535";
            tailf:info "<1-65535>;;Cost of the sham-link";
          }
        }
      }
      list virtual-link {
        tailf:info "Define a virtual link and its parameters";
        must "not(../nssa)" {
          error-message "The area is configured as NSSA area already";
          tailf:dependency "../nssa";
        }
        must "not(../stub)" {
          error-message "The area is configured as stub area already";
          tailf:dependency "../stub";
        }
        key id;
        leaf id {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;ID (IP addr) associated with "
              +"virtual link neighbor";
          }
        }
        leaf authentication {
          tailf:info "Set authentication type";
          type empty;
        }
        container authentication-key {
          tailf:info "Set authentication key";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf auth-type {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              range "0..7";
              tailf:info "<0-7>;;Encryption type (0 for not yet encrypted, "
                +"7 for proprietary)";
            }
          }
          leaf auth-key {
            tailf:cli-drop-node-name;
            tailf:cli-full-command;
            type string {
              tailf:info "WORD;;Authentication key";
            }
          }
        }
        leaf dead-interval {
          tailf:info "Dead router detection time";
          type uint32 {
            range "1..262140";
            tailf:info "<1-262140;;Seconds>";
          }
          default 40;
        }
        leaf hello-interval {
          tailf:info "Hello packet interval";
          default 10;
          type int32 {
            range "1..65535";
            tailf:info "<1-63535;;Seconds>";
          }
        }
        list message-digest-key {
          tailf:info "Set message digest key";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          key id;
          leaf id {
            tailf:cli-suppress-range;
            type uint8 {
              tailf:info "<1-255>;;Key ID";
              range "1..255";
            }
          }
          container md5 {
            tailf:info "Use MD5 algorithm";
            tailf:cli-sequence-commands;
            tailf:cli-compact-syntax;
            leaf auth-type {
              tailf:cli-drop-node-name;
              tailf:cli-optional-in-sequence;
              type uint8 {
                range "0..7";
                tailf:info "<0-7>;;Encryption type (0 for not "
                  +"yet encrypted, 7 for proprietary)";
              }
            }
            leaf auth-key {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "WORD;;Authentication key (16 chars)";
                length "1..16";
              }
            }
          }
        }
        leaf retransmit-interval {
          tailf:info "LSA retransmit interval";
          default 5;
          type uint16 {
            range "1..65535";
            tailf:info "<1-65535>;;Seconds";
          }
        }
        leaf transmit-delay {
          tailf:info "LSA transmission delay";
          default 1;
          type uint16 {
            range "1..8192";
            tailf:info "<1-8192>;;Seconds";
          }
        }
      }
    }
  }

  grouping ospf-ospfv3-common-grouping {

    uses ospf-area-grouping;

    container auto-cost {
      tailf:info "Calculate OSPF interface cost according to bandwidth";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf reference-bandwidth {
        tailf:info "Reference bandwidth used to assign OSPF cost";
        type uint32 {
          tailf:info "<1-4000000>;;Rate in Mbps (bandwidth) or Gbps (max 4000), default 40000 Mbps";
        }
      }
      leaf rate-unit {
        tailf:cli-drop-node-name;
        type enumeration {
          enum Gbps {
            tailf:info "Specify rate in Gbps";
          }
          enum Mbps {
            tailf:info "Specify rate in Mbps";
          }
        }
      }
    }

    leaf bfd {
      tailf:info "Enable BFD on all OSPF interfaces";
      tailf:cli-diff-dependency "/nx:feature/bfd";
      when "/nx:feature/bfd" {
        tailf:dependency "/nx:feature/bfd";
      }
      type empty;
    }

    container log-adjacency-changes {
      tailf:info "Log changes in adjacency state";
      presence "Log changes in adjacency state";
      leaf detail {
        tailf:info "Log all state changes";
        type empty;
      }
    }

    container max-lsa {
      tailf:info "maximum number of LSAs OSPF process will receive";
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      tailf:cli-compact-syntax;
      leaf number {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<1-4294967295>;;Set maximum number of non self-generated LSAs";
          range "1..4294967295";
        }
      }
      leaf threshold-value {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        type uint32 {
          range "1..100";
          tailf:info "<1-100>;;Threshold value (%) at which "
            +"to generate a warning msg";
        }
      }
      choice ignore-or-warning {
        case ignore {
          leaf ignore-time {
            tailf:info "Set time during which all adjacencies are suppressed";
            tailf:cli-optional-in-sequence;
            type uint32 {
              range "1..17895";
              tailf:info "<1-17895>;;Ignore-time in minutes";
            }
          }
          leaf ignore-count {
            tailf:info "Set count on how many times adjacencies can be suppressed";
            tailf:cli-optional-in-sequence;
            type uint32 {
              tailf:info "<1-4294967295>;;Ignore-count";
              range "1..4294967295";
            }
          }
          leaf reset-time {
            tailf:info "Set number of minutes after which ignore-count is reset to zero";
            type uint32 {
              range "2..35791";
              tailf:info "<2-35791>;;Reset-time in minutes";
            }
          }
        }
        case warning {
          leaf warning-only {
            tailf:info "Only give warning message when limit is exceeded";
            type empty;
          }
        }
      }
    }

    container max-metric {
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf router-lsa {
        tailf:info "Router LSA";
        type empty;
      }
      leaf external-lsa {
        tailf:info "External LSAs";
        tailf:cli-optional-in-sequence;
        type empty;
      }
      leaf external-lsa-value {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        when "../external-lsa" {
          tailf:dependency "../external-lsa";
        }
        type uint32 {
          tailf:info "<1-16777215>;;Max metric value for external LSAs";
        }
      }
      leaf include-stub {
        tailf:info "Advertise Max metric for Stub links as well";
        tailf:cli-optional-in-sequence;
        type empty;
      }
      leaf on-startup {
        tailf:info "Effective only at startup";
        tailf:cli-optional-in-sequence;
        type empty;
      }
      leaf on-startup-value {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        when "../on-startup" {
          tailf:dependency "../on-startup";
        }
        type uint32 {
          tailf:info "<5-86400>;;Wait period in seconds after startup";
        }
      }
      container wait-for {
        tailf:cli-optional-in-sequence;
        tailf:cli-flatten-container;
        // Bug in NCS (relates to https://wiki.tail-f.com/trac/ticket/14696)
        //        when "../on-startup" {
        //          tailf:dependency "../on-startup";
        //        }
        leaf bgp {
          tailf:non-strict-leafref {
            path "/nx:router/bgp/id";
          }
          type string {
            tailf:info "WORD;;Tag of BGP to wait for (Max Size 20)";
          }
        }
      }
      leaf summary-lsa {
        tailf:info "Summary LSAs";
        type empty;
      }
      leaf summary-lsa-value {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<1-16777215>;;Max metric value for summary LSAs";
        }
      }
    }

    container passive-interface {
      tailf:info "Suppress routing updates on the interface";
      leaf default {
        tailf:info "Interfaces passive by default";
        type empty;
      }
    }

    container timers {
      tailf:info "Configure timer related constants";
      leaf lsa-arrival {
        tailf:info "Mimimum interval between arrival of a LSA";
        default 1000;
        type uint32 {
          tailf:info "<10-600000>;;Interval value (milliseconds)";
          range "10..600000";
        }
      }
      leaf lsa-group-pacing {
        tailf:info "LSA group refresh/maxage interval";
        type uint16 {
          tailf:info "<1-1800>;;Interval value (seconds)";
          range "1..1800";
        }
      }
      container throttle {
        tailf:info "Configure timer related constants";
        container lsa {
          tailf:info "Set rate-limiting for LSA generation";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf start {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<0-5000>;;Start interval (milliseconds)";
              range "0..5000";
            }
          }
          leaf hold {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<50-30000>;;Hold interval (milliseconds)";
              range "50..30000";
            }
          }
          leaf max {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<50-30000>;;Max interval (milliseconds)";
              range "50..30000";
            }
          }
        }
        container spf {
          tailf:info "OSPF SPF timers";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf initial {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<1-600000>;;Initial SPF schedule delay in milliseconds";
              range "1..600000";
            }
          }
          leaf minimum {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<1-600000>;;Minimum SPF schedule delay in milliseconds";
              range "1..600000";
            }
          }
          leaf maximum {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-600000>;;Maximum SPF schedule delay in milliseconds";
              range "1..600000";
            }
          }
        }
      }
    }

    leaf router-id {
      tailf:cli-full-command;
      tailf:info "Override configured router identifier (peers will "
        +"reset)";
      type inet:ipv4-address {
        tailf:info "A.B.C.D;;Manually configured router identifier";
      }
    }

    container discard-route {
      tailf:info "Enable or disable discard-route installation";
      leaf external {
        tailf:info "External route";
        default true;
        type boolean;
        tailf:cli-boolean-no;
      }
      leaf internal {
        tailf:info "Internal route";
        default true;
        type boolean;
        tailf:cli-boolean-no;
      }
    }

    leaf name-lookup {
      tailf:info "Enable Name Lookup for OSPF Neighbors";
      type empty;
    }
  }

  grouping ospf-grouping {

    list summary-address {
      tailf:info "Configure route summarization for redistribution";
      tailf:cli-suppress-mode;
      key address;
      leaf address {
        type tailf:ipv4-address-and-prefix-length {
          tailf:info "A.B.C.D/LEN;;IP prefix format: x.x.x.x/ml";
        }
      }
      // TODO: choice:
      // not-advertise  Supress advertising the specified summary
      // tag            32-bit tag value
    }

    uses ospf-ospfv3-common-grouping;
    uses common-router-redistribute-grouping;

    leaf default-metric {
      tailf:info "Set metric of redistributed routes";
      tailf:cli-full-command;
      type uint32 {
        range "0..4294967295";
        tailf:info "<0-4294967295>;;Default metric";
      }
    }

    leaf rfc1583compatibility {
      tailf:info "Configure 1583 compatibility for external path preferences";
      type empty;
    }
  }

  grouping isis-common-grouping {
    container authentication {
      tailf:info "Set authentication keychain string";
      list key-chain {
        tailf:info "Set authentication keychain string";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key type;
        leaf name {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type string {
            tailf:info "WORD;;Authentication keychain (Max Size 63)";
            length "1..63";
          }
        }
        leaf type {
          type enumeration {
            enum level-1 {
              tailf:info "Specify authentication key for level-1 LSP, CSNP and PSNP";
            }
            enum level-2 {
              tailf:info "Specify authentication key for level-2 LSP, CSNP and PSNP";
            }
          }
        }
      }
    }

    container authentication-check {
      tailf:info "Check authentication on received LSP/CSNP/PSNP's";
      leaf level-1 {
        tailf:info "Specify authentication check for level-1 LSP, CSNP and PSNP";
        tailf:cli-boolean-no;
        default true;
        type boolean;
      }
      leaf level-2 {
        tailf:info "Specify authentication check for level-2 LSP, CSNP and PSNP";
        tailf:cli-boolean-no;
        default true;
        type boolean;
      }
    }

    list authentication-type {
      tailf:info "Set authentication type";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key type;
      leaf auth-format {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        type enumeration {
          enum cleartext {
            tailf:info "Cleartext";
          }
          enum md5 {
            tailf:info "HMAC-MD5";
          }
        }
      }
      leaf type {
        type enumeration {
          enum level-1 {
            tailf:info "Specify authentication type for level-1 LSP, CSNP and PSNP";
          }
          enum level-2 {
            tailf:info "Specify authentication type for level-2 LSP, CSNP and PSNP";
          }
        }
      }
    }

    leaf is-type {
      tailf:info "IS type for this IS-IS process";
      type enumeration {
        enum level-1 {
          tailf:info "Act as L1 router only";
        }
        enum level-1-2 {
          tailf:info "Act as both L1 and L2 router";
        }
        enum level-2 {
          tailf:info "Act as L2 router only";
        }
      }
    }

    leaf log-adjacency-changes {
      tailf:info "Log changes in adjacency state";
      type empty;
    }

    leaf lsp-mtu {
      tailf:info "Set LSP MTU";
      default 1492;
      type uint16 {
        tailf:info "<256-4352>;;Maximum LSP size in bytes";
      }
    }

    container lsp-gen-interval {
      tailf:info "Configure LSP generation interval";
      container level-1 {
        tailf:info "Configure LSP generation level-1 interval";
        tailf:cli-sequence-commands;
        tailf:cli-compact-syntax;
        uses isis-lsp-gen-interval-grouping;
      }
      container level-2 {
        tailf:info "Configure LSP generation level-2 interval";
        tailf:cli-sequence-commands;
        tailf:cli-compact-syntax;
        uses isis-lsp-gen-interval-grouping;
      }
    }

    leaf max-lsp-lifetime {
      tailf:info "Set maximum LSP lifetime";
      default 1200;
      type uint16 {
        tailf:info "<1-65535>;;Maximum LSP lifetime in seconds *Default value is 1200";
      }
    }

    leaf net {
      tailf:info "Configure Network Entity Title for IS-IS";
      type string {
        tailf:info "XX.AAAA.AAAA.AAAA[.AAAA].XX;;NET in form of XX.XXXX. ... .XXXX.XX";
      }
    }

    uses common-router-redistribute-grouping {
      refine distance {
        default 115;
      }
    }

    leaf set-attached-bit {
      tailf:info "Configure L1|L2 router to set/unset attached bit in its L1 LSP";
      tailf:cli-boolean-no;
      default true;
      type boolean;
    }

    container set-overload-bit {
      tailf:info "Signal other routers not to use us for transit";
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-compact-syntax;
      choice always-or-startup-choice {
        case always-case {
          leaf always {
            tailf:info "Set the overload bit unconditionally";
            type empty;
          }
        }
        case startup-case {
          leaf on-startup {
            tailf:info "Set the overload bit on IS-IS startup";
            type empty;
          }
          leaf elapsed {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            type uint32 {
              tailf:info "<5-86400>;;Clear the overload bit after an elapsed time in seconds";
            }
          }
          container wait-for {
            tailf:info "Clear the overload bit when notified by a specific protocol";
            tailf:cli-flatten-container;
            leaf bgp {
              tailf:info "Border Gateway Protocol (BGP)";
              type asn-type;
            }
          }
        }
      }
      leaf suppress {
        tailf:info "Suppress route redistribution if overload bit set";
        type empty;
      }
      leaf ext-or-int {
        tailf:cli-drop-node-name;
        when "../suppress";
        type enumeration {
          enum external {
            tailf:info "Suppress external route redistribution";
          }
          enum interlevel {
            tailf:info "Suppress interlevel route redistribution";
          }
        }
      }
    }

    container spf-interval {
      tailf:info "Configure SPF interval";
      container level-1 {
        tailf:info "Configure SPF level-1 interval";
        tailf:cli-sequence-commands;
        tailf:cli-compact-syntax;
        uses isis-spf-interval-grouping;
      }
      container level-2 {
        tailf:info "Configure SPF level-2 interval";
        tailf:cli-sequence-commands;
        tailf:cli-compact-syntax;
        uses isis-spf-interval-grouping;
      }
    }

    container address-family {
      container ipv4 {
        container unicast {
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-router-af";
          presence true;
          leaf adjacency-check {
            tailf:info "Adjacency's protocol support consistency check";
            tailf:cli-boolean-no;
            type boolean;
            default true;
          }
          uses common-base-redistribute-grouping;
        }
      }
      container ipv6 {
        container unicast {
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-router-af";
          presence true;
          leaf adjacency-check {
            tailf:info "Adjacency's protocol support consistency check";
            tailf:cli-boolean-no;
            type boolean;
            default true;
          }
          leaf multi-topology {
            tailf:info "Enable multitopology for IPV6";
            type empty;
          }
          uses common-base-redistribute-grouping;
        }
      }
    }

    leaf bfd {
      tailf:info "Enable IPv4 BFD on all ISIS interfaces";
      tailf:cli-diff-dependency "/nx:feature/bfd";
      when "/nx:feature/bfd" {
        tailf:dependency "/nx:feature/bfd";
      }
      type empty;
    }

    container metric-style {
      tailf:info "Configure metric style used in advertised LSPs";
      leaf transition {
        tailf:info "Use both narrow and wide metric style";
        type empty;
      }
    }

  }

  grouping eigrp-common-grouping {

    leaf router-id {
      tailf:info "Router-id for this EIGRP process";
      type inet:ipv4-address {
        tailf:info "A.B.C.D;;EIGRP Router-ID in IP address format";
      }
    }

    leaf autonomous-system {
      tailf:info "Specify AS number for Address Family";
      type uint16 {
        tailf:info "<1-65535>  Local AS number";
      }
    }

    leaf log-neighbor-warnings {
      tailf:info "Enable/Disable IP-EIGRP neighbor warnings";
      tailf:cli-boolean-no;
      default true;
      type boolean;
    }

    leaf log-adjacency-changes {
      tailf:info "Log changes in adjacency state";
      tailf:cli-boolean-no;
      default true;
      type boolean;
    }

    container passive-interface {
      tailf:info "Suppress routing updates on the interface";
      leaf default {
        tailf:info "Interfaces passive by default";
        type empty;
      }
    }

    uses common-base-redistribute-grouping;

    container distance {
      tailf:info "Configure administrative distance";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf internal {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-255>;;Distance for internal routes";
        }
      }
      leaf external {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-255>;;Distance for external routes";
        }
      }
    }

    leaf maximum-paths {
      tailf:info "Forward packets over multiple paths";
      default 8;
      type uint32 {
        tailf:info "<1-32>;;Number of paths";
        range "1..32";
      }
    }

    container default-metric {
      tailf:info "Set metric of redistributed routes";
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-compact-syntax;
      leaf bandwidth {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint32 {
          tailf:info "<1-16777215>;;Bandwidth in Kbits per second";
          range "1..16777215";
        }
      }
      leaf delay {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint32 {
          tailf:info "<1-16777215>;;Delay metric";
          range "1..16777215";
        }
      }
      leaf reliability {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint8 {
          tailf:info "<0-255>;;Reliability metric where 255 is 100% reliable";
        }
      }
      leaf effective {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint8 {
          tailf:info "<0-255>;;Effective bandwidth metric (Loading) where 255 is 100% loaded";
        }
      }
      leaf max-transmission {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<128-9216>;;Maximum Transmission Unit metric of the path";
          range "128..9216";
        }
      }
    }

    leaf bfd {
      tailf:info "Enable BFD on all EIGRP interfaces";
      tailf:cli-diff-dependency "/nx:feature/bfd";
      type empty;
    }

    list network {
      tailf:info "Network address";
      tailf:cli-suppress-mode;
      key address;
      leaf address {
        nx:verify-network-address {
          when "/tailfned/network-address-validation";
        }
        type tailf:ipv4-address-and-prefix-length;
      }
    }

  }

  grouping eigrp-common-af-grouping {
    container address-family {
      container ipv4 {
        container unicast {
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-router-af";
          tailf:cli-explicit-exit;
          uses eigrp-common-grouping {
            refine network {
              tailf:cli-diff-delete-before "../../../../network";
            }
          }
        }
      }
      container ipv6 {
        container unicast {
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-router-af";
          tailf:cli-explicit-exit;
          uses eigrp-common-grouping;
        }
      }
    }
  }

  grouping rip-common-af-grouping {
    container address-family {
      container ipv4 {
        container unicast {
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-router-af";
          uses common-router-redistribute-grouping-rip;
        }
      }
      container ipv6 {
        container unicast {
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-router-af";
          uses common-router-redistribute-grouping-rip;
        }
      }
    }
  }

  grouping router-bgp-address-family-base-grouping {
    list address-family {
      tailf:info "Configure an address-family";
      tailf:cli-explicit-exit;
      key "proto type";
      leaf proto {
        type enumeration {
          enum "ipv4";
          enum "ipv6";
          enum "l2vpn";
          enum "vpnv4";
          enum "vpnv6";
          enum "nsap";
          enum "rtfilter";
        }
      }
      leaf type {
        type enumeration {
          enum "unicast";
          enum "multicast";
          enum "mvpn";
          enum "evpn";
          enum "labeled-unicast";
        }
      }
    }
  }

  // router bgp * / address-family * /
  grouping router-bgp-address-family-grouping {
    uses router-bgp-address-family-base-grouping {
      augment "address-family" {

        // router bgp * / address-family * * / dampening
        uses router-bgp-af-dampening-grouping;

        // router bgp * / address-family * * / nexthop
        container nexthop {
          tailf:info "Nexthop tracking";

          // router bgp * / address-family * * / nexthop trigger-delay critical
          container trigger-delay {
            tailf:info "Set the delay to trigger nexthop tracking";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf critical {
              tailf:info "Nexthop changes affecting reachability";
              tailf:cli-incomplete-command;
              type uint32 {
                tailf:info "<1-4294967295>;;Delay value (miliseconds) *Default value is 3000";
                range "1..4294967295";
              }
              default 3000;
            }
            leaf non-critical {
              tailf:info "Other nexthop changes";
              type uint32 {
                tailf:info "<1-4294967295>;;Delay value (miliseconds) *Default value is 10000";
                range "1..4294967295";
              }
              default 10000;
            }
          }
          leaf route-map {
            tailf:info "Route map for valid nexthops";
            type string {
              tailf:info "WORD;;Route-map name (Max Size 63)";
            }
          }
        }

        // router bgp * / address-family * * / additional-paths
        container additional-paths {
          tailf:info "Additional paths configuration";
          leaf receive {
            tailf:info "Additional paths Receive capability";
            type empty;
          }
          leaf send {
            tailf:info "Additional paths Send capability";
            type empty;
          }
          container selection {
            tailf:info "Additional paths selection";
            leaf route-map {
              tailf:info "Route-map for additional paths selection";
              type string {
                tailf:info "WORD;;Route-map name (Max Size 63)";
              }
            }
          }
          container install {
            tailf:info "Install backup path";
            leaf backup {
              tailf:info "Install backup path";
              type empty;
            }
          }
        }

        // router bgp * / address-family * * / aggregate-address *
        list aggregate-address {
          tailf:info "Configure BGP aggregate prefixes";
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-compact-syntax;
          tailf:cli-delete-when-empty;
          tailf:cli-suppress-mode;
          key ip;
          // ... aggregate-address A.B.C.D/LEN <CR>
          leaf ip {
            type union {
              type tailf:ipv4-address-and-prefix-length {
                tailf:info "A.B.C.D/LEN;;Aggregate prefix";
              }
              type tailf:ipv6-address-and-prefix-length {
                tailf:info "A:B::C:D/LEN;;IPv6 prefix format: xxxx:xxxx/ml, xxxx:"
                  +"xxxx::/ml, xxxx::xx/128";
              }
            }
          }
          leaf as-set {
            tailf:info "Generate AS-SET information";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          leaf summary-only {
            tailf:info "Don't advertise more specifics";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          leaf advertise-map {
            tailf:info "Select attribute information from specific routes";
            tailf:cli-optional-in-sequence;
            type string {
              tailf:info "WORD;;Route-map name (Max Size 63)";
              length "1..63";
            }
          }
          leaf suppress-map {
            tailf:info "Conditionally filter more specific routes";
            tailf:cli-optional-in-sequence;
            type string {
              tailf:info "WORD;;Route-map name (Max Size 63)";
              length "1..63";
            }
          }
          leaf attribute-map {
            tailf:info "Set attribute information of aggregate";
            type string {
              tailf:info "WORD;;Route-map name (Max Size 63)";
              length "1..63";
            }
          }
        }

        // router bgp * / address-family * * / advertise l2vpn evpn
        container advertise {
          tailf:info "Configure advertise for this AF";
          leaf l2vpn {
            tailf:cli-full-command;
            type enumeration {
              enum "evpn";
            }
          }
        }

        // router bgp * / address-family * * / advertise-pip
        leaf advertise-pip {
          tailf:info "Advertise physical ip for type-5 route";
          type empty;
        }

        // router bgp * / address-family * * / allocate-label
        container allocate-label {
          tailf:info "Configure label allocation for this AF";
          tailf:cli-diff-dependency "/nx:feature/mpls/segment-routing";
          choice label-choice {
            leaf all {
              tailf:info "Allocate labels for all routes";
              type empty;
            }
            leaf route-map {
              tailf:info "Allocate labels for selected routes";
              type string {
                tailf:info "WORD;;Route-map name (Max Size 63)";
                length "1..63";
              }
            }
          }
        }

        // router bgp * / address-family * * / distance
        container distance {
          tailf:info "Configure administrative distance";
          tailf:cli-compact-syntax;

          leaf ebgp {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<1-255>;;Distance for EBGP routes *Default value is 20";
            }
          }

          leaf ibgp {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<1-255>;;Distance for IBGP routes *Default value is 200";
            }
          }

          leaf local {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-255>;;Distance for local routes *Default value is 220";
            }
          }
        }

        // router bgp * / address-family * * / maximum-paths
        container maximum-paths {
          tailf:info "Forward packets over multipath paths";
          leaf ibgp {
            tailf:info "Configure multipath for IBGP paths";
            type uint8 {
              tailf:info "<1-64>;;Number of parallel paths";
            }
          }
          leaf number {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-64>;;Number of parallel paths";
            }
          }
          leaf eibgp {
            tailf:info "Configure multipath for both EBGP and IBGP paths";
            tailf:cli-diff-delete-before "../ibgp";
            tailf:cli-diff-delete-before "../number";
            default 1;
            type uint8 {
              tailf:info "<1-64>;;Number of parallel paths";
            }
          }
          leaf mixed {
            tailf:cli-diff-delete-before "../ibgp";
            tailf:cli-diff-delete-before "../number";
            tailf:cli-diff-delete-before "../eibgp";
            tailf:info "Configure multipath for all paths";
            type uint8 {
              tailf:info "<1-64>;;Number of parallel paths";
            }
          }
        }

        // router bgp * / address-family * * / network *
        list network {
          tailf:info "Configure an IP prefix to advertise (NOTE: be sure to match address with address-family type)";
          tailf:cli-compact-syntax;
          tailf:cli-delete-when-empty;
          tailf:cli-sequence-commands;
          tailf:cli-suppress-mode;
          key ip;
          // ... network A.B.C.D/LEN <CR>
          leaf ip {
            nx:verify-network-address {
              when "/tailfned/network-address-validation";
            }
            type union {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IP network to advertise (NOTE: use only under ipv4 address-family)";
              }
              type tailf:ipv4-address-and-prefix-length {
                tailf:info "A.B.C.D/LEN;;IP prefix in CIDR format (NOTE: use only under ipv4 address-family)";
              }
              type tailf:ipv6-address-and-prefix-length {
                tailf:info "A:B::C:D/LEN;;IPv6 prefix format: xxxx:xxxx/ml, xxxx:"
                  +"xxxx::/ml, xxxx::xx/128 (NOTE: use only under ipv6 address-family)";
              }
            }
          }
          // ... network A.B.C.D mask A.B.C.D <CR>
          leaf mask {
            tailf:info "Configure the mask of the IP prefix to advertise";
            when "not(contains(../ip, '/'))" {
              tailf:dependency "../ip";
            }
            type inet:ipv4-address;
          }
          // ... network A.B.C.D mask A.B.C.D route-map WORD <CR>
          leaf route-map {
            tailf:info "Apply route-map to modify attributes";
            type string {
              tailf:info "WORD;;Route-map name (Max Size 63)";
              length "1..63";
            }
          }
        }

        // router bgp * / address-family * * / redistribute
        uses common-base-redistribute-grouping;

        // router bgp * / address-family * * / default-metric
        leaf default-metric {
          tailf:info "Set metric of redistributed routes";
          tailf:cli-full-command;
          type uint32 {
            range "0..4294967295";
            tailf:info "<0-4294967295>;;Default metric";
          }
        }

        // router bgp * / address-family * * / retain
        container retain {
          tailf:info "Retain the routes based on Target VPN Extended Communities";
          when "../type = 'evpn'" {
            tailf:dependency "../type";
          }
          container route-target {
            tailf:info "Specify Target VPN Extended Communities";
            choice all-or-map {
              leaf all {
                tailf:info "All the routes regardless of Target-VPN community";
                type empty;
              }
              leaf route-map {
                tailf:info "Apply route-map to filter routes";
                type string {
                  tailf:info "WORD;;Route-map name (Max Size 63)";
                  length "1..63";
                }
              }
            }
          }
        }

        // router bgp * / address-family * * / export-gateway-ip
        leaf export-gateway-ip {
          tailf:info "Export Gateway IP to Type-5 EVPN routes for VRF";
          type empty;
        }
      }
    }
  }

  // router bgp * / neighbor * / address-family *
  // router bgp * / template peer-policy * /
  grouping template-af-common-grouping {

    // router bgp * / neighbor * / address * * / default-originate
    leaf default-originate {
      tailf:info "Allow default route to propagate";
      type empty;
    }

    // router bgp * / neighbor * / address * * / allowas-in
    container allowas-in {
      tailf:info "Accept as-path with my AS present in it";
      presence "true";
      leaf occurrences {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-10>;;Number of occurrences of AS number, default is 3";
        }
      }
    }

    // router bgp * / neighbor * / address * * / route-reflector-client
    leaf route-reflector-client {
      tailf:info "Configure a neighbor as Route Reflector client";
      type empty;
    }

    // router bgp * / neighbor * / address * * / soo
    leaf soo {
      tailf:info "ID/tag to identify this domain's routes :site of origin";
      type string;
    }

    // router bgp * / neighbor * / address * * / route-map *
    list route-map {
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key direction;
      leaf name {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        type string {
          tailf:info "WORD;;Route-map name (Max Size 63)";
          length "1..63";
        }
      }
      leaf direction {
        type enumeration {
          enum "in";
          enum "out";
        }
      }
    }

    // router bgp * / neighbor * / address * * / maximum-prefix
    container maximum-prefix {
      tailf:info "Maximum number of prefixes from this neighbor";
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      tailf:cli-compact-syntax;
      leaf number {
        tailf:cli-drop-node-name;
        tailf:cli-full-no;
        type uint32 {
          range "1..4294967295";
          tailf:info "<1-4294967295>;;Max. prefix limit";
        }
      }
      leaf threshold {
        tailf:cli-drop-node-name;
        tailf:cli-no-value-on-delete;
        tailf:cli-suppress-no;
        tailf:cli-optional-in-sequence;
        type uint32 {
          range "1..100";
          tailf:info "<1-100>;;Threshold percentage at which to generate a wa"
            +"rning";
        }
      }
      choice restart-or-warning {
        leaf restart {
          tailf:info "Restart bgp connection after limit is exceeded";
          tailf:cli-no-name-on-delete;
          tailf:cli-no-value-on-delete;
          tailf:cli-suppress-no;
          type uint16 {
            tailf:info "<1-65535>;;Restart interval in minutes";
            range "1..65535";
          }
        }
        leaf warning-only {
          tailf:info "Only give warning message when limit is exceeded";
          tailf:cli-no-name-on-delete;
          tailf:cli-suppress-no;
          type empty;
        }
      }
    }

    // router bgp * / neighbor * / address * * / next-hop-self
    leaf next-hop-self {
      tailf:info "Set our peering address as nexthop";
      type empty;
    }

    // router bgp * / neighbor * / address * * / next-hop-third-party
    leaf next-hop-third-party {
      tailf:info "Compute a third-party nexthop if possible";
      tailf:cli-boolean-no;
      tailf:cli-trim-default;
      nx:trim-default-in-show;
      type boolean;
      default true;
    }

    // router bgp * / neighbor * / address * * / rewrite-evpn-rt-asn
    leaf rewrite-evpn-rt-asn {
      tailf:info "Auto generate RTs for EBGP neighbor";
      type empty;
    }

    // router bgp * / neighbor * / address * * / send-community
    container send-community {
      tailf:info "Send community attribute to this neighbor";
      presence true;
      nx:fix-send-community; // Quirk for funny (buggy?) syntax on some nx9k
      leaf attr {
        tailf:cli-trim-default;
        tailf:cli-drop-node-name;
        tailf:cli-remove-before-change;
        default "standard";
        type enumeration {
          enum "standard" {
            tailf:info "Send Standard Community attributes";
          }
          enum "extended" {
            tailf:info "Send Extended Community attributes";
          }
          enum "both" {
            tailf:info "Send Standard and Extended Community attributes";
          }
        }
      }
    }

    // router bgp * / neighbor * / address * * / soft-reconfiguration
    container soft-reconfiguration {
      tailf:info "Soft reconfiguration";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf inbound {
        tailf:info "Allow inbound soft reconfiguration";
        type empty;
      }
      leaf always {
        tailf:info "Always perform inbound soft reconfiguration";
        type empty;
      }
    }

    // router bgp * / neighbor * / address * * / prefix-list *
    list prefix-list {
      tailf:info "Apply prefix-list";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key direction;
      leaf name {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        type string {
          tailf:info "WORD;;Name of prefix-list (Max Size 63)";
          length "1..63";
        }
      }
      leaf direction {
        type enumeration {
          enum "in" {
            tailf:info "Apply policy to incoming routes";
          }
          enum "out" {
            tailf:info "Apply policy to outgoing routes";
          }
        }
      }
    }

    list filter-list {
      tailf:info "Apply AS-PATH filter-list";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key direction;
      leaf name {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        type string {
          tailf:info "WORD;;Name of filter-list (Max Size 63)";
        }
      }
      leaf direction {
        type enumeration {
          enum "in" {
            tailf:info "Apply policy to incoming routes";
          }
          enum "out" {
            tailf:info "Apply policy to outgoing routes";
          }
        }
      }
    }

    // router bgp * / neighbor * / address * * / disable-peer-as-check
    leaf disable-peer-as-check {
      tailf:info "Disable checking of peer AS-number while advertising";
      type empty;
    }

    // router bgp * / neighbor * / address-family * | peer-policy / inherit peer-policy *
    container inherit {
      tailf:info "Inherit a template";
      list peer-policy {
        tailf:info "Inherit a peer-policy template";
        tailf:cli-suppress-mode;
        tailf:cli-incomplete-command;
        tailf:cli-remove-before-change;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Template name (Max Size 80)";
            length "1..80";
          }
        }
        leaf sequence {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-65535>;;Sequence number";
          }
        }
      }
    }

    // router bgp * / neighbor * / address-family * | peer-policy / encapsulation mpls
    container encapsulation {
      tailf:info "Configure encapsulation type for EVPN routes";
      leaf mpls {
        tailf:info "Mpls encapsulation";
        type empty;
      }
    }

    // router bgp * / neighbor * / address-family * | peer-policy / capability additional-paths
    container capability {
      tailf:info "Advertise capability to the peer";
      container additional-paths {
        tailf:info "Additional paths capability";
        choice receive-choice {
          leaf receive {
            tailf:info "Additional paths Receive capability";
            tailf:cli-full-command;
            type empty;
          }
          container disable-receive {
            tailf:cli-drop-node-name;
            container receive {
              tailf:cli-incomplete-command;
              tailf:cli-incomplete-no;
              leaf disable {
                tailf:info "Do not advertise additional paths Receive capability";
                type empty;
              }
            }
          }
        }
        choice send-choice {
          leaf send {
            tailf:info "Additional paths Send capability";
            tailf:cli-full-command;
            type empty;
          }
          container disable-send {
            tailf:cli-drop-node-name;
            container send {
              tailf:cli-incomplete-command;
              tailf:cli-incomplete-no;
              leaf disable {
                tailf:info "Do not advertise additional paths Send capability";
                type empty;
              }
            }
          }
        }
      }
    }

    // router bgp * / template|neighbor * / address * * / weight
    leaf weight {
      tailf:info "Set default weight for routes from this neighbor";
      type uint16 {
        tailf:info "<0-65535>;;Default weight";
      }
    }

    // router bgp * / template|neighbor * / address * * / as-override
    leaf as-override {
      tailf:info "Override matching AS-number while sending update";
      type empty;
    }

    leaf advertisement-interval {
      tailf:info "Advertisement interval";
      type uint16 {
        tailf:info "<1-600>;;Interval";
      }
    }
  }

  // router bgp * / neighbor * /
  // router bgp * / template peer * /
  // router bgp * / template peer-session * /
  grouping template-base-grouping {

    // router bgp * / neighbor * / local-as
    choice local-as-choice {
      leaf local-as {
        tailf:info "Specify the local-as number for the eBGP neighbor";
        tailf:cli-full-command;
        type asn-type;
      }
      // router bgp * / neighbor * / local-as ? no-prepend
      container local-as-no-prepend {
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf local-as {
          tailf:info "Specify the local-as number for the eBGP neighbor";
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          type asn-type;
        }
        leaf no-prepend {
          tailf:info "Do not prepend the local-as number to updates from the eBGP neighbor";
          type empty;
        }
        leaf replace-as {
          tailf:info "Prepend only the local-as number to updates to eBGP neighbor";
          type empty;
        }
        leaf dual-as {
          tailf:info "Connect using either the local-as number or the real as";
          type empty;
        }
      }
    }

    // router bgp * / neighbor * / password
    container password {
      tailf:info "Configure a password for neighbor";
      tailf:cli-compact-syntax;
      leaf encryption {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        nx:device-transformed-dependency;
        type enumeration {
          enum "0" {
            tailf:info "Specifies an UNENCRYPTED "
              +"neighbor password will follow";
          }
          enum "3" {
            tailf:info "Specifies an 3DES ENCRYPTED "
              +"neighbor password will follow";
          }
          enum "7" {
            tailf:info "Specifies a Cisco type 7 ENCRYPTED "
              +"neighbor password will follow";
          }
        }
      }
      leaf passwd {
        tailf:cli-drop-node-name;
        tailf:cli-disallow-value "0|3|7";
        nx:device-transformed-value;
        type NEDCOM_SECRET_TYPE {
          tailf:info "WORD;;The neighbor password";
        }
      }
    }

    // router bgp * / neighbor * / description
    leaf description {
      tailf:info "Neighbor specific description";
      tailf:cli-full-command;
      tailf:cli-multi-value;
      tailf:cli-preformatted;
      tailf:cli-no-value-on-delete;
      type string {
        tailf:info "LINE;;Up to 80 characters describing this neighbor";
      }
    }

    // router bgp * / neighbor * / ebgp-multihop
    leaf ebgp-multihop {
      tailf:info "Allow EBGP neighbors not on directly connected networks";
      type uint8 {
        tailf:info "<2-255>;;maximum hop count";
        range "2..255";
      }
    }

    // router bgp * / neighbor * / inherit
    container inherit {
      tailf:info "Inherit a template";

      // router bgp * / neighbor * / inherit peer
      leaf peer {
        tailf:info "Inherit a peer template";
        type string {
          tailf:info "WORD;;Template name (Max Size 80)";
          length "1..80";
        }
      }

      // router bgp * / neighbor * / inherit peer-session
      leaf peer-session {
        tailf:info "Inherit a peer-session template";
        type string {
          tailf:info "WORD;;Template name (Max Size 80)";
          length "1..80";
        }
      }
    }

    // router bgp * / neighbor * / update-source
    leaf update-source {
      tailf:info "Source of routing updates";
      type string {
        tailf:info "WORD;;Interface name";
      }
    }

    // router bgp * / neighbor * / disable-connected-check
    leaf disable-connected-check {
      tailf:info "Disable check for directly connected peer";
      type empty;
    }

    // router bgp * / neighbor * / no dynamic-capability
    leaf dynamic-capability {
      tailf:info "Dynamic capability";
      tailf:cli-boolean-no;
      tailf:cli-trim-default;
      default "true";
      type boolean;
    }

    // router bgp * / neighbor * / capability suppress 4-byte-as
    container capability {
      tailf:info "Advertise capability to the peer";
      container suppress {
        tailf:info "Suppress advertising capability to the peer ";
        container four-byte-as {
          tailf:alt-name "4-byte-as";
          tailf:info "4-byte-as capability";
          presence "true";
          leaf inheritance-disable {
            tailf:info "Prevent capability suppress 4-type-as being "
              +"inherited from the parent";
            type empty;
          }
        }
      }
    }

    // router bgp * / neighbor * / bfd
    leaf bfd {
      tailf:info "Bidirectional Fast Detection for the neighbor";
      tailf:cli-diff-dependency "/nx:feature/bfd";
      tailf:cli-full-command;
      when "/nx:feature/bfd" {
        tailf:dependency "/nx:feature/bfd";
      }
      type empty;
    }

    container bfd-config {
      tailf:cli-drop-node-name;
      container bfd {
        tailf:cli-diff-dependency "/nx:feature/bfd";
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        container multihop {
          tailf:info "For Multihop sessions";
          container interval {
            tailf:info "Configure BFD session interval parameters";
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            tailf:cli-compact-syntax;
            leaf tx-interval {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint16 {
                tailf:info "<250-999>;;TX interval in milliseconds";
              }
            }
            leaf min_rx {
              tailf:info "Minimum RX interval";
              tailf:cli-incomplete-command;
              type uint16 {
                tailf:info "<250-999>;;RX interval in milliseconds";
              }
            }
            leaf multiplier {
              tailf:info "Configure detect multiplier for bfd sessions";
              type uint8 {
                tailf:info "<1-50>;;Detect Multiplier";
              }
            }
          }
        }
      }
    }

    // router bgp * / neighbor * / shutdown
    leaf shutdown {
      tailf:info "Administratively shutdown this neighbor";
      type empty;
    }

    // router bgp * / neighbor * / timers
    container timers {
      tailf:info "Configure keepalive and hold timers";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf keepalive {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint16 {
          tailf:info "<0-3600>;;Keepalive interval (seconds) *Default value is 60";
          range "0..3600";
        }
      }
      leaf holdtime {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<0-3600>;;Holdtime (seconds) *Default value is 180";
          range "0..3600";
        }
      }
    }

    // router bgp * / neighbor|neighbor * / peer-type
    leaf peer-type {
      tailf:info "Neighbor facing";
      tailf:cli-diff-delete-before "/nx:nv/overlay/evpn";
      type enumeration {
        enum fabric-border-leaf {
          tailf:info "Fabric Border Leaf";
        }
        enum fabric-external {
          tailf:info "Fabric external";
        }
      }
    }

    // router bgp * / neighbor * / remove-private-as
    container remove-private-as {
      tailf:info "Remove private AS number from outbound updates";
      presence true;
      tailf:cli-delete-when-empty;
      choice all-or-replace {
        leaf all {
          tailf:info "All";
          type empty;
        }
        leaf replace-as {
          tailf:info "Replace";
          type empty;
        }
      }
    }

    // router bgp * / neighbor * / log-neighbor-changes
    leaf log-neighbor-changes {
      tailf:info "Log a message for neighbor up/down event";
      type empty;
    }
  }

  // router bgp * / neighbor * /
  // router bgp * / template peer * /
  grouping template-neighbor-common-grouping {
    uses template-base-grouping;
    // router bgp * / neighbor * / address-family *
    list address-family {
      tailf:info "Configure an address-family";
      tailf:cli-explicit-exit;
      key "proto type";
      leaf proto {
        type enumeration {
          enum "ipv4";
          enum "ipv6";
          enum "l2vpn";
          enum "vpnv4";
          enum "vpnv6";
          enum "nsap";
          enum "rtfilter";
        }
      }
      leaf type {
        type enumeration {
          enum "unicast";
          enum "multicast";
          enum "mvpn";
          enum "evpn";
          enum "labeled-unicast";
        }
      }
      uses template-af-common-grouping;
    }

    // router bgp * / neighbor * / egress-engineering
    choice egress-eng-choice {
      leaf egress-engineering {
        tailf:info "Configure Egress Peer Engineering (EPE) for peer";
        tailf:cli-full-command;
        type empty;
      }
      container egress-engineering-peerset {
        tailf:cli-drop-node-name;
        container egress-engineering {
          tailf:info "Configure Egress Peer Engineering (EPE) for peer";
          leaf peer-set {
            tailf:info "Configure EPE Peer-Set";
            type string {
              tailf:info "WORD;;EPE Peer-Set name (Max Size 63)";
            }
          }
        }
      }
    }

    leaf dont-capability-negotiate {
      tailf:info "Don't negotiate capability with this neighbor";
      type empty;
    }
  }

  // router bgp * /
  grouping router-bgp-grouping {

    // router bgp * / address-family *
    uses router-bgp-address-family-grouping;

    // router bgp * / log-neighbor-changes
    leaf log-neighbor-changes {
      tailf:info "Log a message for neighbor up/down event";
      type empty;
    }

    // router bgp * / router-id A.B.C.D <CR>
    leaf router-id {
      tailf:info "Specify the IP address to use as router-id";
      tailf:cli-full-command;
      type inet:ipv4-address;
    }

    leaf cluster-id {
      tailf:info "Configure Route Reflector Cluster-ID";
      type union {
        type uint32 {
          tailf:info "<1-4294967295>;;Cluster-id as a 32 bit quantity";
        }
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Cluster-id as an IP address";
        }
      }
    }

    // router bgp * / neighbor *
    list neighbor {
      tailf:info "Specify a neighbor router";
      tailf:cli-explicit-exit;
      key id;
      leaf id {
        type union {
          type inet:ipv4-address;
          type inet:ipv6-address;
          type tailf:ipv4-address-and-prefix-length;
          type tailf:ipv6-address-and-prefix-length;
        }
      }

      // router bgp * / neighbor * / remote-as X
      container remote-as {
        tailf:cli-compact-syntax;
        tailf:cli-flatten-container;
        tailf:cli-hide-in-submode;
        choice remote-as-choice {
          leaf as-number {
            tailf:cli-drop-node-name;
            tailf:cli-hide-in-submode;
            tailf:cli-full-command;
            type string;
          }
          leaf route-map {
            tailf:cli-hide-in-submode;
            type string;
          }
        }
      }

      // router bgp * / neighbor * / remote-as
      container inner-remote-as {
        tailf:cli-drop-node-name;
        leaf remote-as {
          tailf:info "Specify Autonomous System Number of the neighbor";
          tailf:cli-diff-delete-after "../../address-family/disable-peer-as-check";
          type asn-type;
        }
      }

      leaf rewrite-evpn-rt-asn {
        tailf:info "Auto generate RTs for EBGP neighbor";
        tailf:cli-diff-delete-before "../inner-remote-as/remote-as";
        type empty;
      }

      // router bgp * / neighbor * / X
      uses template-neighbor-common-grouping;

      // router bgp * / neighbor * / address-family link-state
      container af-linkstate {
        tailf:cli-drop-node-name;
        container address-family {
          tailf:info "Configure an address-family for peer";
          container link-state {
            tailf:info "Configure link-state address-family";
            tailf:cli-add-mode;
            presence true;
            leaf allowas-in {
              tailf:info "Accept as-path with my AS present in it";
              type uint8 {
                tailf:info "<1-10>;;Number of occurrences of AS number, default is 3";
              }
            }
          }
        }
      }

      // router bgp * / neighbor * / transport connection-mode passive
      container transport {
        tailf:info "BGP transport connection";
        container connection-mode {
          tailf:info "Specify type of connection";
          leaf passive {
            tailf:info "Allow passive connection setup only";
            type empty;
          }
        }
      }
    }

    // router bgp * / suppress-fib-pending
    leaf suppress-fib-pending {
      tailf:info "Advertise only routes that are programmed in hardware to peers";
      type empty;
    }

    // router bgp * / timers
    container timers {
      tailf:info "Configure bgp related timers";
      container bgp {
        tailf:info "Configure different bgp keepalive and holdtimes";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf keepalive {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<0-3600>;;Keepalive interval (seconds) *Default value is 60";
            range "0..3600";
          }
        }
        leaf holdtime {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-3600>;;Holdtime (seconds) *Default value is 180";
            range "0..3600";
          }
        }
      }
      leaf bestpath-limit {
        tailf:info "Configure timeout for first bestpath after restart";
        tailf:cli-remove-before-change;
        default 300;
        type uint16 {
          tailf:info "<1-3600>;;Bestpath timeout (seconds) *Default value is 300";
        }
      }

    }

    // router bgp * / graceful-restart
    leaf graceful-restart {
      tailf:cli-full-command;
      tailf:cli-boolean-no;
      default true;
      type boolean;
    }
    container graceful-restart-config {
      tailf:cli-drop-node-name;
      container graceful-restart {
        tailf:info "Configure Graceful Restart functionality";
        tailf:cli-incomplete-command;
        leaf restart-time {
          tailf:info "Maximum time for restart advertised to peers";
          default 120;
          type uint16 {
            tailf:info "<1-3600>;;Restart time (seconds) *Default value is 120";
            range "1..3600";
          }
        }
        leaf stalepath-time {
          tailf:info "Maximum time to keep a restarting peer's stale routes";
          default 300;
          type uint16 {
            tailf:info "<1-3600>;;Stalepath time (seconds) *Default value is 300";
            range "1..3600";
          }
        }
      }
    }

    // router bgp * / bestpath
    container bestpath {
      tailf:info "Change default bestpath selection algorithm";
      leaf always-compare-med {
        tailf:info "Compare MED on paths from different AS";
        type empty;
      }
      container as-path {
        tailf:info "AS-Path";
        leaf multipath-relax {
          tailf:info "Relax AS-Path restriction when choosing multipaths";
          type empty;
        }
        leaf ignore {
          tailf:info "Ignore AS-Path during bestpath selection";
          type empty;
        }
      }
      leaf compare-neighborid {
        tailf:info "When more paths available than max path config, use neighborid tibreaker";
        type empty;
      }
      leaf compare-routerid {
        tailf:info "Compare router-id for identical EBGP paths";
        type empty;
      }
      container cost-community {
        tailf:info "Cost community";
        leaf ignore {
          tailf:info "Ignore cost communities in bestpath selection";
          type empty;
        }
      }
      container igp-metric {
        tailf:info "IGP metric for next-hop";
        leaf ignore {
          tailf:info "Ignore IGP metric for next-hop during bestpath selection";
          type empty;
        }
      }
      container med {
        tailf:info "MED";
        leaf confed {
          tailf:info "Compare MED only from paths originated from within a confederation";
          type empty;
        }
        leaf missing-as-worst {
          tailf:info "Treat missing MED as highest MED";
          type empty;
        }
        leaf non-deterministic {
          tailf:info "Not always pick the best-MED path among paths from same AS";
          type empty;
        }
      }
    }

    // router bgp * / neighbor-down
    container neighbor-down {
      tailf:info "Handle BGP neighbor down event, due to various reasons";
      leaf fib-accelerate {
        tailf:info "Accelerate the hardware updates for IP/IPv6 adjacencies for neighbor";
        type empty;
      }
    }
  }

  // router bgp * / address-family * / dampening
  grouping router-bgp-af-dampening-grouping {
    choice dampening-choice {
      leaf dampening {
        tailf:info "Configure route flap dampening";
        tailf:cli-remove-before-change;
        type empty;
      }
      container rm-dampening {
        tailf:cli-drop-node-name;
        container dampening {
          tailf:info "Configure route flap dampening";
          leaf route-map {
            tailf:info "Apply route-map to specify dampening criteria";
            type string {
              tailf:info "WORD;;Route-map name (Max Size 63)";
            }
          }
        }
      }
      container spec-dampening {
        tailf:cli-drop-node-name;
        container dampening {
          tailf:info "Configure route flap dampening";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf decay {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-45>;;Decay half life";
            }
          }
          leaf reuse {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<1-20000>;;Value to start reusing a route";
            }
          }
          leaf suppress {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<1-20000>;;Value to start suppressing a route";
            }
          }
          leaf max-suppress {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-255>;;Maximum suppress time for stable route";
            }
          }
        }
      }
    }
  }

  grouping ip-route-options-grouping {
    leaf track {
      tailf:info "Specify the Object to be Tracked";
      tailf:cli-optional-in-sequence;
      tailf:non-strict-leafref {
        path "/nx:track/id";
      }
      type uint16 {
        tailf:info "<1-512>;;Track Object Number";
      }
    }
    leaf name {
      tailf:cli-optional-in-sequence;
      type string {
        tailf:info "WORD;;Nexthop name";
      }
    }
    leaf tag {
      tailf:cli-optional-in-sequence;
      tailf:info "Supply tag value with static route";
      type uint32;
    }
    leaf preference {
      tailf:cli-drop-node-name;
      type uint8 {
        tailf:info "<1-255>;;Route preference. *Default value is 1";
        range "1..255";
      }
    }
  }

  grouping ip-access-packet-match-grouping {
    choice match-type-choice {
      case packet-match {
        leaf packet-match {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type enumeration {
            enum eq {
              tailf:info "Match only packets on a given port number";
            }
            enum gt {
              tailf:info "Match only packets with a greater port number";
            }
            enum lt {
              tailf:info "Match only packets with a lower port number";
            }
            enum neq {
              tailf:info "Match only packets not on a given port number";
            }
            enum range {
              tailf:info "Match only packets in the range of port numbers";
            }
          }
        }
        leaf value {
          tailf:cli-drop-node-name;
          type protocol-port-type;
        }
        leaf end-value {
          tailf:cli-drop-node-name;
          when "../packet-match = 'range'";
          type protocol-port-type;
        }
      }
      case group-match {
        leaf portgroup {
          tailf:info "Source/destination port group";
          tailf:non-strict-leafref {
            path "/nx:object-group/ip/port/name";
          }
          type string {
            tailf:info "WORD;;Port group name";
          }
        }
      }
    }
  }

  grouping ip-access-list-option-grouping {
    container common-packet-match {
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      tailf:cli-optional-in-sequence;
      tailf:cli-sequence-commands;
      tailf:cli-compact-syntax;
      when "../protocol = 'udp' or ../protocol = 'tcp' or ../protocol = 'sctp'";
      uses ip-access-packet-match-grouping;
    }

    leaf urg {
      tailf:info "Match on the URG bit";
      tailf:cli-optional-in-sequence;
      when "../protocol = 'tcp'";
      type empty;
    }
    leaf ack {
      tailf:info "Match on the ACK bit";
      tailf:cli-optional-in-sequence;
      when "../protocol = 'tcp'";
      type empty;
    }
    leaf psh {
      tailf:info "Match on the PSH bit";
      tailf:cli-optional-in-sequence;
      when "../protocol = 'tcp'";
      type empty;
    }
    leaf rst {
      tailf:info "Match on the RST bit";
      tailf:cli-optional-in-sequence;
      when "../protocol = 'tcp'";
      type empty;
    }
    leaf syn {
      tailf:info "Match on the SYN bit";
      tailf:cli-optional-in-sequence;
      when "../protocol = 'tcp'";
      type empty;
    }
    leaf fin {
      tailf:info "Match on the FIN bit";
      tailf:cli-optional-in-sequence;
      when "../protocol = 'tcp'";
      type empty;
    }
    leaf established {
      tailf:info "Match established connections";
      tailf:cli-optional-in-sequence;
      when "../protocol = 'tcp'";
      type empty;
    }
    choice dscp-or-precedence {
      leaf dscp {
        tailf:info "Match packets with given dscp value";
        tailf:cli-optional-in-sequence;
        type dscp-value-type;
      }
      leaf precedence {
        tailf:info "Match packets with given precedence value";
        tailf:cli-optional-in-sequence;
        type precedence-type;
      }
    }
    leaf fragments {
      tailf:info "Check non-initial fragments";
      tailf:cli-optional-in-sequence;
      type empty;
    }
    leaf time-range {
      tailf:info "Specify a time range";
      tailf:cli-optional-in-sequence;
      type string {
        length "1..64";
      }
    }
    container packet-length {
      tailf:info "Match packets based on layer 3 packet length";
      tailf:cli-optional-in-sequence;
      tailf:cli-flatten-container;
      tailf:cli-sequence-commands;
      tailf:cli-compact-syntax;
      leaf op {
        tailf:cli-drop-node-name;
        type enumeration {
          enum eq {
            tailf:info "Match only packets on a given packet length";
          }
          enum gt {
            tailf:info "Match only packets with a greater packet length";
          }
          enum lt {
            tailf:info "Match only packets with a lower packet length";
          }
          enum neq {
            tailf:info "Match only packets not on a given packet length";
          }
          enum range {
            tailf:info "Match only packets in the range of packet lengths";
          }
        }
      }
      leaf value {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<20-9210>;;Packet legth";
          range "20..9210";
        }
      }
      leaf value-high {
        tailf:cli-drop-node-name;
        when "../op = 'range'";
        type uint16 {
          tailf:info "<20-9210>;;Higher packet length";
          range "20..9210";
        }
      }
    }
    leaf log {
      tailf:info "Log matches against this entry";
      tailf:cli-optional-in-sequence;
      type empty;
    }
    choice capture-or-redirect {
      container capture {
        tailf:info "Enable packet capture on this filter for session";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf session {
          tailf:info "Session ID <1-48> for this session";
          type uint8 {
            tailf:info "<1-48>;;Session ID <1-48> for this session";
            range "1..48";
          }
        }
      }
      container redirect-config {
        tailf:cli-drop-node-name;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        tailf:cli-flatten-container;
        leaf redirect {
          tailf:info "Redirect all or redirect to interface(s).";
          type empty;
        }
        leaf redirect-interfaces {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;Redirect: e.g. Ethernet1/1,port-channel1";
          }
        }
      }
    }
  }

  grouping ip-access-list-grouping {

    // <protocol>
    leaf protocol {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type union {
        type uint8 {
          tailf:info "<0-255>;;A protocol number";
        }
        type enumeration {
          enum "ahp" {
            tailf:info "Authentication header protocol";
            value 51;
          }
          enum "eigrp" {
            tailf:info "Cisco's EIGRP routing protocol";
            value 88;
          }
          enum "esp" {
            tailf:info "Encapsulation security payload";
            value 50;
          }
          enum "gre" {
            tailf:info "Cisco's GRE tunneling";
            value 47;
          }
          enum "icmp" {
            tailf:info "Internet Control Message Protocol";
            value 1;
          }
          enum "igmp" {
            tailf:info "Internet Group Management Protocol";
            value 2;
          }
          enum "ip" {
            tailf:info "Any IP protocol";
            value 0;
          }
          enum "nos" {
            tailf:info "KA9Q NOS compatible IP over IP tunneling";
            value 94;
          }
          enum "ospf" {
            tailf:info "OSPF routing protocol";
            value 89;
          }
          enum "pcp" {
            tailf:info "Payload compression protocol";
            value 108;
          }
          enum "pim" {
            tailf:info "Protocol independent multicast";
            value 103;
          }
          enum "tcp" {
            tailf:info "Transmission Control Protocol";
            value 6;
          }
          enum "udp" {
            tailf:info "User Datagram Protocol";
            value 17;
          }
        }
      }
    }

    // <source>
    container source {
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-incomplete-command;
      choice source-choice {
        leaf host {
          tailf:info "A single source host";
          tailf:cli-incomplete-command;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Source address";
          }
        }
        leaf any {
          tailf:info "Any source address";
          tailf:cli-incomplete-command;
          type empty;
        }
        leaf address-and-prefix {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type tailf:ipv4-address-and-prefix-length {
            tailf:info "A.B.C.D/LEN;;Source network prefix";
          }
        }
        leaf address {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Source network address";
          }
        }
        leaf addrgroup {
          tailf:info "Source address group";
          tailf:cli-incomplete-command;
          tailf:non-strict-leafref {
            path "/nx:object-group/ip/address/name";
          }
          type string {
            tailf:info "WORD;;Address group name";
          }
        }
      }
      leaf source-mask {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        when "../address";
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Source wildcard bits";
        }
      }
    }

    container packet-match-source {
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      tailf:cli-optional-in-sequence;
      tailf:cli-sequence-commands;
      tailf:cli-compact-syntax;
      when "../protocol = 'udp' or ../protocol = 'tcp'";
      uses ip-access-packet-match-grouping;
    }

    // <destination>
    choice destination-choice {
      leaf host {
        tailf:info "A single destination host";
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Destination address";
        }
      }
      leaf any {
        tailf:info "Any destination address";
        type empty;
      }
      leaf address-and-prefix {
        tailf:cli-drop-node-name;
        type tailf:ipv4-address-and-prefix-length {
          tailf:info "A.B.C.D/LEN;;Destination network prefix";
        }
      }
      leaf address {
        tailf:cli-drop-node-name;
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Destination network address";
        }
      }
      leaf addrgroup {
        tailf:info "Destination address group";
        tailf:non-strict-leafref {
          path "/nx:object-group/ip/address/name";
        }
        type string {
          tailf:info "WORD;;Address group name";
        }
      }
    }

    leaf dest-mask {
      tailf:cli-drop-node-name;
      when "../address";
      type inet:ipv4-address {
        tailf:info "A.B.C.D;;Destination wildcard bits";
      }
    }

    leaf icmp-message-match {
      when "../protocol = 'icmp'" {
        tailf:dependency "../protocol";
      }
      tailf:cli-drop-node-name;
      tailf:cli-optional-in-sequence;
      type union {
        type uint8 {
          tailf:info "<0-255>;;ICMP message type";
        }
        type enumeration {
          enum echo-reply {
            tailf:info "Echo reply";
            value 0;
          }
          enum echo {
            tailf:info "Echo (7)";
            value 8;
          }
          enum ttl-exceeded {
            tailf:info "TTL exceeded";
            value 11;
          }
          enum time-exceeded {
            tailf:info "All time exceededs";
          }
          enum port-unreachable {
            tailf:info "Port unreachable";
            value 3;
          }
          enum host-unreachable {
            tailf:info "Host unreachable";
          }
          enum unreachable {
            tailf:info "All unreachables";
          }
          enum packet-too-big {
            tailf:info "Fragmentation needed and DF set";
          }
          enum hop-limit {
            tailf:info "Hop limit exceeded in transit";
          }
          enum next-header {
            tailf:info "Parameter next header problems";
          }
          enum parameter-option {
            tailf:info "Parameter option problems";
          }
          enum parameter-problem {
            tailf:info "All parameter problems";
          }
          enum protocol-unreachable {
            tailf:info "Protocol unreachable";
          }
          enum administratively-prohibited {
            tailf:info "Administratively prohibited";
          }
          enum alternate-address {
            tailf:info "Alternate address";
          }
          enum conversion-error {
            tailf:info "Datagram conversion";
          }
          enum dod-host-prohibited {
            tailf:info "Host prohibited";
          }
          enum dod-net-prohibited {
            tailf:info "Net prohibited";
          }
          enum general-parameter-problem {
            tailf:info "Parameter problem";
          }
          enum host-isolated {
            tailf:info "Host isolated";
          }
          enum host-precedence-unreachable {
            tailf:info "Host unreachable for precedence";
          }
          enum host-redirect {
            tailf:info "Host redirect";
          }
          enum host-tos-redirect {
            tailf:info "Host redirect for TOS";
          }
          enum host-tos-unreachable {
            tailf:info "Host unreachable for TOS";
          }
          enum host-unknown {
            tailf:info "Host unknown";
          }
          enum information-reply {
            tailf:info "Information replies";
          }
          enum information-request {
            tailf:info "Information requests";
          }
          enum mask-reply {
            tailf:info "Mask replies";
          }
          enum mask-request {
            tailf:info "Mask requests";
          }
          enum mobile-redirect {
            tailf:info "Mobile host redirect";
          }
          enum net-redirect {
            tailf:info "Network redirect";
          }
          enum net-tos-redirect {
            tailf:info "Net redirect for TOS";
          }
          enum net-tos-unreachable {
            tailf:info "Network unreachable for TOS";
          }
          enum net-unreachable {
            tailf:info "Net unreachable";
          }
          enum network-unknown {
            tailf:info "Network unknown";
          }
          enum no-room-for-option {
            tailf:info "Parameter required but no room";
          }
          enum option-missing {
            tailf:info "Parameter required but not present";
          }
          enum precedence-unreachable {
            tailf:info "Precedence cutoff";
          }
          enum reassembly-timeout {
            tailf:info "Reassembly timeout";
          }
          enum router-advertisement {
            tailf:info "Router discovery advertisements";
          }
          enum router-solicitation {
            tailf:info "Router discovery solicitations";
          }
          enum traceroute {
            tailf:info "Traceroute";
          }
          enum source-quench {
            tailf:info "Source quenches";
          }
          enum source-route-failed {
            tailf:info "Source route failed";
          }
        }
      }
    }

    leaf icmp-message-code {
      when "../icmp-message-match" {
        tailf:dependency "../icmp-message-match";
      }
      tailf:cli-drop-node-name;
      tailf:cli-optional-in-sequence;
      type uint8 {
        tailf:info "<0-255>;;ICMP message code";
      }
    }

    leaf igmp-message-match {
      when "../protocol = 'igmp'" {
        tailf:dependency "../protocol";
      }
      tailf:cli-drop-node-name;
      tailf:cli-optional-in-sequence;
      type enumeration {
        enum dvmrp {
          tailf:info "Distance Vector Multicast Routing Protocol";
        }
        enum host-query {
          tailf:info "Host query";
        }
        enum host-report {
          tailf:info "Host report";
        }
        enum pim {
          tailf:info "Protocol Independent Multicast";
        }
      }
    }

    uses ip-access-list-option-grouping;
  }

  grouping ipv6-access-list-grouping {
    // <protocol>
    leaf protocol {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type union {
        type uint8 {
          tailf:info "<0-255>;;A protocol number";
        }
        type enumeration {
          enum "ahp" {
            tailf:info "Authentication header protocol";
            value 51;
          }
          enum "eigrp" {
            tailf:info "Cisco's EIGRP routing protocol";
            value 88;
          }
          enum "esp" {
            tailf:info "Encapsulation security payload";
            value 50;
          }
          enum "gre" {
            tailf:info "Cisco's GRE tunneling";
            value 47;
          }
          enum "icmp" {
            tailf:info "Internet Control Message Protocol";
            value 58;
          }
          enum "ipv6" {
            tailf:info "Any IPv6 Protocol";
            value 41;
          }
          enum "sctp" {
            tailf:info "Stream Control Transmission Protocol";
            value 132;
          }
          enum "nos" {
            tailf:info "KA9Q NOS compatible IP over IP tunneling";
            value 94;
          }
          enum "ospf" {
            tailf:info "OSPF routing protocol";
            value 89;
          }
          enum "pcp" {
            tailf:info "Payload compression protocol";
            value 108;
          }
          enum "pim" {
            tailf:info "Protocol independent multicast";
            value 103;
          }
          enum "tcp" {
            tailf:info "Transmission Control Protocol";
            value 6;
          }
          enum "udp" {
            tailf:info "User Datagram Protocol";
            value 17;
          }
          enum "ip" {
            tailf:info "Any IPv6 Protocol";
          }
        }
      }
    }

    // <source>
    container source {
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-incomplete-command;
      choice source-choice {
        leaf host {
          tailf:info "A single source host";
          tailf:cli-incomplete-command;
          type inet:ipv6-address {
            tailf:info "A:B::C:D;;Source address";
          }
        }
        leaf any {
          tailf:info "Any source address";
          tailf:cli-incomplete-command;
          type empty;
        }
        leaf address-and-prefix {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type tailf:ipv6-address-and-prefix-length {
            tailf:info "A:B::C:D/LEN;;Source network prefix";
          }
        }
        leaf address {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type inet:ipv6-address {
            tailf:info "A:B::C:D;;Source network address";
          }
        }
        leaf addrgroup {
          tailf:info "Source address group";
          tailf:cli-incomplete-command;
          tailf:non-strict-leafref {
            path "/nx:object-group/ipv6/address/name";
          }
          type string {
            tailf:info "WORD;;Address group name";
          }
        }
      }
      leaf source-mask {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        when "../address";
        type inet:ipv6-address {
          tailf:info "A:B::C:D;;Source wildcard bits";
        }
      }
    }

    container packet-match-source {
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      tailf:cli-optional-in-sequence;
      tailf:cli-sequence-commands;
      tailf:cli-compact-syntax;
      when "../protocol = 'udp' or ../protocol = 'tcp' or ../protocol = 'sctp'";
      uses ip-access-packet-match-grouping;
    }

    // <destination>
    choice destination-choice {
      leaf host {
        tailf:info "A single destination host";
        type inet:ipv6-address {
          tailf:info "A:B::C:D;;Destination address";
        }
      }
      leaf any {
        tailf:info "Any destination address";
        type empty;
      }
      leaf address-and-prefix {
        tailf:cli-drop-node-name;
        type tailf:ipv6-address-and-prefix-length {
          tailf:info "A:B::C:D/LEN;;Destination network prefix";
        }
      }
      leaf address {
        tailf:cli-drop-node-name;
        type inet:ipv6-address {
          tailf:info "A:B::C:D;;Destination network address";
        }
      }
      leaf addrgroup {
        tailf:info "Destination address group";
        tailf:non-strict-leafref {
          path "/nx:object-group/ipv6/address/name";
        }
        type string {
          tailf:info "WORD;;Address group name";
        }
      }
    }

    leaf dest-mask {
      tailf:cli-drop-node-name;
      when "../address";
      type inet:ipv6-address {
        tailf:info "A:B::C:D;;Destination wildcard bits";
      }
    }

    leaf icmpv6-message-type {
      tailf:cli-drop-node-name;
      tailf:cli-optional-in-sequence;
      when "../protocol = 'icmp'" {
        tailf:dependency "../protocol";
      }
      type enumeration {
        enum echo-request {
          tailf:info "Echo request (ping)";
          value 128;
        }
        enum echo-reply {
          tailf:info "Echo reply";
          value 129;
        }
        enum router-solicitation {
          tailf:info "Neighbor discovery router solicitations";
          value 133;
        }
        enum router-advertisement {
          tailf:info "Neighbor discovery router advertisements";
          value 134;
        }
        enum nd-ns {
          tailf:info "Neighbor discovery neighbor solicitations";
          value 135;
        }
        enum nd-na {
          tailf:info "Neighbor discovery neighbor advertisements";
          value 136;
        }
        enum mld-query {
          tailf:info "Multicast Listener Discovery Query";
          value 130;
        }
        enum mld-reduction {
          tailf:info "Multicast Listener Discovery Reduction";
        }
        enum mld-report {
          tailf:info "Multicast Listener Discovery Report";
          value 131;
        }
        enum mldv2 {
          tailf:info "Multicast Listener Discovery Protocol";
        }
        enum hop-limit {
          tailf:info "Hop limit exceeded in transit";
        }
        enum next-header {
          tailf:info "Parameter next header problems";
        }
        enum packet-too-big {
          tailf:info "Packet too big";
        }
        enum parameter-option {
          tailf:info "Parameter option problems";
        }
        enum parameter-problem {
          tailf:info "All parameter problems";
        }
        enum no-route {
          tailf:info "No route to destination";
        }
        enum port-unreachable {
          tailf:info "Port unreachable";
        }
        enum unreachable {
          tailf:info "All unreachable";
        }
        enum router-renumbering {
          tailf:info "All router renumbering";
        }
        enum time-exceeded {
          tailf:info "All time exceededs";
        }
        enum header {
          tailf:info "Parameter header problems";
        }
        enum destination-unreachable {
          tailf:info "Destination address is unreachable";
        }
        enum renum-command {
          tailf:info "Router renumbering command";
        }
        enum renum-result {
          tailf:info "Router renumbering result";
        }
        enum renum-seq-number {
          tailf:info "Router renumbering sequence number reset";
        }
      }
    }

    uses ip-access-list-option-grouping;
  }


  // ip access-list * /
  // ipv6 access-list * /
  grouping ip-access-list-common-grouping {
    // ip access-list * / fragments
    leaf fragments {
      tailf:info "Optimize fragments rule installation";
      type enumeration {
        enum "deny-all";
        enum "permit-all";
      }
    }

    // ip access-list * / statistics
    container statistics {
      tailf:info "Enable per-entry statistics for the ACL";
      leaf per-entry {
        tailf:info "Collect stats for each ACL entry";
        type empty;
      }
    }
  }

  // ip
  // vrf context * / ip
  grouping ip-grouping {

    // ip domain-list *
    // vrf context * / ip domain-list *
    list domain-list {
      tailf:info "Add additional domain names";
      tailf:cli-suppress-mode;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Enter a domain (Max Size 64)";
          length "1..64";
        }
      }
    }

    // ip domain-name
    leaf domain-name {
      tailf:info "Specify default domain name";
      type string {
        tailf:info "WORD;;Enter the default domain (Max Size 64)";
        length "1..64";

      }
    }

    // ip name-server *
    container name-server {
      tailf:cli-compact-syntax;
      leaf-list servers {
        tailf:info "Specify nameserver address";
        tailf:cli-drop-node-name;
        tailf:cli-flat-list-syntax;
        tailf:cli-disallow-value "use-vrf";
        tailf:cli-replace-all;
        tailf:cli-remove-before-change;
        ordered-by user;
        type union {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Enter an IPv4 address";
          }
          type inet:ipv6-address {
            tailf:info "A:B::C:D;;Enter an IPv6 address";
          }
        }
      }
    }

    container name-server-vrf {
      tailf:cli-drop-node-name;
      list name-server {
        tailf:info "Specify nameserver address";
        tailf:cli-suppress-mode;
        tailf:cli-compact-syntax;
        nx:prefix-key-leaf-list "use-vrf";
        tailf:cli-remove-before-change;
        key use-vrf;
        leaf use-vrf {
          tailf:info "Display per-VRF information";
          tailf:cli-expose-key-name;
          type string {
            tailf:info "WORD;;VRF name (Max Size 32)";
          }
        }
        leaf-list servers {
          tailf:info "Specify nameserver address";
          tailf:cli-drop-node-name;
          tailf:cli-flat-list-syntax;
          tailf:cli-disallow-value "use-vrf";
          tailf:cli-replace-all;
          ordered-by user;
          type union {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Enter an IPv4 address";
            }
            type inet:ipv6-address {
              tailf:info "A:B::C:D;;Enter an IPv6 address";
            }
          }
        }
      }
    }

    // ip route *
    container route {
      tailf:info "Route information";

      // ip route * static
      container static {
        tailf:info "Static route based configuration";
        tailf:cli-diff-dependency "/nx:feature/bfd";
        when "/nx:feature/bfd" {
          tailf:dependency "/nx:feature/bfd";
        }
        // ip route * static bfd
        container bfd {
          tailf:info "Enable bfd detection on static route";
          //  skip: ethernet      Ethernet IEEE 802.3z
          list port-channel {
            tailf:info "Port Channel interface";
            tailf:cli-suppress-mode;
            tailf:cli-incomplete-command;
            tailf:cli-allow-join-with-key {
              tailf:cli-display-joined;
            }
            key id;
            leaf id {
              type string {
                pattern "[0-9]+(\\.[0-9]+)?";
                tailf:info "<1-4096>[.<1-4096>];;Port Channel number [.Sub-interface number]";
              }
            }
            leaf-list next-hop {
              tailf:cli-drop-node-name;
              tailf:cli-list-syntax;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IP next-hop address in format i.i.i.i";
              }
            }
          }
          // ip route * static bfd Vlan *
          list Vlan {
            tailf:info "Vlan interface";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-diff-dependency "/nx:feature/interface-vlan";
            when "/nx:feature/interface-vlan" {
              tailf:dependency "/nx:feature/interface-vlan";
            }
            tailf:cli-incomplete-command;
            tailf:cli-allow-join-with-key {
              tailf:cli-display-joined;
            }
            key id;
            leaf id {
              tailf:info "<1-4094>;;Vlan interface number";
              type uint16 {
                range "1..4094";
              }
            }
            leaf-list next-hop {
              tailf:cli-drop-node-name;
              tailf:cli-list-syntax;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IP next-hop address in format i.i.i.i";
              }
            }
          }
          list Ethernet {
            tailf:info "Ethernet IEEE 802.3z";
            tailf:cli-allow-join-with-key {
              tailf:cli-display-joined;
            }
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key name;
            leaf name {
              type string {
                pattern "([0-9])+/([0-9])+(/([0-9])+)?(\\.[0-9]+)?";
                tailf:info "<1-66>/<1-128>;;Slot number/Port number";
              }
            }
            leaf-list next-hop {
              tailf:cli-drop-node-name;
              tailf:cli-list-syntax;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IP next-hop address in format i.i.i.i";
              }
            }
          }
        }
      }

      list ip-route-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        tailf:cli-diff-dependency "/nx:feature/interface-vlan";
        key "prefix-mask next-hop";
        leaf prefix-mask {
          type tailf:ipv4-address-and-prefix-length {
            tailf:info "A.B.C.D/LEN;;IP prefix and network mask length "
              +"in format x.x.x.x/m";
          }
        }
        leaf next-hop {
          type union {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP next-hop address in format i.i.i.i";
            }
            type tailf:ipv4-address-and-prefix-length {
              tailf:info "A.B.C.D/LEN  IP next-hop prefix in format i.i.i.i/m";
            }
            type enumeration {
              enum Null0 {
                tailf:info "Null interface";
              }
            }
            type string {
              tailf:info "Vlan interface";
              pattern "[Vv]lan[0-9]+";
            }
          }
        }
        uses ip-route-options-grouping;
      }
      list ip-route-interface-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        tailf:cli-remove-before-change;
        tailf:cli-diff-dependency "/nx:feature/interface-vlan";
        key "prefix-mask interface next-hop";
        leaf prefix-mask {
          type tailf:ipv4-address-and-prefix-length {
            tailf:info "A.B.C.D/LEN;;IP prefix and network mask length "
              +"in format x.x.x.x/m";
          }
        }
        leaf interface {
          nx:case-insensitive-type;
          type string {
            tailf:info "WORD;;Interface name";
            pattern "(([Ee]thernet)|([Pp]ort-channel)|([Vv]lan)|([Bb]di)|([Mm]gmt))[0-9/\\.]+";
          }
        }
        leaf next-hop {
          type union {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP next-hop address in format i.i.i.i";
            }
            type tailf:ipv4-address-and-prefix-length {
              tailf:info "A.B.C.D/LEN  IP next-hop prefix in format i.i.i.i/m";
            }
          }
        }
        uses ip-route-options-grouping;
      }
      list ip-route-vrf-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        tailf:cli-remove-before-change;
        tailf:cli-diff-dependency "/nx:feature/interface-vlan";
        key "prefix-mask next-hop vrf";
        leaf prefix-mask {
          type tailf:ipv4-address-and-prefix-length {
            tailf:info "A.B.C.D/LEN;;IP prefix and network mask length "
              +"in format x.x.x.x/m";
          }
        }
        leaf next-hop {
          type union {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP next-hop address in format i.i.i.i";
            }
            type tailf:ipv4-address-and-prefix-length {
              tailf:info "A.B.C.D/LEN  IP next-hop prefix in format i.i.i.i/m";
            }
            type enumeration {
              enum Null0 {
                tailf:info "Null interface";
              }
            }
            type string {
              tailf:info "Vlan interface";
              pattern "[Vv]lan[0-9]+";
            }
          }
        }
        leaf vrf {
          tailf:info "VRF for next-hop if different from this vrf";
          tailf:cli-expose-key-name;
          type string {
            tailf:info "WORD;;VRF name (Max Size 32)";
            length "1..32";
          }
        }
        uses ip-route-options-grouping;
      }
      list ip-route-interface-vrf-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        tailf:cli-remove-before-change;
        tailf:cli-diff-dependency "/nx:feature/interface-vlan";
        key "prefix-mask interface next-hop vrf";
        leaf prefix-mask {
          type tailf:ipv4-address-and-prefix-length {
            tailf:info "A.B.C.D/LEN;;IP prefix and network mask length "
              +"in format x.x.x.x/m";
          }
        }
        leaf interface {
          nx:case-insensitive-type;
          type string {
            tailf:info "WORD;;Interface name";
            pattern "(([Ee]thernet)|([Pp]ort-channel)|([Vv]lan)|([Bb]di)|([Mm]gmt))[0-9/\\.]+";
          }
        }
        leaf next-hop {
          type union {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP next-hop address in format i.i.i.i";
            }
            type tailf:ipv4-address-and-prefix-length {
              tailf:info "A.B.C.D/LEN  IP next-hop prefix in format i.i.i.i/m";
            }
          }
        }
        leaf vrf {
          tailf:info "VRF for next-hop if different from this vrf";
          tailf:cli-expose-key-name;
          type string {
            tailf:info "WORD;;VRF name (Max Size 32)";
            length "1..32";
          }
        }
        uses ip-route-options-grouping;
      }
    }

    // ip mroute *
    container mroute {
      tailf:info "Configure multicast RPF static route";
      list ip-mroute-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        key "prefix-mask next-hop";
        leaf prefix-mask {
          type tailf:ipv4-address-and-prefix-length {
            tailf:info "A.B.C.D/LEN;;IP prefix and network mask length "
              +"in format x.x.x.x/m";
          }
        }
        leaf next-hop {
          type union {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP next-hop address in format i.i.i.i";
            }
            type tailf:ipv4-address-and-prefix-length {
              tailf:info "A.B.C.D/LEN  IP next-hop prefix in format i.i.i.i/m";
            }
          }
        }
      }
    }

    // ip multicast
    container multicast {
      tailf:info "Configure IP multicast global parameters";
      container multipath {
        tailf:info "Configure ECMP multicast load splitting";
        tailf:cli-incomplete-no;
        choice hash-or-disable-choice {
          leaf legacy {
            tailf:info "Configure hash based on source and group";
            type empty;
          }
          container s-g-hash {
            tailf:info "Configure hash based on source and group address";
            leaf next-hop-based {
              tailf:info "Configure hash based on source, group, next-hop address";
              type empty;
            }
          }
          leaf none {
            tailf:info "Disable ECMP multicast load splitting";
            type empty;
          }
        }
        leaf nbm {
          tailf:info "Configure NBM controlled RPF interface";
          tailf:cli-diff-dependency "../resilient" {
            tailf:cli-trigger-on-set;
          }
          type empty;
        }
        leaf resilient {
          tailf:info "Configure resilient RPF interface";
          tailf:cli-diff-dependency "../nbm" {
            tailf:cli-trigger-on-set;
          }
          type empty;
        }
      }
      container multipath-enable {
        tailf:cli-drop-node-name;
        leaf multipath {
          tailf:info "Configure ECMP multicast load splitting";
          tailf:cli-full-command;
          type empty;
        }
      }
    }

    container icmp-errors {
      tailf:info "ICMP unreachable/TTL-exceeded/param-prob messages";
      leaf source-interface {
        tailf:info "Configure source-address for applications";
        tailf:cli-diff-dependency "/nx:feature/interface-vlan";
        nx:case-insensitive-type;
        type string;
      }
    }

    uses ip-pim-grouping;
  }

  grouping iface-choice-grouping {
    choice iface-choice {
      leaf Ethernet {
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:info "Ethernet IEEE 802.3z";
        type string {
        }
      }
      leaf loopback {
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:info "Loopback interface";
        tailf:non-strict-leafref {
          path "/nx:interface/loopback/name";
        }
        type uint16 {
          tailf:info "<0-1023>;;Virtual interface number";
        }
      }
      leaf port-channel {
        tailf:info "Port Channel interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/nx:interface/port-channel/name";
        }
        type string {
          tailf:info "<1-4096>;;Port Channel number";
        }
      }
    }
  }

  grouping rp-candidate-grouping {
    container rp-candidate {
      tailf:info "Configure router as a Rendezvous Point (RP) candidate";
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-compact-syntax;
      uses iface-choice-grouping;
      choice policy-choice {
        leaf group-list {
          tailf:info "Group range list";
          type tailf:ipv4-address-and-prefix-length {
            tailf:info "A.B.C.D/LEN;;Prefix of group range";
          }
        }
        leaf prefix-list {
          tailf:info "Prefix List policy for Candidate RP";
          type string {
            tailf:info "WORD;;Name of prefix-list (Max Size 63)";
          }
        }
        leaf route-map {
          tailf:info "Group range policy for Candidate RP";
          type string {
            tailf:info "WORD;;Route-map name (Max Size 63)";
          }
        }
      }
    }
    leaf rp-candidate-policy {
      tailf:info "Specify policy for filtering RP candidate messages";
      type string {
        tailf:info "WORD;;Route-map name (Max Size 63)";
      }
    }
  }

  grouping forward-listen-grouping {
    choice fwd-lstn-choice {
      leaf forward {
        tailf:info "Forward Auto-RP messages";
        tailf:cli-full-command;
        type empty;
      }
      leaf listen {
        tailf:info "Listen to Auto-RP messages";
        tailf:cli-full-command;
        type empty;
      }
      container forward-and-listen {
        tailf:cli-drop-node-name;
        tailf:cli-sequence-commands;
        tailf:cli-compact-syntax;
        leaf forward {
          tailf:info "Forward Auto-RP messages";
          tailf:cli-incomplete-command;
          type empty;
        }
        leaf listen {
          tailf:info "Listen to Auto-RP messages";
          type empty;
        }
      }
    }
  }

  grouping ip-pim-grouping {
    container pim {
      tailf:info "PIM global configuration commands";
      tailf:cli-diff-dependency "/nx:feature/pim";
      list anycast-rp {
        tailf:cli-suppress-mode;
        key "address rp";
        leaf address {
          tailf:info "A.B.C.D;;Address for the Anycast-RP address";
          type inet:ipv4-address;
        }
        leaf rp {
          tailf:info "A.B.C.D;;Address of RP in the Anycast-RP set";
          type inet:ipv4-address;
        }
      }
      // Seems not configurable on many devices
      // leaf auto-enable {
      //   tailf:info "Auto-enable configure on the vrf";
      //   tailf:cli-boolean-no;
      //   default true;
      //   type boolean;
      // }
      container auto-rp {
        tailf:info "Auto-RP protocol RP-distribution configuration";
        uses forward-listen-grouping;
        container mapping-agent {
          tailf:info "Configures router as an Auto-RP RP-mapping agent";
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-compact-syntax;
          uses iface-choice-grouping;
          leaf scope {
            tailf:info "Configure the scope of Auto-RP Discovery messages";
            default 32;
            type uint8 {
              tailf:info "<1-255>;;TTL value for scope";
            }
          }
        }
        leaf mapping-agent-policy {
          tailf:info "Specify policy for filtering Mapping Agent messages";
          type string {
            tailf:info "WORD;;Route-map name (Max Size 63)";
          }
        }
        uses rp-candidate-grouping;
      }

      leaf bidir-rp-limit {
        tailf:info "Configures maximum Bidir RPs for IPv4 PIM in this VRF";
        default 6;
        type uint8 {
          tailf:info "<0-8>;;Set limit for Bidir RPs permitted in IPv4 PIM";
        }
      }

      // ip pim bsr
      container bsr {
        tailf:info "Bootstrap protocol RP-distribution configuration";
        container bsr-candidate {
          tailf:info "Configure router as a Bootstrap Router candidate";
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-compact-syntax;
          uses iface-choice-grouping;
          leaf hash-len {
            tailf:info "Hash mask length used in Bootstrap messages";
            default 30;
            type uint8 {
              tailf:info "<0-32>;;Hash mask length value";
            }
          }
          leaf priority {
            tailf:info "BSR priority used in Bootstrap messages";
            default 64;
            type uint8 {
              tailf:info "<1-255>  BSR priority value";
            }
          }
          leaf interval {
            tailf:info "Bootstrap message transmission interval";
            default 60;
            type uint16 {
              tailf:info "<1-65535>;;Interval in seconds";
            }
          }
        }
        leaf bsr-policy {
          tailf:info "Specify policy for filtering BSR messages";
          type string {
            tailf:info "WORD;;Route-map name (Max Size 63)";
          }
        }
        uses forward-listen-grouping;
        uses rp-candidate-grouping;
      }

      container bsr-candidate {
        tailf:info "Configure router as a Bootstrap Router candidate";
      }
      // ip pim bfd
      leaf bfd {
        tailf:info "Enable / Disable BFD for all PIM interfaces in the VRF";
        tailf:cli-diff-dependency "/nx:feature/bfd";
        type empty;
      }

      leaf flush-routes {
        tailf:info "Remove routes when restarting PIM";
        type empty;
      }

      leaf log-neighbor-changes {
        tailf:info "Log up/down PIM neighbor transitions";
        type empty;
      }

      leaf pre-build-spt {
        tailf:info "Pre construct PIM trees for all known (S,G)s";
        type empty;
      }

      // ip pim register-policy
      choice register-policy-choice {
        leaf register-policy {
          tailf:info "Specify policy for receiving Register messages";
          tailf:cli-full-command;
          tailf:cli-full-no;
          type string {
            tailf:info "WORD;;A route-map name (Max Size 63)";
          }
        }
        container register-policy-prefix-list {
          tailf:cli-drop-node-name;
          container register-policy {
            tailf:info "Specify policy for receiving Register messages";
            tailf:cli-incomplete-command;
            tailf:cli-incomplete-no;
            leaf prefix-list {
              tailf:info "Prefix List policy for Registers";
              type string {
                tailf:info "WORD;;Prefix-list name (Max Size 63)";
              }
            }
          }
        }
      }

      // ip pim register-rate-limit
      leaf register-rate-limit {
        tailf:info "Rate limit for PIM data registers";
        type uint16 {
          tailf:info "<1-65535>;;Packets per second";
        }
      }

      // ip pim register-until-stop
      leaf register-until-stop {
        tailf:info "Send Data Registers till Register Stop is received";
        type empty;
      }

      // ip pim register-source
      leaf register-source {
        tailf:info "Configure source address for Register messages";
        type string {
          tailf:info "WORD;;Name of interface";
        }
      }

      // ip pim rp-address *
      list rp-address {
        tailf:info "Configure static RP for group range";
        key ip-address;
        tailf:cli-suppress-mode;
        tailf:cli-incomplete-command;
        tailf:cli-recursive-delete;
        tailf:cli-delete-when-empty;
        // ip pim rp-address * ip-address
        leaf ip-address {
          tailf:info "IP address of router which is RP for group range";
          type inet:ipv4-address {
            tailf:info "<inet:ipv4-address>;;IP address of router which is RP f"
              +"or group range";
          }
        }
        // ip pim rp-address * group-list *
        list group-list {
          tailf:info "Group range for static RP";
          key group-range-prefix;
          tailf:cli-suppress-mode;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-delete-when-empty;
          // ip pim rp-address * group-list * group-range-prefix
          leaf group-range-prefix {
            tailf:info "Group range prefix";
            type tailf:ipv4-address-and-prefix-length {
              tailf:info "<tailf:ipv4-address-and-prefix-length>;;Group range"
                +" prefix";
            }
          }
          // ip pim rp-address * group-list * bidir
          leaf bidir {
            tailf:info "Group range is treated in PIM bidirectional mode";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          // ip pim rp-address * group-list * override
          leaf override {
            tailf:info "RP address will override the dynamically learnt RPs";
            type empty;
          }
        }
        // ip pim rp-address * prefix-list *
        container prefix-list {
          tailf:info "Prefix List policy for static RP";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-diff-delete-before "../group-list";
          // ip pim rp-address * prefix-list * prefix-list-name
          leaf prefix-list-name {
            tailf:cli-drop-node-name;
            tailf:info "Prefix-list name (Max Size 63)";
            type string {
              tailf:info "<string>;;Prefix-list name (Max Size 63)";
              length "1..63";
            }
          }
          // ip pim rp-address * prefix-list * bidir
          leaf bidir {
            tailf:info "Group range is treated in PIM bidirectional mode";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          // ip pim rp-address * prefix-list * override
          leaf override {
            tailf:info "RP address will override the dynamically learnt RPs";
            type empty;
          }
        }
        // ip pim rp-address * route-map *
        container route-map {
          tailf:info "Route Map policy for static RP";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-diff-delete-before "../group-list";
          tailf:cli-diff-delete-before "../prefix-list";
          // ip pim rp-address * route-map * route-map-name
          leaf route-map-name {
            tailf:info "Route-map name (Max Size 63)";
            tailf:cli-drop-node-name;
            type string {
              tailf:info "<string>;;Route-map name (Max Size 63)";
              length "1..63";
            }
          }
          // ip pim rp-address * route-map * bidir
          leaf bidir {
            tailf:info "Group range is treated in PIM bidirectional mode";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          // ip pim rp-address * route-map * override
          leaf override {
            tailf:info "RP address will override the dynamically learnt RPs";
            type empty;
          }
        }
      }
      // Skip: 'ip pim rp-candidate'
      // Skip: 'ip pim send-rp-announce'
      // Skip: 'ip pim send-rp-discovery'
      // Skip: 'ip pim sg-expiry-timer'
      // Skip: 'ip pim sparse'
      // Skip: 'ip pim spt-threshold'
      // ip pim ssm
      container ssm {
        tailf:info "Source Specific Multicast (SSM) groups";
        // ip pim ssm
        choice ssm-choice {
          // ip pim ssm prefix-list
          leaf prefix-list {
            tailf:info "Group range prefix-list policy for SSM range";
            type string {
              tailf:info "<string>;;A prefix-list name (Max Size 63)";
              length "1..63";
            }
          }
          // ip pim ssm range
          container range {
            tailf:info "Configure explicit group ranges";
            // ip pim ssm range
            choice range-choice {
              // ip pim ssm range list-of-group
              leaf-list list-of-group {
                tailf:info "List of group range prefix";
                tailf:cli-drop-node-name;
                tailf:cli-flat-list-syntax;
                type tailf:ipv4-address-and-prefix-length {
                  tailf:info "<tailf:ipv4-address-and-prefix-length>;;List of"
                    +" group range prefix";
                }
              }
              // ip pim ssm range none
              leaf none {
                tailf:info "Remove all SSM group ranges";
                type empty;
              }
            }
          }
          // ip pim ssm route-map
          leaf route-map {
            tailf:info "Group range route-map policy for SSM range";
            type string {
              tailf:info "<string>;;A route-map name (Max Size 63)";
              length "1..63";
            }
          }
        }
      }

      // ip pim state-limit
      leaf state-limit {
        tailf:info "Configures State limit";
        type uint32 {
          tailf:info "<1-4294967295>;Maximum (*,G)/(S,G) entries allowed in this VRF";
        }
      }

      // Skip: 'ip pim strict-rfc-compliant'
      // Skip: 'ip pim use-shared-tree-only'
    }

  }

  grouping ipv6-grouping {

    // ipv6 route *
    container route {
      tailf:info "Configure IPv6 unicast static route";
      list ipv6-route-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        tailf:cli-remove-before-change;
        tailf:cli-diff-dependency "/nx:feature/interface-vlan";
        key "prefix-mask next-hop";
        leaf prefix-mask {
          type tailf:ipv6-address-and-prefix-length {
            tailf:info "A:B::C:D/LEN;;IPv6 prefix format: xxxx:xxxx/ml, xxxx:"
              +"xxxx::/ml, xxxx::xx/128";
          }
        }
        leaf interface {
          tailf:cli-optional-in-sequence;
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key {
            tailf:cli-before-key 2;
          }
          nx:case-insensitive-type;
          type string {
            tailf:info "WORD;;Interface name";
            pattern "(([Ee]thernet)|([Pp]ort-channel)|([Vv]lan)|([Bb]di)|([Mm]gmt))[0-9/\\.]+";
          }
        }
        leaf next-hop {
          type union {
            type inet:ipv6-address;
            type tailf:ipv6-address-and-prefix-length;
            type enumeration {
              enum Null0 {
                tailf:info "Null interface";
              }
            }
          }
        }
        uses ip-route-options-grouping;
      }
      list ipv6-route-vrf-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        tailf:cli-remove-before-change;
        tailf:cli-diff-delete-before "../ipv6-route-vrf-list";
        tailf:cli-diff-dependency "/nx:feature/interface-vlan";
        key "prefix-mask next-hop vrf";
        leaf prefix-mask {
          type tailf:ipv6-address-and-prefix-length {
            tailf:info "A:B::C:D/LEN;;IPv6 prefix format: xxxx:xxxx/ml, xxxx:"
              +"xxxx::/ml, xxxx::xx/128";
          }
        }
        leaf interface {
          tailf:cli-optional-in-sequence;
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key {
            tailf:cli-before-key 2;
          }
          nx:case-insensitive-type;
          type string {
            tailf:info "WORD;;Interface name";
            pattern "(([Ee]thernet)|([Pp]ort-channel)|([Vv]lan)|([Bb]di)|([Mm]gmt))[0-9/\\.]+";
          }
        }
        leaf next-hop {
          type union {
            type inet:ipv6-address;
            type tailf:ipv6-address-and-prefix-length;
            type enumeration {
              enum Null0 {
                tailf:info "Null interface";
              }
            }
          }
        }
        leaf vrf {
          tailf:info "VRF for next-hop if different from this vrf";
          tailf:cli-expose-key-name;
          type string {
            tailf:info "WORD;;VRF name (Max Size 32)";
            length "1..32";
          }
        }
        uses ip-route-options-grouping;
      }

      // ipv6 route * static
      container static {
        tailf:info "Static route based configuration";
        tailf:cli-diff-dependency "/nx:feature/bfd";
        when "/nx:feature/bfd" {
          tailf:dependency "/nx:feature/bfd";
        }
        container bfd {
          tailf:info "Enable bfd detection on static route";
          list Vlan {
            tailf:info "Vlan interface";
            tailf:cli-suppress-mode;
            tailf:cli-diff-dependency "/nx:feature/interface-vlan";
            when "/nx:feature/interface-vlan" {
              tailf:dependency "/nx:feature/interface-vlan";
            }
            tailf:cli-allow-join-with-key {
              tailf:cli-display-joined;
            }
            key "id next-hop";
            leaf id {
              tailf:info "<1-4094>;;Vlan interface number";
              type uint16 {
                range "1..4094";
              }
            }
            leaf next-hop {
              type inet:ipv6-address {
                tailf:info "A:B::C:D;;IPv6 next-hop address in format aaaa:bbbb:cccc:dddd:eeee:ffff:gggg:hhhh, aaaa::bbbb";
              }
            }
          }
          list Ethernet {
            tailf:info "Ethernet IEEE 802.3z";
            tailf:cli-suppress-mode;
            tailf:cli-allow-join-with-key {
              tailf:cli-display-joined;
            }
            key "name next-hop";
            leaf name {
              type string {
                pattern "([0-9])+/([0-9])+(/([0-9])+)?(\\.[0-9]+)?";
                tailf:info "<1-66>/<1-128>;;Slot number/Port number";
              }
            }
            leaf next-hop {
              type inet:ipv6-address {
                tailf:info "A:B::C:D;;IPv6 next-hop address in format aaaa:bbbb:cccc:dddd:eeee:ffff:gggg:hhhh, aaaa::bbbb";
              }
            }
          }
          list port-channel {
            tailf:info "Port Channel interface";
            tailf:cli-suppress-mode;
            tailf:cli-allow-join-with-key {
              tailf:cli-display-joined;
            }
            key "id next-hop";
            leaf id {
              type string {
                tailf:info "<1-4096>;;Port Channel number";
                pattern "[0-9]+(\\.[0-9]+)?";
              }
            }
            leaf next-hop {
              type inet:ipv6-address {
                tailf:info "A:B::C:D;;IPv6 next-hop address in format aaaa:bbbb:cccc:dddd:eeee:ffff:gggg:hhhh, aaaa::bbbb";
              }
            }
          }
        }
      }
    }

    container pim {
      tailf:info "PIM6 global configuration commands";
      tailf:cli-diff-delete-before "/nx:feature/pim6" {
        tailf:cli-when-target-delete;
      }
      tailf:cli-diff-set-after "/nx:feature/pim6" {
        tailf:cli-when-target-set;
      }
      container ssm {
        tailf:info "Source Specific Multicast (SSM) groups";
        choice rm-or-range {
          container range-none {
            tailf:cli-drop-node-name;
            container range {
              tailf:info "Configure explicit group ranges";
              leaf none {
                tailf:info "Remove all SSM group ranges";
                type empty;
              }
            }
          }
          leaf-list range {
            tailf:info "Configure explicit group ranges";
            tailf:cli-flat-list-syntax;
            tailf:cli-replace-all;
            tailf:cli-disallow-value "none";
            type inet:ipv6-prefix;
          }
          leaf route-map {
            tailf:info "Group range policy for SSM range";
            type string {
              tailf:info "WORD;;A route-map name (Max Size 63)";
            }
          }
        }
      }
    }
  }

  grouping line-access-class-grouping {
    list access-class {
      tailf:info "Specify access control for packets";
      tailf:cli-suppress-mode;
      key direction;
      leaf name {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        type string {
          tailf:info "WORD;;List name (Max Size 64)";
          length "1..64";
        }
      }
      leaf direction {
        type enumeration {
          enum in {
            tailf:info "Inbound packets";
          }
          enum out {
            tailf:info "Outbound packets";
          }
        }
      }
    }
  }

  // line vty
  // line console
  grouping line-grouping {

    // line vty * / exec-timeout
    leaf exec-timeout {
      tailf:info "Configure exec timeout";
      type uint32 {
        tailf:info "<0-525600>;;Enter timeout in minutes, 0 to disable";
        range "0..525600";
      }
    }

    uses line-access-class-grouping;

    container ipv6 {
      tailf:info "Configure IPv6 features";
      uses line-access-class-grouping;
    }

    container privilege {
      tailf:info "Change privilege level for line";
      leaf level {
        tailf:info "Assign default privilege level for line";
        type uint8 {
          tailf:info "<0-15>;;Default privilege level for line";
          range "0..15";
        }
      }
    }
  }

  // vdc *
  // vdc resource template *
  grouping vdc-grouping {

    // vdc * / limit-resource
    container limit-resource {
      tailf:info "Resource configuration";
      leaf-list module-type {
        tailf:info "Controls which type of modules are allowed in this vdc";
        tailf:cli-flat-list-syntax;
        type module-type;
      }
      container anycast_bundleid {
        tailf:info "Set anycast bundle id resource limits";
        tailf:cli-compact-syntax;
        leaf minimum {
          tailf:info "Minimum anycast bundle ids to allocate";
          type enumeration {
            enum "0" {
              tailf:info "<0-0>;;Only maximum is supported";
            }
          }
        }
        leaf maximum {
          tailf:info "Maximum anycast bundle ids to allocate";
          type uint16 {
            tailf:info "<0-64>;;Maximum anycast switch id value";
          }
        }
      }
      container vlan {
        tailf:cli-compact-syntax;
        leaf minimum {
          type uint16;
        }
        leaf maximum {
          type uint16;
        }
      }

      container monitor-session {
        tailf:cli-compact-syntax;
        leaf minimum {
          type uint16;
        }
        leaf maximum {
          type uint16;
        }
      }
      container monitor-rbs-filter {
        tailf:info "Rule Based SPAN Filters";
        tailf:cli-compact-syntax;
        leaf minimum {
          tailf:info "Minimum RBS filter to allocate";
          type uint16 {
            tailf:info "<0-16>;;Minimum RBS filter value";
            range "0..16";
          }
        }
        leaf maximum {
          tailf:info "Maximum RBS filter to allocate";
          type uint16 {
            tailf:info "<0-16>;;Maximum RBS filter value";
            range "0..16";
          }
        }
      }
      container monitor-rbs-product {
        tailf:info "Rule Based SPAN Products";
        tailf:cli-compact-syntax;
        leaf minimum {
          tailf:info "Minimum RBS product to allocate";
          type uint16 {
            tailf:info "<0-16>;;Minimum RBS product value";
            range "0..16";
          }
        }
        leaf maximum {
          tailf:info "Maximum RBS product to allocate";
          type uint16 {
            tailf:info "<0-16>;;Maximum RBS product value";
            range "0..16";
          }
        }
      }
      container monitor-session-erspan-dst {
        tailf:info "Monitor erspan destination session";
        tailf:cli-compact-syntax;
        leaf minimum {
          tailf:info "Minimum monitor erspan-dst session to allocate";
          type uint16 {
            tailf:info "<0-23>;;Minimum monitor erspan-dst session value";
            range "0..23";
          }
        }
        leaf maximum {
          tailf:info "Maximum monitor erspan-dst session to allocate";
          type uint16 {
            tailf:info "<0-23>;;Maximum monitor erspan-dst session value";
            range "0..23";
          }
        }
      }
      container monitor-session-extended {
        tailf:info "Monitor local/erspan-source session";
        tailf:cli-compact-syntax;
        leaf minimum {
          tailf:info "Minimum extended monitor session to allocate";
          type uint16 {
            tailf:info "<0-16>;;Minimum extended monitor session value";
            range "0..16";
          }
        }
        leaf maximum {
          tailf:info "Maximum extended monitor session to allocate";
          type uint16 {
            tailf:info "<0-16>;;Maximum extended monitor session value";
            range "0..16";
          }
        }
      }
      container monitor-session-inband-src {
        tailf:info "Monitor inband source";
        tailf:cli-compact-syntax;
        leaf minimum {
          tailf:info "Minimum monitor inband source to allocate";
          type uint16 {
            tailf:info "<0-1>;;Minimum monitor inband source value";
            range "0..1";
          }
        }
        leaf maximum {
          tailf:info "Maximum monitor inband source to allocate";
          type uint16 {
            tailf:info "<0-1>;;Maximum monitor inband source value";
            range "0..1";
          }
        }
      }
      container monitor-session-mx-exception-src {
        tailf:info "Monitor Mx module exception source";
        tailf:cli-compact-syntax;
        leaf minimum {
          tailf:info "Minimum monitor exception source to allocate";
          type uint16 {
            tailf:info "<0-1>;;Minimum monitor exception source value";
            range "0..1";
          }
        }
        leaf maximum {
          tailf:info "Maximum monitor exception source to allocate";
          type uint16 {
            tailf:info "<0-1>;;Maximum monitor exception source value";
            range "0..1";
          }
        }
      }
      container vrf {
        tailf:cli-compact-syntax;
        leaf minimum {
          type uint16;
        }
        leaf maximum {
          type uint16;
        }
      }
      container vrf-session {
        tailf:cli-compact-syntax;
        leaf minimum {
          type uint16;
        }
        leaf maximum {
          type uint16;
        }
      }
      container port-channel {
        tailf:cli-compact-syntax;
        leaf minimum {
          type uint16;
        }
        leaf maximum {
          type uint16;
        }
      }
      container u4route-mem {
        tailf:cli-compact-syntax;
        leaf minimum {
          type uint16;
        }
        leaf maximum {
          type uint16;
        }
      }
      container u6route-mem {
        tailf:cli-compact-syntax;
        leaf minimum {
          type uint16;
        }
        leaf maximum {
          type uint16;
        }
      }
      container m4route-mem {
        tailf:cli-compact-syntax;
        leaf minimum {
          type uint16;
        }
        leaf maximum {
          type uint16;
        }
      }
      container m6route-mem {
        tailf:cli-compact-syntax;
        leaf minimum {
          type uint16;
        }
        leaf maximum {
          type uint16;
        }
      }
      container vni_bd {
        tailf:cli-compact-syntax;
        leaf minimum {
          type uint16;
        }
        leaf maximum {
          type uint16;
        }
      }
    }
  }

  grouping aaa-group-local-grouping {
    leaf group {
      tailf:info "Specify server groups to redirect the accounting logs";
      tailf:cli-full-command;
      type string {
        length "1..127";
      }
    }

    leaf local {
      tailf:info "Use local accounting";
      tailf:cli-full-command;
      tailf:cli-boolean-no;
      default "true";
      type boolean;
    }
  }

  // interface ethernet * /
  // interface mgmt * /
  grouping interface-eth-and-mgmt-grouping {
    container lldp {
      tailf:info "Configure Interface LLDP parameters";
      tailf:cli-diff-dependency "/nx:feature/lldp";

      // interface * / no lldp transmit
      leaf transmit {
        tailf:info "Enable LLDP transmission on interface";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // interface * / no lldp receive
      leaf receive {
        tailf:info "Enable LLDP reception on interface";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      container tlv-set {
        tailf:info "LLDP TLV configuration for interface";
        leaf management-address {
          tailf:info "Management address to be sent in management-tlv of LLDPDU.";
          type union {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP address in dotted decimal format i.i.i.i";
            }
            type inet:ipv6-address {
              tailf:info "A:B::C:D;;IPv6 address";
            }
          }
        }
        choice vlan-or-id {
          leaf vlan {
            tailf:info "VLAN-id whose SVI IP address should be used as management"
              +"adrress in management-tlv of LLDPDU. Default is native VLAN.";
            type empty;
          }
          container vlan-id {
            tailf:cli-incomplete-command;
            tailf:cli-drop-node-name;
            leaf vlan {
              tailf:info "VLAN-id whose SVI IP address should be used as management"
                +"adrress in management-tlv of LLDPDU. Default is native VLAN.";
              type uint16 {
                tailf:info "<1-4094>;;Vlan-id within range of 1-4094";
                range "1..4094";
              }
            }
          }
        }
      }
    }
    // interface * / cdp
    container cdp {
      tailf:info "Configure CDP interface parameters";
      leaf enable {
        tailf:info "Enable/disable CDP on the interface";
        type boolean;
        default true;
        tailf:cli-boolean-no;
      }
    }
    uses interface-l2port-common-grouping;
  }

  // class-map type control-plane * match exception ip
  // class-map type control-plane * match exception ipv6
  grouping class-map-match-exception-ip-grouping {
    container icmp {
      tailf:info "ICMP packets";
      leaf redirect {
        tailf:info "Send redirected packets back to sender";
        type empty;
      }
      leaf unreachable {
        tailf:info "Send unreachable packets back to sender";
        type empty;
      }
    }
    container multicast {
      tailf:info "Multicast traffic";
      leaf directly-connected-sources {
        tailf:info "Directly connected sources";
        type empty;
      }
      leaf rpf-failure {
        tailf:info "Failure in RPF check";
        type empty;
      }
    }
    leaf municast {
      tailf:info "IP/IPv6 unicast packets with multicast MAC";
      type empty;
    }
    leaf option {
      tailf:info "Match IP/IPv6 option packets";
      type empty;
    }
    container unicast {
      tailf:info "Unicast traffic";
      leaf rpf-failure {
        tailf:info "Unicast packets failed in RPF check";
        type empty;
      }
    }
  }

  grouping feature-set-grouping {
    leaf fabric {
      tailf:info "FABRIC";
      type empty;
    }
    leaf fabricpath {
      tailf:info "FABRICPATH";
      type empty;
    }
    leaf fcoe {
      tailf:info "FCOE";
      type empty;
    }
    leaf fex {
      tailf:info "FEX";
      type empty;
    }
    leaf mpls {
      tailf:info "MPLS";
      type empty;
    }
    leaf virtualization {
      tailf:info "VIRTUALIZATION";
      type empty;
    }
  }

  grouping vlan-bd-config-grouping {
    container ip {
      tailf:info "Configure IP features";
      container igmp {
        tailf:info "IGMP configuration commands";
        container snooping-disable {
          tailf:cli-drop-node-name;
          leaf snooping {
            tailf:info "Configures IGMP Snooping";
            tailf:cli-full-command;
            tailf:cli-boolean-no;
            default true;
            type boolean;
          }
        }
        container snooping {
          tailf:info "Configures IGMP Snooping";
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          list access-group {
            tailf:info "IGMP access-group";
            tailf:cli-suppress-mode;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            tailf:cli-delete-when-empty;
            key interface;
            leaf interface {
              tailf:cli-expose-key-name;
              nx:case-insensitive-type;
              type string {
                tailf:info "<name>;;Specify interface for filtering (Ethernet or port-channel)";
                pattern "(([Ee]thernet)|([Pp]ort-channel))[0-9/\\.]+";
              }
            }
            choice prefix-key-choice {
              leaf prefix-list {
                tailf:info "IPv4 Prefix-List Policy";
                tailf:cli-prefix-key;
                type string {
                  tailf:info "WORD;;Policy Name Name (Max Size 63)";
                  length "1..63";
                }
              }
              leaf route-map {
                tailf:info "Route-Map Policy";
                tailf:cli-prefix-key;
                type string {
                  tailf:info "WORD;;Policy Name Name (Max Size 63)";
                  length "1..63";
                }
              }
            }
          }
          container access-group-leaf {
            tailf:cli-drop-node-name;
            leaf access-group {
              tailf:info "Configures filter policy for groups mentioned in route-map";
              tailf:alt-name "access-group";
              tailf:cli-full-command;
              type string {
                tailf:info "WORD;;Route-map name (Max Size 63)";
              }
            }
          }
          leaf explicit-tracking {
            tailf:info "Configures Explicit Host tracking for "
              +"vlan";
            tailf:cli-full-command;
            tailf:cli-boolean-no;
            default true;
            type boolean;
          }
          leaf fast-leave {
            tailf:info "Configures Fast leave for the vlan";
            tailf:cli-full-command;
            type empty;
          }
          leaf last-member-query-interval {
            tailf:info "Configures interval between group-"
              +"specific Query transmissions";
            tailf:cli-full-command;
            type uint8 {
              range "1..25";
              tailf:info "<1-25>  Interval in seconds "
                +"(Default value is 1)";
            }
            default "1";
          }
          leaf link-local-groups-suppression {
            tailf:info "Configures Vlan link-local groups "
              +"suppression";
            tailf:cli-full-command;
            tailf:cli-boolean-no;
            default true;
            type boolean;
          }
          container mrouter {
            tailf:info "Configures static multicast router "
              +"interface";
            container "interface" {
              tailf:info "Specify interface for "
                +"static-mrouter";
              list Ethernet {
                tailf:info "Ethernet IEEE 802.3z";
                tailf:cli-allow-join-with-key {
                  tailf:cli-display-joined;
                }
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                key name;
                leaf name {
                  type string {
                    pattern "([0-9])+/([0-9])+(/([0-9])+)?(\\.[0-9]+)?";
                    tailf:info "<1-66>/<1-128>;;Slot number/Port number";
                  }
                }
              }
              list port-channel {
                tailf:info "Port Channel interface";
                tailf:cli-allow-join-with-key {
                  tailf:cli-display-joined;
                }
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                key name;
                leaf name {
                  tailf:cli-diff-dependency "/nx:interface/port-channel" {
                    tailf:cli-trigger-on-set;
                  }
                  type string {
                    tailf:info "<1-4096>;;Port Channel number";
                    pattern "[0-9]+(\\.[0-9]+)?";
                  }
                }
              }
            }
          }
          list static-group {
            tailf:info "Configures static group membership";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key group;
            leaf group {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Group IP Address";
              }
            }
            container "interface" {
              tailf:info "Specify interface for "
                +"static-mrouter";
              list Ethernet {
                tailf:info "Ethernet IEEE 802.3z";
                tailf:cli-allow-join-with-key {
                  tailf:cli-display-joined;
                }
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                key name;
                leaf name {
                  type string {
                    pattern "([0-9])+/([0-9])+(/([0-9])+)?(\\.[0-9]+)?";
                    tailf:info "<1-66>/<1-128>;;Slot number/Port number";
                  }
                }
              }
              list port-channel {
                tailf:info "Port Channel interface";
                tailf:cli-allow-join-with-key {
                  tailf:cli-display-joined;
                }
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                key name;
                leaf name {
                  tailf:non-strict-leafref {
                    path "/nx:interface/port-channel/name";
                  }
                  type string {
                    tailf:info "<1-4096>;;Port Channel number";
                    pattern "[0-9]+(\\.[0-9]+)?";
                  }
                }
              }
            }
          }
          // Note spelling in the below two: optimised vs optimise
          choice spelling-choice {
            default optimise-multicast-flood;
            leaf optimise-multicast-flood {
              tailf:info "Configures Optimised Multicast Flood (OMF) on the VLAN";
              tailf:cli-boolean-no;
              default true;
              type boolean;
            }
            leaf optimised-multicast-flood {
              tailf:info "Configures Optimised Multicast Flood (OMF) on the VLAN";
              tailf:cli-boolean-no;
              default true;
              type boolean;
            }
          }
          container proxy {
            tailf:info "Configures IGMP snooping proxy";
            container general-queries {
              tailf:info "Configures proxy for general-queries";
              leaf mrt {
                tailf:info "Configure max-response-time for the switch's proxy general-queries";
                default 5;
                type uint8 {
                  tailf:info "<1-25>;;MRT in seconds";
                }
              }
            }
          }
          container proxy-leave {
            tailf:info "Proxy Leave";
            leaf use-group-address {
              tailf:info "Use group address for proxy leave";
              type empty;
            }
          }
          // vlan configuration * / ip igmp snooping querier
          leaf querier {
            tailf:info "Enables snooping querier";
            type inet:ipv4-address;
          }
          leaf querier-timeout {
            tailf:info "Configures querier timeout for IGMPv2";
            default 255;
            type uint16 {
              tailf:info "<1-65535>;;Time in seconds";
            }
          }
          leaf query-interval {
            tailf:info "Configures interval between query transmission";
            default 125;
            type uint16 {
              tailf:info "<1-18000>;;Interval in seconds";
            }
          }
          leaf query-max-response-time {
            tailf:info "Configures MRT for query messages";
            default 10;
            type uint8 {
              tailf:info "<1-25>;;Time in seconds";
            }
          }
          container report-flood {
            tailf:info "Configures Report flooding on a VLAN";
            leaf all {
              tailf:info "Flood on ALL active ports of VLAN";
              type empty;
            }
            list interface {
              tailf:info "Specify interface for report flooding";
              tailf:cli-suppress-mode;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              tailf:cli-delete-when-empty;
              key name;
              leaf name {
                nx:case-insensitive-type;
                type string {
                  tailf:info "<name>;;Specify interface for report flooding (Ethernet or port-channel)";
                  pattern "(([Ee]thernet)|([Pp]ort-channel))[0-9/\\.]+";
                }
              }
            }
          }
          list report-policy {
            tailf:info "IGMP Report Policy";
            tailf:cli-suppress-mode;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            tailf:cli-delete-when-empty;
            key interface;
            leaf interface {
              tailf:cli-expose-key-name;
              nx:case-insensitive-type;
              type string {
                tailf:info "<name>;;Specify interface for filtering (Ethernet or port-channel)";
                pattern "(([Ee]thernet)|([Pp]ort-channel))[0-9/\\.]+";
              }
            }
            choice prefix-key-choice {
              leaf prefix-list {
                tailf:info "IPv4 Prefix-List Policy";
                tailf:cli-prefix-key;
                type string {
                  tailf:info "WORD;;Policy Name Name (Max Size 63)";
                  length "1..63";
                }
              }
              leaf route-map {
                tailf:info "Route-Map Policy";
                tailf:cli-prefix-key;
                type string {
                  tailf:info "WORD;;Policy Name Name (Max Size 63)";
                  length "1..63";
                }
              }
            }
          }
          leaf report-suppression {
            tailf:info "Configures IGMPv1/IGMPv2 Report Suppression for the VLAN/BD";
            tailf:cli-boolean-no;
            default true;
            type boolean;
          }
          leaf robustness-variable {
            tailf:info "Configures RFC defined Robustness Variable";
            default 2;
            type uint8 {
              tailf:info "<1-7>;;Count value";
            }
          }
          leaf startup-query-count {
            tailf:info "Configures number of queries sent at startup";
            type uint8 {
              tailf:info "<1-10>;;Count value";
            }
          }
          leaf startup-query-interval {
            tailf:info "Configures query interval at startup";
            type uint16 {
              tailf:info "<1-18000>;;Interval in seconds";
            }
          }
          leaf group-timeout {
            tailf:info "Configures group membership timeout in VLAN/BD";
            type union {
              type uint16 {
                tailf:info "<1-10080>;;Timeout in minutes";
              }
              type enumeration {
                enum "never" {
                  tailf:info "Never expire ports from group membership";
                }
              }
            }
          }
          leaf v3-report-suppression {
            tailf:info "Configures IGMPv3 Report Suppression and Proxy Reporting for the VLAN/BD";
            type empty;
          }
          leaf version {
            tailf:info "Configures IGMP version number for VLAN/BD";
            nx:trim-default-in-show;
            default 3;
            type uint8 {
              tailf:info "<2-3>;Version number value";
            }
          }
        }
      }
    }

    // vlan * / service-policy
    container service-policy {
      tailf:info "Configure service policy for an interface";
      // interface * / service-policy type
      container type {
        tailf:info "Specify the type of this policy";
        // interface * / service-policy type qos
        container qos {
          tailf:info "Qos policy";
          // interface * / service-policy type qos input
          container input {
            tailf:info "Input Service Policy";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf name {
              tailf:cli-drop-node-name;
              tailf:cli-reset-container;
              tailf:non-strict-leafref {
                path "/nx:policy-map/type/qos/name";
              }
              type policy-map-name-type;
            }
            leaf no-stats {
              tailf:info "Disable statistics for this policy";
              type empty;
            }
          }
          // interface * / service-policy type qos output
          container output {
            tailf:info "Output Service Policy";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf name {
              tailf:cli-drop-node-name;
              tailf:cli-reset-container;
              tailf:non-strict-leafref {
                path "/nx:policy-map/type/qos/name";
              }
              type policy-map-name-type;
            }
            leaf no-stats {
              tailf:info "Disable statistics for this policy";
              type empty;
            }
          }
        }
      }
    }

  }

  grouping isis-spf-interval-grouping {
    leaf max-wait {
      tailf:cli-drop-node-name;
      tailf:cli-reset-container;
      type uint32 {
        tailf:info "<50-120000>;;Maximum wait between trigger and SPF com"
          +"putation (milli-secs)";
        range "50..120000";
      }
    }
    leaf init-wait {
      tailf:cli-drop-node-name;
      type uint32 {
        tailf:info "<50-120000>;;Initial wait between trigger and SPF com"
          +"putation (milli-secs)";
        range "50..120000";
      }
    }
    leaf second-wait {
      tailf:cli-drop-node-name;
      type uint32 {
        tailf:info "<50-120000>;;Second wait between trigger and SPF comp"
          +"utation (milli-secs)";
        range "50..120000";
      }
    }
  }

  grouping isis-lsp-gen-interval-grouping {
    leaf max-wait {
      tailf:cli-drop-node-name;
      tailf:cli-reset-container;
      type uint32 {
        tailf:info "<50-120000>;;Maximum wait between trigger and LSP gen"
          +"eration (milli-secs)";
        range "50..120000";
      }
    }
    leaf init-wait {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type uint32 {
        tailf:info "<50-120000>;;Initial wait between trigger and LSP gen"
          +"eration (milli-secs)";
        range "50..120000";
      }
    }
    leaf second-wait {
      tailf:cli-drop-node-name;
      type uint32 {
        tailf:info "<50-120000>;;Second wait used in LSP generation (mill"
          +"i-secs) during backoff";
        range "50..120000";
      }
    }
  }

  grouping eigrp-interface-config-list-grouping {
    list eigrp {
      tailf:info "EIGRP interface configuration commands";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-diff-dependency "/nx:feature/eigrp";
      key id;
      leaf id {
        tailf:info "WORD;;Process tag (Max Size 20)";
        tailf:non-strict-leafref {
          path "/nx:router/eigrp/id";
        }
        type string {
          length "1..20";
        }
      }
    }
  }

  grouping eigrp-route-or-prefix-list-grouping {
    list eigrp {
      tailf:info "EIGRP interface configuration commands";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-diff-dependency "/nx:feature/eigrp";
      key "id direction";
      leaf id {
        tailf:info "WORD;;Process tag (Max Size 20)";
        tailf:non-strict-leafref {
          path "/nx:router/eigrp/id";
        }
        type string {
          length "1..20";
        }
      }
      choice route-or-prefix-choice {
        leaf prefix-list {
          tailf:info "Use a prefix-list";
          tailf:cli-prefix-key {
            tailf:cli-before-key 2;
          }
          type string {
            tailf:info "WORD;;Reference to prefix-list name";
          }
        }
        leaf route-map {
          tailf:info "Use a route-map";
          tailf:cli-prefix-key {
            tailf:cli-before-key 2;
          }
          tailf:non-strict-leafref {
            path "/nx:route-map/name";
          }
          type string {
            tailf:info "WORD;;Route-map name (Max Size 63)";
          }
        }
      }
      leaf direction {
        type enumeration {
          enum "in" {
            tailf:info "Filter incoming routing updates";
          }
          enum "out" {
            tailf:info "Filter outgoing routing updates";
          }
        }
      }
    }
  }

  grouping lifetime-grouping {
    leaf local {
      tailf:info "Specify time in local timezone";
      tailf:cli-optional-in-sequence;
      tailf:cli-incomplete-command;
      type empty;
    }
    leaf start-time {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type string {
        tailf:info "WORD;;HH:MM:SS Time to start <0-23>:<0-59>:<0-59> (Max Size 8)";
        pattern "[0-9]+:[0-9]+:[0-9]+";
      }
    }
    leaf start-month {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type short-month-type;
    }
    leaf start-day {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type uint8 {
        tailf:info "<1-31>;Day of the month to start";
        range "1..31";
      }
    }
    leaf start-year {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type uint16 {
        tailf:info "<1993-2035>;;Year to start";
        range "1993..2035";
      }
    }
    choice lifetime-choice {
      case end-explicit-time {
        leaf end-time {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type string {
            tailf:info "WORD;;HH:MM:SS Time to end <0-23>:<0-59>:<0-59> (Max Size 8)";
            pattern "[0-9]+:[0-9]+:[0-9]+";
          }
        }
        leaf end-month {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type short-month-type;
        }
        leaf end-day {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<1-31>;Day of the month to end";
            range "1..31";
          }
        }
        leaf end-year {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1993-2035>;;Year to end";
            range "1993..2035";
          }
        }
      }
      leaf duration {
        tailf:info "Set key lifetime duration";
        type uint32 {
          tailf:info "<1-2147483646>;;Duration in seconds";
        }
      }
      leaf infinite {
        tailf:info "Never Expires";
        type empty;
      }
    }
  }

  grouping queue-limit-grouping {
    choice limit-choice {
      case count {
        leaf count {
          tailf:cli-incomplete-command;
          tailf:cli-drop-node-name;
          must "../unit";
          type uint32 {
            tailf:info "<1-83886080>;;Queue size in packets/bytes/kbytes/mbytes/ms/us";
            range "1..83886080";
          }
        }
        // must be set if the count is set
        leaf unit {
          tailf:cli-drop-node-name;
          type enumeration {
            enum bytes {
              tailf:info "Bytes";
            }
            enum kbytes {
              tailf:info "Kilo bytes";
            }
            enum mbytes {
              tailf:info "Mega bytes";
            }
            enum ms {
              tailf:info "Milli second(s)";
            }
            enum packets {
              tailf:info "Packets";
            }
            enum us {
              tailf:info "Micro second(s)";
            }
          }
        }
      }
      case percent {
        leaf percent {
          tailf:info "Specify queue size in Percentage";
          type uint8 {
            tailf:info "<1-100>;;Queue size in percentage of total tx/rx buffer size";
            range "1..100";
          }
        }
      }
    }
  }

  grouping random-detect-grouping {
    container minimum-threshold {
      tailf:info "Specify minimum threshold for WRED";
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-compact-syntax;
      tailf:cli-incomplete-command;
      tailf:cli-flatten-container;
      choice threshold-choice {
        case count {
          leaf count {
            tailf:cli-incomplete-command;
            tailf:cli-drop-node-name;
            must "../unit";
            type uint32 {
              tailf:info "<1-52428800>;;Minimum threshold value";
            }
          }
          // must be set if the count is set
          leaf unit {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type enumeration {
              enum bytes {
                tailf:info "Bytes";
              }
              enum kbytes {
                tailf:info "Kilo bytes";
              }
              enum mbytes {
                tailf:info "Mega bytes";
              }
            }
          }
        }
        leaf percent {
          tailf:info "Specify thresholds in percent";
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<1-100>;;Minimum threshold percent of queue size";
          }
        }
      }
    }
    container maximum-threshold {
      tailf:info "Specify maximum threshold for WRED";
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-compact-syntax;
      tailf:cli-incomplete-command;
      tailf:cli-flatten-container;
      choice threshold-choice {
        case count {
          leaf count {
            tailf:cli-incomplete-command;
            tailf:cli-drop-node-name;
            must "../unit";
            type uint32 {
              tailf:info "<1-52428800>;;Maximum threshold value";
            }
          }
          // must be set if the count is set
          leaf unit {
            tailf:cli-drop-node-name;
            type enumeration {
              enum bytes {
                tailf:info "Bytes";
              }
              enum kbytes {
                tailf:info "Kilo bytes";
              }
              enum mbytes {
                tailf:info "Mega bytes";
              }
            }
          }
        }
        leaf percent {
          tailf:info "Specify thresholds in percent";
          type uint8 {
            tailf:info "<1-100>;;Maximum threshold percent of queue size";
          }
        }
      }
    }
  }

  grouping itu-t-grouping {
    leaf ql {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type enumeration {
        enum exact { tailf:info " Specifies the exact QL to send"; }
        enum highest { tailf:info "Specifies an upper limit on the QL to be sent"; }
        enum lowest { tailf:info "Specifies a lower limit on the QL to be sent"; }
      }
    }
    container itu-t {
      tailf:info "ITU-T options";
      tailf:cli-flatten-container;
      leaf option {
        tailf:info "ITU-T options";
        tailf:cli-incomplete-command;
        type enumeration {
          enum 1 {
            tailf:info "ITU-T QL option 1";
          }
          enum 2 {
            tailf:info "ITU-T QL option 2";
          }
        }
      }
    }
    leaf option1-value {
      tailf:cli-drop-node-name;
      when "../itu-t/option = '1'" {
        tailf:dependency "../itu-t/option";
      }
      nx:enum-alias "DNU" {
        cli:arguments "DNU/DUS";
      }
      type enumeration {
        enum DNU { tailf:info "This signal should not be used for synchronization"; }
        enum EEC1 { tailf:info "ITU-T Option 1: Ethernet equipment clock"; }
        enum PRC { tailf:info " ITU-T Option 1: Primary reference clock"; }
        enum PRTC { tailf:info "ITU-T Option 1: Primary reference timing clock"; }
        enum SEC { tailf:info " ITU-T Option 1: SONET equipment clock"; }
        enum SSU-A { tailf:info " ITU-T Option 1: Type I or V slave clock"; }
        enum SSU-B { tailf:info " ITU-T Option 1: Type IV slave clock"; }
        enum eEEC { tailf:info "ITU-T Option 1: Enhanced ethernet equipment clock"; }
        enum ePRTC { tailf:info "TU-T Option 1: Enhanced primary reference timing clock"; }
      }
    }
    leaf generation {
      tailf:info "ITU-T QL option 2 generation";
      tailf:cli-incomplete-command;
      when "../itu-t/option = '2'" {
        tailf:dependency "../itu-t/option";
      }
      type enumeration {
        enum 1 { tailf:info "ITU-T QL option 2 generation 1"; }
        enum 2 { tailf:info "ITU-T QL option 2 generation 2"; }
      }
    }
    leaf option2-value {
      tailf:cli-drop-node-name;
      when "../itu-t/option = '2'" {
        tailf:dependency "../itu-t/option";
      }
      nx:enum-alias "DUS" {
        cli:arguments "DNU/DUS";
      }
      type itu-t-option2-type;
    }
    leaf highest {
      tailf:info "Specifies an upper limit on the QL to be sent";
      when "../ql = 'lowest'" {
        tailf:dependency "../ql";
      }
      nx:enum-alias "DUS" {
        cli:arguments "DNU/DUS";
      }
      type itu-t-option2-type;
    }
  }

  grouping tcam-region-grouping {
    container region {
      tailf:info "Configure tcam region";
      container arp-ether-with-double-wide {
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf arp-ether {
          tailf:info "Ingress ARP / L2 Ethertype table size";
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          type tcam-size-type;
        }
        leaf double-wide {
          type empty;
        }
      }
      leaf arp-ether {
        tailf:info "Ingress ARP / L2 Ethertype table size";
        tailf:cli-full-command;
        type tcam-size-type;
      }
      leaf copp {
        tailf:info "Ingress COPP size";
        type tcam-size-type;
      }
      leaf e-qos {
        tailf:info "Egress IPV4 QoS size";
        type tcam-size-type;
      }
      leaf e-racl {
        tailf:info "Egress IPV4 RACL size";
        type tcam-size-type;
      }
      leaf ipv6-racl {
        tailf:info "IPV6 RACL size";
        type tcam-size-type;
      }
      leaf l3qos {
        tailf:info "IPV4 L3 QoS size";
        type tcam-size-type;
      }
      leaf qos {
        tailf:info "IPV4 Port QoS size";
        type tcam-size-type;
      }
      leaf racl {
        tailf:info "IPV4 RACL size";
        type tcam-size-type;
      }
      leaf span {
        tailf:info "SPAN size";
        type tcam-size-type;
      }
      leaf vpc-convergence {
        tailf:info "Vpc convergence size";
        type tcam-size-type;
      }
      leaf ipv6-l3qos {
        tailf:info "IPV6 L3 QoS size";
        type tcam-size-type;
      }
      leaf e-ipv6-qos {
        tailf:info "Egress IPV6 QoS size";
        type tcam-size-type;
      }
      leaf e-ipv6-racl {
        tailf:info "Egress IPV6 RACL size";
        type tcam-size-type;
      }
      leaf e-mac-qos {
        tailf:info "Egress MAC QoS size";
        type tcam-size-type;
      }
      leaf e-qos-lite {
        tailf:info "Egress IPV4 QoS (Lite) size";
        type tcam-size-type;
      }
      leaf fcoe-egress {
        tailf:info "Egress FCoE Counters size";
        type tcam-size-type;
      }
      leaf fcoe-ingress {
        tailf:info "Ingress FCoE Counters size";
        type tcam-size-type;
      }
      leaf fex-ifacl {
        tailf:info "FEX IPV4 PACL size";
        type tcam-size-type;
      }
      leaf fex-ipv6-ifacl {
        tailf:info "FEX IPV6 PACL size";
        type tcam-size-type;
      }
      leaf fex-ipv6-qos {
        tailf:info "FEX IPV6 Port QoS size";
        type tcam-size-type;
      }
      leaf fex-mac-ifacl {
        tailf:info "FEX MAC PACL size";
        type tcam-size-type;
      }
      leaf fex-mac-qos {
        tailf:info "FEX MAC Port QoS size";
        type tcam-size-type;
      }
      leaf fex-qos {
        tailf:info "FEX IPV4 Port QoS size";
        type tcam-size-type;
      }
      leaf fex-qos-lite {
        tailf:info "FEX IPV4 Port QoS (Lite) size";
        type tcam-size-type;
      }
      leaf flow {
        tailf:info "Ingress Flow Counters size";
        type tcam-size-type;
      }
      leaf ifacl {
        tailf:info "IPV4 PACL size";
        type tcam-size-type;
      }
      leaf ipsg {
        tailf:info "IPSG SMAC-IP bind table size";
        tailf:cli-diff-delete-before "../racl" {
          tailf:cli-when-target-delete;
        }
        type tcam-size-type;
      }
      leaf ipv6-ifacl {
        tailf:info "IPV6 PACL size";
        type tcam-size-type;
      }
      leaf ipv6-qos {
        tailf:info "IPV6 Port QoS size";
        type tcam-size-type;
      }
      leaf ipv6-vacl {
        tailf:info "IPV6 VACL size";
        type tcam-size-type;
      }
      leaf ipv6-vqos {
        tailf:info "IPV6 VLAN QoS size";
        type tcam-size-type;
      }
      leaf l3qos-lite {
        tailf:info "IPV4 L3 QoS (Lite) size";
        type tcam-size-type;
      }
      leaf mac-ifacl {
        tailf:info "MAC PACL size";
        type tcam-size-type;
      }
      leaf mac-l3qos {
        tailf:info "MAC L3 QoS size";
        type tcam-size-type;
      }
      leaf mac-qos {
        tailf:info "MAC Port QoS size";
        type tcam-size-type;
      }
      leaf mac-vacl {
        tailf:info "MAC VACL size";
        type tcam-size-type;
      }
      leaf mac-vqos {
        tailf:info "MAC VLAN QoS size";
        type tcam-size-type;
      }
      leaf mcast-performance {
        tailf:info "MCAST performance TCAM region size";
        type tcam-size-type;
      }
      leaf mcast_bidir {
        tailf:info "MCAST bidir TCAM region size";
        type tcam-size-type;
      }
      leaf mpls {
        tailf:info "Mpls TCAM region size";
        type tcam-size-type;
      }
      leaf nat {
        tailf:info "NAT TCAM size";
        type tcam-size-type;
      }
      leaf ns-ipv6-l3qos {
        tailf:info "NS IPV4 L3 QoS size";
        type tcam-size-type;
      }
      leaf ns-ipv6-qos {
        tailf:info "NS IPV6 Port QoS size";
        type tcam-size-type;
      }
      leaf ns-ipv6-vqos {
        tailf:info "NS IPV6 VLAN QoS size";
        type tcam-size-type;
      }
      leaf ns-l3qos {
        tailf:info "NS IPV4 L3 QoS size";
        type tcam-size-type;
      }
      leaf ns-mac-l3qos {
        tailf:info "NS MAC L3 QoS size";
        type tcam-size-type;
      }
      leaf ns-mac-qos {
        tailf:info "NS MAC Port QoS size";
        type tcam-size-type;
      }
      leaf ns-mac-vqos {
        tailf:info "NS MAC VLAN QoS size";
        type tcam-size-type;
      }
      leaf ns-qos {
        tailf:info "NS IPV4 Port QoS size";
        type tcam-size-type;
      }
      leaf ns-vqos {
        tailf:info "NS IPV4 VLAN QoS size";
        type tcam-size-type;
      }
      leaf openflow {
        tailf:info "OPENFLOW region size";
        type tcam-size-type;
      }
      leaf openflow-ipv6 {
        tailf:info "OPENFLOW IPV6 region size";
        type tcam-size-type;
      }
      leaf qos-lite {
        tailf:info "IPV4 Port QoS (Lite) size";
        type tcam-size-type;
      }
      leaf redirect {
        tailf:info "Redirect size";
        type tcam-size-type;
      }
      leaf redirect_v4 {
        tailf:info "Redirect v4 size";
        type tcam-size-type;
      }
      leaf redirect_v6 {
        tailf:info "Redirect v6 size";
        type tcam-size-type;
      }
      leaf redirect-tunnel {
        tailf:info "Redirect Tunnel size";
        type tcam-size-type;
      }
      leaf rp-ipv6-qos {
        tailf:info "Ranger Plus IPV6 QoS size";
        type tcam-size-type;
      }
      leaf rp-mac-qos {
        tailf:info "Ranger Plus MAC QoS size";
        type tcam-size-type;
      }
      leaf rp-qos {
        tailf:info "Ranger Plus IPV4 QoS size";
        type tcam-size-type;
      }
      leaf rp-qos-lite {
        tailf:info "Ranger Plus IPV4 QoS (Lite) size";
        type tcam-size-type;
      }
      leaf sflow {
        tailf:info "SFlow ACL size";
        type tcam-size-type;
      }
      leaf span-sflow {
        tailf:info "SPAN+sFlow ACL size";
        type tcam-size-type;
      }
      leaf svi {
        tailf:info "Ingress SVI Counters size";
        type tcam-size-type;
      }
      leaf vacl {
        tailf:info "IPV4 VACL size";
        type tcam-size-type;
      }
      leaf e-vacl {
        tailf:info "Configure tcam for e-vacl region";
        type tcam-size-type;
      }
      leaf vqos {
        tailf:info "IPV4 VLAN QoS size";
        type tcam-size-type;
      }
      leaf vqos-lite {
        tailf:info "IPV4 VLAN QoS (Lite) size";
        type tcam-size-type;
      }
      leaf ing-fstat {
        tailf:info "Ingress FSTAT";
        type tcam-size-type;
      }
      leaf ing-ifacl {
        tailf:info "Ingress IPv4, IPv6, or MAC port ACL TCAM region size";
        type tcam-size-type;
      }
      leaf ing-l2-qos {
        tailf:info "Ingress Layer 2 QoS TCAM region size";
        type tcam-size-type;
      }
      leaf ing-l2-span-filter {
        tailf:info "Ingress Layer 2 SPAN filter TCAM region size";
        type tcam-size-type;
      }
      leaf ing-l3-span-filter {
        tailf:info "Ingress Layer 3 and VLAN SPAN filter TCAM region size";
        type tcam-size-type;
      }
      leaf ing-l3-vlan-qos {
        tailf:info "Ingress Layer 3, VLAN, and SVI QoS TCAM region size";
        type tcam-size-type;
      }
      leaf ing-nbm {
        tailf:info "Ingress NBM";
        type tcam-size-type;
      }
      leaf ing-racl {
        tailf:info "IPv4 or IPv6 ingress router ACL (RACL) TCAM region size";
        type tcam-size-type;
      }
      leaf ing-rbacl {
        tailf:info "Ingress RBACL";
        type tcam-size-type;
      }
      leaf ing-flow-redirect {
        tailf:info "Ingress Flow Redirect";
        type tcam-size-type;
      }
      leaf ing-redirect {
        tailf:info "Redirect TCAM region size for DHCPv4 relay, DHCPv4 snooping, and DHCPv4 client";
        type tcam-size-type;
      }
      leaf ing-sup {
        tailf:info "Ingress supervisor TCAM region size";
        type tcam-size-type;
      }
      leaf ing-mvpn {
        type tcam-size-type;
      }
      leaf egr-l2-qos {
        tailf:info "Egress L2 QOS";
        type tcam-size-type;
      }
      leaf egr-l3-vlan-qos {
        tailf:info "Egress L3/VLAN QOS";
        type tcam-size-type;
      }
      leaf egr-racl {
        tailf:info "Egress IPv4 or IPv6 router ACL (RACL) TCAM region size";
        type tcam-size-type;
      }
      leaf egr-sup {
        tailf:info "Egress supervisor TCAM region size";
        type tcam-size-type;
      }
      leaf ing-netflow {
        tailf:info "Ingress Netflow/Analytics region";
        type tcam-size-type;
      }
    }
  }


  // =========================================================================
  //                        CUSTOM EXTENSIONS
  // =========================================================================

  extension redeploy-data {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.redeployData";
    argument value;
  }

  extension data-category {
    argument value;
    cli:state "none";
  }

  extension trim-default-on-delete {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.trimDefaultOnDelete";
  }

  extension quoted-string {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.quotedString";
  }

  extension redeploy-pbr-stats {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.redeployPBRStats";
  }

  extension macro-expand {
    argument value;
    cli:direction "from-device";
    cli:state "pre-match";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.macroExpand";
  }

  extension diff-list-delete-before-set {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.diffListDeleteBeforeSet";
  }

  extension verify-network-address {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.verifyNetworkAddress";
  }

  extension delete-with {
    argument value; // default | none | <custom command line>
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.deleteWith";
  }

  extension prune-leaf-list-duplicates {
    cli:direction "from-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.pruneLeafListDuplicates";
  }

  extension flowcontrol-delete-with-toggle {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.flowCtrlDeleteWithToggle";
  }

  extension explicit-delete-when-empty {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.explicitDeleteWhenEmpty";
  }

  extension trim-empty-create {
    cli:direction "to-device";
    cli:state "invalid-match";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.trimEmptyCreate";
  }

  extension delete-vlan-mappings-on-delete {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.deleteVlanMappingsOnDelete";
  }

  extension must-be-less-than {
    argument value; // other leaf
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.mustBeLessThan";
  }

  extension show-on-create-only {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.showOnCreateOnly";
  }

  extension conditionally-inject-frequency {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.conditionallyInjectFrequency";
  }

  extension maintenance-mode-cleanup {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.maintenanceModeCleanup";
  }

  extension device-transformed-value {
    cli:direction "both";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.deviceTransformedValue";
  }

  extension device-transformed-dependency {
    cli:state "none";
  }

  extension explicit-ordered-by-user {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.explicitOrderedByUser";
  }

  extension trim-default-in-show {
    cli:direction "from-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.trimDefaultInShow";
  }

  extension trim-default-in-diff {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.trimDefaultInDiff";
  }

  extension split-interface-name {
    cli:direction "from-device";
    cli:state "pre-match";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.splitInterfaceName";
  }

  extension split-compact-line {
    cli:direction "from-device";
    cli:state "pre-match";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.splitCompactLine";
  }

  extension delete-rsa-key {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.deleteRsaKey";
  }

  extension dequote-input {
    cli:direction "from-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.dequoteInput";
  }

  extension escape-questionmark {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.escapeQuestionmark";
  }

  extension no-to-disable {
    cli:direction "both";
    cli:state "pre-match|post-match";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.noToDisable";
  }

  extension explicit-delete-additive {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.explicitDeleteAdditive";
  }

  extension handle-allowed-vsan {
    cli:direction "both";
    cli:state "pre-match|post-match";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.handleAllowedVsan";
  }

  extension dayzero-config {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.checkDayZeroCfg";
  }

  extension inject-vsan-in-db {
    cli:direction "from-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.injectVsanInDb";
  }

  extension filter-non-config {
    cli:direction "from-device";
    cli:state "pre-ctx-match";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.filterNonConfig";
  }

  extension trim-default-key {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.trimDefaultKey";
  }

  extension fix-per-module-lb {
    cli:direction "both";
    cli:state "pre-match|post-match";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.fixPerModuleLB";
  }

  extension reset-terminal-length {
    cli:direction "to-device";
    cli:state "last-exit-context";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.resetTerminalLength";
  }

  extension toggle-hw-module-obfl {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.toggleHWModuleOBFL";
  }

  extension handle-sr-mpls-no-mode {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.handleSRMPLSNoMode";
  }

  extension escape-backslash {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.escapeBackslash";
  }

  extension edit-not-supported {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.editNotSupported";
  }

  extension handle-no-list {
    cli:direction "from-device";
    cli:state "pre-match";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.handleNoList";
  }

  extension show-no-disable {
    cli:direction "from-device";
    cli:state "pre-match";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.showNoDisable";
  }

  extension tri-state-boolean {
    cli:direction "both";
    cli:state "pre-match|post-match";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.triStateBoolean";
  }

  extension handle-allowed-vlan {
    cli:direction "both";
    cli:state "pre-match|post-match";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.handleAllowedVlan";
  }

  extension fix-send-community {
    cli:direction "from-device";
    cli:state "pre-match";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.fixSendCommunity";
  }

  extension expand-bridge-domain {
    cli:direction "from-device";
    cli:state "pre-match|post-ctx-match|exit-context";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.expandBridgeDomain";
  }

  extension expand-bd-member-vni {
    cli:direction "from-device";
    cli:state "pre-match";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.expandBDMemberVni";
  }

  extension scheduler-job-commands {
    cli:direction "from-device";
    cli:state "multi-line";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.schedulerJobCommands";
  }

  extension dot1q-vni-mappings {
    cli:direction "from-device";
    cli:state "pre-match";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.dot1qVniMappings";
  }

  extension iface-encap-profile-dot1q {
    cli:direction "from-device";
    cli:state "pre-match";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.ifaceEncapProfDot1q";
  }

  extension iface-breakout-port-range {
    cli:direction "from-device";
    cli:state "pre-match";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.ifaceBreakoutPortRange";
  }

  extension enum-alias {
    cli:direction "from-device";
    cli:state "pre-match";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.enumAlias";
  }

  extension inject-before {
    argument value;
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.injectBefore";
  }

  extension inject-all-allowed-vlans {
    cli:direction "from-device";
    cli:state "exit-context";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.injectAllAllowedVlans";
  }

  extension dequote-output {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.dequoteOutput";
  }

  extension obu-redeploy-on-edit {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.obuRedeployOnEdit";
  }

  extension redeploy-dependency {
    argument value;
    cli:state "none";
  }

  extension snmp-server-all-traps {
    cli:direction "both";
    cli:state "post-match|last-occurence";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.snmpServerAllTraps";
  }

  extension prefix-key-leaf-list {
    cli:direction "both";
    cli:state "pre-match|post-match";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.prefixKeyLeafList";
  }

  extension case-insensitive-type {
    cli:direction "both";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.caseInsensitiveType";
  }

  extension vrf-member-chg-retain-l3 {
    cli:direction "from-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.vrfMemberChgRetainL3";
  }

  extension comma-separated-list {
    cli:direction "both";
    cli:state "pre-match|post-match";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.commaSeparatedList";
  }

  extension reactivate-zoneset {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.reactivateZoneset";
  }

  extension commit-zone {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.commitZone";
  }

  extension auto-reset-shutdown {
    cli:direction "to-device";
    cli:state "last-exit-context";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.autoResetShutdown";
  }

  extension before-exit-configure {
    cli:direction "to-device";
    cli:state "exit-context";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.beforeExitConfigure";
  }

  extension filter-in-show {
    cli:direction "from-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.nexus.NexusCliExtensions.filterInShow";
  }


  // =========================================================================
  //                        MODEL
  // =========================================================================

  /// ========================================================================
  /// tailfned
  /// ========================================================================
  /// TAILF NED device info used for device specific support.

  container tailfned {
    // NOTE: don't touch these, for internal use in NED (see ned-settings)
    leaf iface-vlan-ipv6-secondary {
      type empty;
    }

    leaf port-channel-load-balance-ethernet {
      type empty;
    }

    leaf default-lacp-suspend-individual {
      type boolean;
    }

    leaf dayzero-included {
      type empty;
    }

    leaf dayzero-permit-write {
      type empty;
    }

    leaf support-per-module-obfl {
      type empty;
    }

    leaf lldp-tlv-select-support {
      type empty;
    }

    leaf snmp-server-enable-all-traps {
      type empty;
    }
  }


  /// ========================================================================
  /// EXEC (exec commands executed in config mode)
  /// ========================================================================

  container EXEC {
    tailf:cli-drop-node-name;

    // execute (run config exec ommands, e,g,; 'crypto key generate' or
    // 'default interface Ethernet 1/1')
    tailf:action "exec" {
      tailf:info "Execute config exec-commands, e.g. 'crypto key generate' or '"
        + "default interface Ethernet 1/1'";
      tailf:actionpoint ncsinternal {
        tailf:internal;
      }
      input {
        leaf-list args {
          tailf:cli-drop-node-name;
          tailf:cli-flat-list-syntax;
          type string {
            tailf:info "ACTION:;;exec <command> <argument(s)> [options]";
          }
        }
      }
      output {
        leaf result {
          type string;
        }
      }
    }

  }



  /// ========================================================================
  /// version
  /// ========================================================================

  leaf version {
    tailf:info "Version";
    tailf:cli-multi-value;
    type string {
      tailf:info "WORD;;Version number";
    }
  }


  /// ========================================================================
  /// hostname
  /// ========================================================================

  // NOTE: This should be a choice, but we can't have choice on top-level
  //  choice hostname-or-switchname {
  leaf hostname {
    tailf:info "Set system's network name";
    type string {
      tailf:info "This system's network name";
    }
  }

  leaf switchname {
    tailf:info "Configure system's host name";
    type string {
      tailf:info "WORD;;Enter switchname (Max Size 32)";
    }
  }
  //  }

  /// ========================================================================
  /// feature
  /// ========================================================================

  container feature {
    tailf:info "Command to enable/disable features";

    leaf bash-shell {
      tailf:info "Enable/Disable bash-shell";
      type empty;
    }
    leaf bgp {
      tailf:info "Enable/Disable Border Gateway Protocol (BGP)";
      type empty;
    }
    leaf bfd {
      tailf:info "Bfd";
      type empty;
    }
    leaf cable-management {
      tailf:info "Enable/Disable Cable Management Manager (CMM)";
      type empty;
    }
    leaf dot1x {
      tailf:info "Enable/Disable dot1x";
      type empty;
    }
    leaf cts {
      tailf:info "Enable/Disable CTS";
      tailf:cli-diff-dependency "../dot1x";
      type empty;
    }
    leaf eigrp {
      tailf:info "Enable/Disable Enhanced Interior Gateway Routing Protocol ("
        +"EIGRP)";
      type empty;
    }
    leaf ethernet-link-oam {
      tailf:info "Enable/Disable Ethernet Link OAM";
      type empty;
    }
    leaf evmed {
      tailf:info "Enable/Disable Generic event detectors";
      type empty;
    }
    // feature fabric
    container fabric {
      tailf:info "Enable/Disable fabric network services";
      // feature fabric access
      leaf access {
        tailf:info "Enable/Disable Single Point of Access (XMPP Client) for the"
          +" fabric network";
        type empty;
      }
      // feature fabric forwarding
      leaf forwarding {
        tailf:info "Enable/Disable Fabric Forwarding Protocol: Host Mobility Ma"
          +"nager (HMM)";
        type empty;
      }
      // feature fabric multicast
      leaf multicast {
        tailf:info "Enable/Disable NGMVPN features";
        type empty;
      }
    }
    leaf fabricpath-vpn {
      tailf:info "Enable/Disable fabricpath-vpn services";
      tailf:cli-diff-set-after "/nx:feature-set/fabricpath";
      type empty;
    }
    leaf fabric-binding {
      tailf:info "Enable/Disable Fabric Binding";
      type empty;
    }
    leaf fcoe {
      tailf:info "Enable/Disable FCoE/FC feature";
      type empty;
    }
    leaf fcoe-npv {
      tailf:info "Enable/Disable FCoE NPV feature";
      type empty;
    }
    leaf frequency-synchronization {
      tailf:info "Enable/Disable fsync";
      type empty;
    }
    leaf fex {
      tailf:info "Enable/Disable FEX";
      type empty;
    }
    leaf fport-channel-trunk {
      tailf:info "Enable/Disable Trunking F Ports and channels";
      type empty;
    }
    leaf grpc {
      tailf:info "Enable/Disable grpc Services";
      type empty;
    }
    leaf glbp {
      tailf:info "Enable/Disable Gateway Load Balancing Protocol (GLBP)";
      type empty;
    }
    leaf flexlink {
      tailf:info "Enable/Disable Flexlink";
      type empty;
    }
    leaf hardware-telemetry {
      tailf:info "Enable/Disable Hardware Telemetry";
      type empty;
    }
    leaf hsrp {
      tailf:info "Enable/Disable Hot Standby Router Protocol (HSRP)";
      type empty;
    }
    leaf icam {
      tailf:info "Enable/Disable icam";
      type empty;
    }
    leaf itd {
      tailf:info "Enable/Disable ITD";
      type empty;
    }
    leaf macsec {
      tailf:info "Enable/Disable CTS";
      type empty;
    }
    leaf msdp {
      tailf:info "Enable/Disable Multicast Source Discovery Protocol (MSDP)";
      type empty;
    }
    container mpls {
      tailf:cli-diff-set-after "/nx:feature-set/mpls";
      leaf l2vpn {
        tailf:info "Enable/Disable Layer 2 Virtual Private Networks";
        type empty;
      }
      leaf l3vpn {
        type empty;
      }

      leaf ldp {
        tailf:info "Enable/Disable Label Distribution Protocol";
        type empty;
      }
      leaf segment-routing {
        tailf:info "Enable Segment-routing";
        type empty;
      }
      leaf evpn {
        tailf:info "Enable MPLS EVPN";
        type empty;
      }
      leaf oam {
        tailf:info "Enable MPLS OAM";
        type empty;
      }
    }
    // feature nat
    leaf nat {
      tailf:info "Enable/Disable NAT";
      type empty;
    }
    leaf ngmvpn {
      tailf:info "Enable/Disable Next-Generation Multicast VPN (ngMVPN)";
      type empty;
    }
    leaf ngoam {
      tailf:info "Enable/Disable ngoam";
      type empty;
    }
    leaf npiv {
      tailf:info "Nx port Id Virtualization (NPIV) feature enable";
      type empty;
    }
    leaf npv {
      tailf:info "Enable/Disable FC N_port Virtualizer";
      type empty;
    }
    leaf ntp {
      tailf:info "Enable/Disable NTP";
      type empty;
    }
    // feature nv
    container nv {
      tailf:info "Enable/Disable NV Overlay";
      // feature nv overlay
      leaf overlay {
        tailf:info "Enable/Disable NV Overlay";
        tailf:cli-diff-delete-before "../../vn-segment-vlan-based" {
          tailf:cli-when-target-delete;
        }
        type empty;
      }
    }
    leaf nxapi {
      tailf:info "Enable/Disable nxapi";
      type empty;
    }
    leaf network-segmentation-manager {
      tailf:info "Enable/Disable network segmentation manager";
      type empty;
    }
    leaf lisp {
      tailf:info "Enable/Disable Locator/ID Separation Protocol (LISP)";
      type empty;
    }
    leaf ldap {
      tailf:info "Enable/Disable ldap";
      type empty;
    }
    leaf lldp {
      tailf:info "Enable/Disable LLDP";
      type empty;
    }
    leaf pbr {
      tailf:info "Enable/Disable Policy Based Routing(PBR)";
      type empty;
    }
    leaf ospf {
      tailf:info "Enable/Disable Open Shortest Path First Protocol (OSPF)";
      type empty;
    }
    leaf ospfv3 {
      tailf:info "Enable/Disable Open Shortest Path First Version 3 Protocol ("
        +"OSPFv3)";
      type empty;
    }
    leaf otv {
      tailf:info "Enable/Disable Overlay Transport Virtualization (OTV)";
      type empty;
    }
    container password {
      tailf:info "Credential(s) for the user(s)/device(s)";
      container encryption {
        tailf:info "Strong encryption for credential(s)";
        leaf aes {
          tailf:info "Encrypt using AES encryption standard";
          type empty;
        }
      }
    }
    leaf pim {
      tailf:info "Enable/Disable Protocol Independent Multicast (PIM)";
      type empty;
    }
    leaf pim6 {
      tailf:info "Enable/Disable Protocol Independent Multicast (PIM) for IPv6";
      type empty;
    }
    leaf poe {
      tailf:info "Enable/Disable PoE";
      type empty;
    }
    leaf pong {
      tailf:info "Enable/Disable Pong";
      type empty;
    }
    leaf port-security {
      tailf:info "Enable/Disable port-security";
      type empty;
    }
    leaf privilege {
      tailf:info "Enable/Disable IOS type privilege level support";
      type empty;
    }
    leaf ptp {
      tailf:info "Enable/Disable PTP";
      type empty;
    }
    leaf restconf {
      tailf:info "Enable/Disable restconf Services";
      type empty;
    }
    leaf rip {
      tailf:info "Enable/Disable Routing Information Protocol (RIP)";
      type empty;
    }
    leaf segmentation {
      tailf:info "Enable/Disable Segmentation/BD feature";
      type empty;
    }
    leaf scheduler {
      tailf:info "Enable/Disable scheduler";
      type empty;
    }
    leaf scp-server {
      tailf:info "Enable/Disable SCP server";
      type empty;
    }
    leaf sftp-server {
      tailf:info "Enable/Disable SFTP server";
      type empty;
    }
    leaf sflow {
      tailf:info "Enable/Disable sFlow agent";
      type empty;
    }
    leaf signature-verification {
      tailf:info "Enable image signature verification";
      type empty;
    }
    container sla {
      tailf:info "Enable/Disable SLA";
      leaf responder {
        tailf:info "Enable/Disable responder part of SLA";
        type empty;
      }
      leaf sender {
        tailf:info "Enable/Disable sender part of SLA";
        type empty;
      }
    }
    leaf udld {
      tailf:info "Enable/Disable UDLD";
      type empty;
    }
    leaf vni {
      tailf:info "Enable/Disable Virtual Network Segment (VNI)";
      type empty;
    }
    leaf vn-segment-vlan-based {
      tailf:info "Enable/Disable VLAN based VN segment";
      tailf:cli-diff-delete-before "../mpls/segment-routing";
      type empty;
    }
    leaf vpc {
      tailf:info "Enable/Disable VPC (Virtual Port Channel)";
      type empty;
    }
    leaf vrrp {
      tailf:info "Enable/Disable Virtual Router Redundancy Protocol (VRRP)";
      type empty;
    }
    leaf vrrpv3 {
      tailf:info "Enable/Disable Virtual Router Redundancy Protocol (VRRP) version 3";
      type empty;
    }
    leaf vtp {
      tailf:info "Enable/Disable Vlan Trunking Protocol (VTP)";
      type empty;
    }
    leaf dhcp {
      tailf:info "Enable/Disable DHCP Snooping";
      type empty;
    }
    leaf http-server {
      type empty;
      tailf:info "Enable/Disable http-server";
    }
    leaf imp {
      tailf:info "Enable/Disable IMP";
      type empty;
    }
    leaf interface-vlan {
      tailf:info "Enable/Disable interface vlan";
      type empty;
    }
    leaf isis {
      tailf:info "Enable/Disable IS-IS Unicast Routing Protocol (IS-IS)";
      type empty;
    }
    leaf lacp {
      tailf:info "Enable/Disable LACP";
      type empty;
    }
    leaf netconf {
      tailf:info "Enable/Disable netconf Services";
      type empty;
    }
    leaf netflow {
      tailf:info "Enable/Disable NetFlow";
      type empty;
    }
    leaf port-profile-roles {
      tailf:info "Enable/Disable Port-profile Roles Feature";
      type empty;
    }
    leaf private-vlan {
      tailf:info "Enable/Disable private-vlan";
      type empty;
    }
    leaf ssh {
      tailf:info "Enable/Disable ssh";
      type empty;
    }
    leaf tacacs-plus {
      tailf:alt-name "tacacs+";
      type empty;
      tailf:info "Enable/Disable tacacs+";
    }
    leaf telemetry {
      tailf:info "Enable/Disable Telemetry";
      type empty;
    }
    leaf telnet {
      type empty;
      tailf:cli-show-no;
      tailf:info "Enable/Disable telnet";
    }
    // feature tunnel
    leaf tunnel {
      tailf:info "Enable/Disable Tunnel Manager";
      type empty;
    }
    leaf vpd {
      type empty;
      tailf:info "Enable/Disable VPC";
    }
  }


  /// ========================================================================
  /// password
  /// ========================================================================

  container password {
    tailf:info "Password for the user";
    leaf strength-check {
      tailf:info "Strength check of password";
      tailf:cli-boolean-no;
      type boolean;
      default "true";
    }
    leaf secure-mode {
      tailf:info "Enable secure mode for changing password";
      tailf:cli-boolean-no;
      type boolean;
      default "true";
    }
  }


  /// ========================================================================
  /// fabric-mode
  /// ========================================================================

  leaf fabric-mode {
    tailf:info "Set switch fabric-mode";
    tailf:cli-case-insensitive;
    type enumeration {
      enum 10g {
        tailf:info "Sets the fabric mode to 10G";
      }
      enum 40g {
        tailf:info "Sets the fabric mode to 40G";
      }
    }
  }


  /// ========================================================================
  /// poweroff
  /// ========================================================================

  container poweroff {
    tailf:info "Power off a module in the switch";
    leaf module {
      tailf:info "Enter a module number";
      type uint8;
    }
  }


  /// ========================================================================
  /// power
  /// ========================================================================

  container power {
    tailf:info "Configure power supply";
    tailf:cli-compact-syntax;
    tailf:cli-sequence-commands {
      tailf:cli-reset-siblings;
    }
    leaf redundancy-mode {
      tailf:info "Configure power supply redundancy mode";
      type enumeration {
        enum combined {
          tailf:info "Configure power supply redundancy mode as combined";
        }
        enum insrc-redundant {
          tailf:info "Configure power supply redundancy mode as grid/AC input source redundant";
        }
        enum ps-redundant {
          tailf:info "Configure power supply redundancy mode as PS redundant";
        }
        enum redundant {
          tailf:info "Configure power supply redundancy mode as InSrc and PS redundant";
        }
      }
    }
    leaf force {
      tailf:info "Force combined mode without prompting";
      tailf:cli-no-name-on-delete;
      type empty;
    }
  }


  /// ========================================================================
  /// nv
  /// ========================================================================
  container nv {
    tailf:info "Command to enable/disable features";
    // nv overlay
    container overlay {
      tailf:info "Command to enable/disable features";
      // nv overlay evpn
      leaf evpn {
        tailf:info "Enable/Disable Ethernet VPN (EVPN)";
        tailf:cli-diff-delete-before "/nx:feature/mpls/segment-routing";
        tailf:cli-diff-delete-before "/nx:feature/nv/overlay";
        type empty;
      }
    }
  }

  /// ========================================================================
  /// vni
  /// ========================================================================

  // vni * <CR>
  container vni {
    tailf:info "Virtual Network Identifier";
    leaf-list vni {
      tailf:info "Virtual Network Identifier";
      tailf:cli-drop-node-name;
      tailf:cli-range-list-syntax;
      tailf:cli-diff-dependency "../../feature/vni";
      nx:prune-leaf-list-duplicates;
      when "../../feature/vni" {
        tailf:dependency "../../feature/vni";
      }
      type uint32 {
        tailf:info "<4096-16777215>;;Vni range, Example: "
          +"4096,4099-5013,5019,6011-6099";
        range "4096..16777215";
      }
    }
  }

  /// ========================================================================
  /// tacacs-server
  /// ========================================================================
  container tacacs-server {
    tailf:info "Configure TACACS+ server related parameters";
    tailf:cli-compact-syntax;
    tailf:cli-diff-dependency "../feature/tacacs-plus";
    // FIXME: netsim doesn't handle rollbacks with this
    // when "../feature/tacacs-plus" {
    //   tailf:dependency "../feature/tacacs-plus";
    // }
    // tacacs-server deadtime
    leaf deadtime {
      tailf:info "Duration for which non-reachable server is skipped";
      tailf:cli-full-command;
      type uint16 {
        range "0..1440";
      }
    }

    // tacacs-server directed-request
    leaf directed-request {
      tailf:info "Enable direct authentication requests to server";
      tailf:cli-full-command;
      type empty;
    }

    // tacacs-server host
    list host {
      tailf:info "TACACS+ server's DNS name or its IP address";
      tailf:cli-compact-syntax;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      ordered-by user;
      nx:explicit-delete-when-empty;
      nx:obu-redeploy-on-edit;
      nx:redeploy-dependency "../../aaa/group/server/tacacs-plus/server[id=%s]";
      key id;
      leaf id {
        tailf:info "IPV4/IPV6 address or DNS name";
        type union {
          type inet:ipv4-address;
          type inet:ipv6-address;
          type string;
        }
      }

      // tacacs-server host secret
      container secret {
        tailf:cli-drop-node-name;
        tailf:cli-sequence-commands;
        tailf:cli-compact-syntax;
        tailf:cli-flatten-container;

        // tacacs-server host secret key
        leaf key {
          tailf:info "TACACS+ shared secret";
          tailf:cli-incomplete-command;
          nx:device-transformed-dependency;
          type enumeration {
            enum "0" {
              tailf:info "TACACS+ shared secret(clear text)";
            }
            enum "6" {
              tailf:info "TACACS+ shared secret(type-6 encrypted)";
            }
            enum "7" {
              tailf:info "TACACS+ shared secret(encrypted)";
            }
          }
        }

        // tacacs-server host secret shared-secret
        leaf shared-secret {
          tailf:cli-drop-node-name;
          nx:device-transformed-value;
          type NEDCOM_SECRET_TYPE {
            tailf:info "TACACS+ shared secret";
          }
        }
      }

      // tacacs-server host port
      leaf port {
        tailf:info "TACACS+ server port";
        type uint16;
      }

      // tacacs-server host test
      container test {
        tailf:info "Parameters to send test packets";
        tailf:cli-flatten-container;
        tailf:cli-optional-in-sequence;
        when "not(../port)" {
          tailf:dependency "../port";
        }

        // tacacs-server host test idle-time
        leaf idle-time {
          tailf:info "Time interval for monitoring the server";
          tailf:cli-full-command;
          type uint16 {
            range "1..1440";
          }
        }

        // tacacs-server host test password
        leaf password {
          tailf:info "User password in test packets";
          tailf:cli-full-command;
          type string {
            length "1..32";
          }
        }

        // tacacs-server host test username
        leaf username {
          tailf:info "User name in test packets";
          type string {
            length "1..32";
          }
        }
      }

      // tacacs-server host timeout
      leaf timeout {
        tailf:info "TACACS+ server timeout period in seconds";
        tailf:cli-full-command;
        type uint8 {
          range "1..60";
        }
      }
    }

    // tacacs-server secret
    container secret {
      tailf:cli-sequence-commands;
      tailf:cli-compact-syntax;
      tailf:cli-drop-node-name;

      // tacacs-server secret key
      leaf key {
        tailf:info "TACACS+ shared secret";
        tailf:cli-incomplete-command;
        nx:device-transformed-dependency;
        type enumeration {
          enum "0" {
            tailf:info "TACACS+ shared secret(clear text)";
          }
          enum "6" {
            tailf:info "TACACS+ shared secret(type-6 encrypted)";
          }
          enum "7" {
            tailf:info "TACACS+ shared secret(encrypted)";
          }
        }
      }

      // tacacs-server secret shared-secret
      leaf shared-secret {
        tailf:cli-drop-node-name;
        nx:device-transformed-value;
        type NEDCOM_SECRET_TYPE {
          tailf:info "TACACS+ shared secret";
        }
      }
    }

    // tacacs-server test
    container test {
      tailf:info "Parameters to send test packets";
      when "not(../secret/key)" {
        tailf:dependency "../secret/key";
      }

      // tacacs-server test idle-time
      leaf idle-time {
        tailf:info "Time interval for monitoring the server";
        tailf:cli-full-command;
        type uint16 {
          range "1..1440";
        }
      }

      // tacacs-server test password
      leaf password {
        tailf:info "User password in test packets";
        tailf:cli-full-command;
        type string {
          length "1..32";
        }
      }

      // tacacs-server test username
      leaf username {
        tailf:info "User name in test packets";
        type string {
          length "1..32";
        }
      }
    }

    // tacacs-server timeout
    leaf timeout {
      tailf:info "TACACS+ server timeout period in seconds";
      tailf:cli-full-command;
      default 5;
      type uint8 {
        range "1..60";
      }
    }
  }

  /// ========================================================================
  /// radius-server
  /// ========================================================================

  container radius-server {
    tailf:info "Configure RADIUS related parameters";

    leaf deadtime {
      tailf:info "Duration for which non-reachable server is skipped";
      type uint16 {
        tailf:info "<0-1440>;;Length of time, in minutes";
        range "0..1440";
      }
    }

    leaf directed-request {
      tailf:info "Enable direct authentication requests to server";
      type empty;
    }

    list host {
      tailf:info "RADIUS server's DNS name or its IP address";
      tailf:cli-suppress-mode;
      tailf:cli-compact-syntax;
      tailf:cli-delete-when-empty;
      ordered-by user;
      nx:explicit-delete-when-empty {
        cli:arguments "full-no";
      }
      nx:obu-redeploy-on-edit;
      nx:redeploy-dependency "../../aaa/group/server/radius/server[id=%s]";

      key id;
      leaf id {
        tailf:info "A:B::C:D|WORD;;IPV4/IPV6 address or DNS name";
        type union {
          type inet:ip-address {
            tailf:info "A.B.C.D;;IPV4 address";
          }
          type inet:ipv6-address {
            tailf:info "A:B::C:D;;IPV6 address";
          }
          type string {
            tailf:info "WORD;;DNS name";
          }
        }
      }
      container key {
        tailf:info "RADIUS shared secret";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf encryption {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          nx:device-transformed-dependency;
          type enumeration {
            enum "0" {
              tailf:info "Specifies an UNENCRYPTED password will follow";
            }
            enum "7" {
              tailf:info "Specifies a HIDDEN password will follow";
            }
            enum "6" {
              tailf:info "Specifies a type6 encrypted password will follow";
            }
          }
        }
        leaf password {
          tailf:cli-drop-node-name;
          nx:device-transformed-value;
          type NEDCOM_SECRET_TYPE {
            tailf:info "WORD;;The HIDDEN user password string";
          }
        }
      }
      leaf pac {
        tailf:info "Secure Radius Enable";
        type empty;
      }
      leaf auth-port {
        tailf:info "RADIUS server's port for authentication";
        default "1812";
        type uint16 {
          tailf:info "<0-65535>;;Port number";
        }
      }
      leaf acct-port {
        tailf:info "RADIUS server's port for accounting";
        default "1813";
        type uint16 {
          tailf:info "<0-65535>;;Port number";
        }
      }
      leaf authentication {
        tailf:info "Use for authentication";
        type empty;
      }
      leaf accounting {
        tailf:info "Use for accounting";
        type empty;
      }
      leaf timeout {
        tailf:info "RADIUS server timeout period in seconds";
        type uint8 {
          tailf:info "<1-60>;;RADIUS server timeout period in seconds";
          range "1..60";
        }
      }
      leaf retransmit {
        tailf:info "RADIUS server retransmit count";
        type uint8 {
          tailf:info "<0-5>;;RADIUS server retransmit count";
          range "0..5";
        }
      }
    }
    container key {
      tailf:info "Global RADIUS server shared secret";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-reset-container;
      leaf encryption {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        tailf:cli-optional-in-sequence;
        nx:device-transformed-dependency;
        type enumeration {
          enum "0" {
            tailf:info "Specifies an UNENCRYPTED password will follow";
          }
          enum "7" {
            tailf:info "Specifies a HIDDEN password will follow";
          }
          enum "6" {
            tailf:info "Specifies a type-6 encrypted password will follow";
          }
        }
      }
      leaf password {
        tailf:cli-drop-node-name;
        tailf:cli-trim-default;
        nx:device-transformed-value;
        type NEDCOM_SECRET_TYPE {
          tailf:info "WORD;;The HIDDEN user password string";
        }
      }
    }
    leaf retransmit {
      tailf:info "Global RADIUS server retransmit count";
      type uint8 {
        tailf:info "<0-5>;;Global RADIUS server retransmit count";
        range "0..5";
      }
    }
    //  test              Parameters to send test packets
    leaf timeout {
      tailf:info "Global RADIUS server timeout period in seconds";
      type uint8 {
        tailf:info "<1-60>;;RADIUS server timeout period in seconds";
        range "1..60";
      }
    }
  }


  /// ========================================================================
  /// ldap
  /// ========================================================================

  container ldap {
    tailf:info "Configure information about ldap";
    tailf:cli-diff-dependency "../feature/ldap";
    list search-map {
      tailf:info "Configure the search-map";
      key name;
      leaf name {
        tailf:info "WORD;;Search Map Name  (Max Size 128)";
        type string;
      }
      grouping attr-filter-grouping {
        leaf attribute-name {
          tailf:info "LDAP attribute-name";
          type string {
            tailf:info "WORD;;Search Map attribute-name  (Max Size 128)";
          }
        }
        leaf search-filter {
          tailf:info "LDAP search-filter";
          type string {
            tailf:info "WORD;;Search Map search-filter  (Max Size 128)";
          }
        }
        leaf base-DN {
          tailf:info "LDAP base-DN";
          type string {
            tailf:info "WORD;;Search Map base-DN Name  (Max Size 128)";
          }
        }
      }
      container CRLLookup {
        tailf:info "Set the CRLLookup";
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        uses attr-filter-grouping;
      }
      container trustedCert {
        tailf:info "Set the trustedCert";
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        uses attr-filter-grouping;
      }
      container user-certdn-match {
        tailf:info "Set the certificate matching";
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        uses attr-filter-grouping;
      }
      container user-pubkey-match {
        tailf:info "Set the pubkey matching";
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        uses attr-filter-grouping;
      }
      container user-switch-bind {
        tailf:info "Set the user-switch-bind";
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        uses attr-filter-grouping;
      }
      container userprofile {
        tailf:info "Set the userprofile";
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        uses attr-filter-grouping;
      }
    }
  }


  /// ========================================================================
  /// ldap-server
  /// ========================================================================

  container ldap-server {
    tailf:info "Configure LDAP related parameters";
    tailf:cli-diff-dependency "../feature/ldap";
    leaf deadtime {
      tailf:info "Global LDAP server deadtime period in seconds";
      type uint8 {
        tailf:info "<1-60>;;LDAP server deadtime period in minutes (default 0 mins -disabled)";
      }
    }
    leaf timeout {
      tailf:info "Global LDAP server timeout period in seconds";
      type uint8 {
        tailf:info "<1-60>;;LDAP server timeout period in seconds (default 5 sec)";
      }
    }
    list host {
      tailf:info "LDAP server's DNS name or IP address";
      key name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      ordered-by user;
      nx:obu-redeploy-on-edit;
      nx:redeploy-dependency "../../aaa/group/server/ldap/server[name=%s]";
      leaf name {
        type string {
          tailf:info "A.B.C.D|A:B::C:D|WORD;;IPV4/IPV6 address or DNS name";
        }
      }
      leaf enable-ssl {
        tailf:info "LDAP server enable ssl";
        type empty;
      }
      leaf referral-disable {
        tailf:info "LDAP server disable referrals";
        type empty;
      }
      container host-config {
        tailf:cli-drop-node-name;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        leaf rootDN {
          tailf:info "LDAP server root DN";
          type string {
            tailf:info "WORD;;Root DN  (Max Size 128)";
          }
        }
        container password {
          tailf:info "LDAP server root password";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf encrypted {
            tailf:alt-name "7";
            tailf:cli-optional-in-sequence;
            tailf:cli-incomplete-command;
            nx:device-transformed-dependency;
            type empty;
          }
          leaf password {
            tailf:cli-drop-node-name;
            nx:device-transformed-value;
            type NEDCOM_SECRET_TYPE {
              tailf:info "WORD  Password (clear text)  (Max Size 64)";
            }
          }
        }
        leaf port {
          tailf:info "LDAP server's port (default: global config)";
          tailf:cli-optional-in-sequence;
          type uint16 {
            tailf:info "<1-65535>;;Port number";
          }
        }
        leaf timeout {
          tailf:info "LDAP server timeout period in seconds";
          type uint8 {
            tailf:info "<1-60>;;LDAP server timeout in seconds (default: global config)";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// aaa
  /// ========================================================================

  container aaa {
    tailf:info "Configure aaa functions";
    tailf:cli-diff-dependency "/nx:tacacs-server";

    grouping groups-and-fallback-grouping {
      leaf group {
        tailf:info "Specify server groups";
        tailf:cli-optional-in-sequence;
        tailf:cli-disallow-value "local|none";
        type string {
          tailf:info "WORD;;Server group name (Max Size 127)";
          length "1..127";
        }
      }

      leaf group2 {
        when "../group" {
          tailf:dependency "../group";
        }
        tailf:cli-optional-in-sequence;
        tailf:cli-drop-node-name;
        tailf:cli-disallow-value "local|none";
        type string {
          tailf:info "WORD;;Server group name (Max Size 127)";
          length "1..127";
        }
      }

      leaf group3 {
        when "../group2" {
          tailf:dependency "../group2";
        }
        tailf:cli-optional-in-sequence;
        tailf:cli-drop-node-name;
        tailf:cli-disallow-value "local|none";
        type string {
          tailf:info "WORD;;Server group name (Max Size 127)";
          length "1..127";
        }
      }

      leaf fallback {
        tailf:cli-drop-node-name;
        default "local";
        type enumeration {
          enum local {
            tailf:info "Use local RBACL based authorization";
          }
          enum none {
            tailf:info "No authorization";
          }
        }
      }
    }

    // aaa group
    container group {
      tailf:info "Configure aaa server group";

      // aaa group server
      container server {
        tailf:info "Configure aaa server group";

        // aaa group server radius
        list radius {
          tailf:info "RADIUS server group name";
          key id;
          leaf id {
            type string {
              length "1..127";
            }
          }
          // aaa group server radius WORD / deadtime <0-1440> <CR>
          leaf deadtime {
            tailf:info "Duration for which non-reachable server is skipped";
            type uint16 {
              tailf:info "<0-1440>;;Length of time, in minutes";
            }
          }

          // aaa group server radius WORD / server WORD <CR>
          list server {
            tailf:info "RADIUS server name or IP address";
            tailf:cli-suppress-mode;
            ordered-by user;
            tailf:cli-show-long-obu-diffs;
            key id;
            leaf id {
              tailf:non-strict-leafref {
                path "/nx:radius-server/host/id";
              }
              type union {
                type inet:ip-address {
                  tailf:info "A.B.C.D;;IPV4 address";
                }
                type inet:ipv6-address {
                  tailf:info "A:B::C:D;;IPV6 address";
                }
                type string {
                  tailf:info "WORD;;DNS name";
                }
              }
            }
          }
          // aaa group server radius WORD / source-interface
          container source-interface {
            tailf:info "Source interface to be used to reach radius server";
            tailf:cli-reset-container;
            // aaa group server radius WORD /
            //   source-interface Ethernet <1-253>/<1-256>.<1-511> <CR>
            leaf Ethernet {
              tailf:info "Ethernet IEEE 802.3z";
              tailf:cli-allow-join-with-value {
                tailf:cli-display-joined;
              }
              type string {
                tailf:info "<1-253>/<1-256>;;Slot/chassis number";
                pattern "\\d+/\\d+(\\.\\d+)?";
              }
            }
            // aaa group server radius WORD /
            //   source-interface loopback <0-1023>
            leaf loopback {
              tailf:info "Loopback interface";
              tailf:cli-allow-join-with-value {
                tailf:cli-display-joined;
              }
              type uint16 {
                tailf:info "<0-1023>;;Virtual interface number";
                range "0..1023";
              }
            }
            // aaa group server radius WORD / source-interface mgmt 0 <CR>
            leaf mgmt {
              tailf:info "Management interface";
              tailf:cli-allow-join-with-value {
                tailf:cli-display-joined;
              }
              type uint16 {
                tailf:info "<0-0>;;Management interface number";
                range "0..1023";
              }
            }
            // aaa group server radius WORD / source-interface null 0 <CR>
            leaf Null {
              tailf:info "Null interface";
              tailf:cli-allow-join-with-value {
                tailf:cli-display-joined;
              }
              type uint16 {
                tailf:info "<0-0>;;Null interface number";
                range "0..1023";
              }
            }
            // aaa group server radius WORD /
            //   source-interface port-channel <1-4096> <CR>
            leaf port-channel {
              tailf:info "Port Channel interface";
              tailf:cli-allow-join-with-value {
                tailf:cli-display-joined;
              }
              type uint16 {
                tailf:info "<1-4096>;;Port Channel number";
                range "1..4096";
              }
            }
            // aaa group server radius WORD / source-interface sup-eth 0 <CR>
            leaf sup-eth {
              tailf:info "Ethernet Inband interface";
              tailf:cli-allow-join-with-value {
                tailf:cli-display-joined;
              }
              type uint16 {
                tailf:info "<0-0>;;Ethernet Inband interface number";
                range "0..1023";
              }
            }
            // aaa group server radius WORD /
            //   source-interface vlan <1-4094> <CR>
            leaf vlan {
              tailf:info "Vlan interface";
              tailf:cli-allow-join-with-value {
                tailf:cli-display-joined;
              }
              type uint16 {
                tailf:info "<1-4094>;;Vlan interface number";
                range "0..4094";
              }
            }
          }
          // aaa group server radius WORD / use-vrf
          leaf use-vrf {
            tailf:info "Vrf to be used to contact servers in this group";
            // aaa group server radius WORD /
            //   use-vrf WORD|default|management
            tailf:cli-trim-default;
            default "default";
            type vrf-member-type;
          }
        }

        // aaa group server tacacs-plus
        list tacacs-plus {
          tailf:info "TACACS+ server group name";
          tailf:cli-full-command;
          tailf:alt-name "tacacs+";
          tailf:cli-diff-dependency "../../../../feature/tacacs-plus";
          when "../../../../feature/tacacs-plus" {
            tailf:dependency "../../../../feature/tacacs-plus";
          }
          key id;
          leaf id {
            type string {
              length "1..127";
            }
          }

          // aaa group server tacacs-plus server
          list server {
            tailf:info "TACACS+ server name or IP address";
            tailf:cli-suppress-mode;
            ordered-by user;
            tailf:cli-show-long-obu-diffs;
            key id;
            leaf id {
              type leafref {
                path "/nx:tacacs-server/host/id";
              }
            }
          }

          // aaa group server tacacs-plus source-interface
          leaf source-interface {
            tailf:info "Source interface to be used to reach tacacs server";
            tailf:cli-full-command;
            nx:case-insensitive-type;
            // Should be a leafref to existing interface
            type string;
          }

          // aaa group server tacacs-plus use-vrf
          leaf use-vrf {
            tailf:info "Vrf to be used to contact servers in this group";
            tailf:cli-full-command;
            tailf:cli-trim-default;
            default "default";
            type vrf-member-type;
          }

          leaf deadtime {
            tailf:info "Duration for which non-reachable server is skipped";
            default 0;
            type uint16 {
              tailf:info "<0-1440>;;Length of time, in minutes";
            }
          }
        }

        list ldap {
          tailf:info "LDAP server group name";
          tailf:cli-diff-dependency "/nx:feature/ldap";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;LDAP server group name  (Max Size 64)";
            }
          }

          container authentication {
            tailf:info "Set the authentication method";
            container bind-first {
              tailf:info "Set the authentication method to bind-first";
              presence true;
              leaf append-with-basedn {
                tailf:info "Change the default value (cn=$userid)";
                type string {
                  tailf:info "WORD;;Append with dn value (Max Size 63)";
                }
              }
            }
            container compare {
              tailf:info "Change the default attribute";
              presence true;
              leaf password-attribute {
                tailf:info "Change the default password attribute (userPassword)";
                type string {
                  tailf:info "WORD;;Password attribute (Max Size 63)";
                }
              }
            }
          }

          container enable {
            tailf:info "Enable";
            leaf Cert-DN-match {
              tailf:info "Enable/Disable Cert-DN matching";
              type empty;
            }
            leaf user-server-group {
              tailf:info "Enable/Disable group validation";
              type empty;
            }
          }

          leaf ldap-search-map {
            tailf:info "Set one of the configured search-map as active";
            tailf:non-strict-leafref {
              path "/nx:ldap/search-map/name";
            }
            type string {
              tailf:info "WORD;;Name of the search-map  (Max Size 128)";
            }
          }

          list server {
            tailf:info "TACACS+ server name or IP address";
            tailf:cli-suppress-mode;
            ordered-by user;
            tailf:cli-show-long-obu-diffs;
            key name;
            leaf name {
              type leafref {
                path "/nx:ldap-server/host/name";
              }
            }
          }

          leaf deadtime {
            tailf:info "Duration for which non-reachable server is skipped";
            default 0;
            type uint16 {
              tailf:info "<0-1440>;;Length of time, in minutes";
            }
          }
        }
      }
    }

    // aaa server
    container server {
      tailf:info "Local AAA server";
      container radius {
        tailf:info "Profile for local radius server";
        container dynamic-author {
          tailf:info "Local server profile for RFC 5176 support";
          presence "true";
          tailf:cli-add-mode;
          list client {
            tailf:info "Specify a RADIUS client";
            tailf:cli-suppress-mode;
            tailf:cli-compact-syntax;
            tailf:cli-delete-when-empty;
            nx:explicit-delete-when-empty;
            key addr;
            leaf addr {
              type union {
                type inet:ipv4-address;
                type inet:ipv6-address;
                type string;
              }
            }

            leaf vrf {
              tailf:non-strict-leafref {
                path "/nx:vrf/context/id";
              }
              type vrf-member-type;
            }

            container server-key {
              tailf:info "Encryption key shared with the radius client";
              leaf cisco_enc {
                tailf:alt-name "7";
                tailf:info "RADIUS shared secret(encrypted)";
                type string {
                  tailf:info "WORD;;RADIUS shared secret(encrypted) (Max Size 63)";
                  length "1..63";
                }
              }
            }
          }
        }
      }
    }

    // aaa accounting
    container accounting {
      tailf:info "Configure accounting methods";
      tailf:cli-diff-dependency "/nx:aaa/group/server/tacacs-plus";
      tailf:cli-diff-dependency "/nx:aaa/group/server/radius";

      // aaa accounting default
      container default {
        tailf:info "Configure default methods";

        // aaa accounting default group
        leaf-list group {
          tailf:info "Specify server groups to redirect the accounting logs";
          tailf:cli-flat-list-syntax;
          tailf:cli-replace-all;
          tailf:cli-full-command;
          ordered-by user;
          type string {
            length "1..127";
          }
        }

        // aaa accounting default local
        leaf local {
          tailf:info "Use local accounting";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          default "true";
          type boolean;
        }
      }

      container dot1x {
        tailf:info "Accounting methods for dot1x";
        tailf:cli-diff-dependency "/nx:feature/dot1x";
        container default {
          tailf:info "Default aaa methods";
          leaf-list group {
            tailf:cli-flat-list-syntax;
            tailf:cli-replace-all;
            type string {
              tailf:info "WORD;;Server group name";
            }
          }
        }
      }

    }

    // aaa authentication
    container authentication {
      tailf:info "Configure authentication methods";
      tailf:cli-diff-dependency "/nx:aaa/accounting";
      tailf:cli-diff-dependency "/nx:aaa/group/server/tacacs-plus";
      tailf:cli-diff-dependency "/nx:aaa/group/server/radius";

      // aaa authentication login
      container login {
        tailf:info "Configure methods for login";

        // aaa authentication login ascii-authentication
        leaf ascii-authentication {
          tailf:info "Enable ascii authentication";
          tailf:cli-full-command;
          type empty;
        }

        // aaa authentication login chap
        leaf chap {
          tailf:info "CHAP authentication for login";
          tailf:cli-full-command;
          type enable-type;
        }

        container fallback-local {
          tailf:cli-drop-node-name;
          grouping fallback-grouping {
            container fallback {
              tailf:info "Configure fallback behavior";
              container error {
                tailf:info "Fallback in case all AAA servers configured for remote authentication are unreachable (Authentication error)";
                leaf local {
                  tailf:info "Fallback to local authentication";
                  tailf:cli-boolean-no;
                  default "true";
                  type boolean;
                }
              }
            }
          }
          container console {
            tailf:info "Configure console methods";
            uses fallback-grouping;
          }
          container default {
            tailf:info "Configure default methods";
            uses fallback-grouping;
          }
        }

        // aaa authentication login console
        container console {
          tailf:info "Configure console methods";
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-compact-syntax;
          uses groups-and-fallback-grouping;
        }

        // aaa authentication login default
        container default {
          tailf:info "Configure default methods";
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-compact-syntax;
          uses groups-and-fallback-grouping;
        }

        // aaa authentication mschap error-enable
        leaf error-enable {
          tailf:info "Enable display of error message on login failures";
          tailf:cli-full-command;
          type empty;
        }

        leaf invalid-username-log {
          tailf:info "Enable invalid username log";
          tailf:cli-full-command;
          type empty;
        }

        // aaa authentication mschap
        leaf mschap {
          tailf:info "MSCHAP authentication for login";
          tailf:cli-full-command;
          type enable-type;
        }

        // aaa authentication mschapv2
        leaf mschapv2 {
          tailf:info "MSCHAP V2 authentication for login";
          tailf:cli-full-command;
          type enable-type;
        }
      }

      // aaa authentication dot1x
      container dot1x {
        tailf:info "Authentication methods for dot1x";
        tailf:cli-diff-dependency "/nx:feature/dot1x";
        container default {
          tailf:info "Default aaa methods";
          leaf-list group {
            tailf:cli-flat-list-syntax;
            tailf:cli-replace-all;
            type string {
              tailf:info "WORD;;Server group name";
            }
          }
        }
      }

      // aaa authentication cts
      container cts {
        tailf:info "Authentication methods for cts";
        tailf:cli-diff-dependency "/nx:feature/cts";
        container default {
          tailf:info "Default aaa methods";
          leaf-list group {
            tailf:cli-flat-list-syntax;
            tailf:cli-replace-all;
            type string {
              tailf:info "WORD;;Server group name";
            }
          }
        }
      }

    }

    // aaa authorization
    container authorization {
      tailf:info "Configure authorization methods";
      tailf:cli-diff-dependency "/nx:aaa/accounting";
      tailf:cli-diff-dependency "/nx:aaa/group/server/tacacs-plus";
      tailf:cli-diff-dependency "/nx:aaa/group/server/radius";

      // aaa authorization commands
      container commands {
        tailf:info "Authorization for all exec-mode commands";
        tailf:cli-compact-syntax;

        // aaa authorization commands console
        container console {
          tailf:info "Configure methods console";
          tailf:cli-sequence-commands;
          tailf:cli-compact-syntax;
          uses groups-and-fallback-grouping;
        }

        // aaa authorization commands default
        container default {
          tailf:info "Configure default methods";
          tailf:cli-sequence-commands;
          tailf:cli-compact-syntax;
          uses groups-and-fallback-grouping;
        }
      }

      // aaa authorization config-commands
      container config-commands {
        tailf:info "Authorization for all exec-mode commands";
        tailf:cli-compact-syntax;

        // aaa authorization config-commands console
        container console {
          tailf:info "Configure methods console";
          tailf:cli-sequence-commands;
          tailf:cli-compact-syntax;
          uses groups-and-fallback-grouping;
        }

        // aaa authorization config-commands default
        container default {
          tailf:info "Configure default methods";
          tailf:cli-sequence-commands;
          tailf:cli-compact-syntax;
          uses groups-and-fallback-grouping;
        }
      }

      // aaa authorization ssh-certificate
      container ssh-certificate {
        tailf:info "Configure ssh certificate";

        // aaa authorization ssh-certificate
        container default {
          tailf:info "Configure default ssh methods";

          // aaa authorization ssh-certificate default group
          leaf group {
            tailf:info "Specify server groups";
            tailf:cli-diff-dependency "/nx:aaa/group/server/tacacs-plus/id";
            tailf:cli-full-command;
            type string {
              length "1..127";
            }
          }

          // aaa authorization ssh-certificate default local
          leaf local {
            tailf:info "Use local username authentication";
            tailf:cli-full-command;
            tailf:cli-boolean-no;
            default "true";
            type boolean;
          }
        }
      }

      // aaa authorization ssh-publickey
      container ssh-publickey {
        tailf:info "Configure ssh publickey";

        // aaa authorization ssh-publickey default
        container default {
          tailf:info "Configure default ssh methods";

          // aaa authorization ssh-publickey default group
          leaf group {
            tailf:info "Specify server groups";
            tailf:cli-diff-dependency "/nx:aaa/group/server/tacacs-plus/id";
            tailf:cli-full-command;
            type string {
              length "1..127";
            }
          }

          // aaa authorization ssh-publickey default local
          leaf local {
            tailf:info "Use local username authentication";
            tailf:cli-full-command;
            tailf:cli-boolean-no;
            default "true";
            type boolean;
          }
        }
      }

      // aaa authorization cts
      container cts {
        tailf:info "Authorization methods for cts";
        tailf:cli-diff-dependency "/nx:feature/cts";
        container default {
          tailf:info "Default aaa methods";
          leaf-list group {
            tailf:cli-flat-list-syntax;
            tailf:cli-replace-all;
            type string {
              tailf:info "WORD;;Server group name";
            }
          }
        }
      }

    }

    // aaa user
    container user {
      tailf:info "Remotely authenticated user";

      // aaa user default-role
      leaf default-role {
        tailf:info "Default role assigned by aaa-admin for remote"
          +" authentication";
        tailf:cli-full-command;
        type empty;
      }
    }
  }


  /// ========================================================================
  /// acllog
  /// ========================================================================

  container acllog {
    tailf:info "Configure ACL logging";
    leaf match-log-level {
      tailf:info "Acllog logging level";
      default 6;
      type uint8 {
        tailf:info "<0-7>;;Match log level";
      }
    }
  }


  /// ========================================================================
  /// segment
  /// ========================================================================

  container segment {
    tailf:cli-diff-dependency "/nx:feature/segmentation";
    when "/nx:feature/segmentation" {
      tailf:dependency "/nx:feature/segmentation";
    }

    // segment mode unicast-only
    container mode {
      leaf unicast-only {
        tailf:cli-boolean-no;
        default "false";
        type boolean;
      }
    }

    // segment control-protocol bgp
    container control-protocol {
      leaf bgp {
        tailf:cli-boolean-no;
        default "false";
        type boolean;
      }
    }
  }


  /// ========================================================================
  /// enable
  /// ========================================================================

  container enable {
    tailf:info "Create secret for privilege escalation";
    container secret {
      tailf:info "Create secret for privilege escalation (defaults to highest priv-lvl 14/15)";
      tailf:cli-diff-dependency "/nx:feature/privilege";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf "type" {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        tailf:cli-incomplete-command;
        nx:device-transformed-dependency;
        type enumeration {
          enum "0" {
            tailf:info "Specifies an UNENCRYPTED password will follow";
          }
          enum "5" {
            tailf:info "Specifies an ENCRYPTED secret will follow";
          }
        }
      }
      leaf secret {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        nx:device-transformed-value;
        type NEDCOM_SECRET_TYPE {
          tailf:info "WORD;;Secret for privilege escalation";
          length "1..64";
        }
      }
    }
  }


  /// ========================================================================
  /// cfs
  /// ========================================================================

  container cfs {
    tailf:info "CFS configuration commands";
    leaf distribute {
      tailf:info "Enable fabric wide distribution";
      type empty;
    }
    container eth {
      tailf:info "ETH configurations";
      leaf distribute {
        tailf:info "Enable CFS distribution over Ethernet";
        tailf:cli-diff-set-before "/nx:feature/vpc";
        type empty;
      }
    }
    container ipv4 {
      tailf:info "IPv4 configurations";
      leaf distribute {
        tailf:info "Enable CFS distribution over IPv4";
        type empty;
      }
      leaf mcast-address {
        tailf:info "Configure IPv4 multicast address";
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Admin scope [239.255/16, 239.192/16-239.251/16]";
        }
      }
    }
    leaf region {
      tailf:info "Regions to limit the distribution scope of application(s)";
      type uint8 {
        tailf:info ";;<1-200>  Region Id";
        range "1..200";
      }
    }
    leaf static-peers {
      tailf:info "Enable Static peers configuration mode";
      type empty;
    }
  }


  /// ========================================================================
  /// cts
  /// ========================================================================

  container cts {
    tailf:info "Config commands for CTS";
    tailf:cli-diff-dependency "/nx:feature/cts";

    container cache {
      tailf:info "Enable Caching of Environment Data downloaded from AAA";
      leaf enable {
        type empty;
      }
    }

    container device-id {
      tailf:info "Device-id used during EAP FAST";
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-compact-syntax;

      leaf name {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type string {
          tailf:info "WORD;;Name";
        }
      }

      container password {
        tailf:info "Password used during EAP FAST";
        tailf:cli-flatten-container;
        choice pwd-type-choice {
          leaf cisco_enc {
            tailf:info "Enter encypted password used during EAP FAST";
            tailf:alt-name "7";
            type string {
              tailf:info "WORD;;Encrypted password";
            }
          }
          leaf clear {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;Clear text password";
            }
          }
        }
      }
    }

    // cts role-based
    container role-based {
      tailf:info "Configure RBACL policies";

      container counters {
        tailf:info "RBACL policy counters";
        leaf enable {
          tailf:info "Enable counters per RBACL policy";
          type empty;
        }
      }

      list sgt-map {
        tailf:info "Configure IP Address to SGT mapping";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key addr;
        leaf addr {
          type union {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP Address in format A.B.C.D";
            }
            type tailf:ipv4-address-and-prefix-length {
              tailf:info "A.B.C.D/LEN;;IPv4 Prefix";
            }
          }
        }

        leaf sgt {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-65519>;;SGT corresponding to the IP Address";
          }
        }
      }

      leaf enforcement {
        tailf:info "Enable RBACL enforcement";
        type empty;
      }
    }

    // cts sgt
    leaf sgt {
      tailf:info "SGT tag for pkts from this device";
      type string {
        tailf:info "<2-65519>;;Sgt value input as decimal or hex. Allowed hex range <0x2-0xffef>";
        pattern "0x[0-9A-F]+";
      }
    }

    // cts sxp
    container sxp {
      tailf:info "Supply configuration for SXP parameters";
      leaf enable {
        tailf:info "Enable SXP";
        type empty;
      }
      container default {
        tailf:info "Default SXP password";
        container password {
          tailf:info "SXP password";
          choice pwd-type-choice {
            leaf cisco_enc {
              tailf:info "Provide encrypted default SXP password";
              tailf:alt-name "7";
              type string {
                tailf:info "WORD;;Encrypted default SXP password";
              }
            }
            leaf clear {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "WORD;;SXP password";
              }
            }
          }
        }
        leaf source-ip {
          tailf:info "Source IP Address";
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP Address in format A.B.C.D";
          }
        }
      }
      container connection {
        tailf:info "Configuration for SXP connection";
        list peer {
          tailf:info "Configuration for peer";
          tailf:cli-suppress-mode;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-compact-syntax;
          tailf:cli-delete-when-empty;
          key "addr vrf";

          leaf addr {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP Address in format A.B.C.D";
            }
          }

          leaf source {
            tailf:cli-optional-in-sequence;
            tailf:cli-prefix-key {
              tailf:cli-before-key "2";
            }
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP Address in format A.B.C.D";
            }
          }

          leaf password {
            tailf:info "SXP password configuration";
            tailf:cli-prefix-key {
              tailf:cli-before-key "2";
            }
            type enumeration {
              enum default {
                tailf:info "Use default password";
              }
              enum none {
                tailf:info "Dont use any password";
              }
              enum required {
                tailf:info "Provide the password to be used with the SXP peer";
              }
            }
          }

          leaf cisco_enc {
            tailf:info "Provide encrypted password for SXP peer";
            tailf:cli-optional-in-sequence;
            tailf:cli-prefix-key {
              tailf:cli-before-key "2";
            }
            when "../password = 'required'" {
              tailf:dependency "../password";
            }
            tailf:alt-name "7";
            type string {
              tailf:info "WORD;;Encrypted password for SXP peer";
            }
          }

          leaf mode {
            tailf:info "SXP mode";
            tailf:cli-prefix-key {
              tailf:cli-before-key "2";
            }
            type enumeration {
              enum listener {
                tailf:info "SXP listener";
              }
              enum speaker {
                tailf:info "SXP speaker";
              }
            }
          }

          leaf vrf {
            tailf:cli-expose-key-name;
            tailf:non-strict-leafref {
              path "/nx:vrf/context/id";
            }
            type vrf-member-type;
          }
        }
      }
    }
  }


  /// ========================================================================
  /// username
  /// ========================================================================


  list username {
    tailf:info "Establish User Name Authentication";
    tailf:cli-compact-syntax;
    tailf:cli-sequence-commands {
      tailf:cli-reset-siblings;
    }
    tailf:cli-suppress-mode;
    tailf:cli-delete-when-empty;
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;User name";
      }
    }

    container password {
      tailf:info "Specify the password for the user";
      tailf:cli-compact-syntax;
      tailf:cli-flatten-container;
      tailf:cli-sequence-commands;
      tailf:cli-reset-container;
      leaf encryption {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        nx:device-transformed-dependency;
        type enumeration {
          enum "0" {
            tailf:info "Specifies an UNENCRYPTED password will follow";
          }
          enum "5" {
            tailf:info "Specifies a HIDDEN password will follow";
          }
        }
      }
      leaf password {
        tailf:cli-drop-node-name;
        tailf:cli-disallow-value "5|0";
        nx:device-transformed-value;
        tailf:cli-incomplete-command;
        type NEDCOM_SECRET_TYPE {
          tailf:info "WORD;;The HIDDEN user password string";
        }
      }
    }

    leaf expire {
      tailf:info "Expiry date for this user account(in YYYY-MM-DD format)";
      tailf:cli-optional-in-sequence;
      type string {
        tailf:info "WORD;;Expiry in YYYY-MM-DD format (Max Size 10)";
      }
    }

    leaf role {
      tailf:info "Role which the user is to be assigned to";
      tailf:non-strict-leafref {
        path "/nx:role/name/name";
      }
      type user-role-type;
    }
  }

  // username * role
  container username-secondary-roles {
    tailf:cli-drop-node-name;
    list username {
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-diff-create-after "/nx:snmp-server/user" {
        tailf:cli-when-target-create;
      }
      key "name role";
      leaf name {
        tailf:non-strict-leafref {
          path "/nx:username/name";
        }
        type string {
          tailf:info "WORD;;User name";
        }
      }
      leaf role {
        tailf:cli-expose-key-name;
        tailf:non-strict-leafref {
          path "/nx:role/name/name";
        }
        type user-role-type;
      }
    }
  }

  container username-config {
    tailf:cli-drop-node-name;
    list username {
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        tailf:non-strict-leafref {
          path "/nx:username/name";
        }
        type string {
          tailf:info "WORD;;User name";
        }
      }

      container sshkey {
        tailf:info "Update ssh key for the user for ssh authentication";
        leaf file {
          tailf:info "Ssh key file";
          type string;
        }
        leaf openssh-key {
          tailf:cli-drop-node-name;
          tailf:cli-multi-value;
          type string {
            tailf:info "LINE;;Ssh key for the user";
          }
        }
      }

      container passphrase {
        tailf:info "User passphrase";
        tailf:cli-compact-syntax;
        leaf gracetime {
          tailf:info "User passphrase gracetime";
          type uint32 {
            tailf:info "<0-99999>;;Grace period of passphrase (in days)";
            range "0..99999";
          }
        }
        leaf lifetime {
          tailf:info "User passphrase lifetime";
          type uint32 {
            tailf:info "<0-99999>;;Lifetime of passphrase (in days)";
            range "0..99999";
          }
        }
        leaf warntime {
          tailf:info "User passphrase warningtime";
          type uint32 {
            tailf:info "<0-99999>;;Warning period of passphrase (in days)";
            range "0..99999";
          }
        }
      }

      container keypair {
        container generate {
          leaf rsa {
            type empty;
          }
        }
      }
    }
  }


  /// ========================================================================
  /// nxapi
  /// ========================================================================

  container nxapi {
    tailf:info "Configure nxapi";
    tailf:cli-diff-dependency "/nx:feature/nxapi";

    container http {
      tailf:info "Http configuration";
      leaf port {
        tailf:info "Port number";
        default 80;
        type uint16 {
          tailf:info "<1-65535>;;Port number. Please do not use well-known protocol ports";
        }
      }
    }

    container https {
      tailf:info "Https configuration";
      leaf port {
        tailf:info "Port number";
        default 443;
        type uint16 {
          tailf:info "<1-65535>;;Port number. Please do not use well-known protocol ports";
        }
      }
    }

    leaf use-vrf {
      tailf:info "Vrf to be used for nxapi communication";
      tailf:non-strict-leafref {
        path "/nx:vrf/context/id";
      }
      type vrf-member-type;
    }
  }


  /// ========================================================================
  /// banner
  /// ========================================================================

  container banner {
    tailf:info "Define a login banner";

    grouping banner-body-grouping {
      leaf start-marker {
        tailf:cli-drop-node-name;
        tailf:cli-no-value-on-delete;
        type string;
      }
      leaf message {
        tailf:cli-drop-node-name;
        tailf:cli-multi-line-prompt;
        tailf:cli-no-value-on-delete;
        type string;
      }
      leaf end-marker {
        tailf:cli-drop-node-name;
        tailf:cli-no-value-on-delete;
        type string;
        must "../end-marker = ../start-marker" {
          tailf:dependency "../end-marker";
          tailf:dependency "../start-marker";
        }
      }
    }

    container exec {
      tailf:info "Set EXEC process creation banner";
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-compact-syntax;
      cli:multi-line-banner {
        cli:json-arguments '{ "text":"message", "start-delim":"start-marker", "end-delim":"end-marker", "eol":"\n" }';
        when "/tailfned/is-netsim='false'";
      }
      uses banner-body-grouping;
    }

    container motd {
      tailf:info "Set Message of the Day banner";
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-compact-syntax;
      cli:multi-line-banner {
        cli:json-arguments '{ "text":"message", "start-delim":"start-marker", "end-delim":"end-marker", "eol":"\n" }';
        when "/tailfned/is-netsim='false'";
      }
      uses banner-body-grouping;
    }
  }


  /// ========================================================================
  /// ssh
  /// ========================================================================

  container ssh {
    tailf:info "Configure SSH parameters";
    container key {
      tailf:info "Generate SSH Key";
      leaf rsa {
        type uint16;
      }
    }

    leaf login-attempts {
      tailf:info "Set maximum login attempts from ssh";
      default 3;
      type uint8 {
        tailf:info "<1-10>;;Specify max-attempt number";
      }
    }
  }


  /// ========================================================================
  /// fabric
  /// ========================================================================
  container fabric {
    tailf:info "Fabric";
    container forwarding {
      tailf:info "Forwarding.";
      leaf anycast-gateway-mac {
        tailf:info "MAC";
        tailf:cli-diff-delete-before "/nx:feature/fabric/forwarding";
        tailf:cli-diff-delete-before "/nx:nv/overlay/evpn";
        tailf:cli-diff-delete-after "/nx:interface/Vlan/fabric/forwarding/mode";
        type string;
      }
    }
  }


  /// ========================================================================
  /// fabricpath
  /// ========================================================================
  container fabricpath {
    tailf:info "Fabricpath configuration";
    // fabricpath domain
    container domain {
      tailf:info "Enter fabricpath IS-IS domain configuration mode";
      // fabricpath domain default
      container default {
        tailf:info "Default fabricpath domain";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-fabricpath-isis";
        tailf:cli-diff-dependency "/nx:feature-set/fabricpath" {
          tailf:cli-trigger-on-set;
        }
        presence "true";
        nx:delete-with "none";
        // fabricpath domain default / spf-interval
        container spf-interval {
          tailf:info "Configure SPF interval";
          tailf:cli-sequence-commands;
          tailf:cli-compact-syntax;
          uses isis-spf-interval-grouping;
        }
        // fabricpath domain default / lsp-gen-interval
        container lsp-gen-interval {
          tailf:info "Configure LSP generation interval";
          tailf:cli-sequence-commands;
          tailf:cli-compact-syntax;
          uses isis-lsp-gen-interval-grouping;
        }
        // fabricpath domain default / root-priority
        leaf root-priority {
          tailf:info "Set priority with which nodes becomes root";
          type uint8 {
            tailf:info "<1-255>;;Root priority value per topology";
            range "1..255";
          }
        }

        // fabricpath domain default / set-overload-bit
        container set-overload-bit {
          tailf:info "Signal other routers not to use us for transit";
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-compact-syntax;
          choice always-or-startup-choice {
            leaf always {
              tailf:info "Set the overload bit unconditionally";
              type empty;
            }
            leaf on-startup {
              tailf:info "Set the overload bit on IS-IS startup";
              type uint32 {
                tailf:info "<5-86400>;;Clear the overload bit after an elapsed time in seconds";
              }
            }
          }
        }
        container fabricpath {
          tailf:info "Configure fabricpath global commands";
          container isis {
            tailf:info "Fabricpath IS-IS global commands";
            list event-history {
              tailf:info "Configure event-history buffers";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key event;
              leaf event {
                type enumeration {
                  enum adjacency { tailf:info "Adjacency events"; }
                  enum cli { tailf:info "CLI events"; }
                  enum csnp { tailf:info "CSNP events"; }
                  enum drap { tailf:info "DRAP events"; }
                  enum events { tailf:info "Message and high-level events"; }
                  enum graceful { tailf:info "Graceful Restart events"; }
                  enum ha { tailf:info "High-Availability events"; }
                  enum iih { tailf:info "Interface hello events"; }
                  enum lsp-flood { tailf:info "LSP-flood events"; }
                  enum lsp-gen { tailf:info "LSP-Gen events"; }
                  enum m2rib { tailf:info "M2rib events"; }
                  enum mccast { tailf:info "Mccast events"; }
                  enum psnp { tailf:info "PSNP events"; }
                  enum redist { tailf:info "Redistribution events"; }
                  enum spf-leaf { tailf:info "Shortest path first events"; }
                  enum spf-tree { tailf:info "SPF-Tree events"; }
                  enum urib { tailf:info "URIB events"; }
                }
              }
              leaf size {
                tailf:info "Configure size";
                type union {
                  type enumeration {
                    enum disabled { tailf:info "Disabled"; }
                    enum large { tailf:info "Large buffer"; }
                    enum medium { tailf:info "Medium buffer"; }
                    enum small { tailf:info "Small buffer"; }
                  }
                  type uint32;
                }
              }
            }
          }
        }

        container address-family {
          container ipv4 {
            container unicast {
              presence true;
            }
          }
          container ipv6 {
            container unicast {
              presence true;
            }
          }
        }

        list topology {
          tailf:info "Configure Layer-2 Topology for IS-IS";
          key id;
          leaf id {
            type uint8 {
              tailf:info "<1-63>;;L2 Topology ID 1-63";
            }
          }
          leaf maximum-paths {
            tailf:info "Set maximum paths per destination";
            default 16;
            type uint8 {
              tailf:info "<1-16>;;Maximum paths per destination";
            }
          }
          container reference-bandwidth {
            tailf:info "Change reference bandwidth used for setting interface metric";
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            tailf:cli-compact-syntax;
            leaf value {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<1-4000000>;;Bandwidth in Mbps/Gbps (default)";
              }
            }
            leaf Mbps {
              tailf:info "Specify in Mbps";
              type empty;
            }
          }
          leaf root-priority {
            tailf:info "Set priority with which nodes becomes root";
            default 64;
            type uint8 {
              tailf:info "<1-255>;;Root priority value per topology";
            }
          }
        }
      }
    }
    // fabricpath graceful-merge
    container graceful-merge {
      tailf:info "Graceful merging of netwoks";
      // fabricpath graceful-merge disable
      leaf disable {
        tailf:info "Disable graceful merge of networks";
        type empty;
      }
    }
    // Skip: fabricpath linkup-delay
    // Skip: fabricpath load-balance
    // fabricpath mode
    container mode {
      tailf:info "Mode";
      // fabricpath mode transit
      leaf transit {
        tailf:info "Enable this system to switch traffic based on switch_id wit"
          +"h no segmentation support";
        type empty;
      }
    }
    // Skip: fabricpath multicast
    // Skip: fabricpath oam
    // Skip: fabricpath route
    // fabricpath switch-id
    leaf switch-id {
      tailf:info "Statically configured switch-id";
      type uint16 {
        tailf:info "<1-4094>;;Switch-id-value";
        range "1..4094";
      }
    }
    // fabricpath timers
    container timers {
      tailf:info "Fabricpath switch-id timers";
      // Skip: allocate-delay    Time delay new resource propagation
      leaf linkup-delay {
        tailf:info "Time delay for link bringup for detecting conflicts";
        type union {
          type uint16 {
            tailf:info "<1-1200>;;Timer value in seconds";
            range "1..1200";
          }
          type enumeration {
            enum always {
              tailf:info "This will always enforce the link-up delay for all co"
              +"re ports. The default behavior does not use the timer in know"
              +"n networks to optimize link bring-up.";
            }
          }
        }
      }
      // Skip: transition-delay  Time delay transitiond value propagation
    }

    // Skip: fabricpath topology
    // fabricpath ttl
    container ttl {
      tailf:info "Configure TTL value";
      // fabricpath ttl multicast
      leaf multicast {
        tailf:info "Configure multicast TTL value";
        tailf:cli-no-value-on-delete;
        type uint8 {
          tailf:info "1-64;;Value of TTL in number of hops. Default is 32.";
          range "1..64";
        }
      }
      // fabricpath ttl unicast
      leaf unicast {
        tailf:info "Configure unicast TTL value";
        tailf:cli-no-value-on-delete;
        type uint8 {
          tailf:info "1-64;;Value of TTL in number of hops. Default is 32.";
          range "1..64";
        }
      }
    }
  }


  /// ========================================================================
  /// ip
  /// ========================================================================

  container ip {
    tailf:info "Configure IP features";

    // ip as-path
    container as-path {
      tailf:info "BGP autonomous system path filter";
      list access-list {
        tailf:info "Specify an access list name";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;AS path access list name (Max Size 63)";
            length "1..63";
          }
        }
        list seq {
          tailf:info "Sequence number of an entry";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          key num;
          leaf num {
            tailf:cli-diff-delete-before "../../seq/num" {
              tailf:cli-when-target-set;
            }
            type uint32 {
              tailf:info "<1-4294967294>;;Sequence number";
            }
          }
          leaf action {
            tailf:cli-drop-node-name;
            type enumeration {
              enum deny { tailf:info "Specify packets to reject"; }
              enum permit { tailf:info "Specify packets to forward"; }
            }
          }
          leaf regex {
            tailf:cli-drop-node-name;
            nx:escape-questionmark;
            type string {
              tailf:info "LINE;;A regular-expression to match BGP AS paths. Use \"ctrl-v ?\" to enter \"?\". (Max Size 63)";
            }
          }
        }
        list unsequenced {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-show-long-obu-diffs;
          ordered-by user;
          key regex;
          leaf regex {
            nx:escape-questionmark;
            type string {
              tailf:info "LINE;;A regular-expression to match BGP AS paths. (Max Size 63)";
            }
          }
          leaf action {
            tailf:cli-prefix-key;
            tailf:cli-drop-node-name;
            type enumeration {
              enum deny { tailf:info "Specify packets to reject"; }
              enum permit { tailf:info "Specify packets to forward"; }
            }
          }
        }
      }
    }

    // ip community-list
    container community-list {
      tailf:info "Add a community list entry";
      list standard {
        tailf:info "Add a standard Community list entry";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Standard community list name (Max Size 63)";
            length "1..63";
          }
        }
        choice entry-syntax-choice {
          list entry {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            ordered-by user;
            key community-spec;
            leaf community-spec {
              tailf:cli-multi-word-key;
              type string {
                tailf:info "<internet> <local-AS> <no-advertise> <no-export> <ASN2:NN>";
                pattern "(internet|local-AS|no-advertise|no-export|([0-9]+:[0-9]+))( (internet|local-AS|no-advertise|no-export|([0-9]+:[0-9]+)))*";
              }
            }
            leaf type {
              tailf:cli-drop-node-name;
              tailf:cli-prefix-key;
              mandatory true;
              type enumeration {
                enum deny {
                  tailf:info "Specify community to reject";
                }
                enum permit {
                  tailf:info "Specify community to accept";
                }
              }
            }
          }
          list seq-entry {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            tailf:cli-compact-syntax;
            tailf:cli-incomplete-command;
            key seq;
            leaf seq {
              tailf:cli-expose-key-name;
              tailf:cli-diff-delete-before "../../seq-entry/seq";
              type uint32 {
                tailf:info "<1-4294967294>;;Sequence number";
              }
            }
            leaf type {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              tailf:cli-remove-before-change;
              mandatory true;
              type enumeration {
                enum deny {
                  tailf:info "Specify community to reject";
                }
                enum permit {
                  tailf:info "Specify community to accept";
                }
              }
            }
            leaf-list community {
              tailf:cli-drop-node-name;
              tailf:cli-flat-list-syntax;
              type union {
                type enumeration {
                  enum internet {
                    tailf:info "Internet (well-known community)";
                  }
                  enum local-AS {
                    tailf:info "Do not send outside local AS (well-known community)";
                  }
                  enum no-advertise {
                    tailf:info "Do not advertise to any peer (well-known community)";
                  }
                  enum no-export {
                    tailf:info "Do not export to next AS (well-known community)";
                  }
                }
                type string {
                  tailf:info "ASN2:NN;;Community number aa:nn format";
                  pattern "[0-9]+:[0-9]+";
                }
              }
            }
          }
        }
      }
      list expanded {
        tailf:info "Add an expanded community list entry";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of expanded community list (Max Size 63)";
            length "1..63";
          }
        }
        choice entry-syntax-choice {
          list entry {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            ordered-by user;
            key regexp;
            leaf regexp {
              tailf:cli-multi-word-key;
              tailf:cli-disallow-value "seq [0-9]+.*";
              type string {
                tailf:info "LINE;;Regular-expression(must use aa:nn format). (Max Size 63)";
                length "1..63";
              }
            }
            leaf type {
              tailf:cli-drop-node-name;
              tailf:cli-prefix-key;
              mandatory true;
              type enumeration {
                enum deny {
                  tailf:info "Specify community to reject";
                }
                enum permit {
                  tailf:info "Specify community to accept";
                }
              }
            }
          }
          list seq-entry {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            tailf:cli-compact-syntax;
            tailf:cli-incomplete-command;
            key seq;
            leaf seq {
              tailf:cli-expose-key-name;
              type uint32 {
                tailf:info "<1-4294967294>;;Sequence number";
              }
            }
            leaf type {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              mandatory true;
              type enumeration {
                enum deny {
                  tailf:info "Specify community to reject";
                }
                enum permit {
                  tailf:info "Specify community to accept";
                }
              }
            }
            leaf regexp {
              tailf:cli-multi-value;
              tailf:cli-drop-node-name;
              type string {
                tailf:info "LINE;;Regular-expression(must use aa:nn format). (Max Size 63)";
                length "1..63";
              }
            }
          }
        }
      }
    }

    container extcommunity-list {
      tailf:info "Add a extcommunity list entry";
      list expanded {
        tailf:info "Add an expanded extcommunity list entry";
        tailf:cli-suppress-mode;
        key "name regex";
        leaf name {
          type string {
            tailf:info "WORD;;Name of expanded extcommunity list (Max Size 63)";
          }
        }
        leaf perm {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key {
            tailf:cli-before-key "2";
          }
          type enumeration {
            enum deny {
              tailf:info "Specify extcommunity to reject";
            }
            enum permit {
              tailf:info "Specify extcommunity to accept";
            }
          }
        }
        leaf regex {
          nx:escape-questionmark;
          type string {
            tailf:info "LINE;;Regular-expression(must use aa:nn format). Use 'ctrl-v ?' to enter '?'. (Max Size 63)";
          }
        }
      }

      list standard {
        tailf:info "Add a standard Extcommunity list entry";
        tailf:cli-suppress-mode;
        key "name spec";
        leaf name {
          type string {
            tailf:info "WORD;;Standard extcommunity list name (Max Size 63)";
          }
        }
        leaf perm {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key {
            tailf:cli-before-key "2";
          }
          type enumeration {
            enum deny {
              tailf:info "Specify extcommunity to reject";
            }
            enum permit {
              tailf:info "Specify extcommunity to accept";
            }
          }
        }
        leaf spec {
          tailf:cli-multi-word-key;
          type string {
            tailf:info "4byteas-generic|rt|soo <value> pairs as entered on device";
          }
        }
      }
    }

    // ip dhcp
    container dhcp {
      tailf:info "Configure DHCP snooping and relay";
      when "../../feature/dhcp" {
        tailf:dependency "../../feature/dhcp";
      }
      tailf:cli-diff-dependency "/nx:feature/dhcp";
      leaf relay {
        tailf:cli-show-with-default;
        tailf:cli-full-command;
        default true;
        tailf:cli-boolean-no;
        type boolean;
      }
      container relay-config {
        tailf:cli-drop-node-name;
        container relay {
          tailf:cli-incomplete-command;
          // ip dhcp relay information
          container information {
            tailf:info "Relay agent information option";
            container option {
              tailf:info "Insert relay information in BOOTREQUEST";
              presence true;
              tailf:cli-display-separated;
              leaf vpn {
                tailf:info "Enable relay support across VRFs";
                type empty;
              }
              leaf trust {
                tailf:info "Enable relay trust functionality on the system";
                type empty;
              }
            }
            leaf trust-all {
              tailf:info "Enable relay trust on all the interfaces";
              type empty;
            }
          }
          // ip dhcp relay sub-option
          container sub-option {
            tailf:info "Relay agent suboption";
            container type {
              tailf:info "Relay agent suboption type";
              leaf cisco {
                tailf:info "Use Cisco propritery suboptions";
                type empty;
              }
            }
          }
        }
      }
      // ip dhcp snooping
      leaf snooping {
        tailf:cli-full-command;
        type empty;
      }
      container snooping-config {
        tailf:cli-drop-node-name;
        container snooping {
          tailf:cli-incomplete-command;
          // dhcp snooping information
          container information {
            tailf:info "DHCP Snooping information";
            leaf option {
              tailf:info "DHCP Snooping information option";
              tailf:cli-full-command;
              type empty;
            }
          }
          // ip dhcp snooping verify
          container verify {
            tailf:info "DHCP snooping verify";
            leaf mac-address {
              tailf:info "DHCP snooping verify mac-address";
              tailf:cli-boolean-no;
              default true;
              type boolean;
            }
          }
          // ip dhcp snooping vlan
          list vlan {
            tailf:info "DHCP Snooping vlan";
            tailf:cli-suppress-mode;
            tailf:cli-range-list-syntax;
            key id;
            leaf id {
              type uint16 {
                tailf:info "<1-3967,4048-4093>;;VLAN ID 1-4094 or "
                  +"range(s): 1-5, 10 or 2-5,7-19";
                range "1..4096";
              }
            }
          }
        }
      }
      // ip dhcp smart-relay
      container smart-relay {
        tailf:info "Configure DHCP smart relay";
        leaf global {
          tailf:info "Configure DHCP smart relay globally";
          type empty;
        }
      }
      // ip dhcp packet
      container packet {
        tailf:info "DHCP packet";
        leaf strict-validation {
          tailf:info "DHCP packet strict validation";
          type empty;
        }
      }
    }

    // ip dns
    container dns {
      tailf:info "Configure dns client";
      tailf:cli-diff-dependency "/nx:interface";
      // Workaround for strange behaviour: dns is returned as domain-lookup
      cli:parse-alt-name "domain-lookup";
      // ip dns source-interface
      list source-interface {
        tailf:cli-suppress-mode;
        key vrf;
        leaf vrf {
          tailf:cli-expose-key-name;
          tailf:key-default "default";
          tailf:non-strict-leafref {
            path "/nx:vrf/context/id";
          }
          type vrf-member-type;
        }
        leaf interface-name {
          tailf:cli-prefix-key;
          tailf:cli-drop-node-name;
          tailf:info "Configure source interface feature for domain-lookup";
          nx:case-insensitive-type;
          type string {
            pattern "(([Ee]thernet)|([Ll]oopback)|([Pp]ort-channel)|([Vv]lan)|([Bb]di)|([Mm]gmt))[0-9/\\.]+";
          }
        }
      }
    }

    // ip ftp
    container ftp {
      tailf:info "Configure FTP client";
      tailf:cli-diff-dependency "/nx:interface";
      list source-interface {
        tailf:cli-suppress-mode;
        key vrf;
        leaf vrf {
          tailf:cli-expose-key-name;
          tailf:key-default "default";
          tailf:non-strict-leafref {
            path "/nx:vrf/context/id";
          }
          type vrf-member-type;
        }
        leaf interface-name {
          tailf:cli-prefix-key;
          tailf:cli-drop-node-name;
          tailf:info "Configure source interface feature for FTP client";
          nx:case-insensitive-type;
          type string {
            pattern "(([Ee]thernet)|([Ll]oopback)|([Pp]ort-channel)|([Vv]lan)|([Bb]di)|([Mm]gmt))[0-9/\\.]+";
          }
        }
      }
    }

    // ip telnet
    container telnet {
      tailf:info "Configure telnet client";
      tailf:cli-diff-dependency "/nx:interface";
      // ip tftp source-interface
      list source-interface {
        tailf:cli-suppress-mode;
        key vrf;
        leaf vrf {
          tailf:cli-expose-key-name;
          tailf:key-default "default";
          tailf:non-strict-leafref {
            path "/nx:vrf/context/id";
          }
          type vrf-member-type;
        }
        leaf interface-name {
          tailf:cli-prefix-key;
          tailf:cli-drop-node-name;
          tailf:info "Configure source interface feature for telnet client";
          nx:case-insensitive-type;
          type string {
            pattern "(([Ee]thernet)|([Ll]oopback)|([Pp]ort-channel)|([Vv]lan)|([Bb]di)|([Mm]gmt))[0-9/\\.]+";
          }
        }
      }
    }

    // ip tftp
    container tftp {
      tailf:info "Configure TFTP client";
      tailf:cli-diff-dependency "/nx:interface";
      // ip tftp source-interface
      list source-interface {
        tailf:cli-suppress-mode;
        key vrf;
        leaf vrf {
          tailf:cli-expose-key-name;
          tailf:key-default "default";
          tailf:non-strict-leafref {
            path "/nx:vrf/context/id";
          }
          type vrf-member-type;
        }
        leaf interface-name {
          tailf:cli-prefix-key;
          tailf:cli-drop-node-name;
          tailf:info "Configure source interface feature for TFTP client";
          nx:case-insensitive-type;
          type string {
            pattern "(([Ee]thernet)|([Ll]oopback)|([Pp]ort-channel)|([Vv]lan)|([Bb]di)|([Mm]gmt))[0-9/\\.]+";
          }
        }
      }
    }

    // ip access-list
    container access-list {
      tailf:info "Configure access list";

      // ip access-list match-local-traffic
      leaf match-local-traffic {
        tailf:info "Enable access-list matching for locally generated traffic";
        tailf:cli-full-command;
        type empty;
      }

      // ip access-list *
      list list-name {
        tailf:cli-drop-node-name;
        tailf:cli-mode-name "config-acl";
        tailf:cli-full-command;
        key id;
        leaf id {
          tailf:cli-disallow-value "match-local-traffic";
          type string {
            tailf:info "WORD;;List name (Max Size 64)";
            length "1..64";
          }
        }

        uses ip-access-list-common-grouping;

        // ip access-list * / *
        list sequence {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          tailf:cli-sequence-commands {
            tailf:cli-reset-all-siblings;
          }
          tailf:cli-compact-syntax;
          tailf:cli-remove-before-change;
          key id;
          leaf id {
            type uint32 {
              tailf:info "<1-4294967295>;;Sequence number";
              range "1..4294967295";
            }
          }

          leaf action {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type enumeration {
              enum "deny" {
                tailf:info "Specify packets to reject";
              }
              enum "permit" {
                tailf:info "Specify packets to forward";
              }
              enum "remark" {
                tailf:info "Access list entry comment";
              }
            }
          }

          uses ip-access-list-grouping {
            when "action != 'remark'";
          }

          leaf remark-value {
            tailf:cli-multi-value;
            tailf:cli-drop-node-name;
            tailf:cli-full-command;
            when "../action = 'remark'";
            type string {
              tailf:info "LINE;;Comment, up to 100 characters (Max Size 100)";
              length "1..100";
            }
          }
        }
      }
    }

    uses ip-grouping {
      augment multicast {
        leaf overlay-distributed-dr {
          tailf:info "Configure node as Distributed-DR";
          tailf:cli-diff-delete-before "/nx:feature/ngmvpn";
          type empty;
        }
        leaf overlay-spt-only {
          tailf:info "Distributed PIM-RP/PIM-RP-less design";
          tailf:cli-diff-delete-before "/nx:feature/ngmvpn";
          type empty;
        }
      }
    }

    // no ip source-route
    leaf source-route {
      tailf:info "IP source routing option";
      tailf:cli-boolean-no;
      default true;
      type boolean;
    }

    container source {
      tailf:info "IP source";
      list binding {
        tailf:info "Static binding";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "address mac vlan";
        tailf:cli-diff-delete-before "/nx:ip/source/binding" {
          tailf:cli-when-target-set;
        }
        leaf address {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP address";
          }
        }
        leaf mac {
          type mac-address-type;
        }
        leaf vlan {
          tailf:info "VLAN";
          tailf:cli-expose-key-name;
          type uint16 {
            tailf:info "<1-3967,4048-4093>;;VLAN id";
          }
        }
        container interface {
          tailf:info "Interface";
          leaf Ethernet {
            tailf:info "Ethernet IEEE 802.3z";
            tailf:cli-allow-join-with-value {
              tailf:cli-display-joined;
            }
            tailf:non-strict-leafref {
              path "/nx:interface/Ethernet/name";
            }
            tailf:cli-diff-set-after "../port-channel" {
              tailf:cli-when-target-delete;
            }
            tailf:cli-diff-delete-before "../port-channel" {
              tailf:cli-when-target-set;
            }
            type string {
              tailf:info "<1-253>/<1-256>;;Slot/chassis number";
            }
          }
          leaf port-channel {
            tailf:info "Port Channel interface";
            tailf:cli-allow-join-with-value {
              tailf:cli-display-joined;
            }
            tailf:non-strict-leafref {
              path "/nx:interface/port-channel/name";
            }
            type string {
              tailf:info "<1-4096>;;Port Channel number";
            }
          }
        }
      }
    }


    // ip igmp
    container igmp {
      tailf:info "IGMP global configuration commands";
      container snooping {
        tailf:info "Configures IGMP Snooping";
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        leaf optimise-multicast-flood {
          tailf:info "Configures Optimized Multicast Flood (OMF) on all VLAN/BDs";
          tailf:cli-boolean-no;
          default true;
          type boolean;
        }
        leaf vxlan {
          tailf:info "Configures Snooping for vxlan vlans";
          type empty;
        }
        container vxlan-umc {
          tailf:info "Turn off flooding on VLANs";
          choice drop-all-or-some-choice {
            leaf drop {
              tailf:info "Drop unknown multicast traffic on all VLANs";
              tailf:cli-full-command;
              type empty;
            }
            container drop-vlan {
              tailf:cli-drop-node-name;
              container drop {
                tailf:info "Drop unknown multicast traffic on all VLANs";
                tailf:cli-incomplete-command;
                tailf:cli-incomplete-no;
                leaf-list vlan {
                  tailf:info "VLAN list to drop the unknown multicast traffic";
                  tailf:cli-range-list-syntax;
                  tailf:cli-replace-all;
                  type uint16 {
                    tailf:info "<1-4096>;;VLAN IDs for which unknown multicast traffic is dropped";
                  }
                }
              }
            }
          }
        }
        container mrouter {
          tailf:info "Configures static multicast router interface";
          leaf vpc-peer-link {
            tailf:info "Specify vpc-peer-link as static mrouter for all VLAN/BDs";
            tailf:cli-boolean-no;
            default true;
            type boolean;
          }
        }
        leaf link-local-groups-suppression {
          tailf:info "Configures Global link-local groups suppression";
          tailf:cli-boolean-no;
          default true;
          type boolean;
        }
        leaf report-suppression {
          tailf:info "Configures Global IGMPv1/IGMPv2 Report Suppression";
          tailf:cli-boolean-no;
          default true;
          type boolean;
        }
        leaf v3-report-suppression {
          tailf:info "Configures Global IGMPv3 Report Suppression and Proxy Reporting";
          type empty;
        }
      }
      container enable-disable-snooping {
        tailf:cli-drop-node-name;
        leaf snooping {
          tailf:info "Configures IGMP Snooping";
          type boolean;
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          default true;
        }
      }
      leaf flush-routes {
        tailf:info "Remove routes when restarting IGMP";
        type empty;
      }
    }

    // ip nat
    container nat {
      tailf:info "NAT configuration commands";
      when "/nx:feature/nat" {
        tailf:dependency "/nx:feature/nat";
      }
      tailf:cli-diff-dependency "/nx:feature/nat";
      // ip nat pool
      list pool {
        tailf:info "Define pool of addresses";
        tailf:cli-suppress-mode;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-remove-before-change;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Pool name (Max Size 64)";
          }
        }
        leaf start-ip {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Start IP address";
          }
        }
        leaf end-ip {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;End IP address";
          }
        }
        choice mask-or-len {
          leaf netmask {
            tailf:info "Specify the network mask";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Network mask";
            }
          }
          leaf prefix-length {
            tailf:info "Specify the prefix length";
            type uint8 {
              tailf:info "<1-32>;;Prefix length";
              range "1..32";
            }
          }
        }
        leaf no-alias {
          tailf:info "Do not create alias for these pool addresses";
          type empty;
        }
      }
      // ip nat inside
      container inside {
        tailf:info "Inside address translation";
        // ip nat inside source
        container source {
          tailf:info "Source address translation";
          // ip nat inside source list *
          list list {
            tailf:info "Access-list";
            tailf:cli-suppress-mode;
            tailf:cli-sequence-commands;
            tailf:cli-compact-syntax;
            tailf:cli-remove-before-change;
            key "name interface ifoverload";
            leaf name {
              type string {
                tailf:info "WORD;;Access-list-name (Max Size 64)";
                length "1..64";
              }
            }
            leaf interface {
              tailf:info "Interface";
              tailf:cli-expose-key-name;
              type string {
                tailf:info "WORD;;Interface name";
              }
            }
            leaf vrf {
              tailf:info "Specify vrf";
              tailf:cli-prefix-key {
                tailf:cli-before-key "3";
              }
              tailf:cli-optional-in-sequence;
              type string {
                tailf:info "WORD;;Vrf name (Max Size 31)";
              }
            }
            leaf match-in-vrf {
              tailf:info "Match incoming vrf";
              tailf:cli-prefix-key {
                tailf:cli-before-key "3";
              }
              tailf:cli-optional-in-sequence;
              when "../vrf" {
                tailf:dependency "../vrf";
              }
              type empty;
            }
            leaf ifoverload {
              type enumeration {
                enum overload {
                  tailf:info "Interface overload";
                }
              }
            }
          }
          container list-pool {
            tailf:cli-drop-node-name;
            list list {
              tailf:info "Access-list";
              tailf:cli-suppress-mode;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              tailf:cli-compact-syntax;
              tailf:cli-remove-before-change;
              key "name";
              leaf name {
                type string {
                  tailf:info "WORD;;Access-list-name (Max Size 64)";
                  length "1..64";
                }
              }
              leaf pool {
                tailf:info "Interface";
                mandatory true;
                type string {
                  tailf:info "WORD;;Interface name";
                }
              }
              leaf vrf {
                tailf:info "Specify vrf";
                tailf:cli-optional-in-sequence;
                type string {
                  tailf:info "WORD;;Vrf name (Max Size 31)";
                }
              }
              leaf overload {
                tailf:info "Interface overload";
                tailf:cli-optional-in-sequence;
                type empty;
              }
              leaf add-route {
                tailf:info "Add a static route for outside local address";
                type empty;
              }
            }
          }
          container static {
            tailf:info "Specify static local->global mapping";
            list local-map {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              key "iaddress gaddress";
              leaf iaddress {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Inside local IP address";
                }
              }
              leaf gaddress {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Inside global IP address";
                }
              }
            }
            // skip: tcp       Transmission Control Protocol
            // skip: udp      User Datagram Protocol
          }
        }
      }
      // ip nat outside
      container outside {
        container source {
          tailf:info "Source address translation";
          list list {
            tailf:info "Specify access list describing local addresses";
            tailf:cli-suppress-mode;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            tailf:cli-compact-syntax;
            tailf:cli-remove-before-change;
            tailf:cli-delete-when-empty;
            key "name pool";
            leaf name {
              type string {
                tailf:info "WORD;;Access-list-name (Max Size 64)";
              }
            }
            leaf pool {
              tailf:info "Name pool of global addresses";
              tailf:cli-expose-key-name;
              type string {
                tailf:info "WORD;;Pool name for global addresses (Max Size 64)";
              }
            }
            leaf vrf {
              tailf:info "Specify vrf";
              tailf:cli-optional-in-sequence;
              type string {
                tailf:info "WORD;;Vrf name (Max Size 31)";
              }
            }
            leaf add-route {
              tailf:info "Add a static route for outside local address";
              type empty;
            }
          }
          container static {
            tailf:info "Specify static local->global mapping";
            list local-map {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              key "gaddress laddress";
              leaf gaddress {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Outside global IP address";
                }
              }
              leaf laddress {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Outside local IP address";
                }
              }
            }
          }
        }
      }
      // ip nat translation
      container translation {
        tailf:info "NAT translation entry configuration";
        leaf max-entries {
          tailf:info "Specify maximum number of NAT dynamic entries";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<1-1023>;;Number of entries";
            range "1..1023";
          }
        }
        container max-entries-all-host {
          tailf:cli-drop-node-name;
          container max-entries {
            tailf:info "Specify maximum number of NAT dynamic entries";
            leaf all-host {
              tailf:info "Specify maximum number of NAT entries for each host";
              type uint16 {
                tailf:info "<1-1023>;;Number of entries";
              }
            }
          }
        }
        leaf tcp-timeout {
          tailf:info "Specify timeout for NAT TCP flows";
          type uint32 {
            tailf:info "<1-172800>;;Timeout in seconds (max: 2days)";
            range "1..172800";
          }
        }
        leaf timeout {
          tailf:info "Specify timeout for dynamic NAT translations";
          type uint32 {
            tailf:info "<1-172800>;;Timeout in seconds (max: 2days)";
            range "1..172800";
          }
        }
        leaf udp-timeout {
          tailf:info "Specify timeout for NAT UDP flows";
          type uint32 {
            tailf:info "<1-172800>;;Timeout in seconds (max: 2days)";
            range "1..172800";
          }
        }
        leaf sampling-timeout {
          tailf:info "Specify timeout after which the device checks for dynamic translation activity.";
          type uint32 {
            tailf:info "<1-172800>;;Timeout in seconds (max: 2days)";
          }
        }
      }
    }

    // ip domain-lookup
    leaf domain-lookup {
      tailf:info "Enable/Disable DNS";
      tailf:cli-boolean-no;
      default "false";
      type boolean;
    }

    // ip host *
    list host {
      tailf:info "Add an entry to the ip hostname table";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-remove-before-change;
      key id;
      leaf id {
        type string;
      }
      leaf address {
        tailf:cli-drop-node-name;
        type inet:ipv4-address;
      }
    }

    // ip prefix-list *
    container prefix-list {
      tailf:info "Build a prefix list";
      list prefixes {
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        key name;
        leaf name {
          tailf:cli-incomplete-command;
          type string {
            tailf:info "WORD;;Name of a prefix list";
            pattern '([^s].*)|(s[^e].*)|(se[^q].*)'
              +'(seq[^u].*)|(sequ[^e].*)|(seque[^n].*)|'
              +'(sequen[^c].*)|(sequenc[^e].*)|(sequence'
                                                +'[^\-].*)|(sequence\-[^n].*)|(sequence\-n'
                                                                               +'[^u].*)|(sequence\-nu[^m].*)|(sequence\-'
                                                                                                               +'num[^b].*)|(sequence\-numb[^e].*)|'
              +'(sequence\-numbe[^r].*)|(sequence\-number..*)';
          }
        }

        // ip prefix-list * description
        leaf "description" {
          tailf:info "Prefix-list specific description";
          tailf:cli-full-command;
          tailf:cli-multi-value;
          tailf:cli-optional-in-sequence;
          tailf:cli-disallow-value ".* deny .*|.* permit .*|.* seq .*";
          type string {
            tailf:info "LINE;;Up to 80 characters describing this prefix-list";
            length "1..80";
          }
        }

        // Duplicated since tailf:cli-compact-syntax is currently
        // broken when using groupings
        choice type-choice {
          // ip prefix-list * seq * deny
          leaf deny {
            tailf:info "Specify packets to reject";
            type tailf:ipv4-address-and-prefix-length {
              tailf:info "A.B.C.D;;IP prefix <network>/"
                +"<length>, e.g., 35.0.0.0/8";
            }
          }
          // ip prefix-list * seq * permit
          leaf permit {
            tailf:info "Specify packets to forward";
            type tailf:ipv4-address-and-prefix-length {
              tailf:info "A.B.C.D;;IP prefix <network>/"
                +"<length>, e.g., 35.0.0.0/8";
            }
          }
        }
        leaf eq {
          tailf:info "Prefix length to be matched";
          tailf:cli-optional-in-sequence;
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<1-32>;;Prefix length";
            range "1..32";
          }
        }
        leaf ge {
          tailf:info "Minimum prefix length to be matched";
          tailf:cli-optional-in-sequence;
          type uint8 {
            tailf:info "<1-32>;;Minimum prefix length";
            range "1..32";
          }
        }
        leaf le {
          tailf:info "Maximum prefix length to be matched";
          type uint8 {
            tailf:info "<1-32>;;Maximum prefix length";
            range "1..32";
          }
        }
        // ip prefix-list * seq *
        list seq {
          tailf:info "sequence number of an entry";
          tailf:cli-compact-syntax;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          tailf:cli-remove-before-change;
          tailf:cli-reset-container;
          tailf:cli-suppress-mode;
          tailf:cli-diff-delete-after "/nx:route-map/match/ip/address/prefix-list";
          nx:diff-list-delete-before-set;
          key "no";
          leaf no {
            type uint32 {
              tailf:info "<1-4294967294>;;Sequence number";
              range "1..4294967294";
            }
          }
          // Duplicated since tailf:cli-compact-syntax is currently
          // broken when using groupings
          choice type-choice {
            // ip prefix-list * seq * deny
            leaf deny {
              tailf:info "Specify packets to reject";
              type tailf:ipv4-address-and-prefix-length {
                tailf:info "A.B.C.D;;IP prefix <network>/"
                  +"<length>, e.g., 35.0.0.0/8";
              }
            }
            // ip prefix-list * seq * permit
            leaf permit {
              tailf:info "Specify packets to forward";
              type tailf:ipv4-address-and-prefix-length {
                tailf:info "A.B.C.D;;IP prefix <network>/"
                  +"<length>, e.g., 35.0.0.0/8";
              }
            }
          }
          leaf eq {
            tailf:info "Prefix length to be matched";
            tailf:cli-optional-in-sequence;
            tailf:cli-full-command;
            type uint8 {
              tailf:info "<1-32>;;Prefix length";
              range "1..32";
            }
          }
          leaf ge {
            tailf:info "Minimum prefix length to be matched";
            tailf:cli-optional-in-sequence;
            type uint8 {
              tailf:info "<1-32>;;Minimum prefix length";
              range "1..32";
            }
          }
          leaf le {
            tailf:info "Maximum prefix length to be matched";
            type uint8 {
              tailf:info "<1-32>;;Maximum prefix length";
              range "1..32";
            }
          }
        }
      }
    }

    // ip sla
    container sla {
      tailf:info "Service Level Agreement (SLA)";
      when "/nx:feature/sla" {
        tailf:dependency "/nx:feature/sla";
      }
      tailf:cli-diff-dependency "/nx:feature/sla";
      tailf:cli-diff-dependency "../../interface" {
        tailf:cli-trigger-on-set;
      }
      tailf:cli-diff-dependency "../../vrf/context" {
        tailf:cli-trigger-on-set;
      }

      list sla-list {
        tailf:cli-drop-node-name;
        tailf:cli-mode-name "config-ip-sla";
        key id;
        leaf id {
          type uint32 {
            tailf:info "<1-2147483647>;;Entry Number (NOTE: dns and icmp-echo entries needs special handling, once created this sla entry is locked to that type, this is how NX-OS works)";
          }
        }

        grouping operation-grouping {
          leaf threshold {
            tailf:info "Operation threshold";
            nx:must-be-less-than "timeout";
            default "5000";
            type uint16 {
              tailf:info "<0-60000>;;Millisecond threshold value";
            }
          }
          leaf timeout {
            tailf:info "Timeout of an operation";
            default "5000";
            type uint32 {
              tailf:info "<0-604800000>;;Timeout in milliseconds";
              range "0..604800000";
            }
          }
          leaf frequency {
            tailf:info "Frequency of an operation";
            type uint32 {
              tailf:info "<1-604800>;;Frequency in seconds";
              range "1..604800";
            }
          }
          leaf vrf {
            tailf:info "Configure IP SLAs for a VPN Routing/Forwarding instance";
            tailf:non-strict-leafref {
              path "/nx:vrf/context/id";
            }
            type vrf-member-type;
          }
        }

        container icmp-echo {
          tailf:info "ICMP Echo Operation (NOTE: Once created, destination/source can't be edited without removing entry, this is a limitation of NX-OS)";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-ip-sla-echo";
          nx:show-on-create-only;
          nx:conditionally-inject-frequency;
          presence "true";

          leaf destination {
            tailf:cli-drop-node-name;
            tailf:cli-hide-in-submode;
            type union {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Destination IP address, broadcast disallowed";
              }
              type inet:ipv6-address {
                tailf:info "A:B::C:D;;Destination IPv6 address";
              }
              type string {
                tailf:info "WORD;;Destination hostname, broadcast disallowed";
              }
            }
          }
          choice iface-or-host {
            leaf source-interface {
              tailf:info "Source Interface (ingress icmp packet interface)";
              tailf:cli-hide-in-submode;
              nx:case-insensitive-type;
              type string {
                tailf:info "Interface name";
              }
            }
            leaf source-ip {
              tailf:info "Source address";
              tailf:cli-hide-in-submode;
              type union {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Source IP address, broadcast disallowed";
                }
                type inet:ipv6-address {
                  tailf:info "A:B::C:D;;Source IPv6 address";
                }
                type string {
                  tailf:info "WORD;;Source IP hostname, broadcast disallowed";
                }
              }
            }
          }

          uses operation-grouping;

          leaf request-data-size {
            tailf:info "Request data size";
            type uint16 {
              tailf:info "<0-16384>;;Number of bytes in payload";
            }
          }
          leaf tos {
            tailf:info "Type of Service";
            type uint8 {
              tailf:info "<1-255>;;Type of Service Value";
            }
          }
          leaf traffic-class {
            tailf:info "Traffic Class";
            type uint8 {
              tailf:info "<1-255>;;Traffic Class Value";
            }
          }
        }

        container dns {
          tailf:info "DNS Operation";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-ip-sla-echo";
          nx:show-on-create-only;
          nx:conditionally-inject-frequency;
          presence "true";

          leaf target {
            tailf:cli-drop-node-name;
            tailf:cli-hide-in-submode;
            type string {
              tailf:info "WORD;;Target IP Address or Hostname";
            }
          }

          leaf name-server {
            tailf:info "Name Server";
            tailf:cli-hide-in-submode;
            type union {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Destination IP address, broadcast disallowed";
              }
              type string {
                tailf:info "WORD;;Destination IP hostname, broadcast disallowed";
              }
            }
          }

          leaf source-ip {
            tailf:info "Source address";
            tailf:cli-hide-in-submode;
            type union {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Source IP address, broadcast disallowed";
              }
              type string {
                tailf:info "WORD;;Source IP hostname, broadcast disallowed";
              }
            }
          }

          uses operation-grouping;
        }
      }

      // ip sla schedule
      list schedule {
        tailf:info "Entry Scheduling";
        tailf:cli-compact-syntax;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-remove-before-change;
        key id;
        leaf id {
          tailf:non-strict-leafref {
            path "../../sla-list/id";
          }
          type uint32 {
            tailf:info "<1-2147483647>;;Entry Number";
          }
        }
        leaf life {
          tailf:info "Length of time to execute in seconds";
          type union {
            type uint32 {
              tailf:info "<0-2147483647>;;Life seconds (default 3600)";
            }
            type enumeration {
              enum forever {
                tailf:info "Continue running forever";
              }
            }
          }
        }
        container start-time {
          tailf:info "When to start this entry";
          tailf:cli-compact-syntax;
          tailf:cli-flatten-container;
          choice when {
            leaf now {
              tailf:info "Start now";
              type empty;
            }
          }
        }
        leaf ageout {
          tailf:info "How long to keep this Entry when inactive";
          type uint32 {
            tailf:info "<0-2073600>;;Ageout Seconds";
            range "0..2073600";
          }
        }
        leaf recurring {
          tailf:info "Probe to be scheduled automatically every day";
          type empty;
        }
      }

      // ip sla logging
      container logging {
        tailf:info "Enable Syslog";
        leaf traps {
          tailf:info "Enable syslog traps";
          type empty;
        }
      }

      list reaction-configuration {
        tailf:info "IP SLAs Reaction-Configuration";
        tailf:cli-suppress-mode;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-delete-when-empty;
        // Seems to trigger NSO bug
        //        tailf:cli-full-no;
        key "id react";
        leaf id {
          tailf:non-strict-leafref {
            path "../../sla-list/id";
          }
          type uint32 {
            tailf:info "<1-2147483647>;;Entry Number";
          }
        }
        leaf react {
          tailf:info "Reaction variable to be configured";
          tailf:cli-expose-key-name;
          type enumeration {
            enum connectionLoss {
              tailf:info "Connection Loss";
            }
            enum rtt {
              tailf:info "Round Trip Time";
            }
            enum timeout {
              tailf:info "Timeout";
            }
            enum verifyError {
              tailf:info "Verify Error";
            }
          }
        }

        container threshold-value {
          tailf:info "Threshold Value";
          tailf:cli-sequence-commands;
          tailf:cli-compact-syntax;
          tailf:cli-flatten-container;
          tailf:cli-optional-in-sequence;
          leaf upper {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<1-60000>;;Upper limit for Threshold";
            }
          }
          leaf lower {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<1-60000>;;Lower limit for Threshold";
            }
          }
        }

        leaf threshold-type {
          tailf:info "Threshold Type";
          tailf:cli-optional-in-sequence;
          type enumeration {
            enum average {
              tailf:info "Average over N attempts";
            }
            enum consecutive {
              tailf:info "Consecutive occurences";
            }
            enum immediate {
              tailf:info "React immediately";
            }
            enum never {
              tailf:info "Never react";
            }
            enum xOfy {
              tailf:info "X out of Y occurences";
            }
          }
        }

        leaf first-arg {
          tailf:cli-drop-node-name;
          tailf:cli-optional-in-sequence;
          when "not(../threshold-type = 'immediately' or ../threshold-type = 'never')" {
            tailf:dependency "../threshold-type";
          }
          default 5;
          type uint8 {
            tailf:info "<1-16>;;Number";
            range "1..16";
          }
        }

        leaf second-arg {
          tailf:cli-drop-node-name;
          when "../first-arg and ../threshold-type = 'xOfy'" {
            tailf:dependency "../threshold-type";
            tailf:dependency "../first-arg";
          }
          type uint8 {
            tailf:info "<1-16>;;Number";
            range "1..16";
          }
        }

        leaf action-type {
          tailf:info "IP SLAs Reaction Action Type";
          type enumeration {
            enum none {
              tailf:info "No action";
            }
            enum trapAndTrigger {
              tailf:info "Trap and Trigger action";
            }
            enum trapOnly {
              tailf:info "Trap Only action";
            }
            enum triggerOnly {
              tailf:info "Trigger Only action";
            }
          }
        }
      }

    }

    // ip tacacs
    container tacacs {
      tailf:info "Tacacs server";
      tailf:cli-diff-dependency "/nx:interface";
      tailf:cli-diff-dependency "/nx:tacacs-server";
      tailf:cli-diff-dependency "/nx:feature/tacacs-plus";
      tailf:cli-compact-syntax;
      leaf source-interface {
        tailf:info "Source interface to be used to reach tacacs server";
        nx:case-insensitive-type;
        type string;
      }
    }

    // ip radius
    container radius {
      tailf:info "Radius server";
      tailf:cli-diff-dependency "/nx:interface";
      leaf source-interface {
        tailf:info "Source interface to be used to reach radius server";
        nx:case-insensitive-type;
        type string;
      }
    }

    // ip arp
    container arp {
      tailf:info "Configure ARP parameters";
      // ip arp timeout
      leaf timeout {
        tailf:info "ARP timeout";
        tailf:cli-no-value-on-delete;
        default "1500";
        type uint16 {
          tailf:info "60-28800;;Time-out value in seconds";
          range "60..28800";
        }
      }
      container inspection {
        tailf:info "Arp Inspection configuration";
        leaf-list validate {
          tailf:info "Validate addresses";
          tailf:cli-flat-list-syntax;
          tailf:cli-replace-all;
          type enumeration {
            enum dst-mac { tailf:info "Validate destination MAC address"; }
            enum ip { tailf:info "Validate IP addresses"; }
            enum src-mac { tailf:info "Validate source MAC address"; }
          }
        }
        list vlan {
          tailf:info "Enable/Disable ARP Inspection on vlans";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-range-list-syntax;
          nx:explicit-delete-when-empty;
          key vlan-id;
          leaf vlan-id {
            type uint16 {
              tailf:info "<1-3967,4048-4093>;;VLAN ID 1-4094 or range(s): 1-5, 10 or 2-5,7-19";
            }
          }
          container logging {
            tailf:info "Configure type of packets to be logged";
            leaf dhcp-bindings {
              tailf:info "Logging of packet that match DHCP bindings";
              type enumeration {
                enum all { tailf:info "Log all packets that match DHCP bindings"; }
                enum none { tailf:info "Do not log packets"; }
                enum permit { tailf:info "Log DHCP Binding Permitted packets"; }
              }
            }
          }
        }
        list filter {
          tailf:info "Filter";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Access list name (Max Size 64)";
            }
          }
          leaf-list vlan {
            tailf:info "Vlan range";
            tailf:cli-range-list-syntax;
            type uint16 {
              tailf:info "<1-3967,4048-4093>;;VLAN ID 1-4094 or range(s): 1-5, 10 or 2-5,7-19";
            }
          }
        }
      }
    }

    // ip tcp
    container tcp {
      tailf:info "Global TCP parameters";

      // ip tcp path-mtu-discovery
      leaf path-mtu-discovery  {
        tailf:info "Enable path-MTU discovery on TCP";
        type empty;
      }
    }

    // ip ssh
    container ssh {
      tailf:info "Configure ssh";
      tailf:cli-diff-dependency "/nx:interface";
      list source-interface {
        tailf:cli-suppress-mode;
        key vrf;
        leaf vrf {
          tailf:cli-expose-key-name;
          tailf:key-default "default";
          tailf:non-strict-leafref {
            path "/nx:vrf/context/id";
          }
          type vrf-member-type;
        }
        leaf interface-name {
          tailf:cli-prefix-key;
          tailf:cli-drop-node-name;
          tailf:info "Configure source interface feature for ssh";
          nx:case-insensitive-type;
          type string {
            pattern "(([Ee]thernet)|([Ll]oopback)|([Pp]ort-channel)|([Vv]lan)|([Bb]di)|([Mm]gmt))[0-9/\\.]+";
          }
        }
      }
    }

    // ip http
    container http {
      tailf:info "Configure HTTP client";
      leaf source-interface {
        tailf:info "Configure source interface feature for HTTP client";
        tailf:cli-diff-delete-before "/nx:feature/interface-vlan" {
          tailf:cli-when-target-delete;
        }
        nx:case-insensitive-type;
        type string;
      }
    }

    container load-sharing {
      tailf:info "ECMP load-sharing";
      container address {
        tailf:info "Configure source/destination addresses, port numbers and hash";
        tailf:cli-compact-syntax;
        tailf:cli-full-no;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf address-type {
          tailf:cli-drop-node-name;
          tailf:cli-remove-before-change;
          tailf:cli-incomplete-command;
          type enumeration {
            enum destination {
              tailf:info "Use destination address";
            }
            enum source {
              tailf:info "Use source address";
            }
            enum source-destination {
              tailf:info "Use both source and destination values for address";
            }
          }
        }
        leaf gre {
          tailf:info "Use source-destination value for gre-key";
          tailf:cli-optional-in-sequence;
          type empty;
        }
        leaf gre-outer {
          tailf:info "Use outer IPv4 header fields for GRE tunnel hashing";
          tailf:cli-optional-in-sequence;
          type empty;
        }
        leaf port {
          tailf:info "Use source-destination value for port";
          tailf:cli-optional-in-sequence;
          type enumeration {
            enum destination {
              tailf:info "Use destination address";
            }
            enum source-destination {
              tailf:info "Use both source and destination values for address";
            }
          }
        }
        leaf concatenation {
          tailf:info "Enable/Disable concatenation";
          tailf:cli-optional-in-sequence;
          type empty;
        }
        leaf rotate {
          tailf:info "Offset to be used in the hash";
          default "32";
          tailf:ned-default-handling report-all;
          type uint8 {
            tailf:info "<1-63>;;Value used for offset, default value is 32";
          }
        }
        leaf universal-id {
          tailf:info "Universal-id to randomize hash functions for load-balance";
          type uint32 {
            tailf:info "<1-4294967295>;;Value used to randomize hash";
          }
        }
      }
    }

    container routing {
      tailf:info "Configure routing information";
      container event-history {
        tailf:info "Configure routing event log";

        grouping eh-size-leaf {
          leaf size {
            tailf:info "Size of buffer";
            type union {
              type uint32 {
                tailf:info "<0-1048576>;;Enter an integer value for the event history buffer";
              }
              type enumeration {
                enum disabled { tailf:info "Disabled"; }
                enum large { tailf:info "Large buffer"; }
                enum medium { tailf:info "Medium buffer"; }
                enum small { tailf:info "Small buffer"; }
              }
            }
          }
        }

        container ufdm {
          tailf:info "UFDM";
          uses eh-size-leaf;
        }
        container ufdm-detail {
          tailf:info "UFDM Detail";
          uses eh-size-leaf;
        }
        container ufdm-summary {
          tailf:info "UFDM Summary";
          uses eh-size-leaf;
        }
        container summary {
          tailf:info "Summary";
          uses eh-size-leaf;
        }
        container recursive-next-hop {
          tailf:info "Recursive next hop";
          uses eh-size-leaf;
        }
        container notifications {
          tailf:info "Notification";
          uses eh-size-leaf;
        }
        container modify-route {
          tailf:info "Modify route";
          uses eh-size-leaf;
        }
        container loop-detection {
          tailf:info "Loop detection";
          uses eh-size-leaf;
        }
        container ha {
          tailf:info "HA";
          uses eh-size-leaf;
        }
        container general {
          tailf:info "General";
          uses eh-size-leaf;
        }
        container errors {
          tailf:info "Errors";
          uses eh-size-leaf;
        }
        container detail {
          tailf:info "Detail";
          uses eh-size-leaf;
        }
        container delete-route {
          tailf:info "Delete route";
          uses eh-size-leaf;
        }
        container cli {
          tailf:info "CLI";
          uses eh-size-leaf;
        }
        container add-route {
          tailf:info "Add route";
          uses eh-size-leaf;
        }
      }
      leaf download-on-convergence {
        tailf:info "Download Routes/RNHs after Table Convergence";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// ipv6
  /// ========================================================================

  container ipv6 {
    tailf:info "Configure IPv6 features";

    // ipv6 access-list
    container access-list {
      tailf:info "Configure access list";

      // ipv6 access-list match-local-traffic
      leaf match-local-traffic {
        tailf:info "Enable access-list matching for locally generated traffic";
        tailf:cli-full-command;
        type empty;
      }

      // ipv6 access-list *
      list list-name {
        tailf:cli-drop-node-name;
        tailf:cli-mode-name "config-acl";
        tailf:cli-full-command;
        key id;
        leaf id {
          tailf:cli-disallow-value "match-local-traffic";
          type string {
            tailf:info "WORD;;List name (Max Size 64)";
            length "1..64";
          }
        }

        uses ip-access-list-common-grouping;

        // ipv6 access-list * / *
        list sequence {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          tailf:cli-sequence-commands {
            tailf:cli-reset-all-siblings;
          }
          tailf:cli-compact-syntax;
          tailf:cli-remove-before-change;
          key id;
          leaf id {
            type uint32 {
              tailf:info "<1-4294967295>;;Sequence number";
              range "1..4294967295";
            }
          }

          leaf action {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type enumeration {
              enum "deny" {
                tailf:info "Specify packets to reject";
              }
              enum "permit" {
                tailf:info "Specify packets to forward";
              }
              enum "remark" {
                tailf:info "Access list entry comment";
              }
            }
          }

          uses ipv6-access-list-grouping {
            when "action != 'remark'";
          }

          leaf remark-value {
            tailf:cli-multi-value;
            tailf:cli-drop-node-name;
            tailf:cli-full-command;
            when "../action = 'remark'";
            type string {
              tailf:info "LINE;;Comment, up to 100 characters (Max Size 100)";
              length "1..100";
            }
          }

        }
      }
    }

    // ipv6 adjacency-stale-timer
    leaf adjacency-stale-timer {
      tailf:info "When probing for an adjacency begins";
      default 1380;
      type uint16 {
        tailf:info "<300-65535>;;Seconds after adjacency uptime";
      }
    }

    // ipv6 host *
    list host {
      tailf:info "Add an entry to the ip hostname table";
      key "name ip";
      leaf name {
        type string {
          tailf:info "WORD;;Name of Host (Max Size 64)";
        }
      }
      leaf ip {
        type inet:ipv6-address {
          tailf:info "A:B::C:D;;Enter an IPv6 address";
        }
      }
    }

    // ipv6 route *
    uses ipv6-grouping;

    // ipv6 prefix-list
    container prefix-list {

      // ipv6 prefix-list *
      list prefixes {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;

        key name;
        leaf name {
          tailf:cli-incomplete-command;
          type string {
            tailf:info "WORD;;Name of a prefix list";
            pattern '([^s].*)|(s[^e].*)|(se[^q].*)'
              +'(seq[^u].*)|(sequ[^e].*)|(seque[^n].*)|'
              +'(sequen[^c].*)|(sequenc[^e].*)|(sequence'
                                                +'[^\-].*)|(sequence\-[^n].*)|(sequence\-n'
                                                                               +'[^u].*)|(sequence\-nu[^m].*)|(sequence\-'
                                                                                                               +'num[^b].*)|(sequence\-numb[^e].*)|'
              +'(sequence\-numbe[^r].*)|(sequence\-number..*)';
          }
        }

        // ipv6 prefix-list * description
        leaf "description" {
          tailf:info "Prefix-list specific description";
          tailf:cli-multi-value;
          tailf:cli-full-command;
          type string {
            tailf:info "LINE;;Up to 80 characters describing this prefix-list";
            length "1..80";
          }
        }

        choice type-choice {
          // ipv6 prefix-list * deny
          leaf deny {
            tailf:info "Specify packets to reject";
            type tailf:ipv6-address-and-prefix-length {
              tailf:info "X:X:X:X::X/<0-128>  IPv6 prefix"
                +"<network>/<length>";
            }
          }
          // ipv6 prefix-list * permit
          leaf permit {
            tailf:info "Specify packets to forward";
            type tailf:ipv6-address-and-prefix-length {
              tailf:info "X:X:X:X::X/<0-128>  IPv6 prefix"
                +"<network>/<length>";
            }
          }
        }

        // ipv6 prefix-list * seq *
        list seq {
          tailf:info "sequence number of an entry";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-all-siblings;
          }
          tailf:cli-remove-before-change;
          key "no";
          leaf no {
            type uint32 {
              tailf:info "<1-4294967294>;;Sequence number";
              range "1..4294967294";
            }
          }

          choice type-choice {
            // ip prefix-list * seq * deny
            leaf deny {
              tailf:info "Specify packets to reject";
              type tailf:ipv6-address-and-prefix-length {
                tailf:info "X:X:X:X::X/<0-128>  IPv6 prefix"
                  +"<network>/<length>";
              }
            }
            // ip prefix-list * seq * permit
            leaf permit {
              tailf:info "Specify packets to forward";
              type tailf:ipv6-address-and-prefix-length {
                tailf:info "X:X:X:X::X/<0-128>  IPv6 prefix"
                  +"<network>/<length>";
              }
            }
          }
          leaf eq {
            tailf:cli-break-sequence-commands;
            type uint8 {
              tailf:info "<1-128>;;Prefix length";
              range "1..128";
            }
          }
          leaf ge {
            tailf:info "Minimum prefix length to be matched";
            type uint8 {
              tailf:info "<1-128>;;Minimum prefix length";
              range "1..128";
            }
          }
          leaf le {
            tailf:info "Maximum prefix length to be matched";
            tailf:cli-full-command;
            type uint8 {
              tailf:info "<1-128>;;Maximum prefix length";
              range "1..128";
            }
          }
        }
      }
    }

    // ipv6 dhcp
    container dhcp {
      tailf:info "Configure DHCP snooping and relay";
      when "../../feature/dhcp" {
        tailf:dependency "../../feature/dhcp";
      }
      tailf:cli-diff-dependency "/nx:feature/dhcp";
      leaf relay {
        tailf:cli-full-command;
        tailf:cli-show-with-default;
        default true;
        tailf:cli-boolean-no;
        type boolean;
      }

      container relay-config {
        tailf:cli-drop-node-name;
        container relay {
          tailf:cli-incomplete-command;
          // ipv6 dhcp relay information
          container option {
            tailf:info "Insert DHCPv6 relay information in Relay forward";
            leaf vpn {
              tailf:info "Enable DHCPv6 relay support across VRFs";
              type empty;
            }
          }
        }
      }
    }

    // ipv6 switch-packets
    container switch-packets {
      tailf:info "Switch ND packets received on core ports";
      leaf lla {
        tailf:info "Switch ND packets targeted to Link local address on core ports";
        type empty;
      }
    }

    // ipv6 snooping
    container snooping {
      tailf:info "IPv6 snooping configuration commands";
      when "../../feature/dhcp" {
        tailf:dependency "../../feature/dhcp";
      }
      tailf:cli-diff-dependency "/nx:feature/dhcp";
      list policy {
        tailf:info "Configure a policy for feature snooping";
        key "name";
        leaf name {
          type string {
            tailf:info "WORD;;Name of the snooping policy";
          }
        }

        leaf device-role {
          tailf:info "Sets the role of the device attached to the port";
          type enumeration {
            enum node {
              tailf:info "Attached device is a node (default)";
            }
            enum switch {
              tailf:info "Attached device is a switch";
            }
          }
        }

        container limit {
          tailf:info "Specifies a limit";
          leaf address-count {
            tailf:info "Configure maximum address per port";
            type uint16 {
              tailf:info "<1-32000>;;Maximum value";
            }
          }
        }

        container protocol {
          tailf:info "Sets the protocol to glean (default all)";
          leaf dhcp {
            tailf:info "Glean addresses in DHCP packets";
            tailf:cli-boolean-no;
            type boolean;
          }
          leaf ndp {
            tailf:info "Glean addresses in NDP packets";
            tailf:cli-boolean-no;
            type boolean;
          }
        }

        leaf security-level {
          tailf:info "Setup security level";
          type enumeration {
            enum glean {
              tailf:info "Glean addresses";
            }
            enum guard {
              tailf:info "Inspect and drop un-authorized messages (default)";
            }
            enum inspect {
              tailf:info "Glean and Validate message";
            }
          }
        }

        container tracking {
          tailf:info "Override default tracking behavior";
          container enable {
            tailf:info "Tracking on";
            presence "true";
            nx:delete-with " tracking disable";
            leaf reachable-lifetime {
              tailf:info "Time entry is kept REACHABLE";
              type union {
                type uint32 {
                  tailf:info "<1-86400>;;Seconds";
                }
                type enumeration {
                  enum infinite {
                    tailf:info "Keep entry in chosen state forever";
                  }
                }
              }
            }
          }
        }

        leaf trusted-port {
          tailf:info "Setup trusted port";
          type empty;
        }
      }
    }

  }


  /// ========================================================================
  /// cdp
  /// ========================================================================

  container cdp {
    tailf:info "Configure CDP parameters";
    leaf enable {
      tailf:info "Enable/disable CDP on all interfaces";
      tailf:cli-boolean-no;
      type boolean;
      default true;
    }
    leaf timer {
      tailf:info "CDP refresh time interval (in seconds)";
      default 60;
      type uint8 {
        tailf:info "<5-254>;;CDP refresh time interval (in seconds)";
      }
    }
    leaf holdtime {
      tailf:info "CDP hold time advertised (in seconds)";
      default 180;
      type uint8 {
        tailf:info "<10-255>;;CDP hold time advertised (in seconds)";
      }
    }
  }


  /// ========================================================================
  /// diagnostic
  /// ========================================================================

  container diagnostic {
    tailf:info "Diagnostic commands";
    container bootup {
      tailf:info "Configure Diagnostic for bootup";
      leaf level {
        tailf:info "Select diagnostic level";
        default "complete";
        type enumeration {
          enum bypass {
            tailf:info "Skip all bootup test";
          }
          enum complete {
            tailf:info "Complete level";
          }
          enum extra {
            tailf:info "Extra level";
          }
        }
      }
    }
    container monitor {
      tailf:info "Configure diagnostic monitoring test";
      container interval {
        tailf:info "Configure diagnostic monitoring tests interval";
        list module {
          tailf:info "Module Keyword";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key mod;
          leaf mod {
            type uint8 {
              tailf:info "<1-N>;;Module number";
            }
          }
          list test {
            tailf:info "Diagnostic test selection";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            tailf:cli-compact-syntax;
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;Test name (Max Size 32)";
              }
            }
            leaf hour {
              tailf:info "Hour of the day";
              tailf:cli-incomplete-command;
              type uint8 {
                tailf:info "<0-23>;;Interval in hours";
              }
            }
            leaf min {
              tailf:info "Minute of an hour";
              tailf:cli-incomplete-command;
              type uint8 {
                tailf:info "<0-59>;;Interval in minutes";
              }
            }
            leaf second {
              tailf:info "Second of a minute";
              type uint8 {
                tailf:info "<0-59>;;Interval in seconds";
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// dot1x
  /// ========================================================================

  container dot1x {
    leaf mac-move {
      tailf:info "Enable or Disable Mac-moves";
      tailf:cli-diff-dependency "/nx:feature/dot1x";
      when "/nx:feature/dot1x" {
        tailf:dependency "/nx:feature/dot1x";
      }
      default permit;
      type enumeration {
        enum deny { tailf:info "Deny mac moves"; }
        enum permit { tailf:info "Permit mac moves"; }
      }
    }
    leaf radius-accounting {
      tailf:info "Accounting messages to RADIUS";
      tailf:cli-diff-dependency "/nx:feature/dot1x";
      type empty;
    }
    leaf system-auth-control {
      tailf:info "Enable or Disable SysAuthControl";
      tailf:cli-diff-dependency "/nx:feature/dot1x";
      when "/nx:feature/dot1x" {
        tailf:dependency "/nx:feature/dot1x";
      }
      type boolean;
      tailf:cli-boolean-no;
      default "true";
    }
  }


  /// ========================================================================
  /// copp
  /// ========================================================================

  container copp {
    tailf:info "Control-Plane Policing";
    // copp profile
    container profile {
      tailf:info "CoPP Profile";
      tailf:cli-diff-dependency "/nx:control-plane/service-policy" {
        tailf:cli-trigger-on-set;
      }
      // copp profile
      choice profile-choice {
        // copp profile dense
        leaf dense {
          tailf:info "The Dense   Profile";
          type empty;
        }
        // copp profile lenient
        leaf lenient {
          tailf:info "The Lenient Profile";
          type empty;
        }
        // copp profile moderate
        leaf moderate {
          tailf:info "The Moderate Profile";
          type empty;
        }
        // copp profile strict
        leaf strict {
          tailf:info "The Strict Profile";
          cli:context-value-inject "static" {
            cli:arguments "";
            when "/tailfned/default-copp-profile-strict='true'";
          }
          nx:filter-in-show {
            when "/tailfned/dayzero-copp-profile-strict='true'";
          }
          type empty;
        }
      }
    }
  }


  /// ========================================================================
  /// bfd
  /// ========================================================================

  uses base-bfd-grouping {
    augment bfd {
      leaf slow-timer {
        tailf:info "Configure slow mode timer for sessions";
        type uint16 {
          tailf:info "<1000-30000>;;Slow rate timer in milliseconds";
        }
      }
      leaf startup-timer {
        tailf:info "Configure Delayed Start Up timer for sessions";
        default 5;
        type uint8 {
          tailf:info "<0-30>;;Start Up timer in seconds";
        }
      }
    }
  }


  /// ========================================================================
  /// mac
  /// ========================================================================

  container mac {
    tailf:info "MAC";

    container access-list {
      tailf:info "Configure access list";

      // mac access-list *
      list list-name {
        tailf:cli-drop-node-name;
        tailf:cli-mode-name "config-mac-acl";
        tailf:cli-full-command;
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;List name (Max Size 64)";
            length "1..64";
          }
        }

        container statistics {
          tailf:info "Enable per-entry statistics for the ACL";
          leaf per-entry {
            tailf:info "Collect stats for each ACL entry";
            type empty;
          }
        }

        // mac access-list * / *
        list sequence {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          key id;
          leaf id {
            type uint32 {
              tailf:info "<1-4294967295>;;Sequence number";
              range "1..4294967295";
            }
          }

          // mac access-list * / * remark
          leaf remark {
            tailf:info "Access list entry comment";
            tailf:cli-optional-in-sequence;
            tailf:cli-multi-value;
            tailf:cli-full-command;
            type string {
              tailf:info "LINE;;Comment, up to 100 characters (Max Size 100)";
              length "1..100";
            }
          }

          // mac access-list * / * deny
          // mac access-list * / * permit
          leaf action {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type enumeration {
              enum "deny" {
                tailf:info "Specify packets to reject";
              }
              enum "permit" {
                tailf:info "Specify packets to forward";
              }
            }
          }

          // <source>
          container source {
            tailf:cli-drop-node-name;
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            choice source-choice {
              leaf any {
                tailf:info "Any source address";
                tailf:cli-incomplete-command;
                type empty;
              }
              case address {
                leaf address {
                  tailf:cli-drop-node-name;
                  tailf:cli-incomplete-command;
                  type mac-address-type;
                }
                leaf wildcard-bits {
                  tailf:cli-drop-node-name;
                  tailf:cli-incomplete-command;
                  type mac-address-type;
                }
              }
            }
          }

          // <destination>
          choice destination-choice {
            leaf any {
              tailf:info "Any destination address";
              type empty;
            }
            case address {
              leaf address {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type mac-address-type;
              }
              leaf wildcard-bits {
                tailf:cli-drop-node-name;
                type mac-address-type;
              }
            }
          }

          // <protocol>
          leaf protocol {
            tailf:cli-drop-node-name;
            tailf:cli-break-sequence-commands;
            type union {
              type enumeration {
                enum aarp {
                  tailf:info "Appletalk AARP";
                }
                enum appletalk {
                  tailf:info "Appletalk";
                }
                enum decnet-iv {
                  tailf:info "DECnet Phase IV";
                }
                enum diagnostic {
                  tailf:info "DEC Diagnostic Protocol";
                }
                enum etype-6000 {
                  tailf:info "Ethertype 0x6000";
                }
                enum etype-8042 {
                  tailf:info "Ethertype 0x8042";
                }
                enum ip {
                  tailf:info "IP (Internet Protocol V4)";
                }
                enum lat {
                  tailf:info "DEC LAT";
                }
                enum lavc-sca {
                  tailf:info "DEC LAVC,SCA";
                }
                enum mop-console {
                  tailf:info "DEC MOP Remote console";
                }
                enum mop-dump {
                  tailf:info "DEC MOP dump";
                }
                enum vines-echo {
                  tailf:info "VINES Echo";
                }
              }
              type string {
                tailf:info "<0x0-0xffff>;;MAC protocol number";
                pattern "0x.*";
              }
            }
          }

          // mac access-list * / * cos
          leaf cos {
            tailf:info "CoS value";
            type uint8 {
              tailf:info "<0-7>;;CoS value";
              range "0..7";
            }
          }

          // mac access-list * / * vlan
          leaf vlan {
            tailf:info "VLAN number";
            type uint16 {
              tailf:info "<0-3967,4048-4093>;;VLAN number";
              range "0..4093";
            }
          }

          // mac access-list * / * time-range
          leaf time-range {
            type uint32 {
            }
          }
        }
      }
    }

    container address-table {
      tailf:info "MAC Address Table";
      leaf aging-time {
        tailf:info "Aging time";
        type uint32 {
          tailf:info "<120-918000>;;Aging time in seconds. (0 disables aging)";
          range "0|120..918000";
        }
      }

      container notification {
        tailf:info "Notify of mac-move";
        leaf mac-move {
          tailf:info "Proxy Learning of remote macs for F-PATH VLANS";
          cli:context-value-inject "dynamic" {
            cli:arguments "/tailfned/default-notification-mac-move";
          }
          tailf:cli-boolean-no;
          type boolean;
        }
        choice threshold-choice {
          container threshold-enable {
            tailf:cli-drop-node-name;
            leaf threshold {
              tailf:info "MAC Address Table threshold notification";
              tailf:cli-full-command;
              type empty;
            }
          }
          container threshold {
            tailf:info "MAC Address Table threshold notification";
            tailf:cli-incomplete-command;
            tailf:cli-incomplete-no;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf limit {
              tailf:info "Specify the percentage limit beyond which notifications are enabled";
              tailf:cli-incomplete-command;
              type uint8 {
                tailf:info "<1-100>;;Percentage of MAC Table Consumption";
              }
            }
            leaf interval {
              tailf:info "Minimum time in seconds between two notifications";
              type uint16 {
                tailf:info "<10-10000>;;Interval time in seconds";
              }
            }
          }
        }
      }

      container fabricpath {
        tailf:info "Learning change for all F-PATH VLANS";
        leaf remote-learning {
          tailf:info "Proxy Learning of remote macs for F-PATH VLANS";
          tailf:cli-boolean-no;
          default true;
          type boolean;
        }
      }

      list static {
        tailf:info "Static Entry";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "address vlan";
        leaf address {
          type mac-address-type;
        }
        leaf vlan {
          tailf:info "VLAN";
          tailf:cli-expose-key-name;
          tailf:non-strict-leafref {
            path "/nx:vlan/vlan-list/id";
          }
          type uint16 {
            tailf:info "<1-3967>;;VLAN ID";
          }
        }
        choice drop-or-iface {
          container interface {
            tailf:info "Interface";
            choice eth-or-po {
              leaf Ethernet {
                tailf:info "Ethernet IEEE 802.3z";
                tailf:cli-allow-join-with-value {
                  tailf:cli-display-joined;
                }
                tailf:non-strict-leafref {
                  path "/nx:interface/Ethernet/name";
                }
                type string {
                  tailf:info "<1-253>/<1-256>;;Slot/chassis number";
                }
              }
              leaf port-channel {
                tailf:info "Port Channel interface";
                tailf:cli-allow-join-with-value {
                  tailf:cli-display-joined;
                }
                tailf:non-strict-leafref {
                  path "/nx:interface/port-channel/name";
                }
                type string {
                  tailf:info "<1-4096>;;Port Channel number";
                }
              }
            }
          }
          leaf drop {
            tailf:info "Drop all traffic";
            type empty;
          }
        }
      }
      list vlan {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key id;
        leaf id {
          type uint16 {
            tailf:info "<1-4094>;;VLAN ID 1-4094 or ";
          }
        }
        container learning {
          leaf mode {
            type string;
          }
        }
      }
      container loop-detect {
        tailf:info "Action for Mac loop detection";
        container nve {
          tailf:info "Configure NVE information";
          leaf port-down {
            tailf:info "Take port-down action for mac loop detection";
            type empty;
          }
        }
        leaf port-down {
          tailf:info "Take port-down action for mac loop detection";
          type empty;
        }
      }
    }
  }


  /// ========================================================================
  /// arp
  /// ========================================================================

  container arp {
    tailf:info "ARP access-list configuration commands";
    list access-list {
      tailf:info "Configure access list";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;List name (Max Size 64)";
        }
      }
      list sequence {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-remove-before-change;
        key id;
        leaf id {
          type uint32 {
            tailf:info "<1-4294967295>;;Sequence number";
            range "1..4294967295";
          }
        }
        grouping entry-grouping {
          leaf direction {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            type enumeration {
              enum request { tailf:info "ARP requests"; }
              enum response { tailf:info "ARP Responses"; }
            }
          }
          leaf ip {
            tailf:info "Any IP protocol";
            type union {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IP address <a.b.c.d>";
              }
              type enumeration {
                enum any { tailf:info "Any IP address"; }
                enum host { tailf:info "Host IP address"; }
              }
            }
          }
          leaf mask {
            tailf:cli-drop-node-name;
            when "contains(../ip, '.')" {
              tailf:dependency "../ip";
            }
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP mask <a.b.c.d>";
            }
          }
          leaf host {
            tailf:cli-drop-node-name;
            when "../ip = 'host'" {
              tailf:dependency "../ip";
            }
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP address <a.b.c.d>";
            }
          }
          leaf resp-ip {
            tailf:cli-drop-node-name;
            when "../direction = 'response'" {
              tailf:dependency "../direction";
            }
            type union {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IP address <a.b.c.d>";
              }
              type enumeration {
                enum any { tailf:info "Any IP address"; }
                enum host { tailf:info "Host IP address"; }
              }
            }
          }
          leaf resp-mask {
            tailf:cli-drop-node-name;
            when "contains(../resp-ip, '.')" {
              tailf:dependency "../resp-ip";
            }
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP mask <a.b.c.d>";
            }
          }
          leaf resp-host {
            tailf:cli-drop-node-name;
            when "../resp-ip = 'host'" {
              tailf:dependency "../resp-ip";
            }
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP address <a.b.c.d>";
            }
          }
          leaf mac {
            tailf:info "MAC";
            type union {
              type mac-address-type;
              type enumeration {
                enum any { tailf:info "Any MAC address"; }
                enum host { tailf:info "Host MAC address"; }
              }
            }
          }
          leaf host-mac {
            tailf:cli-drop-node-name;
            when "../mac = 'host'" {
              tailf:dependency "../mac";
            }
            type mac-address-type;
          }
          leaf mac-mask {
            tailf:cli-drop-node-name;
            when "../mac != 'host' and ../mac != 'any'" {
              tailf:dependency "../mac";
            }
            type mac-address-type;
          }
        }
        leaf remark {
          tailf:info "Access list entry comment";
          tailf:cli-multi-value;
          tailf:cli-full-command;
          tailf:cli-reset-container;
          type string {
            tailf:info "LINE;;Comment, up to 100 characters (Max Size 100)";
            length "1..100";
          }
        }
        container permit {
          tailf:info "Specify packets to forward";
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-compact-syntax;
          uses entry-grouping;
        }
        container deny {
          tailf:info "Specify packets to reject";
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-compact-syntax;
          uses entry-grouping;
        }
      }
    }
  }


  /// ========================================================================
  /// mac-list
  /// ========================================================================

  list mac-list {
    tailf:info "Build a mac list";
    tailf:cli-suppress-mode;
    tailf:cli-delete-when-empty;
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;Name of mac-list (Max Size 63)";
      }
    }
    list seq {
      tailf:info "Sequence number of an entry";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-compact-syntax;
      tailf:cli-remove-before-change;
      key num;
      leaf num {
        type uint32 {
          tailf:info "<1-4294967294>;;Sequence number";
        }
      }
      leaf action {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type enumeration {
          enum deny { tailf:info "Specify routes to reject"; }
          enum permit { tailf:info "Specify routes to forward"; }
        }
      }
      leaf mac-address {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type mac-address-type;
      }
      leaf mask {
        tailf:cli-drop-node-name;
        type mac-address-type;
      }
    }
  }

  /// ========================================================================
  /// macsec
  /// ========================================================================
  container macsec {
    tailf:info "Configure MACSEC";
    list policy {
      tailf:info "Configure MACSEC policy";
      tailf:cli-diff-dependency "/nx:feature/macsec";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Name of Policy";
        }
      }
      leaf cipher-suite {
        tailf:info "Configure Cipher Suite";
        default GCM-AES-XPN-256;
        type enumeration {
          enum GCM-AES-128 { tailf:info "GCM AES 128 Bit Encryption"; }
          enum GCM-AES-256 { tailf:info "GCM AES 256 Bit Encryption"; }
          enum GCM-AES-XPN-128 { tailf:info "GCM AES XPN 128 Bit Encryption"; }
          enum GCM-AES-XPN-256 { tailf:info "GCM AES XPN 256 Bit Encryption"; }
        }
      }
      leaf security-policy {
        tailf:info "Configure Security policy";
        default should-secure;
        type enumeration {
          enum must-secure { tailf:info "Must-Secure policy"; }
          enum should-secure { tailf:info "Should-Secure policy"; }
        }
      }
    }
  }


  /// ========================================================================
  /// errdisable
  /// ========================================================================

  container errdisable {
    tailf:info "Error disable";
    container recovery {
      tailf:info "Error disable recovery";
      container cause {
        tailf:info "Enable error disable recovery for application";
        leaf bpduguard {
          tailf:info "Enable timer to recover from BPDU Guard error disable state";
          type empty;
        }
        leaf failed-port-state {
          tailf:info "Enable timer to recover from stp set port state failure";
          type empty;
        }
        leaf link-flap {
          tailf:info "Enable timer to recover from linkstate flapping";
          type empty;
        }
        leaf loopback {
          tailf:info "Enable timer to recover from loopback error disabled state detected by UDLD";
          type empty;
        }
        leaf psecure-violation {
          tailf:info "Enable timer to recover from psecure violation disable state";
          type empty;
        }
        leaf security-violation {
          tailf:info "Enable timer to recover from 802.1x violation disable state";
          type empty;
        }
        leaf storm-control {
          tailf:info "Enable timer to recover from storm control error disabled state";
          type empty;
        }
        leaf udld {
          tailf:info "Enable timer to recover from udld error disabled state";
          type empty;
        }
        leaf vpc-peerlink {
          tailf:info "Enable timer to recover from inconsistent vpc peer-link";
          type empty;
        }
        leaf pause-rate-limit {
          tailf:info "Enables a timer to recover from the pause rate limit error disabled state.";
          type empty;
        }
        leaf dcbx-no-ack {
          tailf:info "Enable timer to recover from no DCBX Acks";
          type empty;
        }
      }
      leaf interval {
        tailf:info "Error disable recovery timer value";
        default 300;
        type uint16 {
          tailf:info "<30-65535>;;Timer-interval (sec)";
          range "30..65535";
        }
      }
    }
    container detect {
      tailf:info "Error disable detection";
      container cause {
        tailf:info "Enable error disable detection for application";
        leaf acl-exception {
          tailf:info "Enable error detection for access-list installation failures";
          type empty;
        }
        leaf link-flap {
          tailf:info "Enable error disable detection on linkstate-flapping";
          type empty;
        }
        leaf loopback {
          tailf:info "Enable error disable detection on loopback";
          type empty;
        }
        leaf miscabling {
          tailf:info "Enable timer to detect from miscabled port";
          type empty;
        }
      }
    }
  }


  /// ========================================================================
  /// vem
  /// ========================================================================

  list vem {
    key id;
    leaf id {
      type uint16;
    }

    container host {
      leaf id {
        type string;
      }
      container vmware {
        leaf id {
          type string;
        }
      }
    }
  }

  /// ========================================================================
  /// vtp
  /// ========================================================================

  container vtp {
    tailf:info "Configure global VTP state";
    tailf:cli-diff-dependency "../feature/vtp";

    // vtp mode
    leaf mode {
      tailf:info "Configure VTP device mode (NOTE: might need to enable ned-setting 'behaviour vtp-support')";
      type enumeration {
        enum transparent {
          tailf:info "Set the device to transparent mode";
        }
        enum client {
          tailf:info "Set the device to client mode";
        }
        enum off {
          tailf:info "Set the device to off mode";
        }
        enum server {
          tailf:info "Set the device to server mode";
        }
      }
    }

    // vtp domain
    leaf domain {
      tailf:info "Set the name of the VTP administrative domain";
      //when "../mode";
      tailf:cli-diff-dependency "../mode";
      nx:delete-with "none";
      type string {
        tailf:info "WORD;;The ascii name for the VTP administrative domain (Max"
          +"Size 32)";
        length "1..32";
      }
    }

    leaf file {
      tailf:info "Set the name of the VTP file name";
      type string;
    }

    leaf interface {
      tailf:info "Configure interface as the preferred source for the VTP IP updater address";
      tailf:cli-diff-set-after "/nx:interface";
      type string {
        tailf:info "WORD;;The name of the interface providing the VTP updater ID for this device (Max Size 254)";
      }
    }

    leaf password {
      tailf:info "Set the password for the VTP administrative domain (NOTE: need to enable ned-setting 'behaviour vtp-support')";
      type string {
        tailf:info "WORD;;The ascii password for the VTP administrative domain (Max Size 64)";
      }
    }

    leaf pruning {
      tailf:info "Set the adminstrative domain to permit pruning (NOTE: need to enable ned-setting 'behaviour vtp-support')";
      type empty;
    }

    leaf version {
      tailf:info "Set the adminstrative domain to VTP version (NOTE: need to enable ned-setting 'behaviour vtp-support')";
      type uint8 {
        tailf:info "<1-3>;;Set the adminstrative domain to VTP version";
      }
    }

  }

  /// ========================================================================
  /// telemetry
  /// ========================================================================

  container telemetry {
    tailf:info "Telemetry";
    tailf:cli-add-mode;
    tailf:cli-diff-delete-before "/nx:feature/telemetry";
    presence "true";

    // telemetry / destination-group
    list destination-group {
      tailf:info "Create destination group";
      key id;
      leaf id {
        type union {
          type uint16 {
            tailf:info "<1-4095>;;Identifier";
          }
          type string {
            tailf:info "WORD;;Identifier (Max Size 32)";
          }
        }
      }

      list ip {
        tailf:info "Set destination IPv4 address";
        tailf:cli-suppress-mode;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-incomplete-command;
        key "address port";
        leaf address {
          tailf:info "IP address";
          tailf:cli-expose-key-name;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Destination IPv4 Address";
          }
        }
        leaf port {
          tailf:info "Set destination port";
          tailf:cli-expose-key-name;
          type uint16 {
            tailf:info "<1-65535>;;Destination port";
          }
        }
        leaf protocol {
          tailf:info "Set transport protocol";
          tailf:cli-incomplete-command;
          type enumeration {
            enum HTTP;
            enum TCP;
            enum UDP;
            enum gRPC;
          }
        }
        leaf encoding {
          tailf:info "Set encoding format";
          type enumeration {
            enum GPB {
              tailf:info "Set encoding to GPB only";
            }
            enum JSON {
              tailf:info "Set encoding to JSON";
            }
            enum Form-data {
              tailf:info "Set encoding to Form-data only";
            }
            enum GPB-compact {
              tailf:info "Set encoding to Compact-GPB only";
            }
            enum XML {
              tailf:info "Set encoding to XML";
            }
          }
        }
      }

      container use-chunking {
        tailf:info "Enable chunking";
        leaf size {
          tailf:info "Chunk size";
          type uint16 {
            tailf:info "<64-4096>;;Specify chunking size in kilobytes";
          }
        }
      }
      leaf use-compression {
        tailf:info "Specify the destination compression method";
        type enumeration {
          enum gzip {
            tailf:info "GZIP compression algorithm";
          }
        }
      }
    }

    container destination-profile {
      tailf:info "Specify the default destination profile";
      tailf:cli-add-mode;
      presence true;

      leaf source-interface {
        tailf:info "Source interface";
        type string {
          tailf:info "<interface>;;ethernet|loopback|port-channel interface";
        }
      }
      leaf use-compression {
        tailf:info "Specify the destination compression method";
        type enumeration {
          enum gzip {
            tailf:info "GZIP compression algorithm";
          }
        }
      }
      leaf use-nodeid {
        tailf:info "Set the node ID (Max size 128)";
        type string {
          tailf:info "WORD;;Node ID (Max size 128)";
        }
      }
      container use-retry {
        tailf:info "Specify send retry details";
        leaf size {
          tailf:info "Retry buffer size";
          default 10;
          type uint16 {
            tailf:info "<10-1500>;;Buffer size in Mega bytes";
          }
        }
      }
      leaf use-vrf {
        tailf:info "Specify the destination vrf";
        type string {
          tailf:info "WORD;;Configurable VRF name (Max Size 32)";
        }
      }
    }

    // telemetry / sensor-group
    list sensor-group {
      tailf:info "Create a sensor group";
      key id;
      leaf id {
        type union {
          type uint16 {
            tailf:info "<1-4095>;;Identifier";
          }
          type string {
            tailf:info "WORD;;Identifier (Max Size 32)";
          }
        }
      }

      leaf data-source {
        tailf:info "Specify the data source";
        type enumeration {
          enum DME {
            tailf:info "DME objectstore";
          }
          enum NX-API {
            tailf:info "NX-API";
          }
          enum NATIVE {
            tailf:info "NATIVE";
          }
          enum YANG {
            tailf:info "YANG";
          }
        }
      }

      list path {
        tailf:info "Create a sensor path";
        tailf:cli-suppress-mode;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-delete-when-empty;
        key dn;
        leaf dn {
          type union {
            type enumeration {
              enum adjacency {
                tailf:info "Monitor ARP, AM with IP adjacencies";
              }
              enum environment {
                tailf:info "Monitor chassis information including fan,temperature,power,storage,supervisor,linecard";
              }
              enum interface {
                tailf:info "Monitor all the interface counters and status changes";
              }
              enum mac {
                tailf:info "Monitor static and dynamic mac entries";
              }
              enum mac-all {
                tailf:info "Monitor add/delete/move activities of static/dynamic MACs in the L2 table";
              }
              enum resources {
                tailf:info "Monitor system resources like CPU utilization, memory utilization";
              }
              enum rib {
                tailf:info "Monitor RIB routes";
              }
              enum vxlan {
                tailf:info "Monitor VXLAN EVPN (VXLAN peers, VXLAN counter, VLAN counters, BGP peers data)";
              }
            }
            type string {
              tailf:info "WORD;;Distinguished Name";
            }
          }
        }

        leaf depth {
          tailf:info "Specify a retrieval depth";
          type union {
            type uint8 {
              tailf:info "<0-32>;;Retrieval depth";
            }
            type enumeration {
              enum unbounded {
                tailf:info "Retrieve entire tree";
              }
            }
          }
        }

        leaf query-condition {
          tailf:info "Specify a query condition";
          tailf:cli-optional-in-sequence;
          type string {
            tailf:info "WORD;;Query condition (Max Size 256)";
          }
        }

        leaf filter-condition {
          tailf:info "Specify a filter condition";
          type string {
            tailf:info "WORD;;Filter Condition";
          }
        }
      }
    }

    // telemetry / subscription
    list subscription {
      tailf:info "Create a Subscription";
      key id;
      leaf id {
        type uint16 {
          tailf:info "<1-4095>;;Identifier";
        }
      }

      list dst-grp {
        tailf:info "Associated destination group";
        tailf:cli-suppress-mode;
        key id;
        leaf id {
          tailf:non-strict-leafref {
            path "../../../destination-group/id";
          }
          type union {
            type uint16 {
              tailf:info "<1-4095>;;Identifier";
            }
            type string {
              tailf:info "WORD;;Identifier (Max Size 32)";
            }
          }
        }
      }

      list snsr-grp {
        tailf:info "Associated sensor group";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          tailf:non-strict-leafref {
            path "../../../sensor-group/id";
          }
          type union {
            type uint16 {
              tailf:info "<1-4095>;;Identifier";
            }
            type string {
              tailf:info "WORD;;Identifier (Max Size 32)";
            }
          }
        }
        leaf sample-interval {
          tailf:info "Cadence Time in milliseconds(0 for events)";
          type uint32 {
            tailf:info "<0-604800000>;;Cadence Time in milliseconds";
          }
        }
      }
    }

  }


  /// ========================================================================
  /// icam
  /// ========================================================================

  container icam {
    tailf:info "Intelligent CAM";
    container monitor {
      tailf:info "Icam monitor";
      // container entries {
      //   tailf:info "Icam monitor entries stats";
      //   container acl {
      //     tailf:info "Icam monitor entries type ACL";
      //     tailf:cli-sequence-commands {
      //       tailf:cli-reset-siblings;
      //     }
      //     tailf:cli-compact-syntax;
      //     leaf module {
      //       tailf:info "Module Number";
      //       type uint8 {
      //         tailf:info "<1-30>  Enter Module Number";
      //       }
      //     }
      //     leaf inst {
      //       tailf:info "ASIC/Forwarding Engine Instance Number";
      //       type uint8 {
      //         tailf:info "<0-11>;Enter Instance Number";
      //       }
      //     }
      //   }
      // }
      // container interval {
      //   tailf:info "Icam monitor interval";
      //   tailf:cli-sequence-commands {
      //     tailf:cli-reset-siblings;
      //   }
      //   tailf:cli-compact-syntax;
      //   leaf hours {
      //     tailf:cli-drop-node-name;
      //     tailf:cli-incomplete-command;
      //     type uint8 {
      //       tailf:info "<1-24>;;Icam monitor interval in hours";
      //     }
      //   }
      //   leaf history {
      //     tailf:info "Icam monitor history";
      //     type uint16 {
      //       tailf:info "<168-1344>;;Number of intervals to keep in icam monitor history";
      //     }
      //   }
      // }
      // resource  Icam monitor resource utilization
      //   acl-tcam  Icam monitor resource type ACL TCAM
      //   fib-tcam  Icam monitor resource type FIB TCAM
      //
      leaf scale {
        tailf:info "Icam monitor scale";
        tailf:cli-full-command;
        tailf:cli-diff-dependency "/nx:feature/icam";
        type empty;
      }
      container scale-config {
        tailf:cli-drop-node-name;
        container scale {
          tailf:info "Icam monitor scale";
          tailf:cli-incomplete-command;
          grouping limit-leaf {
            leaf limit {
              tailf:info "Change feature limit";
              tailf:cli-diff-dependency "/nx:feature/icam";
              type uint32 {
                tailf:info "<1-4294967295>  New feature limit";
              }
            }
          }
          container l2-switching {
            tailf:info "Layer 2 switching";
            container infra {
              tailf:info "Infrasture";
              container mac {
                tailf:info "MAC Address";
                uses limit-leaf;
              }
            }
            container stp {
              tailf:info "Spanning Tree Protocol";
              container isolated-portvlan {
                tailf:info "Total number of VLANs x ports with switchport isolated";
                uses limit-leaf;
              }
              container mst-instance {
                tailf:info "MST instances";
                uses limit-leaf;
              }
              container mst-vport {
                tailf:info "MST virtual ports";
                uses limit-leaf;
              }
              container rpvst-vlan {
                tailf:info "RPVST VLANs";
                uses limit-leaf;
              }
              container rpvst-vport {
                tailf:info "RPVST virtual ports";
                uses limit-leaf;
              }
            }
            container vlan {
              tailf:info "VLAN";
              container vlan-count {
                tailf:info "Number of VLANs";
                uses limit-leaf;
              }
            }
          }
          container multicast-routing {
            tailf:info "Multicast routing";
            container pim {
              tailf:info "PIM";
              container neighbor {
                tailf:info "PIM neighbor";
                uses limit-leaf;
              }
            }
            container routing-forwarding {
              tailf:info "Routing and forwarding";
              container route-sg-v4 {
                tailf:info "IPv4 S,G Route";
                uses limit-leaf;
              }
              container route-sg-v6 {
                tailf:info "IPv6 S,G Route";
                uses limit-leaf;
              }
              container route-starg-v4 {
                tailf:info "IPv4 *,G Route";
                uses limit-leaf;
              }
              container route-starg-v6 {
                tailf:info "IPv6 *,G Route";
                uses limit-leaf;
              }
              container route-v4 {
                tailf:info "IPv4 Route";
                uses limit-leaf;
              }
              container route-v6 {
                tailf:info "IPv6 Route";
                uses limit-leaf;
              }
            }
          }
          container threshold {
            tailf:info "Change percent threshold limit";
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            tailf:cli-compact-syntax;
            tailf:cli-diff-dependency "/nx:feature/icam";
            leaf info {
              tailf:info "Info threshold";
              tailf:cli-incomplete-command;
              type uint8 {
                tailf:info "<1-100>;;Info threshold percent";
              }
            }
            leaf warning {
              tailf:info "Warning threshold";
              type uint8 {
                tailf:info "<1-100>;;Warning threshold percent";
              }
            }
            leaf critical {
              tailf:info "Critical threshold";
              type uint8 {
                tailf:info "<1-100>;;Critical threshold percent";
              }
            }
          }
          container unicast-routing {
            tailf:info "Unicast routing";
            container arp {
              tailf:info "ARP";
              container arp-count {
                tailf:info "ARP count";
                uses limit-leaf;
              }
            }
            container bfd {
              tailf:info "BFD";
              container session {
                tailf:info "BFD session";
                uses limit-leaf;
              }
            }
            container bgp {
              tailf:info "BGP";
              container neighbor {
                tailf:info "BGP neighbor";
                uses limit-leaf;
              }
            }
            container eigrp {
              tailf:info "EIGRP";
              container neighbor {
                tailf:info "EIGRP neighbor";
                uses limit-leaf;
              }
              container route {
                tailf:info "EIGRP route";
                uses limit-leaf;
              }
            }
            container hsrp {
              tailf:info "HSRP";
              container mac {
                tailf:info "HSRP MAC";
                uses limit-leaf;
              }
            }
            container ipv6-nd {
              tailf:info "IPv6 ND";
              container nd-count {
                tailf:info "ND count";
                uses limit-leaf;
              }
            }
            container isis {
              tailf:info "IS-IS";
              container adjacency {
                tailf:info "IS-ISv4 adjacency";
                uses limit-leaf;
              }
              container bfd-session {
                tailf:info "IS-ISv4 BFD session";
                uses limit-leaf;
              }
              container route {
                tailf:info "IS-ISv4 route";
                uses limit-leaf;
              }
            }
            container ospf {
              tailf:info "OSPF";
              container area {
                tailf:info "OSPF Area";
                uses limit-leaf;
              }
              container lsa {
                tailf:info "OSPF LSA";
                uses limit-leaf;
              }
              container neighbor {
                tailf:info "OSPF neighbor";
                uses limit-leaf;
              }
            }
            container pbr {
              tailf:info "PBR";
              container ace-v4 {
                tailf:info "PBR IPv4 ACEs";
                uses limit-leaf;
              }
              container ace-v6 {
                tailf:info "PBR IPv6 ACEs";
                uses limit-leaf;
              }
              container intf {
                tailf:info "Interfaces with PBR policy";
                uses limit-leaf;
              }
              container nh-per-policy {
                tailf:info "PBR NextHop per policy";
                uses limit-leaf;
              }
              container seq-per-policy {
                tailf:info "PBR Configured sequences per policy";
                uses limit-leaf;
              }
            }
            container routing {
              tailf:info "Routing";
              container host-route-v4 {
                tailf:info "IPv4 host route";
                uses limit-leaf;
              }
              container host-route-v6 {
                tailf:info "IPv6 host route";
                uses limit-leaf;
              }
              container lpm-route-v4 {
                tailf:info "IPv4 LPM route";
                uses limit-leaf;
              }
              container lpm-route-v6 {
                tailf:info "IPv6 LPM route";
                uses limit-leaf;
              }
            }
            container vrf {
              tailf:info "VRF";
              container vrf-count {
                tailf:info "VRF count";
                uses limit-leaf;
              }
            }
            container vrrp {
              tailf:info "VRRP";
              container grp-per-intf {
                tailf:info "VRRP groups per interface";
                uses limit-leaf;
              }
            }
            container vrrp3 {
              tailf:info "VRRPv3";
              container grp-and-path {
                tailf:info "VRRPv3 groups and pathways combined";
                uses limit-leaf;
              }
              container grp-dft-timer {
                tailf:info "VRRPv3 groups with default timers (1 s)";
                uses limit-leaf;
              }
              container grp-per-intf {
                tailf:info "VRRPv3 groups per interface";
                uses limit-leaf;
              }
              container grp-relax-timer {
                tailf:info "VRRPv3 groups with relaxed timers (3 s)";
                uses limit-leaf;
              }
              container path-dft-timer {
                tailf:info "Pathways with one VRRPv3 group with default timer (1 s)";
                uses limit-leaf;
              }
            }
          }
          container vxlan {
            tailf:info "VxLAN";
            grouping vxlan-common-limits {
              container vlan-logical-port-vp {
                tailf:info "VLAN logical port VP count";
                uses limit-leaf;
              }
              container vlan-per-fex-port {
                tailf:info "VLAN per FEX port";
                uses limit-leaf;
              }
              container vni {
                tailf:info "VNI";
                uses limit-leaf;
              }
              container vrf {
                tailf:info "VRF";
                uses limit-leaf;
              }
              container vtep {
                tailf:info "VTEP";
                uses limit-leaf;
              }
            }
            grouping vxlan-bgp-common-limits {
              container host-route-v4 {
                tailf:info "IPv4 host route";
                uses limit-leaf;
              }
              container host-route-v6 {
                tailf:info "IPv6 host route";
                uses limit-leaf;
              }
              container igmp-group {
                tailf:info "IGMP group";
                uses limit-leaf;
              }
              container mac {
                tailf:info "MAC address";
                uses limit-leaf;
              }
              container overlay-lpm-route-v4 {
                tailf:info "IPv4 LPM route";
                uses limit-leaf;
              }
              container overlay-lpm-route-v6 {
                tailf:info "IPv6 LPM route";
                uses limit-leaf;
              }
              container svi {
                tailf:info "SVI with Anycast Gateway";
                uses limit-leaf;
              }
            }
            container bgp {
              tailf:info "BGP eVPN";
              uses vxlan-bgp-common-limits;
              container underlay-mcast-group {
                tailf:info "Underlay multicast group";
              }
              uses vxlan-common-limits;
            }
            container bgp-ir {
              tailf:info "BGP eVPN Ingress Replication";
              uses vxlan-bgp-common-limits;
              uses vxlan-common-limits;
            }
            container fl {
              tailf:info "VXLAN Flood and Learn";
              container igmp-group {
                tailf:info "IGMP group";
                uses limit-leaf;
              }
              container ir-mac {
                tailf:info "Ingress replication MAC address";
                uses limit-leaf;
              }
              container ir-peer {
                tailf:info "Ingress replication peer";
                uses limit-leaf;
              }
              container ir-vni {
                tailf:info "Ingress replication L2 VNI";
                uses limit-leaf;
              }
              container static-mac-to-vtep {
                tailf:info "Static MACs to remote VTEP";
                uses limit-leaf;
              }
              container total-mac {
                tailf:info "Total MAC address";
                uses limit-leaf;
              }
              container underlay-mcast-group {
                tailf:info "Underlay multicast group";
                uses limit-leaf;
              }
              uses vxlan-common-limits;
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// crypto
  /// ========================================================================

  container crypto {
    tailf:info "Set crypto settings";
    container key {
      tailf:info "Configure key pair related information";
      container param {
        list rsa {
          tailf:info "Configure rsa key pair generation related information";
          tailf:cli-suppress-mode;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-compact-syntax;
          tailf:cli-delete-when-empty;
          tailf:cli-remove-before-change;
          key "label";
          leaf label {
            tailf:info "Key-pair label";
            tailf:cli-expose-key-name;
            nx:delete-rsa-key;
            type string {
              tailf:info "WORD;;Key-pair label (Max Size 64)";
            }
          }
          leaf modulus {
            tailf:info "Key-pair size";
            type uint16 {
              tailf:info "<512-2048>;;Key-pair size";
            }
          }
          leaf exportable {
            tailf:info "Key-pair is exportable";
            type empty;
          }
        }
      }
      container generate {
        tailf:info "Configure key pair generation related information";
        list rsa {
          tailf:info "Configure rsa key pair generation related information";
          tailf:cli-suppress-mode;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-compact-syntax;
          tailf:cli-delete-when-empty;
          tailf:cli-remove-before-change;
          key "label";
          leaf label {
            tailf:info "Key-pair label";
            tailf:cli-expose-key-name;
            type string {
              tailf:info "WORD;;Key-pair label (Max Size 64)";
            }
          }
          leaf exportable {
            tailf:info "Key-pair is exportable";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          leaf modulus {
            tailf:info "Key-pair size";
            type uint16 {
              tailf:info "<512-2048>;;Key-pair size";
            }
          }
        }
      }
    }
    list certificatemap {
      tailf:info "Configure certificatemap filters";
      tailf:cli-mode-name "config-certmap-filter";
      key "mapname";
      leaf mapname {
        tailf:info "Create a new filter map";
        tailf:cli-expose-key-name;
        type string {
          tailf:info "WORD;;Name of the filter map (Max Size 64)";
        }
      }
      container filter {
        tailf:info "Configure mapping filter";
        leaf altname-email {
          tailf:info "Email id as an alternate name";
          type string {
            tailf:info "WORD;;Email id (Max Size 64)";
          }
        }
        leaf altname-upn {
          tailf:info "User principal name as an alternate name";
          type string {
            tailf:info "WORD;;User principal name (Max Size 64)";
          }
        }
        leaf subject-name {
          tailf:info "Subject name of the certificate";
          type string {
            tailf:info "WORD;;Subject name (Max Size 64)";
          }
        }
      }
    }
    container cert {
      tailf:info "Configure certificate maping filter settings";
      list ssh-authorize {
        tailf:info "Configure mapping filter for ssh";
        tailf:cli-suppress-mode;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        tailf:cli-remove-before-change;
        key name;
        leaf name {
          type string {
            tailf:info "default|WORD;;Issuer name of the certificate (Max Size 64)";
          }
        }
        leaf map {
          tailf:info "Mapping filter to be applied";
          tailf:non-strict-leafref {
            path "/nx:crypto/certificatemap/mapname";
          }
          type string {
            tailf:info "WORD;;Name of the mapping filter which is already configured (Max Size 64)";
          }
        }
        leaf map2 {
          tailf:cli-drop-node-name;
          tailf:non-strict-leafref {
            path "/nx:crypto/certificatemap/mapname";
          }
          type string {
            tailf:info "WORD;;Name of the mapping filter which is already configured (Max Size 64)";
          }
        }
      }
    }
    container ca {
      tailf:info "Configure certificate authority related information";
      leaf lookup {
        tailf:info "Choose the certstore for authentication";
        type enumeration {
          enum both {
            tailf:info "Use both local and remote certstore";
          }
          enum local {
            tailf:info "Use local certstore";
          }
          enum remote {
            tailf:info "Use remote certstore";
          }
        }
      }
      // remote        Use ca from remote certstore
      list trustpoint {
        tailf:info "Configure trustpoint certificate authority";
        key label;
        leaf label {
          type string {
            tailf:info "WORD;;Trustpoint label (Max Size 64)";
          }
        }
        container enrollment {
          tailf:info "Configure trustpoint enrollment";
          leaf terminal {
            tailf:info "Configure trustpoint enrollment via console";
            type empty;
          }
        }
        // ocsp              Configure trustpoint ocsp details
        container revocation-check {
          tailf:info "Configure trustpoint revocation check methods";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf crl {
            tailf:info "Configure revocation check using crl";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          leaf ocsp {
            tailf:info "Configure revocation check using ocsp";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          leaf none {
            tailf:info "Configure revocation check using none";
            type empty;
          }
        }
        leaf rsakeypair {
          tailf:info "Configure trustpoint rsa key-pair details";
          tailf:cli-remove-before-change;
          tailf:non-strict-leafref {
            path "/nx:crypto/key/generate/rsa/label";
          }
          type string {
            tailf:info "WORD;;Key-pair label (Max Size 64)";
          }
        }
      }
      // trustpool     Configure trustpool related information
    }
  }


  /// ========================================================================
  /// time-range
  /// ========================================================================

  list time-range {
    key name;
    leaf name {
      type string {
        tailf:info "WORD  Time range name (Max Size 64)";
      }
    }
    // list sequence {
    //   tailf:cli-drop-node-name;
    //   tailf:cli-compact-syntax;
    //   tailf:cli-sequence-commands {
    //     tailf:cli-reset-siblings;
    //   }
    //   leaf type {
    //     tailf:cli-drop-node-name;
    //     tailf:cli-incomplete-command;
    //     type enumeration {
    //       enum absolute {
    //         tailf:info "Absolute time and date";
    //       }
    //       enum periodic {
    //         tailf:info "Periodic time and date";
    //       }
    //       enum remark {
    //         tailf:info "Time range entry comment";
    //       }
    //     }
    //   }
    // }
  }


  /// ========================================================================
  /// snmp-server
  /// ========================================================================

  container snmp-server {

    // snmp-server contact
    leaf contact {
      tailf:info "Modify sysContact";
      tailf:cli-full-command;
      tailf:cli-multi-value;
      tailf:cli-preformatted;
      tailf:cli-no-value-on-delete;
      type string;
    }

    // snmp-server community *
    list community {
      tailf:info "Set community string and access privs";
      key snmp-community-string;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      // snmp-server community * snmp-community-string
      leaf snmp-community-string {
        tailf:info "SNMP community string (Max Size 32)";
        type word32;
      }
      // snmp-server community * group
      leaf group {
        tailf:info "Group to which the community belongs";
        type word32;
      }
      // Skip: 'snmp-server community * ro'
      // Skip: 'snmp-server community * rw'
      // snmp-server community * use-acl
      leaf use-acl {
        tailf:info "Acl name to filter snmp requests";
        type word32;
      }
    }

    container community-config {
      tailf:cli-drop-node-name;
      list community {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        key snmp-community-string;
        leaf snmp-community-string {
          type leafref {
            path "/nx:snmp-server/community/snmp-community-string";
          }
        }
        leaf use-ipv4acl {
          tailf:info "Specify IPv4 ACL, the ACL name specified after must be IPv4 ACL.";
          type string {
            tailf:info "WORD;;IPv4 ACL name to filter snmp requests (Max Size 32)";
          }
        }
        leaf use-ipv6acl {
          tailf:info "Specify IPv6 ACL, the ACL name specified after must be IPv6 ACL.";
          type string {
            tailf:info "WORD;;IPv6 ACL name to filter snmp requests (Max Size 32)";
          }
        }
      }
    }

    container counter {
      tailf:info "Configure port counter configuration";
      container cache {
        tailf:info "Port stats cache";
        leaf enable {
          tailf:info "Enable port stats cache";
          tailf:cli-boolean-no;
          default true;
          type boolean;
        }
        leaf timeout {
          tailf:info "Timeout for port stats cache";
          // caution varying default 10 and 50 seen
          type uint16 {
            tailf:info "<1-3600>;;Timeout for which cached port stats exists(in secs)";
          }
        }
      }
    }

    // snmp-server enable
    container enable {
      tailf:info "Enable SNMP Traps";
      nx:snmp-server-all-traps {
        when "/tailfned/snmp-server-enable-all-traps";
      }
      // snmp-server enable traps
      container traps {
        tailf:info "Enable SNMP traps";
        // snmp-server enable traps aaa
        when "not(/nx:tailfned/snmp-server-enable-all-traps)" {
          tailf:dependency "/nx:tailfned/snmp-server-enable-all-traps";
        }
        container aaa {
          tailf:info "Enable aaa traps";
          leaf server-state-change {
            tailf:info "AAA server state change notification";
            type empty;
          }
        }

        // snmp-server enable traps bfd
        container bfd {
          tailf:info "Enable bfd traps";
          tailf:cli-diff-dependency "/nx:feature/bfd";
          leaf session-down {
            tailf:info "Sesssion going DOWN";
            tailf:cli-boolean-no;
            default true;
            type boolean;
          }
          leaf session-up {
            tailf:info "Sesssion going UP";
            tailf:cli-boolean-no;
            default true;
            type boolean;
          }
        }

        // snmp-server enable traps bgp
        choice bgp-choice {
          leaf bgp {
            tailf:info "Enable SNMP BGP traps";
            tailf:cli-diff-dependency "/nx:feature/bgp";
            tailf:cli-full-command;
            tailf:cli-full-no;
            type empty;
          }
          container bgp-state-chg {
            tailf:cli-drop-node-name;
            container bgp {
              tailf:cli-diff-dependency "/nx:feature/bgp";
              tailf:cli-incomplete-command;
              tailf:cli-incomplete-no;
              leaf state-changes {
                tailf:info "Traps for FSM state changes";
                tailf:cli-full-command;
                type empty;
              }
              container state-changes-alt {
                tailf:cli-drop-node-name;
                container state-changes {
                  tailf:info "Traps for FSM state changes";
                  tailf:cli-incomplete-command;
                  tailf:cli-incomplete-no;
                  leaf all {
                    tailf:info "CISCO specific trap for all fsm state changes";
                    type empty;
                  }
                  leaf backward-trans {
                    tailf:info "CISCO specific trap for backward transition";
                    type empty;
                  }
                  leaf limited {
                    tailf:info "Trap for standard backward transition and established";
                    type empty;
                  }
                }
              }
            }
          }
        }
        container bgp-threshold {
          tailf:cli-drop-node-name;
          container bgp {
            tailf:cli-diff-dependency "/nx:feature/bgp";
            tailf:cli-incomplete-command;
            tailf:cli-incomplete-no;
            container threshold {
              tailf:info "Traps for threshold events";
              leaf prefix {
                tailf:info "CISCO specific trap for prefix threshold events";
                type empty;
              }
            }
          }
        }
        container bgp-cbgp2 {
          tailf:cli-drop-node-name;
          container bgp {
            tailf:cli-diff-dependency "/nx:feature/bgp";
            tailf:cli-incomplete-command;
            tailf:cli-incomplete-no;
            leaf cbgp2 {
              tailf:info "Enable SNMP CISCO-BGP-MIBv2 traps";
              type empty;
            }
          }
        }

        // snmp-server enable traps bridge
        container bridge {
          tailf:info "Enable bridge traps";
          leaf newroot {
            tailf:info "Enable SNMP STP Bridge MIB newroot traps";
            type empty;
          }
          leaf topologychange {
            tailf:info "Enable SNMP STP Bridge MIB topologychange traps";
            type empty;
          }
        }
        // snmp-server enable traps config
        container config {
          tailf:info "Enable config traps";
          leaf ccmCLIRunningConfigChanged {
            tailf:info "Running config change trap";
            type empty;
          }
        }
        // snmp-server enable traps callhome
        container callhome {
          tailf:info "Enable callhome traps";
          leaf event-notify {
            tailf:info "Callhome External Event Notification";
            type empty;
          }
          leaf smtp-send-fail {
            tailf:info "SMTP Message Send Fail notification";
            type empty;
          }
        }
        // snmp-server enable traps cfs
        container cfs {
          tailf:info "Enable cfs traps";
          leaf state-change-notif {
            tailf:info "State change notification";
            type empty;
          }
          leaf merge-failure {
            tailf:info "Merge failure notification";
            type empty;
          }
        }
        // Skip: 'snmp-server enable traps config'
        // snmp-server enable traps entity
        container entity {
          tailf:info "Enable entity traps";
          tailf:cli-incomplete-command;
          leaf entity_mib_change {
            tailf:info "Entity MIB change";
            tailf:cli-boolean-no;
            default true;
            type boolean;
          }
          leaf entity_module_status_change {
            tailf:info "Entity Module Status Change";
            tailf:cli-boolean-no;
            default true;
            type boolean;
          }
          leaf entity_power_status_change {
            tailf:info "Entity Power Status Change";
            tailf:cli-boolean-no;
            default true;
            type boolean;
          }
          leaf entity_module_inserted {
            tailf:info "Entity Module Inserted";
            tailf:cli-boolean-no;
            default true;
            type boolean;
          }
          leaf entity_module_removed {
            tailf:info "Entity Module Removed";
            tailf:cli-boolean-no;
            default true;
            type boolean;
          }
          leaf entity_unrecognised_module {
            tailf:info "Entity Unrecognised Module";
            tailf:cli-boolean-no;
            default true;
            type boolean;
          }
          leaf entity_fan_status_change {
            tailf:info "Entity Fan Status Change";
            tailf:cli-boolean-no;
            default true;
            type boolean;
          }
          leaf entity_power_out_change {
            tailf:info "Entity Power Out Change";
            tailf:cli-boolean-no;
            default true;
            type boolean;
          }
          leaf entity_sensor {
            tailf:info "Entity sensor";
            tailf:cli-boolean-no;
            default true;
            type boolean;
          }
          leaf cefcMIBEnableStatusNotification {
            tailf:info "CefcMIBEnableStatusNotification";
            tailf:cli-boolean-no;
            default true;
            type boolean;
          }
          leaf cefcEnablePSOutputChangeNotif {
            tailf:info "CefcEnablePSOutputChangeNotif";
            tailf:cli-boolean-no;
            default true;
            type boolean;
          }
        }
        // snmp-server enable traps feature-control
        container feature-control {
          tailf:info "Enable feature-control traps";
          leaf FeatureOpStatusChange {
            tailf:info "Feature operation status change notification";
            type empty;
          }
          leaf ciscoFeatOpStatusChange {
            tailf:info "Feature operation status change notification";
            type empty;
          }
        }
        container generic {
          tailf:info "Enable generic traps";
          leaf coldStart {
            tailf:info "Generic coldStart trap";
            type boolean;
            tailf:cli-boolean-no;
            default true;
          }
          leaf warmStart {
            tailf:info "Generic warmStart trap";
            type boolean;
            tailf:cli-boolean-no;
            default true;
          }
        }
        // snmp-server enable traps hsrp
        container hsrp {
          tailf:info "Enable hsrp traps";
          tailf:cli-diff-dependency "../../../../feature/hsrp";
          // Bug in NCS (https://wiki.tail-f.com/trac/ticket/14696)
          //          when "../../../../feature/hsrp" {
          //            tailf:dependency "../../../../feature/hsrp";
          //          }
          leaf state-change {
            tailf:info "State Change Notification";
            type empty;
          }
        }
        // snmp-server enable traps ip
        container ip {
          tailf:info "Enable ip traps";
          tailf:cli-diff-dependency "../../../../feature/sla";
          leaf sla {
            tailf:info "Service Level Agreement (SLA)";
            type empty;
          }
        }
        // snmp-server enable traps license
        container license {
          tailf:info "Enable license traps";
          leaf notify-license-expiry {
            tailf:info "License Expiry Notification";
            type boolean;
            tailf:cli-boolean-no;
            default true;
          }
          leaf notify-license-expiry-warning {
            tailf:info "License Expiry Warning Notification";
            type boolean;
            tailf:cli-boolean-no;
            default true;
          }
          leaf notify-licensefile-missing {
            tailf:info "License File Missing Notification";
            type boolean;
            tailf:cli-boolean-no;
            default true;
          }
          leaf notify-no-license-for-feature {
            tailf:info "No License installed for feature Notification ";
            type boolean;
            tailf:cli-boolean-no;
            default true;
          }
        }
        // snmp-server enable traps link
        container link {
          tailf:info "Enable link traps";
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          // snmp-server enable traps link cisco-xcvr-mon-status-chg
          leaf cisco-xcvr-mon-status-chg {
            tailf:info "Cisco interface transceiver monitor status change notif"
              +"ication";
            type empty;
          }
          leaf cieLinkDown {
            tailf:info "Cisco extended link state down notification";
            type boolean;
            tailf:cli-boolean-no;
            default true;
          }
          leaf cieLinkUp {
            tailf:info "Cisco extended link state up notification";
            type boolean;
            tailf:cli-boolean-no;
            default true;
          }
          leaf delayed-link-state-change {
            tailf:info "Delayed link state change";
            type boolean;
            tailf:cli-boolean-no;
            default true;
          }
          leaf extended-linkDown {
            tailf:info "IETF extended link state down notification";
            type boolean;
            tailf:cli-boolean-no;
            default true;
          }
          leaf extended-linkUp {
            tailf:info "IETF extended link state up notification";
            type boolean;
            tailf:cli-boolean-no;
            default true;
          }
          leaf linkDown {
            tailf:info "IETF Link state down notification";
            type boolean;
            tailf:cli-boolean-no;
            default true;
          }
          leaf linkUp {
            tailf:info "IETF Link state up notification";
            type boolean;
            tailf:cli-boolean-no;
            default true;
          }
          leaf connUnitPortStatusChange {
            tailf:info "FCMGMT The overall status of the connectivity unit Notification";
            type boolean;
            tailf:cli-boolean-no;
            default true;
          }
          leaf cErrDisableInterfaceEventRev1 {
            tailf:info "Err-disable state notification";
            type boolean;
            tailf:cli-boolean-no;
            default true;
          }
        }
        container old-link-syntax {
          tailf:cli-drop-node-name;
          leaf link {
            tailf:cli-full-command;
            tailf:cli-full-no;
            type empty;
          }
        }
        container mmode {
          tailf:info "Enable mmode traps";
          leaf cseMaintModeChangeNotify {
            tailf:info "Maint Mode Change Notification";
            type empty;
          }
          leaf cseNormalModeChangeNotify {
            tailf:info "Normal Mode Change Notification";
            type empty;
          }
        }
        container mpls {
          tailf:info "Enable mpls traps";
          container ldp {
            tailf:info "Enable LDP notifications";
            leaf session-up {
              tailf:info "MPLS LDP Session Up Notification";
              type boolean;
              tailf:cli-boolean-no;
              default false;
            }
            leaf session-down {
              tailf:info "MPLS LDP Session Down Notification";
              type boolean;
              tailf:cli-boolean-no;
              default false;
            }
          }
        }
        container pim {
          tailf:info "Enable pim traps";
          tailf:cli-diff-dependency "/nx:feature/pim";
          leaf pimNeighborLoss {
            tailf:info "Pim trap for pimNeighborLoss";
            type empty;
          }
        }
        container pseudowire {
          tailf:info "Enable pseudowire traps";
          container vc {
            tailf:info "Allow SNMP Pseudowire (PW) VC traps";
            leaf up {
              tailf:info "Enable Pseudowire (PW) VC up traps";
              type boolean;
              tailf:cli-boolean-no;
              default false;
            }
            leaf down {
              tailf:info "Enable Pseudowire (PW) VC down traps";
              type boolean;
              tailf:cli-boolean-no;
              default false;
            }
          }
        }
        container port-security {
          tailf:info "Enable port-security traps";
          tailf:cli-diff-dependency "/nx:feature/port-security";
          leaf access-secure-mac-violation {
            tailf:info "Secure Mac violation";
            type boolean;
            tailf:cli-boolean-no;
            default false;
          }
          leaf trunk-secure-mac-violation {
            tailf:info "Vlan Secure Mac violation";
            type boolean;
            tailf:cli-boolean-no;
            default false;
          }
        }
        // snmp-server enable traps lldp
        container lldp {
          tailf:info "Enable lldp traps";
          tailf:cli-diff-dependency "/nx:feature/lldp";
          leaf lldpRemTablesChange {
            tailf:info "Lldp remote table change trap";
            type empty;
          }
        }
        // snmp-server enable traps ospf
        container ospf {
          tailf:info "Enable SNMP OSPF traps";
          tailf:cli-diff-dependency "../../../../feature/ospf";
          presence true;
          leaf proc-tag {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;Process tag (Max Size 20)";
              length "1..20";
            }
          }
        }
        // snmp-server enable traps poe
        container poe {
          tailf:info "Enables SNMP PoE traps";
          leaf portonoff {
            tailf:info "portonoff";
            type empty;
          }
          leaf pwrusageon {
            tailf:info "pwrusageon";
            type empty;
          }
          leaf pwrusageoff {
            tailf:info "pwrusageoff";
            type empty;
          }
          leaf police {
            tailf:info "police";
            type empty;
          }
        }
        container rf {
          tailf:info "Enable rf traps";
          leaf redundancy_framework {
            tailf:info "Redundancy_Framework (RF) Sup switchover MIB";
            tailf:cli-boolean-no;
            default true;
            type boolean;
          }
        }
        // snmp-server enable traps rmon
        container rmon {
          tailf:info "Enable rmon traps";
          leaf fallingAlarm {
            tailf:info "Rmon falling alarm";
            type boolean;
            tailf:cli-boolean-no;
            default true;
          }
          leaf hcFallingAlarm {
            tailf:info "High capacity Rmon falling alarm";
            type boolean;
            tailf:cli-boolean-no;
            default true;
          }
          leaf hcRisingAlarm {
            tailf:info "High capacity Rmon rising alarm";
            type boolean;
            tailf:cli-boolean-no;
            default true;
          }
          leaf risingAlarm {
            tailf:info "Rmon rising alarm";
            type boolean;
            tailf:cli-boolean-no;
            default true;
          }
        }
        // snmp-server enable traps snmp
        container snmp {
          tailf:info "Module notifications enable";
          // snmp-server enable traps snmp authentication
          leaf authentication {
            tailf:info "SNMP authentication trap";
            type empty;
          }
        }
        container storm-control-enable {
          tailf:cli-drop-node-name;
          leaf storm-control {
            tailf:info "Enable storm-control traps";
            tailf:cli-full-command;
            tailf:cli-boolean-no;
            default true;
            type boolean;
          }
        }
        container storm-control {
          tailf:info "Enable storm-control traps";
          tailf:cli-incomplete-no;
          leaf trap-rate {
            tailf:info "Number of traps per minute";
            type uint16 {
              tailf:info "<0-1000>;;Per Minute (0 means no upper rate)";
              range "0..1000";
            }
          }
          leaf cpscEventRev1 {
            tailf:info "Port-Storm-Control-Event";
            tailf:cli-boolean-no;
            default true;
            type boolean;
          }
        }
        // snmp-server enable traps stpx
        container stpx {
          tailf:info "Enable stpx traps";
          leaf inconsistency {
            tailf:info "Enable SNMP STPX MIB InconsistencyUpdate traps";
            type empty;
          }
          leaf root-inconsistency {
            tailf:info "Enable SNMP STPX MIB RootInconsistencyUpdate traps";
            type empty;
          }
          leaf loop-inconsistency {
            tailf:info "Enable SNMP STPX MIB LoopInconsistencyUpdate traps";
            type empty;
          }
        }
        container syslog {
          tailf:info "Enable syslog traps";
          leaf message-generated {
            tailf:info "Message Generated Notification";
            type empty;
          }
        }
        // snmp-server enable traps sysmgr
        container sysmgr {
          tailf:info "Enable sysmgr traps";
          leaf cseFailSwCoreNotifyExtended {
            tailf:info "Software Core Notification";
            type empty;
          }
        }
        // snmp-server enable traps system
        container system {
          tailf:info "Enable system traps";
          leaf Clock-change-notification {
            tailf:info "Clock change notification";
            type empty;
          }
        }
        // snmp-server enable traps upgrade
        container upgrade {
          tailf:info "Enable upgrade traps";
          leaf UpgradeOpNotifyOnCompletion {
            tailf:info "Upgrade Global Status Notification";
            tailf:cli-boolean-no;
            default true;
            type boolean;
          }
          leaf UpgradeJobStatusNotify {
            tailf:info "Upgrade Job Status Notification";
            tailf:cli-boolean-no;
            default true;
            type boolean;
          }
        }
        container vtp {
          tailf:info "Enable vtp traps";
          leaf notifs {
            tailf:info "Enable vtpConfigRevNumberError vtpConfigDigestError vtpServerDisabled vtpVersionOneDeviceDetected vlanTrunkPortDynamicStatusChange vtpLocalModeChanged vtpVersionInUseChanged vtpPruningStateOperChange notification";
            type empty;
          }
          leaf vlancreate {
            tailf:info "Enable vtpVlanCreated notification";
            type empty;
          }
          leaf vlandelete {
            tailf:info "Enable vtpVlanDeleted notification";
            type empty;
          }
        }
        container zone {
          tailf:info "Enable zone traps";
          leaf default-zone-behavior-change {
            tailf:info "Default zone behavior change notification";
            type empty;
          }
          leaf enhanced-zone-db-change {
            tailf:info "Enhanced mode zone db change notification";
            type empty;
          }
          leaf merge-failure {
            tailf:info "Merge failure notification";
            type empty;
          }
          leaf merge-success {
            tailf:info "Merge success notification";
            type empty;
          }
          leaf request-reject1 {
            tailf:info "Request Reject notification";
            type empty;
          }
          leaf unsupp-mem {
            tailf:info "Unsupported member notification";
            type empty;
          }
        }
      }
      leaf all-traps {
        tailf:info "use with 'api/snmp-server-enable-all-traps' ned-setting to enable all traps on device";
        when "/nx:tailfned/snmp-server-enable-all-traps" {
          tailf:dependency "/nx:tailfned/snmp-server-enable-all-traps";
        }
        type empty;
      }
    }

    // snmp-server location
    leaf location {
      tailf:info "Modify sysLocation";
      tailf:cli-full-command;
      tailf:cli-multi-value;
      tailf:cli-preformatted;
      tailf:cli-no-value-on-delete;
      type string;
    }

    // snmp-server source-interface
    container source-interface {
      tailf:info "Source interface to be used for sending out SNMP notification"
        +"s";
      // snmp-server source-interface inform
      leaf informs {
        tailf:info "SNMP Inform notifications for which this source interface n"
          +"eeds to be used";
        nx:case-insensitive-type;
        type string;
      }
      leaf inform {
        tailf:info "SNMP Inform notifications for which this source interface n"
          +"eeds to be used (alternative syntax)";
        nx:case-insensitive-type;
        type string;
      }
      // snmp-server source-interface trap
      leaf traps {
        tailf:info "SNMP Trap notifications for which this source interface nee"
          +"ds to be used";
        nx:case-insensitive-type;
        type string;
      }
      leaf trap {
        tailf:info "SNMP Trap notifications for which this source interface nee"
          +"ds to be used (alternative syntax)";
        nx:case-insensitive-type;
        type string;
      }
    }

    list user {
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      nx:explicit-delete-when-empty;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Name of the user (Max Size 32)";
        }
      }
      leaf role {
        tailf:cli-drop-node-name;
        tailf:cli-disallow-value "auth|use-ipv4acl|use-ipv6acl|enforcePriv";
        tailf:cli-optional-in-sequence;
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        tailf:cli-no-value-on-delete;
        tailf:non-strict-leafref {
          path "/nx:role/name/name";
        }
        type user-role-type;
      }

      // snmp-server user * auth
      container auth {
        tailf:info "Authentication parameters for the user";
        tailf:cli-compact-syntax;
        tailf:cli-flatten-container;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        choice auth-alg {
          leaf md5 {
            tailf:info "Use HMAC MD5 algorithm for authentication";
            nx:device-transformed-value;
            type NEDCOM_SECRET_TYPE {
              tailf:info "Authentication password for user (Max Size 130)";
            }
          }
          leaf sha {
            tailf:info "Use HMAC SHA algorithm for authentication";
            nx:device-transformed-value;
            type NEDCOM_SECRET_TYPE {
              tailf:info "Authentication password for user (Max Size 130)";
            }
          }
        }
        container priv {
          tailf:cli-break-sequence-commands;
          tailf:info "Encryption parameters for the user";
          tailf:cli-compact-syntax;
          tailf:cli-flatten-container;
          choice priv-choice {
            leaf passphrase-2 {
              tailf:cli-drop-node-name;
              tailf:cli-disallow-value "aes-128";
              nx:device-transformed-value;
              type NEDCOM_SECRET_TYPE {
                tailf:info "WORD;;Privacy password for user (Max Size 130)";
              }
            }
            leaf aes-128 {
              tailf:info "Use 128-bit AES algorithm for privacy";
              nx:device-transformed-value;
              type NEDCOM_SECRET_TYPE {
                tailf:info "WORD;;Privacy password for user (Max Size 130)";
              }
            }
          }
        }
        leaf localizedkeyAlt {
          tailf:info "Specifies whether the passwords are in localized "
            +"key format";
          nx:device-transformed-dependency;
          tailf:alt-name "localizedkey";
          type empty;
        }
        leaf engineID {
          tailf:info "EngineID for configuring notif target user "
            +"(for V3 informs)";
          type string {
            tailf:info "WORD;;Specifies notification target's SNMP "
              +"engineID(colon separated) (Max Size 128)";
          }
        }
        leaf localizedkey {
          tailf:info "Specifies whether the passwords are in localized "
            +"key format";
          nx:device-transformed-dependency;
          type empty;
        }
      }
    }

    // snmp-server user *
    container user-secondary-roles {
      tailf:cli-drop-node-name;
      list user {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-diff-delete-before "/nx:username-secondary-roles/username" {
          tailf:cli-when-target-create;
        }
        tailf:cli-diff-delete-before "/nx:username-secondary-roles/username" {
          tailf:cli-when-target-delete;
        }
        key "name role";
        leaf name {
          tailf:non-strict-leafref {
            path "/nx:snmp-server/user/name";
          }
          type string {
            tailf:info "WORD;;Name of the user (Max Size 32)";
          }
        }
        leaf role {
          tailf:non-strict-leafref {
            path "/nx:role/name/name";
          }
          tailf:cli-disallow-value "use-ipv4acl|use-ipv6acl|enforcePriv";
          tailf:cli-full-command;
          type user-role-type;
        }
      }
    }

    // snmp-server user * use-ipv4acl
    // snmp-server user * use-ipv6acl
    container user-config {
      tailf:cli-drop-node-name;
      list user {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        key name;
        leaf name {
          type leafref {
            path "/nx:snmp-server/user/name";
          }
        }
        leaf use-ipv4acl {
          tailf:info "Specify IPv4 ACL, the ACL name specified after must be IPv4 ACL.";
          type string {
            tailf:info "WORD;;IPv4 ACL name to filter snmp requests (Max Size 32)";
          }
        }
        leaf use-ipv6acl {
          tailf:info "Specify IPv6 ACL, the ACL name specified after must be IPv6 ACL.";
          type string {
            tailf:info "WORD;;IPv6 ACL name to filter snmp requests (Max Size 32)";
          }
        }
      }
    }

    // snmp-server user * enforcePriv
    container user-config2 {
      tailf:cli-drop-node-name;
      list user {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        key name;
        leaf name {
          type leafref {
            path "/nx:snmp-server/user/name";
          }
        }
        leaf enforcePriv {
          tailf:info "Enforce privacy for the user";
          type empty;
        }
      }
    }

    // snmp-server host *
    list host {
      tailf:info "Specify hosts to receive SNMP notifications";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      key "host-id udp-port";
      leaf host-id {
        tailf:info "A.B.C.D|A:B::C:D|WORD;;IPv4 or IPv6 address or DNS Name of SNMP notification host";
        type string;
      }
      leaf udp-port {
        tailf:cli-expose-key-name;
        tailf:key-default "162";
        type uint16 {
          tailf:info "<0-65535>;;The notification host's UDP port number";
        }
      }
      leaf type {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        tailf:cli-prefix-key {
          tailf:cli-before-key "2";
        }
        type enumeration {
          enum traps {
            tailf:info "Send Traps messages to this host";
          }
          enum informs {
            tailf:info "Send Inform messages to this host";
          }
        }
      }
      leaf version {
        tailf:info "SNMP version to use for notification messages";
        tailf:cli-incomplete-command;
        tailf:cli-prefix-key {
          tailf:cli-before-key "2";
        }
        type enumeration {
          enum 1 {
            tailf:info "Use SNMPv1";
          }
          enum 2c {
            tailf:info "Use SNMPv2c";
          }
          enum 3 {
            tailf:info "Use SNMPv3";
          }
        }
      }
      leaf security-level {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        tailf:cli-optional-in-sequence;
        tailf:cli-prefix-key {
          tailf:cli-before-key "2";
        }
        when "../version = '3'";
        type enumeration {
          enum auth {
            tailf:info "Use the SNMPv3 authNoPriv Security Level";
          }
          enum priv {
            tailf:info "Use the SNMPv3 authPriv Security Level";
          }
        }
      }
      leaf id {
        tailf:cli-drop-node-name;
        nx:dequote-output;
        nx:escape-questionmark;
        tailf:cli-prefix-key {
          tailf:cli-before-key "2";
        }
        type string {
          tailf:info "WORD;;SNMP community string or SNMPv3 user name (Max Size 32)";
          length "1..32";
        }
      }
    }

    container snmp-server-host-vrf {
      tailf:cli-drop-node-name;
      list host {
        tailf:info "Specify hosts to receive SNMP notifications";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-sequence-commands;
        tailf:cli-compact-syntax;
        key "host-id udp-port";
        leaf host-id {
          tailf:info "A.B.C.D|A:B::C:D|WORD;;IPv4 or IPv6 address or DNS Name of SNMP notification host";
          tailf:cli-incomplete-command;
          tailf:non-strict-leafref {
            path "../../../host/host-id";
          }
          type string;
        }
        leaf udp-port {
          tailf:cli-expose-key-name;
          tailf:key-default "162";
          tailf:non-strict-leafref {
            path "../../../host/udp-port";
          }
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<0-65535>;;The notification host's UDP port number";
          }
        }
        leaf use-vrf {
          tailf:info "Configures SNMP to use the selected use-vrf to communicate with the host receiver";
          tailf:cli-prefix-key {
            tailf:cli-before-key "2";
          }
          type string {
            tailf:info "WORD;;VRF name (Max Size 32)";
            length "1..32";
          }
        }
      }
    }

    container snmp-server-host-src-iface {
      tailf:cli-drop-node-name;
      list host {
        tailf:info "Specify hosts to receive SNMP notifications";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-sequence-commands;
        tailf:cli-compact-syntax;
        key "host-id udp-port";
        leaf host-id {
          tailf:info "A.B.C.D|A:B::C:D|WORD;;IPv4 or IPv6 address or DNS Name of SNMP notification host";
          tailf:non-strict-leafref {
            path "../../../host/host-id";
          }
          type string;
        }
        leaf udp-port {
          tailf:cli-expose-key-name;
          tailf:key-default "162";
          tailf:non-strict-leafref {
            path "../../../host/udp-port";
          }
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<0-65535>;;The notification host's UDP port number";
          }
        }
        leaf source-interface {
          tailf:info "Source interface to be used for sending out SNMP notifications to this host";
          tailf:cli-prefix-key {
            tailf:cli-before-key "2";
          }
          nx:case-insensitive-type;
          type string;
        }
      }
    }

    // snmp-server context *
    list context {
      tailf:info "SNMP context to be mapped";
      tailf:cli-suppress-mode;
      tailf:cli-compact-syntax;
      tailf:cli-delete-when-empty;
      nx:explicit-delete-when-empty;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Name of the SNMP context (Max Size 32)";
          length "1..32";
        }
      }
      leaf instance {
        tailf:info "Protocol instance associated with the SNMP context";
        type string {
          tailf:info "WORD;;Name of the protocol instance (Max Size 32)";
          length "1..32";
        }
      }
      leaf vrf {
        tailf:info "VRF associated with the SNMP context";
        type string {
          tailf:info "WORD;;VRF name (Max Size 32)";
          length "1..32";
        }
      }
      leaf topology {
        tailf:info "Topology associated with the SNMP context";
        type string {
          tailf:info "WORD;;Name of the Topology (Max Size 32)";
          length "1..32";
        }
      }
    }

    // snmp-server mib
    container mib {
      tailf:info "Mib access parameters";
      list community-map {
        tailf:info "SNMP community";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key community;
        leaf community {
          tailf:non-strict-leafref {
            path "../../../community/snmp-community-string";
          }
          tailf:info "WORD;;SNMP community string (Max Size 32)";
          tailf:cli-incomplete-command;
          type word32;
        }
        leaf context {
          tailf:info "WORD;;Name of the SNMP context (Max Size 32)";
          tailf:non-strict-leafref {
            path "../../../context/name";
          }
          type string {
            length "1..32";
          }
        }
      }
    }

    leaf globalEnforcePriv {
      tailf:info "Globally enforce privacy for all the users";
      type empty;
    }

    leaf packetsize {
      tailf:info "Largest SNMP packet size";
      type uint16 {
        tailf:info "<484-17382>;;Packet size";
      }
    }

    container engineID {
      tailf:info "Configure a local SNMPv3 engineID";
      leaf local {
        tailf:info "EngineID of the local agent";
        type string {
          tailf:info "WORD;;Engine ID should be an even number of hexadecimal characters, which ranges from 10 to 64 where every two hexadecimal characters should be separated by colon. Including colons- (Max Size 95)";
        }
      }
    }

  }


  /// ========================================================================
  /// callhome
  /// ========================================================================

  container callhome {
    tailf:info "Enter the callhome configuration mode";
    tailf:cli-add-mode;
    list destination-profile {
      tailf:info "Configure destination profiles";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      nx:explicit-delete-when-empty;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;User defined destination profile name (Max Size 31)";
        }
      }
      leaf format {
        tailf:info "Callhome message format (default XML)";
        type enumeration {
          enum XML {
            tailf:info "XML message format";
          }
          enum full-txt {
            tailf:info "Plain text message format";
          }
          enum short-txt {
            tailf:info "Short text message format";
          }
        }
      }
      leaf transport-method {
        tailf:info "Callhome message sending transport-method";
        type enumeration {
          enum email {
            tailf:info "Email transport-method";
          }
          enum http {
            tailf:info "Http transport-method";
          }
        }
      }
      leaf message-size {
        tailf:info "Configure maximum message size (default 2500000)";
        type uint32 {
          tailf:info "<0-5000000>;;Provide maximum possible message size";
        }
      }
    }
    leaf email-contact {
      tailf:info "Email address of the contact person";
      type string {
        tailf:info "WORD;;Provide email address, example: jdow@xyz.com (Max Size 255)";
      }
    }
  }


  /// ========================================================================
  /// snmp
  /// ========================================================================

  container snmp {
    tailf:info "Configure snmp";
    container ifmib {
      tailf:info "Configure snmp interface mib feature";
      container ifalias {
        tailf:info "Configure snmp interface alias attribute for interface mib";
        leaf long {
          tailf:info "Enable long description up to 256 characters for interface alias";
          type empty;
        }
      }
    }
  }


  /// ========================================================================
  /// rmon
  /// ========================================================================

  container rmon {
    tailf:info "Remote Monitoring";

    // rmon event *
    list event {
      tailf:info "Configure an RMON event";
      tailf:cli-compact-syntax;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key number;
      leaf number {
        type uint16 {
          tailf:info "<1-65535>;;Event number";
          range "1..65535";
        }
      }
      leaf log {
        tailf:info "Generate RMON log when the event fires";
        type empty;
      }
      leaf trap {
        tailf:info "Generate SNMP trap when event fires";
        type string {
          tailf:info "WORD;;SNMP community string (Max Size 32)";
        }
      }
      leaf "description" {
        tailf:info "Specify a description of the event";
        type string {
          tailf:info "WORD;;Event description";
        }
      }
      leaf owner {
        tailf:info "Specify an owner for the event";
        type string {
          tailf:info "WORD;;Event owner";
        }
      }
    }

    list alarm {
      tailf:info "Configure an RMON alarm";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-remove-before-change;
      key number;
      leaf number {
        type uint16 {
          tailf:info "<1-65535>;;Alarm number";
        }
      }
      leaf mib {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type string {
          tailf:info "WORD;;MIB object to monitor";
        }
      }
      leaf sample-interval {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint32 {
          tailf:info "<1-700000>;;Sample interval";
        }
      }
      leaf sample-mode {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type enumeration {
          enum absolute {
            tailf:info "Test each sample directly";
          }
          enum delta {
            tailf:info "Test delta between samples";
          }
        }
      }
      leaf rising-threshold {
        tailf:info "Configure the rising threshold";
        type int64 {
          tailf:info "<-2147483648-2147483647>;;Rising threshold value";
        }
      }
      leaf event-to-fire-rising {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        tailf:cli-optional-in-sequence;
        type uint16 {
          tailf:info "<1-65535>;;Event to fire on rising threshold crossing";
        }
      }
      leaf falling-threshold {
        tailf:info "Configure the falling threshold";
        type int64 {
          tailf:info "<-2147483648-2147483647>;;Falling threshold value";
        }
      }
      leaf event-to-fire-falling {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        type uint16 {
          tailf:info "<1-65535>;;Event to fire on falling threshold crossing";
        }
      }
      leaf owner {
        tailf:info "Specify an owner for the alarm";
        type string {
          tailf:info "WORD;;Alarm owner (Max Size 127)";
        }
      }
    }
  }

  /// ========================================================================
  /// install
  /// ========================================================================

  container install {
  container feature-set {
  tailf:info "Install feature-set";
  uses feature-set-grouping;
}
}


  /// ========================================================================
  /// feature-set
  /// ========================================================================

  container feature-set {
  tailf:info "Installed feature-set(s)";
  tailf:cli-diff-dependency "/nx:install/feature-set";
  uses feature-set-grouping;
}


  /// ========================================================================
  /// fex
  /// ========================================================================

  list fex {
  tailf:info "FEX configuration";
  tailf:cli-diff-dependency "/nx:feature-set/fex";
  key id;
  leaf id {
  type uint8 {
  tailf:info "<100-199>;;FEX number";
  range "100..199";
        }
      }

      container pinning {
        leaf max-links {
          type uint16;
        }
      }
      leaf description {
        tailf:info "Enter description of maximum 80 characters";
        tailf:cli-full-command;
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-no-value-on-delete;
      type string {
        length "1..80";
      }
    }
    leaf serial {
      tailf:info "Chassis serial number";
      type string {
        tailf:info "WORD;;Serial number (Max Size 20)";
      }
    }
    leaf type {
      tailf:info "FEX Card type";
      type string {
        tailf:info "Fabric Extender Module";
      }
    }
    container locator-led {
      tailf:info "To turn on the locator LED of a Fabric Extender";
      leaf fex {
        tailf:info "Fabric Extender chassis ID.";
        tailf:ned-ignore-compare-config; // since this might be needed transiently by technician on location
        type uint8 {
          tailf:info "<100-199>;;FEX number";
        }
      }
    }
    list hardware {
      tailf:info "FEX Card type";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key module;
      leaf module {
        type union {
          type string {
            tailf:info "Fabric Extender type";
          }
          type enumeration {
            enum N2148T {
              tailf:info "Fabric Extender 48x1G 4x10G SFP+ Module";
            }
            enum N2224TP {
              tailf:info "Fabric Extender 24x1G 2x10G SFP+ Module";
            }
            enum N2232P {
              tailf:info "Fabric Extender 32x10G SFP+ 8x10G SFP+ Module";
            }
            enum N2232TM {
              tailf:info "Fabric Extender 32x10GBase-T 8x10G SFP+ Module";
            }
            enum N2232TM-E {
              tailf:info "Fabric Extender 32x10GBase-T 8x10G SFP+ Module";
            }
            enum N2248PQ {
              tailf:info "Fabric Extender 48x10G SFP+ 4x40G QSFP Module";
            }
            enum N2248T {
              tailf:info "Fabric Extender 48x1G 4x10G SFP+ Module";
            }
            enum N2248TP-E {
              tailf:info "Fabric Extender 48x1G 4x10G SFP+ Module";
            }
            enum N2332TQ {
              tailf:info "Fabric Extender 32x10GBase-T 4x40G QSFP Module";
            }
            enum N2348PQ {
              tailf:info "Fabric Extender 48x10G SFP+ 6x40G QSFP Module";
            }
            enum N2348TQ {
              tailf:info "Fabric Extender 48x10GBase-T 6x40G QSFP Module";
            }
            enum N2348UPQ {
              tailf:info "Fabric Extender 48x10G SFP+ 6x40G QSFP Module";
            }
            enum NB22DELL {
              tailf:info "Fabric Extender 16x10G SFP+ 8x10G SFP+ Module";
            }
            enum NB22FJ {
              tailf:info "Fabric Extender 16x10G SFP+ 8x10G SFP+ Module";
            }
            enum NB22HP {
              tailf:info "Fabric Extender 16x10G SFP+ 8x10G SFP+ Module";
            }
            enum NB22IBM {
              tailf:info "Fabric Extender 14x10G SFP+ 8x10G SFP+ Module";
            }
          }
        }
      }
      leaf buffer-threshold {
        tailf:info "Set Buffer value";
        type uint32 {
          tailf:info "<81920-316160>;;Buffer threshold in bytes";
        }
      }
      leaf queue-limit {
        tailf:info "Set queue-limit";
        type uint32 {
          tailf:info "<81920-652800>;;Queue limit in bytes";
        }
      }
      leaf shared-buffer-size {
        tailf:info "Buffer Size";
        type uint32 {
          tailf:info "<10800-25392>;;Buffer size in KBytes";
        }
      }
      container uplink-pause-no-drop {
        tailf:info "Uplink pause no drop";
        leaf distance {
          tailf:info "Distance between fex and switch";
          type uint32 {
            tailf:info "<300-3000>;;Distance in meters";
          }
        }
      }
      leaf qos-policy-offload {
        tailf:info "Offload QoS policy";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// mpls
  /// ========================================================================

  container mpls {
    tailf:info "Configure MPLS settings";
    container label {
      tailf:info "Label properties";
      tailf:cli-diff-dependency "/nx:feature/mpls/evpn";
      tailf:cli-diff-dependency "/nx:feature/mpls/segment-routing";
      container range {
        tailf:info "Label range";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf min {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<16-471804>;;Minimum label value";
          }
        }
        leaf max {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<16-471804>;;Maximum label value";
          }
        }
      }
    }
    container ldp {
      tailf:info "Label Distribution Protocol";
      tailf:cli-diff-dependency "/nx:feature/mpls/ldp";
      container configuration {
        tailf:info "Enter LDP global configuration submode";
        tailf:cli-add-mode;

        leaf advertise-labels {
          tailf:info "Label advertisements";
          tailf:cli-full-command;
          tailf:cli-boolean-no;
          default "true";
          type boolean;
        }

        container advertise-labels-config {
          tailf:cli-drop-node-name;
          container advertise-labels {
            tailf:info "Label advertisements";
            tailf:cli-incomplete-command;
            tailf:cli-incomplete-no;
            list for {
              tailf:info "Prefix list specifying controls on destination prefixes";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-remove-before-change;
              key name;
              leaf name {
                type string {
                  tailf:info "WORD;;Name of prefix list";
                }
              }
              leaf to {
                tailf:info "Prefix list specifying controls on LDP peers";
                type string {
                  tailf:info "WORD;;Name of prefix list";
                }
              }
            }
            list interface {
              tailf:info "Advertise /32 interface address";
              tailf:cli-suppress-mode;
              tailf:cli-diff-set-after "/nx:interface";
              tailf:cli-diff-delete-before "/nx:interface";
              key name;
              leaf name {
                type string {
                  tailf:info "interface";
                }
              }
            }
          }
        }

        container backoff {
          tailf:info "Set LDP session backoff parameters";
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-compact-syntax;
          leaf initial {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<5-2147483>;;Initial session backoff time (seconds)";
            }
          }
          leaf maximum {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<5-2147483>;;Maximum session backoff time (seconds)";
            }
          }
        }

        container discovery {
          tailf:info "LDP discovery";
          container hello {
            tailf:info "LDP discovery Hello";
            leaf holdtime {
              tailf:info "LDP discovery Hello holdtime";
              type uint16 {
                tailf:info "<1-65535>;;Holdtime in seconds";
              }
            }
            leaf interval {
              tailf:info "LDP discovery Hello interval";
              type uint16 {
                tailf:info "<1-65535>;;Hello interval in seconds";
              }
            }
          }

          container targeted-hello {
            tailf:info "LDP discovery Targeted Hello";
            container accept {
              tailf:info "Accept targeted hellos";
              presence "true";
              leaf from {
                tailf:info "Prefix list to specify acceptable targeted hello sources";
                type string {
                  tailf:info "WORD;;Name of prefix list";
                }
              }
            }
            leaf holdtime {
              tailf:info "LDP discovery Targeted Hello holdtime";
              type uint16 {
                tailf:info "<1-65535>;;Holdtime in seconds";
              }
            }
            leaf interval {
              tailf:info "LDP discovery Targeted Hello interval";
              type uint16 {
                tailf:info "<1-65535>;;Hello interval in seconds";
              }
            }
          }
        }

        container explicit-null {
          tailf:info "Advertise Explicit Null label in place of Implicit Null";
          presence "true";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf for {
            tailf:info "Prefix list specifying controls on destination prefixes";
            tailf:cli-optional-in-sequence;
            type string {
              tailf:info "WORD;;Name of prefix list";
            }
          }
          leaf to {
            tailf:info "Access-list specifying controls on LDP peers";
            type string {
              tailf:info "WORD;;Name of prefix list";
            }
          }
        }

        leaf graceful-restart {
          tailf:info "Configure LDP Graceful Restart";
          tailf:cli-full-command;
          tailf:cli-boolean-no;
          default "true";
          type boolean;
        }

        container gracefule-restart-config {
          tailf:cli-drop-node-name;
          container graceful-restart {
            tailf:info "Configure LDP Graceful Restart";
            tailf:cli-incomplete-command;
            tailf:cli-incomplete-no;
            container timers {
              tailf:info "Configure Graceful Restart timers";
              leaf forwarding-holding {
                tailf:info "Forwarding State Holding time";
                type uint16 {
                  tailf:info "<30-600>;;Seconds";
                }
              }
              leaf max-recovery {
                tailf:info "Max-Recovery time";
                type uint16 {
                  tailf:info "<15-600>;;Seconds";
                }
              }
              leaf neighbor-liveness {
                tailf:info "Neighbor-Liveness time";
                type uint16 {
                  tailf:info "<15-600>;;Seconds";
                }
              }
            }
          }
        }

        leaf holdtime {
          tailf:info "LDP session holdtime";
          type union {
            type uint16 {
              tailf:info "<15-65535>;;Holdtime in seconds";
            }
            type enumeration {
              enum infinite {
                tailf:info "Ignore LDP session holdtime";
              }
            }
          }
        }

        container label {
          tailf:info "LDP label configuration";
          container allocate {
            tailf:info "Allocate local labels";
            container global {
              tailf:info "Specify default VPN Routing/Forwarding instance";
              choice instance-choice {
                leaf all-routes {
                  tailf:info "Allocate local labels for all routes";
                  type empty;
                }
                leaf host-routes {
                  tailf:info "Allocate local labels for host routes only (default)";
                  type empty;
                }
                leaf prefix-list {
                  tailf:info "Specify a prefix-list for local label filtering";
                  type string {
                    tailf:info "WORD;;IP prefix-list for destination prefixes";
                  }
                }
              }
            }
          }
        }

        container logging {
          tailf:info "Enable LDP logging";
          leaf neighbor-changes {
            tailf:info "Log LDP neighbor state changes";
            tailf:cli-boolean-no;
            default "true";
            type boolean;
          }
          container password {
            tailf:info "Log LDP password events";
            choice configuration-choice {
              default "configuration";
              leaf configuration {
                tailf:info "Log LDP password configuration changes";
                tailf:cli-boolean-no;
                tailf:cli-full-command;
                default "true";
                type boolean;
              }
              container configuration-rate-limit {
                tailf:cli-drop-node-name;
                container configuration {
                  tailf:info "Log LDP password configuration changes";
                  tailf:cli-incomplete-command;
                  leaf rate-limit {
                    type uint8 {
                      tailf:info "<1-60>;;Messages per minute";
                    }
                  }
                }
              }
            }
            choice rollover-choice {
              default "rollover";
              leaf rollover {
                tailf:info "Log LDP password rollover events";
                tailf:cli-boolean-no;
                tailf:cli-full-command;
                default "true";
                type boolean;
              }
              container rollover-rate-limit {
                tailf:cli-drop-node-name;
                container rollover {
                  tailf:info "Log LDP password rollover events";
                  leaf rate-limit {
                    type uint8 {
                      tailf:info "<1-60>;;Messages per minute";
                    }
                  }
                }
              }
            }
          }
        }

        container mpls {
          tailf:info "MPLS configuration commands";
          container ip {
            tailf:info "Dynamic MPLS forwarding for IP";
            leaf default-route {
              tailf:info "Allow MPLS forwarding for ip default route";
              type empty;
            }
          }
          //          static  MPLS static application
        }

        list neighbor {
          tailf:info "Configure neighbor parameters";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          key address;
          leaf address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP address for LDP neighbor";
            }
          }
          leaf implicit-withdraw {
            tailf:info "Enable LDP Implicit Withdraw Label";
            type empty;
          }
          container labels {
            tailf:info "Configure label binding exchange controls";
            leaf accept {
              tailf:info "Specify label bindings to accept";
              type string {
                tailf:info "WORD;;Name of prefix list";
              }
            }
          }
          leaf targeted {
            tailf:info "Establish targeted session";
            type empty;
          }
        }

        container password {
          tailf:info "Configure LDP password";
          container fallback {
            tailf:info "Specifies a fallback password will follow";
            leaf key-chain {
              tailf:info "Specifies a key-chain name will follow";
              type string {
                tailf:info "WORD;;Key-chain name";
              }
            }
          }
          list option {
            tailf:info "WORD;;Key-chain name";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            tailf:cli-compact-syntax;
            key "sequence";
            leaf sequence {
              type uint16 {
                tailf:info "<1-32767>;;Sequence number of the LDP password option";
              }
            }
            leaf for {
              tailf:info "Prefix list specifying control on LDP peers";
              tailf:cli-incomplete-command;
              type string {
                tailf:info "WORD;;Prefix list for LDP peers";
              }
            }
            leaf key-chain {
              tailf:info "Specifies a key-chain name will follow";
              type string {
                tailf:info "WORD;;Key-chain name";
              }
            }
          }
          container required {
            tailf:info "Password is required for the peer";
            presence "true";
            leaf for {
              tailf:info "Prefix list specifying control on LDP peers";
              type string {
                tailf:info "WORD;;Prefix list for LDP peers";
              }
            }
          }
        }

        leaf router-id {
          tailf:info "Select interface to prefer for LDP identifier address";
          tailf:cli-diff-set-after "/nx:interface";
          tailf:cli-diff-delete-before "/nx:interface";
          type string {
            tailf:info "ethernet|loopback|port-channel<N>;;interface";
          }
        }

        container session {
          tailf:info "Configure session parameters";
          container protection {
            tailf:info "Configure session protection parameters";
            presence "true";
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            tailf:cli-compact-syntax;
            leaf for {
              tailf:info "Prefix list to specify LDP peers";
              tailf:cli-optional-in-sequence;
              type string {
                tailf:info "WORD;;Prefix list for LDP peers";
              }
            }
            leaf duration {
              tailf:info "Period to sustain session protection after loss of link discovery";
              type union {
                type uint32 {
                  tailf:info "<30-2147483>;Holdup time in seconds";
                }
                type enumeration {
                  enum infinite {
                    tailf:info "Protect session forever after loss of link discovery";
                  }
                }
              }
            }
          }
        }

        leaf shutdown {
          tailf:info "Disable MPLS forwarding for IP";
          tailf:cli-boolean-no;
          default "false";
          type boolean;
        }
      }
    }
  }


  /// ========================================================================
  /// segment-routing
  /// ========================================================================

  container segment-routing {
    tailf:info "Segment-routing properties";
    tailf:cli-add-mode;
    nx:handle-sr-mpls-no-mode; // nxos < 9.3 segment-routing is no mode with mpls
    container mpls {
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-segment-routing-mpls";
      tailf:info "MPLS configuration commands";
      nx:handle-sr-mpls-no-mode;

      container global-block {
        tailf:info "Specify global block range for Segment Routing bindings";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-diff-dependency "/nx:feature/mpls/segment-routing";
        leaf min {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<16-471804>;;Minimum label value";
          }
        }
        leaf max {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<16-471804>;;Maximum label value";
          }
        }
      }
      container connected-prefix-sid-map {
        tailf:info "Configure connected prefix Segment Identifier mappings";
        tailf:cli-add-mode;
        tailf:cli-diff-dependency "/nx:feature/mpls/segment-routing";
        presence true;
        container address-family {
          tailf:info "Configure an address-family";
          container ipv4 {
            tailf:cli-add-mode;
            presence true;
            list prefix-format {
              tailf:cli-suppress-mode;
              tailf:cli-drop-node-name;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              key address;
              leaf address {
                type inet:ipv4-prefix;
              }
              leaf type {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type enumeration {
                  enum absolute {
                    tailf:info "Absolute value of SID";
                  }
                  enum index {
                    tailf:info "Index of SID wrt SRGB";
                  }
                }
              }
              leaf start {
                tailf:cli-drop-node-name;
                cli:globally-unique-value "segment-id";
                type uint32 {
                  tailf:info "<0-471804>;;Start of SID";
                }
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// vlan
  /// ========================================================================

  container vlan {
    tailf:info "Vlan commands";

    // vlan *
    list vlan-list {
      tailf:cli-drop-node-name;
      tailf:cli-mode-name "config-vlan";
      tailf:cli-range-list-syntax;
      tailf:cli-explicit-exit;
      key id;
      leaf id {
        type uint16 {
          tailf:info "<1-4094>;;VLAN ID 1-4094 or "
            +"range(s): 1-5, 10 or 2-5,7-19";
          range "1..4094";
        }
      }

      // vlan * / ip
      uses vlan-bd-config-grouping;

      // vlan * / mode
      leaf mode {
        tailf:info "Operational mode of the VLAN";
        default "ce";
        type enumeration {
          enum ce {
            tailf:info "Classical Ethernet VLAN mode";
          }
          enum fabricpath {
            tailf:info "Fabricpath VLAN mode";
          }
        }
      }

      container fcoe {
        tailf:info "FCOE Congiguration";
        leaf vsan {
          tailf:info "Translated VSAN Status";
          tailf:cli-remove-before-change;
          type uint16 {
            tailf:info "<1-4094>;;Enter VSAN-ID being associated with VLAN-ID";
          }
        }
      }

      // vlan * / name
      leaf name {
        tailf:info "Ascii name of the VLAN";
        tailf:cli-full-command;
        tailf:cli-diff-dependency "/nx:system/vlan/long-name" {
          tailf:cli-trigger-on-set;
        }
        tailf:cli-remove-before-change;
        cli:globally-unique-value "vlan-name";
        type string {
          tailf:info "WORD;;The ascii name for the VLAN (Max Size 128)";
          length "1..128";
        }
      }

      // vlan * / shutdown
      leaf shutdown {
        tailf:info "Shutdown VLAN switching";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default "false";
      }

      // vlan * / state
      leaf state {
        tailf:info "Operational state of the VLAN";
        tailf:cli-full-command;
        type enumeration {
          enum "active" {
            tailf:info "VLAN Active State";
          }
          enum "suspend" {
            tailf:info "VLAN Suspended State";
          }
        }
        default "active";
      }

      // vlan * / vn-segment
      leaf vn-segment {
        tailf:info "VN Segment id of the VLAN";
        tailf:cli-full-command;
        tailf:cli-diff-delete-before "/nx:feature/vn-segment-vlan-based" {
          tailf:cli-when-target-delete;
        }
        tailf:cli-remove-before-change;
        cli:globally-unique-value "vlan-vn-segment-mapping";
        type uint32 {
          tailf:info "<4096-16777215>;;Segment-id";
        }
      }

      container private-vlan {
        tailf:cli-diff-delete-before "/nx:feature/private-vlan";
        choice vlan-type {
          leaf community {
            tailf:info "Configure the VLAN as community private VLAN";
            type empty;
          }
          leaf isolated {
            tailf:info "Configure the VLAN as isolated private VLAN";
            type empty;
          }
          leaf primary {
            tailf:info "Configure the VLAN as primary private VLAN";
            type empty;
          }
        }
        leaf-list association {
          tailf:cli-range-list-syntax;
          tailf:cli-diff-delete-before "/nx:vlan/vlan-list/private-vlan/association" {
            tailf:cli-when-target-set;
          }
          tailf:info "Add association between private VLANs";
          type uint16 {
            tailf:info "<1-4094>;;VLAN IDs of the private VLANs to be configured";
          }
        }
      }
    }

    // vlan configuration * /
    list configuration {
      tailf:cli-mode-name "config-vlan-config";
      tailf:cli-range-list-syntax;
      key id;
      leaf id {
        type uint16 {
          tailf:info "<1-4094>;;VLAN ID 1-4094 or "
            +"range(s): 1-5, 10 or 2-5,7-19";
          range "1..4094";
        }
      }
      uses vlan-bd-config-grouping;
    }

    // vlan access-map *
    list access-map {
      tailf:info "Configure a VLAN access map";
      tailf:cli-mode-name "config-access-map";
      key name;
      leaf name {
        tailf:cli-multi-word-key;
        type string {
          tailf:info "WORD;;Access map name (Max Size 64) [<1-4294967295>  Sequence number]";
          length "1..64";
        }
      }

      // vlan access-map * / match
      container match {
        tailf:info "Specify the match clause";

        // vlan access-map * / match ip address
        container ip {
          tailf:info "Display IP information";
          leaf address {
            tailf:info "Match an access list";
            tailf:cli-remove-before-change;
            type string {
              tailf:info "WORD;;List name (Max Size 64)";
              length "1..64";
            }
          }
        }

        // vlan access-map * / match ipv6 address
        container ipv6 {
          tailf:info "Display IPv6 information";
          leaf address {
            tailf:info "Match an access list";
            tailf:cli-remove-before-change;
            type string {
              tailf:info "WORD;;List name (Max Size 64)";
              length "1..64";
            }
          }
        }

        // vlan access-map * / match mac address
        container mac {
          tailf:info "MAC configuration commands";
          leaf address {
            tailf:info "Match an access list";
            tailf:cli-remove-before-change;
            type string {
              tailf:info "WORD;;List name (Max Size 64)";
              length "1..64";
            }
          }
        }
      }

      // vlan access-map * / action
      container action {
        tailf:info "Specify the action clause";
        choice action-choice {
          leaf drop {
            tailf:info "Drop matched packets";
            type empty;
          }
          leaf forward {
            tailf:info "Forward matched packets";
            type empty;
          }
          leaf redirect {
            type string {
              tailf:info "WORD;;Interface name";
            }
          }
        }
      }

      // vlan access-map * / statistics per-entry
      container statistics {
        tailf:info "Enable per-entry statistics for the ACL";
        leaf per-entry {
          tailf:info "Collect stats for each ACL entry";
          type empty;
        }
      }
    }

    // vlan filter *
    list filter {
      tailf:info "Specify access control for packets";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-diff-dependency "../access-map";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Access map name (Max Size 64)";
        }
      }

      // vlan filter * vlan-list
      leaf-list vlan-list {
        tailf:info "Specify list of VLANs to apply access control";
        tailf:cli-range-list-syntax;
        type uint16 {
          tailf:info "<1-3967,4048-4093>;;List of VLANs";
          range "1..4093";
        }
      }
    }

    // vlan dot1Q
    container dot1Q {
      tailf:info "IEEE 802.1Q Virtual LAN";
      // vlan dot1Q tag
      container tag {
        tailf:info "Tag parameters";
        // vlan dot1Q tag native
        leaf native {
          tailf:info "Tag native vlan";
          type empty;
        }
      }
    }

  }


  /// ========================================================================
  /// evpn
  /// ========================================================================
  container evpn {
    tailf:info "Enter EVPN configuration mode";
    tailf:cli-add-mode;
    tailf:cli-full-command;
    tailf:cli-diff-delete-before "/nx:feature/bgp";
    presence "true";

    // evpn evi *
    list evi {
      tailf:info "Configure Ethernet VPN ID";
      key id;
      leaf id {
        type uint32 {
          tailf:info "<1-16777215>;;Specify VNI ID";
        }
      }
      leaf vni {
        tailf:info "VNI";
        tailf:cli-hide-in-submode;
        type empty;
      }
      container bgp {
        tailf:info "Enter EVPN BGP configuration mode";
        tailf:cli-add-mode;
        leaf rd {
          tailf:info "VPN Route Distinguisher";
          type string;
        }
        list route-target {
          tailf:info "Specify Target VPN Extended Communities";
          tailf:cli-suppress-mode;
          key "method";
          leaf method {
            type enumeration {
              enum "import" {
                tailf:info "Import Target-VPN community";
              }
              enum "export" {
                tailf:info "Export Target-VPN community";
              }
            }
          }
          leaf rt {
            tailf:cli-drop-node-name;
            type union {
              type enumeration {
                enum "auto" {
                  tailf:info "Generate RT automatically";
                }
              }
              type asn-ip-type;
            }
          }
        }
      }
    }

    // evpn vni *
    list vni {
      tailf:info "Configure Ethernet VPN ID";
      key id;
      leaf id {
        type uint32 {
          tailf:info "<1-16777215>;;Specify VNI ID";
        }
      }

      leaf l2 {
        tailf:info "Layer-2 VNI";
        tailf:cli-hide-in-submode;
        type empty;
      }

      leaf rd {
        tailf:info "VPN Route Distinguisher";
        type union {
          type enumeration {
            enum "auto" {
              tailf:info "Generate RD automatically";
            }
          }
          type asn-ip-type;
        }
      }

      list route-target {
        tailf:info "Specify Target VPN Extended Communities";
        tailf:cli-suppress-mode;
        key "method rt";
        leaf method {
          type enumeration {
            enum "import" {
              tailf:info "Import Target-VPN community";
            }
            enum "export" {
              tailf:info "Export Target-VPN community";
            }
          }
        }
        leaf rt {
          type union {
            type enumeration {
              enum "auto" {
                tailf:info "Generate RT automatically";
              }
            }
            type asn-ip-type;
          }
        }
      }
    }

  }

  container evpn-flat-syntax {
    tailf:cli-drop-node-name;
    container evpn {
      tailf:info "VxLAN evpn feature";
      tailf:cli-incomplete-command;
      container multisite {
        tailf:info "Multisite";
        tailf:cli-diff-dependency "/nx:feature/nv/overlay";
        tailf:cli-add-mode;
        presence "true";
        leaf border-gateway {
          tailf:info "Border-gateway";
          tailf:cli-hide-in-submode;
          type uint64 {
            tailf:info "<1-281474976710655>;;Multisite Site-Id";
          }
        }
        container delay-restore {
          tailf:info "Delay-restore";
          leaf time {
            tailf:info "Time";
            default 180;
            type uint16 {
              tailf:info "<30-1000>;;Time in seconds";
            }
          }
        }
      }

      // evpn esi multihoming
      container esi {
        tailf:info "ESI based multihoming";
        leaf multihoming {
          tailf:info "Multihoming feature";
          type empty;
        }
      }

      // evpn storm-control
      container storm-control {
        tailf:info "Storm-control";
        grouping level-grouping {
          leaf level {
            tailf:info "Traffic level";
            type uint8 {
              tailf:info "<0-100>;;Enter the storm suppression level";
              range "0..100";
            }
          }
        }
        container broadcast {
          tailf:info "Broadcast Packets";
          uses level-grouping;
        }
        container multicast {
          tailf:info "Multicast Packets";
          uses level-grouping;
        }
        container unicast {
          tailf:info "Unknown Unicast Packets";
          uses level-grouping;
        }
      }

    }

  }


  /// ========================================================================
  /// route-map
  /// ========================================================================

  list route-map {
    tailf:info "Create route-map or enter route-map command mode";
    tailf:cli-compact-syntax;
    tailf:cli-full-command;
    key "name sequence";
    leaf name {
      nx:redeploy-pbr-stats;
      type string {
        tailf:info "WORD;;Route-map name (Max Size 63)";
        length "1..63";
      }
    }
    // route-map * #
    leaf sequence {
      type uint16 {
        tailf:info "<0-65535>;;Sequence to insert to/delete from "
          +"existing route-map entry";
        range "0..65535";
      }
    }

    // route-map * permit
    // route-map * deny
    leaf operation {
      tailf:cli-drop-node-name;
      tailf:cli-prefix-key {
        tailf:cli-before-key "2";
      }
      type enumeration {
        enum "deny" {
          tailf:info "Route map denies set operations";
        }
        enum "permit" {
          tailf:info "Route map permits set operations";
        }
      }
      default "permit";
    }

    // route-map * / match
    container match {
      tailf:info "Match values from routing table";
      grouping addr-match-grouping {
        container address {
          tailf:info "Match address of route or match packet";
          leaf-list prefix-list {
            tailf:info "Match entries of prefix-lists";
            tailf:cli-flat-list-syntax;
            ordered-by user;
            type string;
          }
          leaf access-list {
            tailf:cli-drop-node-name;
            tailf:cli-remove-before-change;
            type string {
              tailf:info "WORD;;Access-list name (for use in route-maps for PBR only)";
              length "1..63";
            }
          }
        }
      }
      container ip {
        tailf:info "IP specific information";
        tailf:cli-diff-dependency "../ipv6" {
          tailf:cli-trigger-on-set;
        }
        uses addr-match-grouping;
        container multicast {
          tailf:info "Match multicast attributes";
          choice type-choice {
            leaf group {
              tailf:info "Multicast Group prefix";
              type tailf:ipv4-address-and-prefix-length {
                tailf:info "A.B.C.D/LEN;;IPv4 group prefix";
              }
            }
            container group-range {
              tailf:info "Multicast Group address range";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf first {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type inet:ipv4-address {
                  tailf:info "A.B.C.D  First Group address";
                }
              }
              leaf to {
                tailf:info "to;;Range";
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Last Group address";
                }
              }
            }
            leaf rp {
              tailf:info "Rendezvous point";
              type tailf:ipv4-address-and-prefix-length {
                tailf:info "A.B.C.D/LEN;;IPv4 rendezvous prefix";
              }
            }
            leaf source {
              tailf:info "Multicast source address";
              type tailf:ipv4-address-and-prefix-length {
                tailf:info "A.B.C.D/LEN;;IPv4 source prefix";
              }
            }
          }
        }
        container next-hop {
          tailf:info "Match next-hop address of route";
          leaf-list prefix-list {
            tailf:info "Match entries of prefix-lists";
            tailf:cli-flat-list-syntax;
            ordered-by user;
            type string {
              tailf:info "WORD;;Name of prefix-list (Max Size 63)";
            }
          }
        }
      }
      container ipv6 {
        tailf:info "IPv6 specific information";
        tailf:cli-diff-dependency "../ip" {
          tailf:cli-trigger-on-set;
        }
        uses addr-match-grouping;
      }
      leaf-list tag {
        tailf:info "Match tag of route";
        tailf:cli-flat-list-syntax;
        type uint32 {
          tailf:info "<0-4294967295>;;Tag value";
        }
      }
      container as-number {
        tailf:info "Match BGP peer AS number";
        leaf-list as-path-list {
          tailf:info "AS-path access-list";
          tailf:cli-flat-list-syntax;
          ordered-by user;
          type string {
            tailf:info "WORD;;AS path access list name (Max Size 63)";
          }
        }
        leaf-list as-number {
          tailf:cli-drop-node-name;
          tailf:cli-flat-list-syntax;
          nx:comma-separated-list;
          tailf:cli-diff-delete-before "../as-number" {
            tailf:cli-when-target-set;
          }
          type string {
            tailf:info "WORD;;<AA4> or <AA4>-<AA4>  (Max Size 11)";
            pattern "[0-9]+(-[0-9]+)?";
          }
        }
      }
      leaf-list as-path {
        tailf:info "Match BGP AS path list";
        tailf:cli-flat-list-syntax;
        type string {
          tailf:info "WORD;;AS path access list name (Max Size 63)";
          length "1..63";
        }
      }
      leaf-list community {
        tailf:info "Match BGP community list";
        tailf:cli-flat-list-syntax;
        type string {
          tailf:info "WORD;;Community list name (Max Size 63)";
          length "1..63";
        }
      }
      leaf-list extcommunity {
        tailf:info "Match BGP community list";
        tailf:cli-flat-list-syntax;
        type string {
          tailf:info "WORD  Extended Community list name (Max Size 63)";
          length "1..63";
        }
      }
      leaf-list route-type {
        tailf:info "Match route-type of route";
        tailf:cli-flat-list-syntax;
        type enumeration {
          enum external {
            tailf:info "External route (BGP, EIGRP and OSPF type 1/2)";
          }
          enum inter-area {
            tailf:info "OSPF inter area route";
          }
          enum internal {
            tailf:info "Internal route (including OSPF intra/inter area)";
          }
          enum intra-area {
            tailf:info "OSPF intra area route";
          }
          enum level-1 {
            tailf:info "IS-IS level-1 route";
          }
          enum level-2 {
            tailf:info "IS-IS level-2 route";
          }
          enum local {
            tailf:info "Locally generated route";
          }
          enum nssa-external {
            tailf:info "Nssa-external route (OSPF type 1/2)";
          }
          enum type-1 {
            tailf:info "OSPF external type 1 route";
          }
          enum type-2 {
            tailf:info "OSPF external type 2 route";
          }
        }
      }

      leaf-list metric {
        tailf:info "Match metric of route";
        tailf:cli-flat-list-syntax;
        type uint32 {
          tailf:info "<0-4294967295>;;Metric value";
        }
      }

      // route-map * / match interface
      leaf-list interface {
        tailf:info "Match first hop interface of route";
        tailf:cli-flat-list-syntax;
        tailf:cli-diff-dependency "/nx:feature/interface-vlan";
        nx:case-insensitive-type;
        type string {
          pattern "(([Ee]thernet)|([Ll]oopback)|([Pp]ort-channel)|([Vv]lan)|([Mm]gmt)|([Nn]ull)|([Bb]di))[0-9/\\.]+";
        }
      }

      leaf-list mac-list {
        tailf:info "Match entries of mac-lists";
        tailf:cli-flat-list-syntax;
        type string {
          tailf:info "WORD;;Mac list (Max Size 63)";
        }
      }

      leaf-list ospf-area {
        tailf:info "Match ospf area";
        tailf:cli-flat-list-syntax;
        tailf:cli-diff-dependency "/nx:feature/ospf";
        ordered-by user;
        type uint32 {
          tailf:info "<0-4294967295>;;Area id";
        }
      }
    }

    // route-map * / set
    container set {

      // route-map * / set as-path
      container as-path {
        tailf:info "Prepend string for a BGP AS-path attribute";
        container prepend {
          tailf:info "Prepend to the AS-Path";
          leaf as-list {
            tailf:cli-drop-node-name;
            tailf:cli-multi-value;
            type string {
              tailf:info "<1-4294967295>|<1-65535>[.<0-65535>];;AS number";
              pattern "(([0-9]+\\.)?([0-9]+) )*(([0-9]+\\.)?([0-9]+))";
            }
          }
          leaf last-as {
            tailf:info "Prepend last AS to the as-path";
            type uint8 {
              tailf:info "<1-10>;;Number of last-AS prepends";
              range "1..10";
            }
          }
        }
        leaf tag {
          tailf:info "Set the tag as an AS-path attribute";
          type empty;
        }
      }

      // route-map * / set distance
      leaf distance {
        tailf:info "Set the Administrative distance of route";
        type uint8 {
          tailf:info "<1-255>;;Administrative distance for IGP or EBGP routes";
          range "1..255";
        }
      }

      // route-map * / set interface
      leaf interface {
        tailf:info "Output interface";
        tailf:cli-diff-dependency "../ip/next-hop" {
          tailf:cli-trigger-on-set;
        }
        type enumeration {
          enum Null0 {
            tailf:info "Null interface";
          }
        }
      }

      // route-map * / set ip
      container ip {
        tailf:info "Configure IP features";
        container next-hop {
          tailf:info "Next hop address";
          tailf:cli-compact-syntax;

          leaf-list next-hop-addr {
            ordered-by user;
            tailf:cli-drop-node-name;
            tailf:cli-flat-list-syntax;
            tailf:cli-diff-dependency "../../../interface" {
              tailf:cli-trigger-on-set;
            }
            tailf:cli-diff-dependency "../peer-address" {
              tailf:cli-trigger-on-set;
            }
            tailf:cli-diff-dependency "../redist-unchanged" {
              tailf:cli-trigger-on-set;
            }
            tailf:cli-diff-dependency "../unchanged" {
              tailf:cli-trigger-on-set;
            }
            tailf:cli-diff-dependency "../verify-availability" {
              tailf:cli-trigger-on-set;
            }
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP address of next hop";
            }
          }
          leaf load-share {
            tailf:info "Enables load sharing";
            type empty;
          }
          leaf peer-address {
            tailf:info "Use peer address (for BGP only)";
            tailf:cli-diff-dependency "../unchanged" {
              tailf:cli-trigger-on-set;
            }
            tailf:cli-diff-dependency "../redist-unchanged" {
              tailf:cli-trigger-on-set;
            }
            tailf:cli-diff-dependency "../next-hop-addr" {
              tailf:cli-trigger-on-set;
            }
            type empty;
          }
          leaf redist-unchanged {
            tailf:info "Use unchanged address during redistribution (for BGP session only)";
            tailf:cli-diff-dependency "../peer-address" {
              tailf:cli-trigger-on-set;
            }
            tailf:cli-diff-dependency "../next-hop-addr" {
              tailf:cli-trigger-on-set;
            }
            type empty;
          }
          leaf unchanged {
            tailf:info "Use unchanged address (for eBGP session only)";
            tailf:cli-diff-dependency "../peer-address" {
              tailf:cli-trigger-on-set;
            }
            tailf:cli-diff-dependency "../next-hop-addr" {
              tailf:cli-trigger-on-set;
            }
            type empty;
          }
          list verify-availability {
            tailf:info "Verify the reachability of the tracked object";
            tailf:cli-suppress-mode;
            tailf:cli-compact-syntax;
            tailf:cli-delete-when-empty;
            tailf:cli-diff-dependency "../peer-address" {
              tailf:cli-trigger-on-set;
            }
            tailf:cli-diff-dependency "../next-hop-addr" {
              tailf:cli-trigger-on-set;
            }
            nx:explicit-ordered-by-user;
            ordered-by user;
            key "addr";
            leaf addr {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IP address of next hop";
              }
            }
            leaf track {
              tailf:info "The tracking method is track";
              tailf:cli-reset-container;
              tailf:non-strict-leafref {
                path "/nx:track/id";
              }
              type uint16 {
                tailf:info "<1-512>;;Object number that the tracking subsystem is tracking";
              }
            }
            leaf load-share {
              tailf:info "Enables load sharing";
              tailf:cli-reset-container;
              type empty;
            }
          }
        }
      }

      // route-map * / set ipv6
      container ipv6 {
        tailf:info "Configure IPv6 features";
        container next-hop {
          tailf:info "Next hop ipv6 address";
          tailf:cli-compact-syntax;

          leaf-list next-hop-addr {
            ordered-by user;
            tailf:cli-drop-node-name;
            tailf:cli-flat-list-syntax;
            tailf:cli-diff-dependency "../../../interface" {
              tailf:cli-trigger-on-set;
            }
            tailf:cli-diff-dependency "../peer-address" {
              tailf:cli-trigger-on-set;
            }
            tailf:cli-diff-dependency "../redist-unchanged" {
              tailf:cli-trigger-on-set;
            }
            tailf:cli-diff-dependency "../unchanged" {
              tailf:cli-trigger-on-set;
            }
            tailf:cli-diff-dependency "../verify-availability" {
              tailf:cli-trigger-on-set;
            }
            type inet:ipv6-address {
              tailf:info "A:B::C:D;;Next hop ipv6 address";
            }
          }
          leaf load-share {
            tailf:info "Enables load sharing";
            type empty;
          }
          leaf peer-address {
            tailf:info "Use peer address (for BGP only)";
            tailf:cli-diff-dependency "../unchanged" {
              tailf:cli-trigger-on-set;
            }
            tailf:cli-diff-dependency "../redist-unchanged" {
              tailf:cli-trigger-on-set;
            }
            tailf:cli-diff-dependency "../next-hop-addr" {
              tailf:cli-trigger-on-set;
            }
            type empty;
          }
          leaf redist-unchanged {
            tailf:info "Use unchanged address during redistribution (for BGP session only)";
            tailf:cli-diff-dependency "../peer-address" {
              tailf:cli-trigger-on-set;
            }
            tailf:cli-diff-dependency "../next-hop-addr" {
              tailf:cli-trigger-on-set;
            }
            type empty;
          }
          leaf unchanged {
            tailf:info "Use unchanged address (for eBGP session only)";
            tailf:cli-diff-dependency "../peer-address" {
              tailf:cli-trigger-on-set;
            }
            tailf:cli-diff-dependency "../next-hop-addr" {
              tailf:cli-trigger-on-set;
            }
            type empty;
          }
          list verify-availability {
            tailf:info "Verify the reachability of the tracked object";
            tailf:cli-suppress-mode;
            tailf:cli-compact-syntax;
            tailf:cli-delete-when-empty;
            tailf:cli-diff-dependency "../peer-address" {
              tailf:cli-trigger-on-set;
            }
            tailf:cli-diff-dependency "../next-hop-addr" {
              tailf:cli-trigger-on-set;
            }
            nx:explicit-ordered-by-user;
            ordered-by user;
            key "addr";
            leaf addr {
              type inet:ipv6-address {
                tailf:info "A:B::C:D  IP address of next hop";
              }
            }
            leaf track {
              tailf:info "The tracking method is track";
              tailf:cli-reset-container;
              tailf:non-strict-leafref {
                path "/nx:track/id";
              }
              type uint16 {
                tailf:info "<1-512>;;Object number that the tracking subsystem is tracking";
              }
            }
            leaf load-share {
              tailf:info "Enables load sharing";
              tailf:cli-reset-container;
              type empty;
            }
          }
        }
      }

      // route-map * / set label-index
      leaf label-index {
        tailf:info "Set Segment Routing (SR) label index of route";
        type uint32 {
          tailf:info "<0-471788>;;Segment Routing (SR) label index";
        }
      }

      // route-map * / set local-preference
      leaf local-preference {
        tailf:info "BGP local preference path attribute";
        type uint32 {
          tailf:info "Preference value";
        }
      }

      // route-map * / set metric
      container metric {
        tailf:info "Set metric for destination routing protocol";
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        leaf value {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;[+/-] Metric value or Bandwidth in Kbits per second (Max Size 11)";
            length "1..11";
          }
        }
        leaf igrp-delay {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<1-4294967295>;;IGRP delay metric";
          }
        }
        leaf igrp-reliability {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<0-255>;;IGRP reliability metric where 255 is 100% reliable";
          }
        }
        leaf igrp-effective {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<1-255>;;IGRP Effective bandwidth metric (Loading) 255 is 100%";
          }
        }
        leaf igrp-mtu {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-16777215>;;IGRP MTU of the path";
            range "1..16777215";
          }
        }
      }

      // route-map * / set metric-type
      leaf metric-type {
        tailf:info "Type of metric for destination routing protocol";
        type enumeration {
          enum external {
            tailf:info "IS-IS external metric";
          }
          enum internal {
            tailf:info "Use IGP metric as the MED for BGP";
          }
          enum type-1 {
            tailf:info "OSPF external type 1 metric";
          }
          enum type-2 {
            tailf:info "OSPF external type 2 metric";
          }
        }
      }

      // route-map * / set nssa-only
      leaf nssa-only {
        tailf:info "OSPF NSSA Areas";
        type empty;
      }

      // route-map * / set community
      container community {
        tailf:info "BGP community attribute";
        tailf:cli-sequence-commands;
        tailf:cli-compact-syntax;
        choice number-or-none-choice {
          case number {
            leaf-list community-number {
              tailf:cli-drop-node-name;
              tailf:cli-flat-list-syntax;
              tailf:cli-disallow-value "additive";
              nx:explicit-delete-additive; // quirk for NSO bug
              type union {
                type uint32 {
                  tailf:info "<1-4294967295>;;community number";
                  range "1..4294967295";
                }
                type enumeration {
                  enum "internet" {
                    tailf:info "Internet (well-known community)";
                  }
                  enum local-AS {
                    tailf:info "Do not send outside local AS "
                      +"(well-known community)";
                  }
                  enum no-advertise {
                    tailf:info "Do not advertise to any peer "
                      +"(well-known community)";
                  }
                  enum no-export {
                    tailf:info "Do not export to next AS "
                      +"(well-known community)";
                  }
                }
                type string {
                  tailf:info "aa:nn;;community number in aa:nn format";
                  pattern "[0-9]+:[0-9]+";
                }
              }
            }
            leaf additive {
              tailf:info "Add to the existing community";
              type empty;
            }
          }
          leaf none {
            tailf:info "No community attribute";
            type empty;
          }
        }
      }

      container extcommunity {
        tailf:info "Set BGP extcommunity attribute";
        container four-byteas-generic {
          tailf:alt-name "4byteas-generic";
          tailf:info "Generic extended community";
          nx:split-compact-line "non-transitive|transitive|additive";
          choice set-or-none-choice {
            leaf none {
              tailf:info "No extcommunity generic attribute";
              type empty;
            }
            container set {
              tailf:cli-drop-node-name;
              list transitive {
                tailf:info "Transitive extended community";
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                key number;
                leaf number {
                  type string {
                    tailf:info "ASN4:NN;;Extcommunity number aa4:nn format";
                  }
                }
              }
              list non-transitive {
                tailf:info "Non-Transitive extended community";
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                key number;
                leaf number {
                  type string {
                    tailf:info "ASN4:NN;;Extcommunity number aa4:nn format";
                  }
                }
              }
              leaf additive {
                tailf:info "Add to existing generic extcommunity";
                type empty;
              }
            }
          }
        }
        container cost {
          tailf:info "Cost";
          nx:split-compact-line "igp|pre-bestpath";
          list pre-bestpath {
            tailf:info "Compare before all other steps in bestpath calculation";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key id;
            leaf id {
              type uint8 {
                tailf:info "<0-255>;;Community ID";
              }
            }
            leaf cost {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<0-4294967295>;;Cost Community value";
              }
            }
          }
          list igp {
            tailf:info "Compare following IGP cost comparison";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key id;
            leaf id {
              type uint8 {
                tailf:info "<0-255>;;Community ID";
              }
            }
            leaf cost {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<0-4294967295>;;Cost Community value";
              }
            }
          }
        }
        container rt {
          tailf:info "Route-Target";
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-compact-syntax;
          leaf-list ext-comm {
            tailf:cli-drop-node-name;
            tailf:cli-flat-list-syntax;
            tailf:cli-replace-all;
            tailf:cli-remove-before-change;
            tailf:cli-disallow-value "additive";
            type asn-ip-type;
          }
          leaf additive {
            type empty;
          }
        }
      }

      // route-map * / set tag
      leaf tag {
        tailf:info "Tag value for destination routing protocol";
        type uint32 {
          tailf:info "<0-4294967295>;;Tag value";
        }
      }

      // route-map * / set path-selection
      container path-selection {
        tailf:info "Path selection criteria for BGP";
        container all {
          tailf:info "Specifies all BGP Paths";
          leaf advertise {
            tailf:info "Advertise add paths to its peers if receive capability enabled";
            type empty;
          }
        }
      }

      // route-map * / set vrf
      leaf vrf {
        tailf:info "Set the VRF for next-hop resolution";
        type vrf-member-type;
      }

      leaf weight {
        tailf:info "BGP weight for routing table";
        type uint16 {
          tailf:info "<0-65535>;;Weight value";
        }
      }

      leaf origin {
        tailf:info "BGP origin code";
        type enumeration {
          enum egp {
            tailf:info "Remote EGP";
          }
          enum igp {
            tailf:info "Local IGP";
          }
          enum incomplete {
            tailf:info "Unknown heritage";
          }
        }
      }
    }

    leaf description {
      tailf:info "Description of the route-map";
      tailf:cli-full-command;
      tailf:cli-multi-value;
      tailf:cli-preformatted;
      tailf:cli-no-value-on-delete;
      type string {
        tailf:info "LINE;;Route-map description string (Max Size 90)";
        length "1..90";
      }
    }

    // route-map * / continue
    leaf continue {
      tailf:info "Continue on a different entry within the route-map";
      type uint16 {
        tailf:info "<0-65535>;;Route-map entry sequence number";
      }
    }

  }

  container pbr-stats-route-map {
    tailf:cli-drop-node-name;
    list route-map {
      tailf:info "Create route-map or enter route-map command mode";
      tailf:cli-suppress-mode;
      tailf:cli-compact-syntax;
      tailf:cli-diff-dependency "/nx:feature/pbr";
      tailf:cli-diff-dependency "../../route-map";
      tailf:cli-incomplete-command;
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Route-map name (Max Size 63)";
          length "1..63";
        }
      }
      leaf pbr-statistics {
        tailf:info "Statistics for policy based routing";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// class-map
  /// ========================================================================

  container class-map {
    tailf:info "Configure a class-map";
    container type {
      tailf:info "Specify the type of this class-map";
      list qos {
        tailf:info "Qos class";
        tailf:cli-mode-name "config-cmap-qos";
        key name;
        leaf name {
          type class-name-type;
        }
        leaf prematch {
          tailf:cli-prefix-key;
          tailf:cli-drop-node-name;
          tailf:cli-show-with-default;
          tailf:ned-default-handling report-all;
          type enumeration {
            enum match-all {
              tailf:info "Logical-AND all matching statements under "
                +"this classmap";
            }
            enum match-any {
              tailf:info "Logical-OR all matching statements under "
                +"this classmap";
            }
          }
          default "match-all";
        }
        leaf description {
          tailf:info "Class-Map description";
          tailf:cli-full-command;
          tailf:cli-multi-value;
          tailf:cli-preformatted;
          tailf:cli-no-value-on-delete;
          type string {
            tailf:info "LINE;;Description of this class-map (up to 200 "
              +"characters)";
          }
        }
        container match {
          tailf:info "Classification criteria";
          uses match-grouping;
        }
      }
      list network-qos {
        tailf:info "Network Qos class";
        tailf:cli-mode-name "config-cmap-nq";
        key name;
        leaf name {
          type class-name-type;
        }
        leaf prematch {
          tailf:cli-prefix-key;
          tailf:cli-drop-node-name;
          type enumeration {
            enum match-any {
              tailf:info "Logical-OR all matching statements under "
                +"this classmap";
            }
          }
        }
        leaf description {
          tailf:info "Class-Map description";
          tailf:cli-full-command;
          tailf:cli-multi-value;
          tailf:cli-preformatted;
          tailf:cli-no-value-on-delete;
          type string {
            tailf:info "LINE;;Description of this class-map (up to 200 "
              +"characters)";
          }
        }
        container match {
          tailf:info "Classification criteria";
          leaf qos-group {
            tailf:info "QoS-group";
            type uint8 {
              tailf:info "<0-7>;;List of qos-group values";
              range "0..7";
            }
          }
        }
      }
      list queuing {
        tailf:info "Queuing class";
        tailf:cli-mode-name "config-cmap-que";
        key name;
        leaf name {
          type class-name-type;
        }
        leaf prematch {
          tailf:cli-prefix-key;
          tailf:cli-drop-node-name;
          type enumeration {
            enum match-any {
              tailf:info "Logical-OR all matching statements under "
                +"this classmap";
            }
          }
        }
        leaf description {
          tailf:info "Class-Map description";
          tailf:cli-full-command;
          tailf:cli-multi-value;
          tailf:cli-preformatted;
          tailf:cli-no-value-on-delete;
          type string {
            tailf:info "LINE;;Description of this class-map (up to 200 "
              +"characters)";
          }
        }
        container match {
          tailf:info "Classification criteria";
          leaf qos-group {
            tailf:info "QoS-group";
            type uint8 {
              tailf:info "<0-7>;;List of qos-group values";
              range "0..7";
            }
          }
          uses match-grouping;
        }
      }
      // class-map type control-plane
      list control-plane {
        tailf:info "Control-Plane";
        tailf:cli-mode-name "config-cmap";
        key name;
        leaf name {
          type class-name-type;
        }
        leaf prematch {
          tailf:cli-prefix-key;
          tailf:cli-drop-node-name;
          tailf:cli-show-with-default;
          type enumeration {
            enum match-all {
              tailf:info "Logical-AND all matching statements under "
                +"this classmap";
            }
            enum match-any {
              tailf:info "Logical-OR all matching statements under "
                +"this classmap";
            }
          }
          default "match-any";
        }
        // class-map type control-plane * match
        container match {
          tailf:info "Match Criteria";
          // class-map type control-plane * match access-group
          container access-group {
            tailf:info "Match with given access group";
            leaf-list name {
              tailf:info "Named Access List";
              tailf:cli-list-syntax;
              type string {
                length "1..64";
                tailf:info "WORD;;Access List name (Max Size 64)";
              }
            }
          }
          // class-map type control-plane * match protocol
          container protocol {
            tailf:info "Protocol";
            leaf arp {
              tailf:info "IP ARP";
              type empty;
            }
            container mpls {
              tailf:info "Multi-protocol Label Switching";
              tailf:cli-delete-when-empty;
              presence true;
              leaf router-alert {
                tailf:info "Match packets with router-alert label set to 1 fo"
                  +"r OTV Overlay frames";
                type empty;
              }
              leaf exp {
                type uint8;
              }
            }
          }
          // class-map type control-plane * match redirect
          container redirect {
            tailf:info "Match redirected packets";
            leaf arp-inspect {
              tailf:info "Match redirected packets for arp-inspect";
              type empty;
            }
            leaf dhcp-snoop {
              tailf:info "Match redirected packets for dhcp";
              type empty;
            }
          }
          // class-map type control-plane * match exception
          container exception {
            tailf:info "Match exception packets";
            // class-map type control-plane * match exception ip
            container ip {
              tailf:info "IPv4 match criteria";
              uses class-map-match-exception-ip-grouping;
            }
            // class-map type control-plane * match exception ipv6
            container ipv6 {
              tailf:info "IPv6 match criteria";
              uses class-map-match-exception-ip-grouping;
            }
            container multicast {
              tailf:info "Multicast packets";
              leaf dest-miss {
                tailf:info "L3 multicast destination lookup failure";
                type empty;
              }
              leaf ipv6-dest-miss {
                tailf:info "IPv6 L3 multicast destination lookup failure";
                type empty;
              }
              leaf ipv6-rpf-failure {
                tailf:info "IPv6 multicast rpf check failure";
                type empty;
              }
              leaf ipv6-sg-rpf-failure {
                tailf:info "IPv6 multicast sg rpf check failure";
                type empty;
              }
              leaf rpf-failure {
                tailf:info "Multicast rpf check failure";
                type empty;
              }
              leaf sg-rpf-failure {
                tailf:info "Multicast sg rpf check failure";
                type empty;
              }
              leaf directly-connected-sources {
                tailf:info "Directly connected sources";
                type empty;
              }
            }
            leaf fcoe-fib-miss {
              type empty;
            }
            leaf glean {
              tailf:info "Glean packets";
              type empty;
            }
            leaf mtu-failure {
              tailf:info "Mtu-failure";
              type empty;
            }
            leaf nat-flow {
              tailf:info "Ipv4 software nat flow packets";
              type empty;
            }
            leaf ttl-failure {
              tailf:info "Failed in ttl";
              type empty;
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// control-plane
  /// ========================================================================

  container control-plane {
    tailf:cli-add-mode;
    tailf:info "Enter to control-plane sub-mode";

    container scale-factor {
      tailf:info "Scale factor";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf scale {
        tailf:cli-drop-node-name;
        type decimal64 {
          fraction-digits "2";
          tailf:info "<whole>.<decimal>;;Specify scale factor value from 0.10 "
            +"to 2.00";
          range "0..2";
        }
      }

      leaf module {
        tailf:info "Module";
        type uint8 {
          tailf:info "<1-3>;;Specify module number";
          range "1..3";
        }
      }
    }
    container service-policy {
      tailf:info "Attach a policy to control-plane interface";
      leaf input {
        tailf:info "Input the policy name";
        tailf:non-strict-leafref {
          path "/nx:policy-map/type/control-plane/name";
        }
        nx:delete-with "copp profile strict" {
          when "/tailfned/dayzero-copp-profile-strict='true'";
        }
        type string {
          tailf:info "WORD;;Name of the policy (Max Size 64)";
        }
      }
    }
  }


  /// ========================================================================
  /// ntp
  /// ========================================================================

  container ntp {
    tailf:info "NTP Configuration";

    leaf authenticate {
      tailf:info "Enable/Disable authentication";
      type empty;
    }

    list authentication-key {
      tailf:info "NTP authentication key";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-sequence-commands;
      tailf:cli-compact-syntax;
      key id;
      leaf id {
        type uint16 {
          tailf:info "<1-65535>;;Authentication key number (range 1-65535)";
        }
      }

      leaf md5 {
        tailf:info "Use md5 authentication scheme";
        tailf:cli-incomplete-command;
        nx:device-transformed-value;
        type NEDCOM_SECRET_TYPE {
          tailf:info "WORD;;MD5 string (Max Size 32)";
        }
      }

      leaf encryption-type {
        tailf:cli-drop-node-name;
        nx:device-transformed-dependency;
        type enumeration {
          enum 0 {
            tailf:info "Clear text";
          }
          enum 7 {
            tailf:info "Encrypted";
          }
        }
      }
    }

    leaf trusted-key {
      tailf:info "NTP trusted-key";
      tailf:non-strict-leafref {
        path "../authentication-key/id";
      }
      type uint16 {
        tailf:info "<1-65535>;;Trusted-key number";
      }
    }

    // ntp commit
    leaf commit {
      tailf:info "Commit the ntp configuration";
      type empty;
    }

    // ntp distribute
    leaf distribute {
      tailf:info "Enable NTP configuration distribution";
      type empty;
    }

    // ntp peer *
    list peer {
      tailf:info "NTP Peer address";
      tailf:cli-suppress-mode;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      tailf:cli-compact-syntax;
      tailf:cli-delete-when-empty;
      key id;
      leaf id {
        type inet:ipv4-address;
      }
      leaf prefer {
        tailf:info "Preferred Server";
        tailf:cli-optional-in-sequence;
        type empty;
      }
      leaf use-vrf {
        tailf:info "Display per-VRF information";
        default "default";
        tailf:ned-default-handling report-all;
        type string {
          tailf:info "WORD;;VRF name (Max Size 32)";
        }
      }
      leaf key {
        tailf:info "Keyid to be used while communicating to this server";
        tailf:cli-optional-in-sequence;
        type uint16 {
          tailf:info "<1-65535>;;Value of keyid 1-65535";
        }
      }
      leaf minpoll {
        tailf:info "Minimum interval to poll a peer";
        default 4;
        type uint8 {
          tailf:info "<4-17>;;Poll interval in secs to a power of 2 [default 4]";
        }
      }
      leaf maxpoll {
        tailf:info "Maximum interval to poll a peer";
        default 6;
        type uint8 {
          tailf:info "<4-17>;;Poll interval in secs to a power of 2 [default 6]";
        }
      }
    }

    // ntp server *
    list server {
      tailf:info "NTP server address";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key id;
      leaf id {
        type string {
          tailf:info "A.B.C.D|WORD;;Hostname/IP address of the NTP Server";
        }
      }
      // ntp server * prefer
      leaf prefer {
        tailf:info "Preferred Server";
        type empty;
      }
      leaf use-vrf {
        tailf:info "Display per-VRF information";
        type vrf-member-type;
      }
      leaf key {
        tailf:info "Keyid to be used while communicating to this server";
        type uint16 {
          tailf:info "<1-65535>;;Value of keyid 1-65535";
          range "1..65535";
        }
      }
    }

    // ntp source-interface
    leaf source-interface {
      tailf:info "Source interface sending NTP packets";
      tailf:cli-diff-dependency "/nx:feature/interface-vlan";
      nx:case-insensitive-type;
      type string;
    }

    container source {
      tailf:info "Source of NTP packets";
      tailf:cli-diff-delete-before "../source-interface";
      tailf:cli-diff-set-after "../source-interface";
      leaf ipv6-address {
        tailf:cli-drop-node-name;
        type inet:ipv6-address {
          tailf:info "A:B::C:D;;IPv6";
        }
      }
      leaf ipv4-address {
        tailf:cli-drop-node-name;
        type inet:ip-address {
          tailf:info "A.B.C.D;;IPv4";
        }
      }
    }

    // ntp access-group
    container access-group {
      tailf:info "NTP access-group";
      list peer {
        tailf:info "Access-group peer";
        tailf:cli-suppress-mode;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of access list";
          }
        }
      }
      // ntp access-group serve
      leaf serve {
        tailf:info "Access-group serve";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;Name of access list";
        }
      }
      // ntp access-group query-only
      leaf query-only {
        tailf:info "Access-group query-only";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;Name of access list";
        }
      }
    }

    leaf logging {
      tailf:info "Enable/Disable logging of NTPD Events";
      type empty;
    }

    // ntp master
    leaf master {
      tailf:info "Act as NTP master clock";
      type uint8 {
        tailf:info "<1-15>;;Stratum number";
        range "1..15";
      }
    }
  }


  /// ========================================================================
  /// service
  /// ========================================================================

  container service {
    tailf:info "Service module";
    leaf dhcp {
      tailf:cli-diff-dependency "/nx:feature/dhcp";
      type empty;
    }

    leaf unsupported-transceiver {
      tailf:info "Configure support for transceivers not supported by Cisco";
      tailf:cli-boolean-no;
      cli:context-value-inject "static" {
        cli:arguments "false";
        when "/tailfned/default-unsupported-transceiver='false'";
      }
      default true;
      type boolean;
    }
  }


  /// ========================================================================
  /// key
  /// ========================================================================

  // key chain *
  container key {
    tailf:info "Key Management";
    list chain {
      tailf:info "Keychain Management";
      tailf:cli-mode-name "config-keychain";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Key-chain name (Max Size 63)";
          length "1..63";
        }
      }

      leaf type {
        tailf:cli-drop-node-name;
        tailf:cli-hide-in-submode;
        type enumeration {
          enum macsec { tailf:info "Macsec Keychain"; }
          enum tunnel-encryption { tailf:info "Tunnel-encryption Keychain"; }
        }
      }

      // key chain * / key *
      list key {
        tailf:info "Configure a key";
        tailf:cli-mode-name "config-keychain-key";
        key id;
        leaf id {
          type union {
            type uint16 {
              tailf:info "<0-65535>;;Key identifier";
            }
            type string {
              tailf:info "WORD;;MACsec Key identifier ranging from 1 octet to 32 (Max Size 64)";
            }
          }
        }

        // key chain * / key * / cryptographic-algorithm
        leaf cryptographic-algorithm {
          tailf:info "Set cryptographic-algorithm to be used";
          type enumeration {
            enum MD5 {
              tailf:info "MD5 authentication algorithm";
            }
            enum HMAC-SHA-1 {
              tailf:info "HMAC-SHA-1 authentication algorithm";
            }
            enum HMAC-SHA-256 {
              tailf:info "HMAC-SHA-256 authentication algorithm";
            }
            enum HMAC-SHA-384 {
              tailf:info "HMAC-SHA-384 authentication algorithm";
            }
            enum HMAC-SHA-512 {
              tailf:info "HMAC-SHA-512 authentication algorithm";
            }
          }
        }

        // key chain * / key * / key-string
        container key-string {
          tailf:info "(no abbrev)  Set key string";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf key-type {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            nx:device-transformed-dependency;
            type enumeration {
              enum 0 {
                tailf:info "Encryption Type - No Encryption(default)";
              }
              enum 7 {
                tailf:info "Encryption Type - Proprietary";
              }
            }
          }
          leaf key-value {
            tailf:cli-drop-node-name;
            nx:device-transformed-value;
            type NEDCOM_SECRET_TYPE {
              tailf:info "LINE;;Key string (Max Size 255)";
            }
          }
        }
        container key-octet-string {
          tailf:info "Set key octet string";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf key-type {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            nx:device-transformed-dependency;
            type enumeration {
              enum 0 {
                tailf:info "Encryption Type - No Encryption(default)";
              }
              enum 6;
              enum 7 {
                tailf:info "Encryption Type - Proprietary";
              }
            }
          }
          leaf key-value {
            tailf:cli-drop-node-name;
            nx:device-transformed-value;
            tailf:cli-incomplete-command;
            tailf:cli-remove-before-change;
            type NEDCOM_SECRET_TYPE {
              tailf:info "WORD;;Key octet string (Max Size 64)";
            }
          }
          leaf cryptographic-algorithm {
            tailf:info "Select CMAC algorithm for authentication";
            type enumeration {
              enum AES_128_CMAC { tailf:info "Cryptographic-algorithm AES-128-CMAC"; }
              enum AES_256_CMAC { tailf:info "Cryptographic-algorithm AES-256-CMAC"; }
            }
          }
        }
        container accept-lifetime {
          tailf:info "Set accept lifetime of key";
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-compact-syntax;
          uses lifetime-grouping;
        }
        container send-lifetime {
          tailf:info "Set send lifetime of key";
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-compact-syntax;
          uses lifetime-grouping;
        }
      }
    }
  }


  /// ========================================================================
  /// key-chain
  /// ========================================================================

  // key-chain
  container key-chain {
    container macsec-psk {
      tailf:info "Macsec Pre-shared key";
      leaf no-show {
        tailf:info "Do not show";
        type empty;
      }
    }
    container tunnelencrypt-psk {
      tailf:info "Tunnel-encryption Pre-shared key";
      leaf no-show {
        tailf:info "Do not show";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// flow
  /// ========================================================================

  container flow {
    tailf:info "Enable/Disable NetFlow configuration";
    tailf:cli-diff-dependency "../feature/netflow";
    list exporter {
      tailf:info "Define a Flow Exporter";
      tailf:cli-mode-name "config-flow-exporter";
      key name;
      leaf name {
        type string {
          tailf:info "WORD  Name of Flow Exporter (Max Size 63)";
          length "1..63";
        }
      }

      leaf description {
        tailf:info "Provide a description for this Flow Exporter";
        tailf:cli-full-command;
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-no-value-on-delete;
        type string {
          tailf:info "LINE;;Monitor description string (Max Size 63)";
        }
      }

      container destination {
        tailf:info "Specify the destination address";
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        tailf:cli-compact-syntax;
        leaf address {
          tailf:cli-drop-node-name;
          type union {
            type inet:ip-address;
            type inet:ipv6-address;
          }
        }
        leaf use-vrf {
          tailf:info "Configure IP SLAs for a VPN Routing/Forwarding instance";
          default "default";
          tailf:non-strict-leafref {
            path "/nx:vrf/context/id";
          }
          type vrf-member-type;
        }
      }

      container transport {
        tailf:info "Transport Destination Port";
        leaf udp {
          tailf:info "Destination UDP Port";
          type uint16 {
            tailf:info "<1-65535>;;Destination UDP Port";
            range "1..65535";
          }
        }
      }

      leaf source {
        tailf:info "Source Interface for this destination";
        nx:case-insensitive-type;
        type string {
          pattern "(([Ee]thernet)|([Ll]oopback)|([Pp]ort-channel)|([Vv]lan)|([Bb]di)|([Mm]gmt))[0-9/\\.]+";
        }
      }

      container version {
        tailf:info "Specify the export version";
        tailf:cli-add-mode;
        tailf:cli-incomplete-command;
        leaf version {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          tailf:cli-full-command;
          type enumeration {
            enum "5" {
              tailf:info "Version 5 Export";
            }
            enum "9" {
              tailf:info "Version 9 Export";
            }
          }
        }
        container option {
          tailf:info "Version 9 Option Templates and Data";
          when "../version='9'" {
            tailf:dependency "../version";
          }
          grouping timeout-grp {
            leaf timeout {
              tailf:info "Option resend time";
              type uint32 {
                tailf:info "<1-86400>;;Time in seconds";
              }
            }
          }
          container arp-table {
            tailf:info "ARP Table Option";
            uses timeout-grp;
          }
          container exporter-stats {
            tailf:info "Exporter Statistics Option";
            uses timeout-grp;
          }
          container interface-stats {
            tailf:info "Interface Stats Option";
            uses timeout-grp;
          }
          container interface-table {
            tailf:info "Interface Table Option";
            uses timeout-grp;
          }
          container sampler-table {
            tailf:info "Export Sampler Information";
            uses timeout-grp;
          }
        }
        container template {
          tailf:info "Version 9 Template";
          when "../version='9'" {
            tailf:dependency "../version";
          }
          container data {
            tailf:info "Data";
            leaf timeout {
              tailf:info "Template Data resend time";
              type uint32 {
                tailf:info "<1-86400>;;Time in seconds";
              }
            }
          }
        }
      }
    }

    list monitor {
      tailf:info "Define a Flow Monitor";
      tailf:cli-mode-name "config-flow-monitor";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Name of Flow Monitor (Max Size 63)";
          length  "1..63";
        }
      }

      leaf description {
        tailf:info "Provide a description for this Flow Monitor";
        tailf:cli-full-command;
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-no-value-on-delete;
        type string {
          tailf:info "LINE;;Monitor description string (Max Size 63)";
        }
      }

      container record {
        tailf:info "Specify Flow Record to use";
        choice record-choice {
          container netflow {
            tailf:info "Traditional NetFlow collection schemes";
            choice collection-choice {
              leaf ipv4 {
                tailf:info "Traditional IPv4 NetFlow collection schemes";
                type enumeration {
                  enum original-input {
                    tailf:info "Traditional IPv4 input NetFlow";
                  }
                  enum original-output {
                    tailf:info "Traditional IPv4 output NetFlow";
                  }
                }
              }
              leaf ipv6 {
                tailf:info "IPv6 collection schemes";
                type enumeration {
                  enum original-input {
                    tailf:info "Input NetFlow";
                  }
                  enum original-output {
                    tailf:info "Output NetFlow";
                  }
                }
              }
              container layer2-switched {
                tailf:info "Traditional L2 NetFlow collection schemes";
                leaf input {
                  tailf:info "Input NetFlow";
                  type empty;
                }
              }
              leaf protocol-port {
                tailf:info "Protocol and Ports aggregation scheme";
                type empty;
              }
            }
          }
          leaf netflow-original {
            tailf:info "Traditional IPv4 input NetFlow with origin ASs";
            type empty;
          }
          leaf record-name {
            tailf:cli-drop-node-name;
            type leafref {
              path "/nx:flow/record/name";
            }
          }
        }
      }

      list exporter {
        tailf:info "Add an Exporter to use to export records";
        tailf:cli-suppress-mode;
        key name;
        leaf name {
          tailf:non-strict-leafref {
            path "../../../exporter/name";
          }
          type string {
            tailf:info "WORD;;Name of exporter (Max Size 63)";
          }
        }
      }
    }

    list record {
      tailf:info "Define a Flow Record";
      tailf:cli-mode-name "config-flow-record";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Record name (Max Size 63)";
        }
      }
      container collect {
        tailf:info "Specify a non-key field";

        container counter {
          tailf:info "Counters to collect";
          choice counter-bytes-choice {
            leaf bytes {
              tailf:info "Total number of bytes";
              tailf:cli-full-command;
              type empty;
            }
            container bytes-long {
              tailf:cli-drop-node-name;
              container bytes {
                tailf:info "Total number of bytes";
                tailf:cli-incomplete-command;
                leaf long {
                  tailf:info "Long counter (64 bits)";
                  type empty;
                }
              }
            }
          }

          choice counter-packets-choice {
            leaf packets {
              tailf:info "Total number of packets";
              tailf:cli-full-command;
              type empty;
            }
            container packets-long {
              tailf:cli-drop-node-name;
              container packets {
                tailf:info "Total number of packets";
                tailf:cli-incomplete-command;
                leaf long {
                  tailf:info "Long counter (64 bits)";
                  type empty;
                }
              }
            }
          }
        }

        container flow {
          tailf:info "Flow identifying fields";
          container sampler {
            tailf:info "Sampler";
            leaf id {
              tailf:info "Identifer for sampler used for the flow";
              type empty;
            }
          }
        }

        container ip {
          tailf:info "IP attributes";
          leaf version {
            tailf:info "IPv4 or IPv6";
            type empty;
          }
        }

        container routing {
          tailf:info "Routing attributes";
          container destination {
            tailf:info "AS destination";
            leaf as {
              tailf:info "Destination AS number of origin network";
              tailf:cli-full-command;
              type empty;
            }
            container as-peer {
              tailf:cli-drop-node-name;
              container as {
                tailf:info "Destination AS number of origin network";
                tailf:cli-incomplete-command;
                leaf peer {
                  tailf:info "Destination AS number of the peer network";
                  type empty;
                }
              }
            }
          }

          leaf forwarding-status {
            tailf:info "Forwarding status of the packet";
            type empty;
          }

          container next-hop {
            tailf:info "Next hop address";
            container address {
              tailf:info "Address";

              leaf ipv4 {
                tailf:info "IPv4 next hop address";
                tailf:cli-full-command;
                type empty;
              }

              container ipv4-bgp {
                tailf:cli-drop-node-name;
                container ipv4 {
                  tailf:info "IPv4 next hop address";
                  tailf:cli-incomplete-command;
                  leaf bgp {
                    tailf:info "BGP next hop IPv4 address";
                    type empty;
                  }
                }
              }

              leaf ipv6 {
                tailf:info "IPv6 next hop address";
                tailf:cli-full-command;
                type empty;
              }

              container ipv6-bgp {
                tailf:cli-drop-node-name;
                container ipv6 {
                  tailf:info "IPv6 next hop address";
                  tailf:cli-incomplete-command;
                  leaf bgp {
                    tailf:info "BGP next hop IPv6 address";
                    type empty;
                  }
                }
              }
            }
          }

          container source {
            tailf:info "AS source";
            leaf as {
              tailf:info "AS source";
              tailf:cli-full-command;
              type empty;
            }

            container as-peer {
              tailf:cli-drop-node-name;
              container as {
                tailf:info "AS source";
                tailf:cli-incomplete-command;
                leaf peer {
                  tailf:info "Source AS number of the peer network";
                  type empty;
                }
              }
            }
          }
        }

        container timestamp {
          tailf:info "Timestamp fields";

          container sys-uptime {
            tailf:info "System uptime";

            leaf first {
              tailf:info "Time the first packet was seen";
              type empty;
            }

            leaf last {
              tailf:info "Time the most recent packet was seen";
              type empty;
            }
          }
        }

        container transport {
          tailf:info "Transport layer fields";
          container tcp {
            tailf:info "TCP layer fields";
            leaf flags {
              tailf:info "TCP flags";
              type empty;
            }
          }
        }
      }

      leaf description {
        tailf:info "Provide a description for this Flow Record";
        tailf:cli-full-command;
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-no-value-on-delete;
        type string {
          tailf:info "LINE;;Record description string (63 characters maximum) (Max Size 63)";
        }
      }

      container match {
        tailf:info "Specify a key field";
        container datalink {
          tailf:info "Datalink (Layer 2) attributes";
          tailf:cli-diff-delete-before "../../collect/routing";
          tailf:cli-diff-delete-before "../../collect/ip";
          tailf:cli-diff-delete-before "../../collect/transport";
          tailf:cli-diff-set-after "../../collect/routing";
          tailf:cli-diff-set-after "../../collect/ip";
          tailf:cli-diff-set-after "../../collect/transport";
          leaf ethertype {
            tailf:info "Ethertype";
            type empty;
          }

          container mac {
            tailf:info "MAC Address";
            leaf destination-address {
              tailf:info "Destination MAC Address";
              type empty;
            }
            leaf source-address {
              tailf:info "Source MAC Address";
              type empty;
            }
          }

          leaf vlan {
            tailf:info "VLAN ID";
            type empty;
          }
        }

        container ip {
          tailf:info "IP attributes";
          tailf:cli-diff-delete-before "../datalink";
          tailf:cli-diff-set-after "../datalink";
          leaf protocol {
            tailf:info "Protocol";
            type empty;
          }
          leaf tos {
            tailf:info "TOS";
            type empty;
          }
        }

        container ipv4 {
          tailf:info "IPv4 attributes";
          tailf:cli-diff-delete-before "../datalink";
          tailf:cli-diff-set-after "../datalink";
          container destination {
            tailf:info "Destination Address";
            leaf address {
              tailf:info "Address";
              type empty;
            }
          }
          container source {
            tailf:info "Source Address";
            leaf address {
              tailf:info "Address";
              type empty;
            }
          }
        }

        container ipv6 {
          tailf:info "IPv6 attributes";
          tailf:cli-diff-delete-before "../ipv4";
          tailf:cli-diff-delete-before "../datalink";
          tailf:cli-diff-set-after "../ipv4";
          tailf:cli-diff-set-after "../datalink";
          container destination {
            tailf:info "Destination Address";
            leaf address {
              tailf:info "Address";
              type empty;
            }
          }
          leaf flow-label {
            tailf:info "Flow label";
            type empty;
          }

          leaf options {
            tailf:info "Options";
            type empty;
          }

          container source {
            tailf:info "Source Address";
            leaf address {
              tailf:info "Address";
              type empty;
            }
          }
        }

        container transport {
          tailf:info "Transport layer fields";
          leaf destination-port {
            tailf:info "Transport destination port";
            type empty;
          }
          leaf source-port {
            tailf:info "Transport source port";
            type empty;
          }
        }
      }
    }

    container timeout {
      tailf:info "Define a Flow Timeout";

      leaf f2-timeout {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<5-60>;;Time in seconds (flush-cache-Only for F2 cards)";
        }
      }

      leaf active {
        tailf:info "Active or long timeout";
        tailf:cli-remove-before-change;
        type uint16 {
          tailf:info "<60-4092>;;Time in seconds";
        }
      }

      leaf inactive {
        tailf:info "Inactive or normal timeout";
        tailf:cli-remove-before-change;
        type uint16 {
          tailf:info "<15-4092>;;Time in seconds";
        }
      }

      container aggressive {
        tailf:info "Aggressive aging";
        leaf threshold {
          tailf:info "Threshold to start the aggressive aging";
          type uint8 {
            tailf:info "<50-99>;;Percentage of NetFlow Table full";
          }
        }
      }

      container fast {
        tailf:info "Fast aging timeout";
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        leaf time {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<32-512>;;Time in seconds";
          }
        }
        leaf threshold {
          tailf:info "Threshold to start fast aging";
          type uint16 {
            tailf:info "<1-4000>;;Number of packets in flow before timeout for the flow to not expire";
          }
        }
      }

      leaf session {
        tailf:info "Enable TCP session aging";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// sampler
  /// ========================================================================

  list sampler {
    tailf:info "Define a Sampler";
    tailf:cli-mode-name "config-flow-sampler";
    tailf:cli-diff-dependency "../feature/netflow";
    key name;
    leaf name {
      type string {
        tailf:info "WORD  Name of sampler (Max Size 63)";
        length "1..63";
      }
    }

    container mode {
      tailf:info "Define the Sampler mode";
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      tailf:cli-compact-syntax;
      leaf num-samples {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-63>;;Number of samples per sampling - 63 max";
          range "1..63";
        }
      }
      leaf out-of {
        tailf:info "M out of N packets";
        type uint32 {
          tailf:info "<1-131070>;;Number of packets in each sampling - 131071 (Max only for F3 only VDC & Version 9) - 8191 (Other card types)";
          range "1..131070";
        }
      }
    }
  }


  /// ========================================================================
  /// udld
  /// ========================================================================

  container udld {
    tailf:info "UDLD protocol";
    tailf:cli-diff-dependency "../feature/udld";
    leaf aggressive {
      tailf:info "Enable UDLD aggressive mode on all fiber optic ports";
      type empty;
    }
    leaf message-time {
      tailf:info "Setting the time in seconds between UDLD probe messages";
      default 15;
      type uint8 {
        tailf:info "<7-90>;;Enter the message timer value [default = 15]";
        range "7..90";
      }
    }
  }


  /// ========================================================================
  /// vrf
  /// ========================================================================

  container vrf {
    tailf:info "Configure VRF parameters";

    // vrf context *
    list context {
      tailf:info "Create VRF and enter VRF mode";
      tailf:cli-explicit-exit;
      tailf:cli-recursive-delete;
      key id;
      leaf id {
        type vrf-member-type;
      }

      // vrf context * / description
      leaf description {
        tailf:info "Enter description of maximum 254 characters";
        tailf:cli-full-command;
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        nx:delete-with "none";
        type string {
          tailf:info "LINE;;Description of maximum 254 characters";
          length "1..254";
        }
      }

      // vrf context * / vni
      leaf vni {
        tailf:info "Virtual Network Identifier";
        type uint32 {
          tailf:info "<4096-16777215>;;Vni, Example: 4096,6099";
        }
      }

      // vrf context * / rd
      leaf rd {
        tailf:info "VPN Route Distinguisher";
        tailf:cli-diff-delete-before "/nx:feature/bgp";
        type union {
          type enumeration {
            enum "auto" {
              tailf:info "Generate RD automatically";
            }
          }
          type asn-ip-type;
        }
      }

      // vrf context * / address-family
      container address-family {
        tailf:cli-diff-dependency "../vni";
        grouping unicast-grouping {
          container unicast {
            tailf:cli-add-mode;
            presence "true";
            list route-target {
              tailf:info "Specify Target VPN Extended Communities";
              tailf:cli-suppress-mode;
              tailf:cli-diff-delete-before "../../../../vni";
              key "method asn target-evpn";
              leaf method {
                type enumeration {
                  enum "both" {
                    tailf:info "Export And Import Target-VPN community";
                  }
                  enum "export" {
                    tailf:info "Export Target-VPN community";
                  }
                  enum "import" {
                    tailf:info "Import Target-VPN community";
                  }
                }
              }
              leaf asn {
                type union {
                  type enumeration {
                    enum "auto" {
                      tailf:info "Generate route target automatically";
                    }
                  }
                  type asn-ip-type;
                  type string;
                }
              }
              leaf target-evpn {
                tailf:info "Specify Target for EVPN routes";
                tailf:key-default "non-evpn";
                tailf:cli-diff-delete-before "/nx:feature/bgp";
                tailf:cli-diff-delete-before "/nx:feature/mpls/evpn";
                tailf:cli-diff-delete-before "/nx:feature/ngmvpn";
                tailf:cli-diff-delete-before "/nx:nv/overlay/evpn";
                nx:trim-default-key;
                type enumeration {
                  enum "evpn" {
                    tailf:info "Specify Target for EVPN routes";
                  }
                  enum "non-evpn";
                  enum "mvpn" {
                    tailf:info "Specify Target for MVPN routes";
                  }
                }
              }
            }
            container export {
              tailf:info "VRF export";
              leaf map {
                tailf:info "Route-map based VRF export";
                type string {
                  tailf:info "WORD;;Route-map name (Max Size 63)";
                  length "1..63";
                }
              }
            }
            container export-vrf {
              tailf:cli-drop-node-name;
              container export {
                tailf:info "VRF export";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                leaf vrf {
                  tailf:info "Virtual Router Context";
                  tailf:cli-incomplete-command;
                  type vrf-member-type;
                }
                leaf max-limit {
                  tailf:cli-drop-node-name;
                  tailf:cli-optional-in-sequence;
                  type uint32 {
                    tailf:info "<1-2147483647>;;Maximum prefix limit";
                  }
                }
                leaf map {
                  tailf:info "Route-map based VRF export";
                  type string {
                    tailf:info "WORD;;Route-map name (Max Size 63)";
                    length "1..63";
                  }
                }
                leaf allow-vpn {
                  tailf:info "Allow re-importation of VPN imported routes";
                  type empty;
                }
              }
            }
            container import {
              tailf:info "VRF import";
              leaf map {
                tailf:info "Route-map based VRF import";
                type string {
                  tailf:info "WORD;;Route-map name (Max Size 63)";
                  length "1..63";
                }
              }
            }
            container import-vrf {
              tailf:cli-drop-node-name;
              container import {
                tailf:info "VRF import";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                leaf vrf {
                  tailf:info "Virtual Router Context";
                  tailf:cli-incomplete-command;
                  type vrf-member-type;
                }
                leaf max-limit {
                  tailf:cli-drop-node-name;
                  tailf:cli-optional-in-sequence;
                  type uint32 {
                    tailf:info "<1-2147483647>;;Maximum prefix limit";
                  }
                }
                leaf map {
                  tailf:info "Route-map based VRF import";
                  type string {
                    tailf:info "WORD;;Route-map name (Max Size 63)";
                    length "1..63";
                  }
                }
                leaf advertise-vpn {
                  tailf:info "Allow leaked routes to be advertised to VPN";
                  type empty;
                }
              }
            }
            container maximum {
              tailf:info "Set a limit";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-all-siblings;
              }
              leaf routes {
                tailf:info "Maximum number of routes allowed in this routing table";
                type uint32 {
                  tailf:info "<1-4294967295>;;Maximum number of routes allowed";
                }
              }
              choice warn-or-threshold-choice {
                case threshold {
                  leaf threshold {
                    tailf:cli-drop-node-name;
                    type uint8 {
                      tailf:info "<1-100>;;Threshold value (%) at which to generate a warning msg";
                      range "1..100";
                    }
                  }
                  leaf reinstall {
                    tailf:info "Reinstall previous rejected route due to over maximum route limit";
                    type uint8 {
                      tailf:info "<1-100>;;Threshold value (%) at which to reinstall routes back to VRF";
                    }
                  }
                }
                case warning {
                  leaf warning-only {
                    tailf:info "Only give a warning message if limit is exceeded";
                    type empty;
                  }
                }
              }
            }
          }
        }
        container ipv4 {
          tailf:info "Configure IPv4 address family";
          uses unicast-grouping;
        }
        container ipv6 {
          tailf:info "Configure IPv6 address family";
          uses unicast-grouping;
        }
      }

      // vrf context * / ip
      container ip {
        tailf:info "Configure IP features";
        uses ip-grouping;
      }

      // vrf context * / ipv6
      container ipv6 {
        tailf:info "Configure IPv6 features";
        uses ipv6-grouping;
      }

      // vrf context * / ipv6
      container cts {
        tailf:info "Config commands for CTS";
        tailf:cli-diff-dependency "/nx:feature/cts";
        container role-based {
          tailf:info "Configure RBACL policies";
          list sgt-map {
            tailf:info "Configure IP Address to SGT mapping";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key addr;
            leaf addr {
              type union {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IP Address in format A.B.C.D";
                }
                type tailf:ipv4-address-and-prefix-length {
                  tailf:info "A.B.C.D/LEN;;IPv4 Prefix";
                }
              }
            }
            leaf sgt {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<1-65519>;;SGT corresponding to the IP Address";
              }
            }
          }
        }
      }

    }
  }


  /// ========================================================================
  /// ptp
  /// ========================================================================

  container ptp {
    tailf:info "Precision Time Protocol (IEEE 1588) Subsystem";
    tailf:cli-diff-set-after "/nx:feature/ptp" {
      tailf:cli-when-target-set;
    }
    tailf:cli-diff-delete-before "/nx:feature/ptp" {
      tailf:cli-when-target-delete;
    }
    when "/nx:feature/ptp" {
      tailf:dependency "/nx:feature/ptp";
    }
    container correction-range {
      tailf:info "Set correction range threshold value";
      leaf threshold {
        tailf:cli-drop-node-name;
        default 100000;
        type uint32 {
          tailf:info "<10-1000000000>;;Correction threshold (ns) [-value, +value], default 100000 (100 us)";
        }
      }
      leaf logging {
        tailf:info "Enable logging for corrections exceeding threshold value";
        type empty;
      }
    }
    leaf domain {
      tailf:info "Ptp clock domain";
      type uint8 {
        tailf:info "<0-127>;;Enter domain value";
      }
    }
    leaf management {
      tailf:info "Management packet support";
      tailf:cli-boolean-no;
      default true;
      type boolean;
    }
    leaf mean-path-delay {
      tailf:info "Set mean-path-delay threshold value";
      default 1000000000;
      type uint32 {
        tailf:info "<10-1000000000>;;Mean-path-delay threshold (ns), default 1000000000 (1 sec)";
      }
    }
    container notification {
      tailf:info "Define the PTP notification.";
      container type {
        tailf:info "Notification type";
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        leaf high-correction {
          tailf:info "Corrections which is crossing the threshold value.";
          type empty;
        }
        leaf interval {
          tailf:info "Wait time between two successive notifications.";
          type union {
            type uint16 {
              tailf:info "<1-300>;;Duration value granularity is in seconds.";
            }
            type enumeration {
              enum immediate { tailf:info "Notification will be sent immediately after the event"; }
            }
          }
        }
        leaf periodic-notification {
          tailf:info "Define how notification will be sent.";
          default "disable";
          when "../interval != 'immediate'" {
            tailf:dependency "../interval";
          }
          type enumeration {
            enum disable { tailf:info "Notification will be sent only when any event occurance."; }
            enum enable { tailf:info "Always send notification with configured <duration> period."; }
          }
        }
      }
    }
    leaf priority1 {
      tailf:info "Priority1";
      type uint8 {
        tailf:info "<0-255>;;Priority1";
      }
    }
    leaf priority2 {
      tailf:info "Priority2";
      type uint8 {
        tailf:info "<0-255>;;Priority2";
      }
    }
    container source {
      tailf:info "Source IP address";
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-compact-syntax;
      leaf address {
        tailf:cli-drop-node-name;
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;IPv4 address (A.B.C.D) of source";
        }
      }
      leaf vrf {
        tailf:info "Vrf to be used for hello messages";
        type string {
          tailf:info "WORD;;Vrf to be used for hellos";
        }
      }
    }
    container profile {
      tailf:info "PTP profile";
      tailf:cli-add-mode;
      presence true;
      leaf type {
        tailf:cli-drop-node-name;
        tailf:cli-hide-in-submode;
        type enumeration {
          enum "8275-1" {
            tailf:info "PTP telecom profile matching 8275.1";
          }
          enum default {
            tailf:info "Default profile";
          }
        }
      }
      // leaf mode {
      //   type enumeration {
      //     enum hybrid { tailf:info " Hybrid mode"; }
      //     enum non-hybrid { tailf:info "Non-hybrid mode"; }
      //     enum none  { tailf:info "No mode selected"; }
      //   }
      // }
    }
  }


  /// ========================================================================
  /// hsrp
  /// ========================================================================

  container hsrp {
    tailf:info "HSRP interface configuration commands";
    tailf:cli-diff-dependency "../feature/hsrp";
    when "../feature/hsrp" {
      tailf:dependency "../feature/hsrp";
    }

    list anycast {
      tailf:info "Anycast related commands";
      tailf:cli-mode-name "config-anycast-bundle";
      key "bundle proto";
      leaf bundle {
        tailf:info "<1-4096>;;Bundle number";
        type uint16;
      }
      leaf proto {
        type enumeration {
          enum both {
            tailf:info "Associate IP Version 4 and 6 for the bundle";
          }
          enum ipv4 {
            tailf:info "Associate IP Version 4 for the bundle";
          }
          enum ipv6 {
            tailf:info "Associate IP Version 6 for the bundle";
          }
        }
      }

      leaf priority {
        tailf:info "Configure Bundle priority";
        default 100;
        type uint8 {
          tailf:info "<1-127>;;Priority value";
          range "1..127";
        }
      }

      leaf switch-id {
        tailf:info "Configure Switch ID";
        type uint16 {
          tailf:info "<1-4095>;;Anycast Switch ID";
        }
      }

      leaf-list vlan {
        tailf:info "Set allowed fabricpath VLANs for a given anycast bundle";
        tailf:cli-range-list-syntax;
        type uint16 {
          tailf:info "<1-3967>;;VLAN IDs of the allowed fabricpath VLANs in the anycast bundle";
        }
      }

      leaf shutdown {
        tailf:info "Change the admin status of the bundle";
        tailf:cli-boolean-no;
        default true;
        type boolean;
      }
    }

    container bfd {
      tailf:info "BFD protocol";
      tailf:cli-diff-dependency "/nx:feature/bfd";
      leaf all-interfaces {
        tailf:info "On all interfaces";
        type empty;
      }
    }

    container timers {
      tailf:info "Global Timers";
      container extended-hold {
        tailf:info "Extended Hold";
        presence true;
        leaf value {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<10-255>;;Time in seconds";
          }
        }
      }
    }
  }

  /// ========================================================================
  /// sflow
  /// ========================================================================

  container sflow {
    tailf:info "Change sFlow global settings";
    tailf:cli-diff-dependency "../feature/sflow";
    leaf agent-ip {
      tailf:info "SFlow Agent IP address";
      type inet:ipv4-address {
        tailf:info "A.B.C.D;;SFlow Agent IP address";
      }
    }
    container collector-ip {
      tailf:info "SFlow Collector IP address";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf address {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;SFlow Collector IP address";
        }
      }
      leaf vrf {
        tailf:info "Display per-VRF information";
        tailf:non-strict-leafref {
          path "/nx:vrf/context/id";
        }
        type vrf-member-type;
      }
      leaf source {
        tailf:info "Source IP address to send to sFlow Collector";
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Source IP address to send to sFlow Collector";
        }
      }
    }
    leaf collector-port {
      tailf:info "SFlow Collector UDP port";
      type uint16 {
        tailf:info "<0-65535>;;SFlow Collector UDP port";
      }
    }
    leaf counter-poll-interval {
      tailf:info "SFlow Counter Poll Interval";
      type uint32 {
        tailf:info "<0-2147483647>;;SFlow Counter Poll Interval";
      }
    }
    container data-source {
      tailf:info "SFlow Data Source";
      list interface {
        tailf:cli-suppress-mode;
        tailf:cli-diff-set-after "/nx:interface";
        tailf:cli-diff-delete-before "/nx:interface";
        key name;
        leaf name {
          type string {
            tailf:info "SFlow Data Source Interface";
          }
        }
      }
    }
    leaf max-datagram-size {
      tailf:info "SFlow Datagram Size";
      type uint16 {
        tailf:info "<200-9000>;;SFlow Datagram Size";
      }
    }
    leaf max-sampled-size {
      tailf:info "SFlow Sampled Size";
      type uint16 {
        tailf:info "<64-256>;;SFlow Sampled Size";
      }
    }
    leaf sampling-rate {
      tailf:info "SFlow Sampling Rate";
      default 4096;
      type uint32 {
        tailf:info "<4096-1000000000>;;SFlow Sampling rate";
      }
    }
  }

  /// ========================================================================
  /// vpc
  /// ========================================================================

  container vpc {
    tailf:info "Vpc";
    tailf:cli-diff-dependency "../feature/vpc";
    when "../feature/vpc" {
      tailf:dependency "../feature/vpc";
    }

    // vpc domain *
    container domain {
      tailf:info "Specify domain";
      tailf:cli-explicit-exit;
      tailf:cli-add-mode;
      tailf:cli-incomplete-command;
      nx:filter-non-config "no delay peer-link";
      nx:filter-non-config "port-channel limit";
      presence "true";

      leaf id {
        tailf:cli-drop-node-name;
        tailf:cli-hide-in-submode;
        mandatory true;
        type uint16 {
          tailf:info ";;<1-1000>  Domain id";
          range "1..1000";
        }
      }

      // vpc domain * / auto-recovery <CR>
      choice enable-or-disable-auto-recovery {
        default "auto-recovery";
        case auto-recovery {
          container auto-recovery {
            tailf:info "VPC settings to enable auto recovery if peer is presumed non-operational";
            tailf:cli-incomplete-no;
            tailf:cli-incomplete-command;
            leaf reload-delay {
              tailf:info "Duration to wait before assuming peer dead and restoring vpcs";
              nx:delete-with "default";
              tailf:ned-default-handling report-all;
              default 240;
              type uint16 {
                tailf:info "<240-3600>;;Time-out for restoring vPC links (in seconds)";
              }
            }
          }
        }
        container disable {
          tailf:cli-drop-node-name;
          leaf auto-recovery {
            tailf:info "Disable auto-recovery";
            tailf:cli-boolean-no;
            tailf:cli-full-command;
            type boolean;
          }
        }
      }

      // vpc domain * / delay restore <CR>
      container delay {
        tailf:info "Initialization delay";
        leaf restore {
          tailf:info "Delay after restoring peer-link";
          tailf:cli-full-command;
          tailf:ned-default-handling report-all;
          default 30;
          type uint16 {
            tailf:info "<1-3600>;;Delay in bringing up the vPC links "
              +"(in seconds)";
          }
        }
        container other-delay {
          tailf:cli-drop-node-name;
          container restore {
            tailf:cli-incomplete-command;
            leaf interface-vlan {
              tailf:info "Delay in bringing-up interface-vlan";
              tailf:ned-default-handling report-all;
              default 10;
              type uint16 {
                tailf:info "<1-3600>;;Delay in bringing up the interface-vlan (in seconds)";
              }
            }
            leaf orphan-port {
              tailf:info "Configure vPC orphan-port delay bring-up timer";
              tailf:ned-default-handling report-all;
              default 0;
              type uint16 {
                tailf:info "<0-300>;;Specify delay time in seconds";
              }
            }
          }
        }
      }
      container ipv6 {
        tailf:info "Configure IPv6 features";
        container nd {
          tailf:info "Display Neighbor Discovery interface information";
          leaf synchronize {
            tailf:info "CFS synchronize";
            type empty;
          }
        }
      }
      // vpc domain * / ip synchronize <CR>
      container ip {
        tailf:info "Configure IP features";
        leaf arp {
          type enumeration {
            enum synchronize;
          }
        }
      }
      // vpc domain * / peer-gateway <CR>
      leaf peer-gateway {
        tailf:info "Enable L3 forwarding for packets destined to peer's "
          +"gateway mac-address";
        type empty;
      }
      // vpc domain * / peer-keepalive
      container peer-keepalive {
        tailf:info "Keepalive/Hello with peer switch";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        // vpc domain * / peer-keepalive destination A.B.C.D <CR>
        leaf destination {
          tailf:info "Specify destination ip address of peer switch";
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IPv4 address (A.B.C.D) of destination";
          }
        }
        // vpc domain * / peer-keepalive destination A.B.C.D source A.B.C.D <CR>
        leaf source {
          tailf:info "Source interface for hello";
          tailf:cli-optional-in-sequence;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IPv4 address (A.B.C.D) of source";
          }
        }
        leaf udp-port {
          tailf:info "Enter UDP port number used for hello";
          tailf:ned-default-handling report-all;
          tailf:cli-optional-in-sequence;
          default 3200;
          type uint16 {
            tailf:info "<1024-65000>;;Udp port number for hellos";
          }
        }
        // vpc domain * / peer-keepalive destination A.B.C.D source A.B.C.D
        //   vrf WORD <CR>
        leaf vrf {
          tailf:info "Vrf to be used for hello messages";
          tailf:ned-default-handling report-all;
          default "management";
          type string {
            tailf:info "WORD;;Vrf to be used for hellos";
          }
        }
        leaf interval {
          tailf:info "Enter interval in milliseconds";
          tailf:ned-default-handling report-all;
          default 1000;
          type uint16 {
            tailf:info "<400-10000>;;Enter interval in milliseconds";
          }
        }
        leaf timeout {
          tailf:info "Enter timeout in seconds";
          tailf:ned-default-handling report-all;
          default 5;
          type uint8 {
            tailf:info "<3-20>;;Enter timeout in seconds";
          }
        }
        leaf precedence {
          tailf:info "Precedence";
          tailf:ned-default-handling report-all;
          default 6;
          type uint8 {
            tailf:info "<0-7>;;Precedence value";
          }
        }
        leaf hold-timeout {
          tailf:info "Hold timeout to ignore stale peer alive messages";
          tailf:ned-default-handling report-all;
          default 3;
          type uint8 {
            tailf:info "<3-10>;;Enter hold-timeout in seconds";
          }
        }
      }
      container virtual {
        tailf:info "Virtual peer-link";
        container peer-link {
          tailf:info "peer-link to peer switch";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf destination {
            tailf:info "specify destination ip address of peer switch";
            tailf:cli-incomplete-command;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IPv4 address (A.B.C.D) of destination";
            }
          }
          leaf source {
            tailf:info "source interface for peer-link";
            type union {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IPv4 address (A.B.C.D) of source";
              }
              type tailf:ipv4-address-and-prefix-length {
                tailf:info "A.B.C.D/LEN;;IPv4 Addr/Prefix of source";
              }
            }
          }
          leaf dscp {
            tailf:info "Set dscp value";
            type dscp-type;
          }
        }
      }
      // vpc domain * / peer-switch <CR>
      leaf peer-switch {
        tailf:info "Enable peer switch on vPC pair switches";
        type empty;
      }
      // vpc domain * / role priority <1-65535> <CR>
      container role {
        tailf:info "Role related configuration";
        leaf priority {
          tailf:info "Configure priority to be used during vPC role "
            +"(primary/secondary) election";
          tailf:ned-default-handling report-all;
          default 32667;
          type string {
            tailf:info "<1-65535>;;Specify priority value";
          }
        }
      }
      container fabricpath {
        tailf:cli-diff-dependency "/nx:feature-set/fabricpath";
        leaf switch-id {
          tailf:info "Configure Switch ID";
          type uint16 {
            tailf:info "<1-4095>;;Anycast Switch ID";
          }
        }
        container multicast {
          tailf:info "Configuration pertaining to all multi-destination packets";
          leaf load-balance {
            tailf:info "Make both vPC peers as partial designated forwarders when possible";
            tailf:cli-boolean-no;
            type boolean;
          }
        }
      }
      leaf system-priority {
        tailf:info "Configure system priority";
        tailf:ned-default-handling report-all;
        default 32667;
        type uint16 {
          tailf:info "<1-65535>;;Specify system priority";
          range "1..65535";
        }
      }
      container layer3 {
        tailf:info "Enable layer 3 functionality";
        tailf:cli-case-insensitive;
        leaf peer-router {
          tailf:info "No change for TTL of packets destined to the peer";
          cli:parse-alt-name "peer";
          tailf:cli-diff-dependency "../../peer-gateway";
          tailf:cli-full-command;
          type empty;
        }
        container syslog-config {
          tailf:cli-drop-node-name;
          container peer-router {
            tailf:cli-incomplete-command;
            container syslog {
              tailf:info "Print layer 3 protocol syslog";
              nx:no-to-disable;
              choice enable-disable {
                default interval;
                case interval {
                  leaf interval {
                    tailf:info "How frequent to print the syslog";
                    default "3600";
                    nx:delete-with "default";
                    tailf:ned-default-handling report-all;
                    type uint16 {
                      tailf:info "<1-3600>;;How many seconds to print a syslog";
                    }
                  }
                }
                leaf disable {
                  type empty;
                }
              }
            }
          }
        }
      }
      // vpc domain * / track
      leaf track {
        tailf:info "Tracking object to suspend vPC if object goes down";
        tailf:non-strict-leafref {
          path "/nx:track/id";
        }
        tailf:cli-remove-before-change;
        tailf:cli-diff-delete-before "/nx:vpc/domain";
        type uint16 {
          tailf:info "<1-512>;;Tracked object";
        }
      }
      container dual-active {
        tailf:info "Configuration when peer link is down but peer is alive";
        container exclude {
          tailf:info "Interface vlans to exclude from suspension when dual-active";
          leaf-list interface-vlan {
            tailf:info "Interface vlan configuration";
            tailf:cli-show-no;
            tailf:cli-range-list-syntax;
            tailf:cli-replace-all;
            nx:prune-leaf-list-duplicates;
            type uint16 {
              tailf:info "<1-3967>;;Set allowed interface vlans";
            }
          }
        }
      }
      leaf fast-convergence {
        tailf:info "Enable vPC fast-convergence";
        type empty;
      }
      container graceful {
        tailf:info "Enable graceful features";
        leaf consistency-check {
          tailf:info "Enable graceful type-1 consistency check";
          type empty;
        }
      }
      leaf shutdown {
        tailf:info "Suspend vPC locally";
        tailf:cli-show-no;
        type empty;
      }
      leaf peer-config-check-bypass {
        tailf:info "Ignore type checks on primary, when MCT is down";
        type empty;
      }
      container bypass {
        leaf module-check {
          type empty;
        }
      }
    }
  }


  /// ========================================================================
  /// lacp
  /// ========================================================================

  container lacp {
    leaf offload {
      tailf:cli-diff-delete-before "/nx:feature/lacp";
      type empty;
    }
    leaf system-priority {
      tailf:info "Set LACP system priority";
      tailf:cli-diff-delete-before "/nx:feature/lacp";
      type uint16 {
        tailf:info "<1-65535>;;Enter System Priority";
        range "1..65535";
      }
    }
  }


  /// ========================================================================
  /// lldp
  /// ========================================================================

  container lldp {
    tailf:cli-diff-dependency "/nx:feature/lldp";
    tailf:info "Configure global LLDP parameters";
    leaf reinit {
      tailf:info "Delay (in sec) for LLDP initialisation on any interface";
      default 2;
      type uint8 {
        tailf:info "<1-10>;;Reinit in sec";
        range "1..10";
      }
    }
    leaf timer {
      tailf:info "Specify the rate at which LLDP packets are sent (in sec)";
      default 30;
      type uint8 {
        tailf:info "<5-254>;;Rate of packets in sec";
        range "5..254";
      }
    }
    leaf holdtime {
      tailf:info "Specify the holdtime (in sec) to be sent in packets";
      default 120;
      type uint16 {
        tailf:info "<1-255>;;Holdtime in sec";
      }
    }
    leaf portid-subtype {
      tailf:info "Config portid subtype for LLDP TLV and SNMP MIBs";
      default 0;
      type uint8 {
        tailf:info "<0-1>;;0: long interface name (default), 1: short interface name";
      }
    }
    container tlv-select {
      tailf:info "Selection of LLDP to send";
      when "/nx:tailfned/lldp-tlv-select-support and /nx:feature/lldp" {
        tailf:dependency "/nx:feature/lldp";
        tailf:dependency "/nx:tailfned/lldp-tlv-select-support";
      }
      leaf dcbxp {
        tailf:info "DCBXP TLVs";
        tailf:cli-boolean-no;
        type boolean;
      }
      container management-address {
        tailf:info "Management Address TLV";
        leaf v4 {
          tailf:info "Management Address TLV v4";
          tailf:cli-boolean-no;
          type boolean;
        }
        leaf v6 {
          tailf:info "Management Address TLV v6";
          tailf:cli-boolean-no;
          type boolean;
        }
      }
      leaf port-description {
        tailf:info "Port Description TLV";
        tailf:cli-boolean-no;
        type boolean;
      }
      leaf port-vlan {
        tailf:info "Port Vlan ID TLV";
        tailf:cli-boolean-no;
        type boolean;
      }
      leaf power-management {
        tailf:info "IEEE 802.3 DTE Power via MDI TLV";
        tailf:cli-boolean-no;
        type boolean;
      }
      leaf four-wire-power-management {
        tailf:info "4-Wire Power via MDI TLV";
        tailf:cli-boolean-no;
        type boolean;
      }
      leaf system-capabilities {
        tailf:info "System Capabilities TLV";
        tailf:cli-boolean-no;
        type boolean;
      }
      leaf system-description {
        tailf:info "System Description TLV";
        tailf:cli-boolean-no;
        type boolean;
      }
      leaf system-name {
        tailf:info "System Name TLV";
        tailf:cli-boolean-no;
        type boolean;
      }
    }
  }


  /// ========================================================================
  /// port-channel
  /// ========================================================================

  container port-channel {

    // port-channel hash-distribution
    leaf hash-distribution {
      tailf:info "Configure port-channel hash-distribution";
      default adaptive;
      type enumeration {
        enum adaptive {
          tailf:info "Port-channel hash-distribution type is adaptive";
        }
        enum fixed {
          tailf:info "Port-channel hash-distribution type is fixed";
        }
      }
    }

    container load-balance {
      leaf ethernet {
        when "/nx:tailfned/port-channel-load-balance-ethernet";
        nx:inject-before "tailfned port-channel-load-balance-ethernet" {
          when "/tailfned/is-netsim='true'";
        }
        tailf:cli-diff-delete-before "/nx:tailfned/port-channel-load-balance-ethernet" {
          tailf:cli-when-target-delete;
        }
        type enumeration {
          enum source-mac {
            tailf:info "Source MAC address";
          }
          enum destination-ip {
            tailf:info "Destination IP address";
          }
          enum destination-mac {
            tailf:info "Destination MAC address";
          }
          enum destination-port {
            tailf:info "Destination TCP/UDP port";
          }
          enum source-dest-ip {
            tailf:info "Source & Destination IP address";
          }
          enum source-dest-mac {
            tailf:info "Source & Destination MAC address";
          }
          enum source-dest-port {
            tailf:info "Source & Destination TCP/UDP port";
          }
          enum source-ip {
            tailf:info "Source IP address";
          }
          enum source-port {
            tailf:info "Source TCP/UDP port";
          }
          enum source-dest-port-only {
            tailf:info "Source & Destination TCP/UDP port only";
          }
          enum source-dest-ip-only   {
            tailf:info "Source & Destination IP addresses only";
          }
          enum source-dest-ip-gre    {
            tailf:info "Source & Destination IP address and NVGRE Key (includes l2)";
          }
          enum source-ip-gre         {
            tailf:info "Source IP address & NVGRE Key";
          }
          enum destination-ip-gre    {
            tailf:info "Destination IP address & NVGRE Key";
          }
        }
      }

      container load-balance-parameters {
        tailf:cli-drop-node-name;
        when "not(/nx:tailfned/port-channel-load-balance-ethernet)";
        nx:fix-per-module-lb;
        grouping lb-parameters-grouping {
          leaf param-type {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type enumeration {
              enum dst {
                tailf:info "Destination based parameters";
              }
              enum src {
                tailf:info "Source based parameters";
              }
              enum src-dst {
                tailf:info "Source-destination based parameters";
              }
            }
          }
          leaf param-value {
            tailf:cli-drop-node-name;
            type enumeration {
              enum ip {
                tailf:info "IP";
              }
              enum ip-l4port {
                tailf:info "IP and L4 port";
              }
              enum ip-l4port-vlan {
                tailf:info "IP, L4 port and VLAN";
              }
              enum ip-vlan {
                tailf:info "IP and VLAN";
              }
              enum l4port {
                tailf:info "L4 port";
              }
              enum mac {
                tailf:info "MAC";
              }
            }
          }
          leaf rotate {
            tailf:info "Offset the hash-input";
            tailf:cli-optional-in-sequence;
            type uint8 {
              tailf:info "<0-15>;;Offset the hash-input";
            }
          }
          leaf asymmetric {
            tailf:info "Asymmetric hash";
            type empty;
          }
        }
        container global-parameters {
          tailf:cli-drop-node-name;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-all-siblings;
          }
          uses lb-parameters-grouping;
        }
        list module {
          tailf:info "Specify a module number";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-sequence-commands {
            tailf:cli-reset-all-siblings;
          }
          tailf:cli-compact-syntax;
          key id;
          leaf id {
            type uint8 {
              tailf:info "<1-32>;;Specify a module number";
            }
          }
          uses lb-parameters-grouping;
        }
        leaf hash-modulo {
          tailf:info "Enable/disable modulo hash for N7K cards";
          type empty;
        }
        leaf hash-modulo-f2 {
          tailf:info "Enable/disable modulo hash for N7K cards";
          tailf:cli-diff-dependency "../hash-modulo";
          type empty;
        }
      }
    }
  }


  /// ========================================================================
  /// hardware
  /// ========================================================================

  container hardware {

    container access-list {
      tailf:info "Access Control List";
      container lou {
        tailf:info "LOU";
        container resource {
          tailf:info "Hardware resource";
          leaf threshold {
            tailf:info "Port expansion threshold";
            type uint8 {
              tailf:info "<1-50>;;Value of threshold";
            }
          }
        }
      }
      container update {
        tailf:info "Configure atomic/non-atomic update and default-result";
        leaf atomic {
          tailf:info "Enable atomic update of access-list in hardware";
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }
        container default-result {
          tailf:info "Default access-list result during non-atomic hardware update";
          leaf permit {
            tailf:info "Permit all packets during non-atomic update";
            type empty;
          }
        }
      }

      container tcam {
        tailf:info "Configure tcam parameters";
        uses tcam-region-grouping;
      }

      container resource {
        tailf:info "Hardware resource";
        container feature {
          tailf:info "Feature";
          leaf bank-mapping {
            tailf:info "Dynamic selection of tcam banks";
            type empty;
          }
        }
      }
    }

    container forwarding {
      tailf:info "Forwarding information";
      container unicast {
        tailf:info "Hardware Unicast forwarding";
        leaf trace {
          tailf:info "Debug traces";
          type empty;
        }
      }
      container interface {
        tailf:info "Interface";
        container statistics {
          tailf:info "Statistics";
          leaf mode {
            tailf:info "Statistics mode";
            tailf:cli-full-command;
            default "default";
            type enumeration {
              enum default { tailf:info "Default mode"; }
              enum mpls { tailf:info "Mpls mode"; }
              enum invalid  { tailf:info "Invalid"; }
            }
          }
          container stats-per-module {
            tailf:cli-drop-node-name;
            list mode {
              tailf:info "Statistics mode";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key module;
              leaf module {
                tailf:info "Specify a module number";
                tailf:cli-expose-key-name;
                type uint8 {
                  tailf:info "<1-N>;;Module number";
                }
              }
              leaf mode {
                tailf:info "Statistics mode";
                tailf:cli-drop-node-name;
                tailf:cli-prefix-key;
                mandatory true;
                type enumeration {
                  enum default { tailf:info "Default mode"; }
                  enum mpls { tailf:info "Mpls mode"; }
                  enum invalid  { tailf:info "Invalid"; }
                }
              }
            }
          }
        }
      }
    }

    container ip {
      tailf:info "IP";
      container glean {
        tailf:info "Glean";
        container throttle {
          tailf:info "Throttle";
          tailf:cli-display-separated;
          presence "true";
          leaf maximum {
            tailf:info "Maximum number of entries";
            tailf:cli-diff-dependency "../../throttle";
            default 1000;
            type uint16 {
              tailf:info "<0-32767>;;Count";
              range "0..32767";
            }
          }
          leaf syslog {
            tailf:info "Threshold for syslog for number of packets hitting the entry";
            tailf:cli-diff-dependency "../../throttle";
            default 10000;
            type uint16 {
              tailf:info "<0-65535>;;Packet count";
            }
          }
          leaf timeout {
            tailf:info "Timeout";
            tailf:cli-diff-dependency "../../throttle";
            default 300;
            type uint16 {
              tailf:info "<300-1800>;;Timeout value in seconds (should be multiple of 30, else will be rounded off to nearest boundary)";
            }
          }
        }
      }
      container verify {
        tailf:info "Enable IPv4 and some IPv6 packet validation checks in hardware";
        container address {
          tailf:info "IPv4 Source and destination address validation";
          // class-e      Class E IDS check
          container destination {
            tailf:info "Check destination address";
            leaf zero {
              tailf:info "Destination address is 0.0.0.0";
              tailf:cli-boolean-no;
              default true;
              type boolean;
            }
          }
          leaf identical {
            tailf:info "Same IP SA and DA";
            tailf:cli-boolean-no;
            default false;
            type boolean;
          }
          leaf reserved {
            tailf:info "Source address is 127.x.x.x";
            tailf:cli-boolean-no;
            default false;
            type boolean;
          }
          container source {
            tailf:info "Check source address";
            leaf broadcast {
              tailf:info "Source address is 255.255.255.255";
              tailf:cli-boolean-no;
              default true;
              type boolean;
            }
            leaf multicast {
              tailf:info "Source address is 224.x.x.x";
              tailf:cli-boolean-no;
              default true;
              type boolean;
            }
          }
        }
        leaf checksum {
          tailf:info "Verify IPv4 and IPv6 packet checksum";
          tailf:cli-boolean-no;
          default true;
          type boolean;
        }
        leaf fragment {
          tailf:info "Check IPv4 and IPv6 fragment with non-zero offset and DF bit active";
          tailf:cli-boolean-no;
          default false;
          type boolean;
        }
        container length {
          tailf:info "Validate IPv4 packet header and payload length";
          leaf consistent {
            tailf:info "Actual frame size is equal to or more than IPv4 length plus ethernet header";
            tailf:cli-boolean-no;
            default true;
            type boolean;
          }
          container maximum {
            tailf:info "Check max fragment offset and payload length";
            leaf max-frag {
              tailf:info "Fragment offset field value";
              tailf:cli-boolean-no;
              default true;
              type boolean;
            }
            leaf max-tcp {
              tailf:info "Maximum TCP length has to be less than IPv4 payload length";
              tailf:cli-boolean-no;
              default true;
              type boolean;
            }
          }
          leaf minimum {
            tailf:info "Minimum IPv4 header length";
            tailf:cli-boolean-no;
            default true;
            type boolean;
          }
        }
        leaf protocol {
          tailf:info "Verify IP procotol";
          tailf:cli-boolean-no;
          default true;
          type boolean;
        }
        leaf syslog {
          tailf:info "Syslog Messages logging configuration for IDS check drops";
          tailf:cli-boolean-no;
          default false;
          type boolean;
        }
        container tcp {
          tailf:info "Validate TCP packet header";
          leaf flags {
            tailf:info "Check TCP flags";
            tailf:cli-boolean-no;
            default false;
            type boolean;
          }
          leaf tiny-frag {
            tailf:info "Check TCP tiny fragment";
            tailf:cli-boolean-no;
            default true;
            type boolean;
          }
        }
        leaf version {
          tailf:info "Must be 4 for an ethertype of IPv4 (0x0800)";
          tailf:cli-boolean-no;
          default true;
          type boolean;
        }
      }
    }

    container ipv6 {
      tailf:info "IPv6";
      container glean {
        tailf:info "Glean";
        container throttle {
          tailf:info "Throttle";
          tailf:cli-display-separated;
          presence "true";
          leaf maximum {
            tailf:info "Maximum number of entries";
            tailf:cli-diff-dependency "../../throttle";
            default 1000;
            type uint16 {
              tailf:info "<0-32767>;;Count";
            }
          }
        }
      }
    }

    container rate-limiter {
      tailf:info "Configure Rate-Limiter for packets forwarded to supervisor";
      container layer-2 {
        tailf:info "Layer-2 control and Bridged packets";
        leaf vpc-peer-gw {
          tailf:info "Traffic to be redirected to vPC peer";
          tailf:cli-full-command;
          tailf:cli-full-no;
          type union {
            type uint16 {
              tailf:info "<0-30000>;;Value in packets per sec";
            }
            type enumeration {
              enum disable { tailf:info "Disable the rate-limiter"; }
            }
          }
        }
        container vpc-pgw-per-module {
          tailf:cli-drop-node-name;
          list vpc-peer-gw {
            tailf:info "Traffic to be redirected to vPC peer";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key module;
            leaf module {
              tailf:info "Specify a module number";
              tailf:cli-expose-key-name;
              type uint8 {
                tailf:info "<1-N>;;Specify a module number";
              }
            }
            leaf value {
              tailf:cli-drop-node-name;
              tailf:cli-prefix-key;
              mandatory true;
              type union {
                type uint16 {
                  tailf:info "<0-30000>;;Value in packets per sec";
                }
                type enumeration {
                  enum disable { tailf:info "Disable the rate-limiter"; }
                }
              }
            }
          }
        }
      }
      container layer-3 {
        tailf:info "Layer-3 control and Routed packets";
        leaf glean {
          tailf:info "Glean traffic";
          type uint16 {
            tailf:info "<0-40000>;;Value in packets per sec";
          }
        }
        container multicast {
          tailf:info "Multicast data packets";
          leaf local-groups {
            tailf:info "Data packets punted for initiating SPT join";
            tailf:cli-full-command;
            tailf:cli-full-no;
            default "3000";
            type union {
              type uint16 {
                tailf:info "<0-30000>;;Value in packets per sec";
              }
              type enumeration {
                enum disable {
                  tailf:info "Disable the rate-limiter";
                }
              }
            }
          }
          container local-groups-per-module {
            tailf:cli-drop-node-name;
            list local-groups {
              tailf:info "Data packets punted for initiating SPT join";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key module;
              leaf module {
                tailf:cli-expose-key-name;
                type uint8 {
                  tailf:info "Specify a module number";
                }
              }
              leaf value {
                tailf:cli-drop-node-name;
                tailf:cli-prefix-key;
                mandatory true;
                type union {
                  type uint16 {
                    tailf:info "<0-30000>;;Value in packets per sec";
                  }
                  type enumeration {
                    enum disable {
                      tailf:info "Disable the rate-limiter";
                    }
                  }
                }
              }
            }
          }
          leaf directly-connected {
            tailf:info "Data packets punted for ASM source registration";
            tailf:cli-full-command;
            tailf:cli-full-no;
            default "3000";
            type union {
              type uint16 {
                tailf:info "<0-30000>  Value in packets per sec";
              }
              type enumeration {
                enum disable {
                  tailf:info "Disable the rate-limiter";
                }
              }
            }
          }
          container directly-connected-per-module {
            tailf:cli-drop-node-name;
            list directly-connected {
              tailf:info "Data packets punted for ASM source registration";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key module;
              leaf module {
                tailf:cli-expose-key-name;
                type uint8 {
                  tailf:info "Specify a module number";
                }
              }
              leaf value {
                tailf:cli-drop-node-name;
                tailf:cli-prefix-key;
                mandatory true;
                type union {
                  type uint16 {
                    tailf:info "<0-30000>;;Value in packets per sec";
                  }
                  type enumeration {
                    enum disable {
                      tailf:info "Disable the rate-limiter";
                    }
                  }
                }
              }
            }
          }
        }
      }
      container access-list-log {
        tailf:info "Select access-list-log";
        leaf packets {
          tailf:info "Set the rate in number of packets per second";
          type uint32 {
            tailf:info "<50-600000>;;Value in packets per sec";
          }
        }
        leaf packets-per-sec {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-40000>;;Value in packets per sec";
          }
        }
      }
      leaf span {
        tailf:info "SPAN traffic";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<0-40000>;;Value in packets per sec";
        }
      }
      container span-per-module {
        tailf:cli-drop-node-name;
        list span {
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key module;
          leaf module {
            tailf:cli-expose-key-name;
            tailf:info "Specify a module number";
            type uint8 {
              tailf:info "<1-N>;;Specify a module number";
            }
          }
          leaf value {
            tailf:cli-drop-node-name;
            tailf:cli-prefix-key;
            mandatory true;
            type uint16 {
              tailf:info "<0-40000>;;Value in packets per sec";
            }
          }
        }
      }
    }

    container qos {
      tailf:info "Configure qos related configuration";
      leaf ns-buffer-profile {
        tailf:info "NorthStar buffer absorption profiles";
        cli:context-value-inject "static" {
          cli:arguments "mesh";
          when "/tailfned/default-qos-ns-buffer-profile-mesh='true'";
        }
        cli:context-value-inject "static" {
          cli:arguments "burst";
          when "/tailfned/default-qos-ns-buffer-profile-mesh='false'";
        }
        type enumeration {
          enum "burst" {
            tailf:info "Burst optimized";
          }
          enum "mesh" {
            tailf:info "Mesh optimized";
          }
          enum "ultra-burst" {
            tailf:info "Ultra burst optimzed";
          }
        }
      }

      container shared-buffer {
        tailf:info "Classification for shared buffer";
        list module {
          tailf:info "Controls which modules shared-buffer queing is enable";
          tailf:cli-suppress-mode;
          key id;
          leaf id {
            type uint8 {
              tailf:info "<1-18>;;Module number";
            }
          }
        }
      }
    }

    container profile {
      tailf:info "Profile settings";
      container tcam {
        tailf:info "Configure tcam parameters";
        container feature {
          container interface-qos {
            tailf:info "interface QoS";
            leaf limit {
              tailf:info "interface QoS TCAM limit";
              type tcam-size-type;
            }
          }
        }
        uses tcam-region-grouping;
      }

      leaf portmode {
        tailf:info "QSFP port mode setting";
        type string {
          tailf:info "<mode>;;48x10G+6x40G, 48x10g+breakout6x40g, 72x10g... (NOTE: case-sensitive, must match device)";
        }
      }

      container multicast {
        tailf:info "Multicast settings";
        leaf max-limit {
          tailf:info "Maximum limit";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<0-32768>;;Mcast Table Entries";
          }
        }
        container max-limit-lpm {
          tailf:cli-drop-node-name;
          container max-limit {
            tailf:cli-incomplete-command;
            leaf lpm-entries {
              tailf:info "Lpm(non-host) entries";
              type uint16 {
                tailf:info "<0-4096>;;Maximum entries";
              }
            }
          }
        }
      }
      container buffer {
        tailf:info "Buffer utilization related configuration";
        container monitor {
          tailf:info "Monitor buffer utilization";
          //raise-syslog  Raise syslog once the usage of buffer crosses given threshold
          container sampling {
            tailf:info "Hardware polling interval configuration";
            leaf fast {
              tailf:info "Enable fast polling (250 milliseconds)";
              type empty;
            }
          }
        }
      }
    }

    list module {
      tailf:info "Controls which modules shared-buffer queing is enable";
      nx:delete-with "none";
      key "id port-group";
      leaf id {
        type uint8 {
          tailf:info "<1-18>;;Module number";
        }
      }
      leaf port-group {
        tailf:info "Controls which port-group shared-buffer queing is enable";
        tailf:cli-expose-key-name;
        type uint8 {
          tailf:info "<0-11>;;Port group numbers";
        }
      }

      container qos {
        tailf:info "QoS Global Commands";
        container shared-buffer {
          tailf:info "Classification for shared buffer";
          tailf:cli-full-no;
          container queue-limit {
            tailf:info "Classification for bandwidth of shared buffer";
            leaf percent {
              tailf:info "Percent of available bandwidth";
              tailf:ned-default-handling report-all;
              default 50;
              type uint8 {
                tailf:info "<10-80>;;Queue-limit percentage for port-groups";
              }
            }
          }
        }
      }
    }

    container multicast {
      tailf:info "Multicast feature";

      leaf disable-slow-port-pruning {
        tailf:info "Disable slow port pruning";
        type empty;
      }

      container snooping {
        tailf:info "IGMP snooping";

        leaf group-limit {
          tailf:info "Specify the group-limit";
          type uint16 {
            tailf:info "<100-16000>;;Specify a value between 100-16000";
          }
        }
      }
    }

    container ejector {
      tailf:info "Card ejector functionality";
      leaf enable {
        tailf:info "Enabled means when both ejectors are open, card is powered down";
        tailf:cli-boolean-no;
        default true;
        type boolean;
      }
    }

    container fabricpath {
      tailf:info "Fabric Path";
      container mac-learning {
        tailf:info "MAC Learning";
        list module {
          tailf:info "Specify a module number";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key id;
          leaf id {
            type uint8 {
              tailf:info "<1-N>;;Specify a module number";
            }
          }
          leaf port-group {
            tailf:info "Port Group";
            type string;
          }
        }
      }
    }

  }


  /// ========================================================================
  /// port-profile
  /// ========================================================================

  container port-profile {
    tailf:info "Configure a port-profile";
    container default {
      tailf:info "Configure default settings";

      // port-profile default max-ports
      leaf max-ports {
        tailf:info "Configure default max-ports";
        type uint16 {
          tailf:info "<1-1024>;;Enter the default max-number of ports for "
            +"vethernet port-profiles";
          range "1..1024";
        }
      }

      // port-profile default port-binding static
      leaf port-binding {
        type enumeration {
          enum "static";
          enum "dynamic";
          enum "ephemeral";
        }
      }
    }

    // port-profile type *
    list profiles {
      tailf:cli-drop-node-name;
      tailf:cli-mode-name "config-port-prof";
      key id;
      leaf id {
        tailf:cli-disallow-value "default";
        type string {
          tailf:info "WORD;;Enter the name of the profile (Max Size 80)";
        }
      }
      leaf type {
        tailf:info "Configure type of the profile";
        tailf:cli-prefix-key;
        type enumeration {
          enum "ethernet" { tailf:info "Ethernet type"; }
          enum "interface-vlan" { tailf:info "Interface-vlan type"; }
          enum "port-channel" { tailf:info "Port-channel type"; }
          enum "vethernet" ;
          enum pseudowire { tailf:info "Pseudowire type"; }
          enum tunnel-te { tailf:info "Tunnel-te type"; }
        }
      }

      // port-profile type * / max-ports
      leaf max-ports {
        tailf:info "Max ports on which this profile can be inherited";
        default 512;
        type uint16 {
          range "1..1024";
        }
      }

      container capability {
        // port-profile type * / capability l3control
        leaf l3control {
          type empty;
        }
        // port-profile type * / capability vxlan
        leaf vxlan {
          type empty;
        }
      }

      // port-profile type * / vmware
      container vmware {
        tailf:info "VMware configuration";
        leaf port-group {
          type empty;
        }
      }

      // port-profile type * / shutdown
      leaf shutdown {
        tailf:info "Enable/disable an interface";
        tailf:cli-show-no;
        type empty;
      }

      // port-profile type * / guid
      leaf guid {
        type string;
      }

      // port-profile type * / description
      leaf description {
        tailf:info "Enter description of maximum 80 characters";
        tailf:cli-full-command;
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-no-value-on-delete;
        type string;
      }

      // port-profile type * / state
      leaf state {
        tailf:info "Port-profile state";
        type enumeration {
          enum "enabled";
          enum "disabled";
        }
      }

      // port-profile type * / publish
      leaf publish {
        type enumeration {
          enum "port-profile";
        }
      }

      // port-profile type * / inherit
      container inherit {
        tailf:info "Inherit a port-profile";
        leaf port-profile {
          tailf:info "Inherit a port-profile";
          type string {
            tailf:info "WORD;;Enter the name of the profile (Max Size 80)";
          }
        }
      }

      container switchport {
        tailf:info "Configure switchport parameters";

        leaf enable {
          tailf:cli-drop-node-name;
          type empty;
        }

        // port-profile type * / switchport mode
        leaf mode {
          tailf:info "Enter the port mode";
          nx:trim-default-in-show;
          default access;
          type enumeration {
            enum "access" {
              tailf:info "Set access mode characteristics of the interface";
            }
            enum "trunk" {
              tailf:info "Configure trunking parameters on an interface";
            }
            enum dot1q-tunnel {
              tailf:info "Port mode dot1q tunnel";
            }
            enum fabricpath {
              tailf:info "Port mode fabricpath";
            }
            enum fex-fabric {
              tailf:info "Port mode FEX fabric";
            }
          }
        }
        // port-profile type * / switchport access
        container access {
          tailf:info "Set access mode characteristics of the interface";
          leaf vlan {
            tailf:info "Set VLAN when interface is in access mode";
            type uint16 {
              tailf:info "<1-3967,4048-4093>;;VLAN ID of the VLAN when this "
                +"port is in access mode";
            }
          }
        }
        // port-profile type * / switchport trunk
        container trunk {
          tailf:info "Configure trunking parameters on an interface";
          when "../mode = 'trunk'" {
            tailf:dependency "../mode";
          }
          container native {
            tailf:info "Set trunking native characteristics when interface "
              +"is in trunking mode";
            leaf-list vlan {
              tailf:info "Set native VLAN when interface is in trunking mode";
              tailf:cli-range-list-syntax;
              tailf:cli-replace-all;
              type uint16;
            }
          }
          container allowed {
            tailf:info "Set allowed VLAN characteristics when interface "+
              "is in trunking mode";
            container vlan {
              tailf:info "Set allowed VLANs when interface is in trunking mode";
              // Note: The below extension handles add/remove keywords, also drops
              // 'add' when present in config on device (i.e. where device splits
              // range over multiple lines)
              nx:handle-allowed-vlan;
              choice vlan-choice {
                leaf none {
                  tailf:info "No VLANs";
                  type empty;
                }
                leaf-list ids {
                  tailf:cli-drop-node-name;
                  tailf:cli-range-list-syntax;
                  type vlan-list-type;
                }
              }
            }
          }
        }

        container port-security {
          tailf:cli-display-separated;
          presence "true";
          leaf maximum {
            type uint16;
          }
        }

      }

      leaf org {
        type string;
      }

      container ip {
        tailf:info "Configure IP features";
        container port {
          tailf:info "Port policy";
          leaf access-group {
            tailf:info "Specify access control for packets";
            type string {
              tailf:info "WORD;;List name (Max Size 64)";
            }
          }
        }
        container verify {
          leaf source {
            type enumeration {
              enum "dhcp-snooping-vlan";
            }
          }
        }
      }

      container vn-service {
        tailf:cli-compact-syntax;
        leaf ip-address {
          type inet:ipv4-address;
        }
        leaf l3-mode {
          type empty;
        }
        leaf security-profile {
          type string;
        }
      }

      container channel-group {
        tailf:info "Configure port channel parameters";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;

        leaf auto {
          type empty;
        }

        leaf mode {
          type enumeration {
            enum "on";
            enum "off";
          }
        }

        leaf mac-pinning {
          type empty;
        }
      }

      container system {
        leaf vlan {
          type uint16;
        }
      }

      leaf mtu {
        tailf:info "Configure mtu for the port";
        type uint16 {
          tailf:info "<576-9216>;;Enter MTU";
        }
      }

      list load-interval {
        tailf:info "Specify interval for load calculation for an interface";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key counter;
        leaf counter {
          tailf:cli-expose-key-name;
          type uint8 {
            tailf:info "<1-3>;;Specify counter for this load interval";
          }
        }
        leaf delay {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<30-300>;;Load interval delay in seconds";
          }
        }
      }

      container cdp {
        leaf enable {
          tailf:info "Configure CDP interface parameters";
          tailf:cli-boolean-no;
          default "true";
          type boolean;
        }
      }

      container spanning-tree {
        tailf:info "Spanning Tree Subsystem";
        container port {
          tailf:info "Spanning tree port options";
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-compact-syntax;
          leaf type {
            tailf:info "Specify a port type for spanning tree protocol use";
            type enumeration {
              enum edge    {
                tailf:info "Consider the interface as edge port (enable portfast)";
              }
              enum network {
                tailf:info "Consider the interface as inter-switch link";
              }
              enum normal  {
                tailf:info "Consider the interface as normal spanning tree port";
              }
            }
          }
          leaf trunk {
            tailf:info "Consider the interface as edge port (enable portfast) even in trunk mode";
            type empty;
          }
        }
        leaf port-priority {
          tailf:info "Change an interface's spanning tree port priority";
          type uint8 {
            tailf:info "<0-224>;;Port priority in increments of 32";
          }
        }
      }

      list service-policy {
        tailf:info "Configure service policy for an interface";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        key "type direction";
        leaf type {
          tailf:info "Specify the type of this policy";
          tailf:cli-expose-key-name;
          type enumeration {
            enum qos { tailf:info "Qos policy"; }
            enum queuing { tailf:info "Queuing policy"; }
          }
        }
        leaf direction {
          type enumeration {
            enum input { tailf:info "Input Service Policy"; }
            enum output { tailf:info "Output Service Policy"; }
          }
        }
        leaf policy-map {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;Policy-map name (Max Size 40)";
          }
        }
        leaf no-stats {
          tailf:info "Disable statistics for this policy";
          type empty;
        }
      }

      leaf port-type {
        tailf:info "Identifies if port is fabric-facing or not";
        type string;
      }

      container encapsulation {
        tailf:info "Data encapsulation method";
        container mpls {
          tailf:info "Use MPLS encapsulation";
          tailf:cli-diff-dependency "/nx:feature/mpls/l2vpn";
          tailf:cli-add-mode;
          presence true;
        }
      }
    }
  }


  /// ========================================================================
  /// configure (from exec)
  /// ========================================================================

  grouping maintenance-mode-grouping {
    container system {
      tailf:info "System management commands";
      container interface {
        tailf:info "Configure system interface config";
        leaf shutdown {
          tailf:info "Configure interface shutdown";
          tailf:cli-boolean-no;
          tailf:cli-show-with-default;
          tailf:ned-default-handling report-all;
          default false;
          type boolean;
        }
      }
    }
    container router {
      tailf:info "Enable a routing process";
      // router bgp *
      list bgp {
        tailf:info "Border Gateway Protocol (BGP)";
        tailf:cli-mode-name "config-router";
        tailf:cli-diff-dependency "/nx:feature/bgp";
        key id;
        leaf id {
          type string {
            tailf:info "Autonomous system number";
          }
        }
        leaf isolate {
          tailf:info "Withdraw remote BGP routes to isolate this router";
          type empty;
        }
        container template {
          tailf:info "Enter template command mode";
          tailf:cli-compact-syntax;
          tailf:cli-incomplete-command;
          // router bgp * / template peer *
          list peer {
            tailf:info "Template configuration for peer parameters";
            tailf:cli-explicit-exit;
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;Neighbor template name (Max Size 80)";
                length "1..80";
              }
            }

            // router bgp * / template peer * / X
            uses template-neighbor-common-grouping;

            // router bgp * / template peer * / remote-as
            leaf remote-as {
              tailf:info "Specify Autonomous System Number of the neighbor";
              type asn-type;
            }
          }
        }
      }
      list ospf {
        tailf:info "Open Shortest Path First (OSPF)";
        tailf:cli-mode-name "config-router";
        tailf:cli-diff-dependency "/nx:feature/ospf";
        key id;
        leaf id {
          tailf:cli-suppress-range;
          type ospf-id-type;
        }
        leaf isolate {
          tailf:info "Isolate this router from OSPF perspective";
          type empty;
        }
      }
    }
  }

  container configure {
    container maintenance {
      tailf:info "Maintenance profile mode";
      container profile {
        tailf:info "Maintenance profile";

        container maintenance-mode {
          tailf:info "Maintenance mode profile";
          tailf:cli-add-mode;
          tailf:cli-exit-command "configure terminal";
          tailf:cli-diff-delete-after "/nx:system/mode/maintenance";
          presence true;
          uses maintenance-mode-grouping;
        }

        container normal-mode {
          tailf:info "Normal mode profile";
          tailf:cli-add-mode;
          tailf:cli-exit-command "configure terminal";
          tailf:cli-diff-delete-after "/nx:system/mode/maintenance";
          presence true;
          uses maintenance-mode-grouping;
        }

      }
    }
  }


  /// ========================================================================
  /// system
  /// ========================================================================

  container system {
    tailf:info "System management commands";

    // system bridge-domain *
    leaf-list bridge-domain {
      tailf:info "Bridge-Domain";
      tailf:cli-range-list-syntax;
      tailf:cli-remove-before-change;
      tailf:cli-full-command;
      type uint16 {
        tailf:info "Bridge-domain ID 1-4094 or range(s): "
          +"1-5, 10 or 2-5,7-19";
        range "1..4094";
      }
    }

    // system vlan
    container vlan {
      tailf:info "Vlan commands";

      leaf long-name {
        tailf:info "Configure 128 character VLAN names";
        tailf:cli-full-command;
        type empty;
      }

      container nve-overlay {
        tailf:info "Nve overlay vlan";
        leaf-list id {
          tailf:info "VLAN ID";
          tailf:cli-range-list-syntax;
          type uint16 {
            tailf:info "<1-4094>;;VLAN ID 1-4094 or range(s): 1-5, 10 or 2-5,7-19";
          }
        }
      }

    }

    // system storage-loss log time
    container storage-loss {
      container log {
        leaf time {
          type uint16;
        }
      }
    }

    // system qos
    container qos {
      tailf:info "QoS parameters";
      tailf:cli-add-mode;
      // Skip: 'system qos / fex'

      // system qos / service-policy type
      container service-policy {
        tailf:info "Policy Map";
        container type {
          tailf:info "Specify the type of this policy-map";

          // system qos / service-policy type network-qos
          leaf network-qos {
            tailf:info "Network Qos policy";
            tailf:non-strict-leafref {
              path "/nx:policy-map/type/network-qos/name";
            }
            type policy-map-name-type;
          }

          // system qos / service-policy type qos
          container qos {
            tailf:info "System-level QoS policy";
            // system qos / service-policy type qos input
            leaf input {
              tailf:info "Input Service Policy";
              tailf:non-strict-leafref {
                path "/nx:policy-map/type/qos/name";
              }
              type policy-map-name-type;
            }
          }

          // system qos / service-policy type queuing
          container queuing {
            tailf:info "DCE Queuing policy";
            // system qos / service-policy type queuing input
            leaf input {
              tailf:info "Input Service Policy";
              tailf:non-strict-leafref {
                path "/nx:policy-map/type/queuing/name";
              }
              type policy-map-name-type;
            }
            // system qos / service-policy type queuing output
            leaf output {
              tailf:info "Output Service Policy";
              tailf:non-strict-leafref {
                path "/nx:policy-map/type/queuing/name";
              }
              type policy-map-name-type;
            }
          }
        }
      }
    }

    // system auto-upgrade epld
    container auto-upgrade {
      tailf:info "Enable/Disable automatic upgrade";
      leaf epld {
        tailf:info "Enable/Disable automatic EPLD upgrade";
        tailf:cli-show-no;
        type empty;
      }
    }

    // system module-type *
    leaf-list module-type {
      tailf:info "Controls which type of modules are allowed in this chassis";
      tailf:cli-flat-list-syntax {
        tailf:cli-replace-all;
      }
      type module-type;
    }

    // system jumbomtu
    leaf jumbomtu {
      tailf:info "Configure system jumbomtu";
      type uint16 {
        tailf:info "<1500-9216>;;Enter jumbomtu";
      }
    }

    // system urpf disable
    container urpf {
      tailf:info "Manage urpf enable/disable";
      leaf disable {
        tailf:info "Disable/enable";
        type empty;
      }
    }

    container module {
      tailf:info "Module commands";
      container failure-action {
        tailf:info "Configure module action on failure";
        leaf shutdown {
          tailf:info "Action on failure - shutdown";
          type empty;
        }
      }
    }

    // system nve
    container nve {
      tailf:info "VXLAN interface";
      leaf-list infra-vlans {
        tailf:info "Configure Vxlan SVI Uplinks(requires system reload)";
        tailf:cli-range-list-syntax;
        type uint16 {
          tailf:info "<1-4094>;;VLAN ID 1-4094 or range(s): 1-5, 10 or 2-5,7-19 (The range of vlans configured must not exceed 512)";
        }
      }
    }

    // system interface
    container interface {
      tailf:info "Configure system interface config";
      leaf shutdown {
        tailf:info "Configure interface shutdown";
        type empty;
      }
    }

    // system mode
    container mode {
      tailf:info "System mode commands";
      container maintenance {
        tailf:info "System maintenance mode";
        nx:maintenance-mode-cleanup;
        presence true;
        leaf shutdown {
          tailf:info "Issue shutdown instead of isolate (default)";
          tailf:cli-delete-container-on-delete;
          type empty;
        }
      }
    }

    leaf admin-vdc {
      tailf:info "Make the default vdc used only for switchwide configuration";
      when "/nx:tailfned/dayzero-included" {
        tailf:dependency "/nx:tailfned/dayzero-included";
      }
      nx:dayzero-config;
      type empty;
    }

    // system default
    container default {
      tailf:info "Configure system default values";
      leaf switchport {
        tailf:info "Configure switchport";
        when "/nx:tailfned/dayzero-included" {
          tailf:dependency "/nx:tailfned/dayzero-included";
        }
        nx:dayzero-config;
        tailf:cli-full-command;
        tailf:cli-boolean-no;
        type boolean;
      }

      container switchport-config {
        tailf:cli-drop-node-name;
        container switchport {
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          tailf:info "Configure switchport";
          leaf shutdown {
            tailf:info "Configure admin state";
            tailf:cli-boolean-no;
            when "/nx:tailfned/dayzero-included" {
              tailf:dependency "/nx:tailfned/dayzero-included";
            }
            nx:dayzero-config;
            type boolean;
          }
          leaf fabricpath {
            tailf:cli-diff-delete-before "/nx:feature-set/fabricpath" {
              tailf:cli-when-target-delete;
            }
            when "/nx:tailfned/dayzero-included" {
              tailf:dependency "/nx:tailfned/dayzero-included";
            }
            nx:dayzero-config;
            tailf:info "Configure default port mode as fabricpath";
            type empty;
          }
        }
      }

      container zone {
        tailf:info "Configure default values for zone";
        container smart-zone {
          tailf:info "Configure default values for smart-zone";
          leaf enable {
            tailf:info "Default smart-zone enable/disable";
            type empty;
          }
        }
      }
    }

    container routing {
      tailf:info "Layer-3 routing";
      leaf unknown-unicast-flood {
        tailf:info "Hardware flood post-routed traffic on SVI if dest-mac->layer2-port binding unknown";
        tailf:cli-boolean-no;
        default true;
        type boolean;
      }
      leaf template {
        tailf:cli-drop-node-name;
        type enumeration {
          enum template-dual-stack-host-scale {
            tailf:info "Dual Stack Host Scale";
          }
          enum template-internet-peering {
            tailf:info "Internet Peering";
          }
          enum template-lpm-heavy {
            tailf:info "LPM Heavy";
          }
          enum template-mpls-heavy {
            tailf:info "MPLS Heavy Scale";
          }
          enum template-multicast-heavy {
            tailf:info "Multicast Heavy Scale";
          }
        }
      }
    }

    container vrf-member-change {
      tailf:info "Vrf member change";
      leaf retain-l3-config {
        tailf:info "Retain L3 configuration";
        nx:vrf-member-chg-retain-l3;
        type empty;
      }
    }

    container dot1q-tunnel {
      tailf:info "Dot1Q tunnel";
      container transit {
        tailf:info "Transit box for multi-tag Ethernet Frames";
        presence true;
        leaf vlan {
          type uint16;
        }
      }
    }

    container  login {
      tailf:info "Enable secure login checking";
      container block-for {
        tailf:info "Set quiet-mode active time period";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf time {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<1-65535>;;Time period in seconds";
          }
        }
        leaf attempts {
          tailf:info "Set max number of fail attempts";
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<1-65535>;;Fail attempts max value";
          }
        }
        leaf within {
          tailf:info "Watch period for fail attempts";
          type uint16 {
            tailf:info "<1-65535>;;Time period in seconds";
          }
        }
      }
      container quiet-mode {
        tailf:info "Set quiet-mode options";
        leaf access-class {
          tailf:info "Set access class";
          type string {
            tailf:info "WORD;;Access-list name (Max Size 64)";
          }
        }
      }
    }

  }

  /// ========================================================================
  /// bridge-domain
  /// ========================================================================

  // bridge-domain * <CR>
  list bridge-domain {
    tailf:info "Bridge-Domain";
    key id;
    nx:expand-bridge-domain;
    leaf id {
      tailf:info "Bridge-Domain";
      tailf:cli-diff-dependency "/nx:vni";
      tailf:cli-diff-dependency "../../feature/vni";
      // This when triggers bug in NSO >= 4.4.2.2
      //      when "../../feature/vni" {
      //        tailf:dependency "../../feature/vni";
      //      }
      tailf:cli-diff-dependency "/nx:system/bridge-domain";
      type uint16 {
        tailf:info "<1..4094>;;Bridge-domain ID 1-4094 or range(s): "
          +"1-5, 10 or 2-5,7-19";
        range "1..4094";
      }
    }
    // bridge-domain * / member vni * <CR>
    container member {
      tailf:info "Configure the bridge domain member";
      tailf:cli-no-name-on-delete;
      leaf vni {
        tailf:info "Virtual Network Identifier";
        tailf:cli-diff-dependency "/nx:vni";
        tailf:cli-no-name-on-delete;
        tailf:cli-no-value-on-delete;
        nx:expand-bd-member-vni;
        type uint32 {
          tailf:info "<1-16777215>;;Specify VNI ID";
        }
      }
    }
    uses vlan-bd-config-grouping;
  }


  /// ========================================================================
  /// vdc
  /// ========================================================================

  container vdc {
    tailf:info "Manage Virtual Device Context ";

    // vdc *
    list vdc-list {
      tailf:cli-drop-node-name;
      key "name id";
      leaf name {
        tailf:cli-disallow-value "resource";
        type string;
      }
      leaf id {
        tailf:cli-expose-key-name;
        type uint16;
      }
      uses vdc-grouping;

      leaf cpu-share {
        tailf:info "Priority of this vdc. Control cpu time during periods of contention";
        type uint8 {
          tailf:info "<1-10>;;Priority of this vdc. Control cpu time during periods of contention";
          range "1..10";
        }
      }

      container allow {
        tailf:info "Used to change permisions inside a vdc";
        container feature-set {
          uses feature-set-grouping {
            // OUCH...
            refine fabric {
              tailf:cli-diff-create-before "/nx:feature-set/fabric";
              tailf:cli-diff-delete-before "/nx:install/feature-set/fabric" {
                tailf:cli-when-target-delete;
              }
              tailf:cli-diff-delete-after "/nx:feature-set/fabric" {
                tailf:cli-when-target-delete;
              }
            }
            refine fabricpath {
              tailf:cli-diff-create-before "/nx:feature-set/fabricpath";
              tailf:cli-diff-delete-before "/nx:install/feature-set/fabricpath" {
                tailf:cli-when-target-delete;
              }
              tailf:cli-diff-delete-after "/nx:feature-set/fabricpath" {
                tailf:cli-when-target-delete;
              }
            }
            refine fcoe {
              tailf:cli-diff-create-before "/nx:feature-set/fcoe";
              tailf:cli-diff-delete-before "/nx:install/feature-set/fcoe" {
                tailf:cli-when-target-delete;
              }
              tailf:cli-diff-delete-after "/nx:feature-set/fcoe" {
                tailf:cli-when-target-delete;
              }
            }
            refine fex {
              tailf:cli-diff-create-before "/nx:feature-set/fex";
              tailf:cli-diff-delete-before "/nx:install/feature-set/fex" {
                tailf:cli-when-target-delete;
              }
              tailf:cli-diff-delete-after "/nx:feature-set/fex" {
                tailf:cli-when-target-delete;
              }
            }
            refine mpls {
              tailf:cli-diff-create-before "/nx:feature-set/mpls";
              tailf:cli-diff-create-after "/nx:install/feature-set/mpls";
              tailf:cli-diff-delete-before "/nx:install/feature-set/mpls" {
                tailf:cli-when-target-delete;
              }
              tailf:cli-diff-delete-after "/nx:feature-set/mpls" {
                tailf:cli-when-target-delete;
              }
            }
            refine virtualization {
              tailf:cli-diff-create-before "/nx:feature-set/virtualization";
              tailf:cli-diff-create-after "/nx:install/feature-set/virtualization";
              tailf:cli-diff-delete-before "/nx:install/feature-set/virtualization" {
                tailf:cli-when-target-delete;
              }
              tailf:cli-diff-delete-after "/nx:feature-set/virtualization" {
                tailf:cli-when-target-delete;
              }
            }
          }
        }
      }

      container allocate {
        tailf:info "Assign interfaces to vdc";
        list interface {
          tailf:info "Assign interface range to vdc";
          key name;
          leaf name {
            type string {
              tailf:info "Interface name/range to allocate NOTE: write exactly as device reports back in 'show running-config'";
            }
          }
        }
      }

      leaf boot-order {
        tailf:info "The order at which a vdc will boot up. VDCs at the same level will be started parallely";
        type uint8 {
          tailf:info "<1-9>;;The order at which a vdc will boot up.";
        }
      }

    }

    // vdc resource template *
    container resource {
      tailf:info "Configure resource template";
      list template {
        tailf:info "Configure resource template";
        tailf:cli-mode-name "config-vdc-template";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Resource template name (Max Size 255)";
          }
        }
        uses vdc-grouping;
      }
    }

    leaf combined-hostname {
      tailf:info "The hostname of non-default vdcs will be <default vdc name>-<nondefault vdc name>";
      tailf:cli-boolean-no;
      default true;
      type boolean;
    }

  }


  /// ========================================================================
  /// policy-map
  /// ========================================================================

  container policy-map {
    tailf:info "Configure a policy map";
    container type {
      tailf:info "Specify the type of this policy-map";
      // policy-map type control-plane *
      list control-plane {
        tailf:info "Control-Plane";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Policy-map name (alphanumeric) (Max Size 64)";
            length "1..64";
          }
        }
        list class {
          tailf:info "Policy Criteria";
          tailf:cli-mode-name "config-pmap-c";
          tailf:cli-diff-dependency "/nx:class-map/type/control-plane";
          key name;
          leaf name {
            tailf:non-strict-leafref {
              path "/nx:class-map/type/control-plane/name";
            }
            type class-name-type;
          }
          uses policy-map-class-qos-grouping;
          container logging {
            tailf:info "Set logging for copp class";
            container drop {
              tailf:info "Logging for copp drops";
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              tailf:cli-compact-syntax;
              leaf threshold {
                tailf:info "Threshold value for dropped bytes";
                type uint64 {
                  tailf:info "<1-80000000000>;;Dropped byte count";
                }
              }
              leaf level {
                tailf:info "Syslog level";
                type uint8 {
                  tailf:info "<1-7>;;Specify the logging level between 1-7";
                }
              }
            }
          }
        }
      }
      // policy-map type qos *
      list qos {
        tailf:info "Qos class";
        tailf:cli-mode-name "config-pmap-qos";
        key name;
        leaf name {
          type policy-map-name-type;
        }
        leaf description {
          tailf:info "Policy-Map description";
          tailf:cli-full-command;
          tailf:cli-multi-value;
          tailf:cli-preformatted;
          tailf:cli-no-value-on-delete;
          type string {
            tailf:info "LINE;;Description of this policy-map (up to 200 "
              +"characters)";
          }
        }
        list class {
          tailf:info "Policy Criteria";
          tailf:cli-mode-name "config-pmap-c-qos";
          tailf:cli-diff-dependency "/nx:class-map/type/qos";
          tailf:cli-show-long-obu-diffs;
          ordered-by user;
          key name;
          leaf name {
            tailf:non-strict-leafref {
              path "/nx:class-map/type/qos/name";
            }
            type class-name-type;
          }
          uses policy-map-class-qos-grouping;
        }
      }
      list network-qos {
        tailf:info "Network Qos class";
        tailf:cli-mode-name "config-cmap-nq";
        key name;
        leaf name {
          type policy-map-name-type;
        }
        leaf description {
          tailf:info "Policy-Map description";
          tailf:cli-full-command;
          tailf:cli-multi-value;
          tailf:cli-preformatted;
          tailf:cli-no-value-on-delete;
          type string {
            tailf:info "LINE;;Description of this policy-map (up to 200 "
              +"characters)";
          }
        }
        uses policy-map-class-network-qos-grouping;
      }
      list queuing {
        tailf:info "Queuing class";
        tailf:cli-mode-name "config-pmap-que";
        key name;
        leaf name {
          type policy-map-name-type;
        }
        leaf description {
          tailf:info "Policy-Map description";
          tailf:cli-full-command;
          tailf:cli-multi-value;
          tailf:cli-preformatted;
          tailf:cli-no-value-on-delete;
          type string {
            tailf:info "LINE;;Description of this policy-map (up to 200 "
              +"characters)";
          }
        }
        uses policy-map-class-queuing-grouping;
      }
    }
  }


  /// ========================================================================
  /// advertise
  /// ========================================================================

  container advertise {
    tailf:info "Advertise L2 multicast capability";
    container evpn {
      tailf:info "Evpn";
      leaf multicast {
        tailf:info "L2 multicast";
        tailf:cli-diff-delete-before "/nx:feature/nv/overlay";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// encapsulation
  /// ========================================================================

  // encapsulation
  container encapsulation {
    tailf:info "VNI Encapsulation Configuration";
    // encapsulation profile
    container profile {
      tailf:info "VNI Encapsulation Profile Configuration";
      // encapsulation profile vni
      list vni {
        tailf:info "Virtual Network Identifier";
        tailf:cli-diff-dependency "../../../feature/vni";
        when "../../../feature/vni" {
          tailf:dependency "../../../feature/vni";
        }
        key name;
        // encapsulation profile vni WORD <CR>
        leaf name {
          type string {
            tailf:info "WORD;;VNI Encapsulation Profile Name (Max Size 128)";
            length "1..128";
          }
        }
        list dot1q {
          tailf:info "Encapsulation Dot1q under service instance";
          tailf:cli-incomplete-command;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          nx:dot1q-vni-mappings;
          key vlan-id;
          leaf vlan-id {
            type uint16 {
              tailf:info "<2-4095>;;Encapsulation vlan id";
              range "2..4095";
            }
          }
          leaf vni {
            tailf:info "Virtual Network Identifier";
            tailf:cli-remove-before-change;
            type uint32 {
              tailf:info "<4096-16777215>;;Vni range, Example: "
                +"4096,4099-5013,5019,6011-6099";
              range "4096..16777215";
            }
          }
        }
        // encapsulation profile vni WORD / untagged
        container untagged {
          tailf:info "Untagged frame vni mapping";
          tailf:cli-compact-syntax;
          // encapsulation profile vni WORD / untagged vni
          // <4096-16777215>
          leaf vni {
            tailf:info "Virtual Network Identifier";
            type uint32 {
              tailf:info "<4096-16777215>;;Enter VN-Segment ID";
              range "4096..16777215";
            }
          }
        }
      }
    }
    // encapsulation vni
    container vni {
      tailf:info "Virtual Network Identifier";
      tailf:cli-diff-dependency "../../feature/vni";
      when "../../feature/vni" {
        tailf:dependency "../../feature/vni";
      }
      // encapsulation vni dynamic
      container dynamic {
        tailf:info "For autoconfig VDP VSIs only allow using this set of vlans";
        // encapsulation vni dynamic dot1q
        container dot1q {
          tailf:info "Set of vlans";
          tailf:cli-sequence-commands;
          tailf:cli-compact-syntax;
          // encapsulation vni dynamic dot1q vlan-id
          leaf-list vlan-id {
            tailf:info "Encapsulation vlan id";
            tailf:cli-drop-node-name;
            tailf:cli-range-list-syntax;
            type uint16 {
              tailf:info "2-4095;;Encapsulation vlan id";
              range "2..4095";
            }
          }
        }
      }
    }
  }

  /// ========================================================================
  /// l2vpn
  /// ========================================================================

  container l2vpn {
    tailf:info "Layer2 VPN commands";
    tailf:cli-diff-dependency "/nx:feature/mpls/l2vpn";
    tailf:cli-add-mode;
    container logging {
      tailf:info "Configure logging flags";
      container pseudowire {
        tailf:info "Pseudowire status transition logging";
        leaf status {
          tailf:info "Pseudowire status up/down logging";
          type empty;
        }
      }
      leaf redundancy {
        tailf:info "Xconnect redundancy events";
        type empty;
      }
    }
    leaf router-id {
      tailf:info "Configure a Layer2 router-id";
      type inet:ipv4-address {
        tailf:info "A.B.C.D;;Layer2 router-id value";
      }
    }
    leaf sanity {
      tailf:info "Enable sanity checks for Layer2 VPN";
      type empty;
    }
    leaf shutdown {
      tailf:info "Shutdown Layer2 VPN";
      type empty;
    }
    container vfi {
      tailf:info "Configure VFI global params";
      container redundancy {
        tailf:info "Configure VFI redundancy params";
        container delay {
          tailf:info "Configure VFI activation wait timers";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf init-wait {
            tailf:info "Configure VFI init wait time in sec";
            type uint16 {
              tailf:info "<1-3600>;;Init wait in secs";
            }
          }
          leaf pw-wait {
            tailf:info "Configure PW wait time in sec";
            type uint16 {
              tailf:info "<1-3600>;;PW wait in secs";
            }
          }
        }
      }
    }
  }

  container l2vpn-xconnect {
    tailf:cli-drop-node-name;
    container l2vpn {
      tailf:info "Layer2 VPN commands";
      container xconnect {
        tailf:info "Configure a cross connect";
        list context {
          tailf:cli-diff-dependency "/nx:feature/mpls/l2vpn";
          tailf:info "Layer2 VPN Context";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Configure the cross connect name (Max Size 31)";
            }
          }
          leaf description {
            tailf:info "Set xconnect description string";
            tailf:cli-full-command;
            tailf:cli-multi-value;
            tailf:cli-preformatted;
            tailf:cli-no-value-on-delete;
            type string {
              tailf:info "LINE;;Description of maximum 80 characters (Max Size 80)";
            }
          }
          leaf interworking {
            tailf:info "Interworking options for the cross connect";
            type enumeration {
              enum ethernet { tailf:info "Ethernet interworking"; }
              enum vlan { tailf:info "VLAN interworking"; }
            }
          }
          container member {
            tailf:info "Configure the cross connect member";
            list vc-member {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              tailf:cli-remove-before-change;
              key "address vc-id";
              leaf address {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IP address of the peer";
                }
              }
              leaf vc-id {
                type uint32 {
                  tailf:info "<1-4294967295>  Enter VC ID value";
                }
              }
              choice enc-or-prof {
                leaf encapsulation {
                  tailf:info "Data encapsulation method";
                  type enumeration {
                    enum mpls { tailf:info "Use MPLS encapsulation"; }
                  }
                }
                leaf port-profile {
                  tailf:info "Port-profile to use for encapsulation and protocol configuration";
                  tailf:non-strict-leafref {
                    path "/nx:port-profile/profiles/id";
                  }
                  type string {
                    tailf:info "WORD  Port-profile name (Max Size 31)";
                  }
                }
              }
              leaf group {
                tailf:info "Configure the cross connect member redundancy group";
                type string {
                  tailf:info "WORD;;Enter redundancy group name (Max Size 31)";
                }
              }
              leaf priority {
                tailf:info "Configure the cross connect member priority";
                type uint8 {
                  tailf:info "<0-16>;;Enter priority number of the member (0: Highest, 16: Lowest)";
                }
              }
            }
            list if-member {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              tailf:cli-remove-before-change;
              key interface;
              leaf interface {
                type string {
                  tailf:info "<interface>;;Ethernet IEEE 802.3z, Port Channel interface, or Pseudowire interface";
                }
              }
              leaf address {
                tailf:cli-drop-node-name;
                tailf:cli-optional-in-sequence;
                tailf:cli-incomplete-command;
                when "contains(../interface, 'pseudowire')" {
                  tailf:dependency "../interface";
                }
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IP address of the peer";
                }
              }
              leaf vc-id {
                tailf:cli-drop-node-name;
                when "../address" {
                  tailf:dependency "../address";
                }
                type uint32 {
                  tailf:info "<1-4294967295>;;Enter VC ID value";
                }
              }
              choice enc-or-prof {
                when "./vc-id" {
                  tailf:dependency "./vc-id";
                }
                leaf encapsulation {
                  tailf:info "Data encapsulation method";
                  type enumeration {
                    enum mpls { tailf:info "Use MPLS encapsulation"; }
                  }
                }
                leaf port-profile {
                  tailf:info "Port-profile to use for encapsulation and protocol configuration";
                  tailf:non-strict-leafref {
                    path "/nx:port-profile/profiles/id";
                  }
                  type string {
                    tailf:info "WORD  Port-profile name (Max Size 31)";
                  }
                }
              }
              leaf service-instance {
                tailf:info "Ethernet Service Instance";
                tailf:cli-optional-in-sequence;
                when "not(contains(../interface, 'pseudowire'))" {
                  tailf:dependency "../interface";
                }
                type uint16 {
                  tailf:info "<1-4095>;;Service Instance ID";
                }
              }
              leaf group {
                tailf:info "Configure the cross connect member redundancy group";
                type string {
                  tailf:info "WORD;;Enter redundancy group name (Max Size 31)";
                }
              }
              leaf priority {
                tailf:info "Configure the cross connect member priority";
                type uint8 {
                  tailf:info "<0-16>;;Enter priority number of the member (0: Highest, 16: Lowest)";
                }
              }
            }
          }
          container redundancy {
            tailf:info "Xconnect redundancy information";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf delay {
              tailf:info "Xconnect redundancy delay parameters";
              tailf:cli-incomplete-command;
              type uint8 {
                tailf:info "<0-180>;;Enable delay";
              }
            }
            leaf disable {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type union {
                type uint8 {
                  tailf:info "<0-180>;;Disable delay";
                }
                type enumeration {
                  enum never { tailf:info "Disallow disable"; }
                }
              }
            }
            leaf group {
              tailf:info "Redundancy group name";
              type string {
                tailf:info "WORD;;Enter name (Max Size 31)";
              }
            }
          }
          container remote {
            tailf:info "L2VPN remote peer configuration commands";
            container link {
              tailf:info "Link information";
              container failure {
                tailf:info "Failure information";
                leaf notification {
                  tailf:info "Notify in case of remote link failure";
                  tailf:cli-boolean-no;
                  default "true";
                  type boolean;
                }
              }
            }
          }
          leaf shutdown {
            tailf:info "Shutdown Xconnect";
            type empty;
          }
        }
      }
    }
  }

  /// ========================================================================
  /// slot
  /// ========================================================================

  list slot {
    tailf:info "Configure a slot";
    key number;
    leaf number {
      type uint8 {
        tailf:info "<1-199>  Enter a slot number";
      }
    }
    container provision {
      tailf:info "Pre-provision a module in this slot";
      leaf model {
        tailf:info "Type of the module to be provisioned";
        tailf:cli-remove-before-change;
        type union {
          type enumeration {
            enum N2K-B22DELL {
              tailf:info "Fabric Extender 16x10G Module";
            }
            enum N2K-B22FJ {
              tailf:info "Fabric Extender 16x10G Module";
            }
            enum N2K-B22HP {
              tailf:info "Fabric Extender 16x10G Module";
            }
            enum N2K-B22IBM {
              tailf:info "Fabric Extender 14x10G Module";
            }
            enum N2K-C2148T {
              tailf:info "Fabric Extender 48x1G 4x10G Module";
            }
            enum N2K-C2232P {
              tailf:info "Fabric Extender 32x10G Module";
            }
            enum N2K-C2232TM {
              tailf:info "Fabric Extender 32x10G Module - Zephyr";
            }
            enum N2K-C2232TM-E-10GE {
              tailf:info "Fabric Extender 32x10G Module - Zephyr VE";
            }
            enum N2K-C2248GV+P {
              tailf:info "Fabric Extender 48x1G 4x10G POE Module";
            }
            enum N2K-C2248PQ {
              tailf:info "Fabric Extender 48x10G 4x40G QSFP Module";
            }
            enum N2K-C2248T {
              tailf:info "Fabric Extender 48x1G 4x10G Module";
            }
            enum N2K-C2248TP-E-1GE {
              tailf:info "Fabric Extender 48x1G 4x10G Module";
            }
            enum N2K-C2332TQ {
              tailf:info "Fabric Extender 32*10G(T), 4*40G Module";
            }
            enum N2K-C2348TQ {
              tailf:info "Fabric Extender 48*10G(T), 6*40G Module";
            }
            enum N2K-C2348UPQ {
              tailf:info "Fabric Extender 48*10G, 6*40G Module";
            }
            enum N2K-N2224TP {
              tailf:info "Fabric Extender 24x1G 2x10G SFP+ Module";
            }
            enum N55-M12T {
              tailf:info "Cisco 12x10GBase-T Ethernet Expansion Module";
            }
            enum N55-M16FP {
              tailf:info "Cisco 16 port Port Fiber Channel Expansion Module 16 x SFP";
            }
            enum N55-M16P {
              tailf:info "Cisco 16x10G Ethernet Expansion Module";
            }
            enum N55-M16UP {
              tailf:info "Cisco 16x10G Flexible Ethernet Expansion Module";
            }
            enum N55-M4EP40G {
              tailf:info "Cisco 4x40G Ethernet Expansion Module";
            }
            enum N55-M4Q {
              tailf:info "Cisco 16x10G Flexible Ethernet Expansion Europium Module";
            }
            enum N55-M8P8FP {
              tailf:info "Cisco 8 Port 1/2/4/8G FC + 8 Port 10G Ethernet Expansion Module";
            }
            enum N56-M24UP2Q {
              tailf:info "Cisco Nexus 24x10GE Eth/FC + 2x40GE QSFP expansion module";
            }
            enum N5600-12Q-FIX {
              tailf:info "Cisco Nexus 12xQSFP Fixed Ethernet Module";
            }
            enum N5600-48Q-12Q-FIX {
              tailf:info "Cisco Nexus 12xQSFP Fixed Ethernet Module";
            }
            enum N5600-M12Q {
              tailf:info "Cisco Nexus 12xQSFP Removable Ethernet Module";
            }
            enum N5696-M12Q {
              tailf:info "Cisco 48x10G 12x40G Linecard Expansion Module";
            }
            enum N5696-M4C {
              tailf:info "Cisco 4 Port 100G Module";
            }
            enum N5K-M1008 {
              tailf:info "Cisco 8 Port Fiber Channel Expansion Module 8 x SFP";
            }
            enum N5K-M1060 {
              tailf:info "Cisco 6 Port Fiber Channel Expansion Module 6 x SFP";
            }
            enum N5K-M1404 {
              tailf:info "Expansion Module 4 x 10GBase-T LAN, 4 x Fiber Channel";
            }
            enum N5K-M1600 {
              tailf:info "Cisco 6-port 10 Gigabit Ethernet SFP Module 6 x SFP";
            }
            enum N5K-N5696-M20UP {
              tailf:info "Cisco Nexus 20X10GE Eth/FC Linecard Expansion Module";
            }
            enum N6004-M12Q {
              tailf:info "Cisco 48x10G 12x40G Linecard Expansion Module";
            }
            enum N6K-C6004-M12Q {
              tailf:info "Cisco 48x10G 12x40G Linecard Expansion Module";
            }
            enum N6K-C6004X-M20UP {
              tailf:info "Cisco Nexus 20x10GE Eth/FC Linecard Expansion Module";
            }
          }
          type string;
        }
      }
    }
    list port {
      tailf:info "Configure a port";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      when "/nx:tailfned/dayzero-included" {
        tailf:dependency "/nx:tailfned/dayzero-included";
      }
      nx:dayzero-config;
      key range;
      leaf range {
        type string {
          tailf:info "<1-199>;;Enter a port range";
          pattern "[0-9]+-[0-9]+";
        }
      }
      leaf type {
        tailf:info "Configure a port type";
        type enumeration {
          enum ethernet { tailf:info "Ethernet Port"; }
          enum fc { tailf:info "FC Port"; }
        }
      }
    }

  }


  /// ========================================================================
  /// interface
  /// ========================================================================

  container interface {
    tailf:info "Configure interfaces";

    list breakout {
      tailf:info "Configuring the breakout for an interface";
      tailf:cli-suppress-mode;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-delete-when-empty;
      tailf:cli-remove-before-change;
      key "module port";
      leaf module {
        tailf:cli-expose-key-name;
        type uint8 {
          tailf:info "<n>;;High Bandwidth Module number";
        }
      }
      leaf port {
        tailf:cli-expose-key-name;
        nx:iface-breakout-port-range;
        type uint16 {
          tailf:info "<m>;;Parent(HBP / Front-panel) port to be broken out";
        }
      }
      leaf map {
        tailf:info "Breakout Map";
        type enumeration {
          enum "10g-4x" {
            tailf:info "Breaks out a 40G  high BW front panel port into four 10G ports";
          }
          enum "25g-4x" {
            tailf:info "Breaks out a 100G high BW front panel port into four 25G ports";
          }
          enum "50g-2x" {
            tailf:info "Breaks out a 100G high BW front panel port into two 50G ports";
          }
        }
      }
    }

    // interface mgmt *
    list mgmt {
      tailf:info "Management interface";
      tailf:cli-mode-name "config-if";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      key name;
      leaf name {
        type uint16 {
          tailf:info "<0-0>;;Management interface number";
          range "0";
        }
      }
      leaf shutdown {
        tailf:info "Enable/disable an interface";
        tailf:cli-full-command;
        tailf:cli-show-no;
        when "not(../shutdown-force/shutdown/force)" {
          tailf:dependency "../shutdown-force/shutdown/force";
        }
        type empty;
      }
      container shutdown-force {
        tailf:cli-drop-node-name;
        container shutdown {
          tailf:info "Enable/disable an interface";
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          leaf force {
            tailf:info "Enable/disable an interface";
            type empty;
          }
        }
      }
      uses interface-common-grouping {
        augment "ipv6" {
          uses interface-ip-flow-grouping;
        }
        augment "ip" {
          uses interface-ip-flow-grouping;
        }
      }
      uses interface-eth-and-mgmt-grouping;

      container snmp {
        tailf:info "Modify SNMP interface parameters";
        container trap {
          tailf:info "Allow a specific SNMP trap";
          leaf link-status {
            tailf:info "Allow SNMP LINKUP and LINKDOWN traps";
            tailf:cli-boolean-no;
            default true;
            type boolean;
          }
        }
      }
    }

    // interface cmp-mgmt module *
    container cmp-mgmt {
      list module {
        key id;
        leaf id {
          type uint8;
        }
        container ip {
          container address {
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            tailf:cli-compact-syntax;
            leaf ip {
              tailf:cli-drop-node-name;
              type union {
                type tailf:ipv4-address-and-prefix-length;
                type inet:ipv4-address;
              }
            }
            leaf mask {
              tailf:cli-drop-node-name;
              when "not(contains(../ip, '/'))" {
                tailf:dependency "../ip";
              }
              type inet:ipv4-address;
            }
          }
          leaf default-gateway {
            type inet:ipv4-address;
          }
        }
      }
    }

    // interface Vlan *
    list Vlan {
      tailf:info "VLAN interface";
      tailf:cli-mode-name "config-if";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-diff-dependency "../../vlan/vlan-list/id";
      tailf:cli-diff-dependency "../../feature/interface-vlan";
      when "../../feature/interface-vlan" {
        tailf:dependency "../../feature/interface-vlan";
      }
      tailf:cli-explicit-exit;
      key name;
      leaf name {
        type uint16 {
          tailf:info "<1-4094>;;VLAN interface number";
          range "1..4094";
        }
      }

      leaf shutdown {
        tailf:info "Enable/disable an interface";
        tailf:cli-full-command;
        tailf:cli-show-no;
        cli:context-value-inject "static" {
          when "/tailfned/inject-switchport-defaults='true'";
        }
        type empty;
      }
      container fabricpath {
        tailf:info "Data Center Intermediate System to Intermediate System (L2MP-IS-IS)";
        leaf domain {
          tailf:info "Fabricpath IS-IS domain";
          type string {
            tailf:info "WORD;;Process tag (Max Size 20)";
          }
        }
        container isis {
          tailf:info "Fabricpath IS-IS interface commands";
          leaf fabric-control {
            tailf:info "Set interface to fabric-control svi";
            type empty;
          }
        }
      }
      uses interface-common-grouping {
        augment "ipv6" {
          leaf forward {
            tailf:info "Enable ipv6 forwarding on interface";
            type empty;
          }
          uses interface-ip-flow-grouping;
        }
        augment "ip" {
          uses interface-ip-flow-grouping;
        }
        refine "vrf/member" {
          nx:redeploy-data "layer3";
        }
      }

      uses interface-bfd-grouping;
      uses interface-vlan-grouping;

      container private-vlan {
        tailf:cli-diff-delete-before "/nx:feature/private-vlan";
        leaf-list mapping {
          tailf:info "Set the private VLAN interface mapping";
          tailf:cli-range-list-syntax;
          type uint16 {
            tailf:info "<1-4094>;;Secondary VLAN IDs of the private VLAN interface mapping";
          }
        }
      }
    }

    // interface nve *
    list nve {
      tailf:info "NVE interface";
      tailf:cli-mode-name "config-if-nve";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-diff-delete-before "/nx:feature/nv/overlay";
      key name;
      leaf name {
        type uint16 {
          tailf:info " <1-64>;;Config allowed on  NVEs, range is 1-64";
          range "1..64";
        }
      }
      uses interface-nve-grouping;
    }

    // interface Vethernet *
    list Vethernet {
      tailf:info "Ethernet IEEE 802.3z";
      tailf:cli-mode-name "config-if";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      key name;
      leaf name {
        type string {
          tailf:info "<1-66>/<1-128>;;Slot number/Port number";
          pattern "[0-9]+.*";
        }
      }
      uses interface-switchport-grouping;
      leaf shutdown {
        tailf:info "Enable/disable an interface";
        tailf:cli-full-command;
        tailf:cli-show-no;
        type empty;
      }
      uses interface-common-grouping;
      uses interface-ethernet-grouping;

      // interface * / vmware
      container vmware {
        container dvport {
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf port {
            tailf:cli-drop-node-name;
            type uint32;
          }
          leaf dvswitch {
            type empty;
          }
          leaf uuid {
            type string;
          }
        }
        container vm {
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf mac {
            type string;
          }
        }
      }

      // interface * / dvport uuid
      container dvport {
        leaf uuid {
          type string;
        }
      }
    }

    // interface Bdi *
    list Bdi {
      tailf:info "Bdi interface";
      tailf:cli-mode-name "config-if";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-diff-dependency "../../feature/interface-vlan";
      tailf:cli-diff-dependency "../../bridge-domain";
      tailf:cli-diff-dependency "/nx:system/bridge-domain";
      when "../../feature/interface-vlan" {
        tailf:dependency "../../feature/interface-vlan";
      }
      tailf:cli-explicit-exit;
      key name;
      leaf name {
        type uint16 {
          tailf:info "<1-4094>;;Bdi interface number";
          range "1..4094";
        }
      }
      leaf shutdown {
        tailf:info "Enable/disable an interface";
        tailf:cli-full-command;
        tailf:cli-show-no;
        cli:context-value-inject "static" {
          when "/tailfned/inject-switchport-defaults='true'";
        }
        type empty;
      }
      uses interface-common-grouping {
        augment "ipv6" {
          leaf forward {
            tailf:info "Enable ipv6 forwarding on interface";
            type empty;
          }
        }
        refine "vrf/member" {
          nx:redeploy-data "layer3";
        }
      }
      uses interface-vlan-grouping;
    }

    // interface port-channel *
    list port-channel {
      tailf:info "Port Channel interface";
      tailf:cli-mode-name "config-if";
      tailf:cli-diff-dependency "/nx:interface/port-channel[not(contains(name, '.')) and contains(current()/name, '.')]";
      tailf:cli-diff-dependency "../../feature/lacp";
      tailf:callpoint init-defaults { tailf:set-hook node; }
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-explicit-exit;
      nx:delete-vlan-mappings-on-delete;
      nx:inject-all-allowed-vlans {
        when "/tailfned/inject-trunk-allowed-all-vlans";
      }
      key name;
      leaf name {
        type string {
          tailf:info "<1-4096>;;Port Channel number";
          pattern "[0-9]+(\\.[0-9]+)?";
        }
      }
      uses interface-switchport-grouping {
        refine "switchport" {
          tailf:callpoint portchannel-member-update { tailf:set-hook subtree; }
        }
      }
      leaf shutdown {
        tailf:info "Enable/disable an interface";
        tailf:cli-full-command;
        tailf:cli-show-no;
        cli:context-value-inject "static" {
          when "/tailfned/inject-switchport-defaults='true' and contains(name, '.')";
        }
        type empty;
      }
      // leaf buffer-boost {
      //   tailf:info "Enable extra buffers for this interface";
      //   type boolean;
      //   tailf:cli-boolean-no;
      //   default true;
      // }
      uses interface-common-grouping {
        augment "ipv6" {
          uses interface-ip-flow-grouping;
        }
        augment "ip" {
          uses interface-ip-flow-grouping;
        }
      }
      uses interface-ethernet-grouping;
      uses ethernet-and-port-channel-grouping;
      uses interface-eth-pc-bfd-grouping;
      uses interface-port-channel-grouping;
      uses interface-l2port-common-grouping;
    }

    // interface Ethernet *
    list Ethernet {
      tailf:info "Ethernet IEEE 802.3z";
      tailf:cli-mode-name "config-if";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-explicit-exit;
      nx:inject-all-allowed-vlans {
        when "/tailfned/inject-trunk-allowed-all-vlans";
      }
      nx:auto-reset-shutdown {
        when "/tailfned/inject-switchport-defaults='true'";
      }

      key name;
      leaf name {
        type string {
          tailf:info "<1-66>/<1-128>;;Slot number/Port number";
          pattern "([0-9])+/([0-9])+(/([0-9])+)?(\\.[0-9]+)?";
        }
      }
      uses interface-switchport-grouping {
        augment "switchport" {
          container voice {
            tailf:info "Set voice mode characterestics of the interface";
            leaf vlan {
              tailf:info "Set VLAN for VoIP traffic";
              type union {
                type uint16 {
                  tailf:info "<1-3967>;;VLAN ID of the VLAN configured for VoIP traffic";
                }
                type enumeration {
                  enum dot1p { tailf:info "Switch will send CDP packets to instruct IP phone to send voice traffic in 802.1p frames"; }
                  enum untagged { tailf:info "Switch will send CDP packets to instruct IP phone to send voice traffic untagged "; }
                }
              }
            }
          }
        }
      }
      uses interface-phys-ethernet-grouping;
      leaf shutdown {
        tailf:info "Enable/disable an interface";
        tailf:cli-full-command;
        tailf:cli-show-no;
        cli:context-value-set-default "dynamic" {
          when "/tailfned/inject-switchport-defaults='true' and not(contains(name, '.') or (enable/switchport='false'))";
          cli:arguments "/tailfned/system-default-switchport-shutdown";
        }
        cli:context-value-set-default "dynamic" {
          when "/tailfned/inject-switchport-defaults='true' and (contains(name, '.') or (enable/switchport='false'))";
          cli:arguments "/tailfned/system-default-l3-port-shutdown";
        }
        type empty;
      }
      uses interface-common-grouping {
        refine "vrf/member" {
          nx:redeploy-data "layer3";
        }
        augment "ipv6" {
          uses interface-ip-flow-grouping;
        }
        augment "ip" {
          uses interface-ip-flow-grouping;
        }
      }
      uses interface-ethernet-grouping {
        augment evpn {
          when "../enable/switchport = 'false'";
          container multihoming {
            tailf:cli-diff-dependency "/nx:evpn-flat-syntax/evpn/esi/multihoming";
            tailf:info "VxLAN evpn multihoming";
            leaf core-tracking {
              tailf:info "Core interface tracking";
              type empty;
            }
          }
        }
      }
      uses ethernet-and-port-channel-grouping;
      uses interface-eth-pc-bfd-grouping;
      uses interface-eth-and-mgmt-grouping;
      uses interface-vrrpv3-grouping;

      container l2protocol {
        tailf:info "Layer 2 Protocol";
        container tunnel {
          tailf:info "Protocol Tunneling";
          leaf cdp {
            tailf:info "Enable l2pt for CDP";
            type empty;
          }
          leaf dot1x {
            tailf:info "Enable l2pt for DOT1X";
            type empty;
          }
          leaf stp {
            tailf:info "Enable l2pt for STP";
            type empty;
          }
          leaf vtp {
            tailf:info "Enable l2pt for VTP";
            type empty;
          }
          container drop-threshold {
            tailf:info "Configure l2pt drop-threshold";
            leaf cdp {
              tailf:info "Configure l2pt drop-threshold for CDP";
              type uint16 {
                tailf:info "<1-4096>;;Packets/sec rate beyond which protocol packets will be dropped";
              }
            }
            leaf dot1x {
              tailf:info "Configure l2pt drop-threshold for DOT1X";
              type uint16 {
                tailf:info "<1-4096>;;Packets/sec rate beyond which protocol packets will be dropped";
              }
            }
            leaf stp {
              tailf:info "Configure l2pt drop-threshold for STP";
              type uint16 {
                tailf:info "<1-4096>;;Packets/sec rate beyond which protocol packets will be dropped";
              }
            }
            leaf vtp {
              tailf:info "Configure l2pt drop-threshold for VTP";
              type uint16 {
                tailf:info "<1-4096>;;Packets/sec rate beyond which protocol packets will be dropped";
              }
            }
          }
          container shutdown-threshold {
            tailf:info "Configure l2pt shut-threshold";
            leaf cdp {
              tailf:info "Configure l2pt shutdown-threshold for CDP";
              type uint16 {
                tailf:info "<1-4096>;;Packets/sec rate beyond which interface is put to err-disable";
              }
            }
            leaf dot1x {
              tailf:info "Configure l2pt shutdown-threshold for DOT1X";
              type uint16 {
                tailf:info "<1-4096>;;Packets/sec rate beyond which interface is put to err-disable";
              }
            }
            leaf stp {
              tailf:info "Configure l2pt shutdown-threshold for STP";
              type uint16 {
                tailf:info "<1-4096>;;Packets/sec rate beyond which interface is put to err-disable";
              }
            }
            leaf vtp {
              tailf:info "Configure l2pt shutdown-threshold for VTP";
              type uint16 {
                tailf:info "<1-4096>;;Packets/sec rate beyond which interface is put to err-disable";
              }
            }
          }
        }
      }

      leaf udld {
        tailf:info "UDLD protocol";
        tailf:cli-diff-dependency "../../../feature/udld";
        type enumeration {
          enum aggressive {
            tailf:info "Enable UDLD aggressive mode for interface(s)";
          }
          enum disable {
            tailf:info "Disable UDLD for fiber interface(s)";
          }
          enum enable {
            tailf:info "Enable UDLD for non-fiber interface(s)";
          }
        }
      }
      container mdix {
        tailf:info "Enable auto mdix mode";
        leaf auto {
          tailf:info "Enable auto mdix mode";
          tailf:cli-boolean-no;
          type boolean;
        }
      }
      container ptp {
        presence true;
        tailf:cli-diff-set-after "/nx:ptp/source" {
          tailf:cli-when-target-set;
        }
        tailf:cli-diff-delete-before "/nx:ptp/source" {
          tailf:cli-when-target-delete;
        }
        tailf:cli-display-separated;
        grouping val-grouping {
          leaf interval {
            tailf:cli-drop-node-name;
            tailf:cli-diff-set-after "../aes67" {
              tailf:cli-when-target-delete;
            }
            tailf:cli-diff-set-after "../smpte-2059-2" {
              tailf:cli-when-target-delete;
            }
            tailf:cli-diff-delete-before "../aes67" {
              tailf:cli-when-target-set;
            }
            tailf:cli-diff-delete-before "../smpte-2059-2" {
              tailf:cli-when-target-set;
            }
            type int8 {
              tailf:info "<N>;;Log seconds";
            }
          }
          leaf aes67 {
            tailf:info "AES67-2015";
            tailf:cli-diff-set-after "../smpte-2059-2" {
              tailf:cli-when-target-delete;
            }
            tailf:cli-diff-delete-before "../smpte-2059-2" {
              tailf:cli-when-target-set;
            }
            type int8 {
              tailf:info "<N>;;AES67-2015 log seconds";
            }
          }
          leaf smpte-2059-2 {
            tailf:info "SMPTE-2059-2";
            type int8 {
              tailf:info "<N>;;SMPTE-2059-2 log seconds";
            }
          }
        }
        container announce {
          tailf:info "Announce";
          tailf:cli-diff-delete-before "../../ptp" {
            tailf:cli-when-target-delete;
          }
          container interval {
            tailf:info "Interval";
            uses val-grouping;
          }
          container timeout {
            tailf:info "Timeout";
            uses val-grouping;
          }
        }
        container delay-request {
          tailf:info "Delay-request";
          tailf:cli-diff-delete-before "../../ptp" {
            tailf:cli-when-target-delete;
          }
          container minimum {
            tailf:info "Minimum";
            container interval {
              tailf:info "Interval";
              uses val-grouping;
            }
          }
        }
        container multicast {
          tailf:info "Multicast";
          tailf:cli-diff-delete-before "../../ptp" {
            tailf:cli-when-target-delete;
          }
          leaf master-only {
            tailf:info "Master only";
            type empty;
          }
        }
        container sync {
          tailf:info "Sync";
          tailf:cli-diff-delete-before "../../ptp" {
            tailf:cli-when-target-delete;
          }
          container interval {
            tailf:info "Interval";
            uses val-grouping;
          }
        }
        leaf vlan {
          tailf:info "Vlan";
          tailf:cli-diff-delete-before "../../ptp" {
            tailf:cli-when-target-delete;
          }
          type uint16 {
            tailf:info "<1-4094>;;Vlan";
          }
        }
      }
      container frequency {
        tailf:info "Frequency Synchronization Manager";
        container synchronization {
          tailf:info "Frequency Synchronization Manager";
          tailf:cli-diff-delete-before "/nx:feature/frequency-synchronization" {
            tailf:cli-when-target-delete;
          }
          tailf:cli-diff-set-after "/nx:feature/frequency-synchronization" {
            tailf:cli-when-target-set;
          }
          tailf:cli-add-mode;
          tailf:cli-display-separated;
          tailf:cli-recursive-delete;
          presence true;
          leaf priority {
            tailf:info "Source priority";
            default 100;
            type uint8 {
              tailf:info "<1-254>;;Priority value, 1 (highest) 100 (default) 254 (lowest)";
            }
          }
          container quality {
            tailf:info "Quality level configuration";
            container receive {
              tailf:info "Adjust the received quality level";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              tailf:cli-full-no;
              uses itu-t-grouping;
            }
            container transmit {
              tailf:info "Set the quality level to be transmitted";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              tailf:cli-full-no;
              uses itu-t-grouping;
            }
          }
          container selection {
            tailf:info "Selection configuration";
            leaf input {
              tailf:info "Enable this source for selection";
              type empty;
            }
          }
          container ssm {
            tailf:info "SSM configuration";
            leaf disable {
              tailf:info "Disable sending of SSMs";
              type empty;
            }
          }
          leaf wait-to-restore {
            tailf:info "Set the wait-to-restore time";
            default 5;
            type uint8 {
              tailf:info "<0-12>;;Value in minutes, default 5";
            }
          }
        }
      }
      container dot1x {
        tailf:info "Dot1x configuration commands";
        leaf pae {
          tailf:info "Role of 802.1x authenticating entity";
          tailf:cli-diff-delete-before "/nx:feature/dot1x";
          tailf:cli-diff-set-after "/nx:feature/dot1x";
          type enumeration {
            enum authenticator { tailf:info "Authenticator role"; }
          }
        }
        leaf host-mode {
          tailf:info "Role of 802.1x authenticating entity";
          tailf:cli-diff-delete-before "../pae";
          tailf:cli-diff-set-after "../pae";
          when "../pae" {
            tailf:dependency "../pae";
          }
          default "single-host";
          tailf:ned-default-handling report-all;
          tailf:cli-show-with-default;
          type enumeration {
            enum multi-auth { tailf:info "Multiple Authentication Mode"; }
            enum multi-host { tailf:info "Multiple Host Mode"; }
            enum single-host { tailf:info "Single Host Mode"; }
          }
        }
        container mac-auth-bypass {
          tailf:info "Configure Mac-Auth-Bypass";
          tailf:cli-diff-delete-before "../pae";
          tailf:cli-diff-set-after "../pae";
          presence true;
          leaf eap {
            tailf:info "EAP Authentication";
            type empty;
          }
        }
        leaf max-reauth-req {
          tailf:info "Maximum Re-authentication Attempts Before Failing";
          tailf:cli-diff-delete-before "../pae";
          tailf:cli-diff-set-after "../pae";
          when "../pae" {
            tailf:dependency "../pae";
          }
          default 2;
          type uint8 {
            tailf:info "<1-10>;;Number of retries ";
          }
        }
        leaf max-req {
          tailf:info "Maximum Retries to Initiate Authentication";
          tailf:cli-diff-delete-before "../pae";
          tailf:cli-diff-set-after "../pae";
          when "../pae" {
            tailf:dependency "../pae";
          }
          default 2;
          type uint8 {
            tailf:info "<1-10>;;Number of retries ";
          }
        }
        leaf port-control {
          tailf:info "Port control";
          tailf:cli-diff-delete-before "../pae";
          tailf:cli-diff-set-after "../pae";
          when "../pae" {
            tailf:dependency "../pae";
          }
          default "force-authorized";
          type enumeration {
            enum auto { tailf:info "PortState will be set to AUTO"; }
            enum force-authorized { tailf:info "PortState set to Authorized"; }
            enum force-unauthorized { tailf:info "PortState will be set to UnAuthorized"; }
          }
        }
        leaf re-authentication {
          tailf:info "Enable or Disable Reauthentication for this port";
          tailf:cli-diff-delete-before "../pae";
          tailf:cli-diff-set-after "../pae";
          when "../pae" {
            tailf:dependency "../pae";
          }
          type boolean;
          tailf:cli-boolean-no;
          default false;
        }
        container timeout {
          tailf:info "Various Timeouts";
          leaf inactivity-period {
            tailf:info "Timeout For Session Inactivity";
            tailf:cli-diff-delete-before "../../pae";
            tailf:cli-diff-set-after "../../pae";
            when "../../pae" {
              tailf:dependency "../../pae";
            }
            type uint32 {
              tailf:info "<600-2147483>;;Time interval in seconds";
            }
          }
          leaf quiet-period {
            tailf:info "Timeout For Retrying Authentication After Failed Authentication";
            tailf:cli-diff-delete-before "../../pae";
            tailf:cli-diff-set-after "../../pae";
            when "../../pae" {
              tailf:dependency "../../pae";
            }
            default 60;
            type uint16 {
              tailf:info "<1-65535>;;Time interval in seconds";
            }
          }
          leaf ratelimit-period {
            tailf:info "Rate Limit period for EAPOL-Start";
            tailf:cli-diff-delete-before "../../pae";
            tailf:cli-diff-set-after "../../pae";
            when "../../pae" {
              tailf:dependency "../../pae";
            }
            type uint16 {
              tailf:info "<1-65535;;Time interval in seconds";
            }
          }
          leaf re-authperiod {
            tailf:info "Timeout For Re-Authentication";
            tailf:cli-diff-delete-before "../../pae";
            tailf:cli-diff-set-after "../../pae";
            when "../../pae" {
              tailf:dependency "../../pae";
            }
            default 3600;
            type uint32 {
              tailf:info "<1-2147483>;;Time interval in seconds";
            }
          }
          leaf server-timeout {
            tailf:info "Timeout for Radius Retries";
            tailf:cli-diff-delete-before "../../pae";
            tailf:cli-diff-set-after "../../pae";
            when "../../pae" {
              tailf:dependency "../../pae";
            }
            default 30;
            type uint16 {
              tailf:info "<1-65535;;Time interval in seconds";
            }
          }
          leaf supp-timeout {
            tailf:info "Timeout for Supplicant retries";
            tailf:cli-diff-delete-before "../../pae";
            tailf:cli-diff-set-after "../../pae";
            when "../../pae" {
              tailf:dependency "../../pae";
            }
            default 30;
            type uint16 {
              tailf:info "<1-65535;;Time interval in seconds";
            }
          }
          leaf tx-period {
            tailf:info "Timeout For Resending Requests To Supplicant";
            tailf:cli-diff-delete-before "../../pae";
            tailf:cli-diff-set-after "../../pae";
            when "../../pae" {
              tailf:dependency "../../pae";
            }
            default 30;
            type uint16 {
              tailf:info "<1-65535;;Time interval in seconds";
            }
          }
        }
      }
      container macsec {
        tailf:info "Specify MKA keychain and MACsec policy";
        tailf:cli-diff-dependency "/nx:feature/macsec";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf keychain {
          tailf:info "Key chain";
          tailf:cli-incomplete-command;
          tailf:cli-remove-before-change;
          tailf:non-strict-leafref {
            path "/nx:key/chain/name";
          }
          type string {
            tailf:info "WORD;;Name of the keychain specified as a string (Max Size 63)";
          }
        }
        leaf policy {
          tailf:info "Policy";
          tailf:cli-remove-before-change;
          tailf:non-strict-leafref {
            path "/nx:macsec/policy/name";
          }
          type string {
            tailf:info "WORD;;Name of the policy specified as a string";
          }
        }
        leaf fallback-keychain {
          tailf:info "Fallback keychain";
          type string {
            tailf:info "WORD;;Name of fallback keychain specified as a string (Max Size 63)";
          }
        }
      }
    }

    // interface fc *
    list fc {
      tailf:info "Fiber Channel interface";
      tailf:cli-mode-name "config-if";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      key name;
      leaf name {
        type string {
          tailf:info "<slot>/<1-N>;;Slot number/Port number";
          pattern "[0-9]+/[0-9]+";
        }
      }
      uses interface-switchport2-grouping {
        augment switchport {
          leaf beacon {
            tailf:info "Disable/enable the beacon for an interface";
            tailf:cli-full-command;
            type empty;
          }
          container fcrxbbcredit {
            tailf:info "Configure receive BB_credit for the port";
            choice bbcredit-choice {
              container creds {
                tailf:cli-drop-node-name;
                leaf credit {
                  tailf:cli-drop-node-name;
                  tailf:cli-reset-container;
                  tailf:cli-full-command;
                  type uint8 {
                    tailf:info "<1-64>;;Enter receive BB_credit";
                    range "1..64";
                  }
                }
                container ecreds {
                  tailf:cli-drop-node-name;
                  tailf:cli-sequence-commands {
                    tailf:cli-reset-siblings;
                  }
                  tailf:cli-compact-syntax;
                  tailf:cli-incomplete-command;
                  presence "true";
                  leaf credit {
                    tailf:cli-drop-node-name;
                    tailf:cli-incomplete-command;
                    type uint8 {
                      tailf:info "<1-64>;;Enter receive BB_credit";
                      range "1..64";
                    }
                  }
                  leaf mode {
                    tailf:info "Configure receive BB_credit for "
                      +"specific mode";
                    type enumeration {
                      enum E {
                        tailf:info "Configure receive BB_credit"
                        +" for E or TE mode";
                      }
                    }
                  }
                }
                container fcreds {
                  tailf:cli-drop-node-name;
                  tailf:cli-sequence-commands {
                    tailf:cli-reset-siblings;
                  }
                  tailf:cli-compact-syntax;
                  presence "true";
                  tailf:cli-incomplete-command;
                  leaf credit {
                    tailf:cli-drop-node-name;
                    tailf:cli-incomplete-command;
                    type uint8 {
                      tailf:info "<1-64>;;Enter receive BB_credit";
                      range "1..64";
                    }
                  }
                  leaf mode {
                    tailf:info "Configure receive BB_credit for "
                      +"specific mode";
                    tailf:cli-value-display-template "F";
                    type enumeration {
                      // Bug in Cisco Nexus, displays
                      // Fx but does not accept Fx as input!!
                      enum "Fx" {
                        tailf:info "Configure receive BB_credit"
                          +" for F mode";
                      }
                    }
                  }
                }
              }
              leaf default {
                tailf:info "Default receive BB_credit";
                type empty;
              }
            }
          }
          container ignore {
            tailf:info "Enter parameter to be ignored";
            leaf bit-errors {
              tailf:info "Ignore bit-errors";
              type empty;
            }
          }
        }
      }

      // interface fc * / channel-group
      container channel-group {
        tailf:info "Add to/remove from a san-port-channel";
        choice channel-group-choice {
          list port {
            tailf:cli-drop-node-name;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            max-elements "1";
            key nr;
            leaf nr {
              type uint16 {
                tailf:info "<1-256>;;Specify a san-port-channel number";
                range "1..256";
              }
            }
            leaf force {
              tailf:info "Forcefully add aport";
              type empty;
            }
          }
          leaf auto {
            tailf:info "Enable Auto Creation of Port Channel";
            type empty;
          }
        }
      }

      // interface fc * / out-of-service
      container out-of-service {
        tailf:info "Put an interface out of service.";
        presence "Put an interface out of service.";
        leaf force {
          tailf:info "put an interface out of service";
          type empty;
        }
      }

      // interface fc * / link-state-trap
      leaf link-state-trap {
        tailf:info "Enable/disable link state change traps";
        tailf:cli-full-command;
        type empty;
      }

      uses interface-fc-and-san-grouping {
        refine shutdown {
          cli:context-value-inject "static" {
            when "/tailfned/inject-switchport-defaults='true' and /tailfned/system-default-fc-shutdown='true'";
          }
        }
      }
    }

    // interface vfc *
    list vfc {
      tailf:info "Virtual FC interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      key id;
      leaf id {
        type uint16 {
          tailf:info "<1-60000>;;Virtual interface ID";
        }
      }
      container bind {
        tailf:info "Bind the VFC";
        choice bind-choice {
          container interface {
            tailf:info "Bind the VFC to an interface";
            choice eth-or-po {
              leaf Ethernet {
                tailf:info "Ethernet IEEE 802.3z";
                tailf:cli-allow-join-with-value {
                  tailf:cli-display-joined;
                }
                tailf:non-strict-leafref {
                  path "/nx:interface/Ethernet/name";
                }
                type string {
                  tailf:info "<1-253>/<1-256>;;Slot/chassis number";
                }
              }
              leaf port-channel {
                tailf:info "Port Channel interface";
                tailf:cli-allow-join-with-value {
                  tailf:cli-display-joined;
                }
                tailf:non-strict-leafref {
                  path "/nx:interface/port-channel/name";
                }
                type string {
                  tailf:info "<1-4096>;;Port Channel number";
                }
              }
            }
          }
          leaf mac-address {
            tailf:info "Bind the VFC to a MAC Address";
            type mac-address-type;
          }
        }
      }
      container switchport {
        tailf:info "Configure switchport parameters";
        leaf description {
          tailf:info "Enter description of maximum 80 characters";
          tailf:cli-full-command;
          tailf:cli-multi-value;
          tailf:cli-preformatted;
          tailf:cli-no-value-on-delete;
          type string {
            tailf:info "LINE;;Description of maximum 80 characters (Max Size 80)";
          }
        }
        leaf mode {
          tailf:info "Enter the port mode";
          type enumeration {
            enum F  {
              tailf:info "F mode";
            }
            enum NP {
              tailf:info "NP mode";
            }
          }
        }
        container trunk {
          tailf:info "Configure trunking parameters on an interface";
          container allowed {
            tailf:info "Configure allowed list for interface(s)";
            leaf-list vsan {
              tailf:info "Configure allowed list for interface(s)";
              tailf:cli-range-list-syntax;
              nx:handle-allowed-vsan;
              type uint16;
            }
          }
        }
      }
      leaf shutdown {
        tailf:info "Enable/disable an interface";
        tailf:cli-full-command;
        tailf:cli-show-no;
        cli:context-value-inject "static" {
          when "/tailfned/inject-switchport-defaults='true' and /tailfned/system-default-fc-shutdown='true'";
        }
        type empty;
      }
    }

    // interface loopback *
    list loopback {
      tailf:info "loopback interface";
      tailf:cli-mode-name "config-if";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-explicit-exit;
      key name;
      leaf name {
        type uint16 {
          tailf:info "<0-1023>;;Virtual interface number";
          range "0..1023";
        }
      }
      leaf shutdown {
        tailf:info "Enable/disable an interface";
        tailf:cli-full-command;
        tailf:cli-show-no;
        type empty;
      }
      uses interface-common-grouping;
    }

    // interface control *
    list control {
      tailf:info "Control interface";
      tailf:cli-mode-name "config-if";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      key name;
      leaf name {
        type uint16 {
          tailf:info "<0-0>;;Control interface number";
          range "0";
        }
      }
      leaf shutdown {
        tailf:info "Enable/disable an interface";
        tailf:cli-full-command;
        tailf:cli-show-no;
        type empty;
      }
      uses interface-common-grouping;
    }

    // interface san-port-channel *
    list san-port-channel {
      tailf:info "SAN Port Channel interface";
      tailf:cli-mode-name "config-if";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      key name;
      leaf name {
        type uint16 {
          tailf:info "<1-256>;;Port Channel number";
          range "1..256";
        }
      }
      uses interface-switchport2-grouping;

      // interface * / channel
      container channel {
        tailf:info "Set the channel mode for the san-port-channel "
          +"interface";
        leaf mode {
          tailf:info "Set the channel mode for the san-port-channel "
            +"interface";
          type enumeration {
            enum active {
              tailf:info "Configure ACTIVE san-port-channel";
            }
          }
        }
      }

      uses interface-fc-and-san-grouping;
    }

    // interface data *
    list data {
      tailf:info "Data interface";
      tailf:cli-mode-name "config-if";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      key name;
      leaf name {
        type uint16 {
          tailf:info "<0-0>;;Data interface number";
          range "0";
        }
      }
      leaf shutdown {
        tailf:info "Enable/disable an interface";
        tailf:cli-full-command;
        tailf:cli-show-no;
        type empty;
      }
      uses interface-common-grouping;
    }

    list Tunnel {
      tailf:info "Tunnel interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-diff-dependency "../../feature/tunnel";
      tailf:cli-explicit-exit;
      key name;
      leaf name {
        type uint16 {
          tailf:info "<0-4095>;;Tunnel interface number";
          range "0..4095";
        }
      }

      leaf shutdown {
        tailf:info "Enable/disable an interface";
        tailf:cli-full-command;
        tailf:cli-show-no;
        cli:context-value-inject "static" {
          when "/tailfned/inject-switchport-defaults='true'";
        }
        type empty;
      }
      uses interface-common-grouping {
        refine "vrf/member" {
          nx:redeploy-data "layer3";
        }
        augment "ipv6" {
          uses interface-ip-flow-grouping;
        }
        augment "ip" {
          uses interface-ip-flow-grouping;
        }
      }

      container tunnel {
        tailf:info "Protocol-over-protocol tunneling";
        leaf destination {
          tailf:info "Destination of tunnel packets";
          type union {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IPv4 address (A.B.C.D)";
            }
            type string {
              tailf:info "WORD;;Host name";
            }
          }
        }
        leaf source {
          tailf:info "Source of tunnel packets";
          type union {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IPv4 address (A.B.C.D)";
            }
            type string {
              tailf:info "WORD;;Interface name";
            }
          }
        }
      }
      leaf mtu {
        tailf:info "Configure MTU";
        type uint16 {
          tailf:info "<64-9196>  Bytes";
        }
      }
      leaf bandwidth {
        tailf:info "Set bandwidth informational parameter";
        type uint32 {
          tailf:info "<1-10000000>;;Bandwidth in kilobits";
        }
      }
    }

    list Overlay {
      tailf:info "Overlay interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-diff-dependency "../../feature/otv";
      tailf:cli-explicit-exit;
      key id;
      leaf id {
        type uint16 {
          tailf:info "<0-65503>;;Overlay interface number";
        }
      }

      leaf description {
        tailf:info "Enter description of maximum 80 characters";
        tailf:cli-full-command;
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-no-value-on-delete;
        type string {
          tailf:info "LINE;;Description of maximum 80 characters (Max Size 80)";
        }
      }

      container otv {
        tailf:info "Configure OTV information";

        container adjacency-server {
          tailf:info "Indicate if the box is an Adjacency Server";
          leaf unicast-only {
            tailf:info "Unicast Only";
            type empty;
          }
        }

        container arp-nd {
          tailf:info "ARP/ND Cache command";
          leaf timeout {
            tailf:info "Timeout interval in seconds";
            default 480;
            type uint32 {
              tailf:info "<60-86400>;;ARP/ND cache timeout in seconds";
            }
          }
        }

        leaf broadcast-group {
          tailf:info "OTV Dedicated Broadcast Group";
          tailf:cli-diff-delete-before "../adjacency-server/unicast-only" {
            tailf:cli-when-target-set;
          }
          tailf:cli-diff-set-after "../adjacency-server/unicast-only" {
            tailf:cli-when-target-delete;
          }
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;OTV External Dedicated Broadcast Group Address";
          }
        }

        leaf control-group {
          tailf:info "OTV VPN Control Multicast Group";
          tailf:cli-diff-delete-before "../adjacency-server/unicast-only" {
            tailf:cli-when-target-set;
          }
          tailf:cli-diff-set-after "../adjacency-server/unicast-only" {
            tailf:cli-when-target-delete;
          }
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;OTV VPN External Multicast Group Address";
          }
        }

        leaf-list data-group {
          tailf:info "Multicast group range for data";
          tailf:cli-flat-list-syntax;
          tailf:cli-replace-all;
          tailf:cli-diff-delete-before "../adjacency-server/unicast-only" {
            tailf:cli-when-target-set;
          }
          tailf:cli-diff-set-after "../adjacency-server/unicast-only" {
            tailf:cli-when-target-delete;
          }
          type tailf:ipv4-address-and-prefix-length {
            tailf:info "A.B.C.D/LEN  List of v4 group range prefixes";
          }
        }

        leaf-list extend-vlan {
          tailf:info "Configure VLANs for overlay";
          tailf:cli-range-list-syntax;
          tailf:cli-replace-all;
          type uint16 {
            tailf:info "<1-3967>;;VLAN IDs of VLANs to be extended";
          }
        }

        // ???  internal              OTV Internal command

        container isis {
          tailf:info "IS-IS configuration commands";
          container authentication {
            tailf:info "Set hello authentication keychain";
            leaf key-chain {
              tailf:info "Set hello authentication keychain";
              type string {
                tailf:info "WORD;;Authentication keychain (Max Size 63)";
              }
            }
          }
          leaf authentication-check {
            tailf:info "Check authentication on received hellos";
            tailf:cli-boolean-no;
            default true;
            type boolean;
          }
          leaf authentication-type {
            tailf:info "Set hello authentication type";
            type enumeration {
              enum cleartext { tailf:info "Cleartext"; }
              enum md5 { tailf:info "HMAC-MD5"; }
            }
          }
          leaf csnp-interval {
            tailf:info "Set CSNP interval in seconds";
            default 10;
            type uint16 {
              tailf:info "<1-65535>;;CSNP interval value";
            }
          }
          leaf hello-interval {
            tailf:info "Set Hello interval in seconds";
            default 20;
            type uint16 {
              tailf:info "<1-65535>;;Hello interval value";
            }
          }
          leaf hello-multiplier {
            tailf:info "Set multiplier for Hello holding time";
            default 3;
            type uint16 {
              tailf:info "<3-1000>;;Hello multiplier value";
            }
          }
          leaf hello-padding {
            tailf:info "Pad IS-IS hello PDUs to full MTU";
            tailf:cli-boolean-no;
            default true;
            type boolean;
          }
          leaf lsp-interval {
            tailf:info "Set LSP transmission interval";
            default 33;
            type uint16 {
              tailf:info "<10-65535>;;LSP transmission interval (milliseconds)";
            }
          }
          leaf metric {
            tailf:info "Configure the metric for interface";
            type uint32 {
              tailf:info "<0-16777215>;;Default metric";
            }
          }
          leaf priority {
            tailf:info "Set priority for DIS election";
            default 64;
            type uint8 {
              tailf:info "<0-127>;;Priority value";
            }
          }
        }

        leaf join-interface {
          tailf:info "OTV VPN Join-Interface";
          type string {
            tailf:info "<name>;;Ethernet IEEE 802.3z or Port Channel interface";
          }
        }

        leaf suppress-arp-nd {
          tailf:info "Suppress sending ARP and neighbor discovery packets on overlay";
          tailf:cli-boolean-no;
          default true;
          type boolean;
        }

        container use-adjacency-server {
          tailf:info "Point to remote Adjacency Server address";
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-compact-syntax;
          tailf:cli-diff-delete-before "../broadcast-group" {
            tailf:cli-when-target-set;
          }
          tailf:cli-diff-set-after "../broadcast-group" {
            tailf:cli-when-target-delete;
          }
          tailf:cli-diff-delete-before "../control-group" {
            tailf:cli-when-target-set;
          }
          tailf:cli-diff-set-after "../control-group" {
            tailf:cli-when-target-delete;
          }
          tailf:cli-diff-delete-before "../data-group" {
            tailf:cli-when-target-set;
          }
          tailf:cli-diff-set-after "../data-group" {
            tailf:cli-when-target-delete;
          }
          leaf primary-address {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type union {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Remote Primary AS IPv4 address";
              }
              type inet:ipv6-address {
                tailf:info "A:B::C:D;;Remote Primary AS IPv6 address";
              }
            }
          }
          leaf secondary-address {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            tailf:cli-optional-in-sequence;
            type union {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Remote Secondary AS IPv4 address";
              }
              type inet:ipv6-address {
                tailf:info "A:B::C:D;;Remote Secondary AS IPv6 address";
              }
            }
          }
          leaf unicast-only {
            tailf:info "Unicast Only Capability";
            type empty;
          }
        }

        // TODO: Wait with this, needs extension to handle add/remove -> mapping list
        // container vlan {
        //   tailf:info "Translate VLANs for overlay";
        //   list mapping {
        //     tailf:info "Translate VLANs for overlay";
        //   }
        // }
      }

      leaf shutdown {
        tailf:info "Enable/disable an interface";
        tailf:cli-full-command;
        tailf:cli-show-no;
        type empty;
      }
    }

    list pseudowire {
      tailf:info "Pseudowire interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-diff-dependency "/nx:feature/mpls/l2vpn";
      tailf:cli-explicit-exit;
      key id;
      leaf id {
        type uint32 {
          tailf:info "<1-200000>;;Config allowed on only static PWs, range is 1-8192";
        }
      }

      leaf description {
        tailf:info "Enter description of maximum 254 characters";
        tailf:cli-full-command;
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-no-value-on-delete;
        type string {
          tailf:info "LINE;;Description of maximum 254 characters";
        }
      }

      container encapsulation {
        tailf:info "Data encapsulation method";
        container mpls {
          tailf:info "Use MPLS encapsulation";
          tailf:cli-add-mode;
          presence true;

        }
      }

      container inherit {
        tailf:info "Inherit a port-profile";
        leaf port-profile {
          tailf:info "Inherit a port-profile";
          tailf:non-strict-leafref {
            path "/nx:port-profile/profiles/id";
          }
          tailf:cli-remove-before-change;
          type string {
            tailf:info "WORD;;Enter the name of the profile (Max Size 80)";
          }
        }
      }

      leaf mtu {
        tailf:info "Configure mtu for the port";
        type uint16 {
          tailf:info "<576-9216>;;Enter MTU";
        }
      }

      container neighbor {
        tailf:info "Neighbor options";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf address {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP address of the peer PE";
          }
        }
        leaf vc-id {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-4294967295>;;Virtual Circuit ID value";
          }
        }
      }

      leaf shutdown {
        tailf:info "Enable/disable an interface";
        type empty;
      }

      container signaling {
        tailf:info "Signaling options";
        leaf protocol {
          tailf:info "Signaling protocol to use";
          default ldp;
          type enumeration {
            enum ldp { tailf:info "Use LDP signaling"; }
            enum none { tailf:info "No signaling, use manually configured pseudowires"; }
          }
        }
      }

      leaf status {
        tailf:info "Pseudowire status capabilities";
        type boolean;
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        default true;
      }

      container status-config {
        tailf:cli-drop-node-name;
        container status {
          tailf:info "Pseudowire status capabilities";
          container control-plane {
            tailf:info "Control plane status events";
            leaf route-watch {
              tailf:info "Listen on the control plane to route-watch events";
              type boolean;
              tailf:cli-boolean-no;
              default true;
            }
          }
          leaf decoupled {
            tailf:info "Reflect standby status of the attachment circuit as up on the pseudowire";
            type boolean;
            tailf:cli-boolean-no;
            default false;
          }
          container peer {
            tailf:info "Peer status configuration";
            container topology {
              tailf:info "Change status behaviour based on peer topology";
              leaf dual-homed {
                tailf:info "Our peer(s) are participating in a redundant solution with some form of redundancy protocol running between the peer routers. Only one of the"
                  + " remote peers will advertise a status of UP at a time. The other will advertise standby. Change our configuration so we can send a status of UP on "
                  + "both active and redundant pseudowires.";
                type boolean;
                tailf:cli-boolean-no;
                default false;
              }
            }
          }
          container redundancy {
            tailf:info "Xconnect redundancy configuration";
            leaf master {
              tailf:info "Put the xconnect redundancy group on this node in master mode";
              type boolean;
              tailf:cli-boolean-no;
              default false;
            }
          }
        }
      }

      container vc {
        tailf:info "Virtual Circuit options";
        leaf type {
          tailf:info "Virtual Circuit type to use";
          type enumeration {
            enum ethernet { tailf:info "Ethernet (type 5)"; }
            enum vlan { tailf:info "VLAN (type 4)"; }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// vsan
  /// ========================================================================

  container vsan {
    tailf:info "Enter the vsan configuration mode";
    container database {
      tailf:info "Enter the vsan configuration mode";
      tailf:cli-add-mode;
      list vsan {
        tailf:info "Configure VSAN information or membership";
        tailf:cli-suppress-mode;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          type uint16 {
            tailf:info "<1-4094>;;VSAN id range";
          }
        }
      }
      container vsan-name {
        tailf:cli-drop-node-name;
        list vsan {
          tailf:info "Configure VSAN information or membership";
          tailf:cli-suppress-mode;
          key name;
          leaf id {
            tailf:cli-prefix-key;
            tailf:cli-drop-node-name;
            tailf:cli-remove-before-change;
            tailf:non-strict-leafref {
              path "/nx:vsan/database/vsan/id";
            }
            nx:inject-vsan-in-db; // vsan implicitly created (workaround NSO bug, can't handle name directly in vsan list)
            mandatory true;
            type uint16 {
              tailf:info "<1-4094>;;VSAN id range";
            }
          }
          leaf name {
            tailf:info "Assign a name to vsan";
            tailf:cli-expose-key-name;
            type string {
              tailf:info "WORD;;Vsan name (Max Size 32)";
            }
          }
        }
      }
      container vsan-vfc-binding {
        tailf:cli-drop-node-name;
        list vsan {
          tailf:info "Configure VSAN information or membership";
          tailf:cli-suppress-mode;
          tailf:cli-sequence-commands;
          key vfc;
          leaf vfc {
            tailf:cli-expose-key-name;
            tailf:cli-allow-join-with-value {
              tailf:cli-display-joined;
            }
            tailf:non-strict-leafref {
              path "/nx:interface/vfc/id";
            }
            type uint16 {
              tailf:info "<1-60000>;;Virtual interface ID";
            }
          }
          leaf vsan-id {
            tailf:cli-drop-node-name;
            tailf:cli-prefix-key;
            tailf:non-strict-leafref {
              path "/nx:vsan/database/vsan/id";
            }
            mandatory true;
            type uint16 {
              tailf:info "<1-4094>;;VSAN id range";
            }
          }
          leaf interface {
            tailf:cli-prefix-key;
            mandatory true;
            type empty;
          }
        }
      }
      container vsan-fc-binding {
        tailf:cli-drop-node-name;
        list vsan {
          tailf:info "Configure VSAN information or membership";
          tailf:cli-suppress-mode;
          tailf:cli-sequence-commands;
          key fc;
          leaf fc {
            tailf:cli-expose-key-name;
            tailf:cli-allow-join-with-value {
              tailf:cli-display-joined;
            }
            tailf:non-strict-leafref {
              path "/nx:interface/fc/name";
            }
            type string {
              tailf:info "<1-2>/<1-48>;;Slot number/Port number";
            }
          }
          leaf vsan-id {
            tailf:cli-drop-node-name;
            tailf:cli-prefix-key;
            mandatory true;
            tailf:non-strict-leafref {
              path "/nx:vsan/database/vsan/id";
            }
            type uint16 {
              tailf:info "<1-4094>;;VSAN id range";
            }
          }
          leaf interface {
            tailf:cli-prefix-key;
            mandatory true;
            type empty;
          }
        }
      }
    }
  }


  /// ========================================================================
  /// device-alias
  /// ========================================================================

  container device-alias {
    tailf:info "Device-alias configuration commands";
    container database {
      tailf:info "Device-alias database configuration commands";
      tailf:cli-add-mode;
      tailf:cli-explicit-exit;
      tailf:cli-exit-command "device-alias commit";
      container device-alias {
        tailf:info "Device-alias configuration commands";
        list name {
          tailf:info "Configure a device-alias";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key alias;
          leaf alias {
            tailf:cli-incomplete-command;
            type string {
              tailf:info "WORD;;Enter the device-alias (Max Size 64)";
            }
          }
          leaf pwwn {
            tailf:info "Configure a device-alias for port WWN";
            tailf:cli-remove-before-change;
            type string {
              tailf:info "<hh:hh:hh:hh:hh:hh:hh:hh>;;Enter port WWN";
            }
          }
        }
      }
    }
    leaf mode {
      tailf:info "Configure device-alias mode";
      type enumeration {
        enum enhanced {
          tailf:info "Configure device-alias enhanced mode";
        }
      }
    }
  }


  /// ========================================================================
  /// fcdomain
  /// ========================================================================

  container fcdomain {
    tailf:info "Enter the fcdomain configuration mode";
    container fcid {
      tailf:info "Configure fcdomain persistent FCIDs";
      container database {
        tailf:info "Enter persistent FCIDs submode";
        tailf:cli-add-mode;
        list vsan {
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-compact-syntax;
          key wwn;
          leaf wwn {
            tailf:info "Specify the device WWN";
            tailf:cli-expose-key-name;
            type string {
              tailf:info "<hh:hh:hh:hh:hh:hh:hh:hh>;;Device WWN";
            }
          }
          leaf vsan-id {
            tailf:cli-drop-node-name;
            tailf:cli-prefix-key;
            tailf:non-strict-leafref {
              path "/nx:vsan/database/vsan/id";
            }
            type uint16 {
              tailf:info "<1-4093>;;VSAN id";
            }
          }
          leaf fcid {
            tailf:info "Specify persistent FCIDs";
            type string {
              tailf:info "<0x0-0xffffff>  Persistent FCIDs";
            }
          }
          leaf area {
            tailf:info "Specify a full area is requested";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          leaf dynamic {
            tailf:info "Specify a dynamic entry is requested";
            type empty;
          }
        }
      }
    }
  }


  /// ========================================================================
  /// zone
  /// ========================================================================

  container zone {
    tailf:info "Zone configuration commands";
    container smart-zoning {
      tailf:info "Configure Smart Zoning";
      container enable {
        tailf:info "Enable Smart Zoning feature";
        list vsan {
          tailf:info "Enable Smart Zoning feature on the given VSAN";
          tailf:cli-suppress-mode;
          key id;
          leaf id {
            tailf:non-strict-leafref {
              path "/nx:vsan/database/vsan/id";
            }
            type uint16 {
              tailf:info "<1-4093>;;VSAN id";
            }
          }
        }
      }
    }
    container mode {
      tailf:info "Configure zoning mode";
      container enhanced {
        tailf:info "Configure zoning mode as enhanced";
        list vsan {
          tailf:info "Configure a zone on a VSAN";
          tailf:cli-suppress-mode;
          key id;
          leaf id {
            tailf:non-strict-leafref {
              path "/nx:vsan/database/vsan/id";
            }
            type uint16 {
              tailf:info "<1-4093>;;VSAN id";
            }
          }
        }
      }
    }
    list name {
      tailf:info "Configure a zone";
      tailf:cli-diff-delete-before "../smart-zoning/enable/vsan/id" {
        tailf:cli-when-target-delete;
      }
      nx:commit-zone;
      key "name vsan";
      leaf name {
        type string {
          tailf:info "WORD;;Enter the name of zone (Max Size 64)";
        }
      }
      leaf vsan {
        tailf:info "Configure a zone on a VSAN";
        tailf:cli-expose-key-name;
        tailf:non-strict-leafref {
          path "/nx:vsan/database/vsan/id";
        }
        type uint16 {
          tailf:info "<1-4093>;;VSAN id";
        }
      }
      container member {
        tailf:info "Add a member to zone";
        list fwwn {
          tailf:info "Add Fabric Port WWN member to zone";
          tailf:cli-suppress-mode;
          key wwn;
          leaf wwn {
            type string {
              tailf:info "<hh:hh:hh:hh:hh:hh:hh:hh>;;Enter Fabric Port WWN";
            }
          }
        }
        list pwwn {
          tailf:info "Add Port WWN member to zone";
          tailf:cli-suppress-mode;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-compact-syntax;
          key wwn;
          leaf wwn {
            type string {
              tailf:info "<hh:hh:hh:hh:hh:hh:hh:hh>  Enter Port WWN";
            }
          }
          leaf type {
            tailf:cli-drop-node-name;
            type enumeration {
              enum both { tailf:info "Enter device-type as both"; }
              enum init { tailf:info "Enter device-type as initiator"; }
              enum target { tailf:info "Enter device-type as target"; }
            }
          }
        }
        list device-alias {
          tailf:info "Add device-alias member to zone";
          tailf:cli-suppress-mode;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-compact-syntax;
          key name;
          leaf name {
            tailf:non-strict-leafref {
              path "/nx:device-alias/database/device-alias/name/alias";
            }
            type string {
              tailf:info "WORD;;Enter device-alias name (Max Size 64)";
            }
          }
          leaf type {
            tailf:cli-drop-node-name;
            type enumeration {
              enum both { tailf:info "Enter device-type as both"; }
              enum init { tailf:info "Enter device-type as initiator"; }
              enum target { tailf:info "Enter device-type as target"; }
            }
          }
        }
        list fcalias {
          tailf:info "Add fcalias to zone";
          tailf:cli-suppress-mode;
          key name;
          leaf name {
            tailf:non-strict-leafref {
              path "/nx:fcalias/name";
            }
            type string {
              tailf:info "WORD;;Enter the name of fcalias (Max Size 64)";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// fcalias
  /// ========================================================================

  list fcalias {
    tailf:info "Fcalias configuration commands";
    key "name vsan";
    nx:commit-zone;
    leaf name {
      tailf:info "Configure an fcalias";
      tailf:cli-expose-key-name;
      type string {
        tailf:info "WORD;;Enter the name of fcalias (Max Size 64)";
      }
    }
    leaf vsan {
      tailf:info "Configure an fcalias on a VSAN";
      tailf:cli-expose-key-name;
      tailf:non-strict-leafref {
        path "/nx:vsan/database/vsan/id";
      }
      type uint16 {
        tailf:info "<1-4093>;;VSAN id";
      }
    }
    container member {
      tailf:info "Add a member to zone";
      list pwwn {
        tailf:info "Add Port WWN member to zone";
        tailf:cli-suppress-mode;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        key wwn;
        leaf wwn {
          type string {
            tailf:info "<hh:hh:hh:hh:hh:hh:hh:hh>  Enter Port WWN";
          }
        }
        leaf type {
          tailf:cli-drop-node-name;
          type enumeration {
            enum both { tailf:info "Enter device-type as both"; }
            enum init { tailf:info "Enter device-type as initiator"; }
            enum target { tailf:info "Enter device-type as target"; }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// zoneset
  /// ========================================================================

  container zoneset {
    tailf:info "Zoneset configuration commands";
    list name {
      tailf:info "Configure a zoneset";
      key "name vsan";
      leaf name {
        type string {
          tailf:info "WORD;;Enter the name of zoneset (Max Size 64)";
        }
      }
      nx:reactivate-zoneset;
      nx:commit-zone;
      leaf vsan {
        tailf:info "Configure a zoneset on a VSAN";
        tailf:cli-expose-key-name;
        tailf:non-strict-leafref {
          path "/nx:vsan/database/vsan/id";
        }
        type uint16 {
          tailf:info "<1-4093>;;VSAN id";
        }
      }
      list member {
        tailf:info "Add zone to zoneset";
        tailf:cli-suppress-mode;
        key name;
        leaf name {
          tailf:non-strict-leafref {
            path "/nx:zone/name/name";
          }
          type string {
            tailf:info "WORD;;Enter the name of zone (Max Size 64)";
          }
        }
      }
    }

    container activate {
      tailf:info "Activate a zoneset";
      list name {
        tailf:info "Zoneset name";
        tailf:cli-suppress-mode;
        key "name vsan";
        nx:commit-zone;
        leaf name {
          tailf:non-strict-leafref {
            path "/nx:zoneset/name/name";
          }
          type string {
            tailf:info "WORD;;Enter the name of zoneset (Max Size 64)";
          }
        }
        leaf vsan {
          tailf:info "Activate a zoneset on the specified VSAN";
          tailf:cli-expose-key-name;
          tailf:non-strict-leafref {
            path "/nx:vsan/database/vsan/id";
          }
          type uint16 {
            tailf:info "<1-4093>;;VSAN id";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// mvr-config
  /// ========================================================================
  container mvr-config {
    tailf:info "Enable IGMP MVR";
    tailf:cli-add-mode;
    presence true;
    container mvr-suppress-query {
      tailf:info "Suppress IGMP General query forwarding from vlans";
      leaf-list vlan {
        tailf:info "MVR Vlan Id or ranges";
        tailf:cli-range-list-syntax;
        tailf:cli-replace-all;
        type uint16 {
          tailf:info "<1-3967>;;VLAN ID 1-4094 or range(s): 1-5, 10 or 2-5,7-19";
        }
      }
    }
    uses mvr-cfg-grouping;
  }


  /// ========================================================================
  /// otv
  /// ========================================================================

  container otv {
    tailf:info "Configure OTV information";
    tailf:cli-diff-dependency "/nx:feature/otv";

    container site-vlan {
      tailf:info "Vlan to discover local OTV enabled devices";
      tailf:cli-add-mode;
      presence "true";
      leaf vlan {
        tailf:cli-drop-node-name;
        tailf:cli-hide-in-submode;
        type uint16 {
          tailf:info "<1-4095>;Vlan ID";
        }
      }
    }

    leaf site-identifier {
      tailf:info "Configure site identifier value";
      type union {
        type mac-address-type;
        type string {
          tailf:info "<0x1-0xffffffff>;;Site ID in hex";
          pattern "0x[0-9A-Fa-f]+";
        }
      }
    }
  }


  /// ========================================================================
  /// clock
  /// ========================================================================

  container clock {

    container protocol {
      tailf:info "Protocol";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf type {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type enumeration {
          enum none {
            tailf:info "None (clock can be set manually)";
          }
          enum ntp {
            tailf:info "Ntp";
          }
          enum ptp {
            tailf:info "Ptp";
          }
        }
      }
      leaf vdc {
        tailf:info "Vdc";
        type uint8 {
          tailf:info "<1-9>;;Vdc-id";
          range "1..9";
        }
      }
    }

    container timezone {
      tailf:info "Configure time zone";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf name {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type string {
          tailf:info "WORD;;Name of time zone, such as PST, MST, CST, EST, etc.. (Max Size 8)";
          length "1..8";
        }
      }
      leaf hours-offset {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type int8 {
          tailf:info "<-23-23>;;Hours offset from UTC";
          range "-23..23";
        }
      }
      leaf minutes-offset {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<0-59>;;Minutes offset from UTC";
          range "0..59";
        }
      }
    }

    container summer-time {
      tailf:info "Configure summer (daylight savings) time";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf tz {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "WORD;;Name of time zone in summer, such as PDT, CDT, EDT, etc.. (Max Size 8)";
          length "1..8";
        }
      }
      leaf start-week {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-5>;;Week number to start (first week=1, last week=5)";
          range "1..5";
        }
      }
      leaf start-day {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "WORD;;Weekday to start (Max Size 9)";
          length "1..9";
        }
      }
      leaf start-month {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "WORD;;Month to start (Max Size 9)";
          length "1..9";
        }
      }
      leaf start-time {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "WORD;;HH:MM Time to start (Max Size 5)";
          length "1..5";
        }
      }
      leaf end-week {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-5>;;Week number to end (first week=1, last week=5)";
          range "1..5";
        }
      }
      leaf end-day {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "WORD;;Weekday to end (Max Size 9)";
          length "1..9";
        }
      }
      leaf end-month {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "WORD;;Month to end (Max Size 9)";
          length "1..9";
        }
      }
      leaf end-time {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "WORD;;HH:MM Time to end (Max Size 5)";
          length "1..5";
        }
      }
      leaf offset {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-120>;;Offset to add in minutes";
          range "1..120";
        }
      }
    }

    container format {
      tailf:info "Display format of clock";
      container show-timezone {
        tailf:info "Display the configured timezone";
        leaf debug {
          tailf:info "Display the configured timezone in debugs";
          type empty;
        }
        leaf syslog {
          tailf:info "Display the configured timezone in syslogs";
          type empty;
        }
      }
      leaf format {
        tailf:cli-drop-node-name;
        default "24-hours";
        type enumeration {
          enum 12-hours {
            tailf:info "12 hours display";
          }
          enum 24-hours {
            tailf:info "24 hours display";
          }
        }
      }
    }

  }


  /// ========================================================================
  /// object-group
  /// ========================================================================

  container object-group {

    // object-group ip
    container ip {
      tailf:info "IP Object groups";

      // object-group ip address *
      list address {
        tailf:info "Address object group";
        tailf:cli-mode-name "config-ipaddr-ogroup";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Object-group name (Max Size 64)";
            length "1..64";
          }
        }
        // object-group ip address * / *
        list sequence {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          tailf:cli-remove-before-change;
          key id;
          leaf id {
            type uint32 {
              tailf:info "<1-2147483647>;;Sequence number";
              range "1..2147483647";
            }
          }
          choice address-choice {
            leaf host {
              tailf:info "Host address of the object-group member";
              tailf:cli-full-command;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;A.B.C.D Host address";
              }
            }
            leaf "prefix" {
              tailf:cli-drop-node-name;
              type tailf:ipv4-address-and-prefix-length {
                tailf:info "A.B.C.D/nn;;Network prefix of the object-group member";
              }
            }
            container network-and-mask {
              tailf:cli-drop-node-name;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf address {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type inet:ipv4-address {
                  tailf:info "A.B.C.D Network address of object-group member";
                }
              }
              leaf mask {
                tailf:cli-drop-node-name;
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Wildcard";
                }
              }
            }
          }
        }
      }

      // object-group ip port *
      list port {
        tailf:info "IP port object group (can be used in IPv4 "
          + "and IPv6 access-lists)";
        tailf:cli-mode-name "config-port-ogroup";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Object-group name (Max Size 64)";
            length "1..64";
          }
        }
        // object-group ip port * / *
        list sequence {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          tailf:cli-remove-before-change;
          key id;
          leaf id {
            tailf:cli-suppress-range;
            type uint32 {
              tailf:info "<1-2147483647>;;Sequence number";
              range "1..2147483647";
            }
          }
          choice port-choice {
            leaf eq {
              tailf:info "Match only packets on a given port number";
              type uint16 {
                tailf:info "<0-65535>;;Port number";
              }
            }
            leaf gt {
              tailf:info "Match only packets with a greater port number";
              type uint16 {
                tailf:info "<0-65534>;;Port number";
                range "0..65534";
              }
            }
            leaf lt {
              tailf:info "Match only packets with a lower port number";
              type uint16 {
                tailf:info "<1-65535>;;Port number";
                range "1..65535";
              }
            }
            leaf neq {
              tailf:info "Match only packets not on a given port number";
              type uint16 {
                tailf:info "<0-65535>;;Port number";
              }
            }
            container range {
              tailf:info "Match only packets in the range of port numbers";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              leaf range-begin {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type uint16 {
                  tailf:info "<0-65535>;;Range begin port number";
                }
              }
              leaf range-end {
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<0-65535>;;Range end port number";
                }
              }
            }
          }
        }
      }
    }

    // object-group ipv6
    container ipv6 {
      tailf:info "IPv6 Object groups";

      // object-group ipv6 address *
      list address {
        tailf:info "Address object group";
        tailf:cli-mode-name "config-ipv6addr-ogroup";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Object-group name (Max Size 64)";
            length "1..64";
          }
        }
        // object-group ipv6 address * / *
        list sequence {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          key id;
          leaf id {
            type uint32 {
              tailf:info "<1-2147483647>;;Sequence number";
              range "1..2147483647";
            }
          }
          choice address-choice {
            leaf host {
              tailf:info "Host address of the object-group member";
              type inet:ipv6-address {
                tailf:info "A:B::C:D;;IPv6 Host address";
              }
            }
            leaf "prefix" {
              tailf:cli-drop-node-name;
              type tailf:ipv6-address-and-prefix-length {
                tailf:info "A:B::C:D/LEN;;IPv6 Network prefix of the object-group member";
              }
            }
          }
        }
      }

    }
  }


  /// ========================================================================
  /// cli
  /// ========================================================================

  container cli {
    tailf:info "Configure CLI commands";
    list alias {
      tailf:info "Define an alias";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        tailf:cli-expose-key-name;
        type string {
          tailf:info "WORD;;Alias command (Max Size 30)";
          length "1..30";
        }
      }
      leaf line {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        type string {
          tailf:info "LINE;;Alias definition";
        }
      }
    }
  }


  /// ========================================================================
  /// line
  /// ========================================================================

  container line {
    tailf:info "Configure a terminal line";

    // line console
    container console {
      tailf:info "Primary terminal line";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-console";
      nx:reset-terminal-length {
        when "/tailfned/is-netsim='false'";
      }
      uses line-grouping;

      // line console / terminal
      container terminal {
        tailf:info "Set terminal line parameters";
        leaf length {
          tailf:info "Set length of the display terminal";
          nx:delete-with "default";
          type uint16 {
            range "0..511";
          }
          default 24;
        }
        leaf width {
          tailf:info "Set width of the display terminal";
          nx:delete-with "default";
          tailf:ned-ignore-compare-config;
          type uint16 {
            tailf:info "<24-511>;;Number of characters on a screen line";
          }
          default 80;
        }
      }
    }

    // line vty
    container vty {
      tailf:info "Virtual terminal line";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-line";
      presence "true";
      uses line-grouping;

      // NOTE: if absolute-timeout is modeled, tests NX-472-rt32439_data|legacy needs to be changed

      leaf session-limit {
        tailf:info "Set the max no of concurrent vsh sessions";
        type uint8 {
          tailf:info "<1-64>;;Max concurrent vsh sessions";
          range "1..64";
        }
      }
      leaf logout-warning {
        tailf:info "Configure logout warning";
        nx:delete-with "logout-warning 0";
        type uint8 {
          tailf:info "<0-60>;;Enter logout warning time in seconds";
        }
      }
    }

  }


  /// ========================================================================
  /// router
  /// ========================================================================

  container router {
    tailf:info "Enable a routing process";

    // router bgp *
    list bgp {
      tailf:info "Border Gateway Protocol (BGP)";
      tailf:cli-mode-name "config-router";
      tailf:cli-diff-dependency "../../feature/bgp";
      when "../../feature/bgp" {
        tailf:dependency "../../feature/bgp";
      }
      key id;
      leaf id {
        type string {
          tailf:info "Autonomous system number";
        }
      }

      container template {
        tailf:info "Enter template command mode";
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        // router bgp * / template peer *
        list peer {
          tailf:info "Template configuration for peer parameters";
          tailf:cli-explicit-exit;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Neighbor template name (Max Size 80)";
              length "1..80";
            }
          }

          // router bgp * / template peer * / X
          uses template-neighbor-common-grouping;

          // router bgp * / template peer * / remote-as
          leaf remote-as {
            tailf:info "Specify Autonomous System Number of the neighbor";
            type asn-type;
          }
        }
        // router bgp * / template peer-policy *
        list peer-policy {
          tailf:info "Template configuration for policy parameters";
          tailf:cli-mode-name "config-router-ptmp";
          tailf:cli-explicit-exit;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Name of peer-policy template (Max Size 80)";
              length "1..80";
            }
          }
          uses template-af-common-grouping;
        }
        list peer-session {
          tailf:info "Template configuration for session parameters";
          tailf:cli-mode-name "config-router-stmp";
          tailf:cli-explicit-exit;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Name of peer-session template (Max Size 80)";
              length "1..80";
            }
          }
          // router bgp * / template peer-session * / X
          uses template-base-grouping;
          choice egress-eng-choice {
            leaf egress-engineering {
              tailf:info "Configure Egress Peer Engineering (EPE) for peer";
              tailf:cli-full-command;
              //        tailf:cli-diff-set-after "../address-family";
              type empty;
            }
            container egress-engineering-peerset {
              tailf:cli-drop-node-name;
              container egress-engineering {
                tailf:info "Configure Egress Peer Engineering (EPE) for peer";
                leaf peer-set {
                  tailf:info "Configure EPE Peer-Set";
                  //            tailf:cli-diff-set-after "../../../address-family";
                  type string {
                    tailf:info "WORD;;EPE Peer-Set name (Max Size 63)";
                  }
                }
              }
            }
          }
          // router bgp * / template peer-session * / remote-as
          leaf remote-as {
            tailf:info "Specify Autonomous System Number of the neighbor";
            type asn-type;
          }
        }
      }

      uses router-bgp-grouping;

      // router bgp * / address-family link-state
      container af-linkstate {
        tailf:cli-drop-node-name;
        container address-family {
          tailf:info "Configure an address-family";
          container link-state {
            tailf:info "Configure link-state address-family";
            tailf:cli-add-mode;
            presence true;

            // router bgp * / address-family link-state / dampening
            uses router-bgp-af-dampening-grouping;

            // router bgp * / address-family link-state / nexthop
            container nexthop {
              tailf:info "Nexthop tracking";
              leaf route-map {
                tailf:info "Route map for valid nexthops";
                type string {
                  tailf:info "WORD;;Route-map name (Max Size 63)";
                }
              }
              container trigger-delay {
                tailf:info "Set the delay to trigger nexthop tracking";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                leaf critical {
                  tailf:info "Nexthop changes affecting reachability";
                  tailf:cli-incomplete-command;
                  type uint32 {
                    tailf:info "<1-4294967295>;;Delay value (miliseconds)";
                  }
                }
                leaf non-critical {
                  tailf:info "Other nexthop changes";
                  type uint32 {
                    tailf:info "<1-4294967295>;;Delay value (miliseconds)";
                  }
                }
              }
            }
          }
        }
      }

      // router bgp * / enforce-first-as
      leaf enforce-first-as {
        tailf:info "Enforce neighbor AS is the first AS in AS-PATH attribute (EBGP)";
        tailf:cli-boolean-no;
        default true;
        type boolean;
      }

      container disable-policy-batching {
        tailf:info "Disable batching evaluation of outbound policy for a peer";
        presence true;
        container ipv4 {
          tailf:info "IPv4 address-family";
          leaf prefix-list {
            tailf:info "Apply prefix-list";
            type string {
              tailf:info "WORD;;Name of prefix-list (Max Size 63)";
            }
          }
        }
        container ipv6 {
          tailf:info "IPv6 address-family";
          leaf prefix-list {
            tailf:info "Apply prefix-list";
            type string {
              tailf:info "WORD;;Name of prefix-list (Max Size 63)";
            }
          }
        }
      }

      // router bgp * / vrf *
      list vrf {
        tailf:cli-mode-name "config-router-vrf";
        tailf:cli-diff-dependency "/nx:vlan/vlan-list";
        tailf:cli-diff-dependency "/nx:vrf/context";
        key name;
        leaf name {
          type string;
        }

        uses router-bgp-grouping {
          augment "address-family/redistribute" {
            container hmm {
              tailf:info "HMM prefix";
              leaf route-map {
                tailf:info "Route-map applied to redistributed routes";
                type string {
                  tailf:info "WORD;;Route-map name (Max Size 63)";
                  length "1..63";
                }
              }
            }
          }
        }

        leaf local-as {
          tailf:info "Specify the local-as for this vrf";
          type asn-type;
        }
      }
      container event-history {
        tailf:info "Configure event-history details";
        grouping eh-size-leaf {
          leaf size {
            tailf:info "Size of buffer";
            type union {
              type uint32 {
                tailf:info "<32768-8388608>;;Buffer size in bytes";
              }
              type enumeration {
                enum large { tailf:info "Large buffer"; }
                enum medium { tailf:info "Medium buffer"; }
                enum small { tailf:info "Small buffer"; }
              }
            }
          }
        }
        container events {
          tailf:info "Events history buffer";
          nx:delete-with "event-history events";
          uses eh-size-leaf;
        }
        container errors {
          tailf:info "Errors history buffer";
          nx:delete-with "event-history errors";
          uses eh-size-leaf;
        }
        container cli {
          tailf:info "CLI event history buffer";
          nx:delete-with "event-history cli";
          uses eh-size-leaf;
        }
        container socket {
          tailf:info "Socket history buffer";
          nx:delete-with "event-history socket";
          uses eh-size-leaf;
        }
        container detail {
          tailf:info "Detailed event history buffer";
          uses eh-size-leaf;
        }
        container objstore {
          tailf:info "Objstore events history buffer";
          uses eh-size-leaf;
        }
        container periodic {
          tailf:info "Periodic events history buffer";
          uses eh-size-leaf;
        }
      }
    }

    // router ospf *
    list ospf {
      tailf:info "Open Shortest Path First (OSPF)";
      tailf:cli-mode-name "config-router";
      tailf:cli-diff-dependency "/nx:feature/ospf";
      key id;
      leaf id {
        tailf:cli-suppress-range;
        type ospf-id-type;
      }

      leaf isolate {
        tailf:info "Isolate this router from OSPF perspective";
        type empty;
      }

      container ip {
        tailf:info "IP events";
        container ospf {
          tailf:info "Debug OSPF events";
          list event-history {
            tailf:info "Log debug events into event history buffer";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key event;
            leaf event {
              type enumeration {
                enum adjacency {
                  tailf:info "Adjacency formation logs";
                }
                enum cli {
                  tailf:info "Cli logs";
                }
                enum event {
                  tailf:info "Internal event logs";
                }
                enum flooding {
                  tailf:info "LSA flooding logs";
                }
                enum ha {
                  tailf:info "HA and GR logs";
                }
                enum hello {
                  tailf:info "HELLO related logs";
                }
                enum ldp {
                  tailf:info "LDP related logs";
                }
                enum lsa {
                  tailf:info "LSA generation and databse logs";
                }
                enum objstore {
                  tailf:info "DME OBJSTORE related logs";
                }
                enum redistribution {
                  tailf:info "Redistribution logs";
                }
                enum rib {
                  tailf:info "RIB related logs";
                }
                enum segrt {
                  tailf:info "Segment Routing related logs";
                }
                enum spf {
                  tailf:info "SPF calculation logs";
                }
                enum spf-trigger {
                  tailf:info "SPF TRIGGER related logs";
                }
                enum te {
                  tailf:info "MPLS TE related logs";
                }
              }
            }
            leaf size {
              tailf:info "Configure the size of the event-hist buffer";
              type union {
                type uint16 {
                  tailf:info "<0-65535>;;Size of the file in kbytes";
                }
                type enumeration {
                  enum disabled {
                    tailf:info "Disabled";
                  }
                  enum large {
                    tailf:info "Large buffer";
                  }
                  enum medium {
                    tailf:info "Medium buffer";
                  }
                }
              }
            }
          }
        }
      }

      uses ospf-grouping;

      list vrf {
        tailf:info "Display per-VRF information";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;VRF name (Max Size 32)";
            length "1..32";
          }
        }
        container capability {
          tailf:info "Capability";
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-compact-syntax;
          leaf vrf-lite {
            tailf:info "Enable VRF-lite support";
            type empty;
          }
          leaf evpn {
            tailf:info "Ethernet VPN";
            type empty;
          }
        }
        uses ospf-grouping;

      }
    }

    // router ospfv3 *
    list ospfv3 {
      tailf:info "Open Shortest Path First (OSPF) (Version 3)";
      tailf:cli-mode-name "config-router";
      tailf:cli-diff-dependency "/nx:feature/ospfv3";
      when "../../feature/ospfv3" {
        tailf:dependency "../../feature/ospfv3";
      }
      key tag;
      leaf tag {
        type string {
          tailf:info "WORD;;Process tag";
          length "1..20";
        }
      }

      leaf isolate {
        tailf:info "Isolate this router from OSPFV3 perspective";
        type empty;
      }

      uses ospf-ospfv3-common-grouping;
      uses ospfv3-address-family-grouping;

      list vrf {
        tailf:info "Display per-VRF information";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;VRF name (Max Size 32)";
            length "1..32";
          }
        }
        uses ospf-ospfv3-common-grouping;
        uses ospfv3-address-family-grouping;
      }
    }

    // router isis *
    list isis {
      tailf:info "Intermediate System to Intermediate System (IS-IS)";
      tailf:cli-mode-name "config-router";
      tailf:cli-diff-dependency "/nx:feature/isis";
      when "../../feature/isis" {
        tailf:dependency "../../feature/isis";
      }
      key id;
      leaf id {
        type string {
          tailf:info "WORD;;Routing process tag (Max Size 20)";
          length "1..20";
        }
      }

      container mpls {
        tailf:info "IS-IS Router mode MPLS information";
        container ldp {
          tailf:info "IS-IS LDP related configuration";
          leaf autoconfig {
            tailf:info "IS-IS LDP Autoconfigure";
            type enumeration {
              enum level-1 {
                tailf:info "Runs MPLS LDP AC on IS-IS level-1 only";
              }
              enum level-1-2 {
                tailf:info "Runs MPLS LDP AC on IS-IS level-1 & level-2";
              }
              enum level-2 {
                tailf:info "Runs MPLS LDP AC on IS-IS level-2 only";
              }
            }
          }
          leaf sync {
            tailf:info "IS-IS LDP Sync";
            type empty;
          }
        }
      }

      uses isis-common-grouping;

      list vrf {
        tailf:info "Configure ISIS VRF information";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;VRF name (Max Size 32)";
            length "1..32";
          }
        }

        uses isis-common-grouping;
      }
    }

    // router eigrp *
    list eigrp {
      tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
      tailf:cli-mode-name "config-router";
      tailf:cli-diff-dependency "/nx:feature/eigrp";
      when "../../feature/eigrp" {
        tailf:dependency "../../feature/eigrp";
      }
      key id;
      leaf id {
        type string {
          tailf:info "WORD;;Process tag (Max Size 20)";
          length "1..20";
        }
      }

      uses eigrp-common-grouping;
      uses eigrp-common-af-grouping;


      list vrf {
        tailf:info "Configure VRF information";
        tailf:cli-mode-name "config-router-vrf";
        tailf:cli-explicit-exit;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;VRF name (Max Size 32)";
            length "1..32";
          }
        }

        uses eigrp-common-grouping;
        uses eigrp-common-af-grouping;
      }
    }

    // router rip *
    list rip {
      tailf:info "Routing Information Protocol (RIP)";
      tailf:cli-diff-dependency "/nx:feature/rip";
      when "../../feature/rip" {
        tailf:dependency "../../feature/rip";
      }
      key id;
      leaf id {
        type string {
          tailf:info "WORD;;Process id (Max Size 20)";
        }
      }

      leaf flush-routes {
        tailf:info "Flush routes in RIB during restart";
        type empty;
      }

      container metric {
        tailf:info "Cost of direct routes";
        leaf direct {
          tailf:info "Cost of direct routes";
          type uint8 {
            tailf:info "0;;Direct route cost is zero to be compatible with IOS";
          }
        }
      }

      uses rip-common-af-grouping;

      list vrf {
        tailf:info "Configure RIP VRF information";
        tailf:cli-mode-name "config-router-vrf";
        tailf:cli-explicit-exit;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;VRF name (Max Size 32)";
            length "1..32";
          }
        }
        uses rip-common-af-grouping;
      }

    }

  }


  /// ========================================================================
  /// poap
  /// ========================================================================

  container poap {
    tailf:info "POAP process";
    // Skip: dhcp     POAP dhcp
    leaf transit {
      tailf:info "Lldp-poap plugin to enable poap transit";
      type empty;
    }
  }


  /// ========================================================================
  /// logging
  /// ========================================================================

  container logging {
    tailf:info "Modify message logging facilities";

    container level {
      tailf:info "Facility parameter for syslog messages";

      list facilities {
        tailf:cli-suppress-mode;
        tailf:cli-drop-node-name;
        tailf:cli-delete-when-empty;
        tailf:cli-diff-dependency "/nx:feature";
        key "facility sub-function";
        leaf facility {
          type string {
            tailf:info "WORD;;Facility to set level for";
          }
          tailf:cli-disallow-value "ethpm";
        }
        leaf sub-function {
          tailf:key-default "__empty_key__";
          tailf:cli-disallow-value "[0-9]+";
          nx:trim-default-key;
          type string;
        }
        leaf level {
          tailf:cli-drop-node-name;
          type loglevel-type;
        }
      }

      container ethpm {
        tailf:info "Set level for ethpm syslog messages";
        leaf level {
          tailf:cli-drop-node-name;
          type loglevel-type;
        }
        leaf link-up {
          tailf:info "Configure logging level for link up syslog messages";
          default "notif";
          type enumeration {
            enum notif;
            enum error;
          }
        }
        leaf link-down {
          tailf:info "Configure logging level for link down syslog messages";
          default "notif";
          type enumeration {
            enum notif;
            enum error;
          }
        }
      }

    }
    // logging / server *
    list server {
      tailf:info "Enable forwarding to Remote Syslog Server";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-sequence-commands;
      tailf:cli-compact-syntax;
      key host;
      leaf host {
        type string {
          tailf:info "A:B::C:D|WORD;;Hostname/IPv4/IPv6 address of the Remote "
            +"Syslog Server";
        }
      }

      leaf level {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        default 5;
        type loglevel-type;
      }

      leaf port {
        tailf:info "Destination Port when forwarding to remote server";
        tailf:cli-optional-in-sequence;
        default 514;
        type uint16 {
          tailf:info "<1-65535>;;Range from 1 - 65535 (Default 514)";
        }
      }

      // logging / server * use-vrf
      leaf use-vrf {
        tailf:info "Display per-VRF information";
        tailf:cli-optional-in-sequence;
        default "default";
        type vrf-member-type;
      }

      leaf facility {
        tailf:info "Facility to use when forwarding to server";
        type enumeration {
          enum auth {
            tailf:info "Use auth facility";
          }
          enum authpriv {
            tailf:info "Use authpriv facility";
          }
          enum cron {
            tailf:info "Use Cron/at facility";
          }
          enum daemon {
            tailf:info "Use daemon facility";
          }
          enum ftp {
            tailf:info "Use file transfer system facility";
          }
          enum kernel {
            tailf:info "Use kernel facility";
          }
          enum local0 {
            tailf:info "Use local0 facility";
          }
          enum local1 {
            tailf:info "Use local1 facility";
          }
          enum local2 {
            tailf:info "Use local2 facility";
          }
          enum local3 {
            tailf:info "Use local3 facility";
          }
          enum local4 {
            tailf:info "Use local4 facility";
          }
          enum local5 {
            tailf:info "Use local5 facility";
          }
          enum local6 {
            tailf:info "Use local6 facility";
          }
          enum local7 {
            tailf:info "Use local7 facility";
          }
          enum lpr {
            tailf:info "Use lpr facility";
          }
          enum mail {
            tailf:info "Use mail facility";
          }
          enum news {
            tailf:info "Use USENET news facility";
          }
          enum syslog {
            tailf:info "Use syslog facility";
          }
          enum user {
            tailf:info "Use user facility";
          }
          enum uucp {
            tailf:info "Use Unix-to-Unix copy system facility";
          }
          enum kern {
            tailf:info "Use kernel facility";
          }
        }
      }
    }

    leaf source-interface {
      tailf:info "Enable Source-Interface for Remote Syslog Server";
      tailf:cli-full-command;
      nx:case-insensitive-type;
      tailf:cli-diff-delete-before "/nx:interface/loopback" {
        tailf:cli-when-target-delete;
      }
      type string {
        tailf:info "<interface-name>;;Note, this syntax assumes device echo's back what you set here, e.g. loopback1";
        pattern "(([Ee]thernet)|([Ll]oopback)|([Pp]ort-channel)|([Vv]lan)|([Bb]di)|([Mm]gmt))[0-9/\\.]+";
      }
    }

    container explicit-source-interface {
      tailf:cli-drop-node-name;
      container source-interface {
        tailf:info "Enable Source-Interface for Remote Syslog Server";
        tailf:cli-sequence-commands;
        tailf:cli-compact-syntax;
        tailf:cli-diff-delete-before "/nx:interface/loopback" {
          tailf:cli-when-target-delete;
        }
        leaf interface-type {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type enumeration {
            enum ethernet {
              tailf:info "Ethernet IEEE 802.3z";
            }
            enum loopback {
              tailf:info "Loopback interface";
            }
            enum mgmt {
              tailf:info "Management interface";
            }
            enum port-channel {
              tailf:info "Port Channel interface";
            }
            enum vlan {
              tailf:info "Vlan interface";
            }
          }
        }
        leaf interface-id {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "<interface-id>;;Interface id (i.e. number or slot/port)";
            pattern "[0-9/]+";
          }
        }
      }
    }

    leaf timestamp {
      tailf:info "Set logging timestamp granularity";
      default "seconds";
      type enumeration {
        enum microseconds {
          tailf:info "Timestamp in micro-seconds";
        }
        enum milliseconds {
          tailf:info "Timestamp in milli-seconds";
        }
        enum seconds {
          tailf:info "Timestamp in seconds (Default)";
        }
      }
    }
    leaf monitor {
      tailf:info "Set terminal line(monitor) logging level";
      tailf:cli-show-no;
      cli:context-value-inject "static" {
        cli:arguments "5";
      }
      type loglevel-type;
    }
    leaf module {
      tailf:info "Set module(linecard) logging";
      tailf:cli-show-no;
      cli:context-value-inject "static" {
        cli:arguments "5";
      }
      type loglevel-type;
    }
    leaf console {
      tailf:info "Set console logging";
      tailf:cli-show-no;
      cli:context-value-inject "static" {
        cli:arguments "2";
      }
      type loglevel-type;
    }

    // logging logfile
    container logfile {
      tailf:info "Set File logging";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      nx:show-no-disable;
      nx:delete-with "logging logfile messages 5 size 4194304";
      choice enable-or-disable-logfile-choice {
        case enable-logfile {
          leaf name {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type string {
              tailf:info "WORD;;Enter the logfile name";
            }
          }
          leaf level {
            tailf:cli-drop-node-name;
            type loglevel-type;
          }
          leaf size {
            tailf:info "Set logfile size";
            default "4194304";
            type uint32 {
              tailf:info "<4096-10485760>;;Enter the logfile size in bytes";
            }
          }
        }
        case disable-logfile {
          leaf disable {
            tailf:info "Set to disable logfile (i.e. 'no logging logfile')";
            type empty;
          }
        }
      }
    }

    container event {
      tailf:info "Interface events";
      container link-status {
        tailf:info "UPDOWN and CHANGE messages";
        leaf default {
          tailf:info "Default logging configuration used by interfaces not explicitly configured";
          tailf:cli-boolean-no;
          cli:context-value-inject "static" {
            cli:arguments "false";
            when "/tailfned/no-logging-event-link-status-default='true'";
          }
          default true;
          type boolean;
        }
        leaf enable {
          tailf:info "To enable logging overriding port level configuration";
          tailf:cli-boolean-no;
          default true;
          type boolean;
        }
      }
      container trunk-status {
        tailf:info "TRUNK status messages";
        leaf default {
          tailf:info "Default logging configuration used by interfaces not explicitly configured";
          tailf:cli-boolean-no;
          default false;
          type boolean;
        }
        leaf enable {
          tailf:info "To enable logging overriding port level configuration";
          tailf:cli-boolean-no;
          default true;
          type boolean;
        }
      }
    }

    container origin-id {
      tailf:info "Enable origin information for Remote Syslog Server";
      choice origin-choice {
        leaf hostname {
          tailf:info "Use hostname as origin-id of logging messages";
          type empty;
        }
        leaf ip {
          tailf:info "Use ip address as origin-id of logging messages";
          type string {
            tailf:info "A:B::C:D|WORD  Hostname/IPv4/IPv6 address";
          }
        }
        leaf string {
          tailf:info "Use text string as origin-id of logging messages";
          type string {
            tailf:info "WORD;;Enter string to append to the front of syslog msgs";
          }
        }
      }
    }

    // logging ip
    container ip {
      tailf:info "IP configuration";
      container access-list {
        tailf:info "Access-list";
        container include {
          tailf:info "Include additional fields in syslogs";
          leaf sgt {
            tailf:info "Include source group tag info in syslogs";
            type empty;
          }
        }
        container cache {
          tailf:info "Logging";
          leaf interval {
            tailf:info "Log-update interval (in sec)";
            default 300;
            type uint32 {
              tailf:info "<5-86400>;;Log-update interval in seconds";
            }
          }
          leaf entries {
            tailf:info "Maximum number of log entries cached in software";
            default 8000;
            type uint32 {
              tailf:info "<0-1048576>;;Number of entries";
            }
          }
          leaf threshold {
            tailf:info "Log-update threshold";
            default 0;
            type uint32 {
              tailf:info "<0-1000000>;;Log-update threshold (number of hits)";
            }
          }
        }
      }
    }

    leaf rate-limit {
      tailf:info "Enables rate limit for log messages";
      tailf:cli-boolean-no;
      default "true";
      type boolean;
    }

  }


  /// ========================================================================
  /// scheduler
  /// ========================================================================

  container scheduler {
    tailf:info "Config commands for scheduler";
    when "/nx:feature/scheduler" {
      tailf:dependency "/nx:feature/scheduler";
    }
    tailf:cli-diff-dependency "/nx:feature/scheduler";

    list job {
      tailf:info "Define a job";
      tailf:cli-explicit-exit;
      tailf:cli-exit-command "end-job";
      key name;
      leaf name {
        tailf:info "Specify a name for the job";
        tailf:cli-expose-key-name;
        type string {
          tailf:info "WORD;;Name of the job (Max Size 31)";
          length "1..31";
        }
      }
      leaf commands {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        nx:scheduler-job-commands;
        type string {
          tailf:info "command1 ;[command2 ;command3 ;...]";
        }
      }
    }

    list schedule {
      tailf:info "Define a schedule";
      nx:filter-non-config "time start [0-9:]+.*"; // filter out schedule start times

      key name;
      leaf name {
        tailf:info "Specify a name for the schedule";
        tailf:cli-expose-key-name;
        type string {
          tailf:info "WORD;;Name of the schedule (Max Size 31)";
          length "1..31";
        }
      }
      container job {
        tailf:info "Assign a job to the schedule";
        leaf name {
          tailf:info "Assign a job to the schedule";
          type string {
            tailf:info "WORD;;Name of the job (Max Size 31)";
            length "1..31";
          }
        }
      }

      container time {
        tailf:info "Specify a schedule to run jobs";
        choice sched-choice {
          leaf daily {
            tailf:info "Specify a daily schedule";
            type string {
              tailf:info "WORD;;[HH:]MM (Max Size 5)";
              length "1..5";
            }
          }
          leaf weekly {
            tailf:info "Specify a weekly schedule";
            type string {
              tailf:info "WORD;;Day-of-week {[[dow:]HH:]MM} dow = 1 (Sun) .. 7 (Sat) (Max Size 10)";
              length "1..10";
            }
          }
          leaf monthly {
            tailf:info "Specify a monthly schedule";
            type string {
              tailf:info "WORD;;Day-of-month {[[dm:]HH:]MM} dm = 1 .. 31 (Max Size 8)";
              length "1..8";
            }
          }
        }
      }
    }

  }


  /// ========================================================================
  /// role
  /// ========================================================================

  container role {
    tailf:info "Configure roles";
    // Skip: 'role abort' - (Abort uncommitted role configuration)
    // Skip: 'role commit' - (Commit role configuration to fabric)
    // Skip: 'role distribute' - (Enable fabric distribution for roles)
    // Skip: 'role feature-group' - (Configure role feature-group)

    grouping role-rule-type-choice {
      choice rule-type {
        leaf command {
          tailf:info "Command line";
          tailf:cli-multi-value;
          tailf:cli-full-command;
          tailf:cli-no-name-on-delete;
          tailf:cli-no-value-on-delete;
          type string {
            tailf:info "<LINE>;;Enter the command (use space+';' for command se"
              +"parator) e.g. config t ; role * (Max Size 128)";
          }
        }
        // role name NAME / rule * deny read
        container read {
          tailf:info "Read access";
          tailf:cli-no-name-on-delete;
          presence true;
          // role name NAME / rule * deny read feature
          leaf feature {
            tailf:info "Feature name";
            tailf:cli-no-name-on-delete;
            tailf:cli-no-value-on-delete;
            type string {
              tailf:info "<WORD>;;Enter the access entity name ";
              length "1..32";
            }
          }
          // role name NAME / rule * deny read feature-group
          leaf feature-group {
            tailf:info "Feature group name";
            tailf:cli-no-name-on-delete;
            tailf:cli-no-value-on-delete;
            type string {
              tailf:info "<WORD>;;Enter the access entity name ";
              length "1..32";
            }
          }
          // role name NAME / rule * deny read oid
          leaf oid {
            tailf:info "SNMP oid (up to 32 elements)";
            tailf:cli-no-name-on-delete;
            tailf:cli-no-value-on-delete;
            type string {
              tailf:info "<WORD>;;Enter snmp oid instance name ";
              length "1..1024";
            }
          }
        }
        // role name NAME / rule * deny read-write
        container read-write {
          tailf:info "Read and write access";
          tailf:cli-no-name-on-delete;
          presence true;
          // role name NAME / rule * deny read-write feature
          leaf feature {
            tailf:info "Feature name";
            tailf:cli-no-name-on-delete;
            tailf:cli-no-value-on-delete;
            type string {
              tailf:info "<WORD>;;Enter the access entity name ";
              length "1..32";
            }
          }
          // role name NAME / rule * deny read-write feature-group
          leaf feature-group {
            tailf:info "Feature group name";
            tailf:cli-no-name-on-delete;
            tailf:cli-no-value-on-delete;
            type string {
              tailf:info "<WORD>;;Enter the access entity name ";
              length "1..32";
            }
          }
          // role name NAME / rule * deny read-write oid
          leaf oid {
            tailf:info "SNMP oid (up to 32 elements)";
            tailf:cli-no-name-on-delete;
            tailf:cli-no-value-on-delete;
            type string {
              tailf:info "<WORD>;;Enter snmp oid instance name ";
              length "1..1024";
            }
          }
        }
      }
    }

    // role name *
    list name {
      tailf:info "Enter the role name";
      key name;
      leaf name {
        type user-role-type {
          tailf:info "<WORD>;;Enter the role name (Max Size 16)";
        }
      }

      // role name * / description
      leaf description {
        tailf:info "Add a description for the role";
        tailf:cli-full-command;
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-no-value-on-delete;
        type string {
          tailf:info "<LINE>;;Enter the description string(can include spaces)"
            +"(Max Size 128)";
          length "1..128";
        }
      }

      // role name * / rule
      list rule {
        tailf:info "Enter the rule number";
        tailf:cli-suppress-mode;
        tailf:cli-incomplete-command;
        tailf:cli-delete-when-empty;
        key id;
        // role name NAME / rule * enter-the-rule
        leaf id {
          tailf:info "Enter the rule number";
          type uint16 {
            tailf:info "1-256;;Enter the rule number";
            range "1..256";
          }
        }
        choice permit-or-deny {
          // role name NAME / rule * deny
          container deny {
            tailf:info "Deny rule";
            tailf:cli-no-name-on-delete;
            uses role-rule-type-choice;
          }
          // role name NAME / rule * permit
          container permit {
            tailf:info "Permit rule";
            tailf:cli-no-name-on-delete;
            uses role-rule-type-choice;
          }
        }
      }

      // role name * / vlan policy deny
      container vlan {
        tailf:info "Configure the vlan policy for this role";
        tailf:cli-diff-dependency "/nx:vlan/vlan-list";
        container policy {
          tailf:info "Configure the vlan policy for this role";
          container deny {
            tailf:info "Deny access to a vlan unless specifically permitted";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-role-vlan";
            presence true;

            // role name * / vlan policy deny / permit vlan *
            container permit {
              tailf:info "Permit access to vlans (applicable if vlan policy is 'deny')";
              leaf-list vlan {
                tailf:info "Enter the range of vlans accessible the role";
                tailf:cli-range-list-syntax;
                type uint16 {
                  tailf:info "<1-3967>;;Enter the vlan range";
                  range "1..3967";
                }
              }
            }
          }
        }
      }

      // role name * / interface policy deny
      container interface {
        tailf:info "Configure the interface policy for this role";
        container policy {
          tailf:info "Configure the interface policy for this role";
          container deny {
            tailf:info "Deny access to a interface unless specifically permitted";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-role-interface";
            presence true;

            // role name * / interface policy deny / permit interface *
            container permit {
              tailf:info "Permit access to interfaces (applicable if interface policy is 'deny')";
              list interface {
                tailf:info "Enter the range of interfaces accessible the role";
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                key name;
                leaf name {
                  nx:split-interface-name;
                  type string {
                    tailf:info "WORD;;interface";
                    pattern "(([Ee]thernet)|([Ll]oopback)|([Pp]ort-channel)|([Vv]lan)|([Mm]gmt)|([Nn]ull)|([Bb]di))[0-9/\\.]+";
                  }
                }
              }
            }
          }
        }
      }

      // role name * / vrf policy deny
      container vrf {
        tailf:info "Configure the vrf policy for this role";
        tailf:cli-diff-dependency "/nx:vrf/context";
        container policy {
          tailf:info "Configure the vrf policy for this role";
          container deny {
            tailf:info "Deny access to a vrf unless specifically permitted";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-role-vrf";
            presence true;

            // role name * / vrf policy deny / permit vrf *
            container permit {
              tailf:info "Permit access to vrf (applicable if vrf policy is 'deny')";
              list vrf {
                tailf:info "Enter the range of vrf accessible the role";
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                key name;
                leaf name {
                  type string {
                    tailf:info "WORD;;VRF name (Max Size 32)";
                  }
                }
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// svs-domain
  /// ========================================================================

  container svs-domain {
    tailf:info "Svs domain configuration";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-svs-domain";

    container domain {
      tailf:info "Configure domain-id";
      leaf id {
        type uint16;
      }
    }

    container control {
      tailf:info "Configure control vlan traffic";
      leaf vlan {
        type uint16;
      }
    }

    container packet {
      tailf:info "Configure packet vlan number";
      leaf vlan {
        type uint16;
      }
    }

    container svs {
      tailf:info "Configure SVS";
      container mode {
        tailf:info "Mode of interface";
        container L3 {
          leaf interface {
            tailf:info "Layer 3 interface";
            type string;
          }
        }
        container L2 {
          tailf:info "Layer 2 interface";
          presence "true";
        }
      }
    }

    leaf switch-guid {
      tailf:info "Configure switch-guid";
      type string;
    }
  }


  /// ========================================================================
  /// svs
  /// ========================================================================

  container svs {
    tailf:info "Configure SVS upgrade";

    // svs connection *
    list connection {
      tailf:cli-mode-name "config-svs-conn";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Name of the connection (Max Size 64)";
          length "1..64";
        }
      }

      // svs connection * / protocol
      leaf protocol {
        type enumeration {
          enum "vmware-vim";
        }
      }

      // svs connection * / remote ip
      container remote {
        container ip {
          tailf:cli-compact-syntax;
          leaf address {
            type inet:ipv4-address;
          }
          leaf port {
            type uint16;
          }
        }
      }

      // svs connection * / vmware dvs
      container vmware {
        container dvs {
          tailf:cli-compact-syntax;
          leaf uuid {
            nx:quoted-string;
            type string;
          }
          leaf datacenter-name {
            type string;
          }
        }
      }

      // svs connection * / max-ports
      leaf max-ports {
        type uint16;
      }

      // svs connection * / connect
      leaf connect {
        type empty;
      }
    }
  }


  /// ========================================================================
  /// vservice
  /// ========================================================================

  container vservice {
    container global {

      // vservice global type vsg
      list type {
        key id;
        leaf id {
          type enumeration {
            enum "vsg";
          }
        }

        // vservice global type vsg / tcp
        container tcp {
          container state-checks {
            tailf:cli-delete-when-empty;
            leaf invalid-ack {
              tailf:cli-boolean-no;
              tailf:cli-show-with-default;
              tailf:cli-full-command;
              type boolean;
              default "true";
            }
            leaf seq-past-window {
              tailf:cli-boolean-no;
              tailf:cli-show-with-default;
              tailf:cli-full-command;
              type boolean;
              default "true";
            }
            leaf window-variation {
              tailf:cli-boolean-no;
              tailf:cli-show-with-default;
              tailf:cli-full-command;
              type boolean;
              default "true";
            }
          }
        }

        // vservice global type vsg / bypass asa-traffic
        container bypass {
          leaf asa-traffic {
            tailf:cli-boolean-no;
            tailf:cli-show-with-default;
            tailf:cli-full-command;
            type boolean;
            default "true";
          }
        }

        // vservice global type vsg / l3-frag
        leaf l3-frag {
          tailf:cli-boolean-no;
          tailf:cli-show-with-default;
          tailf:cli-full-command;
          type boolean;
          default "true";
        }
      }
    }
  }


  /// ========================================================================
  /// vnm-policy-agent
  /// ========================================================================

  container vnm-policy-agent {
    tailf:info "Vnm-policy-agent configuration";
    tailf:cli-add-mode;

    // vnm-policy-agent / registration-ip
    leaf registration-ip {
      tailf:info "VNM Contact IP Address CLI";
      type inet:ipv4-address {
        tailf:info "A.B.C.D;;VNM Service Registry IP-Address";
      }
    }

    // vnm-policy-agent / shared-secret
    leaf shared-secret {
      tailf:info "VNM Shared secret CLI";
      type string;
    }

    // vnm-policy-agent / policy-agent-image
    leaf policy-agent-image {
      tailf:info "Policy-Agent Install CLI";
      type string;
    }

    // vnm-policy-agent / log-level
    leaf log-level {
      tailf:info "VNM PA log-level CLI";
      type string;
    }
  }


  /// ========================================================================
  /// spanning-tree
  /// ========================================================================

  container spanning-tree {
    tailf:info "Spanning Tree Subsystem";
    tailf:cli-incomplete-command;
    // spanning-tree mode mst|rapid-pvst <CR>
    leaf mode {
      tailf:info "Spanning Tree operating mode";
      tailf:cli-full-command;
      tailf:cli-trim-default;
      default "rapid-pvst";
      type enumeration {
        enum "mst" {
          tailf:info "Multiple spanning tree mode";
        }
        enum "rapid-pvst" {
          tailf:info "Per-Vlan spanning tree mode";
        }
      }
    }

    // spanning-tree mst
    container mst {
      tailf:info "Multiple spanning tree configuration";
      tailf:cli-incomplete-command;
      // spanning-tree mst forward-time <4-30> <CR>
      leaf forward-time {
        tailf:info "Set the forward delay for the spanning tree";
        type uint8 {
          tailf:info "<4-30>;;Number of seconds for the forward delay "
            +"timer";
        }
      }
      // spanning-tree mst hello-time <1-10> <CR>
      leaf hello-time {
        tailf:info "Set the hello interval for the spanning tree";
        type uint8 {
          tailf:info "<1-10>;;Number of seconds between generation of "
            +"config bpdu";
        }
      }
      // spanning-tree mst max-age <6-40> <CR>
      leaf max-age {
        tailf:info "Set the max age interval for the spanning tree";
        type uint8 {
          tailf:info "<6-40>;;Maximum number of seconds the information "
            +"in a bpdu is valid";
        }
      }
      // spanning-tree mst max-hops <1-255> <CR>
      leaf max-hops {
        tailf:info "Set the max hops value for the spanning tree";
        type uint8 {
          tailf:info "<1-255>;;Maximum number of hops a BPDU is valid";
        }
      }
      // spanning-tree mst simulate
      container simulate {
        tailf:info "Enable spanning tree simulation";
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        // spanning-tree mst simulate pvst
        container pvst {
          tailf:info "Enable PVST simulation";
          tailf:cli-incomplete-command;
          // spanning-tree mst simulate pvst global <CR>
          leaf global {
            tailf:info "Enable PVST Simulation by default on all ports";
            tailf:cli-boolean-no;
            tailf:cli-full-command;
            tailf:cli-trim-default;
            type boolean;
            default true;
          }
        }
      }
      // spanning-tree mst configuration <CR>
      container configuration {
        tailf:info "Enter MST configuration submode";
        tailf:cli-add-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-mode-name "config-mst";
        // spanning-tree mst configuration / name WORD <CR>
        leaf name {
          tailf:info "Set configuration name";
          type string {
            tailf:info "WORD;;Configuration name";
          }
        }
        // spanning-tree mst configuration / revision <0-65535> <CR>
        leaf revision {
          tailf:info "Set configuration revision number";
          type uint16 {
            tailf:info "<0-65535>;;Configuration revision number";
          }
        }
        // spanning-tree mst configuration / instance <0-4094>
        container instance {
          tailf:info "Map vlans to an MST instance";
          tailf:cli-compact-syntax;
          tailf:cli-reset-container;
          leaf id {
            tailf:info "MST instance id";
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<0-4094>;;MST instance id";
              range "0..4094";
            }
          }
          // spanning-tree mst configuration / instance <0-4094>
          //   vlan <1-4094> <CR>
          leaf-list vlan {
            tailf:info "Range of vlans to add to the instance mapping";
            tailf:cli-range-list-syntax;
            type uint16 {
              tailf:info "<1-4094>;;Vlan range ex: 1-65, 72, 200 - 300";
              range "1..4094";
            }
          }
        }
      }
      list mst-instance {
        tailf:cli-delete-when-empty;
        tailf:cli-drop-node-name;
        tailf:cli-range-list-syntax;
        tailf:cli-suppress-mode;
        key id;
        // spanning-tree mst <0-4094>
        leaf id {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<0-4094>;;MST instance range, example: 0-3,5,7-9";
            range "0..4094";
          }
        }
        // spanning-tree mst <0-4094> priority <0-61440> <CR>
        leaf priority {
          tailf:info "Set the bridge priority for the spanning tree";
          tailf:cli-full-command;
          tailf:cli-show-with-default;
          default "24576";
          type uint16 {
            tailf:info "<0-61440>;;Bridge priority in increments of 4096";
            range "0..61440" {
              tailf:step "4096";
            }
          }
        }
      }
    }

    // spanning-tree vlan
    container vlan {
      tailf:info "VLAN Switch Spanning Tree";
      nx:handle-no-list;

      // no spanning-tree vlan *
      list no-list {
        tailf:info "'no spanning-tree vlan' list entry";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-range-list-syntax;
        key id;
        leaf id {
          type uint16 {
            tailf:info "<1-4095>;;Spanning tree VLAN id";
            range "1..4095";
          }
        }
      }

      list vlan-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-range-list-syntax;
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        key id;
        leaf id {
          tailf:info "Vlan range, Example: 1,3-5,7,9-11";
          type uint16 {
            tailf:info "1-4093;;Vlan range, Example: 1,3-5,7,9-11";
            range "1..4093";
          }
        }
        // spanning-tree vlan * forward-time
        leaf forward-time {
          tailf:info "Set the forward delay for the spanning tree";
          tailf:cli-no-value-on-delete;
          type uint8 {
            tailf:info "4-30;;Number of seconds for the forward delay timer";
            range "4..30";
          }
        }
        // spanning-tree vlan * hello-time
        leaf hello-time {
          tailf:info "Set the hello interval for the spanning tree";
          nx:delete-with "default";
          default 2;
          type uint8 {
            tailf:info "1-10;;Number of seconds between generation of config bp"
              +"du";
            range "1..10";
          }
        }
        // spanning-tree vlan * max-age
        leaf max-age {
          tailf:info "Set the max age interval for the spanning tree";
          tailf:cli-no-value-on-delete;
          type uint8 {
            tailf:info "6-40;;Maximum number of seconds the information in a bp"
              +"du is valid";
            range "6..40";
          }
        }
        // spanning-tree vlan * priority
        leaf priority {
          tailf:info "Set the bridge priority for the spanning tree";
          tailf:cli-no-value-on-delete;
          type uint16 {
            tailf:info "0-61440;;Bridge priority in increments of 4096";
            range "0..61440" {
              tailf:step "4096";
            }
          }
        }
      }
    }

    // spanning-tree port type edge bpduguard default
    container port {
      tailf:info "Spanning tree port options";
      container type {
        tailf:info "Specify a port type for spanning tree protocol use";
        container edge {
          tailf:info "Consider the interface as edge port (enable portfast)";
          container bpduguard {
            tailf:info "Enable edge port (portfast) bpdu guard on this switch";
            leaf default {
              tailf:info "Enable bdpu guard by default on all edge (portfast)"
                +" ports";
              type empty;
            }
          }
          container bpdufilter {
            tailf:info "Enable edge port (portfast) bpdu filter on this switch";
            leaf default {
              tailf:info "Enable bdpu filter by default on all edge (portfast)"
                +" ports";
              type empty;
            }
          }
          leaf default {
            tailf:info "Select edge port type by default on all access ports";
            type empty;
          }
        }
        container network {
          tailf:info "Consider the interface as inter-switch link";
          leaf default {
            tailf:info "Select network port type by default on all ports";
            type empty;
          }
        }
      }
    }

    // spanning-tree pathcost
    container pathcost {
      tailf:info "Spanning tree pathcost options";
      leaf method {
        tailf:info "Method to calculate default port path cost";
        default short;
        type enumeration {
          enum long {
            tailf:info "Use 32 bit based values for default port path costs";
          }
          enum short {
            tailf:info "Use 16 bit based values for default port path costs";
          }
        }
      }
    }

    container loopguard {
      tailf:info "Spanning tree loopguard options";
      leaf default {
        tailf:info "Enable loopguard by default on all ports";
        type empty;
      }
    }

    leaf lc-issu {
      tailf:info "Configure Linecard ISSU type";
      type enumeration {
        enum auto { tailf:info "ISSU type will Auto-detected"; }
        enum disruptive { tailf:info "ISSU will be forced to be Disruptive"; }
        enum non-disruptive { tailf:info "ISSU will be forced to be Non-Disruptive"; }
      }
    }

  }


  /// ========================================================================
  /// event
  /// ========================================================================

  container event {
    tailf:info "Event Manager commands";

    container manager {
      tailf:info "Event Manager commands";

      // event manager applet *
      list applet {
        tailf:info "Create/Modify an Event Manager Policy";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of policy (cannot have underscore in first two characters) (Max Size 29)";
            length "1..29";
          }
        }

        leaf class {
          tailf:info "Specify a class for the applet";
          tailf:cli-hide-in-submode;
          default "default";
          type string {
            tailf:info "<class>;;Class [A - Z] (or default)";
          }
        }

        // event manager applet * / description
        leaf description {
          tailf:info "Configure description for the policy";
          tailf:cli-no-value-on-delete;
          tailf:cli-full-command;
          tailf:cli-multi-value;
          tailf:cli-preformatted;
          nx:dequote-input; // Needed because java-code quotes all description leaves
          nx:quoted-string;
          type string {
            tailf:info "\"WORD\";;Description for the policy (Max Size 80)";
            length "1..80";
          }
        }

        // event manager applet * / event
        container event {
          tailf:info "Configure an event specification";
          choice event-type-choice {

            // event manager applet * / event syslog pattern
            container syslog {
              tailf:info "Create a syslog event specification";
              leaf pattern {
                tailf:info "Enter regex to be used for matching";
                tailf:cli-diff-delete-before "../tag";
                nx:quoted-string;
                type string {
                  tailf:info "\"WORD\";;SYSLOG regex (Max Size 256)";
                  length "1..256";
                }
              }
              list tag {
                tailf:cli-diff-delete-before "../pattern";
                tailf:cli-suppress-mode;
                tailf:cli-compact-syntax;
                tailf:cli-delete-when-empty;
                tailf:cli-incomplete-command;
                key name;
                leaf name {
                  type string {
                    tailf:info "WORD;;Tag name (Max Size 29)";
                  }
                }
                leaf pattern {
                  tailf:info "Enter regex to be used for matching";
                  nx:quoted-string;
                  type string {
                    tailf:info "\"WORD\";;SYSLOG regex (Max Size 256)";
                    length "1..256";
                  }
                }
              }
            }

            // event manager applet * / event snmp
            container snmp {
              tailf:info "Create a 'snmp' event specification.";
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              tailf:cli-compact-syntax;
              leaf oid {
                tailf:info "WORD;;Oid of data element in dot notation.";
                tailf:cli-incomplete-command;
                type string;
              }
              leaf get-type {
                tailf:cli-incomplete-command;
                type enumeration {
                  enum "exact";
                  enum "next";
                }
              }
              leaf entry-op {
                tailf:cli-incomplete-command;
                type comparison-type;
              }
              leaf entry-val {
                tailf:cli-incomplete-command;
                type uint64  {
                  tailf:info "<0-18446744073709551615>;;Value to compare with the current polled value";
                  range "0..18446744073709551615";
                }
              }
              // Not impl: exit-comb      Exit criterion combination
              leaf exit-op {
                tailf:info "Exit comparison operator.";
                tailf:cli-incomplete-command;
                tailf:cli-optional-in-sequence;
                type comparison-type;
              }
              leaf exit-val {
                tailf:cli-incomplete-command;
                when "../exit-op";
                type uint64  {
                  tailf:info "<0-18446744073709551615>;;Value to compare with the current polled value";
                  range "0..18446744073709551615";
                }
              }
              leaf poll-interval {
                tailf:info "Polling interval";
                tailf:cli-full-command;
                type uint32 {
                  range "1..2147483647";
                }
              }
            }

            // event manager applet * / event track
            container track {
              tailf:info "Create a 'track' event specification";
              tailf:cli-sequence-commands;
              tailf:cli-compact-syntax;
              leaf tag {
                tailf:info "Event tag identifier";
                tailf:cli-optional-in-sequence;
                type string {
                  tailf:info "WORD;;Tag name";
                }
              }
              leaf track-objects {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type uint16 {
                  tailf:info "<1-500>;;Track objects";
                  range "1..500";
                }
              }

              leaf state {
                tailf:info "State of tracking object";
                type enumeration {
                  enum any {
                    tailf:info "Any state";
                  }
                  enum down {
                    tailf:info "Down state";
                  }
                  enum up {
                    tailf:info "Up state";
                  }
                }
              }
            }

            // event manager applet * / event module
            container module {
              tailf:info "Create a 'module' event specification";
              tailf:cli-sequence-commands;
              tailf:cli-compact-syntax;
              leaf tag {
                tailf:info "Event tag identifier";
                tailf:cli-optional-in-sequence;
                type string {
                  tailf:info "WORD;;Tag name";
                }
              }

              leaf status {
                tailf:info "Status event";
                tailf:cli-incomplete-command;
                type enumeration {
                  enum any {
                    tailf:info "Online or offline status";
                  }
                  enum offline {
                    tailf:info "Offline status";
                  }
                  enum online {
                    tailf:info "Online status";
                  }
                }
              }

              leaf module {
                tailf:info "Enter a module number";
                type union {
                  type uint8 {
                    tailf:info "<1-4>;;Enter module number";
                    range "1..4";
                  }
                  type enumeration {
                    enum all {
                      tailf:info "All modules";
                    }
                  }
                }
              }
            }

            container timer {
              tailf:info "Create a timer event specification";
              tailf:cli-diff-dependency "/nx:feature/evmed";
              choice timer-choice {
                container absolute {
                  tailf:info "Absolute timer event.";
                  leaf time {
                    tailf:info "Epoch time for absolute. Try epochconverter online tool to get value";
                    type string {
                      tailf:info "WORD;;<1-1924991999[.0-999]> Enter seconds[.milliseconds] value (Max Size 20)";
                      pattern "[0-9\\.]+";
                    }
                  }
                }
                container countdown {
                  tailf:info "Countdown timer event";
                  leaf time {
                    tailf:info "Time period for countdown";
                    type string {
                      tailf:info "WORD;;<1-1924991999[.0-999]> Enter seconds[.milliseconds] value (Max Size 20)";
                      pattern "[0-9\\.]+";
                    }
                  }
                }
                container cron {
                  tailf:info "Cron timer event";
                  leaf cron-entry {
                    tailf:info "Cron entry string";
                    nx:quoted-string;
                    type string {
                      tailf:info "\"WORD\"  Format: * * * * * => min hour dom month dow (Max Size 100)";
                    }
                  }
                }
                container watchdog {
                  tailf:info "Watchdog timer event";
                  leaf time {
                    tailf:info "Time period for watchdog";
                    type string {
                      tailf:info "WORD;;<1-1924991999[.0-999]> Enter seconds[.milliseconds] value (Max Size 20)";
                      pattern "[0-9\\.]+";
                    }
                  }
                }
              }
            }
          }
        }

        // event manager applet * / action
        list action {
          tailf:info "Configure the actions to be executed";
          tailf:cli-suppress-mode;
          key label;
          leaf label {
            type string {
              tailf:info "WORD;;Label (Max Size 18)";
              length "1..18";
            }
          }

          leaf actions {
            tailf:cli-drop-node-name;
            tailf:cli-full-command;
            tailf:cli-multi-value;
            tailf:cli-preformatted;
            type string;
          }
        }

        leaf maxrun {
          tailf:info "Maximum runtime of applet";
          nx:delete-with "default";
          default 20;
          type uint32 {
            tailf:info "<0-2147483647>;;Enter seconds value";
          }
        }

        container tag {
          tailf:info "Event tag identifier";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-diff-delete-before "../event/syslog/tag" {
            tailf:cli-when-target-delete;
          }
          leaf tag-name {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type string {
              tailf:info "WORD;;Tag name (Max Size 29)";
            }
          }
          leaf combined-2 {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type enumeration {
              enum and {
                tailf:info "Use boolean and logic";
              }
              enum andnot {
                tailf:info "Use boolean andnot logic";
              }
              enum or {
                tailf:info "Use boolean or logic";
              }
            }
          }
          leaf tag-name-2 {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type string {
              tailf:info "WORD;;Tag name (Max Size 29)";
            }
          }
          leaf combined-3 {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            tailf:cli-incomplete-command;
            type enumeration {
              enum and {
                tailf:info "Use boolean and logic";
              }
              enum andnot {
                tailf:info "Use boolean andnot logic";
              }
              enum or {
                tailf:info "Use boolean or logic";
              }
            }
          }
          leaf tag-name-3 {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            when "../combined-3";
            type string {
              tailf:info "WORD;;Tag name (Max Size 29)";
            }
          }
          leaf combined-4 {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            tailf:cli-incomplete-command;
            type enumeration {
              enum and {
                tailf:info "Use boolean and logic";
              }
              enum andnot {
                tailf:info "Use boolean andnot logic";
              }
              enum or {
                tailf:info "Use boolean or logic";
              }
            }
          }
          leaf tag-name-4 {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            when "../combined-4";
            type string {
              tailf:info "WORD;;Tag name (Max Size 29)";
            }
          }
          leaf happens {
            tailf:info "The number of occurrences before raising the event";
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<1-4294967295>;;Occurs value";
            }
          }
          leaf in {
            tailf:info "Number of occurrences must occur within this time period";
            type uint32 {
              tailf:info "<0-4294967295>;;Enter seconds value";
            }
          }
        }
      }

      // event manager scheduler
      container scheduler {
        tailf:info "Set Event Manager scheduler options";
        container applet {
          tailf:info "Embedded Event Manager applet scheduling";
          container thread {
            tailf:info "Event Manager thread scheduling";
            list class {
              tailf:info "Set thread scheduling attributes";
              tailf:cli-suppress-mode;
              tailf:cli-compact-syntax;
              tailf:cli-delete-when-empty;
              tailf:cli-incomplete-command;
              key value;
              leaf value {
                type string {
                  tailf:info "WORD;;Enter the class[A-Z] value (or 'default')";
                }
              }
              leaf number {
                tailf:info "Number of concurrent execution threads";
                type uint16 {
                  tailf:info "<1-65535>;;Thread number value";
                }
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// monitor
  /// ========================================================================

  container monitor {
    list session {
      tailf:info "Configure session preferences";
      key id;
      leaf id {
        tailf:info "<1-48>;;Id";
        type uint8;
      }

      leaf type {
        tailf:cli-hide-in-submode;
        tailf:info "Specify a session type";
        default "local";
        type enumeration {
          enum erspan-destination {
            tailf:info "Create an erspan destination session";
          }
          enum erspan-source {
            tailf:info "Create an erspan source session";
          }
          enum local {
            tailf:info "Create a local session";
          }
          enum acl-capture {
            tailf:info "Create a acl-capture session";
          }
        }
      }

      leaf direction {
        tailf:cli-hide-in-submode;
        tailf:cli-drop-node-name;
        type enumeration {
          enum rx {
            tailf:info "Unidirectional ingress session";
          }
          enum tx {
            tailf:info "Unidirectional egress session";
          }
        }
      }

      leaf description {
        tailf:cli-full-command;
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-no-value-on-delete;
        type string {
          tailf:info "LINE;;Enter the description string(can include spaces)";
        }
      }

      leaf header-type {
        tailf:info "Set ERSPAN Source version";
        type uint8 {
          tailf:info "<n>;;ERSPAN Source Version 3";
        }
      }

      leaf mtu {
        tailf:info "Set the MTU size for SPAN packets";
        type uint16 {
          tailf:info "<64-9216>;;Enter the value of MTU truncation size for SPAN packets";
        }
      }

      leaf rate-limit {
        tailf:info "Set the Rate limit for SPAN packets";
        type union {
          type uint8 {
            tailf:info "<1-100>;;Enter the percentage of the maximum rate for SPAN packets";
            range "1..100";
          }
          type enumeration {
            enum auto {
              tailf:info "Set the Rate limit using auto value";
            }
          }
        }
      }

      leaf sampling {
        tailf:info "Set the sampling range for SPAN packets";
        type uint16 {
          tailf:info "<2-1023>;;Sampling range: N = every Nth packet will be spanned";
        }
      }

      // monitor session * / source
      container source {
        tailf:info "Source configuration";
        list interface {
          tailf:info "Configure interfaces";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type string;
          }
          leaf direction {
            tailf:cli-drop-node-name;
            tailf:cli-remove-before-change;
            type enumeration {
              enum both {
                tailf:info "Both";
              }
              enum rx {
                tailf:info "Ingress";
              }
              enum tx {
                tailf:info "Egress";
              }
            }
          }
        }

        list vlan {
          tailf:info "Vlan type";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-range-list-syntax;
          key id;
          leaf id {
            type uint16 {
              tailf:info "1-4093;;Vlan range, Example: 1,3-5,7,9-11";
            }
          }
          leaf direction {
            tailf:cli-drop-node-name;
            tailf:cli-remove-before-change;
            type enumeration {
              enum both {
                tailf:info "Both";
              }
              enum rx {
                tailf:info "Ingress";
              }
              enum tx {
                tailf:info "Egress";
              }
            }
          }
        }
        leaf ip {
          tailf:info "Configure source IP address";
          type inet:ipv4-address;
        }

        container exception {
          tailf:info "Configure exception sources";
          nx:macro-expand "all-exceptions";
          leaf fabricpath {
            type empty;
          }
          leaf layer3 {
            type empty;
          }
          leaf other {
            type empty;
          }
        }
      }

      container destination {
        tailf:info "Destination configuration";
        list interface {
          tailf:info "Configure interfaces";
          tailf:cli-suppress-mode;
          key name;
          leaf name {
            type string;
          }
          leaf primary {
            tailf:info "Designated destination port for Fx module span traffic";
            type empty;
          }
        }
        leaf ip {
          tailf:info "Configure remote IP address";
          type inet:ipv4-address;
        }
      }

      leaf shut {
        tailf:info "Shut a monitor session";
        tailf:cli-boolean-no;
        default true;
        type boolean;
      }

      // monitor session * / filter
      container filter {
        tailf:info "Filter configuration";

        container access-group {
          tailf:info "Access control group";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf name {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;Access control list name";
            }
          }
          leaf allow-sharing {
            tailf:info "Allow up to 4 access control groups on same source interface";
            type empty;
          }
        }

        leaf bpdu {
          tailf:info "Configure to filter BPDU class of packets Ex: lacp, udld, stp";
          type boolean;
        }

        leaf cos {
          tailf:info "Configure to filter based on COS in dot1q header";
          type uint8 {
            tailf:info "<0-7>;;Set cos value";
          }
        }

        container dest-mac {
          tailf:info "Destination MAC address EEEE.EEEE.EEEE";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf address {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type string {
              tailf:info "EEEE.EEEE.EEEE;;Destination MAC address (Option 4)";
              pattern "[a-f0-9]+\\.[a-f0-9]+\\.[a-f0-9]+";
            }
          }
          leaf mask {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "EEEE.EEEE.EEEE;;Destination MAC mask (Option 4)";
              pattern "[a-f0-9]+\\.[a-f0-9]+\\.[a-f0-9]+";
            }
          }
        }

        container src-mac {
          tailf:info "Source MAC address EEEE.EEEE.EEEE";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf address {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type string {
              tailf:info "EEEE.EEEE.EEEE;;Source MAC address (Option 4)";
              pattern "[a-f0-9]+\\.[a-f0-9]+\\.[a-f0-9]+";
            }
          }
          leaf mask {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "EEEE.EEEE.EEEE;;Source MAC mask (Option 4)";
              pattern "[a-f0-9]+\\.[a-f0-9]+\\.[a-f0-9]+";
            }
          }
        }

        leaf eth-type {
          tailf:info "Configure to filter Ethernet type";
          type string {
            tailf:info "<0x0-0xffff>;;Set Ether-type";
            pattern "0x[0-9a-f]+";
          }
        }

        leaf-list vlan {
          tailf:cli-range-list-syntax;
          type uint16;
        }

        container frame-type {
          tailf:info "Configure Frame type";
          grouping ip-type-grouping {
            leaf l4-protocol {
              tailf:info "Layer 4 protocol number set in protocol field of IPv6 header like IGMP and so on";
              cli:parse-match-prefix; // Quirk for arbitrary(?) syntax-shortening
              type union {
                type uint8 {
                  tailf:info "<0-255>;;Set L4 protocol value";
                }
                type enumeration {
                  enum egp {
                    tailf:info "Set egp";
                  }
                  enum gre {
                    tailf:info "Set gre";
                  }
                  enum icmp {
                    tailf:info "Set icmp";
                  }
                  enum igmp {
                    tailf:info "Set igmp";
                  }
                  enum igp {
                    tailf:info "Set igp";
                  }
                  enum ospf {
                    tailf:info "Set ospf";
                  }
                  enum rsvp {
                    tailf:info "Set rsvp prot";
                  }
                  enum tcp {
                    tailf:info "Set tcp";
                  }
                  enum udp {
                    tailf:info "Set udp";
                  }
                  enum ipv6-icmp {
                    tailf:info "Set IPv6 icmp";
                  }
                  enum ipv6-route {
                    tailf:info "Set IPv6-route";
                  }
                  enum no-nxt {
                    tailf:info "Set IPv6 no-next";
                  }
                  enum shim6 {
                    tailf:info "Set shim6";
                  }
                }
              }
            }
            leaf tos {
              tailf:info "Configure to filter based on TOS in ip header";
              type uint8 {
                tailf:info "<0-255>;;Set tos value";
              }
            }
          }
          choice type-choice {
            container arp {
              tailf:info "Configure ARP/RARP frame type";
              presence true;
              tailf:cli-display-separated;
              leaf arp-rarp {
                tailf:info "Choose between ARP or RARP";
                type enumeration {
                  enum arp {
                    tailf:info "Set ARP";
                  }
                  enum rarp {
                    tailf:info "Set RARP";
                  }
                }
              }
              leaf sender-ip {
                tailf:info "Configure ARP/RARP sender ip";
                type tailf:ipv4-address-and-prefix-length {
                  tailf:info "A.B.C.D/LEN;;Set ip & subnet";
                }
              }
              leaf target-ip {
                tailf:info "Configure ARP/RARP target ip";
                type tailf:ipv4-address-and-prefix-length {
                  tailf:info "A.B.C.D/LEN;;Set ip & subnet";
                }
              }
            }
            container eth {
              tailf:info "Configure ETH frame type";
              presence true;
            }
            container fcoe {
              tailf:info "Configure FCOE frame type";
              presence true;
              // TODO
            }
            container ipv4 {
              tailf:info "Configure IPV4 frame type";
              presence true;
              tailf:cli-display-separated;
              leaf dest-ip {
                tailf:info "Configure IPV4 destination ip address";
                type tailf:ipv4-address-and-prefix-length {
                  tailf:info "A.B.C.D/LEN;;Set ip & subnet";
                }
              }
              leaf src-ip {
                tailf:info "Configure IPV4 source ip address";
                type tailf:ipv4-address-and-prefix-length {
                  tailf:info "A.B.C.D/LEN;;Set ip & subnet";
                }
              }
              uses ip-type-grouping;
            }
            container ipv6 {
              tailf:info "Configure IPv6 frame type";
              presence true;
              tailf:cli-display-separated;
              leaf dest-ip {
                tailf:info "Configure IPv6 destination ip address";
                type tailf:ipv6-address-and-prefix-length {
                  tailf:info "A:B::C:D/LEN;;A:B::C:D/Len";
                }
              }
              leaf src-ip {
                tailf:info "Configure IPv6 source ip address";
                type tailf:ipv6-address-and-prefix-length {
                  tailf:info "A:B::C:D/LEN;;A:B::C:D/Len";
                }
              }
              uses ip-type-grouping;
            }
          }
        }
      }

      leaf erspan-id {
        tailf:info "Erspan ID for ERSPAN sessions";
        type uint16 {
          tailf:info "<1-1023>;;Erspan-id";
          range "1..1023";
        }
      }

      leaf vrf {
        tailf:info "Set vrf membership";
        type string {
          tailf:info "WORD;;VRF name (Max Size 32)";
          length "1..32";
        }
      }

      container ip {
        tailf:info "Set ERSPAN IP options";
        leaf dscp {
          tailf:info "Set the IP DSCP value";
          type uint8 {
            tailf:info "<0-63>;;Value";
            range "0..63";
          }
        }
        leaf ttl {
          tailf:info "Set the IP time-to-live value";
          type uint8 {
            tailf:info "<1-255>;;Value";
            range "1..255";
          }
        }
      }

      // monitor session * / marker-packet
      leaf marker-packet {
        tailf:info "Enable/Disable send marker packet";
        type uint16 {
          tailf:info "<100-1000>;;Range between <100-1000> ms default 100 ms";
        }
      }

    }

    container erspan {
      tailf:info "Configure Ethernet ERSPAN sessions";
      container origin {
        tailf:info "Configure the erspan origin ip address";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf ip-address {
          tailf:info "Configure global origin IP address";
          type union {
            type inet:ipv4-address;
            type inet:ipv6-address;
          }
        }
        leaf global {
          tailf:info "Configure in default VDC across all VDCs";
          type empty;
        }
      }
    }
  }


  /// ========================================================================
  /// itd
  /// ========================================================================
  container itd {
    tailf:info "ITD service";
    when "../feature/itd" {
      tailf:dependency "../feature/itd";
    }
    tailf:cli-diff-dependency "../feature/itd" {
      tailf:cli-trigger-on-delete;
    }

    // itd device-group *
    list device-group {
      tailf:info "ITD device group";
      tailf:cli-full-command;
      key group-name;
      leaf group-name {
        tailf:info "WORD;;Service-name (Max Size 32)";
        type word32;
      }

      grouping probe-grouping {
        container probe {
          tailf:info "ITD probe";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf protocol {
            tailf:cli-drop-node-name;
            type enumeration {
              enum dns {
                tailf:info "Dns probe";
              }
              enum icmp {
                tailf:info "Icmp-echo probe";
              }
              enum tcp {
                tailf:info "Tcp-connect probe";
              }
              enum udp {
                tailf:info "Udp-echo probe";
              }
            }
          }
          leaf host {
            tailf:info "Host name/Target address";
            when "../protocol = 'dns'" {
              tailf:dependency "../protocol";
            }
            type string {
              tailf:info "WORD;;DNS Target IP Address or Hostname (Max Size 99)";
            }
          }
          leaf port {
            tailf:info "Port";
            when "../protocol = 'udp' or ../protocol = 'tcp'" {
              tailf:dependency "../protocol";
            }
            type uint16 {
              tailf:info "<1-65535>;;Port number";
            }
          }
          leaf frequency {
            tailf:info "Frequency";
            tailf:cli-optional-in-sequence;
            type uint32 {
              tailf:info "<1-604800>;;Frequency";
              range "1..604800";
            }
          }
          leaf timeout {
            tailf:info "Timeout";
            tailf:cli-optional-in-sequence;
            type uint32 {
              tailf:info "<0-604800>;;Timeout";
              range "0..604800";
            }
          }
          leaf retry-down-count {
            tailf:info "Retry-count when node goes down";
            tailf:cli-optional-in-sequence;
            type uint8 {
              tailf:info "<1-5>;;Count";
              range "1..5";
            }
          }
          leaf retry-up-count {
            tailf:info "Retry-count when node comes back up";
            tailf:cli-optional-in-sequence;
            type uint8 {
              tailf:info "<1-5>;;Count";
              range "1..5";
            }
          }
        }
      }

      // itd device-group * / probe
      uses probe-grouping;

      // itd device-group * / node
      container node {
        tailf:info "ITD node";

        // itd device-group * / node ip *
        list ip {
          tailf:info "ITD node IPv4 address";
          tailf:cli-explicit-exit;
          key address;
          leaf address {
            type inet:ipv4-address;
          }
          leaf mode {
            tailf:info "Hot-standby mode";
            type enumeration {
              enum hot-standby;
            }
          }
          list standby {
            tailf:info "Standby node";
            max-elements 1;
            key address;
            leaf address {
              type inet:ipv4-address;
            }
          }
          leaf weight {
            tailf:info "Weight for traffic distribution";
            type uint16 {
              tailf:info "<1-256>;;Weight value";
              range "1..256";
            }
          }
          // itd device-group * / node ip * / probe
          uses probe-grouping;
        }
      }
    }

    // itd *
    list service {
      tailf:info "ITD service-name";
      tailf:cli-drop-node-name;
      tailf:cli-full-command;
      tailf:cli-explicit-exit;
      key name;
      leaf name {
        type word32 {
          tailf:info "WORD;;ITD service-name (Max Size 32)";
        }
      }

      leaf access-list {
        tailf:info "ITD access-list name";
        tailf:cli-remove-before-change;
        type word50 {
          tailf:info "WORD;;ITD user ACL name (Max Size 50)";
        }
      }
      leaf device-group {
        tailf:info "ITD device group";
        tailf:cli-remove-before-change;
        tailf:non-strict-leafref {
          path "../../device-group/group-name";
        }
        type word32 {
          tailf:info "WORD;;ITD device group name (Max Size 32)";
        }
      }
      container exclude {
        tailf:info "ACL to exclude from redirection";
        tailf:cli-compact-syntax;
        leaf access-list {
          tailf:info "ITD access-list name";
          type word50 {
            tailf:info "WORD;;ITD exclude ACL name (Max Size 50)";
          }
        }
      }
      container failaction {
        tailf:info "ITD failaction";
        tailf:cli-compact-syntax;
        leaf node {
          tailf:info "ITD failaction node";
          type enumeration {
            enum "reassign";
            enum "least-bucket";
            enum "per-bucket";
          }
        }
      }
      container ingress {
        tailf:info "ITD ingress interface";
        tailf:cli-compact-syntax;
        list interface {
          tailf:info "interface;;ITD ingress interface";
          tailf:cli-suppress-mode;
          key name;
          leaf name {
            tailf:cli-diff-dependency "/nx:interface/Vlan/name" {
              tailf:cli-trigger-on-delete;
            }
            type string; // leafref?
          }
        }
      }
      container load-balance {
        tailf:info "ITD Loadbalance";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        container method {
          tailf:info "ITD Loadbalance method";
          tailf:cli-sequence-commands;
          tailf:cli-compact-syntax;
          tailf:cli-flatten-container;
          tailf:cli-optional-in-sequence;
          leaf method {
            tailf:cli-incomplete-command;
            tailf:cli-drop-node-name;
            type enumeration {
              enum dst {
                tailf:info "Destination based parameters";
              }
              enum src {
                tailf:info "Source based parameters";
              }
            }
          }
          choice type {
            case ip {
              leaf ip {
                tailf:info "IP";
                type empty;
              }
            }
            case ip-l4port {
              leaf ip-l4port {
                tailf:info "IP and L4 port";
                tailf:cli-incomplete-command;
                type empty;
              }
              leaf protocol {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type enumeration {
                  enum tcp;
                  enum udp;
                }
              }
              leaf range {
                tailf:info "Match only packets in the range of port numbers";
                tailf:cli-incomplete-command;
                type uint16 {
                  tailf:info "<0-65535>";
                }
              }
              leaf last {
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<0-65535>";
                }
              }
            }
          }
        }
        leaf buckets {
          tailf:info "Used to create the buckets for traffic distribution"
            +", and it should be in powers of 2";
          tailf:cli-optional-in-sequence;
          type uint16 {
            tailf:info "<2-256>;;Loadbalance bucket number";
            range "2..256";
          }
        }
        leaf mask-position {
          tailf:info "Loadbalance mask position";
          type uint8 {
            tailf:info "<0-31>;;Loadbalance mask position number"
              + " range 0-31 for IPv4";
            range "0..31";
          }
        }
      }
      container peer {
        tailf:info "Peer cli for sandwich mode failure notification";
        container local {
          tailf:info "Peer involved in sandwich mode";
          leaf service {
            tailf:info "Peer service involved in sandwich mode";
            type string {
              tailf:info "WORD;;Peer service name string";
            }
          }
        }
        container vdc {
          tailf:info "Peer VDC involved in sandwich mode";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf name {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type string {
              tailf:info "WORD;;VDC name of peer VDC";
            }
          }
          leaf service {
            tailf:info "Peer service involved in sandwich mode";
            type string {
              tailf:info "WORD;;Peer service name string";
            }
          }
        }
      }
      container virtual {
        tailf:info "ITD virtual ip configuration";
        tailf:cli-compact-syntax;
        list ip {
          tailf:info "ITD virtual ip";
          tailf:cli-suppress-mode;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-remove-before-change;
          tailf:cli-incomplete-command;
          key address;
          leaf address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP address in format i.i.i.i";
            }
          }
          leaf mask {
            tailf:cli-drop-node-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP network mask in format m.m.m.m";
            }
          }
          choice proto {
            leaf tcp {
              tailf:cli-optional-in-sequence;
              tailf:cli-incomplete-command;
              type union {
                type uint16 {
                  tailf:info "<0-65535>;;Port Number";
                }
                type enumeration {
                  enum any;
                }
              }
            }
            leaf udp {
              tailf:cli-optional-in-sequence;
              tailf:cli-incomplete-command;
              type union {
                type uint16 {
                  tailf:info "<0-65535>;;Port Number";
                }
                type enumeration {
                  enum any;
                }
              }
            }
          }
          leaf advertise {
            tailf:info "Advertise";
            type enumeration {
              enum enable;
              enum disable;
            }
          }
          leaf active {
            tailf:info "Advertise route on at least one node active";
            when "../advertise" {
              tailf:dependency "../advertise";
            }
            type empty;
          }
        }
      }
      leaf vrf {
        tailf:info "ITD service vrf";
        tailf:cli-full-command;
        type word32 {
          tailf:info "WORD;;ITD Service VRF name (Max Size 32)";
        }
      }
      leaf shut {
        tailf:info "Enable/disable a service";
        tailf:cli-diff-dependency "../device-group" {
          tailf:cli-trigger-on-delete;
        }
        tailf:cli-full-command;
        tailf:cli-boolean-no;
        default true;
        type boolean;
      }
    }
  }


  /// ========================================================================
  /// nsc-policy-agent
  /// ========================================================================

  container nsc-policy-agent {
    tailf:cli-add-mode;

    leaf registration-ip {
      type inet:ipv4-address;
    }

    leaf shared-secret {
      type string;
    }

    leaf log-level {
      type string;
    }
  }


  /// ========================================================================
  /// network
  /// ========================================================================

  container network {
    container segment {

      // network segment manager switch
      container manager {
        container switch {
          tailf:cli-add-mode;
          container dvs {
            leaf name {
              type string;
            }
          }
        }
      }

      // network segment policy *
      list policy {
        key name;
        leaf name {
          type string;
        }

        // network segment policy * / description
        leaf description {
          tailf:cli-full-command;
          tailf:cli-multi-value;
          tailf:cli-preformatted;
          tailf:cli-no-value-on-delete;
          type string;
        }

        // network segment policy * / type
        leaf "type" {
          type string;  // vlan|segmentation
        }

        // network segment policy * / import port-profile
        container import {
          leaf port-profile {
            type string;
          }
        }
      }
    }
  }


  /// ========================================================================
  /// nsm
  /// ========================================================================

  container nsm {

    // nsm ip pool template *
    container ip {
      container pool {
        list template {
          key name;
          leaf name {
            type string;
          }

          // nsm ip pool template * / description
          leaf description {
            tailf:cli-full-command;
            tailf:cli-multi-value;
            tailf:cli-preformatted;
            tailf:cli-no-value-on-delete;
            type string;
          }

          // nsm ip pool template * / ip address
          container ip {
            container address {
              tailf:cli-sequence-commands;
              tailf:cli-compact-syntax;
              leaf start {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type inet:ipv4-address;
              }
              leaf end {
                tailf:cli-drop-node-name;
                type inet:ipv4-address;
              }
            }
          }

          // nsm ip pool template * / network
          container network {
            tailf:cli-sequence-commands;
            tailf:cli-compact-syntax;
            leaf address {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type inet:ipv4-address;
            }
            leaf mask {
              tailf:cli-drop-node-name;
              type inet:ipv4-address;
            }
          }
        }
      }
    }

    // nsm logical network *
    container logical {
      list network {
        key name;
        leaf name {
          type string;
        }
        leaf description {
          tailf:cli-full-command;
          tailf:cli-multi-value;
          tailf:cli-preformatted;
          tailf:cli-no-value-on-delete;
          type string;
        }
      }
    }

    container network {
      container segment {

        // nsm network segment pool *
        list pool {
          key name;
          leaf name {
            type string;
          }

          // nsm network segment pool * / description
          leaf description {
            tailf:cli-full-command;
            tailf:cli-multi-value;
            tailf:cli-preformatted;
            tailf:cli-no-value-on-delete;
            type string;
          }

          // nsm network segment pool * / uuid
          leaf uuid {
            type string;
          }

          // nsm network segment pool * / member-of logical network
          container member-of {
            container logical {
              leaf network {
                type string;
              }
            }
          }
        }

        // nsm network segment *
        list segment-list {
          tailf:cli-drop-node-name;
          key name;
          leaf name {
            tailf:cli-disallow-value "pool";
            type string;
          }

          // nsm network segment * / description
          leaf description {
            tailf:cli-full-command;
            tailf:cli-multi-value;
            tailf:cli-preformatted;
            tailf:cli-no-value-on-delete;
            type string;
          }

          // nsm network segment * / uuid
          leaf uuid {
            type string;
          }

          // nsm network segment * / member-of network segment pool
          container member-of {
            container network {
              container segment {
                leaf pool {
                  type string;
                }
              }
            }
          }

          // nsm network segment * / switchport
          container switchport {
            leaf mode {
              tailf:cli-no-value-on-delete;
              tailf:cli-no-name-on-delete;
              type enumeration {
                enum "access";
                enum "trunk";
              }
            }
            // nsm network segment * / switchport access
            container access {
              tailf:cli-no-name-on-delete;
              when "../mode = 'access'" {
                tailf:dependency "../mode";
              }
              leaf vlan {
                tailf:cli-no-value-on-delete;
                tailf:cli-no-name-on-delete;
                type uint16;
              }
            }
            // nsm network segment * / switchport trunk
            container trunk {
              when "../mode = 'trunk'" {
                tailf:dependency "../mode";
              }
              container native {
                leaf-list vlan {
                  tailf:cli-range-list-syntax;
                  tailf:cli-replace-all;
                  type uint16;
                }
              }
              container allowed {
                leaf-list vlan {
                  tailf:cli-range-list-syntax;
                  tailf:cli-replace-all;
                  type uint16;
                }
              }
            }
          }

          // nsm network segment * / ip pool import
          container ip {
            container pool {
              container import {
                tailf:cli-compact-syntax;
                leaf template {
                  type string;
                }
                leaf uuid {
                  type string;
                }
              }
            }
          }

          // nsm network segment * / publish network segment
          container publish {
            container network {
              container segment {
                presence "true";
                leaf name {
                  tailf:cli-drop-node-name;
                  type string;
                }
              }
            }
          }
        }
      }

      // nsm network vethernet *
      list vethernet {
        key name;
        leaf name {
          type string;
        }

        // nsm network vethernet * / import port-profile
        container import {
          container port-profile {
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf name {
              tailf:cli-drop-node-name;
              type string;
            }
            leaf uuid {
              type string;
            }
          }
        }

        // nsm network vethernet * / allow network
        container allow {
          container network {
            tailf:cli-compact-syntax;
            leaf segment {
              type string;
            }
            leaf uuid {
              type string;
            }
          }
        }

        // nsm network vethernet * / state
        leaf state {
          type enumeration {
            enum "enabled";
            enum "disabled";
          }
        }

        // nsm network vethernet * / port uuid *
        container port {
          list uuid {
            tailf:cli-compact-syntax;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key name;
            leaf name {
              type string;
            }
            leaf mac {
              type string;
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// track
  /// ========================================================================

  // track *
  list track {
    tailf:info "Object tracking configuration commands";
    key id;
    leaf id {
      type uint16 {
        tailf:info "<1-512>;;Tracked Object";
      }
    }

    // track * interface
    container interface {
      tailf:info "Interface to track";
      tailf:cli-hide-in-submode;
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-full-no;
      tailf:cli-no-name-on-delete;
      leaf name {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type string;
      }
      leaf ip {
        tailf:info "IPv4 parameters";
        tailf:cli-optional-in-sequence;
        tailf:cli-full-command;
        type enumeration {
          enum routing {
            tailf:info "Track interface ipv4 routing";
          }
        }
      }
      leaf line-protocol {
        tailf:info "Track interface line-protocol";
        tailf:cli-full-command;
        type empty;
      }
    }

    // track * ip
    container ip {
      tailf:info "IPv4 protocol";
      tailf:cli-hide-in-submode;
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      choice route-or-sla {
        leaf route {
          tailf:info "IPv4 route";
          tailf:cli-incomplete-command;
          type ip-mask {
            tailf:info "A.B.C.D/LEN;;Specify ipv4 route prefix";
          }
        }
        leaf sla {
          tailf:info "IP Service Level Agreement";
          type uint32 {
            tailf:info "<1-2147483647>;;Entry number";
          }
        }
      }
      leaf reachability {
        tailf:info "Route reachability state";
        type empty;
      }
      leaf hmm {
        tailf:info "Track routes owned by hmm";
        type empty;
      }
    }

    container ipv6 {
      tailf:info "IPv6 protocol";
      tailf:cli-hide-in-submode;
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf route {
        tailf:info "IPv6 route";
        tailf:cli-incomplete-command;
        type tailf:ipv6-address-and-prefix-length {
          tailf:info "A:B::C:D/LEN;;Specify ipv6 route prefix";
        }
      }
      leaf reachability {
        tailf:info "Route reachability state";
        type empty;
      }
      leaf hmm {
        tailf:info "Track routes owned by hmm";
        type empty;
      }
    }

    container list {
      tailf:info "Object tracking list";
      tailf:cli-hide-in-submode;
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      choice bool-or-threshold {
        leaf boolean {
          tailf:info "Boolean list type";
          type enumeration {
            enum and {
              tailf:info "List is TRUE if all Objects are TRUE";
            }
            enum or {
              tailf:info "List is TRUE if any Object is TRUE";
            }
          }
        }
        leaf threshold {
          tailf:info "Threshold type";
          type enumeration {
            enum percentage {
              tailf:info "Thresholds described as a percentage of total";
            }
            enum weight {
              tailf:info "Thresholds described by weight values";
            }
          }
        }
      }
    }

    // track * / delay
    container delay {
      tailf:info "Tracking delay";
      tailf:cli-compact-syntax;
      leaf up {
        tailf:info "Delay up change notification";
        default 0;
        type uint8 {
          tailf:info "<0-180>;;Seconds to delay";
          range "0..180";
        }
      }
      leaf down {
        tailf:info "Delay down change notification";
        default 0;
        type uint8 {
          tailf:info "<0-180>;;Seconds to delay";
          range "0..180";
        }
      }
    }

    // track * / vrf
    container vrf {
      tailf:info "Configure VPN Routing/Forwarding table";
      leaf member {
        tailf:info "Set route's VRF membership";
        tailf:non-strict-leafref {
          path "/nx:vrf/context/id";
        }
        type vrf-member-type;
      }
    }

    list object {
      tailf:info "Configure Object as member of tracking list";
      tailf:cli-suppress-mode;
      when "../list" {
        tailf:dependency "../list";
      }
      key id;
      leaf id {
        tailf:non-strict-leafref {
          path "/track/id";
        }
        type uint16 {
          tailf:info "<1-500>;;Tracked Object";
        }
      }
    }

  }

  /// ========================================================================
  /// ngoam
  /// ========================================================================
  container ngoam {
    tailf:info "Configure ngoam oam";
    tailf:cli-diff-dependency "/nx:feature/ngoam";

    leaf authentication-key {
      tailf:info "Ngoam authentication-key";
      type string {
        tailf:info "WORD;;Authentication key (Max Size 63)";
      }
    }

    container install {
      tailf:info "Ngoam install";
      leaf acl {
        tailf:info "Ngoam install acl";
        type empty;
      }
    }

    // ngoam profile *
    list profile {
      tailf:info "Configure ngoam oam profile";
      key id;
      leaf id {
        type uint16 {
          tailf:info "<1-1023>;;Ngoam profile id";
        }
      }

      leaf description {
        tailf:info "Configure description of the profile";
        tailf:cli-full-command;
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-no-value-on-delete;
        type string {
          tailf:info "LINE;;Description of maximum 64 characters (Max Size 64)";
        }
      }

      // ngoam profile * / dot1q
      container dot1q {
        tailf:info "Encapsulation dot1q/bd";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-full-no;
        leaf value {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-4094>;;Encapsulation dot1q/bd value";
          }
        }
        leaf interface {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "<name>;;Ethernet IEEE 802.3z or Port Channel interface";
          }
        }
      }

      container flow {
        tailf:info "Configure ngoam flow";
        container forward {
          tailf:info "Ngoam forward flow";
          tailf:cli-add-mode;
          presence true;

          // ngoam profile * / flow forward / dot1q
          leaf dot1q {
            tailf:info "Specify flow profile to include dot1q tag";
            type uint16 {
              tailf:info "<1-4095>;;Specify flow profile vlan-id";
            }
          }
          choice ipv4-or-ipv6 {
            container ip {
              tailf:info "Specify flow ipv4 address";
              leaf destination {
                tailf:info "Specify flow destination ip address";
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Ipv4 address";
                }
              }
              leaf source {
                tailf:info "Specify flow source ipv4 address";
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Ipv4 address";
                }
              }
            }
            container ipv6 {
              tailf:info "Specify flow ipv6 address";
              leaf destination {
                tailf:info "Specify flow destination ipv6 address";
                type inet:ipv6-address {
                  tailf:info "A:B::C:D;;Ipv6 address";
                }
              }
              leaf source {
                tailf:info "Specify flow source ipv6 address";
                type inet:ipv6-address {
                  tailf:info "A:B::C:D;;Ipv6 address";
                }
              }
            }
          }

          // ngoam profile * / flow forward / mac-address
          container mac-address {
            tailf:info "Specify flow mac address";
            leaf destination {
              tailf:info "Specify flow destination mac address";
              type string {
                tailf:info "EEEE.EEEE.EEEE;;Mac address (Option 4)";
                pattern "[0-9a-f]+\\.[0-9a-f]+\\.[0-9a-f]+";
              }
            }
            leaf source {
              tailf:info "Specify flow source mac address";
              type string {
                tailf:info "EEEE.EEEE.EEEE;;Mac address (Option 4)";
                pattern "[0-9a-f]+\\.[0-9a-f]+\\.[0-9a-f]+";
              }
            }
          }

          // ngoam profile * / flow forward / packet
          leaf packet {
            tailf:info "Provide flow details starting with ethernet header in hex-string format: 0A1B ..";
            type string {
              tailf:info "WORD;;Specify flow and payload in hex string format: 0A1B.. (Max Size 256)";
            }
          }

          // ngoam profile * / flow forward / port
          container port {
            tailf:info "Specify flow port address";
            leaf destination {
              tailf:info "Specify flow destination port address";
              type uint16 {
                tailf:info "<0-65535>;;Port number";
              }
            }
            leaf source {
              tailf:info "Specify flow source port address";
              type uint16 {
                tailf:info "<0-65535>;;Port number";
              }
            }
          }

          // ngoam profile * / flow forward / protocol
          leaf protocol {
            tailf:info "Specify flow protocol number";
            type uint8 {
              tailf:info "<0-255>;;Flow protocol number";
            }
          }
        }
      }

      leaf hop {
        tailf:info "Configure ngoam hop count";
        type uint8 {
          tailf:info "<1-255>;Configure ngoam service hop count value";
        }
      }

      leaf interface {
        tailf:info "Configure ngoam egress interface";
        tailf:cli-no-value-on-delete;
        type string {
          tailf:info "<name>;;Ethernet IEEE 802.3z or Port Channel interface";
        }
      }

      leaf oam-channel {
        tailf:info "Oam-channel used";
        type uint8 {
          tailf:info "<n>;;e.g. 2 - nvo3 tissa";
        }
      }

      container payload {
        tailf:info "Configure ngoam payload";
        leaf pad {
          tailf:info "Configure ngoam payload test pattern pad";
          type string {
            tailf:info "<0x0-0xffff>;;Configure ngoam payload test pad value";
            pattern "0x[0-9a-f]+";
          }
        }
      }

      leaf-list sport {
        tailf:info "Configure ngoam Udp source port range";
        tailf:cli-range-list-syntax;
        tailf:cli-replace-all;
        type uint16 {
          tailf:info "<0-65535>;;Udp source port range, Example: 200-300,400,500";
        }
      }
    }

    // ngoam connect-check *
    list connect-check {
      tailf:info "Configure ngoam oam connectivity check";
      key id;
      leaf id {
        type uint16 {
          tailf:info "<1-1023>;;Connect check id";
        }
      }

      //       container dest {
      //         tailf:info "Destination node";
      //         leaf ip {
      //           tailf:info "Ip address";
      //           type inet:ipv4-address {
      //             tailf:info "A.B.C.D;;Ipv4 address of remote host / VTEP";
      //           }
      //         }
      //         // skip: mac  Mac Address
      //       }

      //       leaf egress {
      //         tailf:info "Outgoing egress Interface";
      //         type string {
      //           tailf:info "<name>;;Ethernet IEEE 802.3z or Port Channel interface";
      //         }
      //       }

      leaf interval {
        tailf:info "Wait interval seconds between sending each packet";
        nx:delete-with "default";
        default 5;
        type uint8 {
          tailf:info "<1-30>;;Interval in seconds";
        }
      }

      leaf packet-size {
        tailf:info "Packet Datagram size to send";
        nx:delete-with "default";
        default 56;
        type uint16 {
          tailf:info "<1-65468>;;Size of datagram";
        }
      }

      //       container payload {
      //         tailf:info "Configure ngoam connectivity check payload";
      //         tailf:cli-add-mode;
      //         tailf:cli-full-no;
      //         container ip {
      //           tailf:info "Ip address";
      //           tailf:cli-compact-syntax;
      //           tailf:cli-sequence-commands {
      //             tailf:cli-reset-siblings;
      //           }
      //           leaf destination {
      //             tailf:cli-drop-node-name;
      //             tailf:cli-incomplete-command;
      //             type inet:ipv4-address {
      //               tailf:info "A.B.C.D;;Destination ipv4 address";
      //             }
      //           }
      //           leaf source {
      //             tailf:cli-drop-node-name;
      //             type inet:ipv4-address {
      //               tailf:info "A.B.C.D;;Source ipv4 address";
      //             }
      //           }
      //         }

      //         container ipv6 {
      //           tailf:info "Ipv6 address";
      //           tailf:cli-compact-syntax;
      //           tailf:cli-sequence-commands {
      //             tailf:cli-reset-siblings;
      //           }
      //           leaf destination {
      //             tailf:cli-drop-node-name;
      //             tailf:cli-incomplete-command;
      //             type inet:ipv6-address {
      //               tailf:info "A:B::C:D;;Destination ipv6 address";
      //             }
      //           }
      //           leaf source {
      //             tailf:cli-drop-node-name;
      //             type inet:ipv6-address {
      //               tailf:info "A:B::C:D;;Source ipv6 address";
      //             }
      //           }
      //         }

      //         // skip:  mac-addr  Mac Address
      //         container port {
      //           tailf:info "L4 port info";
      //           tailf:cli-compact-syntax;
      //           tailf:cli-sequence-commands {
      //             tailf:cli-reset-siblings;
      //           }
      //           leaf source {
      //             tailf:cli-drop-node-name;
      //             tailf:cli-incomplete-command;
      //             type uint16 {
      //               tailf:info "<1-65535>;;Source port";
      //             }
      //           }
      //           leaf destination {
      //             tailf:cli-drop-node-name;
      //             type uint16 {
      //               tailf:info "<1-65535>;;Destination port";
      //             }
      //           }
      //         }

      //         leaf proto {
      //           tailf:info "Protocol";
      //           type uint8 {
      //             tailf:info "<0-255>;;IANA Protocol id";
      //           }
      //         }

      //         leaf src-intf {
      //           tailf:info "Interface on which the host with src ip of the payload is connected";
      //           type string {
      //             tailf:info "<name>;;Ethernet IEEE 802.3z or Port Channel interface";
      //           }
      //         }

      //       }

      leaf profile {
        tailf:info "NGOAM profile to use";
        tailf:non-strict-leafref {
          path "/nx:ngoam/profile/id";
        }
        type uint16 {
          tailf:info "<1-1023>;;NGOAM profile id";
        }
      }

      //       leaf source {
      //         tailf:info "Source IP address to use";
      //         type inet:ipv4-address {
      //           tailf:info "A.B.C.D;;IP address of local system";
      //         }
      //       }

      //       leaf sport {
      //         tailf:info "Outer UDP source port";
      //         type uint16 {
      //           tailf:info "<1-65535>;;Source port";
      //         }
      //       }

      leaf timeout {
        tailf:info "Specify timeout interval";
        nx:delete-with "default";
        default 2;
        type uint8 {
          tailf:info "<0-60>  Timeout in seconds";
        }
      }

      leaf verify-host {
        tailf:info "Verify host reachability - payload info mandatory";
        type empty;
      }

      leaf vni {
        tailf:info "Vni";
        type uint32 {
          tailf:info "<1-16777215>;;Configure vni id";
        }
      }

      leaf vrf {
        tailf:info "Display per-VRF information";
        tailf:non-strict-leafref {
          path "/nx:vrf/context/id";
        }
        default "default";
        type vrf-member-type;
      }
    }

    container loop-detection {
      tailf:info "Configure Loop Detection";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-ng-oam-loop-detection";
      presence true;
      leaf periodic-probe-interval {
        tailf:info "Configure Loop Detection Probe Interval, Unit:Second";
        tailf:ned-default-handling report-all;
        tailf:cli-show-with-default;
        default 300;
        type uint16 {
          tailf:info "<60-3600>;;Loop detection probe timer value in seconds";
        }
      }
      leaf port-recovery-interval {
        tailf:info "Time interval to send recovery probes,Unit:Second";
        tailf:ned-default-handling report-all;
        tailf:cli-show-with-default;
        default 600;
        type uint16 {
          tailf:info "<300-3600>;;Port recovery interval value in seconds";
        }
      }
      container disable {
        tailf:info "Disable port-vlan";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf-list vlan {
          tailf:info "Disable detection on VLAN";
          tailf:cli-range-list-syntax;
          tailf:cli-diff-delete-before "../vlan" {
            tailf:cli-when-target-set;
          }
          tailf:cli-remove-before-change;
          type uint16 {
            tailf:info "<1-4095>;;Vlan range max span 1024, Example: 2000-3000,400,500";
          }
        }
        leaf port {
          type string;
        }
      }
    }

  }

  /// ========================================================================
  /// terminal
  /// ========================================================================
  container terminal {
    tailf:info "Configure terminal settings";
    leaf log-all {
      tailf:info "Accounting log all commands including the show commands";
      type empty;
    }
  }

  /// ========================================================================
  /// telnet
  /// ========================================================================
  container telnet {
    container server {
      leaf enable {
        type boolean;
        tailf:cli-boolean-no;
      }
    }
    leaf login-attempts {
      tailf:info "Set maximum login attempts";
      type uint8 {
        tailf:info "<1-10>;;Specify max-attempt number";
      }
    }
  }

  /// ========================================================================
  /// license
  /// ========================================================================
  container license {
    tailf:info "Modify license features";
    leaf grace-period {
      tailf:info "Configure grace period support for licenses";
      type boolean;
      tailf:cli-boolean-no;
    }
  }

  /// ========================================================================
  /// boot
  /// ========================================================================
  container boot {
    tailf:info "Configure boot variables";
    grouping image-grouping {
      leaf image {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "Enter kickstart image uri";
        }
      }
      leaf module {
        tailf:cli-drop-node-name;
        type enumeration {
          enum sup-1 {
            tailf:info "Enter sup-1 to configure the 1st sup";
          }
          enum sup-2 {
            tailf:info "Enter sup-2 to configure the 2nd sup";
          }
        }
      }
    }
    container kickstart {
      tailf:info "Configure kickstart image";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      uses image-grouping;
    }
    container system {
      tailf:info "Configure system image";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      uses image-grouping;
    }
    container nxos {
      tailf:info "Configure NXOS image";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      uses image-grouping;
    }

    container poap {
      tailf:info "Feature poap";
      leaf enable {
        tailf:info "Enable the feature";
        type empty;
      }
    }

  }

  /// ========================================================================
  /// hw-module
  /// ========================================================================
  container hw-module {
    tailf:info "Enable/Disable OBFL information";
    container logging {
      tailf:info "Enable/Disable OBFL information";
      leaf onboard {
        tailf:info "Enable/Disable OBFL information";
        tailf:cli-boolean-no;
        tailf:cli-full-no;
        tailf:cli-full-command;
        default true;
        type boolean;
      }
      container onboard-per-module {
        tailf:cli-drop-node-name;
        cli:parse-global-when;
        when "/nx:tailfned/support-per-module-obfl" {
          tailf:dependency "/nx:tailfned/support-per-module-obfl";
        }
        container onboard {
          tailf:info "Enable/Disable OBFL information";
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          list module {
            tailf:info "Enable/Disable OBFL information for Module";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key id;
            leaf id {
              nx:toggle-hw-module-obfl;
              type uint8 {
                tailf:info "<1-N>;;Specify a module number";
              }
            }
            leaf counter-stats {
              tailf:info "Enable/Disable OBFL counter statistics";
              tailf:cli-boolean-no;
              type boolean;
            }
            leaf cpuhog {
              tailf:info "Enable/Disable OBFL cpu hog events";
              tailf:cli-boolean-no;
              type boolean;
            }
            leaf environmental-history {
              tailf:info "Enable/Disable OBFL environmental history";
              tailf:cli-boolean-no;
              type boolean;
            }
            leaf error-stats {
              tailf:info "Enable/Disable OBFL error statistics";
              tailf:cli-boolean-no;
              type boolean;
            }
            leaf interrupt-stats {
              tailf:info "Enable/Disable OBFL interrupt statistics";
              tailf:cli-boolean-no;
              type boolean;
            }
            leaf obfl-log {
              tailf:info "Enable/Disable OBFL (boot-uptime/device-version/obfl-history)";
              tailf:cli-boolean-no;
              type boolean;
            }
            leaf memory-info {
              tailf:info "Enable/Disable OBFL memory info";
              tailf:cli-boolean-no;
              type boolean;
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// switch-profile
  /// ========================================================================
  container switch-profile {
    tailf:info "Enter switch-profile configuration mode";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-sync-sp";
    nx:edit-not-supported;
    leaf name {
      tailf:cli-drop-node-name;
      tailf:cli-hide-in-submode;
      type string {
        tailf:info "WORD;;Enter the name of the switch-profile (Max Size 64)";
      }
    }
    container sync-peers {
      tailf:info "Specify peers to whom configuration needs to be synced";
      leaf destination {
        tailf:info "Specify destination ip address of peer switch";
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;IPv4 address (A.B.C.D) of destination";
        }
      }
    }
  }


  /// ========================================================================
  /// as-mode
  /// ========================================================================
  leaf as-format {
    tailf:info "Configure the router's Autonomous system number (ASN) notation";
    tailf:cli-no-value-on-delete;
    type enumeration {
      enum asdot {
        tailf:info "Specifies the Autonomous system number (ASN) notation to asdot format";
      }
    }
  }


  /// ========================================================================
  /// switching-mode
  /// ========================================================================
  container switching-mode {
    tailf:info "Configure the operating switching-mode of asics";
    leaf store-forward {
      tailf:info "Operate in store and forward mode";
      type empty;
    }
  }


  /// ========================================================================
  /// xml
  /// ========================================================================

  container conf_xml {
    // NOTE: "parser-feature", can't have token name starting with 'xml'
    tailf:info "Xml agent";
    tailf:alt-name "xml";
    container server {
      tailf:info "Xml agent server";
      container validate {
        tailf:info "Command to validate an XML session";
        leaf all {
          tailf:info "All sessions";
          type empty;
        }
      }
    }
  }


  /// ========================================================================
  //                          EOF
  /// ========================================================================

}
