// =========================================================================
//                          CISCO-IOSXR NED
// =========================================================================

module tailf-ned-cisco-ios-xr {
  namespace 'http://tail-f.com/ned/cisco-ios-xr';
  prefix cisco-ios-xr;

  import tailf-common {
    prefix tailf;
  }
  import ietf-yang-types {
    prefix yang;
  }
  import ietf-inet-types {
    prefix inet;
  }
  import cliparser-extensions-v11 {
    prefix cli;
  }


  // =========================================================================
  // REVISION
  // =========================================================================

  revision 2022-01-21 {
    description "version 7.38.3, see CHANGES";
  }


  // =========================================================================
  // TURBO EXTENSIONS
  // =========================================================================

  extension lock-delete-redeploy {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.iosxr.IosxrCliExtensions.lockDeleteRedeploy";
  }

  extension if-delete-redeploy {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.iosxr.IosxrCliExtensions.ifDeleteRedeploy";
  }

  extension list-modify-redeploy {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.iosxr.IosxrCliExtensions.listModifyRedeploy";
  }

  extension mode-delete-redeploy {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.iosxr.IosxrCliExtensions.modeDeleteRedeploy";
  }

  extension if-strict-name {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.iosxr.IosxrCliExtensions.ifStrictName";
  }

  extension delete-syntax {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.iosxr.IosxrCliExtensions.deleteSyntax";
  }

  extension string-add-quotes {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.iosxr.IosxrCliExtensions.stringAddQuotes";
  }

  extension string-remove-quotes {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.iosxr.IosxrCliExtensions.stringRemoveQuotes";
  }

  extension max-values-output {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.iosxr.IosxrCliExtensions.maxValuesOutput";
  }

  extension if-vrf-restore {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.iosxr.IosxrCliExtensions.ifVrfRestore";
  }

  extension snmp-server-all-traps {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.iosxr.IosxrCliExtensions.snmpServerAllTraps";
  }

  extension maapi-encrypted {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.iosxr.IosxrCliExtensions.maapiEncrypted";
  }

  extension bgp-vrf-rd-modify {
    cli:direction "to-device";
    cli:state "post-match|call-once";
    cli:java-callback-method "com.tailf.packages.ned.iosxr.IosxrCliExtensions.bgpVrfRdModify";
  }

  extension remove-before-change {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.iosxr.IosxrCliExtensions.removeBeforeChange";
  }

  extension remove-and-commit-before-change {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.iosxr.IosxrCliExtensions.removeAndCommitBeforeChange";
  }

 extension nso-patch-leaf-list-delete {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.iosxr.IosxrCliExtensions.nsoPatchLeafListDelete";
  }

  extension inject-before {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.iosxr.IosxrCliExtensions.injectBefore";
  }

  extension regex-string {
    cli:direction "both";
    cli:state "post-match|pre-match";
    cli:java-callback-method "com.tailf.packages.ned.iosxr.IosxrCliExtensions.regexString";
  }

  extension trim-empty-key {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.iosxr.IosxrCliExtensions.trimEmptyKey";
  }

  extension trim-remove-before-change {
    cli:direction "to-device";
    cli:state "post-match";
    cli:java-callback-method "com.tailf.packages.ned.iosxr.IosxrCliExtensions.trimRemoveBeforeChange";
  }


  // =========================================================================
  // TYPEDEF
  // =========================================================================

  typedef ifname {
    type string {
      tailf:info "WORD;;Interface name";
    }
  }

  typedef month-type {
    type enumeration {
      enum january;
      enum february;
      enum march;
      enum april;
      enum may;
      enum june;
      enum july;
      enum august;
      enum september;
      enum october;
      enum november;
      enum december;
    }
  }

  typedef percentage-type {
    type uint8 {
      tailf:info "<1-100>;;Percentage";
      range "1..100";
    }
  }

  typedef asn-ip-type {
    type string {
      pattern '(([0-9]+)|((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}'
        +  '([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]))):[0-9]+';
      tailf:info "ASN:nn or IP-address:nn";
    }
  }

  typedef ipv4-prefix {
    type tailf:ipv4-address-and-prefix-length;
  }

  typedef task-type {
    type string {
      tailf:info "WORD;;Task ID";
    }
  }

  typedef severity-type {
    type enumeration {
      enum alerts {
        tailf:info "Immediate action needed           (severity=1)";
      }
      enum critical {
        tailf:info "Critical conditions               (severity=2)";
      }
      enum debugging {
        tailf:info "Debugging messages                (severity=7)";
      }
      enum emergencies {
        tailf:info "System is unusable                (severity=0)";
      }
      enum errors {
        tailf:info "Error conditions                  (severity=3)";
      }
      enum info {
      }
      enum informational {
        tailf:info "Informational messages            (severity=6)";
      }
      enum notifications {
        tailf:info "Normal but significant conditions (severity=5)";
      }
      enum warning {
        tailf:info "Warning conditions                (severity=4)";
      }
      enum warnings {
        tailf:info "Warning conditions                (severity=4)";
      }
      enum disable {
        tailf:info "Disable logging";
      }
    }
  }

  typedef dscp-type {
    type union {
      type uint8 {
        tailf:info "<0-63>;;Differentiated services codepoint value";
        range "0..63";
      }
      type enumeration {
        enum af11 {
          tailf:info "AF11 dscp (001010)";
          tailf:code-name "dscp_af11";
        }
        enum af12 {
          tailf:info "AF12 dscp (001100)";
          tailf:code-name "dscp_af12";
        }
        enum af13 {
          tailf:info "AF13 dscp (001110)";
          tailf:code-name "dscp_af13";
        }
        enum af21 {
          tailf:info "AF21 dscp (010010)";
          tailf:code-name "dscp_af21";
        }
        enum af22 {
          tailf:info "AF22 dscp (010100)";
          tailf:code-name "dscp_af22";
        }
        enum af23 {
          tailf:info "AF23 dscp (010110)";
          tailf:code-name "dscp_af23";
        }
        enum af31 {
          tailf:info "AF31 dscp (011010)";
          tailf:code-name "dscp_af31";
        }
        enum af32 {
          tailf:info "AF32 dscp (011100)";
          tailf:code-name "dscp_af32";
        }
        enum af33 {
          tailf:info "AF33 dscp (011110)";
          tailf:code-name "dscp_af33";
        }
        enum af41 {
          tailf:info "AF41 dscp (100010)";
          tailf:code-name "dscp_af41";
        }
        enum af42 {
          tailf:info "AF42 dscp (100100)";
          tailf:code-name "dscp_af42";
        }
        enum af43 {
          tailf:info "AF43 dscp (100110)";
          tailf:code-name "dscp_af43";
        }
        enum cs1 {
          tailf:info "CS1(precedence 1) dscp (001000)";
          tailf:code-name "dscp_cs1";
        }
        enum cs2 {
          tailf:info "CS2(precedence 2) dscp (010000)";
          tailf:code-name "dscp_cs2";
        }
        enum cs3 {
          tailf:info "CS3(precedence 3) dscp (011000)";
          tailf:code-name "dscp_cs3";
        }
        enum cs4 {
          tailf:info "CS4(precedence 4) dscp (100000)";
          tailf:code-name "dscp_cs4";
        }
        enum cs5 {
          tailf:info "CS5(precedence 5) dscp (101000)";
          tailf:code-name "dscp_cs5";
        }
        enum cs6 {
          tailf:info "CS6(precedence 6) dscp (110000)";
          tailf:code-name "dscp_cs6";
        }
        enum cs7 {
          tailf:info "CS7(precedence 7) dscp (111000)";
          tailf:code-name "dscp_cs7";
        }
        enum "default" {
          tailf:info "Default dscp (000000)";
          tailf:code-name "dscp_default";
        }
        enum ef {
          tailf:info "EF dscp (101110)";
          tailf:code-name "dscp_ef";
        }
      }
    }
  }

  typedef precedence-type {
    type union {
      type uint8 {
        tailf:info "<0-7>;;Precedence value";
        range "0..7";
      }
      type enumeration {
        enum routine {
          tailf:info "Set packets with routine precedence (0)";
          value 0;
        }
        enum priority {
          tailf:info "Set packets with priority precedence (1)";
          value 1;
        }
        enum immediate {
          tailf:info "Set packets with immediate precedence (2)";
          value 2;
        }
        enum flash {
          tailf:info "Set packets with flash precedence (3)";
          value 3;
        }
        enum flash-override {
          tailf:info "Set packets with flash override precedence (4)";
          value 4;
        }
        enum critical {
          tailf:info "Set packets with critical precedence (5)";
          value 5;
        }
        enum internet {
          tailf:info "Set packets with internetwork control precedence (6)";
          value 6;
        }
        enum network {
          tailf:info "Set packets with network control precedence (7)";
          value 7;
        }
      }
    }
  }

  typedef police-burst-units-type {
    type enumeration {
      enum bytes {
        tailf:info "Bytes (default)";
      }
      enum gbytes {
        tailf:info "Gigabytes";
      }
      enum kbytes {
        tailf:info "Kilobytes";
      }
      enum mbytes {
        tailf:info "Megabytes";
      }
      enum ms {
        tailf:info "Milliseconds";
      }
      enum packets {
        tailf:info "Packets";
      }
      enum us {
        tailf:info "Microseconds";
      }
      enum cells {
        tailf:info "Cells";
      }
    }
  }

  typedef police-rate-units-type {
    type enumeration {
      enum bps {
        tailf:info "Bits per second (default)";
      }
      enum gbps {
        tailf:info "Gigabits per second";
      }
      enum kbps {
        tailf:info "Kilobits per second";
      }
      enum mbps {
        tailf:info "Megabits per second";
      }
      enum pps {
        tailf:info "Packets per second";  //??
      }
    }
  }

  typedef ospf-area-type {
    type union {
      type uint32 {
        tailf:info "<0-4294967295>;;OSPF area ID as a decimal value";
        range "0..4294967295";
      }
      type inet:ipv4-address {
        tailf:info "A.B.C.D;;OSPF area ID in IP address format";
      }
    }
  }

  typedef operator-type {
    type enumeration {
      enum eq {
        tailf:info "Equal to";
      }
      enum ge {
        tailf:info "Greater than or equal to";
      }
      enum gt {
        tailf:info "Greater than";
      }
      enum le {
        tailf:info "Less than or equal to";
      }
      enum lt {
        tailf:info "Less than";
      }
      enum ne {
        tailf:info "Not equal to";
      }
      enum rg {
        tailf:info "Not in range";
      }
    }
  }

  typedef vrf-type {
    type union {
      type string {
        tailf:info "WORD;;Name of VRF";
      }
      type enumeration {
        enum "default" {
          tailf:info "Default vrf";
        }
      }
    }
  }

  // aaa-group-type
  typedef aaa-group-type {
    type union {
      type string {
        tailf:info "WORD;;Server-group name";
      }
      type enumeration {
        enum ldap {
          tailf:info "Use list of all LDAP hosts.";
        }
        enum radius {
          tailf:info "Use list of all Radius hosts.";
        }
        enum "tacacs+" {
          tailf:info "Use list of all Tacacs+ hosts.";
        }
      }
    }
  }

  typedef if-eth-oam-action-type {
    type enumeration {
      enum disable {
        tailf:info "Perform no action";
      }
      enum efd {
        tailf:info "Enable EFD to bring down the interface";
      }
      enum log {
        tailf:info "Log the event";
      }
      enum error-disable-interface {
        tailf:info "Error-disable the interface";
      }
    }
  }


  // =========================================================================
  // ADMIN SNMP TYPEDEF
  // =========================================================================

  typedef SNMP_TARGET_MIB_SnmpTagValue {
    type string {
      length "min .. 255";
    }
  }

  typedef SNMP_FRAMEWORK_MIB_SnmpSecurityModel {
    type int32 {
      range "0 .. 2147483647";
    }
  }

  typedef SNMP_FRAMEWORK_MIB_SnmpEngineID {
    type tailf:hex-list {
      pattern "(((([0-9A-Fa-f]{2}):){4,31})([0-9A-Fa-f]{2}))";
      tailf:value-length "5 .. 32";
    }
  }

  typedef SNMPv2_TC_DisplayString {
    type string {
      length "min .. 255";
      //CRASH NEDCOM: pattern '\p{IsBasicLatin}{0,255}';
    }
  }

  typedef SNMPv2_TC_TDomain {
    type yang:object-identifier;
  }

  typedef SNMPv2_TC_TAddress {
    type tailf:octet-list {
      tailf:value-length "1 .. 255";
    }
  }

  typedef SNMPv2_TC_AutonomousType {
    type yang:object-identifier;
  }

  typedef SNMPv2_TC_RowPointer {
    type yang:object-identifier;
  }

  typedef UDPIPv4TAddress {
    tailf:info "ipv4+port (6 dot-separated octets)";
    type tailf:octet-list {
      tailf:value-length "6";
    }
  }

  typedef UDPIPv6TAddress {
    tailf:info "ipv6+port (18 dot-separated octets)";
    type tailf:octet-list {
      tailf:value-length "18";
    }
  }

  typedef UDPXTAddress {
    tailf:info "XXX? (dot-separated octets)";
    type tailf:octet-list {
      tailf:value-length "7..17";
    }
  }

  typedef UDPTAddress {
    type union {
      type UDPIPv4TAddress;
      type UDPIPv6TAddress;
      type UDPXTAddress;
    }
  }

  typedef EmptyOctetList {
    type tailf:octet-list {
      tailf:value-length "0";
    }
  }

  typedef UDPTMask {
    tailf:info "octectList, 0, 6 or 18 octets long";
    type union {
      type UDPTAddress;
      type EmptyOctetList;
    }
  }

  typedef snmpTargetAddrEngineIDType {
    type tailf:hex-list {
      pattern "(((([0-9A-Fa-f]{2}):){4,31})([0-9A-Fa-f]{2}))?";
      tailf:value-length "min .. 32";
    }
  }

  typedef SnmpTagValue {
    type string {
      length "min .. 255";
    }
  }

  typedef SnmpTagList {
    type string {
      length "min .. 255";
    }
  }

  typedef snmpTargetAddrNameType {
    type string {
      length "1 .. 32";
    }
  }

  typedef snmpTargetAddrRetryCountType {
    type int32 {
      range "0 .. 255";
    }
  }

  typedef snmpTargetAddrParamsType {
    type string {
      length "1 .. 32";
    }
  }

  typedef snmpTargetParamsNameType {
    type string {
      length "1 .. 32";
    }
  }

  typedef snmpTargetParamsSecurityModelType {
    type int32 {
      range "1 .. 2147483647";
    }
  }

  typedef SNMP_FRAMEWORK_MIB_SnmpAdminString {
    type string {
      length "min .. 255";
    }
  }

  typedef  SNMP_FRAMEWORK_MIB_SnmpMessageProcessingModel {
    type int32 {
      range "0 .. 2147483647";
    }
  }

  typedef SNMP_FRAMEWORK_MIB_SnmpSecurityLevel {
    type enumeration {
      enum "noAuthNoPriv" {
        value 1;
      }
      enum "authNoPriv" {
        value 2;
      }
      enum "authPriv" {
        value 3;
      }
    }
  }

  typedef SNMPv2_TC_TimeInterval {
    type int32 {
      range "0 .. 2147483647";
    }
  }

  typedef SNMPv2_TC_StorageType {
    type enumeration {
      enum "other" {
        value 1;
      }
      enum "volatile" {
        value 2;
      }
      enum "nonVolatile" {
        value 3;
      }
      enum "permanent" {
        value 4;
      }
      enum "readOnly" {
        value 5;
      }
    }
  }

  typedef snmpCommunityIndexType {
    type string {
      length "1 .. 32";
    }
  }

  typedef snmpCommunityNameType {
    type string;
  }

  typedef snmpCommunitySecurityNameType {
    type string {
      length "1 .. 32";
    }
  }

  typedef snmpCommunityContextNameType {
    type string {
      length "min .. 32";
    }
  }

  typedef snmpTargetAddrTMaskType {
    type tailf:hex-list {
      pattern "(((([0-9A-Fa-f]{2}):){0,254}([0-9A-Fa-f]{2}))){0,1}";
      tailf:value-length "min .. 255";
    }
  }

  typedef snmpTargetAddrMMSType {
    type int32 {
      range "0 .. 2147483647";
    }
  }

  typedef snmpNotifyNameType {
    type string {
      length "1 .. 32";
    }
  }

  typedef snmpNotifyTypeType {
    type enumeration {
      enum "trap" {
        value 1;
      }
      enum "inform" {
        value 2;
      }
    }
  }

  typedef KeyChange {
    type tailf:hex-list {
      pattern "(((([0-9A-Fa-f]{2}):)*([0-9A-Fa-f]{2}))){0,1}";
    }
  }

  typedef usmUserNameType {
    type string {
      length "1 .. 32";
    }
  }

  typedef usmUserPublicType {
    type tailf:hex-list {
      pattern "(((([0-9A-Fa-f]{2}):){0,31}([0-9A-Fa-f]{2}))){0,1}";
      tailf:value-length "min .. 32";
    }
  }

  typedef vacmContextNameType {
    type string {
      length "min .. 32";
    }
  }

  typedef vacmSecurityModelType {
    type int32 {
      range "1 .. 2147483647";
    }
  }

  typedef vacmSecurityNameType {
    type string {
      length "1 .. 32";
    }
  }

  typedef vacmGroupNameType {
    type string {
      length "1 .. 32";
    }
  }

  typedef vacmAccessContextPrefixType {
    type string {
      length "min .. 32";
    }
  }

  typedef vacmAccessContextMatchType {
    type enumeration {
      enum "exact" {
        value 1;
      }
      enum "prefix" {
        value 2;
      }
    }
  }

  typedef vacmAccessReadViewNameType {
    type string {
      length "min .. 32";
    }
  }

  typedef vacmAccessWriteViewNameType {
    type string {
      length "min .. 32";
    }
  }

  typedef vacmAccessNotifyViewNameType {
    type string {
      length "min .. 32";
    }
  }

  typedef vacmViewTreeFamilyViewNameType {
    type string {
      length "1 .. 32";
    }
  }

  typedef vacmViewTreeFamilyMaskType {
    type tailf:hex-list {
      pattern "(((([0-9A-Fa-f]{2}):){0,15}([0-9A-Fa-f]{2}))){0,1}";
      tailf:value-length "0 .. 16";
    }
  }

  typedef vacmViewTreeFamilyTypeType {
    type enumeration {
      enum "included" {
        value 1;
      }
      enum "excluded" {
        value 2;
      }
    }
  }

  typedef sysContactType {
    type SNMPv2_TC_DisplayString;
  }

  typedef sysNameType {
    type SNMPv2_TC_DisplayString;
  }

  typedef sysLocationType {
    type SNMPv2_TC_DisplayString;
  }

  typedef snmpEnableAuthenTrapsType {
    type enumeration {
      enum "enabled" {
        value 1;
      }
      enum "disabled" {
        value 2;
      }
    }
  }

// NOTE: This is to be able to run yang with/without ypp
//#if (1 == 0)
  typedef NEDCOM_SECRET_TYPE {
    type string;
  }
//#endif


  // =========================================================================
  // GROUPING
  // =========================================================================


  // description-grouping
  grouping description-grouping {
    leaf description {
      tailf:info "Description text";
      tailf:cli-multi-value;
      tailf:cli-preformatted;
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;Description";
      }
    }
  }

  grouping password-grouping {
    leaf type {
      tailf:cli-drop-node-name;
      tailf:cli-optional-in-sequence;
      tailf:cli-incomplete-command;
      type enumeration {
        enum clear {
          tailf:info "Specify unencrypted password";
        }
        enum encrypted {
          tailf:info "Specify encrypted password";
        }
      }
    }
    leaf secret {
      tailf:cli-drop-node-name;
      tailf:cli-reset-container;
      tailf:cli-disallow-value "clear|encrypted";
      type NEDCOM_SECRET_TYPE {
        tailf:info "WORD;;Specify an unencrypted password";
      }
    }
  }

  // key-grouping
  grouping key-grouping {
    leaf encryption {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      tailf:cli-optional-in-sequence;
      type enumeration {
        enum 0 {
          tailf:info "Specifies an UNENCRYPTED key will follow";
        }
        enum 7 {
          tailf:info "Specifies an ENCRYPTED key will follow";
        }
      }
    }
    leaf key {
      tailf:cli-drop-node-name;
      tailf:cli-reset-container;
      tailf:cli-disallow-value "0|7";
      type NEDCOM_SECRET_TYPE {
        tailf:info "LINE;;The UNENCRYPTED key";
      }
    }
  }

  grouping banner-grouping {
    leaf start-marker {
      tailf:cli-drop-node-name;
      tailf:cli-no-value-on-delete;
      type string {
        tailf:info "WORD;;delimitting start character";
        length "1";
      }
    }
    leaf message {
      tailf:cli-drop-node-name;
      tailf:cli-no-value-on-delete;
      type string {
        tailf:info "WORD;;quoted banner message";
      }
    }
    leaf end-marker {
      tailf:cli-drop-node-name;
      tailf:cli-no-value-on-delete;
      must "../end-marker = ../start-marker" {
        tailf:dependency "../start-marker";
        tailf:dependency "../end-marker";
      }
      type string {
        tailf:info "WORD;;delimitting end character";
        length "1";
      }
    }
  }


  grouping apply-group-grouping {
    leaf-list apply-group {
      tailf:info "Apply configuration from a group";
      tailf:cli-flat-list-syntax;
      tailf:cli-remove-before-change;
      tailf:cli-no-value-on-delete;
      tailf:cli-full-command;
      tailf:cli-suppress-leafref-in-diff;
      tailf:non-strict-leafref {
        path "/cisco-ios-xr:group/name";
      }
      type string {
        tailf:info "WORD;;Group name";
      }
    }
    leaf exclude-group {
      tailf:info "Exclude apply-group configuration from a group";
      tailf:cli-remove-before-change;
      tailf:cli-no-value-on-delete;
      tailf:cli-suppress-leafref-in-diff;
      tailf:non-strict-leafref {
        path "/cisco-ios-xr:group/name";
      }
      type string {
        tailf:info "WORD;;Group name";
      }
    }
  }

  grouping exclude-item-grouping {
    list exclude-item {
      tailf:info "Negate a command or set its defaults";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        tailf:cli-multi-word-key;
        type string {
          tailf:info "LINE;;Exclude line";
        }
      }
    }
  }


  // vrf * / address-family ipv4 unicast / import route-target
  // vrf * / address-family ipv4 unicast / export route-target
  // vrf * / address-family ipv6 unicast / import route-target
  // vrf * / address-family ipv6 unicast / export route-target
  grouping vrf-af-route-target-grouping {

    // vrf * / address-family ipv6 unicast / export route-target / *
    list address-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        type string {
          tailf:info "<1-65535>:<0-4294967295>;;ASN2:index\n"+
            "<65536-4294967295>:<0-65535>;;ASN4:index\n"+
            "<IP address>:<0-65535>;;IPAddress:index "+
            "(hex or decimal format)";
          pattern "[0-9]+.*";
        }
      }
    }

    // vrf * / address-family ipv6 unicast / export route-target / * stitching
    list stitching-address-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      tailf:cli-incomplete-no;
      key name;
      leaf name {
        type string {
          tailf:info "<1-65535>:<0-4294967295>;;ASN2:index\n"+
            "<65536-4294967295>:<0-65535>;;ASN4:index\n"+
            "<IP address>:<0-65535>;;IPAddress:index "+
            "(hex or decimal format)";
          pattern "[0-9]+.*";
        }
      }
      leaf stitching {
        tailf:info "These are stitching RTs";
        type empty;
      }
    }
  }

  // router-af-redistribute-grouping
  grouping router-af-redistribute-grouping {
    leaf metric {
      tailf:info "Metric for redistributed routes";
      type uint32 {
        tailf:info "<0-4294967295>;;Default metric";
      }
    }
    leaf route-policy {
      tailf:info "Route policy reference";
      tailf:cli-suppress-leafref-in-diff;
      tailf:non-strict-leafref {
        path "/cisco-ios-xr:route-policy/name";
      }
      type string {
        tailf:info "WORD;;Name of the policy";
      }
    }
  }

  // router-ospf-af-redistribute-grouping
  grouping router-ospf-af-redistribute-grouping {
    leaf metric {
      tailf:info "Metric for redistributed routes";
      type union {
        type uint32 {
          tailf:info "<0-4294967295>;;Default metric";
        }
        type enumeration {
          enum use-rib-metric {
            tailf:info "Use metric from RIB";
          }
        }
      }
    }
    leaf tag {
      tailf:info "Set tag for routes redistributed into OSPF";
      type uint32 {
        tailf:info "<0-4294967295>;;32-bit tag value";
      }
    }
    leaf metric-type {
      tailf:info "Metric type for redistributed routes";
      type enumeration {
        enum "1" {
          tailf:info "Set OSPF External Type 1 metrics";
        }
        enum "2" {
          tailf:info "Set OSPF External Type 2 metrics";
        }
      }
    }
    leaf route-policy {
      tailf:info "Route policy reference";
      tailf:cli-suppress-leafref-in-diff;
      tailf:non-strict-leafref {
        path "/cisco-ios-xr:route-policy/name";
      }
      type string {
        tailf:info "WORD;;Name of the policy";
      }
    }
  }

  // router-isis-af-redistribute-grouping
  grouping router-isis-af-redistribute-grouping {
    leaf level {
      tailf:cli-drop-node-name;
      type enumeration {
        enum level-1 {
          tailf:info "Redistribute routes into level 1 only";
        }
        enum level-1-2 {
          tailf:info "Redistribute routes into both levels";
        }
        enum level-2 {
          tailf:info "Redistribute routes into level 2 only (the default)";
        }
      }
    }
    uses router-af-redistribute-grouping;
    leaf metric-type {
      tailf:info "Metric type for redistributed routes";
      type enumeration {
        enum external {
          tailf:info "External metric type";
        }
        enum internal {
          tailf:info "Internal metric type";
        }
        enum rib-metric-as-external {
          tailf:info "External metric type and use RIB metric";
        }
        enum rib-metric-as-internal {
          tailf:info "Internal metric type and use RIB metric";
        }
      }
    }
  }

  // router ospf * / authentication
  // router ospf * / message-digest-key
  // router-ospf-area-grouping
  grouping router-ospf-authentication-grouping {

    // router ospf * / authentication-key
    container authentication-key {
      tailf:info "Authentication password (key)";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      uses password-grouping {
        refine "secret" {
          cli:secret " authentication-key <SECRET>";
        }
      }
    }

    // router ospf * / authentication
    container authentication {
      tailf:info "Enable authentication";
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      presence true;
      choice authentication-choice {
        // router ospf * / authentication message-digest
        container message-digest {
          tailf:info "Use message-digest authentication";
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          presence true;
          leaf keychain {
            tailf:info "Specify keychain name";
            tailf:cli-suppress-leafref-in-diff;
            tailf:non-strict-leafref {
              path "/cisco-ios-xr:key/chain/name";
            }
            type string {
              tailf:info "WORD;;The keychain name";
            }
          }
        }

        // router ospf * / authentication ipsec
        container ipsec {
          tailf:info "Use IPSec AH authentication";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf spi {
            tailf:info "Specify the Security Parameter Index value";
            type uint32 {
              tailf:info "<256-4294967295>;;Security Parameter Index value";
              range "256..4294967295";
            }
          }
          leaf algorithm {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type enumeration {
              enum md5 {
                tailf:info "Use the MD5 algorithm";
              }
              enum sha1 {
                tailf:info "Use the SHA1 algorithm";
              }
            }
          }
          leaf type {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            tailf:cli-incomplete-command;
            type enumeration {
              enum clear {
                tailf:info "Enter MD5|SHA1 key in cleartext form";
              }
              enum password {
                tailf:info "Enter MD5|SHA1 key in encrypted form";
              }
            }
          }
          leaf password {
            tailf:cli-drop-node-name;
            cli:secret " authentication ipsec spi (?:\\d+) (?:md5|sha1)(?: password| clear)? <SECRET>";
            type NEDCOM_SECRET_TYPE {
              tailf:info "WORD;;MD5|SHA1 key";
            }
          }
        }

        // router ospf * / authentication disable
        leaf disable {
          tailf:info "Do not authenticate OSPFv3 packets";
          type empty;
        }

        // router ospf * / authentication null
        leaf null {
          tailf:info "Use no authentication";
          type empty;
        }
      }
    }

    // router ospf * / message-digest-key
    list message-digest-key {
      tailf:info "Message digest authentication password (key)";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-incomplete-command;
      key id;
      leaf id {
        tailf:info "Key ID";
        tailf:cli-suppress-range;
        type uint8 {
          tailf:info "<1-255>;;Key ID";
          range "1..255";
        }
      }
      container md5 {
        tailf:info "Use MD5 algorithm";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        uses password-grouping {
          refine "secret" {
            cli:secret " md5 <SECRET>";
          }
        }
      }
    }
  }

  // router bgp * / neighbor * / bfd
  // router bgp * / session-group * / bfd
  // router ospf * / area * / bfd
  // router ospf * / area * / interface * / bfd
  // router pim / address-family ipv4 / interface * / bfd
  grouping bfd-common-parameters-grouping {
    container bfd {
      tailf:info "Configure BFD parameters";

      // ... bfd minimum-interval
      leaf minimum-interval {
        tailf:info "Hello interval";
        type uint16 {
          tailf:info "<3-30000>;;hello interval in milli-seconds";
          range "3..30000";
        }
      }

      // ... bfd fast-detect
      container fast-detect {
        tailf:info "Enable Fast detection";
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        choice fast-detect-choice {
          leaf disable {
            tailf:info "Prevent bfd settings from being inherited from the parent";
            type empty;
          }
          leaf strict-mode {
            tailf:info "Hold down neighbor session until BFD session is up";
            type empty;
          }
        }
      }

      // ... bfd multiplier
      leaf multiplier {
        tailf:info "Detect multiplier";
        type uint8 {
          tailf:info "<2-50>;;Detect multiplier";
          range "2..50";
        }
      }
    }
  }


  // router bgp * / neighbor-group * /
  // router bgp * / session-group * /
  grouping bgp-common-group-grouping {

    // router bgp * / neighbor-group * / ao
    container ao {
      tailf:info "Enable Authentiation Option";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      choice ao-choice {
        leaf inheritance-disable {
          tailf:info "Prevent keychain from being inherited from parent";
          type empty;
        }
        case keychain {
          leaf name {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            tailf:cli-disallow-value "inheritance-disable";
            type string {
              tailf:info "WORD;;Name of the key chain - maximum 32 characters";
            }
          }
          leaf include-tcp-options {
            tailf:info "Include/Exclude other TCP options in the header";
            type enumeration {
              enum disable {
                tailf:info "Exclude other TCP options in the header";
              }
              enum enable {
                tailf:info "Include other TCP options in the header";
              }
            }
          }
          leaf accept-ao-mismatch-connection {
            tailf:info "Accept new connection even if AO mismatched";
            type empty;
          }
        }
      }
    }
  }


  // router ospf *
  // router ospf * / area *
  // router ospf * / area * / interface *
  grouping router-ospf-common-area-grouping {

    // router ospf * / cost
    leaf cost {
      tailf:info "Interface cost";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<1-65535>;;Cost";
        range "1..65535";
      }
    }

    // router ospf * / security ttl
    container security {
      tailf:info "Enable security";
      container ttl {
        tailf:info "Enable ttl security";
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        leaf hops {
          tailf:info "IP hops";
          type uint8 {
            tailf:info "<1-254>;;maximum number of hops allowed";
            range "1..254";
          }
        }
      }
    }

    // router ospf * / passive
    container passive {
      tailf:info "Enable/Disable passive";
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      presence true;
      leaf mode {
        tailf:info "Enable/Disable passive mode";
        tailf:cli-drop-node-name;
        type enumeration {
          enum disable {
            tailf:info "Disable passive";
          }
          enum enable {
            tailf:info "Enable passive";
          }
        }
      }
    }

    // router ospf * / priority
    leaf priority {
      tailf:info "Router priority";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<0-255>;;Priority";
      }
    }

    // router ospf * / mtu-ignore
    container mtu-ignore {
      tailf:info "Enable/Disable ignoring of MTU in DBD packets";
      presence true;
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      leaf mode {
        tailf:cli-drop-node-name;
        type enumeration {
          enum disable {
            tailf:info "Disable ignoring of MTU in DBD packets";
          }
          enum enable {
            tailf:info "Ignores the MTU in DBD packets";
          }
        }
      }
    }

    // router ospf * / flood-reduction
    leaf flood-reduction {
      tailf:info "OSPF Flood Reduction";
      type enumeration {
        enum disable {
          tailf:info "Disable flooding reduction";
        }
        enum enable {
          tailf:info "Enable flooding reduction";
        }
      }
    }

    // router ospf * / retransmit-interval
    leaf retransmit-interval {
      tailf:info "Time between retransmitting lost link state advertisements";
      type uint16 {
        tailf:info "<1-65535>;;Seconds";
        range "1..65535";
      }
    }

    // router ospf * / dead-interval
    leaf dead-interval {
      tailf:info "Dead interval time";
      type uint16 {
        tailf:info "<1-65535>;;Seconds";
        range "1..65535";
      }
    }

    // router ospf * / demand-circuit
    leaf demand-circuit {
      tailf:info "Enable/Disable demand circuits";
      type enumeration {
        enum disable {
          tailf:info "Disable demand circuits";
        }
        enum enable {
          tailf:info "Enable demand circuits";
        }
      }
    }

    // router ospf * / transmit-delay
    leaf transmit-delay {
      tailf:info "Estimated time needed to send link-state update packet";
      type uint16 {
        tailf:info "<1-65535>;;Seconds";
        range "1..65535";
      }
    }

    // router ospf * / fast-reroute
    container fast-reroute {
      tailf:info "IP Fast Reroute";

      // router ospf * / fast-reroute X
      choice per-link-or-prefix {

        // router ospf * / fast-reroute disable
        leaf disable {
          tailf:info "Disable IP Fast Reroute";
          type empty;
        }

        // router ospf * / fast-reroute per-link
        container per-link {
          tailf:info "Per-link Computation";
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          presence true;
          leaf enable {
            tailf:info "Enable";
            type empty;
          }
        }

        // router ospf * / fast-reroute per-prefix
        leaf per-prefix {
          tailf:info "Per-prefix Computation";
          cisco-ios-xr:delete-syntax " no fast-reroute";
          type empty;
        }
      }

      // router ospf * / fast-reroute per-prefix X
      container per-prefix-conf {
        tailf:cli-drop-node-name;
        container per-prefix {
          tailf:info "Per-prefix Computation";
          tailf:cli-incomplete-no;
          tailf:cli-incomplete-command;

          // router ospf * / fast-reroute per-prefix ti-lfa
          leaf ti-lfa {
            tailf:info "Topology Independent LFA computation";
            type enumeration {
              enum disable {
                tailf:info "Disable TI LFA computation";
              }
              enum enable {
                tailf:info "Enable TI LFA computation";
              }
            }
          }

          // router ospf * / fast-reroute per-prefix remote-lfa tunnel mpls-ldp
          container remote-lfa {
            tailf:info "Remote LFA computation";
            container tunnel {
              tailf:info "Enable remote LFA computation using tunnels";
              leaf mpls-ldp {
                tailf:info "MPLS LDP tunnel";
                type empty;
              }
            }
          }

          // router ospf * / fast-reroute per-prefix priority-limit
          leaf priority-limit {
            tailf:info "Limit backup computation upto the prefix priority";
            type enumeration {
              enum medium {
                tailf:info "Compute for critical, high & medium priority prefixes";
              }
              enum high {
                tailf:info "Compute for critical & high priority prefixes";
              }
              enum critical {
                tailf:info "Compute for critical priority prefixes only";
              }
            }
          }

          // router ospf * / fast-reroute per-prefix tiebreaker
          container tiebreaker {
            tailf:info "Configure tiebreaker for multiple backups";

            // router ospf * / fast-reroute per-prefix tiebreaker node-protecting
            container node-protecting {
              tailf:info "Prefer node protecting backup path";
              choice node-protecting-choice {
                leaf disable {
                  tailf:info "Disable tiebreaker";
                  type empty;
                }
                leaf index {
                  tailf:info "Set preference order among tiebreakers";
                  type uint8 {
                    tailf:info "<1-255>;;Index";
                    range "1..255";
                  }
                }
              }
            }

            // router ospf * / fast-reroute per-prefix tiebreaker srlg-disjoint
            container srlg-disjoint {
              tailf:info "Prefer SRLG disjoint backup path";
              choice node-protecting-choice {
                leaf disable {
                  tailf:info "Disable tiebreaker";
                  type empty;
                }
                leaf index {
                  tailf:info "Set preference order among tiebreakers";
                  type uint8 {
                    tailf:info "<1-255>;;Index";
                    range "1..255";
                  }
                }
              }
            }
          }
        }
      }
    }

    // router ospf * / prefix-suppression
    leaf prefix-suppression {
      tailf:info "Suppress advertisement of the prefixes";
      tailf:cli-full-command;
      type empty;
    }
    // router ospf * / prefix-suppression secondary-address
    container prefix-suppression-sec {
      tailf:cli-drop-node-name;
      container prefix-suppression {
        tailf:info "Suppress advertisement of the prefixes";
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        container secondary-address {
          tailf:info "Enable/Disable secondary address suppression";
          leaf enable {
            tailf:info "Enable secondary address suppression";
            type empty;
          }
        }
      }
    }

    // router ospf * / hello-interval
    leaf hello-interval {
      tailf:info "Time between HELLO packets";
      type uint16 {
        tailf:info "<1-65535>;;Seconds";
      }
    }

    // router ospf * / encryption
    container encryption {
      tailf:info "Encrypt and authenticate OSPFv3 packets";

      // router ospf * / encryption disable
      leaf disable {
        tailf:info "Do not encrypt OSPFv3 packets";
        type empty;
      }
    }
  }

  // router ospf * / area * / X
  // router ospf * / area * / interface * / X
  grouping router-ospf-area-grouping {

    uses bfd-common-parameters-grouping;

    uses router-ospf-common-area-grouping;

    // router ospf * / area * / authentication
    // router ospf * / area * / message-digest-key
    uses router-ospf-authentication-grouping;

    // router ospf * / area * / external-out
    leaf external-out {
      tailf:info "Enable/Disable advertisement of intra-area prefixes as external";
      type enumeration {
        enum disable {
          tailf:info "Disable advertisement of intra-area routes as external";
        }
        enum enable {
          tailf:info "Enable advertisement of intra-area routes as external";
        }
      }
    }

    // router ospf * / area * / route-policy * in|out
    uses route-policy-list-grouping;

    // router ospf * / area * / network
    leaf network {
      tailf:info "Network type";
      tailf:cli-full-command;
      type enumeration {
        enum broadcast {
          tailf:info "Specify OSPF broadcast multi-access network";
        }
        enum non-broadcast {
          tailf:info "Specify OSPF NBMA network";
        }
        enum point-to-multipoint {
          tailf:info "Specify OSPF point-to-multipoint network";
        }
        enum point-to-point {
          tailf:info "Specify OSPF point-to-point network";
        }
      }
    }

    // router ospf * / area * / packet-size
    leaf packet-size {
      tailf:info "Customize size of OSPF packets upto MTU";
      type uint32 {
        tailf:info "<576-10000>;;Size of OSPF packets to use. Min: 576  Max: MTU bytes";
        range "576..10000";
      }
    }

    // router ospf * / area * / mpls
    container mpls {
      tailf:info "Configure MPLS routing protocol parameters";

      // router ospf * / area * / mpls ldp
      container ldp {
        tailf:info "Configure LDP parameters";

        // router ospf * / area * / mpls ldp sync
        container sync {
          tailf:info "Enable LDP IGP synchronization on interfaces";
          presence true;
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          leaf disable {
            tailf:info "Disable MPLS LDP sync";
            type empty;
          }
        }

        // router ospf * / area * / mpls ldp auto-config
        leaf auto-config {
          tailf:info "Enable LDP IGP interface auto-configuration";
          tailf:cli-full-command;
          type empty;
        }

        // router ospf * / area * / mpls ldp sync-igp-shortcuts
        container sync-igp-shortcuts {
          tailf:info "LDP sync for igp-shortcut tunnels";
          presence true;
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          leaf disable {
            tailf:info "Disable MPLS LDP sync igp-shortcuts";
            type empty;
          }
        }
      }

      // router ospf * / area * / mpls traffic-eng
      leaf traffic-eng {
        tailf:info "Configure an ospf area to run MPLS Traffic Engineering";
        type empty;
      }
    }

    // router ospf * / area * / segment-routing
    container segment-routing {
      tailf:info "Segment Routing configuration";

      // router ospf * / area * / segment-routing mpls
      // router ospf * / area * / segment-routing disable
      choice mpls-disable-choice {
        leaf mpls {
          tailf:info "SR using MPLS dataplane";
          type empty;
        }
        leaf disable {
          tailf:info "Disable Segment Routing";
          type empty;
        }
      }
    }

    // router ospf * / area * / prefix-sid
    container prefix-sid {
      tailf:info "Prefix SID Configuration";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      choice prefix-sid-choice {
        leaf absolute {
          tailf:info "SID value";
          tailf:cli-reset-container;
          type uint32 {
            tailf:info "<16000-1048575>;;SID label";
            range "16000..1048575";
          }
        }
        leaf index {
          tailf:info "SID Index";
          tailf:cli-reset-container;
          type uint32 {
            tailf:info "<0-1048575>;;SID Index";
            range "0..1048575";
          }
        }
      }
      leaf explicit-null {
        tailf:info "Force penultimate hop to send explicit-null label";
        type empty;
      }
    }

    // router ospf * / area * / distribute-list * in
    list distribute-list {
      tailf:info "Filter networks in routing updates";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-remove-before-change;
      key direction;
      leaf direction {
        type enumeration {
          enum "in" {
            tailf:info "Filter incoming routing updates";
          }
        }
      }
      leaf route-policy {
        tailf:info "Route Policy to filter OSPF prefixes";
        tailf:cli-prefix-key;
        tailf:cli-optional-in-sequence;
        type empty;
      }
      leaf access-list {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        tailf:cli-disallow-value "route-policy";
        tailf:cli-suppress-leafref-in-diff;
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:ipv4/access-list/named-acl/name";
        }
        type string {
          tailf:info "WORD;;Access-list name (disable-inheritance means use no access list)";
        }
      }
    }

    // router ospf * / area * / neighbor *
    list neighbor {
      tailf:info "Specify a neighbor router";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key address;
      leaf address {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Neighbor address (name)";
        }
      }
      // router ospf * / area * / neighbor * priority
      leaf priority {
        tailf:info "OSPF priority of non-broadcast neighbor";
        type uint8 {
          tailf:info "<0-255>;;Priority";
        }
      }
    }

    // router ospf * / area * / nssa
    container nssa {
      tailf:info "Specify area as a NSSA area";
      tailf:cli-compact-syntax;
      tailf:cli-delete-when-empty;
      presence true;

      // router ospf * / area * / nssa no-redistribution
      leaf no-redistribution {
        tailf:info "No redistribution into this NSSA area";
        type empty;
      }

      // router ospf * / area * / nssa default-information-originate
      leaf default-information-originate {
        tailf:info "Originate Type 7 default into NSSA area";
        type empty;
      }

      // router ospf * / area * / nssa metric
      leaf metric {
        tailf:info "OSPF default metric";
        when "../default-information-originate";
        type uint32 {
          tailf:info "<0-16777214>;;OSPF metric";
          range "0..16777214";
        }
      }

      // router ospf * / area * / nssa metric-type
      leaf metric-type {
        tailf:info "OSPF metric type for default routes";
        when "../default-information-originate";
        type uint8 {
          tailf:info "<1-2>;;Link State metric type";
          range "1..2";
        }
      }

      // router ospf * / area * / nssa no-summary
      leaf no-summary {
        tailf:info "Do not send summary LSA into NSSA";
        type empty;
      }
    }

    // router ospf * / area * / database-filter all out
    container database-filter {
      tailf:info "Filter OSPF LSA during synchronization and flooding";
      container all {
        tailf:info "Filter all LSA";
        leaf out {
          tailf:info "Outgoing LSA";
          type enumeration {
            enum disable {
              tailf:info "Disable filtering";
            }
            enum enable {
              tailf:info "Enable filtering";
            }
          }
        }
      }
    }

    // router ospf * / area * / cost-fallback
    container cost-fallback {
      tailf:info "Cost when cumulative bandwidth goes below the theshold";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf cost {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint16 {
          tailf:info "<1-65535>;;Cost";
          range "1..65535";
        }
      }
      leaf threshold {
        tailf:info "Threshold bandwidth when cost-fallback is applied";
        type uint32 {
          tailf:info "<1-4294967>;;Threshold bandwidth in Mbits per second";
          range "1..4294967";
        }
      }
    }
  }

  // router ospf *
  // router ospfv3 *
  grouping router-ospfvx-common-pre-grouping {

    // router ospf * / nsr
    leaf nsr {
      tailf:info "Enable NSR for all VRFs in this process";
      tailf:cli-full-command;
      type empty;
    }

    // router ospf * / router-id
    leaf router-id {
      tailf:info "Specify the router-id for this OSPF process";
      tailf:cli-full-command;
      type inet:ipv4-address {
        tailf:info "A.B.C.D;;OSPF router-id in IPv4 address format";
      }
    }

    // router ospf * / summary-in enable
    leaf summary-in {
      tailf:info "Enable/Disable advertisement of external prefixes as inter-area";
      type enumeration {
        enum  disable {
          tailf:info "Disable advertisement of external prefixes as inter-area";
        }
        enum enable {
          tailf:info "Enable advertisement of external prefixes as inter-area";
        }
      }
    }

    // router ospf * / trace size *
    container trace {
      tailf:info "OSPF tracing options(cisco-support)";
      list size {
        tailf:info "Delete existing buffer and create one with N entries(cisco-support)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of trace buffer";
          }
        }
        leaf size {
          tailf:cli-drop-node-name;
          type enumeration {
            enum 0 {
              tailf:info "disable trace(cisco-support)";
            }
            enum 256 {
              tailf:info "trace entries(cisco-support)";
            }
            enum 512 {
              tailf:info "trace entries(cisco-support)";
            }
            enum 1024 {
              tailf:info "trace entries(cisco-support)";
            }
            enum 2048 {
              tailf:info "trace entries(cisco-support)";
            }
            enum 4096 {
              tailf:info "trace entries(cisco-support)";
            }
            enum 8192 {
              tailf:info "trace entries(cisco-support)";
            }
            enum 16384 {
              tailf:info "trace entries(cisco-support)";
            }
            enum 32768 {
              tailf:info "trace entries(cisco-support)";
            }
            enum 65536 {
              tailf:info "trace entries(cisco-support)";
            }
          }
        }
      }
    }

    // router ospf * / distribute link-state
    container distribute {
      tailf:info "Enable Distribution of LSAs to external services";
      container link-state {
        tailf:info "Distribute the link-state database to external services";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        leaf instance-id {
          tailf:info "Set distribution process instance identifier";
          type uint32 {
            tailf:info "<0-4294967295>;;Instance ID";
          }
        }
        leaf throttle {
          tailf:info "Throttle time between successive LSA updates";
          type uint16 {
            tailf:info "<1-3600>;;Seconds";
            range "1..3600";
          }
        }
      }
    }

    // router ospf * / cost
    uses router-ospf-common-area-grouping;

    // router ospf * / log
    container log {
      tailf:info "Log ospf info";
      container adjacency {
        tailf:info "Log adjacency state info";
        container changes {
          tailf:info "Log changes";
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          presence true;
          leaf changes-state {
            tailf:info "Log all state changes or disable logging";
            tailf:cli-drop-node-name;
            type enumeration {
              enum detail {
                tailf:info "Log all state changes";
              }
              enum disable {
                tailf:info "Disable logging";
              }
            }
          }
        }
      }
    }

    // router ospf * / timers
    container timers {
      tailf:info "Adjust routing timers";

      // router ospf * / timers throttle
      container throttle {
        tailf:info "OSPF throttle timers";

        // router ospf * / timers throttle lsa all
        container lsa {
          tailf:info "LSA throttle timers";
          container all {
            tailf:info "For all types of OSPF LSAs";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf delay {
              tailf:info "Delay to generate first occurrence of LSA in milliseconds";
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint32 {
                tailf:info "<0-600000>;;Delay to generate first occurrence of LSA in milliseconds";
                range "0..600000";
              }
            }
            leaf min-delay {
              tailf:info "Minimum delay between originating the same LSA in milliseconds";
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint32 {
                tailf:info "<1-600000>;;Minimum delay between originating the same LSA in milliseconds";
                range "1..600000";
              }
            }
            leaf max-delay {
              tailf:info "Maximum delay between originating the same LSA in milliseconds";
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<1-600000>;;Maximum delay between originating the same LSA in milliseconds";
                range "1..600000";
              }
            }
          }
        }

        // router ospf * / timers throttle spf
        container spf {
          tailf:info "OSPF SPF throttle timers";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf delay {
            tailf:info "Delay between receiving a change to SPF calculation in milliseconds";
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<1-600000>;;Delay between receiving a change to SPF calculation in milliseconds";
              range "1..600000";
            }
          }
          leaf min-delay {
            tailf:info "Delay between first and second SPF calculation in milliseconds";
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<1-600000>;;Delay between first and second SPF calculation in milliseconds";
              range "1..600000";
            }
          }
          leaf max-delay {
            tailf:info "Maximum wait time in milliseconds for SPF calculations";
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-600000>;;Maximum wait time in milliseconds for SPF calculations";
              range "1..600000";
            }
          }
        }
      }

      // router ospf * / timers lsa
      container lsa {
        tailf:info "OSPF global LSA timers";

        // router ospf * / timers lsa group-pacing
        leaf group-pacing {
          tailf:info "OSPF LSA group pacing timer";
          type uint16 {
            tailf:info "<10-1800>;;Interval between group of LSA being refreshed or maxaged";
            range "10..1800";
          }
        }

        // router ospf * / timers lsa arrival
        leaf arrival {
          tailf:info "LSA arrival timer";
          type uint16 {
            tailf:info "<0-60000>;;The minimum interval in milliseconds between accepting the same LSA";
            range "0..60000";
          }
        }

        // router ospf * / timers lsa min-arrival
        leaf min-arrival {
          tailf:info "OSPF MinLSArrival timer";
          tailf:cli-full-command;
          type uint32 {
            tailf:info "<0-600000>;;The minimum interval in millisec between accepting the same LSA";
            range "0..600000";
          }
        }

        // router ospf * / timers lsa refresh
        leaf refresh {
          tailf:info "OSPF LSA refresh interval";
          type uint16 {
            tailf:info "<1800-2700>;;How often self-originated LSAs should be refreshed, in seconds";
            range "1800..2700";
          }
        }
      }

      // router ospf * / timers pacing floow
      container pacing {
        tailf:info "OSPF pacing timers";
        leaf flood {
          tailf:info "OSPF flood pacing timer";
          type uint8 {
            tailf:info "<5-100>;;Interval in msec to pace flooding on all interfaces";
            range "5..100";
          }
        }
      }
    }

    // router ospf * / auto-cost
    container auto-cost {
      tailf:info "Calculate OSPF interface cost according to bandwidth";
      tailf:cli-delete-when-empty;
      presence true;

      // router ospf * / auto-cost reference-bandwidth
      leaf reference-bandwidth {
        tailf:info "Specify reference bandwidth for OSPF cost computations";
        tailf:cli-full-command;
        type uint32 {
          tailf:info "<1-4294967>;;The reference bandwidth in terms of Mbits per second";
          range "1..4294967";
        }
      }
    }

    // router ospf * / maximum
    container maximum {
      tailf:info "Set OSPF limits";

      // router ospf * / maximum paths
      leaf paths {
        tailf:info "Limit number of paths";
        type uint8 {
          tailf:info "<1-64>;;Maximum number of paths per route";
          range "1..64";
        }
      }

      // router ospf * / maximum interfaces
      leaf interfaces {
        tailf:info "Limit number of interfaces";
        type uint32 {
          tailf:info "<1-4294967295>;;Maximum number of interfaces";
        }
      }

      // router ospf * / maximum redistributed-prefixes
      container redistributed-prefixes {
        tailf:info "Limit number of redistributed prefixes";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf maximum {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-4294967295>;;Maximum number of prefixes redistributed into OSPF";
          }
        }
        leaf threshold-value {
          tailf:cli-drop-node-name;
          tailf:cli-optional-in-sequence;
          type uint8 {
            tailf:info "<1-100>;;Threshold value (%) at which to generate a warning msg";
            range "1..100";
          }
        }
        leaf warning-only {
          tailf:info "Only give warning messsage when limit is exceeded";
          type empty;
        }
      }
    }

    // router ospf * / bfd
    container bfd {
      tailf:info "Configure BFD parameters";

      // router ospf * / bfd fast-detect
      leaf fast-detect {
        tailf:info "Enable Fast detection";
        tailf:cli-full-command;
        type empty;
      }

      // router ospf * / bfd minimum-interval
      leaf minimum-interval {
        tailf:info "Hello interval";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<0-30000>;;hello interval in milli-seconds";
          range "0..30000";
        }
      }

      // router ospf * / bfd multiplier
      leaf multiplier {
        tailf:info "Detect multiplier";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<0-30>;;Detect multiplier";
        }
      }
    }

    // router ospf * / network
    container network {
      tailf:info "Network type";
      choice network-choice {
        leaf broadcast {
          tailf:info "Specify OSPF broadcast multi-access network";
          type empty;
        }
        leaf non-broadcast {
          tailf:info "Specify OSPF NBMA network";
          type empty;
        }
        container point-to-multipoint {
          tailf:info "Specify OSPF point-to-multipoint network";
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          presence true;
          leaf non-broadcast {
            tailf:info "Specify OSPF non-broadcast point-to-multipoint network";
            type empty;
          }
        }
        leaf point-to-point {
          tailf:info "Specify OSPF point-to-point network";
          type empty;
        }
      }
    }

    // router ospf * / domain-id
    container domain-id {
      tailf:info "Specify domain id";

      // router ospf * / domain-id type
      container primary {
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        uses router-ospf-domain-id-grouping;
      }

      // router ospf * / domain-id secondary
      container secondary {
        tailf:info "OSPF secondary domain-id";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        uses router-ospf-domain-id-grouping;
      }
    }

    // router ospf * / default-information originate
    container default-information {
      tailf:info "Control distribution of default information";
      container originate {
        tailf:info "Distribute a default route";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        leaf always {
          tailf:info "Always advertise default route";
          type empty;
        }
        uses router-ospf-af-redistribute-grouping;
      }
    }

    // router ospf * / spf prefix-priority route-policy
    container spf {
      tailf:info "SPF configuration";
      container prefix-priority {
        tailf:info "Configure SPF prefix priority route policy";
        leaf route-policy {
          tailf:info "Specify the route-policy to prioritize route install";
          tailf:cli-suppress-leafref-in-diff;
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:route-policy/name";
          }
          type string {
            tailf:info "WORD;;Name of the policy";
          }
        }
      }
    }

    // router ospf * / distance
    container distance {
      tailf:info "Define an administrative distance";

      // router ospf * / distance ?
      leaf weight {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-255>;;Administrative distance";
          range "1..255";
        }
      }

      // router ospf * / distance *
      list distance-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key "ip-address wildcard-mask";
        leaf weight {
          tailf:cli-prefix-key;
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<1-255>;;Administrative distance";
            range "1..255";
          }
        }
        leaf ip-address {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP Source address";
          }
        }
        leaf wildcard-mask {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP Wild Card bits";
          }
        }
        leaf access-list-name {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;Access list";
          }
        }
      }

      // router ospf * / distance ospf
      container ospf {
        tailf:info "OSPF distance";
        container external {
          tailf:info "External type 5 and type 7 routes";
          leaf distance {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-255>;;Distance for external type 5 and type 7 routes";
              range "1..255";
            }
          }
        }
      }
    }

    // router ospf * / redistribute
    container redistribute {
      tailf:info "Redistribute information from another routing protocol";

      // router ospf * / redistribute connected
      container connected {
        tailf:info "Connected routes";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-ospf-af-redistribute-grouping;
      }

      // router ospf * / redistribute ospf *
      list ospf {
        tailf:info "Open Shortest Path First (OSPF)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;OSPF instance name";
          }
        }
        uses router-ospf-af-redistribute-grouping;
      }

      // router ospf * / redistribute bgp *
      list bgp {
        tailf:info "Border Gateway Protocol (BGP)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          tailf:info "AS number in 2-byte, 4-byte asdot and asplain";
          type string {
            tailf:info "WORD;;AS number in 2-byte, 4-byte asdot and asplain";
          }
        }
        leaf preserve-med {
          tailf:info "Preserve med of BGP routes";
          type empty;
        }
        uses router-ospf-af-redistribute-grouping;
      }

      // router ospf * / redistribute static
      container static {
        tailf:info "Static route";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-ospf-af-redistribute-grouping;
      }

      // router ospf * / redistribute isis *
      list isis {
        tailf:info "ISO IS-IS";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;IS-IS instance name";
          }
        }
        leaf level {
          tailf:cli-drop-node-name;
          type enumeration {
            enum level-1 {
              tailf:info "Redistribute routes into level 1 only";
            }
            enum level-1-2 {
              tailf:info "Redistribute routes into both levels";
            }
            enum level-2 {
              tailf:info "Redistribute routes into level 2 only (the default)";
            }
          }
        }
        uses router-ospf-af-redistribute-grouping;
      }
    }
  }


  // router ospf *
  // router ospfv3 *
  grouping router-ospfvx-common-post-grouping {

    // router ospf * / area *
    list area {
      tailf:info "Enter the OSPF area configuration submode";
      tailf:cli-mode-name "config-ospf-ar";
      key id;
      leaf id {
        tailf:info "Area id";
        tailf:cli-suppress-range;
        type ospf-area-type;
      }
      uses router-ospf-area-grouping;

      // router ospf * / area * / stub
      container stub {
        tailf:info "Specify the area as a stub area";
        tailf:cli-delete-when-empty;
        presence true;
        // router ospf * / area * / stub nu-summary
        leaf no-summary {
          tailf:info "Do not send summary LSA into stub area";
          type empty;
        }
      }

      // router ospf * / area * / range *
      list range {
        tailf:info "Summarize routes matching address/mask (border routers only)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key prefix;
        leaf prefix {
          type ipv4-prefix {
            tailf:info "A.B.C.D/prefix;;IP address/mask for address";
          }
        }
        leaf mode {
          tailf:cli-drop-node-name;
          type enumeration {
            enum advertise {
              tailf:info "Advertise this range (default)";
            }
            enum not-advertise {
              tailf:info "DoNotAdvertise this range";
            }
          }
        }
      }

      // router ospf * / area * / multi-area-interface *
      list multi-area-interface {
        tailf:info "Enable multi-area adjacency on this interface";
        tailf:cli-mode-name "config-ospf-ar-mif";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Interface Name";
          }
        }
        uses router-ospf-area-grouping;
      }

      // router ospf * / area * / interface *
      list interface {
        tailf:info "Enable routing on an interface";
        tailf:cli-mode-name "config-ospf-ar-if";
        key name;
        leaf name {
          tailf:info "Interface Name";
          type string {
            tailf:info "WORD;;Interface Name";
          }
        }
        uses router-ospf-area-grouping;
      }
    }
  }


  // router ospf *
  // router ospf * / vrf *
  grouping router-ospf-grouping {

    // router ospf * / ?
    uses router-ospfvx-common-pre-grouping;

    // router ospf * / distribute-list *
    list distribute-list {
      tailf:info "Filter networks in routing updates";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-remove-before-change;
      key direction;
      leaf direction {
        type enumeration {
          enum "in" {
            tailf:info "Filter incoming routing updates";
          }
          enum "out" {
            tailf:info "Filter outgoing routing updates";
          }
        }
      }
      leaf route-policy {
        tailf:info "Route Policy to filter OSPF prefixes";
        tailf:cli-prefix-key;
        tailf:cli-optional-in-sequence;
        type empty;
      }
      leaf access-list {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        tailf:cli-suppress-leafref-in-diff;
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:ipv4/access-list/named-acl/name";
        }
        type string {
          tailf:info "WORD;;Access-list name (disable-inheritance means use no access list)";
        }
      }
    }

    // router ospf * / distribute-list * <proto>
    container distribute-list-proto {
      tailf:cli-drop-node-name;
      list distribute-list {
        tailf:info "Filter networks in routing updates";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        key direction;
        leaf access-list {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          tailf:cli-disallow-value "out";
          tailf:cli-suppress-leafref-in-diff;
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:ipv4/access-list/named-acl/name";
          }
          type string {
            tailf:info "WORD;;Access-list name (disable-inheritance means use no access list)";
          }
        }
        leaf direction {
          type enumeration {
            enum "out" {
              tailf:info "Filter outgoing routing updates";
            }
          }
        }
        leaf connected {
          tailf:cli-break-sequence-commands;
          tailf:info "Connected";
          type empty;
        }
        leaf static {
          tailf:info "Static routes";
          type empty;
        }
        leaf bgp {
          tailf:info "Border Gateway Protocol (BGP)";
          type union {
            type uint32 {
              tailf:info "<1-4294967295>;;Autonomous system number";
              range "1..4294967295";
            }
            type string {
              tailf:info "<1.0-XX.YY>;;Autonomous system number";
              pattern '[0-9]+\.[0-9]+';
            }
          }
        }
        leaf ospf {
          tailf:info "Open Shortest Path First (OSPF)";
          type string {
            tailf:info "WORD;;OSPF instance name";
          }
        }
      }
    }

    uses router-ospfvx-common-post-grouping;

    // router ospf * / capability
    container capability {
      tailf:info "Enable specific OSPF feature";

      // router ospf * / capability type7 prefer
      container type7 {
        tailf:info "NSSA capability";
        leaf prefer {
          tailf:info "Prefer type7 externals over type5";
          type empty;
        }
      }

      // router ospf * / capability opaque
      container opaque {
        tailf:info "Opaque LSA";
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        // router ospf * / capability opaque disable
        leaf disable {
          tailf:info "Disable Opaque LSA capability";
          type empty;
        }
      }
    }

    // router ospf * / nsf
    container nsf {
      tailf:info "Enable Cisco Non Stop Forwarding";

      // router ospf * / nsf ietf
      container ietf {
        tailf:info "Enable ietf graceful restart";
        tailf:cli-display-separated;
        presence true;
        container helper {
          tailf:info "router's helper support level";
          leaf disable {
            tailf:info "router's helper support disabled";
            type empty;
          }
        }
      }

      // router ospf * / nsf cisco
      container cisco {
        tailf:info "Enable Cisco Non Stop Forwarding";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        container enforce {
          tailf:info "Cancel NSF restart when non-NSF-aware neighbors detected";
          leaf global {
            tailf:info "For the whole OSPF process";
            type empty;
          }
        }
      }

      // router ospf * / nsf interval
      leaf interval {
        tailf:info "Minimum interval between NSF restarts (seconds)";
        type uint16 {
          tailf:info "<90-3600>;;seconds";
          range "90..3600";
        }
      }

      // router ospf * / nsf lifetime
      leaf lifetime {
        tailf:info "Maximum route lifetime following restart (seconds)";
        type uint16 {
          tailf:info "<90-1800>;;seconds";
          range "90..1800";
        }
      }
    }

    // router ospf * / max-lsa
    container max-lsa {
      tailf:info "Maximum number of LSAs OSPF process will receive";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      leaf max {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<1-4294967294>;;Maximum number of non self-generated LSAs this process can receive";
          range "1..4294967294";
        }
      }
      leaf threshold {
        tailf:cli-drop-node-name;
        tailf:cli-break-sequence-commands;
        type uint8 {
          tailf:info "<1-100>;;Threshold value (%) at which to generate a warning msg";
          range "1..100";
        }
      }
      leaf warning-only {
        tailf:info "Only give warning message when limit is exceeded";
        tailf:cli-full-command;
        type empty;
      }
      leaf ignore-time {
        tailf:info "time during which all adjacencies are suppressed";
        type uint32 {
          tailf:info "<1-35791394>;;number of minutes during which all adjacencies are suppressed";
          range "1..35791394";
        }
      }
      leaf ignore-count {
        tailf:info "maximum number of times adjacencies can be suppressed";
        type uint32 {
          tailf:info "<1-4294967294>;;count on how many times adjacencies can be suppressed";
          range "1..4294967294";
        }
      }
      leaf reset-time {
        tailf:info "time after which ignore-count is reset to zero";
        type uint32 {
          tailf:info "<2-71582788>;;number of minutes after which ignore-count is reset to zero";
          range "2..71582788";
        }
      }
    }

    // router ospf * / loopback stub-network
    container loopback {
      tailf:info "OSPF loopback configuration";
      leaf stub-network {
        tailf:info "Advertise loopback as a stub network";
        type enumeration {
          enum disable {
            tailf:info "Disable advertising loopback as a stub network";
          }
          enum enable {
            tailf:info "Enable advertising loopback as a stub network";
          }
        }
      }
    }

    // router ospf * / queue
    container queue {
      tailf:info "Adjust OSPF input queue";

      // router ospf * / queue limit
      container limit {
        tailf:info "High watermark for incoming priority events";
        // router ospf * / queue limit low
        leaf low {
          tailf:info "High watermark for incoming low priority events (DBD/LSUpd/Req)";
          type uint16 {
            tailf:info "<1000-30000>;;DBD/LS Update/Req packets are dropped "+
              "when incoming event queue exceeds this value";
            range "1000..30000";
          }
        }
        // router ospf * / queue limit high
        leaf high {
          tailf:info "High watermark for incoming high priority events (hello)";
          type uint16 {
            tailf:info "<1000-30000>;;Hello events are dropped when incoming event queue exceeds this value";
            range "1000..30000";
          }
        }
        // router ospf * / queue limit medium
        leaf medium {
          tailf:info "High watermark for incoming medium priority events (LSA ACK)";
          type uint16 {
            tailf:info "<1000-30000>;;LSA ACKs are dropped when incoming event queue exceeds this value";
            range "1000..30000";
          }
        }
      }
    }

    // router ospf * / ignore lsa mospf
    container ignore {
      tailf:info "Do not complain about specific event";
      container lsa {
        tailf:info "Do not complain upon receiving LSA of the specified type";
        leaf mospf {
          tailf:info "MOSPF Type 6 LSA";
          type empty;
        }
      }
    }

    // router ospf * / segment-routing
    container segment-routing {
      tailf:info "Segment Routing configuration";

      // router ospf * / segment-routing global-block
      container global-block {
        tailf:info "MPLS label range for SID allocation";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf lower-bound {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<16000-1048574>;;The lower bound of the SRGB";
            range "16000..1048574";
          }
        }
        leaf upper-bound {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<16001-1048575>;;The upper bound of the SRGB";
            range "16001..1048575";
          }
        }
      }

      // router ospf * / segment-routing mpls
      // router ospf * / segment-routing disable
      choice mpls-disable-choice {
        leaf mpls {
          tailf:info "SR using MPLS dataplane";
          type empty;
        }
        leaf disable {
          tailf:info "Disable Segment Routing";
          type empty;
        }
      }

      // router ospf * / segment-routing forwarding mpls
      leaf forwarding {
        tailf:info "Enable Segment-routing forwarding on interfaces";
        type enumeration {
          enum disable {
            tailf:info "Disable advertising loopback as a stub network";
          }
          enum mpls {
            tailf:info "Use MPLS for Segment-routing forwarding";
          }
        }
      }

      // router ospf * / segment-routing sr-prefer
      container sr-prefer {
        tailf:info "Prefer segment routing labels over LDP labels";
        tailf:cli-delete-when-empty;
        tailf:cli-reset-container;
        presence true;

        // router ospf * / segment-routing sr-prefer prefix-list
        leaf prefix-list {
          tailf:info "Filter prefixes for which SR preference is applied";
          tailf:cli-suppress-leafref-in-diff;
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:ipv4/prefix-list/name";
          }
          type string {
            tailf:info "WORD;;Prefix-list name";
          }
        }
      }

      // router ospf * / segment-routing prefix-sid-map
      container prefix-sid-map {
        tailf:info "Configuring segment routing mapping server";

        // router ospf * / address-family * / segment-routing prefix-sid-map receive
        container receive {
          tailf:info "Control the usage of remote mapping server advertisements";
          presence true;
          leaf disable {
            tailf:info "Disable the usage of remote mapping server advertisements";
            type empty;
          }
        }

        // router ospf * / address-family * / segment-routing prefix-sid-map advertise-local
        leaf advertise-local {
          tailf:info "Advertise and use local mapping server entries";
          type empty;
        }
      }
    }

    // router ospf * / microloop avoidance
    container microloop {
      tailf:info "Microloop configuration";
      container avoidance {
        tailf:info "Avoid microloops";

        // router ospf * / microloop avoidance segment-routing
        leaf segment-routing {
          tailf:info "Enable segment routing microloop avoidance";
          type empty;
        }

        // router ospf * / microloop avoidance rib-update-delay
        leaf rib-update-delay {
          tailf:info "Delay to introduce between SPF and RIB update";
          type uint32 {
            tailf:info "<1-600000>;;Delay in milliseconds";
            range "1..600000";
          }
        }
      }
    }

    // router ospf * / summary-prefix *
    list summary-prefix {
      tailf:info "Configure IP address summaries";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      key prefix;
      leaf prefix {
        type ipv4-prefix {
          tailf:info "A.B.C.D/prefix;;IP summary address/mask";
        }
      }
      choice option-choice {
        leaf not-advertise {
          tailf:info "Suppress routes that match the specified prefix/mask pair";
          type empty;
        }
        leaf tag {
          tailf:info "Set tag";
          type uint32 {
            tailf:info "<0-4294967295>;;32-bit tag value";
          }
        }
      }
    }

    // router ospf * / address-family ipv4
    container address-family {
      tailf:info "OSPF address family";
      container ipv4 {
        tailf:info "IPV4 address family";
        tailf:cli-delete-when-empty;
        presence true;
        leaf unicast {
          tailf:info "unicast topology";
          type empty;
        }
      }
    }

    // router ospf * / max-metric
    container max-metric {
      tailf:info "Set maximum metric";

      // router ospf * / max-metric router-lsa
      container router-lsa {
        tailf:info "Maximum metric in self-originated router-LSAs";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-ospf-max-metric-grouping;
      }

      // router ospf * / max-metric router-lsa on-startup
      container route-lsa-on-startup {
        tailf:cli-drop-node-name;
        container router-lsa {
          tailf:info "Maximum metric in self-originated router-LSAs";
          container on-startup {
            tailf:info "On startup";
            tailf:cli-compact-syntax;
            tailf:cli-reset-container;
            choice on-startup-choice {
              leaf time {
                tailf:cli-drop-node-name;
                type uint32 {
                  tailf:info "<5-86400>;;Time in seconds to originate router-LSA with max-metric";
                  range "5..86400";
                }
              }
              leaf wait-for-bgp {
                tailf:info "Let BGP decide when to originate router-LSA with normal metric";
                type empty;
              }
            }
            uses router-ospf-max-metric-grouping;
          }
        }
      }

      // router ospf * / max-metric router-lsa on-proc-restart
      container route-lsa-on-proc-restart {
        tailf:cli-drop-node-name;
        container router-lsa {
          tailf:info "Maximum metric in self-originated router-LSAs";
          container on-proc-restart {
            tailf:info "On process restart";
            tailf:cli-compact-syntax;
            tailf:cli-reset-container;
            choice on-startup-choice {
              leaf time {
                tailf:cli-drop-node-name;
                type uint32 {
                  tailf:info "<5-86400>;;Time in seconds to originate router-LSA with max-metric";
                  range "5..86400";
                }
              }
              leaf wait-for-bgp {
                tailf:info "Let BGP decide when to originate router-LSA with normal metric";
                type empty;
              }
            }
            uses router-ospf-max-metric-grouping;
          }
        }
      }
    }

    // router ospf * / snmp
    container snmp {
      tailf:info "SNMP configuration";

      // router ospf * / snmp context
      leaf context {
        tailf:info "Specified SNMP context for OSPF instance";
        type string {
          tailf:info "WORD;;SNMP context name";
        }
      }
    }

    // router ospf * / external-out
    leaf external-out {
      tailf:info "Enable/Disable advertisement of intra-area prefixes as external";
      type enumeration {
        enum disable {
          tailf:info "Disable advertisement of intra-area routes as external";
        }
        enum enable {
          tailf:info "Enable advertisement of intra-area routes as external";
        }
      }
    }

  }

  // router ospfv3 *
  // router ospfv3 * / vrf *
  grouping router-ospfv3-grouping {

    // router ospfv3 * / graceful-restart
    container graceful-restart {
      tailf:info "Enable Graceful-Restart";
      presence true;
    }

    // router ospfv3 * / ?
    uses router-ospfvx-common-pre-grouping;
    uses router-ospfvx-common-post-grouping;

    // router ospfv3 * / address-family ipv6
    container address-family {
      tailf:info "OSPF address family";
      container ipv6 {
        tailf:info "IPV6 address family";
        tailf:cli-delete-when-empty;
        presence true;
        leaf unicast {
          tailf:info "unicast topology";
          type empty;
        }
      }
    }
  }


  grouping router-ospf-max-metric-grouping {

    // router ospf * / max-metric router-lsa include-stub
    leaf include-stub {
      tailf:info "Set maximum metric for stub links in router-LSAs";
      type empty;
    }

    // router ospf * / max-metric router-lsa summary-lsa
    choice summary-lsa-choice {
      container summary-lsa-container {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf summary-lsa {
          type uint32 {
            tailf:info "<1-16777215>;;Overriding metric in summary-LSAs (default 16711680)";
            range "1..16777215";
          }
        }
      }
      leaf summary-lsa {
        tailf:info "Override summary-lsa metric with max-metric value";
        type empty;
      }
    }

    // router ospf * / max-metric router-lsa external-lsa
    choice external-lsa-choice {
      container external-lsa-container {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf external-lsa {
          type uint32 {
            tailf:info "<1-16777215>;;Overriding metric in external-LSAs (default 16711680)";
            range "1..16777215";
          }
        }
      }
      leaf external-lsa {
        tailf:info "Override external-lsa metric with max-metric";
        type empty;
      }
    }
  }


  // router isis * / address-family ipv4 unicast / fast-reroute per-prefix tiebreaker
  // router isis * / address-family ipv4 unicast / fast-reroute per-prefix tiebreaker
  grouping tiebreaker-config-grouping {
    leaf index {
      tailf:info "Set preference order among tiebreakers";
      tailf:cli-incomplete-command;
      tailf:cli-incomplete-no;
      type uint8 {
        tailf:info "<1-255>;;Index";
      }
    }
    leaf level {
      tailf:info "Configure tiebreaker for one level only";
      type uint8 {
        tailf:info "<1-2>;;Level";
      }
    }
  }

  // router isis * / address-family ipv4 unicast /
  // router isis * / address-family ipv6 unicast /
  // router isis * / interface * / address-family ipv4 unicast /
  // router isis * / interface * / address-family ipv6 unicast /
  grouping router-isis-common-af-grouping {

    // router isis * / address-family * / apply-group
    uses apply-group-grouping;

    // router isis * / address-family * / disable
    leaf disable {
      tailf:info "Disable IS-IS for this topology on this interface";
      type empty;
    }

    // router isis * / address-family * / metric
    leaf metric {
      tailf:info "Configure metric";
      tailf:cli-full-command;
      type union {
        type uint32 {
          tailf:info "<1-16777214>;;Default metric: <1-63> for narrow, <1-16777214> for wide";
          range "1..16777214";
        }
        type enumeration {
          enum maximum {
            tailf:info "Maximum wide metric. All routers will exclude this link from their SPF";
          }
        }
      }
    }

    // router isis * / address-family * / metric * level *
    container metric-level {
      tailf:cli-drop-node-name;
      list metric {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key level;
        leaf level {
          tailf:info "Set metric for one level only";
          tailf:cli-expose-key-name;
          type uint8 {
            tailf:info "<1-2>;;Set metric at this level only";
            range "1..2";
          }
        }
        leaf value {
          tailf:cli-prefix-key;
          tailf:cli-drop-node-name;
          type union {
            type uint32 {
              tailf:info "<1-16777214>;;Default metric: <1-63> for narrow, <1-16777214> for wide";
              range "1..16777214";
            }
            type enumeration {
              enum maximum {
                tailf:info "Maximum wide metric. All routers will exclude this link from their SPF";
              }
            }
          }
        }
      }
    }

    // router isis * / address-family * / route source first-hop
    container route {
      tailf:info "Control the advertisement of routes in the RIB";
      container source {
        tailf:info "Control the path source value";
        leaf first-hop {
          tailf:info "Use the IP address of the first-hop";
          type empty;
        }
      }
    }

    // router isis * / address-family * / fast-reroute
    container fast-reroute {
      tailf:info "Configure Fast ReRoute";

      // router isis * / address-family * / fast-reroute per-prefix
      container enable {
        tailf:cli-drop-node-name;
        leaf per-prefix {
          tailf:cli-full-command;
          tailf:cli-full-no;
          tailf:info "Prefix dependent computation";
          type empty;
        }
      }

      choice fast-reroute-choice {
        // router isis * / address-family * / fast-reroute disable
        leaf disable {
          tailf:info "Disable IP Fast Reroute";
          type empty;
        }

        // router isis * / address-family * / fast-reroute per-prefix X
        container per-prefix {
          tailf:info "Prefix dependent computation";
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;

          // router isis * / address-family * / fast-reroute per-prefix level *
          leaf-list level {
            tailf:info "Configure FRR for one level only";
            tailf:cli-list-syntax;
            type uint8 {
              tailf:info "<1-2>;;Level";
              range "1..2";
            }
          }

          // router isis * / address-family * / fast-reroute per-prefix priority-limit
          container priority-limit {
            tailf:info "Limit backup computation upto the prefix priority";
            leaf value {
              tailf:cli-drop-node-name;
              tailf:cli-full-command;
              type enumeration {
                enum critical {
                  tailf:info "Compute for critical priority prefixes only";
                }
                enum high {
                  tailf:info "Compute for critical & high priority prefixes";
                }
                enum medium {
                  tailf:info "Compute for critical, high & medium priority prefixes";
                }
              }
            }
            // router isis * / address-family * / fast-reroute per-prefix priority-limit ? level *
            list level-value {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              key level;
              leaf level {
                tailf:cli-expose-key-name;
                type uint8 {
                  tailf:info "<1-2>;;Level";
                  range "1..2";
                }
              }
              leaf value {
                tailf:cli-drop-node-name;
                tailf:cli-prefix-key;
                type enumeration {
                  enum critical {
                    tailf:info "Compute for critical priority prefixes only";
                  }
                  enum high {
                    tailf:info "Compute for critical & high priority prefixes";
                  }
                  enum medium {
                    tailf:info "Compute for critical, high & medium priority prefixes";
                  }
                }
              }
            }
          }

          // router isis * / address-family * / fast-reroute per-prefix srlg-protection weighted-global
          container srlg-protection {
            tailf:info "Type of SRLG protection";
            leaf weighted-global {
              tailf:info "Weighted global SRLG protection";
              type empty;
            }
          }

          // router isis * / address-family * / fast-reroute per-prefix remote-lfa
          container remote-lfa {
            tailf:info "Enable remote LFA computation";

            // router isis * / address-family * / fast-reroute per-prefix remote-lfa tunnel mpls-ldp
            container tunnel {
              tailf:info "Enable remote LFA computation using tunnels";

              // router isis * / address-family * / fast-reroute per-prefix remote-lfa tunnel mpls-ldp
              container mpls-ldp {
                tailf:info "Use MPLS LDP tunnel to reach the remote LFA node";
                presence true;
              }

              // router isis * / address-family * / fast-reroute per-prefix remote-lfa tunnel mpls-ldp ? level *
              container mpls-ldp-level {
                tailf:cli-drop-node-name;
                container mpls-ldp {
                  tailf:info "Use MPLS LDP tunnel to reach the remote LFA node";
                  list level {
                    tailf:info "Enable remote LFA for one level only";
                    tailf:cli-suppress-mode;
                    tailf:cli-delete-when-empty;
                    key level;
                    leaf level {
                      type uint8 {
                        tailf:info "<1-2>;;Level";
                        range "1..2";
                      }
                    }
                  }
                }
              }
            }

            // router isis * / address-family * / fast-reroute per-prefix remote-lfa maximum-metric
            leaf maximum-metric {
              tailf:info "Limit remote LFA node selection within the metric";
              tailf:cli-full-command;
              tailf:cli-full-no;
              type uint32 {
                tailf:info "<1-16777215>;;Value of the metric";
                range "1..16777215";
              }
            }

            // router isis * / address-family * / fast-reroute per-prefix remote-lfa maximum-metric ? level *
            container maximum-metric-level {
              tailf:cli-drop-node-name;
              list maximum-metric {
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                tailf:cli-sequence-commands;
                key level;
                leaf value {
                  tailf:cli-drop-node-name;
                  tailf:cli-prefix-key;
                  type uint32 {
                    tailf:info "<1-16777215>;;Value of the metric";
                    range "1..16777215";
                  }
                }
                leaf level {
                  tailf:cli-expose-key-name;
                  type uint8 {
                    tailf:info "<1-2>;;Level";
                    range "1..2";
                  }
                }
              }
            }
          }

          // router isis * / address-family * / fast-reroute per-prefix ti-lfa
          container ti-lfa {
            tailf:info "Enable TI LFA computation";
            tailf:cli-full-command;
            tailf:cli-full-no;
            presence true;
          }

          // router isis * / address-family * / fast-reroute per-prefix ti-lfa level *
          container ti-lfa-level {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            tailf:cli-incomplete-no;
            container ti-lfa {
              tailf:info "Use MPLS LDP tunnel to reach the remote LFA node";
              tailf:cli-incomplete-command;
              tailf:cli-incomplete-no;
              list level {
                tailf:info "Enable remote LFA for one level only";
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                key level;
                leaf level {
                  type uint8 {
                    tailf:info "<1-2>;;Level";
                    range "1..2";
                  }
                }
              }
            }
          }

          // router isis * / address-family * / fast-reroute per-prefix tiebreaker
          container tiebreaker {
            tailf:info "Configure tiebreaker for multiple backups";

            // router isis * / address-family * / fast-reroute per-prefix tiebreaker default
            container default {
              tailf:info "Prefer default (link protecting) backup path";
              leaf level {
                type uint8 {
                  tailf:info "<1-2>;;Level";
                }
              }
            }

            // router isis * / address-family * / fast-reroute per-prefix tiebreaker lowest-backup-metric
            container lowest-backup-metric {
              tailf:info "Prefer backup path with lowest total metric";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              uses tiebreaker-config-grouping;
            }
            container lowest-backup-metric-nolevel {
              tailf:cli-drop-node-name;
              container lowest-backup-metric {
                tailf:info "Prefer backup path with lowest total metric";
                leaf index {
                  tailf:info "Set preference order among tiebreakers";
                  tailf:cli-full-command;
                  type uint8 {
                    tailf:info "<1-255>;;Index";
                  }
                }
              }
            }

            // router isis * / address-family * / fast-reroute per-prefix tiebreaker node-protecting
            container node-protecting {
              tailf:info "Prefer node protecting backup path";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              uses tiebreaker-config-grouping;
            }
            container node-protecting-nolevel {
              tailf:cli-drop-node-name;
              container node-protecting {
                tailf:info "Prefer node protecting backup path";
                leaf index {
                  tailf:info "Set preference order among tiebreakers";
                  tailf:cli-full-command;
                  type uint8 {
                    tailf:info "<1-255>;;Index";
                  }
                }
              }
            }

            // router isis * / address-family * / fast-reroute per-prefix tiebreaker primary-path
            container primary-path {
              tailf:info "Prefer backup path from ECMP set";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              uses tiebreaker-config-grouping;
            }
            container primary-path-nolevel {
              tailf:cli-drop-node-name;
              container primary-path {
                tailf:info "Prefer backup path from ECMP set";
                leaf index {
                  tailf:info "Set preference order among tiebreakers";
                  tailf:cli-full-command;
                  type uint8 {
                    tailf:info "<1-255>;;Index";
                  }
                }
              }
            }

            // router isis * / address-family * / fast-reroute per-prefix tiebreaker srlg-disjoint
            container srlg-disjoint {
              tailf:info "Prefer SRLG disjoint backup path";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              uses tiebreaker-config-grouping;
            }
            container srlg-disjoint-nolevel {
              tailf:cli-drop-node-name;
              container srlg-disjoint {
                tailf:info "Prefer SRLG disjoint backup path";
                leaf index {
                  tailf:info "Set preference order among tiebreakers";
                  tailf:cli-full-command;
                  type uint8 {
                    tailf:info "<1-255>;;Index";
                  }
                }
              }
            }
          }
        }
      }
    }

    // router isis * / address-family * / mpls
    container mpls {
      tailf:info "Configure MPLS routing protocol parameters";

      // router isis * / address-family * / mpls ldp
      container ldp {
        tailf:info "Configure LDP parameters";
        leaf auto-config {
          tailf:info "Enable LDP IGP interface auto-configuration";
          type empty;
        }
        // router isis * / address-family * / mpls ldp sync
        container sync {
          tailf:info "Configure LDP ISIS synchronization";
          presence true;
          leaf level {
            type uint8 {
              tailf:info "<1-2>;;Set LDP synchronization at this level only";
              range "1..2";
            }
          }
        }
      }

      // router isis * / address-family * / mpls traffic-eng
      container traffic-eng {
        tailf:info "Routing protocol commands for MPLS Traffic Engineering";

        // router isis * / address-family * / mpls traffic-eng level
        leaf level {
          tailf:cli-drop-node-name;
          tailf:cli-full-command;
          type enumeration {
            enum level-1 {
              tailf:info "Enable mpls traffic-eng at level 1";
            }
            enum level-1-2 {
              tailf:info "Enable mpls traffic-eng at both level 1 and 2";
            }
            enum level-2-only {
              tailf:info "Enable mpls traffic-eng at level 2";
            }
          }
        }

        // router isis * / address-family * / mpls traffic-eng router-id
        choice router-id-choice {
          container router-id {
            tailf:info "Traffic Engineering stable IP address for system";
            uses interface-name-grouping;
          }
          container router-id-address {
            tailf:cli-drop-node-name;
            leaf router-id {
              tailf:info "Stable IP address for system";
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Router ID address";
              }
            }
          }
        }

        // router isis * / address-family * / mpls traffic-eng igp-intact
        leaf igp-intact {
          tailf:info "Install both TE and non-TE nexthops in the RIB.";
          type empty;
        }

        // router isis * / address-family * / mpls traffic-eng multicast-intact
        leaf multicast-intact {
          tailf:info "Install non-TE nexthops in the RIB for use by multicast";
          tailf:cli-full-command;
          type empty;
        }

        // router isis * / address-family * / mpls traffic-eng tunnel restricted
        container tunnel {
          tailf:info "Tunnel selection";
          leaf restricted {
            tailf:info "Use only primary tunnel for destination IP address";
            type empty;
          }
        }
      }
    }

    // router isis * / address-family * / router-id
    choice router-id-choice {
      container router-id {
        tailf:info "Stable IP address for system";
        uses interface-name-grouping;
      }
      container router-id-address {
        tailf:cli-drop-node-name;
        leaf router-id {
          tailf:info "Stable IP address for system";
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Router ID address";
          }
        }
      }
    }

    // router isis * / address-family * / monitor-convergence
    container monitor-convergence {
      tailf:info "Enables convergence monitoring";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-isis-af-rcmd";
      tailf:cli-delete-when-empty;
      presence true;

      // router isis * / address-family * / monitor-convergence / track-ip-frr
      leaf track-ip-frr {
        tailf:info "Enables Tracking IP-Frr Convergence";
        type empty;
      }
    }

    // router isis * / interface * / address-family ? unicast / tag
    leaf tag {
      tailf:info "Set interface tag";
      tailf:cli-full-command;
      type uint32 {
        tailf:info "<1-4294967295>;;Interface tag";
      }
    }

    // router isis * / interface * / address-family ? unicast / tag ? level *
    container tag-level {
      tailf:cli-drop-node-name;
      list tag {
        tailf:info "Set interface tag";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-sequence-commands;
        key level;
        leaf value {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type uint32 {
            tailf:info "<1-4294967295>;;Interface tag";
          }
        }
        leaf level {
          tailf:cli-expose-key-name;
          tailf:info "Set the tag only at supplied level";
          type uint8 {
            tailf:info "<1-2>;;Level";
            range "1..2";
          }
        }
      }
    }
  }

  // router isis * / address-family ipv4 unicast /
  // router isis * / address-family ipv6 unicast /
  grouping router-isis-af-grouping {

    // router isis * / address-family * / summary-prefix *
    list summary-prefix {
      tailf:info "Configure IP address summaries";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      key prefix;
      leaf prefix {
        type union {
          type ipv4-prefix {
            tailf:info "A.B.C.D/prefix;;IP summary address/mask";
          }
          type tailf:ipv6-address-and-prefix-length {
            tailf:info "X:X::X/length;;IPv6 summary prefix";
          }
        }
      }
      leaf tag {
        tailf:info "Set tag";
        tailf:cli-optional-in-sequence;
        type uint32 {
          tailf:info "<0-4294967295>;;32-bit tag value";
        }
      }
      leaf level {
        tailf:info "Summarize routes in one level only";
        type uint8 {
          tailf:info "<1-2>;;Level";
          range "1..2";
        }
      }
    }

    // router isis * / address-family * / advertise
    container advertise {
      tailf:info "Control the advertisement of prefixes in LSPs";

      // router isis * / address-family * / advertise application lfa link-attributes srlg
      container application {
        tailf:info "Application Specific Data";
        container lfa {
          tailf:info "LFA Application";
          container link-attributes {
            tailf:info "Application Specific Link Attributes";
            leaf srlg {
              tailf:info "Shared Risk Ling Group";
              type empty;
            }
          }
        }
      }

      // router isis * / address-family * / advertise passive-only
      leaf passive-only {
        tailf:info "advertise prefixes of passive interfaces only";
        type empty;
      }

      // router isis * / address-family * / advertise link attributes
      container link {
        tailf:info "IS Neighbor attributes";
        leaf attributes {
          tailf:info "Advertise additional link attributes";
          type empty;
        }
      }
    }

    // router isis * / address-family * / ispf
    leaf ispf {
      tailf:info "Use incremental SPF (ISPF) to calculate network topology";
      tailf:cli-full-command;
      type empty;
    }

    // router isis * / address-family * / ispf level
    container ispf-conf {
      tailf:cli-drop-node-name;
      container ispf {
        tailf:info "Use incremental SPF (ISPF) to calculate network topology";
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        leaf-list level {
          tailf:info "Enable ISPF for one level only";
          tailf:cli-list-syntax;
          type uint8 {
            tailf:info "<1-2>;;Enable ISPF for this level onl";
            range "1..2";
          }
        }
      }
    }

    // router isis * / address-family * / spf-interval * level
    container spf-interval-level {
      tailf:cli-drop-node-name;
      list spf-interval {
        tailf:info "Route calculation scheduling parameters (FSPF, ISPF, PRC)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key level;
        leaf level {
          tailf:cli-expose-key-name;
          tailf:info "Set SPF interval for one level only";
          type uint8 {
            tailf:info "<1-2>;;Level";
            range "1..2";
          }
        }
        leaf maximum-wait {
          tailf:info "Maximum delay before running a route calculation";
          tailf:cli-prefix-key;
          type uint32 {
            tailf:info "<0-120000>;;Delay in milliseconds";
            range "0..120000";
          }
        }
        leaf initial-wait {
          tailf:info "Initial delay before running a route calculation";
          tailf:cli-optional-in-sequence;
          tailf:cli-prefix-key;
          type uint32 {
            tailf:info "<0-120000>;;Delay in milliseconds";
            range "0..120000";
          }
        }
        leaf secondary-wait {
          tailf:info "Secondary delay before running a route calculation";
          tailf:cli-optional-in-sequence;
          tailf:cli-prefix-key;
          type uint32 {
            tailf:info "<0-120000>;;Delay in milliseconds";
            range "0..120000";
          }
        }
      }
    }

    // router isis * / address-family * / spf-interval
    container spf-interval {
      tailf:info "Route calculation scheduling parameters (FSPF, ISPF, PRC)";
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      leaf maximum-wait {
        tailf:info "Maximum delay before running a route calculation";
        type uint32 {
          tailf:info "<0-120000>;;Delay in milliseconds";
          range "0..120000";
        }
      }
      leaf initial-wait {
        tailf:info "Initial delay before running a route calculation";
        type uint32 {
          tailf:info "<0-120000>;;Delay in milliseconds";
          range "0..120000";
        }
      }
      leaf secondary-wait {
        tailf:info "Secondary delay before running a route calculation";
        type uint32 {
          tailf:info "<0-120000>;;Delay in milliseconds";
          range "0..120000";
        }
      }
    }

    // router isis * / address-family * / attached-bit
    container attached-bit {
      tailf:info "Modify behavior of the attached-bit";

      // router isis * / address-family * / attached-bit receive
      leaf receive {
        tailf:info "Modify how we treat received attached bits";
        type enumeration {
          enum ignore {
            tailf:info "Ignore the attached bit in received LSPs";
          }
        }
      }

      // router isis * / address-family * / attached-bit send
      leaf send {
        tailf:info "Modify how we set the attached bit";
        type enumeration {
          enum always-set {
            tailf:info "Always set the attached bit in our LSP";
          }
          enum never-set {
            tailf:info "Never set the attached bit our LSP";
          }
        }
      }
    }

    // router isis * / address-family * / distribute-list *
    list distribute-list {
      tailf:info "Filter networks in routing updates";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-remove-before-change;
      key direction;
      leaf direction {
        type enumeration {
          enum "in" {
            tailf:info "Filter routes sent to RIB";
          }
        }
      }
      choice filter-choice {
        leaf route-policy {
          tailf:info "Filter routes based on a route policy";
          tailf:cli-prefix-key;
          tailf:cli-suppress-leafref-in-diff;
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:route-policy/name";
          }
          type string {
            tailf:info "WORD;;Name of the policy";
          }
        }
        leaf prefix-list {
          tailf:info "Filter routes based on a prefix list";
          tailf:cli-prefix-key;
          tailf:cli-suppress-leafref-in-diff;
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:ipv4/prefix-list/name";
          }
          type string {
            tailf:info "WORD;;Prefix-list name";
          }
        }
      }
    }

    // router isis * / address-family * / distance
    container distance {
      tailf:info "Configure IS-IS administrative distances";

      // router isis * / address-family * / distance
      leaf value {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<1-255>;;Administrative distance";
          range "1..255";
        }
      }

      // router isis * / address-family * / distance *
      list prefix-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        key prefix;
        leaf value {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type uint8 {
            tailf:info "<1-255>;;Administrative distance";
            range "1..255";
          }
        }
        leaf prefix {
          type union {
            type ipv4-prefix {
              tailf:info "A.B.C.D/length;;Route source for this distance";
            }
            type tailf:ipv6-address-and-prefix-length {
              tailf:info "X:X::X/length;;Route source for this distance";
            }
          }
        }
        leaf prefix-list-name {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;List of routes to which this distance applies";
          }
        }
      }
    }

    // router isis * / address-family * / single-topology
    leaf single-topology {
      tailf:info "Run IPv6 Unicast using the standard (IPv4 Unicast) topology";
      type empty;
    }

    // router isis * / address-family * / adjacency-check disable
    container adjacency-check {
      tailf:info "Suppress checking of consistent AF support on received IIHs";
      leaf disable {
        tailf:info "Disable adjacency-checking";
        type empty;
      }
    }

    // router isis * / address-family * / spf
    container spf {
      tailf:info "SPF configuration";

      // router isis * / address-family * / spf periodic
      container periodic {
        tailf:info "Configure the periodic SPF(cisco-support)";

        // router isis * / address-family * / spf periodic disable
        leaf disable {
          tailf:info "Disable the periodic SPF";
          type empty;
        }
      }

      // router isis * / address-family * / spf prefix-priority *
      list prefix-priority {
        tailf:info "Configure a prefix priority list";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key priority;
        leaf priority {
          type enumeration {
            enum critical {
              tailf:info "Specify critical priority prefixes";
            }
            enum high {
              tailf:info "Specify critical priority prefixes";
            }
            enum medium {
              tailf:info "Specify critical priority prefixes";
            }
          }
        }
        choice priority-type {
          leaf access-list {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-leafref-in-diff;
            tailf:non-strict-leafref {
              path "/cisco-ios-xr:ethernet-services/access-list/name";
            }
            type string {
              tailf:info "WORD;;Access-list name";
            }
          }
          leaf tag {
            tailf:info "Specify a tag to indicate priority";
            type uint32 {
              tailf:info "<1-4294967295>;;The tag to indicate priority";
            }
          }
        }
      }

      container prefix-priority-level {
        tailf:cli-drop-node-name;
        list prefix-priority {
          tailf:info "Configure a prefix priority list";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key "level priority";
          leaf level {
            tailf:info "Configure SPF prefix priority list for one level only";
            tailf:cli-expose-key-name;
            type uint8 {
              tailf:info "<1-2>;;Level";
            }
          }
          leaf priority {
            type enumeration {
              enum critical {
                tailf:info "Specify critical priority prefixes";
              }
              enum high {
                tailf:info "Specify critical priority prefixes";
              }
              enum medium {
                tailf:info "Specify critical priority prefixes";
              }
            }
          }
          choice priority-type {
            leaf access-list {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-leafref-in-diff;
              tailf:non-strict-leafref {
                path "/cisco-ios-xr:ethernet-services/access-list/name";
              }
              type string {
                tailf:info "WORD;;Access-list name";
              }
            }
            leaf tag {
              tailf:info "Specify a tag to indicate priority";
              type uint32 {
                tailf:info "<1-4294967295>;;The tag to indicate priority";
              }
            }
          }
        }
      }

    }

    // router isis * / address-family * / default-information
    container default-information {
      tailf:info "Control distribution of default information";
      container originate {
        tailf:info "Distribute a default route";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        tailf:cli-reset-container;
        presence true;
        leaf external {
          tailf:info "Originate default prefix as an external route";
          type empty;
        }
        leaf route-policy {
          tailf:info "Route policy reference";
          tailf:cli-suppress-leafref-in-diff;
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:route-policy/name";
          }
          type string {
            tailf:info "WORD;;Name of the policy";
          }
        }
      }
    }

    // router isis * / address-family * / maximum-paths
    leaf maximum-paths {
      tailf:info "Maximum number of active parallel paths per route";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<1-64>;;Number of paths";
        range "1..64";
      }
    }

    // router isis * / address-family * / maximum-redistributed-prefixes
    leaf maximum-redistributed-prefixes {
      tailf:info "Maximum number of redistributed prefixes";
      tailf:cli-full-command;
      tailf:cli-full-no;
      type uint16 {
        tailf:info "<1-28000>;;maximum limit on number of redistributed prefixes";
        range "1..28000";
      }
    }

    // router isis * / address-family * / maximum-redistributed-prefixes ? level *
    container maximum-redistributed-prefixes-level {
      tailf:cli-drop-node-name;
      list maximum-redistributed-prefixes {
        tailf:info "Maximum number of redistributed prefixes";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-sequence-commands;
        key level;
        leaf value {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type uint16 {
            tailf:info "<1-28000>;;maximum limit on number of redistributed prefixes";
            range "1..28000";
          }
        }
        leaf level {
          tailf:cli-expose-key-name;
          tailf:info "Set maximum redistributed prefixes for one level only";
          type uint8 {
            tailf:info "<1-2>;;Level";
            range "1..2";
          }
        }
      }
    }

    // router isis * / address-family * / propagate level
    container propagate {
      tailf:info "Propagate routes between IS-IS levels";
      list level {
        tailf:info "Source level";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        key "from level";
        leaf from {
          type uint8 {
            tailf:info "<1-2>;;Level";
            range "1..2";
          }
        }
        leaf into {
          tailf:info "into";
          tailf:cli-prefix-key {
            tailf:cli-before-key 2;
          }
          type empty;
        }
        leaf level {
          tailf:info "Destination level";
          tailf:cli-expose-key-name;
          type uint8 {
            tailf:info "<1-2>;;Level";
            range "1..2";
          }
        }
        leaf route-policy {
          tailf:info "Propagate only specified routes";
          tailf:cli-suppress-leafref-in-diff;
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:route-policy/name";
          }
          type string {
            tailf:info "WORD;;Name of the policy";
          }
        }
      }
    }

    // router isis * / address-family * / microloop avoidance
    container microloop {
      tailf:info "Enable microloop protection feature";
      container avoidance {
        tailf:info "Enable local microloop avoidance";

        // router isis * / address-family * / microloop avoidance segment-routing
        leaf segment-routing {
          tailf:info "Enable segment routing microloop avoidance";
          type empty;
        }

        // router isis * / address-family * / microloop avoidance rib-update-delay
        leaf rib-update-delay {
          tailf:info "Delay in milliseconds";
          type uint16 {
            tailf:info "<1000-65535>;;Set value of delay";
            range "1000..65535";
          }
        }

        // router isis * / address-family * / microloop avoidance protected
        leaf protected {
          tailf:info "Enable microloop avoidance for only protected prefixes";
          type empty;
        }
      }
    }

    // router isis * / address-family * / redistribute
    container redistribute {
      tailf:info "Redistribute information from another routing protocol";

      // router isis * / address-family * / redistribute connected
      container connected {
        tailf:info "Connected routes";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-isis-af-redistribute-grouping;
      }

      // router isis * / address-family * / redistribute static
      container static {
        tailf:info "Static route";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-isis-af-redistribute-grouping;
      }

      // router isis * / address-family * / redistribute isis *
      list isis {
        tailf:info "IS-IS";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key name;
        leaf name {
          tailf:cli-suppress-range;
          type string {
            tailf:info "IS-IS instance identifier";
          }
        }
        uses router-isis-af-redistribute-grouping;
      }

      // router isis * / address-family * / redistribute bgp *
      list bgp {
        tailf:info "Border Gateway Protocol (BGP)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          tailf:cli-suppress-range;
          type string {
            tailf:info "WORD;;BGP process ID";
          }
        }
        uses router-isis-af-redistribute-grouping;
      }

      // router isis * / address-family * / redistribute ospf *
      list ospf {
        tailf:info "Open Shortest Path First (OSPF)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          tailf:cli-suppress-range;
          type string {
            tailf:info "WORD;;OSPF process ID";
          }
        }
        leaf match {
          tailf:info "Redistribution of OSPF routes";
          type enumeration {
            enum "external" {
              tailf:info "Redistribute OSPF external routes";
            }
            enum "internal" {
              tailf:info "Redistribute OSPF internal routes";
            }
            enum "nssa-external" {
              tailf:info "Redistribute OSPF NSSA external routes";
            }
          }
        }
        uses router-isis-af-redistribute-grouping;
      }

      // router isis * / address-family * / redistribute ospfv3 *
      list ospfv3 {
        tailf:info "Open Shortest Path First (OSPFv3)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          tailf:cli-suppress-range;
          type string {
            tailf:info "WORD;;OSPF process ID";
          }
        }
        leaf match {
          tailf:info "Redistribution of OSPF routes";
          type enumeration {
            enum "external" {
              tailf:info "Redistribute OSPF external routes";
            }
            enum "internal" {
              tailf:info "Redistribute OSPF internal routes";
            }
            enum "nssa-external" {
              tailf:info "Redistribute OSPF NSSA external routes";
            }
          }
        }
        uses router-isis-af-redistribute-grouping;
      }
    }

    // router isis * / address-family * / ucmp
    container ucmp {
      tailf:info "UnEqual Cost Multipath feature";
      presence true;
    }

    // router isis * / address-family * / segment-routing
    container segment-routing {
      tailf:info "Enable Segment Routing Feature";

      // router isis * / address-family * / segment-routing mpls
      container mpls {
        tailf:info "Enable Segment Routing Feature using MPLS encapsulation";
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;

        // router isis * / address-family * / segment-routing mpls sr-prefer
        leaf sr-prefer {
          tailf:info "Prefer segment routing labels over LDP labels";
          type empty;
        }
      }

      // router isis * / address-family * / segment-routing prefix-sid-map
      container prefix-sid-map {
        tailf:info "Enable prefix-sid-map";

        // router isis * / address-family * / segment-routing prefix-sid-map receive
        container receive {
          tailf:info "Use remote mapping server advertisements";
          presence true;
        }

        // router isis * / address-family * / segment-routing prefix-sid-map advertise-local
        leaf advertise-local {
          tailf:info "Advertise active local prefix-SID mappings";
          type empty;
        }
      }

      // router isis * / address-family * / segment-routing srv6
      container srv6 {
        tailf:info "Enable SRv6";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-isis-srv6";
        presence true;

        // router isis * / address-family * / segment-routing srv6 / locator *
        list locator {
          tailf:info "Enter SRv6 Locator submode";
          tailf:cli-mode-name "config-isis-srv6-loc";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Locator name";
            }
          }
        }
      }
    }
  }

  // router isis *
  // router isis * / address-family ipv4 unicast /
  // router isis * / address-family ipv6 unicast /
  grouping router-isis-common-grouping {

    // router isis * / metric-style
    leaf metric-style {
      tailf:info "Use old-style (ISO 10589) or new-style packet formats";
      tailf:cli-full-command;
      type enumeration {
        enum narrow {
          tailf:info "Use old style of TLVs with narrow metric";
        }
        enum transition {
          tailf:info "Send and accept both styles of TLVs during transition";
        }
        enum wide {
          tailf:info "Use new style of TLVs to carry wider metric";
        }
      }
    }

    // router isis * / metric-style ? level *
    container metric-style-list {
      tailf:cli-drop-node-name;
      list metric-style {
        tailf:info "Use old-style (ISO 10589) or new-style packet formats";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-sequence-commands;
        key level;
        leaf level {
          tailf:cli-expose-key-name;
          tailf:info "Set metric-style for one level only";
          type uint8 {
            tailf:info "<1-2>;;Level";
            range "1..2";
          }
        }
        leaf style {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type enumeration {
            enum narrow {
              tailf:info "Use old style of TLVs with narrow metric";
            }
            enum transition {
              tailf:info "Send and accept both styles of TLVs during transition";
            }
            enum wide {
              tailf:info "Use new style of TLVs to carry wider metric";
            }
          }
        }
      }
    }
  }

  // router isis * / interface * / address-family ipv4 unicast /
  // router isis * / interface * / address-family ipv6 unicast /
  grouping router-isis-if-af-grouping {

    // router isis * / interface * / address-family ipv4 unicast / prefix-sid
    container prefix-sid {
      tailf:info "Specify the Prefix Segment ID";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      choice value-choice {
        leaf absolute {
          tailf:info "Specify the absolute value of Prefix Segement ID";
          type uint32 {
            tailf:info "<0-1048575>;;The Prefix Segment ID value";
            range "0..1048575";
          }
        }
        leaf index {
          tailf:info "Specify the index of Prefix Segement ID";
          type uint32 {
            tailf:info "<0-1048575>;;The Prefix Segment ID value";
            range "0..1048575";
          }
        }
      }
      leaf explicit-null {
        tailf:info "Upstream neighbor must replace prefix-sid with explicit null label";
        tailf:cli-optional-in-sequence;
        type empty;
      }
      leaf n-flag-clear {
        tailf:info "Clear N-flag for the prefix-SID";
        type empty;
      }
    }

    // router isis * / interface * / address-family ipv4 unicast / prefix-sid algorithm *
    container prefix-sid-algorithm {
      tailf:cli-drop-node-name;
      container prefix-sid {
        tailf:info "Specify the Prefix Segment ID";
        list algorithm {
          tailf:info "Algorithm Specific Prefix SID Configuration";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          key id;
          leaf id {
            type uint8 {
              tailf:info "<128-255>;;Algorithm number";
              range "128..255";
            }
          }
          choice value-choice {
            leaf absolute {
              tailf:info "Specify the absolute value of Prefix Segement ID";
              type uint32 {
                tailf:info "<0-1048575>;;The Prefix Segment ID value";
                range "0..1048575";
              }
            }
            leaf index {
              tailf:info "Specify the index of Prefix Segement ID";
              type uint32 {
                tailf:info "<0-1048575>;;The Prefix Segment ID value";
                range "0..1048575";
              }
            }
          }
          leaf explicit-null {
            tailf:info "Upstream neighbor must replace prefix-sid with explicit null label";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          leaf n-flag-clear {
            tailf:info "Clear N-flag for the prefix-SID";
            type empty;
          }
        }
      }
    }

    // router isis * / interface * / address-family ipv4 unicast / prefix-sid strict-spf
    container prefix-sid-strict-spf {
      tailf:cli-drop-node-name;
      container prefix-sid {
        tailf:info "Specify the Prefix Segment ID";
        container strict-spf {
          tailf:info "Strict-SPF Prefix SID Configuration";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          choice value-choice {
            leaf absolute {
              tailf:info "Specify the absolute value of Prefix Segement ID";
              type uint32 {
                tailf:info "<0-1048575>;;The Prefix Segment ID value";
                range "0..1048575";
              }
            }
            leaf index {
              tailf:info "Specify the index of Prefix Segement ID";
              type uint32 {
                tailf:info "<0-1048575>;;The Prefix Segment ID value";
                range "0..1048575";
              }
            }
          }
          leaf explicit-null {
            tailf:info "Upstream neighbor must replace prefix-sid with explicit null label";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          leaf n-flag-clear {
            tailf:info "Clear N-flag for the prefix-SID";
            type empty;
          }
        }
      }
    }
  }

  // vty-pool-grouping
  grouping vty-pool-grouping {
    leaf first-vty {
      tailf:cli-drop-node-name;
      type uint16 {
        tailf:info "<5-99>;;First VTY number";
      }
    }
    leaf last-vty {
      tailf:cli-drop-node-name;
      type uint16 {
        tailf:info "<5-99>;;Last VTY number";
      }
    }
    leaf line-template {
      tailf:info "Line template to configure VTYs";
      tailf:cli-optional-in-sequence;
      type string {
        tailf:info "WORD;;Name of line template";
      }
    }
  }


  // line console /
  // line default /
  // line template * /
  grouping line-grouping {

    // line * / flowcontrol hardware
    container flowcontrol {
      tailf:info "Configure flow control.";
      container hardware {
        tailf:info "Hardware flow control.";
        leaf direction {
          tailf:cli-drop-node-name;
          type enumeration {
            enum in {
              tailf:info "Inbound flow control.";
            }
            enum none {
              tailf:info "No flow control.";
            }
            enum out {
              tailf:info "Outbound flow control.";
            }
          }
        }
      }
    }

    // line * / parity
    leaf parity {
      tailf:info "Set the parity used.";
      type enumeration {
        enum even {
          tailf:info "Even parity.";
        }
        enum none {
          tailf:info "No parity.";
        }
        enum odd {
          tailf:info "Odd parity.";
        }
      }
    }

    // line * / databits
    leaf databits {
      tailf:info "Set the number of databits.";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<5-8>;;Number of databits the serial connection should use.";
      }
    }

    // line * / stopbits
    leaf stopbits {
      tailf:info "Set the stopbits used.";
      tailf:cli-full-command;
      type enumeration {
        enum "1" {
          tailf:info "One stopbit.";
        }
        enum "2" {
          tailf:info "Two stopbits.";
        }
      }
    }

    // line * / access-class
    container access-class {
      tailf:info "Filter connections based on an IP access list";
      leaf egress {
        tailf:info "Filter outgoing connections";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;IP access list name";
        }
      }
      leaf ingress {
        tailf:info "Filter incoming connections";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;IP access list name";
        }
      }
    }

    // line * / secret
    container secret {
      tailf:info "Provide a secure one way encrypted password";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf type {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type enumeration {
          enum "0" {
            tailf:info "Specifies an UNENCRYPTED password will follow";
          }
          enum "5" {
            tailf:info "Specifies an ENCRYPTED secret will follow";
          }
        }
      }
      leaf secret {
        tailf:cli-drop-node-name;
        cisco-ios-xr:maapi-encrypted;
        type NEDCOM_SECRET_TYPE {
          tailf:info "LINE;;The ENCRYPTED 'enable' secret string";
        }
      }
    }

    // line * / password
    container password {
      tailf:info "Specify the password for the user";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf encryption {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum 0 {
            tailf:info "Specifies that an UNENCRYPTED password will follow";
          }
          enum 7 {
            tailf:info "Specifies that an encrypted password will follow";
          }
        }
      }
      leaf password {
        tailf:cli-drop-node-name;
        tailf:cli-reset-container;
        tailf:cli-disallow-value "0|7";
        cli:secret " password <SECRET>";
        type NEDCOM_SECRET_TYPE {
          tailf:info "LINE;;The UNENCRYPTED (cleartext) user password";
        }
      }
    }

    // line * / users group *
    container users {
      tailf:info "Users characteristics";
      list group {
        tailf:info "Group to which the user will belong";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of the user group";
          }
        }
      }
    }

    // line * / accounting
    container accounting {
      tailf:info "Accounting parameters";

      // line * / accounting commands
      leaf commands {
        tailf:info "For exec (shell) commands";
        type union {
          type enumeration {
            enum "default" {
              tailf:info "Use the default accounting list";
            }
          }
          type string {
            tailf:info "WORD;;Use an accounting list with this name";
          }
        }
      }

      // line * / accounting exec
      leaf exec {
        tailf:info "For exec (shell) commands";
        type union {
          type enumeration {
            enum "default" {
              tailf:info "Use the default accounting list";
            }
          }
          type string {
            tailf:info "WORD;;Use an accounting list with this name";
          }
        }
      }
    }

    // line * / authorization
    container authorization {
      tailf:info "Authorization parameters";

      // line * / authorization commands
      leaf commands {
        tailf:info "For exec (shell) commands";
        type union {
          type enumeration {
            enum "default" {
              tailf:info "Use the default authorization list";
            }
          }
          type string {
            tailf:info "WORD;;Use an authorization list with this name";
          }
        }
      }

      // line * / authorization exec
      leaf exec {
        tailf:info "For starting an exec (shell)";
        type union {
          type enumeration {
            enum "default" {
              tailf:info "Use the default authorization list";
            }
          }
          type string {
            tailf:info "WORD;;Use an authorization list with this name";
          }
        }
      }
    }

    // line * / timeout login response
    container timeout {
      tailf:info "Timeouts for the line";
      container login {
        tailf:info "Timeouts related to the login sequence";
        leaf response {
          tailf:info "Timeouts for any user input during login sequence";
          type uint16 {
            tailf:info "<0-300>;;Timeout in seconds (default 30 seconds)";
            range "0..300";
          }
        }
      }
    }

    // line * / timestamp
    container timestamp {
      tailf:info "To enable timestamp printing before each command.";
      tailf:cli-delete-when-empty;
      tailf:cli-reset-container;
      presence true;
      leaf disable {
        tailf:info "To disable timestamp printing before each command.";
        type empty;
      }
    }

    // line * / transport
    container transport {
      tailf:info "Define transport protocols for line";

      // line * / transport input
      leaf-list input {
        tailf:info "Define which protocols to use when connecting to the terminal server";
        tailf:cli-flat-list-syntax;
        tailf:cli-replace-all;
        tailf:cli-no-value-on-delete;
        type enumeration {
          enum all {
            tailf:info "All protocols";
          }
          enum none {
            tailf:info "No protocols";
          }
          enum ssh {
            tailf:info "TCP/IP SSH protocol";
          }
          enum telnet {
            tailf:info "TCP/IP Telnet protocol";
          }
          enum lat {
            //tailf:info
          }
          enum pad {
            tailf:info "X.3 PAD";
          }
          enum udptn {
            tailf:info "UDPTN async via UDP protocol";
          }
          enum rlogin {
            tailf:info "Unix rlogin protocol";
          }
        }
      }

      // line * / transport output
      leaf-list output {
        tailf:info "Define which protocols to use for outgoing connections";
        tailf:cli-flat-list-syntax;
        tailf:cli-replace-all;
        tailf:cli-no-value-on-delete;
        type enumeration {
          enum all {
            tailf:info "All protocols";
          }
          enum none {
            tailf:info "No protocols";
          }
          enum ssh {
            tailf:info "TCP/IP SSH protocol";
          }
          enum telnet {
            tailf:info "TCP/IP Telnet protocol";
          }
        }
      }

      // line * / pager
      leaf pager {
        tailf:info "To enable pager functionality";
        type enumeration {
          enum none {
            tailf:info "No Pagers";
          }
          enum more {
            tailf:info "More Utility";
          }
          enum less {
            tailf:info "Less Utility";
          }
        }
      }

      // line * / transport preferred
      leaf preferred {
        tailf:info "Specify the preferred protocol to use";
        tailf:cli-full-command;
        type enumeration {
          enum none {
            tailf:info "No protocols";
          }
          enum ssh {
            tailf:info "Unix ssh protocol";
          }
          enum telnet {
            tailf:info "TCP/IP Telnet protocol";
          }
        }
      }
    }

    // line * / exec-timeout
    container exec-timeout {
      tailf:info "Set the EXEC timeout";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf minutes {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<0-35791>;;Timeout in minutes";
          range "0..35791";
        }
      }
      leaf seconds {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<0-2147483>;;Timeout in seconds";
          range "0..2147483";
        }
      }
    }

    // line * / length
    leaf length {
      tailf:info "Set number of lines on a screen.";
      type uint16 {
        tailf:info "<0-512>;;Number of lines on screen (0 for no pausing).";
        range "0..512";
      }
    }

    // line * / width
    leaf width {
      tailf:info "Set width of the display terminal.";
      type uint16 {
        tailf:info "<0-512>;;Number of characters on a screen line.";
        range "0..512";
      }
    }

    // line * / login authentication
    container login {
      tailf:info "Enable password checking";
      leaf authentication {
        tailf:info "Authentication parameters";
        type union {
          type enumeration {
            enum "default" {
              tailf:info "Use the default authorization list";
            }
          }
          type string {
            tailf:info "WORD;;Use an authorization list with this name";
          }
        }
      }
    }

    // line * / session-limit
    leaf session-limit {
      tailf:info "Set the number of outgoing connections";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<0-20>;;Number of outgoing connections";
        range "0..20";
      }
    }

    // line * / absolute-timeout
    leaf absolute-timeout {
      tailf:info "Set absolute timeout for line disconnection.";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<0-10000>;;Absolute timeout interval in minutes.";
        range "0..10000";
      }
    }

    // line * / telnet transparent
    container telnet {
      tailf:info "Telnet protocol-specific configuration";
      leaf transparent {
        tailf:info "Send a CR as a CR followed by a NULL instead of a CR followed by a LF";
        type empty;
      }
    }

    // line * / disconnect-character
    leaf disconnect-character {
      tailf:info "Define the disconnect character";
      type string {
        tailf:info "WORD;;Disconnect character or its decimal equivalent";
      }
    }

    // line * / session-timeout
    container session-timeout {
      tailf:info "Set interval for closing connection when there is no input traffic";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf minutes {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<0-35791>;;Session timeout interval in minutes";
          range "0..35791";
        }
      }
      leaf output {
        tailf:info "Include output traffic as well as input traffic";
        type empty;
      }
    }

    // line * / escape-character
    leaf escape-character {
      tailf:info "Change the current line template's escape character";
      type string {
        tailf:info "WORD;;Escape character or its ASCII decimal equivalent";
      }
    }

    // line * / cli whitespace completion
    container cli {
      tailf:info "Set the behaviour of cli.";
      container whitespace {
        tailf:info "Whitespace behaviour";
        leaf completion {
          tailf:info "Command completion on whitespace";
          type empty;
        }
      }
    }
  }

  // lpts-flow-grouping
  grouping lpts-flow-grouping {
    list flow {
      tailf:info "lpts flow type";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      key name;
      leaf name {
        tailf:cli-multi-word-key;
        tailf:cli-disallow-value "exit|(.+ (precedence|rate).*)";
        type string {
          tailf:info "WORD;;flow specifier(s)";
        }
      }
      leaf rate {
        tailf:info "Rate in PPS";
        tailf:cli-full-command;
        type uint32 {
          tailf:info "<0-4294967295>;;Packets Per Second";
        }
      }
      leaf precedence {
        tailf:info "TOS Precedence value(s)";
        tailf:cli-full-command;
        type precedence-type;
      }
    }
  }

  grouping class-random-detect-grouping {
    leaf min-threshold {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type uint32 {
        tailf:info "<0-1073741823>;;Minimum threshold";
        range "0..1073741823";
      }
    }
    leaf min-threshold-unit {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type police-burst-units-type;
    }
    leaf max-threshold {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type uint32 {
        tailf:info "<0-1073741823>;;Maximum threshold";
        range "0..1073741823";
      }
    }
    leaf max-threshold-unit {
      tailf:cli-drop-node-name;
      type police-burst-units-type;
    }
  }

  // class-map-match-grouping
  grouping class-map-match-grouping {

    // class-map * / match access-group
    container access-group {
      tailf:info "Match access group";

      // class-map * / match access-group ipv4
      leaf ipv4 {
        cli:parse-global-when;
        when "not(/cisco-ios-xr:tailfned/api/class-map-match-access-group-list)" {
          tailf:dependency "/cisco-ios-xr:tailfned/api/class-map-match-access-group-list";
        }
        tailf:info "IPv4 access list";
        tailf:cli-remove-before-change;
        tailf:cli-suppress-leafref-in-diff;
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:ipv4/access-list/named-acl/name";
        }
        type string {
          tailf:info "WORD;;Access list name - maximum 32 characters";
        }
      }

      // class-map * / match access-group ipv6
      leaf ipv6 {
        cli:parse-global-when;
        when "not(/cisco-ios-xr:tailfned/api/class-map-match-access-group-list)" {
          tailf:dependency "/cisco-ios-xr:tailfned/api/class-map-match-access-group-list";
        }
        tailf:info "IPv6 access list";
        tailf:cli-remove-before-change;
        tailf:cli-suppress-leafref-in-diff;
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:ipv6/access-list/named-acl/name";
        }
        type string {
          tailf:info "WORD;;Access list name - maximum 32 characters";
        }
      }

      // class-map * / match access-group-list *
      // NOTE: NCS5xx support multiple entries, ASR9K only 1
      list list {
        cli:parse-global-when;
        when "/cisco-ios-xr:tailfned/api/class-map-match-access-group-list" {
          tailf:dependency "/cisco-ios-xr:tailfned/api/class-map-match-access-group-list";
        }
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "af name";
        leaf af {
          type enumeration {
            enum ipv4 {
              tailf:info "IPv4 access list";
            }
            enum ipv6 {
              tailf:info "IPv6 access list";
            }
          }
        }
        leaf name {
          type string {
            tailf:info "WORD;;Access list name - maximum 64 characters";
          }
        }
      }
    }

    // class-map * / match any
    leaf any {
      tailf:info "Any packets";
      type empty;
    }

    // class-map * / match flow-key
    container flow-key {
      tailf:info "Match based on flow keys";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      choice id-choice {
        leaf five-tuple {
          tailf:alt-name "5-tuple";
          tailf:info "Five tuples to identify a flow";
          tailf:cli-optional-in-sequence;
          type empty;
        }
        case ip {
          leaf src-ip {
            tailf:info "Source IP address";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          leaf dst-ip {
            tailf:info "Destination IP address";
            tailf:cli-optional-in-sequence;
            type empty;
          }
        }
      }
      container flow-cache {
        tailf:info "Configure the flow-cache parameters";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf idle-timeout {
          tailf:info "Maximum time of inactivity for a flow";
          type union {
            type enumeration {
              enum none {
                tailf:info "The flow does not expire";
              }
            }
            type uint16 {
              tailf:info "<10-2550>;;The idle timeout period (in seconds)";
              range "10..2550";
            }
          }
        }
      }
    }

    // class-map * / match cos
    container cos {
      tailf:info "Match based on IEEE 802.1Q/ISL Class Of Service value";
      leaf-list cos-value {
        tailf:cli-drop-node-name;
        tailf:cli-flat-list-syntax;
        type uint16 {
          tailf:info "<0-7>;;COS value";
          range "0..7";
        }
      }
      // class-map * / match cos inner
      leaf-list inner {
        tailf:info "Match inner cos values (Upto 8 values)";
        tailf:cli-flat-list-syntax;
        type uint16 {
          tailf:info "<0-7>;;COS value";
          range "0..7";
        }
      }
    }

    // class-map * / match destination-address
    container destination-address {
      tailf:info "Match based on destination address";

      // class-map * / match destination-address ipv4 *
      list ipv4 {
        tailf:info "IPv4 address";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "address mask";
        leaf address {
          tailf:cli-drop-node-name;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP Address";
          }
        }
        leaf mask {
          tailf:cli-drop-node-name;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP subnet mask";
          }
        }
      }

      // class-map * / match destination-address mac
      leaf mac {
        tailf:info "MAC address";
        type string {
          tailf:info "H.H.H;;MAC Address to match";
        }
      }
    }

    // class-map * / match destination-port *
    leaf-list destination-port {
      tailf:info "Match based on destination port";
      tailf:cli-flat-list-syntax;
      type string {
        tailf:info "<0-65535>;;Port or range x-y";
      }
    }

    // class-map * / match discard-class *
    leaf-list discard-class {
      tailf:info "Match based on discard class (upto 8 Ids)";
      tailf:cli-flat-list-syntax;
      type uint16 {
        tailf:info "<0-7>;;Discard Class Id";
        range "0..7";
      }
    }

    // class-map * / match traffic-class *
    leaf-list traffic-class {
      tailf:info "Match based on traffic class field (upto 8 Ids or ranges)";
      tailf:cli-flat-list-syntax;
      type uint8 {
        tailf:info "<0-63>;;Traffic class Id";
        range "0..63";
      }
    }

    // class-map * / match dscp
    container dscp {
      tailf:info "Match based on IP DSCP value (upto 8 values or ranges)";

      // class-map * / match dscp *
      leaf-list dscp-list {
        tailf:cli-drop-node-name;
        tailf:cli-range-list-syntax;
        tailf:cli-full-command;
        cisco-ios-xr:max-values-output "2 :: 8 :: ,"; // values start after 2 words, max 8 per line, separator ,
        type dscp-type;
      }

      // class-map * / match dscp ipv4 *
      leaf-list ipv4 {
        tailf:info "IPV4 DSCP";
        tailf:cli-range-list-syntax;
        tailf:cli-full-command;
        cisco-ios-xr:max-values-output "3 :: 8 :: ,"; // values start after 3 words, max 8 per line, separator ,
        type dscp-type;
      }

      // class-map * / match dscp ipv6 *
      leaf-list ipv6 {
        tailf:info "IPV6 DSCP";
        tailf:cli-range-list-syntax;
        tailf:cli-full-command;
        cisco-ios-xr:max-values-output "3 :: 8 :: ,"; // values start after 3 words, max 8 per line, separator ,
        type dscp-type;
      }
    }

    // class-map * / match fr-de
    container fr-de {
      tailf:info "Match on Frame-relay DE bit";
      tailf:cli-delete-when-empty;
      tailf:cli-reset-container;
      presence true;
      leaf fr-de-value {
        tailf:cli-drop-node-name;
        type enumeration {
          enum "1" {
            tailf:info "<1-1>;;FR DE value";
          }
        }
      }
    }

    // class-map * / match frame-relay dlci *
    container frame-relay {
      tailf:info "Match based on frame-relay specific criteria";
      leaf-list dlci {
        tailf:info "Match frame-relay dlci value(s)";
        tailf:cli-flat-list-syntax;
        type uint16 {
          tailf:info "<16-1007>;;DLCI number";
          range "16..1007";
        }
      }
    }

    // class-map * / match mpls experimental topmost *
    container mpls {
      tailf:info "Match based on MPLS specific values";
      container experimental {
        tailf:info "Match MPLS experimental values";
        leaf-list topmost {
          tailf:info "Match topmost label (Upto 8 values)";
          tailf:cli-flat-list-syntax;
          type uint8 {
            tailf:info "<0-7>;;MPLS experimental topmost label";
            range "0..7";
          }
        }
      }
    }

    // class-map * / match packet length *
    container packet {
      tailf:info "Layer 3 Packet length";
      leaf-list length {
        tailf:info "Layer 3 Packet length";
        tailf:cli-flat-list-syntax;
        type string {
          tailf:info "<0-65535>;;IP packet length, value or range x-y";
        }
      }
    }

    // class-map * / match tcp-flag
    container tcp-flag {
      tailf:info "Match based on TCP flags";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf value {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "<0-4095>;;TCP flags value (Enter Hex value)";
        }
      }
      leaf any {
        tailf:info "Match based on any bit set";
        type empty;
      }
    }

    // class-map * / match ipv4
    container ipv4 {
      tailf:info "Match based on ipv4 icmp";

      // class-map * / match ipv4 icmp-type *
      leaf-list icmp-type {
        tailf:info "IPv4 ICMP type";
        tailf:cli-range-list-syntax;
        type uint8 {
          tailf:info "<0-255>;;Enter the value";
        }
      }

      // class-map * / match ipv4 icmp-code *
      leaf-list icmp-code {
        tailf:info "IPv4 ICMP code";
        tailf:cli-range-list-syntax;
        type uint8 {
          tailf:info "<0-255>;;Enter the value";
        }
      }
    }

    // class-map * / match fragment-type *
    leaf-list fragment-type {
      tailf:info "Fragment type for a packet";
      tailf:cli-flat-list-syntax;
      type enumeration {
        enum dont-fragment {
          tailf:info "Match don't-Fragment bit";
        }
        enum first-fragment {
          tailf:info "Match first fragment bit";
        }
        enum is-fragment {
          tailf:info "Match is-fragment bit";
        }
        enum last-fragment {
          tailf:info "Match last fragment bit";
        }
      }
    }

    // class-map * / match precedence
    container precedence {
      tailf:info "Match based on IP precedence values";

      // class-map * / match precedence ipv4 *
      leaf-list ipv4 {
        tailf:info "IPV4 precedence";
        tailf:cli-flat-list-syntax;
        type precedence-type;
      }

      // class-map * / match precedence ipv6 *
      leaf-list ipv6 {
        tailf:info "IPV6 precedence";
        tailf:cli-flat-list-syntax;
        type precedence-type;
      }

      // class-map * / match precedence *
      leaf-list list {
        tailf:cli-drop-node-name;
        tailf:cli-flat-list-syntax;
        type precedence-type;
      }
    }

    // class-map * / match protocol
    leaf-list protocol {
      tailf:info "Match based on L3 protocol (Upto 8 values or ranges)";
      tailf:cli-flat-list-syntax;
      max-elements 8;
      type union {
        type uint8 {
          tailf:info "<0-255>;;An IP Protocol Number";
        }
        type enumeration {
          enum ahp {
            tailf:info "Authentication Header Protocol";
            value 51;
          }
          enum eigrp {
            tailf:info "Cisco's EIGRP Routing Protocol";
            value 88;
          }
          enum esp {
            tailf:info "Encapsulation Security Payload";
            value 50;
          }
          enum gre {
            tailf:info "Cisco's GRE Tunneling";
            value 47;
          }
          enum icmp {
            tailf:info "Internet Control Message Protocol";
            value 1;
          }
          enum igmp {
            tailf:info "Internet Gateway Message Protocol";
            value 2;
          }
          enum igrp {
            tailf:info "Cisco's IGRP Routing Protocol";
            value 9;
          }
          enum ipinip {
            tailf:info "IP in IP tunneling";
            value 1001;
            //fixme:value?
          }
          enum ipv4 {
            tailf:info "Any IPv4 Protocol";
            value 0;
          }
          enum ipv6 {
            tailf:info "Any IPv6 Protocol";
            value 41;
          }
          enum ipv6icmp {
            tailf:info "IPV6Internet Control Message Protocol";
            value 58;
          }
          enum mpls {
            tailf:info "Any MPLS Packet";
            value 137;
          }
          enum nos {
            tailf:info "KA9Q NOS Compatible IP over IP Tunneling";
            value 94;
          }
          enum ospf {
            tailf:info "OSPF Routing Protocol";
            value 89;
          }
          enum pcp  {
            tailf:info "Payload Compression Protocol";
            value 108;
          }
          enum pim {
            tailf:info "Protocol Independent Multicast";
            value 103;
          }
          enum sctp {
            tailf:info "Stream Control Transmission Protocol";
            value 132;
          }
          enum tcp {
            tailf:info "Transport Control Protocol";
            value 6;
          }
          enum udp {
            tailf:info "User Datagram Protocol";
            value 17;
          }
        }
        type string {
          tailf:info "<0-255>-<0-255>;;Lower-Upper limit of protocol range to match";
          pattern '[0-9]+\-[0-9]+';
        }
      }
    }

    // class-map * / match qos-group
    leaf-list qos-group {
      tailf:info "Match based on QoS Group (upto 8 Ids or ranges)";
      tailf:cli-flat-list-syntax;
      type uint16 {
        tailf:info "<0-63>;;Qos Group Id";
        range "0..63";
      }
    }

    // class-map * / match source-address
    container source-address {
      tailf:info "Match based on source address";

      // class-map * / match source-address ipv4 *
      list ipv4 {
        tailf:info "IPv4 address";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "address mask";
        leaf address {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP Address";
          }
        }
        leaf mask {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP subnet mask";
          }
        }
      }

      // class-map * / match source-address mac
      leaf mac {
        tailf:info "MAC address";
        type string {
          tailf:info "H.H.H;;MAC Address to match";
        }
      }
    }

    // class-map * / match source-port
    leaf-list source-port {
      tailf:info "Match based on source port";
      tailf:cli-flat-list-syntax;
      type string {
        tailf:info "<0-65535>;;Port or range x-y";
      }
    }

    // class-map * / match vlan
    container vlan {
      tailf:info "Match based on Vlan Ids (Upto 8 values or ranges)";

      // class-map * / match vlan *
      leaf-list vlan-list {
        tailf:cli-drop-node-name;
        tailf:cli-range-list-syntax;
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<1-4094>;;Vlan Id";
          range "1..4094";
        }
      }

      // class-map * / match vlan inner *
      leaf-list inner {
        tailf:cli-range-list-syntax;
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<1-4094>;;Vlan Id";
          range "1..4094";
        }
      }
    }

    // class-map * / match vpls
    container vpls {
      tailf:info "Match based on VPLS fields";
      // class-map * / match vpls control
      leaf control {
        tailf:info "VPLS Control";
        tailf:cli-full-command;
        type empty;
      }
      // class-map * / match vpls broadcast
      leaf broadcast {
        tailf:info "VPLS Broadcast";
        tailf:cli-full-command;
        type empty;
      }
      leaf known {
        tailf:info "VPLS Known";
        type empty;
      }
      leaf multicast {
        tailf:info "VPLS Multicast";
        type empty;
      }
      leaf unknown {
        tailf:info "VPLS Unknown";
        type empty;
      }
    }

    // class-map * / match dei
    leaf dei {
      tailf:info "Match based on DEI bit (0/1)";
      type uint8 {
        tailf:info "0-1;;DEI value";
        range "0..1";
      }
    }
  }

  grouping class-map-filter-control-match-grouping {

    // class-map type control subscriber * / match authen-status
    leaf authen-status {
      tailf:info "Authentication Status";
      type enumeration {
        enum authenticated {
          tailf:info "Authenticated";
        }
        enum unauthenticated {
          tailf:info "Unauthenticated";
        }
      }
    }

    // class-map type control subscriber * / match protocol *
    leaf-list protocol {
      tailf:info "protocol";
      tailf:cli-flat-list-syntax;
      type enumeration {
        enum ppp {
          tailf:info "ppp";
        }
        enum dhcpv4 {
          tailf:info "dhcpv4";
        }
        enum dhcpv6 {
          tailf:info "dhcpv6";
        }
      }
    }

    // class-map type control subscriber * / match source-address
    container source-address {
      tailf:info "Source address";

      // class-map type control subscriber * / match source-address ipv4 *
      list ipv4 {
        tailf:info "IPv4 address";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "address mask";
        leaf address {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP Address";
          }
        }
        leaf mask {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP subnet mask";
          }
        }
      }
    }

    // class-map type control subscriber * / match timer
    container timer {
      tailf:info "Timer";
      leaf value {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "WORD;;string - maximum 32 characters";
        }
      }
    }
  }

  // interface * / logging events lsp-status
  // mpls traffic-eng / attribute-set * logging events lsp-status
  grouping logging-events-lsp-status-grouping {
    container lsp-status {
      tailf:info "Enable interface LSP state change alarms";
      leaf reoptimize {
        tailf:info "Enable interface LSP REOPT change alarms";
        type empty;
      }
      leaf state {
        tailf:info "Enable interface LSP UP/DOWN change alarms";
        type empty;
      }
      leaf reroute {
        tailf:info "Enable interface LSP REROUTE change alarms";
        type empty;
      }
      leaf insufficient-bandwidth {
        tailf:info "Enable Syslog for setup/reopt failure due to bandwidth";
        type empty;
      }
      leaf bw-change {
        tailf:info "Enable interface LSP BANDWIDTH change alarms";
        type empty;
      }
      leaf switchover {
        type empty;
      }
    }
  }

  // grouping interface-ipv6-nd-prefix-list-grouping
  grouping interface-ipv6-nd-prefix-list-grouping {
    choice prefix-choices {
      container prefix-lifetime {
        tailf:cli-drop-node-name;
        tailf:cli-reset-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf valid-lifetime {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type union {
            type uint32 {
              tailf:info "<0-4294967295>;;Valid Lifetime (secs)";
              range "0..4294967295";
            }
            type enumeration {
              enum infinite {
                tailf:info "Infinite Valid Lifetime";
              }
            }
          }
        }
        leaf preferred-lifetime {
          tailf:cli-drop-node-name;
          type union {
            type uint32 {
              tailf:info "<0-4294967295>;;Preferred Lifetime (secs) must be <= Valid Lifetime";
              range "0..4294967295";
            }
            type enumeration {
              enum infinite {
                tailf:info "Infinite Preferred Lifetime";
              }
            }
          }
        }
      }
      //TODO: at - Expire prefix at a specific time/date
      leaf no-adv {
        tailf:info "Do not advertise prefix";
        tailf:cli-full-command;
        type empty;
      }
      container options {
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        leaf no-autoconfig {
          tailf:info "Do not use prefix for autoconfiguration";
          type empty;
        }
        leaf off-link {
          tailf:info "Do not use prefix for onlink determination";
          type empty;
        }
      }
    }
  }


  // interface * / service-policy
  // interface * / pvc * / service-policy
  // interface * / l2transport / service-policy
  // interface ATM* / pvc * / service-policy
  // dynamic-template / type ipsubscriber * / service-policy
  grouping interface-service-policy-grouping  {
    container service-policy {
      tailf:info "Configure QoS Service Policy";

      // interface * / service-policy input
      container input {
        tailf:info "Configure a policy in the input direction";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        when "not(/cisco-ios-xr:tailfned/api/service-policy-list)" {
          tailf:dependency "/cisco-ios-xr:tailfned/api/service-policy-list";
        }
        leaf name {
          tailf:info "Name of the service policy";
          tailf:cli-drop-node-name;
          tailf:cli-remove-before-change;
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:policy-map/name";
          }
          type string {
            tailf:info "WORD;;Name of the service policy";
          }
        }
        uses interface-service-policy-content-grouping;
      }

      // interface * / service-policy input-list *
      list input-list {
        tailf:info "Configure additional policies in the input direction";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-remove-before-change;
        when "/cisco-ios-xr:tailfned/api/service-policy-list" {
          tailf:dependency "/cisco-ios-xr:tailfned/api/service-policy-list";
        }
        key name;
        leaf name {
          tailf:info "Name of the service policy";
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:policy-map/name";
          }
          type string {
            tailf:info "WORD;;Name of the service policy";
          }
        }
        uses interface-service-policy-content-grouping;
      }

      // interface * / service-policy output
      container output {
        tailf:info "Configure a policy in the output direction";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        when "not(/cisco-ios-xr:tailfned/api/service-policy-list)" {
          tailf:dependency "/cisco-ios-xr:tailfned/api/service-policy-list";
        }
        leaf name {
          tailf:info "Name of the service policy";
          tailf:cli-drop-node-name;
          tailf:cli-remove-before-change;
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:policy-map/name";
          }
          type string {
            tailf:info "WORD;;Name of the service policy";
          }
        }
        uses interface-service-policy-content-grouping;
      }

      // interface * / service-policy output-list *
      list output-list {
        tailf:info "Configure additional policies in the output direction";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-remove-before-change;
        when "/cisco-ios-xr:tailfned/api/service-policy-list" {
          tailf:dependency "/cisco-ios-xr:tailfned/api/service-policy-list";
        }
        key name;
        leaf name {
          tailf:info "Name of the service policy";
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:policy-map/name";
          }
          type string {
            tailf:info "WORD;;Name of the service policy";
          }
        }
        uses interface-service-policy-content-grouping;
      }

      // interface * / service-policy type
      container type {
        tailf:info "Enter service policy type (default: qos)";

        // interface * / service-policy type lan-queuing
        container lan-queuing {
          tailf:info "Configure Lan Queuing Policy Map";
          leaf input {
            tailf:info "Assign policy-map to the input of an interface";
            type string {
              tailf:info "WORD;;Name of the service policy";
            }
            tailf:non-strict-leafref {
              path "/cisco-ios-xr:policy-map/name";
            }
          }
          leaf output {
            tailf:info "Assign policy-map to the output of an interface";
            type string {
              tailf:info "WORD;;Name of the service policy";
            }
            tailf:non-strict-leafref {
              path "/cisco-ios-xr:policy-map/name";
            }
          }
        }

        // interface * / service-policy type performance-monitor
        container performance-monitor {
          tailf:info "Configure media monitor service-policy type";
          leaf input {
            tailf:info "Assign policy-map to the input of an interface";
            type string {
              tailf:info "WORD;;Name of the service policy";
            }
            tailf:non-strict-leafref {
              path "/cisco-ios-xr:policy-map/name";
            }
          }
          leaf output {
            tailf:info "Assign policy-map to the output of an interface";
            type string {
              tailf:info "WORD;;Name of the service policy";
            }
            tailf:non-strict-leafref {
              path "/cisco-ios-xr:policy-map/name";
            }
          }
          leaf inline {
            tailf:info "Configure inline Service Policy";
            type enumeration {
              enum input {
                tailf:info "Assign policy-map to the input of an interface";
              }
              enum output {
                tailf:info "Assign policy-map to the output of an interface";
              }
            }
          }
        }

        // interface * / service-policy type performance-traffic input
        container performance-traffic {
          tailf:info "Flow monitoring Service policy";
          leaf input {
            tailf:info "configure a policy in the input direction";
            type string {
              tailf:info "WORD;;Name of the service policy";
            }
          }
        }

        // interface * / service-policy type test
        container test {
          tailf:info "Configure Test Policy Map";
          leaf input {
            tailf:info "Assign policy-map to the input of an interface";
            type string {
              tailf:info "WORD;;Name of the service policy";
            }
            tailf:non-strict-leafref {
              path "/cisco-ios-xr:policy-map/name";
            }
          }
          leaf output {
            tailf:info "Assign policy-map to the output of an interface";
            type string {
              tailf:info "WORD;;Name of the service policy";
            }
            tailf:non-strict-leafref {
              path "/cisco-ios-xr:policy-map/name";
            }
          }
          leaf inline {
            tailf:info "Configure inline Service Policy";
            type enumeration {
              enum input {
                tailf:info "Assign policy-map to the input of an interface";
              }
              enum output {
                tailf:info "Assign policy-map to the output of an interface";
              }
            }
          }
        }

        // interface * / service-policy type pbr
        container pbr {
          tailf:info "Policy based routing Service policy";
          leaf input {
            tailf:info "Configure a policy in the input direction";
            type string {
              tailf:info "WORD;;Name of the service policy";
            }
            tailf:non-strict-leafref {
              path "/cisco-ios-xr:policy-map/name";
            }
          }
        }

        // interface * / service-policy control subscriber
        container control {
          tailf:info "control policy";
          leaf subscriber {
            tailf:info "subscriber policy";
            type string {
              tailf:info "WORD;;Policy name";
            }
          }
        }
      }
    }
  }

  // dynamic-template / type ppp * / service-policy *
  // dynamic-template / type service * / service-policy *
  grouping dynamic-template-service-policy-grouping {
    container service-policy {
      tailf:info "Configure QoS Service Policy";

      // dynamic-template / type ppp * / service-policy input
      container input {
        tailf:info "Configure a policy in the input direction";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf name {
          tailf:info "Name of the service policy";
          tailf:cli-drop-node-name;
          tailf:cli-remove-before-change;
          type string {
            tailf:info "WORD;;Name of the service policy";
          }
        }
        uses interface-service-policy-content-grouping;
      }

      // dynamic-template / type ppp * / service-policy output
      container output {
        tailf:info "direction of service policy application";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf name {
          tailf:info "Name of the service policy";
          tailf:cli-drop-node-name;
          tailf:cli-remove-before-change;
          type string {
            tailf:info "WORD;;Name of the service policy";
          }
        }
        uses interface-service-policy-content-grouping;
      }

      // interface * / service-policy type pbr
      container type {
        tailf:info "Configure PBR Service policy";
        container pbr {
          tailf:info "PBR Service policy";
          leaf input {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;Name of the service policy";
            }
          }
        }
      }
    }
  }

  grouping interface-service-policy-content-grouping  {
    container account {
      tailf:info "Turn off layer specific accounting";
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      tailf:cli-optional-in-sequence;
      choice account-choice {
        leaf nolayer2 {
          tailf:info "Turn off l2 accounting";
          type empty;
        }
        leaf user-defined {
          tailf:info "User defined accounting";
          type int8 {
            tailf:info "<-63,+63>;;Overhead accounting value";
            range "-63..63";
          }
        }
      }
    }

    leaf subscriber-parent {
      tailf:info "Configure an svlan policy";
      tailf:cli-optional-in-sequence;
      type empty;
    }

    leaf resource-id {
      when "../subscriber-parent";
      tailf:info "Configure a resource-id";
      tailf:cli-optional-in-sequence;
      type uint8 {
        tailf:info "<0-3>;;resource-id value";
        range "0..3";
      }
    }

    leaf shared-policy-instance {
      tailf:info "Configure a shared-policy-instance";
      tailf:cli-optional-in-sequence;
      tailf:cli-full-command;
      type string {
        tailf:info "WORD;;Name of the shared-policy-instance";
      }
    }

    container merge {
      tailf:info "Enable the policy to be merged";
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf seq {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<0-255>;;Sequence number of the policy";
        }
      }
      leaf acct-stats {
        tailf:info "Enable service accounting";
        type empty;
      }
    }
  }


  // grouping interface-isis-grouping
  grouping interface-isis-grouping {
    // interface * / isis
    container isis {
      tailf:info "IS-IS commands";
      // interface * / isis authentication
      container authentication {
        tailf:info "ISIS authentication for interface related PDUs";
        // interface * / isis authentication mode
        container mode {
          tailf:info "Authentication mode for PDUs";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-reset-container;
          leaf crypt {
            tailf:cli-drop-node-name;
            type enumeration {
              enum md5 {
                tailf:info "Keyed message digest";
              }
              enum text {
                tailf:info "Clear text password";
              }
            }
          }
          leaf level {
            tailf:cli-drop-node-name;
            type enumeration {
              enum level-1 {
                tailf:info "ISIS authentication for level-1 PDUs";
              }
              enum level-2 {
                tailf:info "ISIS authentication for level-2 PDUs";
              }
            }
          }
        }
        // interface * / isis authentication key-chain
        leaf key-chain {
          tailf:info "Authentication key-chain";
          tailf:cli-suppress-leafref-in-diff;
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:key/chain/name";
          }
          type string {
            tailf:info "WORD;;Key-chain";
          }
        }
        // interface * / isis authentication send-only
        container send-only {
          tailf:info "Authentication send only, receive ignore";
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          presence true;
          leaf level {
            tailf:cli-drop-node-name;
            type enumeration {
              enum level-1 {
                tailf:info "ISIS authentication for level-1 PDUs";
              }
              enum level-2 {
                tailf:info "ISIS authentication for level-2 PDUs";
              }
            }
          }
        }
      }

      // interface * / isis circuit-type
      leaf circuit-type {
        tailf:info "Configure circuit type for interface";
        tailf:cli-reset-container;
        type enumeration {
          enum level-1 {
            tailf:info "Level-1 only adjacencies are formed";
          }
          enum level-1-2 {
            tailf:info "Level-1-2 adjacencies are formed";
          }
          enum level-2-only {
            tailf:info "Level-2 only adjacencies are formed";
          }
        }
      }

      // interface * / isis hello
      container hello {
        tailf:info "Add padding to IS-IS hello packets";
        leaf padding {
          tailf:info "Pad hello packets";
          type empty;
        }
      }

      // interface * / isis metric
      container metric {
        tailf:info "Configure the metric for interface";
        tailf:cli-reset-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf metric {
          tailf:cli-drop-node-name;
          type union {
            type uint32 {
              tailf:info "<1-16777214>;;Default metric";
              range "1..16777214";
            }
            type enumeration {
              enum maximum {
                tailf:info "Maximum metric. All routers will exclude this link from their SPF";
              }
            }
          }
        }
        leaf delay {
          tailf:cli-drop-node-name;
          type union {
            type enumeration {
              enum level-1 {
                tailf:info "Apply metric to level-1 links";
              }
              enum level-2 {
                tailf:info "Apply metric to level-2 links";
              }
            }
            type uint32 {
              tailf:info "<1-16777214>;;Delay metric";
              range "1..16777214";
            }
          }
        }
        leaf expense {
          when "../delay != 'level-1' and ../delay != 'level-2'" {
            tailf:dependency "../delay";
          }
          tailf:cli-drop-node-name;
          type union {
            type enumeration {
              enum level-1 {
                tailf:info "Apply metric to level-1 links";
              }
              enum level-2 {
                tailf:info "Apply metric to level-2 links";
              }
            }
            type uint32 {
              tailf:info "<1-16777214>;;Expense metric";
              range "1..16777214";
            }
          }
        }
        leaf error {
          when "../delay != 'level-1' and ../delay != 'level-2' "
            +"and ../expense != 'level-1' and ../expense != 'level-2'" {
            tailf:dependency "../delay";
            tailf:dependency "../expense";
          }
          tailf:cli-drop-node-name;
          type union {
            type enumeration {
              enum level-1 {
                tailf:info "Apply metric to level-1 links";
              }
              enum level-2 {
                tailf:info "Apply metric to level-2 links";
              }
            }
            type uint32 {
              tailf:info "<1-16777214>;;Error metric";
              range "1..16777214";
            }
          }
        }
        leaf rest {
          when "../delay != 'level-1' and ../delay != 'level-2' "
            +"and ../expense != 'level-1' and ../expense != 'level-2'"
            +"and ../error != 'level-1' and ../error != 'level-2'" {
            tailf:dependency "../delay";
            tailf:dependency "../expense";
            tailf:dependency "../error";
          }
          tailf:cli-drop-node-name;
          type union {
            type enumeration {
              enum level-1 {
                tailf:info "Apply metric to level-1 links";
              }
              enum level-2 {
                tailf:info "Apply metric to level-2 links";
              }
            }
          }
        }
      }
    }
  }

  // grouping interface-switch-grouping
  grouping interface-switch-grouping {

    // interface * / channel-protocol
    container channel-protocol {
      tailf:info "Select the channel protocol (LACP, PAgP)";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf number {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint16 {
          tailf:info "<1-512>;;Channel group number";
          range "1..512";
        }
      }
      leaf mode {
        tailf:info "Etherchannel Mode of the interface";
        type enumeration {
          enum active {
            tailf:info "Enable LACP unconditionally";
          }
          enum auto {
            tailf:info "Enable PAgP only if a PAgP device is detected";
          }
          enum desirable {
            tailf:info "Enable PAgP unconditionally";
          }
          enum on {
            tailf:info "Enable Etherchannel only";
          }
          enum passive {
            tailf:info "Enable LACP only if a LACP device is detected";
          }
        }
      }
    }

    // interface * / switch
    container switch {
      tailf:info "Configure switch link";
      container virtual {
        tailf:info "Configure virtual switch values";
        leaf link {
          tailf:info "Configure virtual switch number";
          type uint8 {
            tailf:info "<1-2>;;core switch number";
            range "1..2";
          }
        }
      }
    }

    // interface * / switchport
    // interface * / no switchport
    container switchport-conf {
      tailf:cli-drop-node-name;
      leaf switchport {
        tailf:info "Set switching mode characteristics";
        tailf:cli-boolean-no;
        type boolean;
      }
    }

    // interface * / switchport
    container switchport {
      tailf:info "Set switching mode characteristics";
      tailf:cli-incomplete-command;
      tailf:cli-incomplete-no;

      // interface * / switchport access
      container access {
        tailf:info "Set access mode characteristics of the interface";
        leaf vlan {
          tailf:info "Set VLAN when interface is in access mode";
          type uint16 {
            tailf:info "<1-4094>;;VLAN ID of the VLAN when this port is in access mode";
            range "1..4094";
          }
        }
      }

      // interface * / switchport block
      container block {
        tailf:info "Disable forwarding of unknown uni/multi cast addresses";
        leaf multicast {
          tailf:info "Block unknown multicast addresses";
          tailf:cli-full-command;
          type empty;
        }
        leaf unicast {
          tailf:cli-full-command;
          tailf:info "Block unknown unicast addresses";
          type empty;
        }
      }

      // interface * / switchport mode
      container mode {
        tailf:info "Set trunking mode of the interface";
        choice mode-choice {
          leaf access {
            tailf:info "Set trunking mode to ACCESS unconditionally";
            type empty;
          }
          leaf dot1q-tunnel {
            tailf:info "set trunking mode to TUNNEL unconditionally";
            type empty;
          }
          leaf dynamic {
            tailf:info "Set trunking mode to dynamically negotiate access or trunk mode";
            type enumeration {
              enum auto {
                tailf:info "Set trunking mode dynamic negotiation parameter to AUTO";
              }
              enum desirable {
                tailf:info "Set trunking mode dynamic negotiation parameter to DESIRABLE";
              }
            }
          }
          leaf trunk {
            tailf:info "Set trunking mode to TRUNK unconditionally";
            type empty;
          }
        }
      }

      // interface * / switchport nonegotiate
      leaf nonegotiate {
        tailf:info "Device will not engage in negotiation protocol on this interface";
        type empty;
      }

      // interface * / switchport trunk
      container trunk {
        tailf:info "Set trunking characteristics of the interface";
        container allowed {
          tailf:info "Set allowed VLAN characteristics when interface is in trunking mode";
          container vlan {
            tailf:info "Set allowed VLANs when interface is in trunking mode";
            choice vlan-choice {
              leaf-list vlans {
                tailf:cli-range-list-syntax;
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "WORD;;VLAN IDs of the allowed VLANs when this port is in trunking mode";
                }
              }
              leaf all {
                tailf:info "all VLANs";
                type empty;
              }
              leaf-list except {
                tailf:info "all VLANs except the following";
                tailf:cli-range-list-syntax;
                type uint16 {
                  tailf:info "WORD;;VLAN IDs of the allowed VLANs when this port is in trunking mode";
                }
              }
              leaf none {
                tailf:info "no VLANs";
                type empty;
              }
            }
          }
        }
        container native {
          tailf:info "Set trunking native characteristics when interface is in trunking mode";
          leaf vlan {
            tailf:info "Set native VLAN when interface is in trunking mode";
            type union {
              type enumeration {
                enum tag {
                  tailf:info "Set native VLAN tagging state";
                }
              }
              type uint16 {
                tailf:info "<1-4094>;;VLAN ID of the native VLAN when this port is in trunking mode";
                range "1..4094";
              }
            }
          }
        }

        container pruning {
          tailf:info "Set pruning VLAN characteristics when interface is in trunking mode";
          container vlan {
            tailf:info "Set VLANs enabled for pruning when interface is in trunking mode";
            choice vlan-choice {
              leaf-list vlans {
                tailf:cli-range-list-syntax;
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "WORD;;VLAN IDs of the allowed VLANs when this port is in trunking mode";
                }
              }
              leaf-list except {
                tailf:info "all VLANs except the following";
                tailf:cli-range-list-syntax;
                type uint16 {
                  tailf:info "WORD;;VLAN IDs of the allowed VLANs when this port is in trunking mode";
                }
              }
              leaf none {
                tailf:info "no VLANs";
                type empty;
              }
            }
          }
        }
      }
    }

    // interface * / spanning-tree
    container spanning-tree {
      tailf:info "Spanning Tree Subsystem";
      leaf bpdufilter {
        tailf:info "Don't send or receive BPDUs on this interface";
        type enumeration {
          enum disable {
            tailf:info "Disable BPDU filtering for this interface";
          }
          enum enable {
            tailf:info "Enable BPDU filtering for this interface";
          }
        }
      }
      leaf bpduguard {
        tailf:info "Don't accept BPDUs on this interface";
        type enumeration {
          enum disable {
            tailf:info "Disable BPDU guard for this interface";
          }
          enum enable {
            tailf:info "Enable BPDU guard for this interface";
          }
        }
      }
      leaf guard {
        tailf:info "Change an interface's spanning tree guard mode";
        type enumeration {
          enum loop {
            tailf:info "Set guard mode to loop guard on interface";
          }
          enum none {
            tailf:info "Set guard mode to none";
          }
          enum root {
            tailf:info "Set guard mode to root guard on interface";
          }
        }
      }
      leaf portfast {
        tailf:info "Spanning tree portfast options";
        type enumeration {
          enum disable {
            tailf:info "Disable portfast for this interface";
          }
          enum edge {
            tailf:info "Enable portfast edge on the interface";
          }
          enum network {
            tailf:info "Enable portfast network on the interface";
          }
        }
      }
    }

  }


  // grouping interface-bundle-grouping
  grouping interface-bundle-grouping {

    // interface * / bundle
    container bundle {
      tailf:info "Bundle interface commands";

      // interface * / bundle wait-while
      leaf wait-while {
        tailf:info "Set the wait-while timeout for members of this bundle";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<0-2000>;;Wait-while timeout in milliseconds (default: 2000)";
          range "0..2000";
        }
      }

      // interface * / bundle load-balancing
      container load-balancing {
        tailf:info "Load balancing commands on a bundle";

        // interface * / bundle load-balancing hash
        leaf hash {
          tailf:info "Select the hash function used for traffic forwarded over the bundle";
          type union {
            type uint8 {
              tailf:info "<1-64>;;Set the hash value to map traffic to for this EFP";
              range "1..64";
            }
            type enumeration {
              enum dst-ip {
                tailf:info "Use the destination IP as the hash function";
              }
              enum src-ip {
                tailf:info "Use the source IP as the hash function";
              }
              enum auto {
                tailf:info "Map traffic on this EFP to a single member link, chosen automatically";
              }
            }
          }
        }

        // interface * / bundle load-balancing localize threshold links
        container localize {
          tailf:info "Restrict forwarding to members in the same rack where possible";
          container threshold {
            tailf:info "The threshold below which traffic is no longer localized";
            leaf links {
              tailf:info "Set a threshold of active member links per rack";
              type uint8 {
                tailf:info "<1-64>;;The number of links required on each rack to localize";
                range "1..64";
              }
            }
          }
        }
      }

      // interface * / bundle maximum-active
      container maximum-active {
        tailf:info "Set a limit on the number of links that can be active";
        container links {
          tailf:info "Set the number of active links needed to bring up this bundle";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf number {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-64>;;Number of active links needed to bring up this bundle";
              range "1..64";
            }
          }
          leaf hot-standby {
            tailf:info "Hot-standby behaviour (non-standard, only effective on links with LACP enabled)";
            type empty;
          }
        }
      }

      // interface * / bundle minimum-active
      container minimum-active {
        tailf:info "Set the minimum criteria for the bundle to be active";

        // interface * / bundle minimum-active links
        leaf links {
          tailf:info "Set the number of active links needed to bring up this bundle";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<1-64>;;Number of active links needed to bring up this bundle";
          }
        }

        // interface * / bundle minimum-active bandwidth
        container bandwidth {
          tailf:info "Set the bandwidth (in kbps) needed to bring up this bundle";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf unit {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            tailf:cli-incomplete-command;
            type enumeration {
              enum "kbps";
              enum "mbps";
              enum "gbps";
            }
          }
          leaf value {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-4294967295>;;Bandwidth needed to bring up this bundle";
              range "1..4294967295";
            }
          }
        }
      }

      // interface * / bundle lacp-fallback timeout
      container lacp-fallback {
        tailf:info "Set the lacp-fallback for members of this bundle";
        leaf timeout {
          tailf:info "Set the timeout for lacp-fallback";
          type uint16 {
            tailf:info "<1-120>;;Lacp-Fallback timer in seconds";
            range "1..120";
          }
        }
      }

      // interface * / bundle logging oos
      container logging {
        tailf:info "logging events for the members of this bundle";
        leaf oos {
          tailf:info "Enable OOS logging events for the members of this bundle";
          type empty;
        }
      }
    }

    // interface * / lacp
    container lacp {
      tailf:info "Bundle interface LACP commands";

      // interface * / lacp mode
      leaf mode {
        tailf:info "Set the LACP mode on bundle to be used by its member link";
        type enumeration {
          enum active {
            tailf:info "Run LACP in active mode over the port.";
          }
          enum on {
            tailf:info "Do not run LACP over the port.";
          }
          enum passive {
            tailf:info "Run LACP in passive mode over the port.";
          }
        }
      }

      // interface * / lacp churn logging
      container churn {
        tailf:info "Settings for LACP churn detection";
        leaf logging {
          tailf:info "Set parameters for logging of churn events";
          type enumeration {
            enum actor {
              tailf:info "Log actor churn events only";
            }
            enum both {
              tailf:info "Log actor and partner churn events";
            }
            enum partner {
              tailf:info "Log partner churn events only";
            }
          }
        }
      }

      // interface * / lacp period
      leaf period {
        tailf:info "Set the period on bundle to be used by its member link";
        type union {
          type uint16 {
            tailf:info "<100-1000>;;Specify the requested transmission period (in milliseconds)"
              +" for the partner system (must be multiple of 100; default 1000)";
            range "100..1000";
          }
          type enumeration {
            enum short {
              tailf:info "set the short period on bundle";
            }
          }
        }
      }

      // interface * / lacp system
      container system {
        tailf:info "Configure LACP system parameters for the bundle";

        // interface * / lacp system mac
        leaf mac {
          tailf:info "Configure the system ID to use in LACP negotiations for this bundle.";
          type string {
            tailf:info "H.H.H;;Bundle LACP system ID.";
          }
        }

        // interface * / lacp system priority
        leaf priority {
          tailf:info "Configure the system priority to use in LACP negotiations for this bundle.";
          type uint16 {
            tailf:info "<1-65535>;;Bundle LACP system priority. Lower value is higher priority.";
            range "1..65535";
          }
        }
      }

      // interface * / lacp non-revertive
      leaf non-revertive {
        tailf:info "Set the bundle to lacp non-revertive mode";
        type empty;
      }

      // interface * / lacp switchover suppress-flaps
      container switchover {
        tailf:info "Modify behavior for switching between links in this bundle";
        leaf suppress-flaps {
          tailf:info "Set the time for which to suppress flaps during a LACP switchover";
          type uint16 {
            tailf:info "<100-65535>;;The longest down flap which should be suppressed (milliseconds)";
            range "100..65535";
          }
        }
      }

      // interface * / lacp collector-max-delay
      leaf collector-max-delay {
        tailf:info "Collector max delay to be signaled to the LACP partner";
        type uint16 {
          tailf:info "<0-65535>;;The delay in tens of microseconds (default: 0xFFFF)";
        }
      }

      // interface * / lacp cisco enable
      container cisco {
        tailf:info "Cisco LACP extensions";
        container enable {
          tailf:info "Enable the use of Cisco LACP extensions";
          presence true;
        }
      }
    }

    // interface * / mlacp
    container mlacp {
      tailf:info "Multi-chassis LACP per-interface commands";

      // interface * / mlacp iccp-group
      leaf iccp-group {
        tailf:info "ICCP redundancy group related commands for this bundle.";
        tailf:cli-full-command;
        type uint32 {
          tailf:info "<1-4294967295>;;The ICCP redundancy group in which this bundle should operate.";
          range "1..4294967295";
        }
      }

      // interface * / mlacp port-priority
      leaf port-priority {
        tailf:info "Set the priority for all member links on this device when running mLACP.";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<1-65535>;;Priority for member ports. Lower value is higher priority.";
          range "1..65535";
        }
      }

      // interface * / mlacp switchover
      container switchover {
        tailf:info "Set the parameters for performing a switchover to/from the mLACP peer";

        // interface * / mlacp switchover maximize
        container maximize {
          tailf:info "Parameters for switchover behavior to maximize operational links/bandwidth";
          container links {
            tailf:info "Compare the number of operational links";
            tailf:cli-reset-container;
            tailf:cli-delete-when-empty;
            presence true;
            leaf threshold {
              tailf:info "Set the threshold below which to switch to the peer if it has more links available";
              type uint8 {
                tailf:info "<1-64>;;The number of links below which to "
                  +"switch to the peer if it has more links available";
                range "1..64";
              }
            }
          }
        }

        // interface * / mlacp switchover recovery-delay
        leaf recovery-delay {
          tailf:info "Specify delay before bundle becoming active after recovery from failure";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<0-65535>;;Recovery delay in seconds.";
          }
        }

        // interface * / mlacp switchover type
        leaf type {
          tailf:info "Set the type of switchover operation to use";
          tailf:cli-full-command;
          type enumeration {
            enum brute-force {
              tailf:info "Force switchover by disabling all local member links";
            }
            enum revertive {
              tailf:info "Revert based on configured priority values";
            }
          }
        }
      }
    }
  }

  // grouping interface-non-bundle-grouping
  grouping interface-non-bundle-grouping {

    // interface * / bundle
    container bundle {
      tailf:info "Link aggregation per-interface commands";

      // interface * / bundle id
      container id {
        tailf:info "Add the port to an aggregated interface.";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf id-value {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-65535>;;Identifier of the bundle to add the port to.";
          }
        }
        leaf mode {
          tailf:info "Specify the mode of operation.";
          type enumeration {
            enum active {
              tailf:info "Run LACP in active mode over the port.";
            }
            enum on {
              tailf:info "Do not run LACP over the port.";
            }
            enum passive {
              tailf:info "Run LACP in passive mode over the port.";
            }
            enum inherit {
              tailf:info "Run LACP as configured in bundle.";
            }
          }
        }
      }

      // interface * / bundle port-priority
      leaf port-priority {
        tailf:info "Priority for this port. Lower value is higher priority.";
        type uint16 {
          tailf:info "<1-65535>;;Priority for this port. Lower value is higher priority.";
          range "1..65535";
        }
      }
    }

    // interface * / lacp
    container lacp {
      tailf:info "Link Aggregation Control Protocol per-interface commands";

      // interface * / lacp period
      container period {
        tailf:info "Configure the rate at which packets are sent or received";
        leaf period-value {
          tailf:cli-drop-node-name;
          tailf:cli-full-command;
          type uint16 {
            tailf:info "Specify the requested transmission period "+
              "(in milliseconds) for the partner system (must be multiple of 100; default 1000)";
            range "100..1000";
          }
        }

        // interface * / lacp period short
        container short-enable {
          tailf:cli-drop-node-name;
          leaf short {
            tailf:info "Configure usage of the LACP short interval";
            tailf:cli-full-command;
            type empty;
          }
        }

        // interface * / lacp period short receive
        // interface * / lacp period short transmit
        container short {
          tailf:info "Configure usage of the LACP short interval";
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;

          // interface * / lacp period short receive
          leaf receive {
            tailf:info "Expected period for rx packets if LACP short is enabled "+
              "(NOTE: This CLI is deprecated and will be removed in future releases. "+
              "Use the CLI 'lacp period <time in milliseconds>' to configure short periods)";
            type uint16 {
              tailf:info "<100-1000>;;Period in milliseconds(must be multiple of 100; default 1000)";
              range "100..1000" {
                tailf:step 100;
              }
            }
          }

          // interface * / lacp period short transmit
          leaf transmit {
            tailf:info "Period for tx packets if the peer is using LACP short "+
              "(NOTE: This CLI is deprecated and will be removed in future releases. "+
              "Use the CLI 'lacp period <time in milliseconds>' to configure short periods)";
            type uint16 {
              tailf:info "<100-1000>;;Period in milliseconds(must be multiple of 100; default 1000)";
              range "100..1000" {
                tailf:step 100;
              }
            }
          }
        }
      }
    }

    // interface * / small-frame-padding
    leaf small-frame-padding {
      tailf:info "Pad small frames to 68 bytes";
      type empty;
    }
  }

  // interface-pointtopoint-grouping
  grouping interface-pointtopoint-grouping {

    // interface * / keepalive
    container keepalive {
      tailf:info "Set the keepalive interval, or disable keepalives";
      choice keepalive-choice {
        container values {
          tailf:cli-drop-node-name;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf interval {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-30>;; Enable keepalives with this interval (default is 10 seconds)";
              range "1..30";
            }
          }
          leaf retry {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-255>;;Set the keepalive retry count (default is 3 for HDLC, 5 for PPP)";
              range "1..255";
            }
          }
        }
        leaf disable {
          tailf:info "Disable keepalives";
          type empty;
        }
      }
    }

    // interface * / pvc *
    list pvc {
      tailf:info "Configure a pvc on this interface";
      tailf:cli-mode-name "config-fr-vc";
      key dlci;
      leaf dlci {
        type uint16 {
          tailf:info "<16-1007>;;DLCI Number";
          range "16..1007";
        }
      }

      // interface * / pvc * / service-policy
      uses interface-service-policy-grouping;

      // interface * / pvc * / encap
      leaf encap {
        tailf:info "Set the Encapsulation of this PVC";
        type enumeration {
          enum cisco {
            tailf:info "Use Cisco encapsulation for this PVC";
          }
          enum ietf {
            tailf:info "Use RFC1490/RFC2427 encapsulation for this PVC";
          }
        }
      }

      // interface * / pvc * / fragment
      container fragment {
        tailf:info "Enable FRF.12 fragmentation and define fragment size";
        tailf:cli-compact-syntax;
        leaf end-to-end {
          tailf:info "Choose end-to-end FRF.12 fragmentation";
          type uint16 {
            tailf:info "<16-1600>;;fragment size in bytes";
            range "16..1600";
          }
        }
        leaf fragment-counter {
          tailf:info "Enable fragmentation counters";
          type empty;
        }
      }
    }

    // interface * / ppp
    container ppp {
      tailf:info "Point-to-Point Protocol";

      // interface * / ppp multilink
      container multilink {
        tailf:info "Configure PPP Multilink settings";

        // interface * / ppp multilink minimum-active links
        container minimum-active {
          tailf:info "Configure the minimum requirements to activate the interface";
          leaf links {
            tailf:info "Configure the minimum number of active links required";
            type uint16 {
              tailf:info "<1-65535>;;Number of links";
              range "1..65535";
            }
          }
        }
      }
    }
  }

  // interface-multilink-grouping
  grouping interface-multilink-grouping {

    // interface * / multilink
    container multilink {
      tailf:info "Modify Multilink parameters!";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-if-multilink";

      // interface * / multilink / fragment-size
      container fragment-size {
        tailf:info "Fragment size (some fragment sizes may not be supported)";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-if-multilink-frag";
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        leaf size {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type uint16 {
            tailf:info "<64-512>;;Size of fragments";
            range "64..512";
          }
        }
        // interface * / multilink / fragment-size / fragment-counter
        leaf fragment-counter {
          tailf:info "Enable/Disable the fragmentation counters";
          type empty;
        }
      }

      // interface * / multilink / fragment
      container fragment {
        tailf:info "Set the fragmentation";

        // interface * / multilink / fragment size
        leaf size {
          tailf:info "Set the fragmentation size";
          type uint16 {
            tailf:info "<64-9216>;;Fragmentation size in bytes";
            range "64..9216";
          }
        }
      }
    }
  }

  // grouping interface-ethernet-grouping
  grouping interface-ethernet-grouping {

    // interface * / fec
    leaf fec {
      tailf:info "Set the Forward Error Correction on an interface";
      type enumeration {
        enum none {
          tailf:info "Disable any FEC enabled on the interface";
        }
        enum base-r {
          tailf:info "Enable BASE-R FEC";
        }
        enum standard {
          tailf:info "Enable the standard (Reed-Solomon) FEC";
        }
      }
    }

    // interface * / carrier-delay
    container carrier-delay {
      tailf:info "Set the carrier delay on an interface";
      tailf:cli-compact-syntax;
      leaf up {
        tailf:info "Set the carrier delay up value";
        type uint32 {
          tailf:info "<0-2147483647>;;Delay in milliseconds";
          range "0..2147483647";
        }
      }
      leaf down {
        tailf:info "Set the carrier delay down value";
        type uint32 {
          tailf:info "<0-2147483647>;;Delay in milliseconds";
          range "0..2147483647";
        }
      }
    }

    // interface * / duplex
    leaf duplex {
      tailf:info "Configure duplex operational mode";
      tailf:cli-full-command;
      type enumeration {
        enum full {
          tailf:info "Full duplex";
          tailf:code-name "duplex_full";
        }
        enum half {
          tailf:info "Half duplex";
          tailf:code-name "duplex_half";
        }
      }
    }

    // interface * / ethernet
    container ethernet {
      tailf:info "Ethernet per-interface configuration commands";

      // interface * / ethernet udld
      container udld {
        tailf:info "Enable the UniDirectional Link Detection protocol";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-if-udld";
        presence true;

        // interface * / ethernet udld / mode
        leaf mode {
          tailf:info "Set the mode in which to run the UDLD protocol";
          tailf:cli-full-command;
          type enumeration {
            enum aggressive {
              tailf:info "Run UDLD in aggressive mode";
            }
            enum normal {
              tailf:info "Run UDLD in normal mode";
            }
          }
        }

        // interface * / ethernet udld / message-time
        leaf message-time {
          tailf:info "Set the 'Mslow' message time (in seconds) for the UDLD protocol";
          type uint8 {
            tailf:info "<7-90>;;'Mslow' message time (in seconds) to use for the UDLD protocol";
            range "7..90";
          }
        }
      }

      // interface * / ethernet cfm
      container cfm {
        tailf:info "802.1ag Connectivity Fault Management configuration";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-if-cfm";

        // interface * / ethernet cfm / mep
        container mep {
          tailf:info "CFM Maintenance End Point configuration";

          // interface * / ethernet cfm / mep domain *
          list domain {
            tailf:info "Specify the Maintenance Domain the MEP operates in";
            tailf:cli-incomplete-command;
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;Maintenance Domain name";
              }
            }
            leaf service {
              tailf:info "Specify the Maintenance Service the MEP operates in";
              tailf:cli-hide-in-submode;
              tailf:cli-incomplete-command;
              type string {
                tailf:info "WORD;;Maintenance Service name";
              }
            }
            leaf mep-id {
              tailf:info "Specify the MEP ID to assign to the MEP";
              tailf:cli-hide-in-submode;
              type uint16 {
                tailf:info "<1-8191>;;MEP ID";
                range "1..8191";
              }
            }

            // interface * / ethernet cfm / mep domain * / cos
            leaf cos {
              tailf:info "Specify CoS bits for messages initiated by this MEP";
              type uint8 {
                tailf:info "<0-7>;;Class of Service";
                range "0..7";
              }
            }

            // interface * / ethernet cfm / mep domain * / sla
            container sla {
              tailf:info "Service Level Agreement configuration";
              container operation {
                tailf:info "SLA operation configuration";
                list profile {
                  tailf:info "Specify the SLA profile for this operation";
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  tailf:cli-compact-syntax;
                  tailf:cli-sequence-commands;
                  key "name mep-id";
                  leaf name {
                    type string {
                      tailf:info "WORD;;Profile name";
                    }
                  }
                  leaf target {
                    tailf:info "Specify the target for the SLA operation";
                    tailf:cli-prefix-key {
                      tailf:cli-before-key 2;
                    }
                    type empty;
                  }
                  leaf mep-id {
                    tailf:cli-expose-key-name;
                    tailf:info "Specify a target MEP";
                    type uint16 {
                      tailf:info "<1-8191>;;Target MEP ID";
                    }
                  }
                }
              }
            }
          }
        }

        // interface * / ethernet cfm / ais
        container ais {
          tailf:info "CFM Alarm Indication Signal configuration";
          container transmission {
            tailf:info "CFM AIS transmission configuration";
            container up {
              tailf:info "Up configuration";
              tailf:cli-compact-syntax;
              tailf:cli-reset-container;
              presence true;
              leaf cos {
                tailf:info "Specify CoS bits for AIS messages";
                type uint8 {
                  tailf:info "<0-7>;;Class of Service";
                  range "0..7";
                }
              }
              leaf interval {
                tailf:info "Specify the AIS transmission interval";
                type enumeration {
                  enum "1s" {
                    tailf:info "Interval of 1 second";
                  }
                  enum "1m" {
                    tailf:info "Interval of 1 minute";
                  }
                }
              }
            }
          }
        }
      }

      // interface * / ethernet oam
      container oam {
        tailf:info "OAM configuration";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-if-eoam";
        presence true;

        // interface * / ethernet oam / mode
        leaf mode {
          tailf:info "OAM mode";
          type enumeration {
            enum active {
              tailf:info "Active mode";
            }
            enum passive {
              tailf:info "Passive mode";
            }
          }
        }

        // interface * / ethernet oam / profile
        leaf profile {
          tailf:info "Set the profile to use on the interface";
          type string {
            tailf:info "WORD;;Enter a profile name using only letters, numbers, '_' & '-'";
          }
        }

        // interface * / ethernet oam / connection timeout
        container connection {
          tailf:info "OAM connection configuration";
          leaf timeout {
            tailf:info "OAM connection session timeout period";
            type uint8 {
              tailf:info "<2-30>;;Connection timeout period in number of lost periodic Information OAMPDUs";
              range "2..30";
            }
          }
        }

        // interface * / ethernet oam / mib-retrieval
        container mib-retrieval {
          tailf:info "MIB retrieval support";
          tailf:cli-delete-when-empty;
          tailf:cli-reset-container;
          presence true;
          leaf disable {
            tailf:info "Disable MIB retrieval support";
            type empty;
          }
        }

        // interface * / ethernet oam / link-monitor /
        container link-monitor {
          tailf:info "Enter link-monitor submode";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-if-eoam-lm";

          // interface * / ethernet oam / link-monitor / monitoring
          container monitoring {
            tailf:info "Monitoring support";
            tailf:cli-delete-when-empty;
            tailf:cli-reset-container;
            presence true;
            leaf disable {
              tailf:info "Disable monitoring";
              type empty;
            }
          }
        }

        // interface * / ethernet oam / require-remote /
        container require-remote {
          tailf:info "Enter require-remote submode";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-if-eoam-require";

          // interface * / ethernet oam / require-remote / link-monitoring
          leaf link-monitoring {
            tailf:info "Requirement of Link monitoring support";
            type empty;
          }
        }

        // interface * / ethernet oam / action /
        container action {
          tailf:info "Enter action submode";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-if-eoam-action";

          // interface * / ethernet oam / action / critical-event
          leaf critical-event {
            tailf:info "Action to perform when a critical event occurs";
            type if-eth-oam-action-type;
          }

          // interface * / ethernet oam / action / dying-gasp
          leaf dying-gasp {
            tailf:info "Action to perform when a dying gasp occurs";
            type if-eth-oam-action-type;
          }

          // interface * / ethernet oam / action / capabilities-conflict
          leaf capabilities-conflict {
            tailf:info "Action to perform when a capabilities conflict occurs";
            type if-eth-oam-action-type;
          }

          // interface * / ethernet oam / action / discovery-timeout
          leaf discovery-timeout {
            tailf:info "Action to perform when discovery timeout occurs";
            type if-eth-oam-action-type;
          }

          // interface * / ethernet oam / action / remote-loopback
          leaf remote-loopback {
            tailf:info "Action to perform when a remote loopback event occurs";
            type if-eth-oam-action-type;
          }

          // interface * / ethernet oam / action / session-down
          leaf session-down {
            tailf:info "Action to perform when a session goes down";
            type if-eth-oam-action-type;
          }

          // interface * / ethernet oam / action / wiring-conflict
          leaf wiring-conflict {
            tailf:info "Action to perform when a wiring conflict occurs";
            type if-eth-oam-action-type;
          }
        }

        // interface * / ethernet oam / remote-loopback
        container remote-loopback {
          tailf:info "Remote-loopback support";
          tailf:cli-delete-when-empty;
          tailf:cli-reset-container;
          presence true;
          leaf disable {
            tailf:info "Disable remote loopback support";
            type empty;
          }
        }

        // interface * / ethernet oam / hello-interval
        leaf hello-interval {
          tailf:info "Hello interval time";
          type enumeration {
            enum 100ms {
              tailf:info "100 millisecond hello interval";
            }
            enum 1s {
              tailf:info "1 second hello interval";
            }
          }
        }
      }

      // interface * / ethernet egress-filter
      leaf egress-filter {
        tailf:info "Override default egress-filter configuration on this interface";
        type enumeration {
          enum disable {
            tailf:info "No egress filtering, regardless of the global configuration";
          }
          enum strict {
            tailf:info "Strict egress filtering, regardless of the global configuration";
          }
        }
      }

      // interface * / ethernet loopback
      container loopback {
        tailf:info "Ethernet Loopback configuration";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-if-ethlb";

        // interface * / ethernet loopback / permit
        container permit {
          tailf:info "Permit Ethernet Loopback on this interface";
          leaf external {
            tailf:info "Permit external (wire-facing) loopback on this interface";
            type empty;
          }
          leaf internal {
            tailf:info "Permit internal (bridge-facing) loopback on this interface";
            type empty;
          }
        }
      }

      // interface * / ethernet service-activation-test
      container service-activation-test {
        tailf:info "Service activation test config";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-if-ethsat";

        // interface * / ethernet service-activation-test / permit
        leaf permit {
          tailf:info "Config to allow Service Activation Tests on the interface";
          type enumeration {
            enum all {
              tailf:info "Config to allow Service Activation Tests in either direction";
            }
            enum external {
              tailf:info "Config to only allow external Service Activation Tests";
            }
            enum internal {
              tailf:info "Config to only allow internal Service Activation Tests";
            }
          }
        }
      }
    }


    // interface * / ethernet-services
    container ethernet-services {
      tailf:info "Ethernet related services";
      // interface * / ethernet-services access-group
      list access-group {
        tailf:info "Specify access control for packets";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-remove-before-change;
        key direction;
        leaf direction {
          type enumeration {
            enum egress {
              tailf:info "Filter outgoing packets";
            }
            enum ingress {
              tailf:info "Filter incoming packets";
            }
          }
        }
        leaf name {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          tailf:cli-suppress-leafref-in-diff;
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:ethernet-services/access-list/name";
          }
          type string {
            tailf:info "WORD;;Access-list name";
          }
        }
      }
    }

    // interface * / speed
    leaf speed {
      tailf:info "Set the ethernet speed on an interface";
      tailf:cli-full-command;
      type enumeration {
        enum "10" {
          tailf:info "Ethernet is 10Mb";
        }
        enum "100" {
          tailf:info "Ethernet is 100Mb";
        }
        enum "1000" {
          tailf:info "Ethernet is 1Gb";
        }
      }
    }

    // interface * / transceiver
    container transceiver {
      tailf:info "transceiver commands";
      container permit {
        tailf:info "permit";
        container pid {
          tailf:info "Permit pluggable pid (Product ID) all";
          leaf all {
            tailf:info "all";
            type empty;
          }
        }
      }
    }

    // interface * / nv
    container nv {
      tailf:info "Network Virtualisation interface configuration";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-if-nV";

      // interface * / nv / edge
      container edge {
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-nV-Edge";

        // interface * / nv / edge / interface
        leaf interface {
          tailf:info "nV Edge inter-rack interconnect interface";
          type empty;
        }
      }

      // interface * / nv / service-policy input *
      container service-policy {
        tailf:info "Configure QoS Service policy";
        list input {
          tailf:info "Configure a policy in the input direction";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Name of the service policy";
            }
          }
        }
      }

      // interface * / nv / satellite-fabric-link #
      container satellite-fabric-link {
        tailf:info "Satellite Fabric Link configuration";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-satellite-fabric-link";
        tailf:cli-incomplete-command;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf satellite {
          tailf:info "Satellite ID";
          tailf:cli-hide-in-submode;
          type uint16 {
            tailf:info "<100-65534>;;Satellite ID";
            range "100..65534";
          }
        }

        // interface * / nv / satellite-fabric-link # / redundancy
        container redundancy {
          tailf:cli-break-sequence-commands;
          tailf:info "Redundancy configuration";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-nV-red";

          // interface * / nv / satellite-fabric-link # / redundancy / iccp-group
          leaf iccp-group {
            tailf:info "Redundancy group ID";
            type uint32 {
              tailf:info "<1-4294967295>;;Redundancy group ID";
            }
          }

          // interface * / nv / satellite-fabric-link # / redundancy / minimum preferred links
          container minimum {
            tailf:info "Min-links configuration";
            container preferred {
              tailf:info "Soft Min-links";
              leaf links {
                tailf:info "Active links";
                type uint8 {
                  tailf:info "<1-64>;;Preferred minimum number of active links";
                  range "1..64";
                }
              }
            }
          }
        }

        // interface * / nv / satellite-fabric-link # / remote-ports
        container remote-ports {
          tailf:info "Remote ports configuration";
          choice remote-ports-choice {
            leaf GigabitEthernet {
              tailf:info "Remote ports type";
              type string {
                tailf:info "Slot/Subslot/Port(s)";
              }
            }
            leaf TenGigE {
              tailf:info "Remote ports type";
              type string {
                tailf:info "Slot/Subslot/Port(s)";
              }
            }
          }
        }

        // interface * / nv / satellite-fabric-link # / minimum required links
        container minimum {
          tailf:info "Min-links configuration";
          container required {
            tailf:info "Hard Min-links";
            leaf links {
              tailf:info "Active links";
              type uint8 {
                tailf:info "<1-64>;;Required minimum number of active links";
              }
            }
          }
        }
      }
    }

    // interface * / attach generic-interface-list
    container attach {
      tailf:info "Attach to an interface list";
      leaf generic-interface-list {
        tailf:info "Interface List";
        type string {
          tailf:info "WORD;;The name of the interface list";
        }
      }
    }
  }

  // grouping interface-common-grouping
  grouping interface-common-grouping {

    // interface * / apply-group *
    uses apply-group-grouping;

    // interface * / description
    leaf description {
      tailf:info "Set description for this interface";
      tailf:cli-multi-value;
      tailf:cli-preformatted;
      tailf:cli-no-value-on-delete;
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;Description for this interface";
      }
    }

    // interface * / bandwidth
    leaf bandwidth {
      tailf:info "Set the bandwidth of an interface";
      tailf:cli-full-command;
      type uint32 {
        tailf:info "<0-4294967295>;;bandwidth in kbps";
      }
    }

    // interface * / loopback
    leaf loopback {
      tailf:info "Set the loopback mode on an interface";
      tailf:cli-full-command;
      type enumeration {
        enum "external" {
          tailf:info "Enable external loopback (requires loopback connector)";
        }
        enum "internal" {
          tailf:info "Enable internal loopback";
        }
        enum "line" {
          tailf:info "Enable line loopback";
        }
      }
    }

    // interface * / mtu
    leaf mtu {
      tailf:info "Set the MTU on an interface";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<64-65535>;;MTU size in bytes";
        range "64..65535";
      }
    }

    // interface * / negotiation auto
    container negotiation {
      tailf:info "Select autonegotiation mode";
      container auto {
        tailf:info "Perform link autonegotiation";
        tailf:cli-delete-when-empty;
        presence true;
        leaf allow-overrides {
          tailf:info "Allow configured values to override negotiated settings";
          type empty;
        }
      }
    }

    // interface * / monitor-session *
    uses interface-monitor-session-grouping;

    // interface * / encapsulation
    container encapsulation {
      tailf:info "Set the encapsulation on an (sub)interface";
      choice encapsulation-choice {

        // interface * / encapsulation frame-relay
        container frame-relay {
          tailf:info "Frame Relay networks";
          tailf:cli-delete-when-empty;
          presence true;
          leaf IETF {
            tailf:info "Use RFC1490/RFC2427 encapsulation";
            type empty;
          }
        }

        // interface * / encapsulation hdlc
        leaf hdlc {
          tailf:info "Serial HDLC synchronous";
          tailf:cli-full-command;
          type empty;
        }

        // interface * / encapsulation mfr
        leaf mfr {
          tailf:info "Multilink Frame Relay Member Link";
          tailf:cli-full-command;
          type empty;
        }

        // interface * / encapsulation ppp
        leaf ppp {
          tailf:info "Point-to-Point protocol";
          tailf:cli-full-command;
          type empty;
        }

        // interface * / encapsulation default
        leaf default {
          tailf:info "Packets unmatched by other service instances";
          tailf:cli-full-command;
          type empty;
        }

        // interface * / encapsulation untagged
        container untagged {
          tailf:info "Packets with no explicit VLAN tag";
          tailf:cli-compact-syntax;
          tailf:cli-delete-when-empty;
          presence true;
          // +ingress
        }

        // interface * / encapsulation ambiguous
        container ambiguous {
          tailf:info "Ambiguous L3 VLAN configuration";

          // interface * / encapsulation ambiguous dot1q
          container dot1q {
            tailf:info "IEEE 802.1Q VLAN-tagged packets";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf-list vlan-id {
              tailf:cli-drop-node-name;
              tailf:cli-range-list-syntax;
              tailf:cli-replace-all;
              type union {
                type uint16 {
                  tailf:info "<1-4094>;;Single VLAN id";
                  range "1..4094";
                }
                type enumeration {
                  enum any {
                    tailf:info "Match any VLAN id";
                  }
                }
              }
            }
            leaf-list second-dot1q {
              tailf:info "IEEE 802.1Q VLAN-tagged packets";
              tailf:cli-optional-in-sequence;
              tailf:cli-range-list-syntax;
              tailf:cli-replace-all;
              type union {
                type uint16 {
                  tailf:info "<1-4094>;;Single VLAN id";
                  range "1..4094";
                }
                type enumeration {
                  enum any {
                    tailf:info "Match any VLAN id";
                  }
                }
              }
            }
          }
        }

        // interface * / encapsulation dot1q
        container dot1q {
          tailf:info "IEEE 802.1Q VLAN-tagged packets";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
//#if (ENCAP_DOT1Q_AS_LEAF)
//#replace (^//) (  )
//        leaf vlan-id {
//          tailf:cli-drop-node-name;
//          type string;
//        }
//        leaf second-dot1q {
//          tailf:info "IEEE 802.1Q VLAN-tagged packets";
//          tailf:cli-optional-in-sequence;
//          type string;
//        }
//#else
          leaf-list vlan-id {
            tailf:cli-drop-node-name;
            tailf:cli-range-list-syntax;
            tailf:cli-replace-all;
            type union {
              type uint16 {
                tailf:info "<1-4094>;;Single VLAN id";
                range "1..4094";
              }
              type enumeration {
                enum any {
                  tailf:info "Match any VLAN id";
                }
                enum priority-tagged {
                  tailf:info "IEEE 802.1ad priority-tagged packets";
                }
                enum untagged {
                  tailf:info "Untagged";
                }
              }
            }
          }
          leaf-list second-dot1q {
            tailf:info "IEEE 802.1Q VLAN-tagged packets";
            tailf:cli-optional-in-sequence;
            tailf:cli-range-list-syntax;
            tailf:cli-replace-all;
            type union {
              type uint16 {
                tailf:info "<1-4094>;;Single VLAN id";
                range "1..4094";
              }
              type enumeration {
                enum any {
                  tailf:info "Match any VLAN id";
                }
              }
            }
          }
//#endif
          leaf exact {
            tailf:info "Do not allow further inner tags";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          container ingress {
            tailf:info "Perform MAC-based matching";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            leaf source-mac {
              tailf:info "Perform source MAC-based matching";
              type string {
                tailf:info "H.H.H;;MAC Address";
              }
            }
          }
        }

        // interface * / encapsulation dot1ad
        container dot1ad {
          tailf:info "IEEE 802.1ad VLAN-tagged packets";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf-list vlan-id {
            tailf:cli-drop-node-name;
            tailf:cli-range-list-syntax;
            tailf:cli-replace-all;
            type union {
              type uint16 {
                tailf:info "<1-4094>;;Single VLAN id";
                range "1..4094";
              }
              type enumeration {
                enum any {
                  tailf:info "Match any VLAN id";
                }
                enum priority-tagged {
                  tailf:info "IEEE 802.1ad priority-tagged packets";
                }
              }
            }
          }

          // interface * / encapsulation dot1ad * dot1q
          leaf-list dot1q {
            tailf:info "IEEE 802.1Q VLAN-tagged packets";
            tailf:cli-range-list-syntax;
            tailf:cli-replace-all;
            tailf:cli-optional-in-sequence;
            type union {
              type uint16 {
                tailf:info "<1-4094>;;Single VLAN id";
                range "1..4094";
              }
              type enumeration {
                enum any {
                  tailf:info "Match any VLAN id";
                }
              }
            }
          }

          // interface * / encapsulation dot1ad * exact
          leaf exact {
            tailf:info "Do not allow further inner tags";
            type empty;
          }
        }
      }
    }

    // interface * / pppoe enable
    container pppoe {
      tailf:info "PPP over Ethernet";
      container enable {
        tailf:info "Enable PPPoE on the interface";
        tailf:cli-delete-when-empty;
        presence true;

        // interface * / pppoe enable group
        leaf bba-group {
          tailf:info "Specify the bba-group to use with the interface";
          type string {
            tailf:info "WORD;;The bba-group to use";
          }
        }
      }
    }

    // interface * / frame-relay
    container frame-relay {
      tailf:info "Frame Relay interface configuration commands";

      // interface * / frame-relay lmi disable
      container lmi {
        tailf:info "Disable LMI";
        leaf disable {
          tailf:info "Disable LMI";
          type empty;
        }
      }

      // interface * / frame-relay lmi-type
      container lmi-type {
        tailf:info "Use CISCO-ANSI-CCITT type LMI to select type";
        tailf:cli-delete-when-empty;
        presence true;
        leaf type {
          tailf:cli-drop-node-name;
          type enumeration {
            enum ansi {
              tailf:info "Use ANSI type LMI";
            }
            enum cisco {
              tailf:info "Use CISCO type LMI";
            }
            enum q933a {
              tailf:info "Use CCITT type LMI";
            }
          }
        }
      }

      // interface * / frame-relay intf-type
      container intf-type {
        tailf:info "Use DTE/DCE mode for LMI";
        tailf:cli-delete-when-empty;
        presence true;
        leaf type {
          tailf:cli-drop-node-name;
          type enumeration {
            enum dce {}
          }
        }
      }

      // interface * / frame-relay multilink
      container multilink {
        tailf:info "Multilink Frame Relay interface configuration commands";
        leaf bandwidth-class {
          tailf:info "Multilink Frame Relay bandwidth class";
          type enumeration {
            enum "a" {
              tailf:info "Bandwidth class A";
            }
            enum "b" {
              tailf:info "Bandwidth class B";
            }
            enum "c" {
              tailf:info "Bandwidth class C";
            }
          }
        }
      }
    }

    // interface * / frequency synchronization
    container frequency {
      tailf:info "Frequency Synchronization configuration";

      // interface * / frequency synchronization
      container synchronization {
        tailf:info "Frequency Synchronization configuration";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-if-freqsync";
        presence true;

        // interface * / frequency synchronization / selection
        container selection {
          tailf:info "Selection configuration commands";
          leaf input {
            tailf:info "Enable this source for selection";
            type empty;
          }
        }

        // interface * / frequency synchronization / priority
        leaf priority {
          tailf:info "Source priority";
          type uint8 {
            tailf:info "<1-254>;;Source priority";
            range "1..254";
          }
        }

        // interface * / frequency synchronization / wait-to-restore
        leaf wait-to-restore {
          tailf:info "Set the wait-to-restore time";
          type uint8 {
            tailf:info "<0-12>;;Wait-to-restore time, in minutes";
            range "0..12";
          }
        }

        // interface * / frequency synchronization / time-of-day-priority
        leaf time-of-day-priority {
          tailf:info "Source time-of-day priority";
          type uint8 {
            tailf:info "<1-254>;;Source time-of-day priority";
            range "1..254";
          }
        }

        // interface * / frequency synchronization / quality
        container quality {
          tailf:info "Quality level configuration";
          container receive {
            tailf:info "Adjust the received quality level";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            uses freqsync-quality-grouping;
          }
          container transmit {
            tailf:info "Set the quality level to be transmitted";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            uses freqsync-quality-grouping;
          }
        }
      }
    }

    // interface * / service-policy
    uses interface-service-policy-grouping;

    // interface * / vrf
    leaf vrf {
      tailf:info "Set VRF in which the interface operates";
      tailf:cli-full-command;
      tailf:cli-diff-dependency "/cisco-ios-xr:vrf";
      cisco-ios-xr:if-vrf-restore;
      type vrf-type;
    }

    // interface * / aaa radius attribute
    container aaa {
      tailf:info "AAA configuration";
      container radius {
        tailf:info "AAA radius configuration";
        container attribute {
          tailf:info "AAA radius attribute";
          leaf nas-port-type {
            tailf:info "AAA nas-port-type attribute";
            type union {
              type uint8 {
                tailf:info "<0-44>;;Nas Port Type value";
              }
              type string {
                tailf:info "WORD;;Nas Port Type name";
              }
            }
          }
        }
      }
    }

    // interface * / ptp
    container ptp {
      tailf:info "Precision Time Protocol config";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-if-ptp";
      presence true;

      // interface * / ptp / cos
      container cos {
        tailf:info "Specify the COS value to use";
        leaf value {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<0-7>;;The COS value to use";
            range "0..7";
          }
        }

        // interface * / ptp / cos event
        leaf event {
          tailf:info "Specify the COS value to use";
          type uint8 {
            tailf:info "<0-7>;;The COS value to use";
            range "0..7";
          }
        }

        // interface * / ptp / cos general
        leaf general {
          tailf:info "Specify the COS value to use";
          type uint8 {
            tailf:info "<0-7>;;The COS value to use";
            range "0..7";
          }
        }
      }

      // interface * / ptp / profile
      leaf profile {
        tailf:info "PTP Profile to use on this interface";
        type string {
          tailf:info "WORD;;Name of Profile";
        }
      }

      // interface * / ptp / ipv4-ttl
      leaf ipv4-ttl {
        tailf:info "Specify the IPv4 TTL value to use";
        type uint8 {
          tailf:info "<1-255>;;The IPv4 TTL value to use";
          range "1..255";
        }
      }

      // interface * / ptp / ipv6-hop-limit
      leaf ipv6-hop-limit {
        tailf:info "Specify the IPv6 hop limit value to use";
        type uint8 {
          tailf:info "<1-255>;;The IPv6 hop limit value to use";
          range "1..255";
        }
      }

      // interface * / ptp / master
      container master {
        tailf:info "Add a master to listen to on this interface";

        // interface * / ptp / master ipv4 *
        list ipv4 {
          tailf:info "IPv4 address";
          tailf:cli-mode-name "config-if-ptp-master";
          key address;
          leaf address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Specify the master's IPv4 address";
            }
          }

          // interface * / ptp / master ipv4 * / priority
          leaf priority {
            tailf:info "Specify the priority of this master";
            type uint8 {
              tailf:info "<0-255>;;The local priority value to use for this master";
            }
          }
        }
      }

      // interface * / ptp / local-priority
      leaf local-priority {
        tailf:info "Configure a local priority";
        type uint8 {
          tailf:info "<1-255>;;The local priority value to use";
          range "1..255";
        }
      }

      // interface * / ptp / delay-assymetry
      container delay-asymmetry {
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf value {
          tailf:cli-drop-node-name;
          type int32 {
            tailf:info "<-500000000,+500000000>;;How much longer the master to slave path takes than the reverse";
          }
        }
        leaf units {
          tailf:cli-drop-node-name;
          type enumeration {
            enum nanoseconds {
              tailf:info "Use nanoseconds as the delay asymmetry units";
            }
            enum microseconds {
              tailf:info "Use microseconds as the delay asymmetry units";
            }
            enum milliseconds {
              tailf:info "Use milliseconds as the delay asymmetry units";
            }
          }
        }
      }

      // interface * / ptp / delay-response
      container delay-response {
        tailf:info "Delay-Response message options";

        // interface * / ptp / delay-response timeout
        leaf timeout {
          tailf:info "Configure the delay-response timeout value";
          type uint32 {
            tailf:info "<100-100000>;;The timeout value, in milliseconds";
            range "100..100000";
          }
        }

        // interface * / ptp / delay-response grant-duration
        leaf grant-duration {
          tailf:info "Configure the delay-response unicast grant duration value";
          type uint16 {
            tailf:info "<60-1000>;;The grant duration, in seconds";
            range "60..1000";
          }
        }
      }

      // interface * / ptp / X
      uses ptp-profile-grouping;
    }

    // interface * / ipv4
    container ipv4 {
      tailf:info "IPv4 interface subcommands";

      // interface * / ipv4 point-to-point
      leaf point-to-point {
        tailf:info "Enable point-to-point handling for this interface.";
        tailf:cli-full-command;
        type empty;
      }

      // interface * / ipv4 address
      choice address-choice {

        // interface * / ipv4 address [mask]
        case yes {
          container address {
            tailf:info "Set the IPv4 address of an interface";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            cisco-ios-xr:trim-remove-before-change "route-tag" {
              cli:arguments "ip mask";
            }
            leaf ip {
              tailf:cli-drop-node-name;
              tailf:cli-remove-before-change;
              tailf:cli-incomplete-command;
              tailf:cli-incomplete-no;
              type string {
                tailf:info "A.B.C.D;;IP address";
                pattern '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}'
                  +'([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])';
              }
            }
            leaf mask {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "A.B.C.D or /X;;IP subnet mask or /prefix";
                pattern '((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}'
                  +'([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]))|(/[0-9]+)';
              }
            }
            leaf route-tag {
              tailf:info "Route-tag to be associated with this address";
              type uint32 {
                tailf:info "<1-4294967295>;;Route-tag value (default: no tag)";
                range "1..4294967295";
              }
            }
          }

          // interface * / ipv4 address [mask] secondary
          container address-secondary-list {
            tailf:cli-drop-node-name;
            list address {
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              key "ip secondary";
              leaf ip {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IP address";
                  pattern '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}'
                    +'([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])';
                }
              }
              leaf secondary {
                type enumeration {
                  enum secondary {
                    tailf:info "Make this IPv4 address a secondary address";
                  }
                }
              }
              leaf mask {
                tailf:cli-drop-node-name;
                tailf:cli-prefix-key {
                  tailf:cli-before-key 2;
                }
                type string {
                  tailf:info "A.B.C.D or /X;;IP subnet mask or /prefix";
                  pattern '((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}'
                    +'([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]))|(/[0-9]+)';
                }
              }
              leaf route-tag {
                tailf:info "Route-tag to be associated with this address";
                type uint32 {
                  tailf:info "<1-4294967295>;;Route-tag value (default: no tag)";
                  range "1..4294967295";
                }
              }
            }
          }
        }

        // interface * / ipv4 address dhcp
        container address-dhcp {
          tailf:cli-drop-node-name;
          container address {
            tailf:info "Set the IPv4 address of an interface";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf dhcp {
              tailf:info "IPv4 address and Mask negotiated via DHCP";
              type empty;
            }
            // interface * / ipv4 address dhcp options 60 ascii
            leaf options {
              tailf:info "options to set";
              tailf:cli-incomplete-command;
              type enumeration {
                enum 60 {
                  tailf:info "Configure Vendor id (Option 60)";
                }
              }
            }
            leaf ascii {
              tailf:info "Option 60 in ascii";
              type string {
                tailf:info "WORD;;Enter ascii pattern";
              }
            }
          }
        }
      }

      // interface * / ipv4 access-group * ingress
      // interface * / ipv4 access-group * egress
      list access-group {
        tailf:info "Specify access control for packets";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        tailf:cli-remove-before-change;
        key direction;
        leaf direction {
          type enumeration {
            enum egress {
              tailf:info "Filter outgoing packets";
            }
            enum ingress {
              tailf:info "Filter incoming packets";
            }
          }
        }
        leaf name {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          tailf:cli-suppress-leafref-in-diff;
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:ipv4/access-list/named-acl/name";
          }
          type string {
            tailf:info "WORD;;access-list name";
          }
        }
        leaf hardware-count {
          tailf:cli-break-sequence-commands;
          tailf:info "Count packets in hardware";
          type empty;
        }
        leaf interface-statistics {
          tailf:info "Per interface statistics in hardware";
          type empty;
        }
      }

      // interface * / ipv4 helper-address vrf *
      container helper-address {
        tailf:info "Specify a destination address for UDP broadcasts";
        list vrf {
          tailf:info "Select a VRF to be displayed";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key "name address";
          leaf name {
            type string {
              tailf:info "WORD;;VPN Routing/Forwarding instance name";
            }
          }
          leaf address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP destination address";
            }
          }
        }
      }

      // interface * / ipv4 mask-reply
      leaf mask-reply {
        tailf:info "Enable sending ICMP mask reply messages";
        type empty;
      }

      // interface * / ipv4 redirects
      leaf redirects {
        tailf:info "Enable sending ICMP Redirect messages";
        type empty;
      }

      // interface * / ipv4 directed-broadcast
      leaf directed-broadcast {
        tailf:info "Enable forwarding of directed broadcasts";
        type empty;
      }

      // interface * / ipv4 mtu
      leaf mtu {
        tailf:info "Set IPv4 Maximum Transmission Unit";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<68-65535>;;MTU (bytes)";
          range "68..65535";
        }
      }

      // interface * / ipv4 tcp-mss-adjust
      leaf tcp-mss-adjust {
        tailf:info "Enable tcp mss adjust for this interface.";
        type enumeration {
          enum "enable";
        }
      }

      // interface * / ipv4 bgp policy
      container bgp {
        tailf:info "Enable BGP policy based feature";
        container policy {
          tailf:info "BGP policy";

          // interface * / ipv4 bgp policy propagation input
          container propagation {
            tailf:info "BGP QoS policy propagation";
            container input {
              tailf:info "QPPB on input";

              // interface * / ipv4 bgp policy propagation input qos-group
              container qos-group {
                tailf:info "QPPB using Qos Group";
                choice qos-group-choice {
                  // interface * / ipv4 bgp policy propagation input qos-group destination
                  container destination {
                    tailf:info "QPPB on destination IP address";
                    presence true;
                  }
                  // interface * / ipv4 bgp policy propagation input qos-group source
                  container source {
                    tailf:info "QPPB on source IP address";
                    tailf:cli-delete-when-empty;
                    tailf:cli-reset-container;
                    presence true;
                    leaf ip-precedence {
                      tailf:info "QPPB using IP Precedence";
                      type enumeration {
                        enum destination {
                          tailf:info "QPPB on destination IP address";
                        }
                        enum source {
                          tailf:info "QPPB on source IP address";
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }

      // interface * / ipv4 pim
      container pim {
        tailf:info "PIM interface commands";
        leaf bidir-neighbor-filter {
          tailf:info "PIM bidir capable peering filter";
          type union {
            type uint8 {
              tailf:info "<1-99>;;Access list number";
              range "1..99";
            }
            type string {
              tailf:info "WORD;;IP Named Standard Access list";
            }
          }
        }
        leaf bsr-border {
          tailf:info "Border of PIM domain";
          type empty;
        }
        leaf dr-priority {
          tailf:info "PIM router DR priority";
          type uint32 {
            tailf:info "<0-4294967294>;;DR priority, preference given to larger value";
            range "0..4294967294";
          }
        }
        leaf nbma-mode {
          tailf:info "Use Non-Broadcast Multi-Access (NBMA) mode on interface";
          type empty;
        }
        leaf neighbor-filter {
          tailf:info "PIM peering filter";
          type union {
            type uint8 {
              tailf:info "<1-99>;;Access list number";
              range "1..99";
            }
            type string {
              tailf:info "WORD;;IP Named Standard Access list";
            }
          }
        }
        container query-interval {
          tailf:info "PIM router query interval";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          choice interval-choice {
            case secs {
              leaf secs {
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<1-65535>;;Query interval in seconds or milliseconds";
                  range "1..65535";
                }
              }
            }
            case msec {
              leaf msecs {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type uint16 {
                  tailf:info "<1-65535>;;Query interval in seconds or milliseconds";
                  range "100..65535";
                }
                must "../msec";
              }
              leaf msec {
                type empty;
              }
            }
          }
        }
        choice pim-mode {
          leaf sparse-dense-mode {
            tailf:info "Enable PIM sparse-dense-mode operation";
            type empty;
          }
          container dense-mode {
            tailf:cli-reset-container;
            tailf:info "Enable PIM dense-mode operation";
            presence true;
            container proxy-register {
              tailf:cli-reset-container;
              tailf:info "Send proxy registers";
              choice proxy-mode {
                leaf list {
                  tailf:info "Access list";
                  type union {
                    type uint16 {
                      tailf:info "<100-199>;;Extended access list number";
                      range "100..199";
                    }
                    type uint16 {
                      tailf:info "<2000-2699>;;Extended access list number (expanded range)";
                      range "2000..2699";
                    }
                    type string {
                      tailf:info "WORD;;IP named extended access list";
                    }

                  }
                }
                leaf route-map {
                  tailf:info "Route-map";
                  type string {
                    tailf:info "WORD;;Route-map reference";
                  }
                }
              }
            }
          }
          leaf sparse-mode {
            tailf:info "Enable PIM sparse-mode operation";
            type empty;
          }
        }
        container state-refresh {
          tailf:info "PIM DM State-Refresh configuration";
          container origination-interval {
            tailf:info "PIM State-Refresh origination interval";
            tailf:cli-delete-when-empty;
            tailf:cli-reset-container;
            presence true;
            leaf secs {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<1-100>;;Interval in seconds";
                range "1..100";
              }
            }
          }
        }
      }

      // interface * / ipv4 verify unicast
      container verify {
        tailf:info "Enable per packet validation";
        container unicast {
          tailf:info "Enable per packet validation for unicast";

          // interface * / ipv4 verify unicast notification
          container notification {
            tailf:info "drop-rate notify";
            leaf threshold {
              tailf:info "Urpf NOTIFY drop rate threshold";
              type uint32 {
                tailf:info "<0-4294967295>;;Drop rate in pps triggering notify - 0 is any drops";
                range "0..4294967295";
              }
            }
          }

          // interface * / ipv4 verify unicast source
          container source {
            tailf:info "Validation of source address";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-all-siblings;
            }
            leaf reachable-via {
              tailf:info "Specify reachability check to apply to the source address";
              type enumeration {
                enum any {
                  tailf:info "Source is reachable via any interface";
                }
                enum rx {
                  tailf:info "Source is reachable via interface on which packet was received";
                }
              }
            }
            leaf allow-self-ping {
              tailf:cli-break-sequence-commands;
              tailf:info "Allow router to ping itself (opens vulnerability in verification)";
              type empty;
            }
            leaf allow-default {
              tailf:info "Allow default route to match when checking source address";
              type empty;
            }
          }
        }
      }

      // interface * / ipv4 router
      container router {
        tailf:info "IP router interface commands";
        container isis {
          tailf:info "IS-IS Routing for IP";
          presence true;
          tailf:cli-reset-container;
          leaf routing-process {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;Routing process tag";
            }
          }
        }
      }

      // interface * / ipv4 unnumbered
      container unnumbered {
        tailf:info "Enable IPv4 processing without an explicit address";
        uses interface-name-grouping;
      }

      // interface * / ipv4 unreachables disable
      container unreachables {
        tailf:info "Enable sending ICMP Unreachable messages";
        leaf disable {
          tailf:info "Override sending of ICMP Unreachable messages";
          type empty;
        }
      }

      // interface * / ipv4 flowspec disable
      container flowspec {
        tailf:info "Flowspec on IPv4 interface";
        leaf disable {
          tailf:info "Disable FlowSpec on this interface";
          type empty;
        }
      }
    }

    // interface * / arp
    container arp {
      tailf:info "Configure Address Resolution Protocol";

      // interface * / arp timeout
      leaf timeout {
        tailf:info "Set ARP cache timeout";
        tailf:cli-full-command;
        type uint32 {
          tailf:info "<30-2144448000>;;Seconds";
          range "30..2144448000";
        }
      }

      // interface * / arp purge-delay
      leaf purge-delay {
        tailf:info "Delay purging ARP entries when the interface goes down";
        type uint16 {
          tailf:info "<1-65535>;;Purge delay in seconds";
          range "1..65535";
        }
      }

      // interface * / arp learning
      leaf learning {
        tailf:info "Configuration for dynamic learning of ARP entries";
        tailf:cli-full-command;
        type enumeration {
          enum disable {
            tailf:info "Disable dynamic learning of ARP entries";
          }
          enum local {
            tailf:info "Enable dynamic learning only for local subnet only";
          }
        }
      }

      // interface * / arp gratuitous ignore
      container gratuitous {
        tailf:info "Configure the handling of Gratuitous ARP packets";
        leaf ignore {
          tailf:info "Ignore the receipt of Gratuitous ARP packets";
          type empty;
        }
      }
    }

    // interface * / proxy-arp
    leaf proxy-arp {
      tailf:info "Enable proxy ARP";
      tailf:cli-full-command;
      type empty;
    }

    // interface * / local-proxy-arp
    leaf local-proxy-arp {
      tailf:info "Enable local proxy ARP";
      type empty;
    }

    // interface * / ipv6
    container ipv6 {
      tailf:info "IPv6 interface subcommands";

      // interface * / ipv6 mtu
      leaf mtu {
        tailf:info "Set IPv6 Maximum Transmission Unit";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<1280-65535>;;MTU (bytes)";
          range "1280..65535";
        }
      }

      // interface * / ipv6 tcp-mss-adjust
      leaf tcp-mss-adjust {
        tailf:info "Enable tcp mss adjust for this interface.";
        type enumeration {
          enum "enable";
        }
      }

      // interface * / ipv6 nd
      container nd {
        tailf:info "IPv6 interface Neighbor Discovery subcommands";

        // interface * / ipv6 nd cache-limit
        leaf cache-limit {
          tailf:info "Set Cache Limit for neighbor entry";
          tailf:cli-full-command;
          type uint32 {
            tailf:info "<0-128000>;;Cache Limit";
            range "1..128000";
          }
        }

        // interface * / ipv6 nd router-preference
        leaf router-preference {
          tailf:info "IPv6 ND router-preference";
          type enumeration {
            enum low {
              tailf:info "Low default router preference";
            }
            enum  high {
              tailf:info "High default router preference";
            }
            enum medium {
              tailf:info "Medium default router preference";
            }
          }
        }

        // interface * / ipv6 nd dad attempts
        container dad {
          tailf:info "Duplicate Address Detection";
          leaf attempts {
            tailf:info "Set IPv6 Duplicate Address Detection Transmits";
            type uint16 {
              tailf:info "<0-600>;;Number of attempts";
              range "0..600";
            }
          }
        }

        // interface * / ipv6 nd managed-config-flag
        leaf managed-config-flag {
          tailf:info "Hosts should use stateful protocol for address config";
          tailf:cli-full-command;
          type empty;
        }

        // interface * / ipv6 nd ns-interval
        leaf ns-interval {
          tailf:info "Set advertised NS retransmission interval";
          tailf:cli-full-command;
          type uint32 {
            tailf:info "<1000-4294967295>;;Retransmission interval in milliseconds";
            range "1000..4294967295";
          }
        }

        // interface * / ipv6 nd other-config-flag
        leaf other-config-flag {
          tailf:info "Hosts should use stateful protocol for non-address config";
          tailf:cli-full-command;
          type empty;
        }

        // interface * / ipv6 nd prefix
        container prefix {
          tailf:info "Configure IPv6 Routing Prefix Advertisement";
          list prefix-list {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            key prefix;
            leaf prefix {
              type union {
                type inet:ipv6-address {
                  tailf:info "X:X:X:X::X;;IPv6 link-local address";
                }
                type tailf:ipv6-address-and-prefix-length {
                  tailf:info "X:X::X/<0-128>;;IPv6 prefix x:x::y/<z>";
                }
                type string; // for %zone support
              }
            }
            uses interface-ipv6-nd-prefix-list-grouping;
          }
          container default {
            tailf:info "Specify prefix default parameters";
            uses interface-ipv6-nd-prefix-list-grouping;
          }
        }

        // interface * / ipv6 nd ra
        container ra {
          tailf:info "IPv6 interface ND RA subcommands";

          // interface * / ipv6 nd ra hoplimit
          leaf hoplimit {
            tailf:info "IPv6 ND RA hoplimit";
            tailf:cli-full-command;
            type enumeration {
              enum "unspecified" {
                tailf:info "Unspecified IPv6 ND RA hop-limit value";
              }
            }
          }

          // interface * / ipv6 nd ra mtu
          leaf mtu {
            tailf:info "IPv6 ND RA mtu option configuration";
            tailf:cli-full-command;
            type enumeration {
              enum unspecified {
                tailf:info "Unspecified IPv6 ND RA hop-limit value";
              }
              enum suppress {
                tailf:info "Suppress mtu option in IPv6 ND RA header";
              }
            }
          }
        }

        // interface * / ipv6 nd ra-interval
        container ra-interval {
          tailf:info "Set IPv6 Router Advertisement Interval";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf maximum {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<4-1800>;;Maximum RA Interval (sec)";
              range "4..1800";
            }
          }
          leaf minimum {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<3-1800>;;Minimum RA Interval (sec)";
              range "3..1800";
            }
          }
        }

        // interface * / ipv6 nd ra-lifetime
        leaf ra-lifetime {
          tailf:info "Set IPv6 Router Advertisement Lifetime";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<0-9000>;;RA Lifetime (seconds)";
            range "0..9000";
          }
        }

        // interface * / ipv6 nd reachable-time
        leaf reachable-time {
          tailf:info "Set advertised reachability time";
          tailf:cli-full-command;
          type uint32 {
            tailf:info "<0-3600000>;;Reachability time in milliseconds";
            range "0..3600000";
          }
        }

        // interface * / ipv6 nd redirects
        leaf redirects {
          tailf:info "Enable sending of ICMP Redirect messages";
          tailf:cli-full-command;
          type empty;
        }

        // interface * / ipv6 nd suppress-ra
        leaf suppress-ra {
          tailf:info "Suppress IPv6 Router Advertisements";
          tailf:cli-full-command;
          type empty;
        }

        // interface * / ipv6 nd unicast-ra
        leaf unicast-ra {
          tailf:info "Send Unicast Solicited IPv6 Router Advertisements";
          tailf:cli-full-command;
          type empty;
        }
      }

      // interface * / ipv6 verify unicast source
      container verify {
        tailf:info "Enable per packet validation";
        container unicast {
          tailf:info "Enable per packet validation for unicast";
          container source {
            tailf:info "Validation of source address";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf reachable-via {
              tailf:info "Specify reachability check to apply to the source address";
              type enumeration {
                enum any {
                  tailf:info "Source is reachable via any interface";
                }
                enum rx {
                  tailf:info "Source is reachable via interface on which packet was received";
                }
              }
            }
            leaf allow-default {
              tailf:info "Allow default route to match when checking source address";
              tailf:cli-break-sequence-commands;
              type empty;
            }
            leaf allow-self-ping {
              tailf:info "Allow router to ping itself (opens vulnerability in verification)";
              type empty;
            }
          }
        }
      }

      // interface * / ipv6 address *
      container address {
        tailf:info "Configure IPv6 address on interface";
        list prefix-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-all-siblings;
          }
          key prefix;
          leaf prefix {
            type union {
              type inet:ipv6-address {
                tailf:info "X:X:X:X::X;;IPv6 address";
              }
              type tailf:ipv6-address-and-prefix-length {
                tailf:info "X:X::X/length;;IPv6 prefix";
              }
              type string {
                tailf:info "X:X::X%zone;;IPv6 name or address";
              }
            }
          }
          leaf eui-64 {
            tailf:info "Use eui-64 interface identifier";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          leaf link-local {
            tailf:info "Use link-local address";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          leaf route-tag {
            tailf:info "Route-tag to be associated with this address";
            type uint32 {
              tailf:info "<1-4294967295>;;Route-tag value (default: no tag)";
              range "1..4294967295";
            }
          }
        }
      }

      // interface * / ipv6 enable
      leaf enable {
        tailf:info "Enable IPv6 on interface";
        tailf:cli-full-command;
        type empty;
      }

      // interface * / ipv6 access-group
      list access-group {
        tailf:info "Specify access control for packets";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key direction;
        leaf direction {
          type enumeration {
            enum egress {
              tailf:info "Filter outgoing packets";
            }
            enum ingress {
              tailf:info "Filter incoming packets";
            }
          }
        }
        leaf name {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          tailf:cli-suppress-leafref-in-diff;
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:ipv6/access-list/named-acl/name";
          }
          type string {
            tailf:info "WORD;;access-list name";
          }
        }
        leaf interface-statistics {
          type empty;
        }
      }

      // interface * / ipv6 unreachables disable
      container unreachables {
        tailf:info "Enable sending ICMP Unreachable messages";
        leaf disable {
          tailf:info "Override sending of ICMP Unreachable messages";
          type empty;
        }
      }

      // interface * / ipv6 flowspec disable
      container flowspec {
        tailf:info "Flowspec on IPv6 interface";
        leaf disable {
          tailf:info "Disable FlowSpec on this interface";
          type empty;
        }
      }
    }

    // interface * / lldp
    container lldp {
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-lldp";
      presence true;

      // interface * / lldp / enable
      leaf enable {
        tailf:info "Enable LLDP TX and RX on an interface";
        type empty;
      }

      // interface * / lldp / receive disable
      container receive {
        tailf:info "Disable LLDP RX on an interface";
        leaf disable {
          tailf:info "Disable LLDP RX on an interface";
          type empty;
        }
      }

      // interface * / lldp / transmit disable
      container transmit {
        tailf:info "Disable LLDP TX on an interface";
        leaf disable {
          tailf:info "Disable LLDP TX on an interface";
          type empty;
        }
      }
    }

    // interface * / mpls
    container mpls {
      tailf:info "MPLS interface subcommands";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-if-mpls";

      // interface * / mpls / ip
      leaf ip {
        tailf:info "Configure dynamic MPLS forwarding for IP";
        type empty;
      }

      // interface * / mpls / label-security
      container label-security {
        tailf:info "MPLS label-security for the interface";
        leaf rpf {
          tailf:info "MPLS RPF for incoming packets";
          tailf:cli-full-command;
          type empty;
        }
        leaf multi-label-packet {
          tailf:info "Handling incoming packets with multiple labels on the stack";
          tailf:cli-full-command;
          type enumeration {
            enum drop {
              tailf:info "Drop packets with multiple labels on the stack";
            }
          }
        }
      }

      // interface * / mpls / mtu
      leaf mtu {
        tailf:info "Set the MPLS MTU for the interface";
        type uint16 {
          tailf:info "<68-65535>;;MTU size in bytes";
          range "68..65535";
        }
      }
    }

    // interface * / backup-bw
    container backup-bw {
      tailf:info "Fast-reroute backup bandwidth requirement";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      choice backup-bw-choice {

        // interface * / backup-bw unlimited
        container unlimited {
          tailf:info "Unlimited backup bandwidth";
          tailf:cli-optional-in-sequence;
          choice unlimited-choice {
            leaf any-class-type {
              tailf:info "Specify any bandwidth class type";
              type empty;
            }
            leaf class-type {
              tailf:info "Specify the bandwidth class type";
              type uint8 {
                tailf:info "<0-1>;;Class type number";
                range "0..1";
              }
            }
          }
        }

        // interface * / backup-bw ?
        case value {
          leaf bandwidth {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-4294967295>;;Bandwidth requirement in kbps";
              range "1..4294967295";
            }
          }
          leaf any-class-type {
            tailf:info "Specify any bandwidth class type";
            tailf:cli-optional-in-sequence;
            tailf:cli-full-command;
            type empty;
          }
          leaf class-type {
            tailf:info "Specify the bandwidth class type";
            type uint8 {
              tailf:info "<0-1>;;Class type number";
              range "0..1";
            }
          }
        }
      }
    }

    // interface * / exclude-item *
    uses exclude-item-grouping;

    // interface * / shutdown
    leaf shutdown {
      tailf:info "shutdown the given interface";
      tailf:cli-show-no;
      tailf:cli-full-command;
      type empty;
    }

    // interface * / isis
    uses interface-isis-grouping;

    // interface * / load-interval
    leaf load-interval {
      tailf:info "Specify interval for load calculation for an interface";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<0-600>;;Number of seconds";
        range "0..600" {
          tailf:step 30;
        }
      }
    }

    // interface * / ipsubscriber
    container ipsubscriber {
      tailf:info "Configure IP Subscriber settings";

      // interface * / ipsubscriber interface
      leaf interface {
        tailf:info "Enable IP Static subscriber";
        type empty;
      }

      // interface * / ipsubscriber ipv4
      container ipv4 {
        tailf:info "Enable IPv4 Subscriber";

        // interface * / ipsubscriber ipv4 routed
        container routed {
          tailf:info "Enable Routed IP Subscriber";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-if-ipsub-ipv4-routed";

          // interface * / ipsubscriber ipv4 routed / initiator
          container initiator {
            tailf:info "Configure IP Subscriber initiator";

            // interface * / ipsubscriber ipv4 routed / initiator dhcp
            leaf dhcp {
              tailf:info "Configure DHCP as first-sign-of-life protocol for IPv4 subscriber";
              type empty;
            }
          }
        }

        // interface * / ipsubscriber ipv4 l2-connected
        container l2-connected {
          tailf:info "Enable L2-connected IP Subscriber";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-if-ipsub-ipv4-l2conn";

          // interface * / ipsubscriber ipv4 l2-connected / initiator
          container initiator {
            tailf:info "Configure IP Subscriber initiator";

            // interface * / ipsubscriber ipv4 l2-connected / initiator dhcp
            leaf dhcp {
              tailf:info "Configure DHCP as first-sign-of-life protocol for IPv4 subscriber";
              type empty;
            }

            // interface * / ipsubscriber ipv4 l2-connected / initiator unclassified-source
            container unclassified-source {
              tailf:info "Configure unclassified packets as first-sign-of-life for IPv4 subscriber";
              tailf:cli-reset-container;
              tailf:cli-delete-when-empty;
              presence true;
              leaf address-unique {
                tailf:info "Check for subscriber IP uniqueness during first-sign-of-life";
                type empty;
              }
            }
          }
        }
      }

      // interface * / ipsubscriber ipv6
      container ipv6 {
        tailf:info "Enable Ipv6 Subscriber";

        // interface * / ipsubscriber ipv6 l2-connected
        container l2-connected {
          tailf:info "Enable L2-connected IP Subscriber";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-if-ipsub-ipv6-l2conn";

          // interface * / ipsubscriber ipv6 l2-connected / initiator dhcp
          container initiator {
            tailf:info "Configure IP Subscriber initiator";
            leaf dhcp {
              tailf:info "Configure DHCP as first-sign-of-life protocol for Ipv6 subscriber";
              type empty;
            }
          }
        }
      }
    }

    // interface * / capture software packets
    container capture {
      tailf:info "capture interface packets (platform)(cisco-support)";
      container software {
        tailf:info "capture software switched packets(cisco-support)";
        leaf packets {
          tailf:info "turns on both ingress and egress (platform)(cisco-support)";
          type empty;
        }
      }
    }

    // interface * / address-family
    container address-family {
      tailf:info "AFI/SAFI configuration";

      // interface * / address-family ipv4 multicast
      container ipv4 {
        tailf:info "IPv4 address family";
        leaf multicast {
          tailf:info "Multicast topology";
          type empty;
        }
      }
    }

    // interface * / transport-mode
    container transport-mode {
      tailf:info "Set the transport mode on an interface";
      choice transport-mode-choice {
        leaf wan {
          tailf:info "10GBASE-W WAN SONET/SDH (9.95328Gb/s)";
          type empty;
        }
        container otn {
          tailf:info "10GE over Optical Transport Network (G.709)";
          leaf bit-transparent {
            tailf:info "10GBASE-R transparently mapped into OTU-2";
            type enumeration {
              enum opu1e {
                tailf:info "10GBASE-R over OPU1e without fixed stuffing (11.0491Gb/s)";
              }
              enum opu2e {
                tailf:info "10GBASE-R over OPU2e with fixed stuffing (11.0957Gb/s)";
              }
            }
          }
        }
        leaf rx-only {
          tailf:info "10GE UDLR Mode, Receive Only";
          type empty;
        }
        leaf tx-only {
          tailf:info "10GE UDLR Mode, Transmit Only";
          type empty;
        }
      }
    }

    // interface * / flow-control
    leaf flow-control {
      tailf:info "configure flow-control on the given interface";
      tailf:cli-full-command;
      type enumeration {
        enum bidirectional {
          tailf:info "Enable bidirectional flow-control on an interface";
        }
        enum egress {
          tailf:info "Enable egress flow-control on an interface";
        }
        enum ingress {
          tailf:info "Enable ingress flow-control on an interface";
        }
      }
    }

    // interface * / flow
    // flow [ ipv4 | ipv6 | mpls ] monitor name sampler name { egress | ingress }
    list flow {
      tailf:info "Netflow configuration";
      tailf:cli-suppress-mode;
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      key "proto monitor direction";
      leaf proto {
        type enumeration {
          enum ipv4 {
            tailf:info "IPV4 netflow configuration";
          }
          enum ipv6 {
            tailf:info "IPV6 netflow configuration";
          }
          enum mpls {
            tailf:info "MPLS netflow configuration";
          }
        }
      }
      leaf monitor {
        tailf:info "Specify a flow monitor for packets";
        tailf:cli-expose-key-name;
        tailf:cli-suppress-leafref-in-diff;
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:flow/monitor-map/name";
        }
        type string {
          tailf:info "WORD;;Flow monitor map name";
        }
      }
      leaf sampler {
        tailf:info "Specify a sampler for packets";
        tailf:cli-prefix-key {
          tailf:cli-before-key 3;
        }
        tailf:cli-suppress-leafref-in-diff;
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:sampler-map/name";
        }
        type string {
          tailf:info "WORD;;Sampler map name";
        }
      }
      leaf direction {
        type enumeration {
          enum egress {
            tailf:info "Apply flow monitor on outgoing packets";
          }
          enum ingress {
            tailf:info "Apply flow monitor on incoming packets";
          }
        }
      }
    }

    // interface * / dampening
    container dampening {
      tailf:info "configure state dampening on the given interface";
      tailf:cli-compact-syntax;
      tailf:cli-delete-when-empty;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      presence true;
      leaf half-life {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-45>;;Decay half life (in minutes)";
          range "1..45";
        }
      }
      leaf reuse {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<1-20000>;;Reuse threshold";
          range "1..20000";
        }
      }
      leaf suppress {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint16 {
          tailf:info "<1-20000>;;Suppress threshold";
          range "1..20000";
        }
      }
      leaf max-suppress-time {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-255>;;Max suppress time (in minutes)";
          range "1..255";
        }
      }
    }

    // interface * / logging
    container logging {
      tailf:info "Configure logging for interface";

      // interface * / logging events
      container events {
        tailf:info "Interface events";

        // interface * / logging events all
        leaf all {
          tailf:info "Enable all logging for this interface";
          type empty;
        }

        // interface * / logging events bundle-status
        leaf bundle-status {
          tailf:info "BUNDLE/UNBUNDLE messages";
          type empty;
        }

        // interface * / logging events link-status
        leaf link-status {
          tailf:info "UPDOWN and CHANGE messages";
          type empty;
        }

        // interface * / logging events nfas-status
        leaf nfas-status {
          tailf:info "NFAS D-channel status messages";
          type empty;
        }

        // interface * / logging events spanning-tree status
        container spanning-tree {
          tailf:info "Spanning-tree Interface events";
          leaf status {
            tailf:info "Spanning-tree state change messages";
            type empty;
          }
        }

        // interface * / logging events subif-link-status
        container subif-link-status {
          tailf:info "Sub-interface UPDOWN and CHANGE messages";
          tailf:cli-delete-when-empty;
          presence true;
          leaf ignore-bulk {
            tailf:info "Do not log messages when the main interface is transitioning";
            type empty;
          }
        }

        // interface * / logging events trunk-status
        leaf trunk-status {
          tailf:info "TRUNK status messages";
          type empty;
        }

        // interface * / logging events lsp-status
        uses logging-events-lsp-status-grouping;

        // interface * / logging events sub-lsp-status state
        container sub-lsp-status {
          tailf:info "Enable all sub-LSP state change alarms";
          leaf state {
            tailf:info "Enable all sub-LSP UP/DOWN change alarms";
            type empty;
          }
        }

        // interface * / logging events pcalc-failure
        leaf pcalc-failure {
          tailf:info "Enable logging for path calculation failures";
          tailf:cli-full-command;
          type empty;
        }
      }

      // interface * / logging ip access-list cache
      container ip {
        tailf:info "IP configuration";
        container access-list {
          tailf:info "Access-list";
          container cache {
            tailf:info "Optimized logging";
            leaf in {
              tailf:info "inbound packet logs";
              type empty;
            }
            leaf out {
              tailf:info "outbound packet logs";
              type empty;
            }
          }
        }
      }
    }

    // interface * / storm-control
    container storm-control {
      tailf:info "storm configuration";

      // interface * / storm-control action level
      container action {
        tailf:info "Action to take for storm..control;";
        leaf level {
          tailf:info "Set storm suppression level on this interface";
          type decimal64 {
            fraction-digits 2;
            tailf:info "<0-100>;;Enter Integer part of level as percentage of bandwidth";
            range "0..100";
          }
        }
      }

      // interface * / storm-control broadcast level
      container broadcast {
        tailf:info "Broadcast address storm control";
        leaf level {
          tailf:info "Set storm suppression level on this interface";
          type decimal64 {
            fraction-digits 2;
            tailf:info "<0-100>;;Enter Integer part of level as percentage of bandwidth";
            range "0..100";
          }
        }
      }

      container multicast {
        tailf:info "Multicast address storm control";
        leaf level {
          tailf:info "Set storm suppression level on this interface";
          type decimal64 {
            fraction-digits 2;
            tailf:info "<0-100>;;Enter Integer part of level as percentage of bandwidth";
            range "0..100";
          }
        }
      }
      container unicast {
        tailf:info "Unicast address storm control";
        leaf level {
          tailf:info "Set storm suppression level on this interface";
          type decimal64 {
            fraction-digits 2;
            tailf:info "<0-100>;;Enter Integer part of level as percentage of bandwidth";
            range "0..100";
          }
        }
      }
    }

    // interface * / mac-address
    leaf mac-address {
      tailf:info "Set the Mac address(xxxx.xxxx.xxxx) on an interface";
      type string {
        tailf:info "WORD;;Mac address in hexadecimal xxxx.xxxx.xxxx";
        pattern '[0-9a-fA-F]+\.[0-9a-fA-F]+\.[0-9a-fA-F]+';
      }
    }

    // interface * / dot1x profile
    container dot1x {
      tailf:info "Interface Config Commands for IEEE 802.1X";
      leaf profile {
        tailf:info "Credentials profile configuration";
        tailf:cli-suppress-leafref-in-diff;
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:dot1x/profile/name";
        }
        type string {
          tailf:info "WORD;;String";
        }
      }
    }

    // interface * / macsec
    container macsec {
      tailf:info "Enable MACSec for the interface";

      // interface * / macsec psk-keychain
      container psk-keychain {
        tailf:info "Configure MACsec Key Agreement(MKA) PSK Keychain";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf name {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;Name of keychain to be used to get keys, maximum length 32";
          }
        }
        leaf fallback-psk-keychain {
          tailf:info "Configure MKA fallback PSK Keychain";
          tailf:cli-optional-in-sequence;
          type string {
            tailf:info "WORD;;Name of keychain to be used to get fallback PSK keys, maximum length 32";
          }
        }
        leaf policy {
          tailf:info "Enter the policy name, maximum length 16";
          type string {
            tailf:info "WORD;;MACsec Policy name, maximum length 16";
          }
        }
      }

      // interface * / macsec eap profile
      container eap {
        tailf:info "Configure MACsec Key Agreement(MKA) to use EAP";
        leaf policy {
          tailf:info "Enter the policy name";
          tailf:cli-suppress-leafref-in-diff;
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:macsec-policy/name";
          }
          type string {
            tailf:info "policy;;Enter the policy name";
          }
        }
      }
    }
  }

  // grouping subinterface-common-grouping
  grouping subinterface-common-grouping {

    // interface * / rewrite
    container rewrite {
      tailf:info "Set the tag rewriting policy for this EFP";
      container ingress {
        tailf:info "Set the tag rewriting policy for this EFP";
        container tag {
          tailf:info "Set the tag rewriting policy for this EFP";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          choice tag-choice {
            // interface * / rewrite ingress tag pop
            leaf pop {
              tailf:info "Remove one or more tags";
              type enumeration {
                enum "1" {
                  tailf:info "Remove outer tag only";
                }
                enum "2" {
                  tailf:info "Remove two outermost tags";
                }
              }
            }
            // interface * / rewrite ingress tag push
            leaf push {
              tailf:info "Push one or more tags";
              tailf:cli-incomplete-command;
              type empty;
            }
            // interface * / rewrite ingress tag translate
            leaf translate {
              tailf:info "Replace tags with other tags";
              tailf:cli-incomplete-command;
              type enumeration {
                enum "1-to-1" {
                  tailf:info "Replace the outermost tag with another tag";
                }
                enum "1-to-2" {
                  tailf:info "Replace the outermost tag with two tags";
                }
                enum "2-to-1" {
                  tailf:info "Replace the outermost two tags with one tag";
                }
                enum "2-to-2" {
                  tailf:info "Replace the outermost two tags with two other tags";
                }
              }
            }
          }

          leaf dot1ad {
            when "not(../pop)" {
              tailf:dependency "../pop";
            }
            tailf:info "Push a Dot1ad tag";
            tailf:cli-optional-in-sequence;
            type uint16 {
              tailf:info "<1-4094>;;VLAN Id to push";
              range "1..4094";
            }
          }
          leaf dot1q {
            when "not(../pop)" {
              tailf:dependency "../pop";
            }
            tailf:info "Push a Dot1Q tag";
            tailf:cli-optional-in-sequence;
            type uint16 {
              tailf:info "<1-4094>;;VLAN Id to push";
              range "1..4094";
            }
          }
          leaf second-dot1q {
            when "(../dot1q and not(../dot1ad))" {
              tailf:dependency "../dot1ad";
              tailf:dependency "../dot1q";
            }
            tailf:info "Push another Dot1Q tag";
            tailf:cli-optional-in-sequence;
            type uint16 {
              tailf:info "<1-4094>;;VLAN Id to push";
              range "1..4094";
            }
          }

          // [symmetric]
          leaf mode {
            tailf:cli-drop-node-name;
            type enumeration {
              enum symmetric {
                tailf:info "All rewrites must be symmetric";
              }
            }
          }
        }
      }
    }

    // interface * / dot1q vlan
    container dot1q {
      tailf:info "802.1Q VLAN configuration";
      container vlan {
        tailf:info "Configure a VLAN ID on the subinterface";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf vlan-id {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-4094>;;Single VLAN id";
            range "1..4094";
          }
        }
        leaf second-dot1q {
          tailf:cli-drop-node-name;
          type union {
            type uint16 {
              tailf:info "<1-4094>;;Configure second (inner 802.1Q) VLAN ID on the subinterface";
              range "1..4094";
            }
            type string {
              // VLAN range
            }
            type enumeration {
              enum any {
                tailf:info "Match any VLAN id";
              }
            }
          }
        }
      }
    }

    // interface * / dot1ad
    container dot1ad {
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf vlan-id {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<1-4094>;;Single VLAN id";
          range "1..4094";
        }
      }
      leaf second-dot1d {
        tailf:cli-drop-node-name;
        type union {
          type uint16 {
            tailf:info "<1-4094>;;Single VLAN id";
            range "1..4094";
          }
          type string {
            // VLAN range
          }
          type enumeration {
            enum any {
              tailf:info "Match any VLAN id";
            }
          }
        }
      }
    }

    // interface * / l2protocol cpsv
    container l2protocol {
      tailf:info "Layer 2 protocol handling";
      leaf cpsv {
        tailf:info "CDP, PVST+, STP, and VTP protocols";
        type enumeration {
          enum drop {
            tailf:info "Drop these protocol packets";
          }
          enum reverse-tunnel {
            tailf:info "Tunnel at egress";
          }
          enum tunnel {
            tailf:info "Tunnel at ingress";
          }
        }
      }
    }
  }

  grouping interface-bfd-grouping {

    // interface * / bfd
    container bfd {
      tailf:info "BFD interface configuration commands";

      // interface * / bfd address-family
      container address-family {
        tailf:info "Set configuration for a given address family";

        grouping bfd-param-grouping {
          // interface * / bfd address-family ipv4 timers
          container timers {
            tailf:info "Set the timers that determine when a BFD session defaults to down";

            // interface * / bfd address-family timers start
            leaf start {
              tailf:info "The time since starting a BFD session before it is considered to have gone down";
              type uint16 {
                tailf:info "<60-3600>;;Time in seconds";
                range "60..3600";
              }
            }

            // interface * / bfd address-family timers nbr-unconfig
            leaf nbr-unconfig {
              tailf:info "The time since a BFD signalled that a peer session is unconfigured before it is considered to have gone down";
              type uint16 {
                tailf:info "<60-3600>;;Time in seconds";
                range "60..3600";
              }
            }
          }

          // interface * / bfd address-family ipv4 multiplier
          leaf multiplier {
            tailf:info "Set the preferred multiplier for the BFD session";
            type uint8 {
              tailf:info "<2-50>;;The preferred multiplier for the BFD session";
              range "2..50";
            }
          }

          // interface * / bfd address-family ipv4 fast-detect
          leaf fast-detect {
            tailf:info "Enable fast detection using BFD on bundle members";
            type empty;
          }

          // interface * / bfd address-family ipv4 minimum-interval
          leaf minimum-interval {
            tailf:info "Set the preferred minimum interval for the BFD session";
            type uint16 {
              tailf:info "<3-30000>;;The preferred minimum interval (in ms) for the BFD session";
              range "3..30000";
            }
          }
        }

        // interface * / bfd address-family ipv4
        container ipv4 {
          tailf:info "Set configuration for the IPv4 address family";
          uses bfd-param-grouping;

          // interface * / bfd address-family ipv4 echo minimum-interval
          container echo {
            tailf:info "Set the configuration for the echo mode of BFD";
            leaf minimum-interval {
              tailf:info "Set the preferred minimum interval for the BFD session";
              type uint16 {
                tailf:info "<15-2000>;;The preferred minimum interval (in ms) for the BFD session";
              }
            }
          }

          // interface * / bfd address-family ipv4 destination
          leaf destination {
            tailf:info "Set the destination address for the BFD session";
            type inet:ipv4-address {
              tailf:info "IPv4 destination address for the BFD session";
            }
          }
        }
        // interface * / bfd address-family ipv6
        container ipv6 {
          tailf:info "Set configuration for the IPv6 address family";
          uses bfd-param-grouping;

          // interface * / bfd address-family ipv6 destination
          leaf destination {
            tailf:info "Set the destination address for the BFD session";
            type inet:ipv6-address {
              tailf:info "X:X::X;;IPv6 destination address for the BFD session";
            }
          }
        }
      }

      // interface * / bfd echo
      leaf echo {
        tailf:info "Use echo adjunct as bfd detection mechanism";
        type empty;
      }

      // interface * / bfd interval
      container interval {
        tailf:info "Transmit interval between BFD packets";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-reset-container;
        leaf msecs {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<750-999>;;Milliseconds";
            range "750..999";
          }
        }
        leaf min_rx {
          tailf:info "Minimum receive interval capability";
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<750-999>;;Milliseconds";
            range "750..999";
          }
        }
        leaf multiplier {
          tailf:info "Multiplier value used to compute holddown";
          type uint8 {
            tailf:info "<3-50>;;value used to multiply the interval";
            range "3..50";
          }
        }
      }

      // interface * / bfd mode
      leaf mode {
        tailf:info "Standard used for per-member BFD";
        type enumeration {
          enum cisco {
            tailf:info "Use Cisco standard for BoB";
          }
          enum ietf {
            tailf:info "Use IETF standard for BoB";
          }
        }
      }
    }
  }

  // grouping non-subinterface-common-grouping
  grouping non-subinterface-common-grouping {

    // interface * / backup
    container backup {
      tailf:info "Modify backup parameters";
      container interface {
        tailf:info "Configure an interface as a backup";
        uses interface-name-grouping;
      }
    }

    // interface * / cdp
    leaf cdp {
      tailf:info "Enable CDP on an interface";
      tailf:cli-full-command;
      type empty;
    }

    // interface * / dual-active
    container dual-active {
      tailf:info "VS dual-active configuration command";
      leaf fast-hello {
        tailf:info "dual-active fast-hello detection method";
        type empty;
      }
    }

    // interface * / l2transport
    container l2transport {
      tailf:info "Enable Layer 2 transport and enter its configuration submode";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-if-l2";
      presence true;

      // interface * / l2transport / service-policy
      uses interface-service-policy-grouping;

      // interface * / l2transport / l2protocol
      container l2protocol {
        tailf:info "Layer 2 protocol handling";

        // interface * / l2transport / l2protocol cpsv
        leaf cpsv {
          tailf:info "CDP, PVST+, STP, and VTP protocols";
          type enumeration {
            enum drop {
              tailf:info "Drop these protocol packets";
            }
            enum reverse-tunnel {
              tailf:info "Tunnel at egress";
            }
            enum tunnel {
              tailf:info "Tunnel at ingress";
            }
          }
        }

        // interface * / l2transport / l2protocol cdp
        container cdp {
          tailf:info "Cisco Discovery Protocol";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          uses if-l2transport-l2protocol-grouping;
        }

        // interface * / l2transport / l2protocol stp
        container stp {
          tailf:info "Spanning Tree Protocol";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          uses if-l2transport-l2protocol-grouping;
        }

        // interface * / l2transport / l2protocol vtp
        container vtp {
          tailf:info "VLAN Trunk Protocol";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          uses if-l2transport-l2protocol-grouping;
        }

        // interface * / l2transport / l2protocol pvst
        container pvst {
          tailf:info "Per VLAN Spanning Tree";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          uses if-l2transport-l2protocol-grouping;
        }
      }

      // interface * / l2transport / propagate remote-status
      container propagate {
        tailf:info "Select events to propagate";
        leaf remote-status {
          tailf:info "Propagate remote link status changes";
          type empty;
        }
      }

      // interface * / l2transport / monitor-session *
      uses interface-monitor-session-grouping;
    }

    // interface * / platform
    container platform {
      tailf:info "platform specific interface configuration";
      container qos {
        tailf:info "qos command keyword";
        leaf channel-consistency {
          tailf:info "enable or disable qos consistency checks";
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }
      }
    }

    // interface * / xconnect
    container xconnect {
      tailf:info "Xconnect commands";
      leaf vfi {
        tailf:info "connect to a virtual forwarding instance";
        type string {
          tailf:info "WORD;;VFI name";
        }
      }
    }

    uses interface-switch-grouping;
  }


  // interface tunnel-te*
  // interface tunnel-mte*
  grouping interface-tunnel-te-grouping {

    // interface tunnel-te* / signalled-name
    leaf signalled-name {
      tailf:info "The signaling name to assign to tunnel";
      tailf:cli-full-command;
      type string {
        tailf:info "WORD;;The name to be included in signaling";
      }
    }

    // interface tunnel-te* / signalled-bandwidth
    container signalled-bandwidth {
      tailf:info "Tunnel bandwidth requirement to be signalled";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf sub-pool {
        tailf:info "Specify sub-pool bandwidth";
        tailf:cli-optional-in-sequence;
        tailf:cli-incomplete-command;
        type empty;
      }
      leaf bandwidth {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<0-4294967295>;;Bandwidth requirement in kbps";
        }
      }
      leaf class-type {
        when "not(../sub-pool)" {
          tailf:dependency "../sub-pool";
        }
        tailf:info "Specify the bandwidth class type";
        type uint8 {
          tailf:info "<0-1>;;Class type number";
          range "0..1";
        }
      }
    }

    // interface tunnel-te* / priority
    container priority {
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf setup {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint8 {
          tailf:info "<0-7>;;Setup Priority";
          range "0..7";
        }
      }
      leaf hold-value {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<0-7>;;Hold Priority";
        }
      }
    }

    // interface tunnel-te* / binding-sid mpls
    container binding-sid {
      tailf:info "Binding Segment Identifier";
      container mpls {
        tailf:info "Use MPLS label as binding segment identifier";
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        // interface tunnel-te* / binding-sid mpls label
        leaf label {
          tailf:info "Specify label value";
          type uint16 {
            tailf:info "<16-4015>;;MPLS label";
            range "16..4015";
          }
        }
      }
    }

    // interface tunnel-te* / fast-reroute
    choice fast-reroute-choice {
      leaf fast-reroute {
        tailf:info "Specify MPLS tunnel can be fast-rerouted";
        tailf:cli-full-command;
        tailf:cli-full-no;
        type empty;
      }
      // interface tunnel-te* / fast-reroute protect
      container fast-reroute-conf {
        tailf:cli-drop-node-name;
        container fast-reroute {
          tailf:info "Specify MPLS tunnel can be fast-rerouted";
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          leaf protect {
            tailf:info "Enable protection request";
            type enumeration {
              enum bandwidth {
                tailf:info "Enable bandwidth protection request";
              }
              enum node {
                tailf:info "Enable node protection request";
              }
            }
          }
        }
      }
    }

    // interface tunnel-te* / policy-class
    container policy-class {
      tailf:info "Specify classs for policy-based tunnel selection";
      choice policy-class-choice {
        leaf-list values {
          tailf:cli-drop-node-name;
          tailf:cli-flat-list-syntax;
          tailf:cli-remove-before-change;
          ordered-by user;
          type uint8 {
            tailf:info "<1-7>;;Tunnel policy class Value(s)";
            range "1..7";
          }
        }
        leaf default {
          tailf:info "Default class for policy-based tunnel selection";
          type empty;
        }
      }
    }

    // interface tunnel-te* / record-route
    leaf record-route {
      tailf:info "Record the route used by the tunnel";
      tailf:cli-full-command;
      type empty;
    }

    // interface tunnel-te* / affinity
    uses affinity-grouping;
  }


  // mpls traffic-eng / gmpls optical-nni / controller Odu-Group-Te * / path-option *
  // mpls traffic-eng / gmpls optical-uni / controller * / tunnel-properties / path-option *
  grouping mpls-traffic-eng-controller-path-option-grouping {
    list path-option {
      tailf:info "Configure a GMPLS-UNI path-option";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-incomplete-command;
      key id;
      leaf id {
        type uint16 {
          tailf:info "<1-1000>;;Preference for this path option";
          range "1..1000";
        }
      }
      choice path-choice {
        case explicit {
          leaf explicit {
            tailf:info "Setup based on preconfigured path";
            tailf:cli-incomplete-command;
            type empty;
          }
          leaf identifier {
            tailf:info "Specify an explicit path by number";
            tailf:cli-optional-in-sequence;
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<1-65535>;;Explicit path number";
              range "1..65535";
            }
          }
          leaf name {
            tailf:info "Specify an explicit path by name";
            tailf:cli-incomplete-command;
            when "not(../identifier)";
            type string {
              tailf:info "WORD;;Explicit path name";
            }
          }
        }
        case no-ero {
          leaf no-ero {
            tailf:info "No path configuration";
            tailf:cli-incomplete-command;
            type empty;
          }
        }
      }
      leaf signaled-label {
        tailf:cli-break-sequence-commands;
        tailf:info "Specify a fixed upstream label to be used";
        type enumeration {
          enum dwdm {
            tailf:info "DWDM label (RFC 6205), 50GHz channel-spacing";
          }
        }
      }
      leaf wavelength {
        when "../signaled-label";
        tailf:info "DWDM wavelength";
        type uint8 {
          tailf:info "<1-89>;;DWDM channel number (ITU), 50GHz channel-spacing";
          range "1..89";
        }
      }
      leaf protected-by {
        tailf:info "Index of the protecting path-option";
        type union {
          type uint32 {
            tailf:info "<1-1000>;;Index of the protecting path-option";
            range "1..1000";
          }
          type enumeration {
            enum none {
              tailf:info "No path protection";
            }
          }
        }
      }
      leaf xro-attribute-set {
        tailf:info "Attribute-set containing path exclusions";
        type string {
          tailf:info "WORD;;Specify attribute-set name (max 64 char)";
        }
      }
      leaf lockdown {
        tailf:info "Not a candidate for reoptimization";
        type empty;
      }
      leaf verbatim {
        tailf:info "Use explicit path to construct ERO directly";
        type empty;
      }
    }

  }

  // interface tunnel-te* / path-option *
  // interface tunnel-mte* / destination * / path-option *
  grouping interface-tunnel-path-option-grouping {
    list path-option {
      tailf:info "Primary or fallback path setup option";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      tailf:cli-incomplete-command;
      key preference-priority;
      leaf preference-priority {
        type uint16 {
          tailf:info "<1-1000>;;Preference for this path option";
          range "1..1000";
        }
      }
      choice path-option-choice {
        container dynamic {
          tailf:info "Setup based on dynamically allocated path";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          presence true;
        }
        container explicit {
          tailf:info "Setup based on preconfigured path";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          choice path-choice {
            leaf identifier {
              tailf:info "Specify an IP explicit path by number";
              type uint32 {
                tailf:info "<1-4294967295>;;Specify an IP explicit path by number";
              }
            }
            leaf name {
              tailf:info "Specify an IP explicit path by name";
              type string {
                tailf:info "WORD;;Specify an IP explicit path by name";
              }
            }
          }
        }
      }
      leaf pce {
        tailf:info "Use Path Computation Element";
        tailf:cli-break-sequence-commands;
        type empty;
      }
      container address {
        tailf:info "Address of PCE";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf ipv4 {
          tailf:info "IPv4 PCE address";
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IPv4 PCE address";
          }
        }
      }
      leaf segment-routing {
        tailf:info "Require segment routing`";
        type empty;
      }
      leaf verbatim {
        tailf:info "Do not require topology database for explicit path";
        type empty;
      }
      leaf lockdown {
        tailf:info "Not a candidate for reoptimization";
        type empty;
      }
      // [ ospf instance-name area { value | address } ]
      container ospf {
        tailf:info "Limit CSPF to a single OSPF instance and area";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf instance-name {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type string {
            tailf:info "WORD;;OSPF instance name";
          }
        }
        leaf area {
          tailf:info "OSPF area";
          type union {
            type uint32 {
              tailf:info "<0-4294967295>;;OSPF area ID as a decimal value";
            }
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;OSPF area ID in IP address format";
            }
          }
        }
      }
      // interface * / path-option * attribute-set
      leaf attribute-set {
        tailf:info "Attribute set for this LSP";
        type string {
          tailf:info "WORD;;Specify attribute-set name (max 64 char)";
          length "1..64";
        }
      }
      // interface * / path-option * protected-by
      leaf protected-by {
        tailf:info "Index of the protecting path-option";
        type union {
          type uint32 {
            tailf:info "<1-1000>;;Index of the protecting path-option";
            range "1..1000";
          }
          type enumeration {
            enum none {
              tailf:info "No path protection";
            }
          }
        }
      }
    }
  }


  // interface-name-grouping - all interface lists collected
  grouping interface-name-grouping {
    choice interface-choice {

      leaf Bundle-Ether {
        tailf:info "Aggregated Ethernet interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:cli-suppress-leafref-in-diff;
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/Bundle-Ether/id";
        }
        type uint16 {
          tailf:info "<1-65535>";
        }
      }
      container Bundle-Ether-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf Bundle-Ether {
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          tailf:cli-suppress-leafref-in-diff;
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:interface/Bundle-Ether-subinterface/Bundle-Ether/id";
          }
          type string {
            pattern '[0-9]+\.[0-9]+';
          }
        }
      }

      leaf Bundle-POS {
        tailf:info "Aggregated POS interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:cli-suppress-leafref-in-diff;
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/Bundle-POS/id";
        }
        type uint16 {
          tailf:info "<1-65535>";
        }
      }

      leaf BVI {
        tailf:info "Bridge-Group Virtual Interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:cli-suppress-leafref-in-diff;
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/BVI/id";
        }
        type uint32 {
          tailf:info "<1-4294967295>";
          range "1..4294967295";
        }
      }

      leaf PTP {
        tailf:info "FastEthernet/IEEE 802.3 interface(s) | short name is PTP";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:cli-suppress-leafref-in-diff;
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/PTP/id";
        }
        type string {
          tailf:info "WORD;;Rack/Slot/Instance/Port";
          pattern "[A-Z0-9]+(/[A-Z0-9]+)*";
        }
      }

      leaf FastEthernet {
        tailf:info "FastEthernet IEEE 802.3";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:cli-suppress-leafref-in-diff;
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/FastEthernet/id";
        }
        type string {
          tailf:info "WORD;;Rack/Slot/Instance/Port";
          pattern "[0-9]+(/[0-9]+)*";
        }
      }
      container FastEthernet-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf FastEthernet {
          tailf:info "FastEthernet IEEE 802.3";
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          tailf:cli-suppress-leafref-in-diff;
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:interface/FastEthernet-subinterface/FastEthernet/id";
          }
          type string {
            tailf:info "WORD;;Rack/Slot/Instance/Port.subid";
            pattern '[0-9]+(/[0-9]+)*\.[0-9]+';
          }
        }
      }

      leaf GigabitEthernet {
        tailf:info "GigabitEthernet IEEE 802.3z";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:cli-suppress-leafref-in-diff;
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/GigabitEthernet/id";
        }
        type string {
          tailf:info "WORD;;Rack/Slot/Instance/Port";
          pattern "[0-9]+(/[0-9]+)*";
        }
      }
      container GigabitEthernet-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf GigabitEthernet {
          tailf:info "GigabitEthernet IEEE 802.3z";
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          tailf:cli-suppress-leafref-in-diff;
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:interface/GigabitEthernet-subinterface/GigabitEthernet/id";
          }
          type string {
            tailf:info "WORD;;Rack/Slot/Instance/Port.subif";
            pattern '[0-9]+(/[0-9]+)*\.[0-9]+';
          }
        }
      }

      leaf TenGigE {
        tailf:info "TenGigabitEthernet/IEEE 802.3 interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:cli-suppress-leafref-in-diff;
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/TenGigE/id";
        }
        type string {
          pattern "[0-9]+(/[0-9]+)*";
        }
      }
      container TenGigE-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf TenGigE {
          tailf:info "TenGigabitEthernet/IEEE 802.3 interface(s)";
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          tailf:cli-suppress-leafref-in-diff;
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:interface/TenGigE-subinterface/TenGigE/id";
          }
          type string {
            pattern '[0-9]+(/[0-9]+)*\.[0-9]+';
          }
        }
      }

      leaf TwentyFiveGigE {
        tailf:info "TwentyFiveGigabitEthernet/IEEE 802.3 interface(s) | short name is Tw";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:cli-suppress-leafref-in-diff;
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/TwentyFiveGigE/id";
        }
        type string {
          pattern "[0-9]+(/[0-9]+)*";
        }
      }
      container TwentyFiveGigE-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf TwentyFiveGigE {
          tailf:info "TwentyFiveGigabitEthernet/IEEE 802.3 interface(s) | short name is Tw";
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          tailf:cli-suppress-leafref-in-diff;
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:interface/TwentyFiveGigE-subinterface/TwentyFiveGigE/id";
          }
          type string {
            pattern '[0-9]+(/[0-9]+)*\.[0-9]+';
          }
        }
      }

      leaf FortyGigE {
        tailf:info "FortyGigabitEthernet/IEEE 802.3 interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:cli-suppress-leafref-in-diff;
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/FortyGigE/id";
        }
        type string {
          pattern "[0-9]+(/[0-9]+)*";
        }
      }
      container FortyGigE-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf FortyGigE {
          tailf:info "FortyGigabitEthernet/IEEE 802.3 interface(s)";
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          tailf:cli-suppress-leafref-in-diff;
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:interface/FortyGigE-subinterface/FortyGigE/id";
          }
          type string {
            pattern '[0-9]+(/[0-9]+)*\.[0-9]+';
          }
        }
      }

      leaf FiftyGigE {
        tailf:info "FiftyGigabitEthernet/IEEE 802.3 interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:cli-suppress-leafref-in-diff;
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/FiftyGigE/id";
        }
        type string {
          pattern "[0-9]+(/[0-9]+)*";
        }
      }
      container FiftyGigE-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf FiftyGigE {
          tailf:info "FiftyGigabitEthernet/IEEE 802.3 interface(s)";
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          tailf:cli-suppress-leafref-in-diff;
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:interface/FiftyGigE-subinterface/FiftyGigE/id";
          }
          type string {
            pattern '[0-9]+(/[0-9]+)*\.[0-9]+';
          }
        }
      }

      leaf HundredGigE {
        tailf:info "HundredGigEthernet";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:cli-suppress-leafref-in-diff;
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/HundredGigE/id";
        }
        type string {
          tailf:info "WORD;;Rack/Slot/Instance/Port";
          pattern "[0-9]+(/[0-9]+)*";
        }
      }
      container HundredGigE-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf HundredGigE {
          tailf:info "HundredGigEthernet";
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          tailf:cli-suppress-leafref-in-diff;
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:interface/HundredGigE-subinterface/HundredGigE/id";
          }
          type string {
            tailf:info "WORD;;Rack/Slot/Instance/Port.subif";
            pattern '[0-9]+(/[0-9]+)*\.[0-9]+';
          }
        }
      }

      leaf TwoHundredGigE {
        tailf:info "TwoHundredGigEthernet";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:cli-suppress-leafref-in-diff;
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/TwoHundredGigE/id";
        }
        type string {
          tailf:info "WORD;;Rack/Slot/Instance/Port";
          pattern "[0-9]+(/[0-9]+)*";
        }
      }
      container TwoHundredGigE-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf TwoHundredGigE {
          tailf:info "TwoHundredGigEthernet";
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          tailf:cli-suppress-leafref-in-diff;
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:interface/TwoHundredGigE-subinterface/TwoHundredGigE/id";
          }
          type string {
            tailf:info "WORD;;Rack/Slot/Instance/Port.subif";
            pattern '[0-9]+(/[0-9]+)*\.[0-9]+';
          }
        }
      }

      leaf FourHundredGigE {
        tailf:info "FourHundredGigEthernet";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:cli-suppress-leafref-in-diff;
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/FourHundredGigE/id";
        }
        type string {
          tailf:info "WORD;;Rack/Slot/Instance/Port";
          pattern "[0-9]+(/[0-9]+)*";
        }
      }
      container FourHundredGigE-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf FourHundredGigE {
          tailf:info "FourHundredGigEthernet";
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          tailf:cli-suppress-leafref-in-diff;
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:interface/FourHundredGigE-subinterface/FourHundredGigE/id";
          }
          type string {
            tailf:info "WORD;;Rack/Slot/Instance/Port.subif";
            pattern '[0-9]+(/[0-9]+)*\.[0-9]+';
          }
        }
      }

      leaf PW-Ether {
        tailf:info "Pseudo-Wire Ethernet interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:cli-suppress-leafref-in-diff;
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/PW-Ether/id";
        }
        type uint16 {
          tailf:info "<1-32768>";
        }
      }
      container PW-Ether-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf PW-Ether {
          tailf:info "Pseudo-Wire Ethernet sub-interface(s)";
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          tailf:cli-suppress-leafref-in-diff;
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:interface/PW-Ether-subinterface/PW-Ether/id";
          }
          type string {
            pattern '[0-9]+\.[0-9]+';
          }
        }
      }

      leaf PW-IW {
        tailf:info "PWHE VC11 IP Interworking Interface | short name is PI";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:cli-suppress-leafref-in-diff;
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/PW-IW/id";
        }
        type uint16 {
          tailf:info "<1-32768>";
        }
      }

      leaf Null {
        tailf:info "Null interface | short name is Nu";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:cli-suppress-leafref-in-diff;
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/Null/id";
        }
        type string {
          tailf:info "<0-0>";
          pattern "0";
        }
      }

      leaf Loopback {
        tailf:info "Loopback interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:cli-suppress-leafref-in-diff;
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/Loopback/id";
        }
        type uint32 {
          tailf:info "<0-2147483647>";
        }
      }

      leaf MgmtEth {
        tailf:info "Ethernet/IEEE 802.3 interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:cli-suppress-leafref-in-diff;
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/MgmtEth/id";
        }
        type string {
          tailf:info "WORD;;Rack/Slot/Instance/Port";
        }
      }

      leaf Multilink {
        tailf:info "Multilink network interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:cli-suppress-leafref-in-diff;
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/Multilink/id";
        }
        type string {
          tailf:info "WORD;;Rack/Slot/Instance/Port";
        }
      }
      container Multilink-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf Multilink {
          tailf:info "Multilink network interface(s)";
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          tailf:cli-suppress-leafref-in-diff;
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:interface/Multilink-subinterface/Multilink/id";
          }
          type string {
            pattern '[0-9]+(/[0-9]+)*\.[0-9]+';
          }
        }
      }

      leaf SRP {
        tailf:info "SRP interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:cli-suppress-leafref-in-diff;
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/SRP/id";
        }
        type string {
          pattern "[0-9]+.*";
        }
      }

      leaf Port-channel {
        tailf:info "Ethernet Channel of interfaces";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:cli-suppress-leafref-in-diff;
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/Port-channel/id";
        }
        type uint32 {
          tailf:info "<1-512>";
        }
      }

      leaf POS {
        tailf:info "Packet over SONET/SDH network interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:cli-suppress-leafref-in-diff;
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/POS/id";
        }
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
        }
      }
      container POS-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf POS {
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          tailf:cli-suppress-leafref-in-diff;
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:interface/POS-subinterface/POS/id";
          }
          type string {
            pattern '[0-9]+/[0-9]+/[0-9]+/[0-9]+\.[0-9]+';
          }
        }
      }

      leaf Serial {
        tailf:info "Serial interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:cli-suppress-leafref-in-diff;
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/Serial/id";
        }
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
          pattern "[0-9]+(/[0-9]+)+(:[0-9]+)?";
        }
      }
      container Serial-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf Serial {
          tailf:info "Serial interface";
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          tailf:cli-suppress-leafref-in-diff;
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:interface/Serial-subinterface/Serial/id";
          }
          type string {
            tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
            pattern '[0-9]+(/[0-9]+)+(:[0-9]+)?\.[0-9]+';
          }
        }
      }

      leaf tunnel-ip {
        tailf:info "GRE/IPinIP Tunnel Interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:cli-suppress-leafref-in-diff;
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/tunnel-ip/id";
        }
        type uint16 {
          tailf:info "<0-65535>";
        }
      }

      leaf tunnel-te {
        tailf:info "MPLS Traffic Engineering Tunnel interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:cli-suppress-leafref-in-diff;
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/tunnel-te/id";
        }
        type uint16 {
          tailf:info "<0-65535>";
        }
      }

      leaf tunnel-tp {
        tailf:info "MPLS Transport Protocol Tunnel interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:cli-suppress-leafref-in-diff;
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/tunnel-tp/id";
        }
        type uint16 {
          tailf:info "<0-65535>";
        }
      }

      leaf tunnel-mte {
        tailf:info "MPLS Traffic Engineering P2MP Tunnel interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:cli-suppress-leafref-in-diff;
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/tunnel-mte/id";
        }
        type uint16 {
          tailf:info "<0-65535>";
        }
      }

      leaf tunnel-ipsec {
        tailf:info "IPSec Tunnel interface(s)";
        //tailf:cli-allow-join-with-value {
        //tailf:cli-display-joined;
        //}
        tailf:cli-suppress-leafref-in-diff;
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/tunnel-ipsec/id";
        }
        type uint32 {
          tailf:info "<0-4294967295>";
        }
      }

      leaf ATM {
        tailf:info "ATM Network Interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:cli-suppress-leafref-in-diff;
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/ATM/id";
        }
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
          pattern "[0-9]+(/[0-9]+)+";
        }
      }
      container ATM-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf ATM {
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          tailf:cli-suppress-leafref-in-diff;
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:interface/ATM-subinterface/ATM/id";
          }
          type string {
            pattern '[0-9]+(/[0-9]+)*\.[0-9]+';
          }
        }
      }

      leaf Vlan {
        tailf:info "Iosxr Vlans";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:cli-suppress-leafref-in-diff;
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/Vlan/id";
        }
        type uint16 {
          tailf:info "<1-4094>;;Vlan interface number";
          range "1..4094";
        }
      }

      leaf CEM {
        tailf:info "Circuit Emulation interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:cli-suppress-leafref-in-diff;
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/CEM/id";
        }
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
          pattern "[0-9]+.*";
        }
      }

      leaf GCC0 {
        tailf:info "OTN GCC0 interface(s) | short name is G0";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:cli-suppress-leafref-in-diff;
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/GCC0/id";
        }
        type string {
          pattern "[0-9]+.*";
        }
      }

      leaf CSI {
        tailf:info "Cross SDR interface(s) | short name is csi";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:cli-suppress-leafref-in-diff;
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:interface/CSI/id";
        }
        type uint8 {
          range "1..32";
        }
      }
    }
  }


  // interface-grouping
  grouping interface-grouping {

    // interface Null0
    list Null {
      tailf:info "Null interface | short name is Nu";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-null0";
      key id;
      leaf id {
        tailf:info "Null interface number 0";
        type string {
          tailf:info "<0-0>;;Null interface number";
          pattern "0";
        }
      }

      // interface Null0 / ipv4 icmp unreachables disable
      container ipv4 {
        tailf:info "Disable sending IPv4 ICMP Unreachable messages";
        container icmp {
          tailf:info "Disable sending ICMP Unreachable messages";
          container unreachables {
            tailf:info "Disable sending ICMP Unreachable messages";
            leaf disable {
              tailf:info "Override sending of ICMP Unreachable messages";
              type empty;
            }
          }
        }
      }

      // interface Null0 / ipv6 icmp unreachables disable
      container ipv6 {
        tailf:info "Disable sending IPv4 ICMP Unreachable messages";
        container icmp {
          tailf:info "Disable sending ICMP Unreachable messages";
          container unreachables {
            tailf:info "Disable sending ICMP Unreachable messages";
            leaf disable {
              tailf:info "Override sending of ICMP Unreachable messages";
              type empty;
            }
          }
        }
      }

    }

    // interface Loopback*
    list Loopback {
      tailf:info "Loopback interface";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        tailf:info "Loopback interface number";
        type uint32 {
          tailf:info "<0-2147483647>;;Loopback interface number";
          range "0..2147483647";
        }
      }
      uses interface-common-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
    }

    // interface Bundle-Ether*
    list Bundle-Ether {
      tailf:info "Aggregated Ethernet interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        tailf:info "Bundle-Ether interface id";
        type uint16 {
          tailf:info "<1-65535>";
          range "1..65535";
        }
      }

      uses interface-common-grouping;
      uses interface-ethernet-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
      uses interface-bundle-grouping;
    }

    // interface Bundle-Ether-subinterface*
    container Bundle-Ether-subinterface {
      tailf:cli-drop-node-name;
      list Bundle-Ether {
        tailf:cli-mode-name "config-subif";
        tailf:cli-allow-join-with-key;
        cisco-ios-xr:if-delete-redeploy "mode";
        key id;
        leaf id {
          tailf:info "Bundle-Ether sub-interface id";
          tailf:cli-diff-dependency "../../../Bundle-Ether";
          type string {
            pattern '[0-9]+\.[0-9]+';
          }
        }
        leaf mode {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum l2transport {
              tailf:info "Treat as an attachment circuit";
            }
            enum symmetric;
          }
        }
        uses interface-common-grouping;
        uses interface-ethernet-grouping;
        uses subinterface-common-grouping;
        uses interface-bundle-grouping;
      }
    }

    // interface Bundle-POS*
    list Bundle-POS {
      tailf:info "Aggregated POS interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        tailf:info "Bundle-POS interface id";
        type uint16 {
          tailf:info "<1-65535>";
          range "1..65535";
        }
      }

      uses interface-common-grouping;
      uses interface-ethernet-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
      uses interface-bundle-grouping;
    }

    // interface MgmtEth*
    list MgmtEth {
      tailf:info "Ethernet/IEEE 802.3 interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        tailf:info "Ethernet/IEEE 802.3 interface id";
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
          pattern "[0-9A-Z]+/.+/.+/.+";
        }
      }
      uses interface-common-grouping;
      uses interface-ethernet-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
      uses interface-non-bundle-grouping;
    }

    // interface TenGigE*
    list TenGigE {
      tailf:info "TenGigabitEthernet/IEEE 802.3 interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        tailf:info "Ten Gigabit Ethernet interface id";
        type string {
          pattern "[0-9]+(/[0-9]+)*";
        }
      }
      uses interface-common-grouping;
      uses interface-ethernet-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
      uses interface-non-bundle-grouping;
    }

    // subinterface TenGigE*
    container TenGigE-subinterface {
      tailf:cli-drop-node-name;
      list TenGigE {
        tailf:cli-mode-name "config-subif";
        tailf:cli-allow-join-with-key;
        cisco-ios-xr:if-delete-redeploy "mode";
        key id;
        leaf id {
          tailf:info "Ten Gigabit Ethernet sub-interface id";
          type string {
            pattern '[0-9]+(/[0-9]+)*\.[0-9]+';
          }
        }
        leaf mode {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum l2transport;
            enum symmetric;
          }
        }
        uses interface-common-grouping;
        uses interface-ethernet-grouping;
        uses subinterface-common-grouping;
      }
    }

    // interface TwentyFiveGigE #/#/#/#
    list TwentyFiveGigE {
      tailf:info "TwentyFiveGigabitEthernet/IEEE 802.3 interface(s) | short name is Tw";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        tailf:info "Twentyfive Gigabit Ethernet interface id";
        type string {
          pattern "[0-9]+(/[0-9]+)*";
        }
      }
      uses interface-common-grouping;
      uses interface-ethernet-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
      uses interface-non-bundle-grouping;
    }

    // subinterface TwentyFiveGigE #/#/#/#
    container TwentyFiveGigE-subinterface {
      tailf:cli-drop-node-name;
      list TwentyFiveGigE {
        tailf:cli-mode-name "config-subif";
        tailf:cli-allow-join-with-key;
        key id;
        leaf id {
          tailf:info "Twentyfive Gigabit Ethernet sub-interface id";
          type string {
            pattern '[0-9]+(/[0-9]+)*\.[0-9]+';
          }
        }
        leaf mode {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum l2transport;
            enum symmetric;
          }
        }
        uses interface-common-grouping;
        uses interface-ethernet-grouping;
        uses subinterface-common-grouping;
      }
    }

    // interface FortyGigE*
    list FortyGigE {
      tailf:info "FortyGigEthernet";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        tailf:info "Forty Gigabit Ethernet interface id";
        type string {
          pattern "[0-9]+(/[0-9]+)*";
        }
      }
      uses interface-common-grouping;
      uses interface-ethernet-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
      uses interface-non-bundle-grouping;
    }

    // subinterface FortyGigE*.*
    container FortyGigE-subinterface {
      tailf:cli-drop-node-name;
      list FortyGigE {
        tailf:cli-mode-name "config-subif";
        tailf:cli-allow-join-with-key;
        key id;
        leaf id {
          tailf:info "Forty Gigabit Ethernet sub-interface id";
          type string {
            pattern '[0-9]+(/[0-9]+)*\.[0-9]+';
          }
        }
        leaf mode {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum l2transport;
            enum symmetric;
          }
        }
        uses interface-common-grouping;
        uses interface-ethernet-grouping;
        uses subinterface-common-grouping;
      }
    }

    // interface FiftyGigE*
    list FiftyGigE {
      tailf:info "FiftyGigEthernet";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        tailf:info "Fifty Gigabit Ethernet interface id";
        type string {
          pattern "[0-9]+(/[0-9]+)*";
        }
      }
      uses interface-common-grouping;
      uses interface-ethernet-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
      uses interface-non-bundle-grouping;
    }

    // subinterface FiftyGigE>*.*
    container FiftyGigE-subinterface {
      tailf:cli-drop-node-name;
      list FiftyGigE {
        tailf:cli-mode-name "config-subif";
        tailf:cli-allow-join-with-key;
        key id;
        leaf id {
          tailf:info "Fifty Gigabit Ethernet sub-interface id";
          type string {
            pattern '[0-9]+(/[0-9]+)*\.[0-9]+';
          }
        }
        leaf mode {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum l2transport;
            enum symmetric;
          }
        }
        uses interface-common-grouping;
        uses interface-ethernet-grouping;
        uses subinterface-common-grouping;
      }
    }

    // interface HundredGigE*
    list HundredGigE {
      tailf:info "HundredGigEthernet";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        tailf:info "Hundred Gigabit Ethernet interface id";
        type string {
          pattern "[0-9]+(/[0-9]+)*";
        }
      }
      uses interface-common-grouping;
      uses interface-ethernet-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
      uses interface-non-bundle-grouping;
    }

    // subinterface HundredGigE*
    container HundredGigE-subinterface {
      tailf:cli-drop-node-name;
      list HundredGigE {
        tailf:cli-mode-name "config-subif";
        tailf:cli-allow-join-with-key;
        key id;
        leaf id {
          tailf:info "Hundred Gigabit Ethernet sub-interface id";
          type string {
            pattern '[0-9]+(/[0-9]+)*\.[0-9]+';
          }
        }
        leaf mode {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum l2transport;
            enum symmetric;
          }
        }
        uses interface-common-grouping;
        uses interface-ethernet-grouping;
        uses subinterface-common-grouping;
      }
    }

    // interface TwoHundredGigE*
    list TwoHundredGigE {
      tailf:info "TwoHundredGigEthernet";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        tailf:info "TwoHundred Gigabit Ethernet interface id";
        type string {
          pattern "[0-9]+(/[0-9]+)*";
        }
      }
      uses interface-common-grouping;
      uses interface-ethernet-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
      uses interface-non-bundle-grouping;
    }

    // subinterface TwoHundredGigE*
    container TwoHundredGigE-subinterface {
      tailf:cli-drop-node-name;
      list TwoHundredGigE {
        tailf:cli-mode-name "config-subif";
        tailf:cli-allow-join-with-key;
        key id;
        leaf id {
          tailf:info "TwoHundred Gigabit Ethernet sub-interface id";
          type string {
            pattern '[0-9]+(/[0-9]+)*\.[0-9]+';
          }
        }
        leaf mode {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum l2transport;
            enum symmetric;
          }
        }
        uses interface-common-grouping;
        uses interface-ethernet-grouping;
        uses subinterface-common-grouping;
      }
    }

    // interface FourHundredGigE*
    list FourHundredGigE {
      tailf:info "FourHundredGigEthernet";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        tailf:info "FourHundred Gigabit Ethernet interface id";
        type string {
          pattern "[0-9]+(/[0-9]+)*";
        }
      }
      uses interface-common-grouping;
      uses interface-ethernet-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
      uses interface-non-bundle-grouping;
    }

    // subinterface FourHundredGigE*
    container FourHundredGigE-subinterface {
      tailf:cli-drop-node-name;
      list FourHundredGigE {
        tailf:cli-mode-name "config-subif";
        tailf:cli-allow-join-with-key;
        key id;
        leaf id {
          tailf:info "FourHundred Gigabit Ethernet sub-interface id";
          type string {
            pattern '[0-9]+(/[0-9]+)*\.[0-9]+';
          }
        }
        leaf mode {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum l2transport;
            enum symmetric;
          }
        }
        uses interface-common-grouping;
        uses interface-ethernet-grouping;
        uses subinterface-common-grouping;
      }
    }

    // interface FastEthernet*
    list FastEthernet {
      tailf:info "FastEthernet/IEEE 802.3 interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        tailf:info "Fast Ethernet interface id";
        type string {
          tailf:info "WORD;;Rack/Slot/Instance/Port";
          pattern "[0-9]+(/[0-9]+)*";
        }
      }
      uses interface-common-grouping;
      uses interface-ethernet-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
      uses interface-non-bundle-grouping;
    }

    // subinterface FastEthernet*
    container FastEthernet-subinterface {
      tailf:cli-drop-node-name;
      list FastEthernet {
        tailf:info "FastEthernet/IEEE 802.3 interface(s)";
        tailf:cli-allow-join-with-key;
        tailf:cli-mode-name "config-if";
        key id;
        leaf id {
          tailf:info "Fast Ethernet sub-interface id";
          type string {
            tailf:info "WORD;;Rack/Slot/Instance/Port.subid";
            pattern '[0-9]+(/[0-9]+)*\.[0-9]+';
          }
        }
        leaf mode {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum l2transport {
              tailf:info "Treat as an attachment circuit";
            }
          }
        }
        uses interface-common-grouping;
        uses interface-ethernet-grouping;
        uses subinterface-common-grouping;
      }
    }

    // interface GigabitEthernet*
    list GigabitEthernet {
      tailf:info "GigabitEthernet/IEEE 802.3 interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        tailf:info "Gigabit Ethernet interface id";
        type string {
          pattern "[0-9]+(/[0-9]+)*";
        }
      }
      uses interface-common-grouping;
      uses interface-ethernet-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
      uses interface-non-bundle-grouping;
    }

    // subinterface GigabitEthernet*
    container GigabitEthernet-subinterface {
      tailf:cli-drop-node-name;
      list GigabitEthernet {
        tailf:cli-mode-name "config-subif";
        tailf:cli-allow-join-with-key;
        cisco-ios-xr:if-delete-redeploy "mode";
        key id;
        leaf id {
          tailf:info "Gigabit Ethernet sub-interface id";
          type string {
            pattern '[0-9]+(/[0-9]+)*\.[0-9]+';
          }
        }
        leaf mode {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum l2transport;
            enum symmetric;
          }
        }
        uses interface-common-grouping;
        uses interface-ethernet-grouping;
        uses subinterface-common-grouping;
      }
    }

    // interface nve *
    list nve {
      tailf:info "Network Virtualization Endpoint Interface(s)";
      tailf:cli-mode-name "config-if-nve";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      key name;
      leaf name {
        tailf:info "nve interface name";
        type uint16 {
          tailf:info "<0-65535>;;Config allowed on NVEs, range is 0-65535";
          range "0..65535";
        }
      }

      uses interface-common-grouping;

      // interface nve* / redundancy
      container redundancy {
        tailf:info "Redundancy";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-nve-red";
        presence true;

        // interface nve* / redundancy / backbone
        container backbone {
          tailf:info "Configure ICCP backbone";

          // interface nve* / redundancy / backbone mpls
          container mpls {
            tailf:info "ICCP MPLS backbone";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-nve-red-backbone-mpls";
            presence true;

            // interface nve* / redundancy / backbone mpls / iccp
            container iccp {
              tailf:info "Inter-Chassis Communication Protocol";
              leaf group {
                tailf:info "Configure ICCP group number";
                type uint32 {
                  tailf:info "<1-4294967295>;;Enter group number";
                  range "1..4294967295";
                }
              }
            }
          }

          // interface nve* / redundancy / backbone vxlan
          container vxlan {
            tailf:info "ICCP VXLAN backbone";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-nve-red-backbone-vxlan";
            presence true;

            // interface nve* / redundancy / backbone vxlan / iccp
            container iccp {
              tailf:info "Inter-Chassis Communication Protocol";
              leaf group {
                tailf:info "Configure ICCP group number";
                type uint32 {
                  tailf:info "<1-4294967295>;;Enter group number";
                  range "1..4294967295";
                }
              }
            }
          }
        }
      }

      // interface nve* / member vni *
      container member {
        tailf:info "NVE VN-Segment Membership";
        list vni {
          tailf:info "Virtual Network Identifier";
          tailf:cli-mode-name "config-nve-vni";
          tailf:cli-range-list-syntax;
          key id;
          leaf id {
            type union {
              type uint32 {
                tailf:info "<1-16777215>;;Single VNI";
                range "1..16777215";
              }
              type string {
                tailf:info "<1-X>;;VNI range";
              }
            }
          }

          // interface nve* / member vni * / vrf
          leaf vrf {
            tailf:info "Associate a VRF with VxLAN segment";
            tailf:cli-remove-before-change;
            tailf:cli-full-command;
            type string {
              tailf:info "WORD;;VRF name";
            }
          }

          // interface nve* / member vni * / suppress-unknown-unicast-flooding
          leaf suppress-unknown-unicast-flooding {
            tailf:info "Configure the suppression of unknown unicast flooding";
            type empty;
          }

          // interface nve* / member vni * / host-reachability protocol bgp
          container host-reachability {
            tailf:info "Configure host reachability advertisement";
            leaf protocol {
              tailf:info "Control protocol to use";
              type enumeration {
                enum "bgp" {
                  tailf:info "Border Gateway Protocol";
                }
              }
            }
          }
          // interface nve* / member vni * /  host-reachabilty protocol bgp
          // Note: ASR5.3 spelling typo support.
          container host-reachabilty {
            tailf:info "Configure host reachabilty advertisement";
            leaf protocol {
              tailf:info "Control protocol to use";
              type enumeration {
                enum "bgp" {
                  tailf:info "Border Gateway Protocol";
                }
              }
            }
          }

          // interface nve* / member vni * / load-balance per-evi
          container load-balance {
            tailf:info "Configure load balance mode";
            leaf per-evi {
              tailf:info "Configure per-evi load balance mode (default is per-flow)";
              type empty;
            }
          }

          // interface nve* / member vni * / mcast-group
          container mcast-group {
            tailf:info "associate a multicast core group with VxLAN segment(s)";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf ip-address {
              tailf:cli-drop-node-name;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Single mcast ID or Start of range";
              }
            }
            leaf end-ip-address {
              tailf:cli-drop-node-name;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;End of mcast IP range";
              }
            }
          }
        }
      }

      // interface nve* / remap-replication-servers
      leaf remap-replication-servers {
        tailf:info "Remap Replication servers to VNIs";
        tailf:cli-full-command;
        type empty;
      }

      // interface nve* / overlay-encapsulation
      leaf overlay-encapsulation {
        tailf:info "Configure encapsulation for Network Virtualization Endpoint";
        type enumeration {
          enum soft-gre {
            tailf:info "Configure Soft GRE encapsulation for Network Virtualization Endpoint";
          }
          enum vxlan {
            tailf:info "Configure VxLAN encapsulation for Network Virtualization Endpoint";
          }
        }
      }

      // interface nve* / replication-server
      leaf replication-server {
        tailf:info "Configure a replication server";
        tailf:cli-full-command;
        type inet:ipv4-address {
        }
      }

      // interface nve* / source-interface Loopback
      container source-interface {
        tailf:info "Configure source interface for Network Virtualization Endpoint";
        leaf Loopback {
          tailf:info "Loopback interface";
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          tailf:cli-suppress-leafref-in-diff;
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:interface/Loopback/id";
          }
          type uint32 {
            tailf:info "<0-2147483647>";
            range "0..2147483647";
          }
        }
      }

      // interface nve* / anycast source-interface Loopback
      container anycast {
        tailf:info "Configure anycast mode parameters for this VTEP";
        container source-interface {
          tailf:info "Configure source interface for the anycast mode";
          leaf Loopback {
            tailf:info "Loopback interface";
            tailf:cli-allow-join-with-value {
              tailf:cli-display-joined;
            }
            tailf:cli-suppress-leafref-in-diff;
            tailf:non-strict-leafref {
              path "/cisco-ios-xr:interface/Loopback/id";
            }
            type uint32 {
              tailf:info "<0-2147483647>";
              range "0..2147483647";
            }
          }
        }
      }
    }

    // interface PW-Ether*
    list PW-Ether {
      tailf:info "Pseudo-Wire Ethernet interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        tailf:info "Pseudo-Wire Ethernet interface id";
        type uint16 {
          tailf:info "<1-32768>";
          range "1..32768";
        }
      }
      uses interface-common-grouping;
      uses interface-ethernet-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
      uses interface-non-bundle-grouping;

      // interface PW-Ether* / l2overhead
      leaf l2overhead {
        tailf:info "Set Layer 2 Overhead size";
        type uint8 {
          tailf:info "<1-64>;;L2 overhead size in bytes";
          range "1..64";
        }
      }
    }

    // interface PW-Ether*
    container PW-Ether-subinterface {
      tailf:cli-drop-node-name;
      list PW-Ether {
        tailf:cli-mode-name "config-subif";
        tailf:cli-allow-join-with-key;
        key id;
        leaf id {
          tailf:info "Pseudo-Wire Ethernet sub-interface id";
          type string {
            pattern '[0-9]+\.[0-9]+';
          }
        }
        leaf l2transport {
          tailf:info "Treat as an attachment circuit";
          tailf:cli-hide-in-submode;
          type empty;
        }
        uses interface-common-grouping;
        uses interface-ethernet-grouping;
        uses subinterface-common-grouping;
      }
    }

    // interface PW-IW*
    list PW-IW {
      tailf:info "PWHE VC11 IP Interworking Interface | short name is PI";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        tailf:info "PW-IW interface id";
        type uint16 {
          tailf:info "<1-32768>";
          range "1..32768";
        }
      }
      uses interface-common-grouping;
      uses interface-ethernet-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
      uses interface-non-bundle-grouping;
    }

    // interface Port-channel*
    list Port-channel {
      tailf:info "Ethernet Channel of interfaces";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        tailf:info "Port-channel interface id";
        type uint32 {
          tailf:info "<1-512>;;Port-channel interface number";
          range "1..512";
        }
      }
      uses interface-common-grouping;
      uses interface-ethernet-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
    }

    // interface POS*
    list POS {
      tailf:info "Packet over SONET/SDH network interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        tailf:info "POS interface id";
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
          pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+";
        }
      }
      uses interface-common-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
      uses interface-pointtopoint-grouping;

      // interface POS* / pos / crc
      container pos {
        tailf:info "Modify POS parameters";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-if-pos";
        leaf crc {
          type enumeration {
            enum "16" {
              tailf:info "16-bit CRC mode";
            }
            enum "32" {
              tailf:info "32-bit CRC mode (default)";
            }
          }
        }
      }
    }

    // subinterface POS*
    container POS-subinterface {
      tailf:cli-drop-node-name;
      list POS {
        tailf:info "Packet over SONET/SDH network interface(s)";
        tailf:cli-allow-join-with-key;
        tailf:cli-mode-name "config-subif";
        key id;
        leaf id {
          tailf:info "POS sub-interface id";
          type string {
            pattern '[0-9]+/[0-9]+/[0-9]+/[0-9]+\.[0-9]+';
          }
        }
        leaf mode {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum point-to-point {
              tailf:info "Treat as a point-to-point link";
            }
          }
        }
        uses interface-common-grouping;
        uses subinterface-common-grouping;
        uses interface-pointtopoint-grouping;
      }
    }

    // interface PTP*
    list PTP {
      tailf:info "FastEthernet/IEEE 802.3 interface(s) | short name is PTP";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        tailf:info "PTP interface id";
        type string {
          tailf:info "WORD;;Rack/Slot/Instance/Port";
          pattern "[A-Z0-9]+(/[A-Z0-9]+)*";
        }
      }
      uses interface-common-grouping;
      uses interface-ethernet-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
      uses interface-non-bundle-grouping;
    }

    // interface BVI*
    list BVI {
      tailf:info "Bridge-Group Virtual Interface";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        tailf:info "BVI interface id";
        type uint32 {
          tailf:info "<1-4294967295>";
          range "1..4294967295";
        }
      }
      // interface BVI* / host-routing
      leaf host-routing {
        tailf:info "Enable host-routing on this interface";
        type empty;
      }
      uses interface-common-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
    }

    // interface Vlan*
    list Vlan {
      tailf:info "Iosxr Vlans";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        tailf:info "Vlan interface id";
        type uint16 {
          tailf:info "<1-4094>;;Vlan interface number";
          range "1..4094";
        }
      }
      uses interface-common-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
    }

    // interface tunnel-ip*
    list tunnel-ip {
      tailf:info "GRE/IPinIP Tunnel Interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        tailf:info "tunnel-ip interface id";
        type uint16 {
          tailf:info "<0-65535>";
        }
      }
      uses interface-common-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
      uses interface-pointtopoint-grouping;

      // interface tunnel-ip* / tunnel
      container tunnel {
        tailf:info "Configure GRE tunnel parameters";

        // interface tunnel-ip* / tunnel protection ipsec
        container protection {
          tailf:info "Configure protection profile for the tunnel";
          container ipsec {
        	tailf:info "Configure protection profile for the tunnel";
        	tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
        	leaf profile {
        	  tailf:info "Configure protection profile for the tunnel";
              tailf:cli-incomplete-command;
        	  type string {
                tailf:info "WORD;;tunnel protection profile name - maximum 32 characters";
              }
        	}
        	leaf ipsec-node {
        	  tailf:info "ipsec-node configuration to be added under ipsec profile";
        	  type string {
                tailf:info "WORD;;ipsec-node Name";
              }
        	}
          }
        }

        // interface tunnel-ip* / tunnel mode
        container mode {
          tailf:info "Tunnel encapsulation method (default: gre ipv4)";
          choice mode-choice {
            // interface tunnel-ip* / tunnel mode gre
            leaf gre {
              tailf:info "IP over GRE encapsulation";
              type enumeration {
                enum ipv4 {
                  tailf:info "GRE over IPV4 encapsulation";
                }
                enum ipv6 {
                  tailf:info "GRE over IPV6 encapsulation";
                }
              }
            }
            // interface tunnel-ip* / tunnel mode ipv4
            leaf ipv4 {
              tailf:info "Generic packet tunneling over IPv4 encapsulation";
              type empty;
            }
            // interface tunnel-ip* / tunnel mode ipv6
            leaf ipv6 {
              tailf:info "Generic packet tunneling over IPv6 encapsulation";
              type empty;
            }
          }
        }

        // interface tunnel-ip* / tunnel source
        leaf source {
          tailf:info "Tunnel source physical interface";
          type string {
            tailf:info "WORD;;Interface Name";
          }
        }

        // interface tunnel-ip* / tunnel vrf
        leaf vrf {
          tailf:info "set tunnel vrf membership";
          type string {
            tailf:info "WORD;;vrf table name";
          }
        }

        // interface tunnel-ip* / tunnel destination
        leaf destination {
          tailf:info "Tunnel destination IP address";
          type union {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Ip Address";
            }
            type inet:ipv6-address {
              tailf:info "X:X::X;;IPV6 address of the tunnel destination";
            }
          }
        }

        // interface tunnel-ip* / tunnel dfbit disable
        container dfbit {
          tailf:info "Modify Do not Fragment Bit";
          leaf disable {
            tailf:info "Disable DF bit (i.e. allow fragmentation)";
            type empty;
          }
        }
      }
    }

    // interface tunnel-te*
    list tunnel-te {
      tailf:info "MPLS Traffic Engineering Tunnel interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        tailf:info "tunnel-te interface id";
        type uint16 {
          tailf:info "<0-65535>";
        }
      }
      uses interface-common-grouping;
      uses non-subinterface-common-grouping;
      uses interface-tunnel-te-grouping;

      // interface tunnel-te* / bfd
      container bfd {
        tailf:info "Configure BFD parameters";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-if-tunte-bfd";
        presence true;

        // interface tunnel-te* / bfd / multiplier
        leaf multiplier {
          tailf:info "Detect multiplier";
          type uint8 {
            tailf:info "3-10;;Detect multiplier (default 3)";
            range "3..10";
          }
        }

        // interface tunnel-te* / bfd / fast-detect
        container fast-detect {
          tailf:info "Enable BFD fast detection";
          tailf:cli-delete-when-empty;
          presence true;
          // interface tunnel-te* / bfd / fast-detect sbfd
          leaf sbfd {
            tailf:info "Enable SBFD";
            type empty;
          }
        }

        // interface tunnel-te* / bfd / minimum-interval
        leaf minimum-interval {
          tailf:info "Hello interval";
          type uint16 {
            tailf:info "3-30000;;Hello interval in milliseconds (default 100)";
            range "3..30000";
          }
        }

        // interface tunnel-te* / bfd / dampening
        container dampening {
          tailf:info "Configure dampening intervals to bring tunnel up";

          // interface tunnel-te* / bfd / dampening maximum-wait
          leaf maximum-wait {
            tailf:info "Maximum delay bringing up the tunnel";
            type uint32 {
              tailf:info "<1-518400000>;;Delay in milliseconds (default 600000)";
              range "1..518400000";
            }
          }

          // interface tunnel-te* / bfd / dampening secondary-wait
          leaf secondary-wait {
            tailf:info "Secondary delay bringing up the tunnel";
            type uint32 {
              tailf:info "<1-518400000>;;Delay in milliseconds (default 20000)";
              range "1..518400000";
            }
          }

          // interface tunnel-te* / bfd / dampening initial-wait
          leaf initial-wait {
            tailf:info "Initial delay before bringing up the tunnel";
            type uint32 {
              tailf:info "<1-518400000>;;Delay in milliseconds (default 16000)";
              range "1..518400000";
            }
          }
        }

        // interface tunnel-te* / bfd / bringup-timeout
        leaf bringup-timeout {
          tailf:info "Timeout before BFD session bring up on new LSP is aborted";
          type uint16 {
            tailf:info "<10-3600>;;Wait for session to come up in seconds (default 60)";
            range "10..3600";
          }
        }

        // interface tunnel-te* / bfd / lsp-ping
        container lsp-ping {
          tailf:info "Configure periodic LSP ping";
          choice lsp-ping-choice {
            leaf disable {
              tailf:info "Disable periodic LSP Ping";
              type empty;
            }
            leaf interval {
              tailf:info "Periodic LSP ping interval";
              type uint16 {
                tailf:info "<60-3600>;;Periodic LSP Ping interval in seconds (default 120)";
                range "60..3600";
              }
            }
          }
        }
      }

      // interface tunnel-te* / load-share
      leaf load-share {
        tailf:info "Specify tunnel load-sharing metric";
        tailf:cli-full-command;
        type uint32 {
          tailf:info "<1-4294967295>;;Loadshare value. Scale is the same as bandwidths.";
          range "1..4294967295";
        }
      }

      // interface tunnel-te* / auto-bw
      container auto-bw {
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-if-tunte-autobw";
        presence true;

        // interface tunnel-te* / auto-bw / bw-limit
        container bw-limit {
          tailf:info "Set min/max bandwidth auto-bw can apply on a tunnel";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf min {
            tailf:info "Set minimum bandwidth auto-bw can apply on a tunnel";
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<0-4294967295>;;Minimum bandwidth to apply (kbps)";
            }
          }
          leaf max {
            tailf:info "Set maximum bandwidth auto-bw can apply on a tunnel";
            type uint32 {
              tailf:info "<0-4294967295>;;Maximum bandwidth to apply (kbps)";
            }
          }
        }

        // interface tunnel-te* / auto-bw / overflow threshold
        container overflow {
          tailf:info "Configuring the tunnel overflow detection";
          uses interface-tunnel-te-auto-bw-threshold-grouping;
        }

        // interface tunnel-te* / auto-bw / underflow threshold
        container underflow {
          tailf:info "Configuring the tunnel underflow detection";
          uses interface-tunnel-te-auto-bw-threshold-grouping;
        }

        // interface tunnel-te* / auto-bw / adjustment-threshold
        container adjustment-threshold {
          tailf:info "Set the bandwidth change threshold to trigger adjustment";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf percentage {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-100>;;Bandwidth change percent to trigger adjustment";
              range "1..100";
            }
          }
          leaf min {
            tailf:info "Set the bandwidth change value to trigger adjustment";
            type uint32 {
              tailf:info "<10-4294967295>;;Bandwidth change value to trigger adjustment (kbps)";
              range "10..4294967295";
            }
          }
        }

        // interface tunnel-te* / auto-bw / application
        leaf application {
          tailf:info "Set the tunnel auto-bw application frequency";
          type uint16 {
            tailf:info "<5-10080>;;Auto-bw application frequency (minutes)";
            range "5..10080";
          }
        }
      }

      // interface tunnel-te* / autoroute
      container autoroute {
        tailf:info "Parameters for IGP routing over tunnel";
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;

        // interface tunnel-te* / autoroute metric
        container metric {
          tailf:info "Specify MPLS tunnel metric";
          choice metric-choice {
            leaf absolute {
              tailf:info "Set metric mode absolute";
              type uint32 {
                tailf:info "<1-2147483647>;;Absolute metric";
                range "1..2147483647";
              }
            }
            leaf relative {
              tailf:info "Set metric mode relative";
              type int8 {
                tailf:info "<-10,+10>;;Relative metric";
                range "-10..10";
              }
            }
          }
        }

        // interface tunnel-te* / autoroute announce
        container announce {
          tailf:info "Announce tunnel to IGP";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-if-tunte-aa";
          tailf:cli-full-command;
          presence true;

          // interface tunnel-te* / autoroute announce / metric
          container metric {
            tailf:info "Specify MPLS tunnel metric";
            choice metric-choice {
              // interface tunnel-te* / autoroute announce / metric constant
              leaf constant {
                tailf:cli-drop-node-name;
                type uint32 {
                  tailf:info "<1-2147483647>;;Set constant metric";
                  range "1..2147483647";
                }
              }
              // interface tunnel-te* / autoroute announce / metric absolute
              leaf absolute {
                tailf:info "Set metric mode absolute";
                type uint32 {
                  tailf:info "<1-2147483647>;;Absolute metric";
                  range "1..2147483647";
                }
              }
              // interface tunnel-te* / autoroute announce / metric relative
              leaf relative {
                tailf:info "Set metric mode relative";
                type int8 {
                  tailf:info "<-10,+10>;;Relative metric";
                  range "-10..10";
                }
              }
            }
          }

          // interface tunnel-te* / autoroute announce / exclude-traffic segment-routing
          container exclude-traffic {
            tailf:info "Exclude the type of traffic that goes through AA";
            leaf segment-routing {
              tailf:info "Exclude segment-routing traffic from the autoroute announced tunnel";
              type empty;
            }
          }
        }

        // interface tunnel-te* / autoroute destination *
        list destination {
          tailf:info "Adds static route to destination";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key addr;
          leaf addr {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Address of static route to add";
            }
          }
        }
      }

      // interface tunnel-te* / forwarding-adjacency
      container forwarding-adjacency {
        tailf:info "Enable tunnel as a forwarding-adjacency and enter its submode";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-if-tunte-fwdadj";
        presence true;

        // interface tunnel-te* / forwarding-adjacency / holdtime
        leaf holdtime {
          tailf:info "Hold time in ms";
          type uint16 {
            tailf:info "<0-20000>;;Hold time in ms";
            range "0..20000";
          }
        }

        // interface tunnel-te* / forwarding-adjacency / include-ipv6
        leaf include-ipv6 {
          tailf:info "Announce tunnel as an IPv6 FA also";
          type empty;
        }
      }

      // interface tunnel-te* / destination
      leaf destination {
        tailf:info "Specify tunnel destination";
        tailf:cli-full-command;
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Destination address";
        }
      }

      // interface tunnel-te* / forward-class
      leaf forward-class {
        tailf:info "Specify tunnel forward class for policy based routing";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<1-7>;;Forward class for the tunnel (default value 0)";
          range "1..7";
        }
      }

      // interface tunnel-te* / soft-preemption
      leaf soft-preemption {
        tailf:info "Enable the soft-preemption feature on this tunnel";
        tailf:cli-full-command;
        type empty;
      }

      // interface tunnel-te* / path-protection
      leaf path-protection {
        tailf:info "Enable the path protection feature on this tunnel";
        tailf:cli-full-command;
        type empty;
      }

      // interface tunnel-te* / path-selection
      container path-selection {
        tailf:info "Path Selection Configuration";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-if-tunte-path-sel";

        // interface tunnel-te* / path-selection / metric
        container metric {
          tailf:info "Metric Type for path calculation";
          leaf metric-type {
            tailf:cli-drop-node-name;
            tailf:cli-full-command;
            type enumeration {
              enum igp {
                tailf:info "Use IGP metric";
              }
              enum te {
                tailf:info "Use TE metric";
              }
              enum delay {
                tailf:info "Use delay metric";
              }
            }
          }
        }

        // interface tunnel-te* / path-selection / delay-limit
        leaf delay-limit {
          tailf:info "Delay limit configuration";
          type uint32 {
            tailf:info "<1-4294967295>;;Delay limit in usec";
            range "1..4294967295";
          }
        }

        // interface tunnel-te* / path-selection / hop-limit
        leaf hop-limit {
          tailf:info "Hop limit configuration";
          type uint8 {
            tailf:info "<1-255>;;Hop limit";
            range "1..255";
          }
        }

        // interface tunnel-te* / path-selection / cost-limit
        leaf cost-limit {
          tailf:info "Cost limit configuration";
          type uint32 {
            tailf:info "<1-4294967295>;;Cost limit";
            range "1..4294967295";
          }
        }

        // interface tunnel-te* / path-selection / segment-routing adjacency
        container segment-routing {
          tailf:info "Segment-routing path-selection options";
          leaf adjacency {
            tailf:info "Segment-routing adjacency path-selection type";
            type enumeration {
              enum protected {
                tailf:info "Use only protected adjacencies";
              }
              enum unprotected {
                tailf:info "Use only unprotected adjacencies";
              }
            }
          }
        }
      }

      // interface tunnel-te* / path-option *
      uses interface-tunnel-path-option-grouping;

      // interface tunnel-te* / pce
      container pce {
        tailf:info "Config PCE parameters";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-if-pce";
        presence true;

        // interface tunnel-te* / pce / delegation
        leaf delegation {
          tailf:info "Enable PCE delegation";
          type empty;
        }
      }
    }

    // interface tunnel-tp*
    list tunnel-tp {
      tailf:info "MPLS Transport Protocol Tunnel interface";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        tailf:info "tunnel-tp interface id";
        type uint16 {
          tailf:info "<0-65535>";
        }
      }
      uses interface-common-grouping;
      uses non-subinterface-common-grouping;
    }

    // interface tunnel-mte*
    list tunnel-mte {
      tailf:info "MPLS Traffic Engineering P2MP Tunnel interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        tailf:info "tunnel-mte interface id";
        type uint16 {
          tailf:info "<0-65535>";
        }
      }
      uses interface-common-grouping;
      uses non-subinterface-common-grouping;
      uses interface-tunnel-te-grouping;

      // interface tunnel-mte* / destination *
      list destination {
        tailf:info "Specify a destination to an endpoint of the tunnel";
        tailf:cli-mode-name "config-if-p2mp-dest";
        key addr;
        leaf addr {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Destination address";
          }
        }
        // interface tunnel-mte* / destination * / path-option *
        uses interface-tunnel-path-option-grouping;
      }
    }

    // interface tunnel-ipsec*
    list tunnel-ipsec {
      tailf:info "IPSec Tunnel interface(s)";
      //NSO BUG: tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        tailf:info "tunnel-ipsec interface id";
        type uint32 {
          tailf:info "<0-4294967295>";
        }
      }
      uses interface-common-grouping;
      uses non-subinterface-common-grouping;
    }

    // interface ATM*
    list ATM {
      tailf:info "ATM Network Interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        tailf:info "ATM Network interface id";
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
          pattern "[0-9]+(/[0-9]+)+";
        }
      }
      uses interface-common-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
      uses interface-atm-grouping;
    }

    // subinterface ATM* l2transport
    // subinterface ATM* point-to-point
    container ATM-subinterface {
      tailf:cli-drop-node-name;
      list ATM {
        tailf:info "ATM Network Interface(s)";
        tailf:cli-mode-name "config-subif";
        tailf:cli-allow-join-with-key;
        key id;
        leaf id {
          tailf:info "ATM Network sub-interface id";
          type string {
            pattern '[0-9]+(/[0-9]+)*\.[0-9]+';
          }
        }
        choice mode-choice {
          leaf l2transport {
            tailf:info "Treat as an attachment circuit";
            tailf:cli-full-command;
            tailf:cli-hide-in-submode;
            type empty;
          }
          leaf point-to-point {
            tailf:info "Treat as a point-to-point link";
            tailf:cli-full-command;
            tailf:cli-hide-in-submode;
            type empty;
          }
        }
        uses interface-common-grouping;
        uses subinterface-common-grouping;
        uses interface-atm-grouping;
      }
    }

    // interface Multilink*
    list Multilink {
      tailf:info "Multilink network interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        tailf:info "Multilink interface id";
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
          pattern "[0-9]+(/[0-9]+)+";
        }
      }
      uses interface-common-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
      uses interface-pointtopoint-grouping;
      uses interface-multilink-grouping;
    }

    // subinterface Multilink*
    container Multilink-subinterface {
      tailf:cli-drop-node-name;
      list Multilink {
        tailf:cli-mode-name "config-subif";
        tailf:cli-allow-join-with-key;
        key id;
        leaf id {
          tailf:info "Multilink sub-interface id";
          type string {
            pattern '[0-9]+(/[0-9]+)*\.[0-9]+';
          }
        }
        leaf mode {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum point-to-point {
              tailf:info "Treat as a point-to-point link";
            }
          }
        }
        uses interface-common-grouping;
        uses subinterface-common-grouping;
        uses interface-pointtopoint-grouping;
        uses interface-multilink-grouping;
      }
    }

    // interface SRP*
    list SRP {
      tailf:info "SRP interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        type string {
          pattern "[0-9]+.*";
        }
      }
      uses interface-common-grouping;
      uses non-subinterface-common-grouping;

      // interface SRP* / threshold
      container threshold {
        tailf:info "Commands to set the threshold for the appropriate Bit Error Rate";

        // interface SRP* / threshold b2-tca
        leaf b2-tca {
          tailf:info "Set B2 BER Threshold Crossing Alert (TCA) threshold";
          type uint8 {
            tailf:info "<3-9>;;Bit error rate (10 to the minus n) (default 6)";
            range "3..9";
          }
        }
      }
    }

    // interface Serial*
    list Serial {
      tailf:info "Serial network interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        tailf:info "Serial network interface id";
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
          pattern "[0-9]+(/[0-9]+)+(:[0-9]+)?";
        }
      }
      uses interface-common-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
      uses interface-pointtopoint-grouping;

      // interface Serial * / multilink
      container multilink {
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-if-multilink";
        leaf group {
          tailf:info "Enter multilink group ID";
          type uint32 {
            tailf:info "<1-999999999>;;Group Id";
            range "1..999999999";
          }
        }
      }

      // interface Serial * / serial
      container serial {
        tailf:info "Modify Serial parameters";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-if-serial";

        // interface Serial * / serial / crc
        leaf crc {
          tailf:info "Set the Encapsulation of this PVC";
          type enumeration {
            enum 16 {
              tailf:info "16-bit CRC mode (default)";
            }
            enum 32 {
              tailf:info "32-bit CRC mode";
            }
          }
        }

        // interface Serial * / serial / scramble
        leaf scramble {
          tailf:info "Enable payload scrambling on Serial interface";
          type empty;
        }
      }
    }

    container Serial-subinterface {
      tailf:cli-drop-node-name;
      list Serial {
        tailf:info "Serial network interface(s)";
        tailf:cli-allow-join-with-key;
        tailf:cli-mode-name "config-subif";
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          tailf:info "Serial network sub-interface id";
          type string {
            tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
            pattern '[0-9]+(/[0-9]+)+(:[0-9]+)?\.[0-9]+';
          }
        }
        leaf mode {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum point-to-point {
              tailf:info "Treat as a point-to-point link";
            }
            enum l2transport {
              tailf:info "Treat as an attachment circuit";
            }
          }
        }
        uses interface-common-grouping;
        uses interface-bfd-grouping;
        uses subinterface-common-grouping;
        uses interface-pointtopoint-grouping;
        leaf subinterface {
          tailf:info "Do not SET, internal testing leaf only";
          tailf:cli-full-command;
          type empty;
        }
      }
    }

    // interface CEM*
    list CEM {
      tailf:info "Circuit Emulation interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        tailf:info "Circuit Emulation interface id";
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
          pattern "[0-9]+.*";
        }
      }
      uses interface-common-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;

      // interface CEM* / cem
      container cem {
        tailf:info "Global CEM interface configuration subcommands";

        // interface CEM * / cem class-attach
        leaf class-attach {
          tailf:info "Attach a CEM class to this interface";
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;CEM class name";
          }
        }

        // interface CEM * / cem dejitter
        leaf dejitter {
          tailf:info "Configure dejitter buffer";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<1-500>;;buffer size in milliseconds";
          }
        }
      }
    }

    // interface GCC0*
    list GCC0 {
      tailf:info "OTN GCC0 interface(s) | short name is G0";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        tailf:info "OTN GCC0 interface(s) | short name is G0";
        type string {
          pattern "[0-9]+.*";
        }
      }
      uses interface-common-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
    }

    // interface CSI*
    list CSI {
      tailf:info "Cross SDR interface(s) | short name is csi";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-if";
      key id;
      leaf id {
        tailf:info "Cross SDR interface(s) | short name is csi";
        type uint8 {
          tailf:info "<1-32>";
          range "1..32";
        }
      }
      uses interface-common-grouping;
      uses non-subinterface-common-grouping;
    }
  }

  // bgp-address-family-pre-grouping
  grouping bgp-address-family-pre-grouping {

    // router bgp * / address-family * / apply-group
    uses apply-group-grouping;

    // router bgp * / address-family * / mvpn single-forwarder-selection
    container mvpn {
      tailf:info "MVPN commands";
      leaf single-forwarder-selection {
        tailf:info "Enable single forwarder selection";
        type enumeration {
          enum all {
            tailf:info "Select all paths";
          }
          enum highest-ip-address {
            tailf:info "Select PE with highest ip address";
          }
        }
      }
    }

    // router bgp * / address-family * / label mode
    container label {
      tailf:info "Label-related configuration";
      container  mode {
        tailf:info "Select label mode";
        choice mode-choice {
          leaf per-ce  {
            tailf:info "Set per CE label mode";
            type empty;
          }
          leaf per-prefix {
            tailf:info "Set per perfix label mode";
            type empty;
          }
          leaf per-vrf {
            tailf:info "Set per VRF label mode";
            type empty;
          }
          leaf route-policy {
            tailf:info "Use a route policy to select prefixes for label allocation mode";
            type string {
              tailf:info "WORD;;Name of the policy";
            }
          }
        }
      }
    }

    // router bgp * / address-family * / table-policy
    leaf table-policy {
      tailf:info "Configure policy for installation of routes to RIB";
      tailf:cli-full-command;
      type string {
        tailf:info "WORD;;Name of the policy";
      }
    }

    // router bgp * / address-family * / retain
    container retain {
      tailf:info "Accept/Retain specified bgp parameters";

      // router bgp * / address-family * / retain local-label
      leaf local-label {
        tailf:info "Delay the release of the local label as configured";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<3-60>;;Label retention time in minutes";
          range "3..60";
        }
      }

      // router bgp * / address-family * / retain route-target
      container route-target {
        tailf:info "Accept received updates with the specified route targets";
        choice route-target-choice {
          leaf all {
            tailf:info "Accept received updates containing at least one route target";
            type empty;
          }
          leaf route-policy {
            tailf:info "Accept received updates accepted by the specified policy";
            tailf:cli-suppress-leafref-in-diff;
            tailf:non-strict-leafref {
              path "/cisco-ios-xr:route-policy/name";
            }
            type string {
              tailf:info "WORD;;Name of the policy";
            }
          }
        }
      }
    }

    // router bgp * / address-family * / update
    container update {
      tailf:info "BGP Update generation configuration";

      // router bgp * / address-family * / update limit
      container limit {
        tailf:info "Upper bound on transient memory usage for update generation";
        leaf address-family {
          tailf:info "Update limit for address-family";
          type uint16 {
            tailf:info "<4-2048>;;Update limit in MegaBytes(MB); default is 256 MB";
            range "4..2048";
          }
        }
        container sub-group {
          tailf:info "Update limit for sub-groups";
          leaf ebgp {
            tailf:info "Update limit for eBGP sub-groups";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<1-512>;;Update limit in MegaBytes(MB); default is 32 MB";
              range "1..512";
            }
          }
          leaf ibgp {
            tailf:info "Update limit for iBGP sub-groups";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<1-512>;;Update limit in MegaBytes(MB); default is 32 MB";
              range "1..512";
            }
          }
        }
      }

      // router bgp * / address-family * / update wait-install
      leaf wait-install {
        tailf:info "Wait for route install";
        type empty;
      }
    }

    // router bgp * / address-family * / additional-paths
    container additional-paths {
      tailf:info "Additional paths configuration";

      // router bgp * / address-family ? / additional-paths receive
      leaf receive {
        tailf:info "Additional paths Receive capability";
        tailf:cli-full-command;
        type empty;
      }

      // router bgp * / address-family ? / additional-paths send
      leaf send {
        tailf:info "Additional paths Send capability";
        tailf:cli-full-command;
        type empty;
      }

      // router bgp * / address-family ? / additional-paths selection
      container selection {
        tailf:info "Additional paths selection";

        // router bgp * / address-family ? / additional-paths selection disable
        // router bgp * / address-family ? / additional-paths selection route-policy
        choice selection-choice {
          leaf disable {
            tailf:info "Disable additional paths selection";
            type empty;
          }
          list route-policy {
            tailf:info "Route-policy for additional paths selection";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key name;
            leaf name {
              tailf:cli-suppress-leafref-in-diff;
              tailf:non-strict-leafref {
                path "/cisco-ios-xr:route-policy/name";
              }
              type string {
                tailf:info "WORD;;Name of the policy";
              }
            }
          }
        }
      }
    }

    // router bgp * / address-family * / weight
    leaf weight {
      tailf:info "Define or modify weight";
      tailf:cli-full-command;
      type union {
        type enumeration {
          enum reset-on-import {
            tailf:info "Reset weight of paths on import";
          }
        }
        type uint32 {
          tailf:info "<0-65535>;;default weight";
          range "0..65535";
        }
      }
    }

    // router bgp * / address-family * / advertise
    container advertise {
      tailf:info "Advertise BGP path";

      // router bgp * / address-family * / advertise best-external
      leaf best-external {
        tailf:info "Advertise best-external path";
        type empty;
      }

      // router bgp * / address-family * / advertise local-labeled-route
      container local-labeled-route {
        tailf:info "Advertisement of routes with local-label";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-delete-when-empty;
        presence true;
        leaf safi-unicast {
          tailf:info "Advertisement of routes with local-label via Unicast SAFI";
          tailf:cli-optional-in-sequence;
          tailf:cli-incomplete-command;
          type empty;
        }
        leaf disable {
          tailf:info "Do not advertise routes with local-label via Unicast SAFI";
          type empty;
        }
      }

      // router bgp * / address-family * / advertise permanent-network
      leaf permanent-network {
        tailf:info "Allow permanent networks for this neighbor";
        type empty;
      }

      // router bgp * / address-family * / advertise vpnv4 unicast
      container vpnv4 {
        tailf:info "VPNv4 Address Family";
        container unicast {
          tailf:info "Address Family modifier";
          tailf:cli-delete-when-empty;
          presence true;
          uses router-bgp-af-advertise-grouping;
        }
      }

      // router bgp * / address-family * / advertise vpnv6 unicast
      container vpnv6 {
        tailf:info "Vpnv6 Address Family";
        container unicast {
          tailf:info "Address Family modifier";
          tailf:cli-delete-when-empty;
          presence true;
          uses router-bgp-af-advertise-grouping;
        }
      }

      // router bgp * / address-family * / advertise l2vpn evpn
      container l2vpn {
        tailf:info "L2VPN Address Family";
        container evpn {
          tailf:info "Address Family modifier";
          tailf:cli-delete-when-empty;
          presence true;
          uses router-bgp-af-advertise-grouping;
        }
      }
    }

    // router bgp * / address-family * / bgp
    container bgp {
      tailf:info "BGP Commands";

      // router bgp * / address-family * / bgp attribute-download
      leaf attribute-download {
        tailf:info "Configure attribute download for this address-family";
        tailf:cli-full-command;
        type empty;
      }

      // router bgp * / address-family * / bgp dampening
      container dampening {
        tailf:info "Enable route-flap dampening";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-delete-when-empty;
        presence true;
        choice dampening-choice {
          case a {
            leaf half-life {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<1-45>;;Half-life time for the penalty";
                range "1..45";
              }
            }
            leaf reuse {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint16 {
                tailf:info "<1-20000>;;Value to start reusing a route";
                range "1..20000";
              }
            }
            leaf suppress {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint16 {
                tailf:info "<1-20000>;;Value to start suppressing a route";
                range "1..20000";
              }
            }
            leaf max-suppress-time {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<1-255>;;Maximum duration to suppress a stable route";
                range "1..255";
              }
            }
          }
          case b {
            // router bgp * / address-family * / bgp dampening route-policy
            leaf route-policy {
              tailf:info "Route policy to specify criteria for dampening";
              tailf:cli-full-command;
              type string {
                tailf:info "WORD;;Name of the policy";
              }
            }
          }
        }
      }

      // router bgp * / address-family * / bgp scan-time
      leaf scan-time {
        tailf:info "Configure background scanner interval for generic scanner";
        type uint16 {
          tailf:info "<5-3600>;;Scanner interval (seconds)";
          range "5..3600";
        }
      }

      // router bgp * / address-family * / bgp label-delay
      container label-delay {
        tailf:info "Specify delay for batching label processing";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf seconds {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<0-10>;;Delay, seconds part";
            range "0..10";
          }
        }
        leaf milliseconds {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-999>;;Delay, milliseconds part";
            range "0..999";
          }
        }
      }

      // router bgp * / address-family * / bgp import-delay
      container import-delay {
        tailf:info "Specify delay for import processing";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf seconds {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<0-10>;;Delay, seconds part";
            range "0..10";
          }
        }
        leaf milliseconds {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-999>;;Delay, milliseconds part";
            range "0..999";
          }
        }
      }

      // router bgp * / address-family * / bgp client-to-client reflection
      container client-to-client {
        tailf:info "Configure client to client route reflection";
        container reflection {
          tailf:info "Reflection";

          // router bgp * / address-family * / bgp client-to-client reflection disable
          leaf disable {
            tailf:info "Disable";
            type empty;
          }
        }
      }

      // router bgp * / address-family * / bgp origin-as validation
      container origin-as {
        tailf:info "BGP origin-AS knobs";
        container validation {
          tailf:info "BGP origin-AS validation knobs";

          // router bgp * / address-family * / bgp origin-as validation enable
          leaf enable {
            tailf:info "Enable RPKI origin-AS validation";
            type empty;
          }

          // router bgp * / address-family * / bgp origin-as validation signal ibgp
          container signal {
            tailf:info "Signal origin-AS validity towards peers";
            leaf ibgp {
              tailf:info "Signal origin-AS validity towards iBGP peers";
              type empty;
            }
          }
        }
      }

      // router bgp * / address-family * / bgp bestpath origin-as
      container bestpath {
        tailf:info "Change default route selection criteria";
        uses bgp-bestpath-origin-as-grouping;
      }
    }

    // router bgp * / address-family * / maximum-paths
    container maximum-paths {
      tailf:info "Forward packets over multiple paths";

      // router bgp * / address-family * / maximum-paths eibgp
      container eibgp {
        tailf:info "eiBGP-multipath";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf maximum {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<2-32>;;Number of paths";
          }
        }
        leaf selective {
          tailf:info "Allow multipaths only from marked neighbors";
          type  empty;
        }
      }

      // router bgp * / address-family * / maximum-paths ebgp
      container ebgp {
        tailf:info "eBGP-multipath";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf maximum {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<2-32>;;Number of paths";
          }
        }
        leaf selective {
          tailf:info "Allow multipaths only from marked neighbors";
          type  empty;
        }
      }

      // router bgp * / address-family * / maximum-paths ibgp
      container ibgp {
        tailf:info "iBGP-multipath";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf maximum {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<2-32>;;Number of paths (limit includes backup path)";
          }
        }
        leaf unequal-cost {
          tailf:info "Allow multipaths to have different BGP nexthop IGP metrics";
          tailf:cli-optional-in-sequence;
          type empty;
        }
        leaf selective {
          tailf:info "Allow multipaths only from marked neighbors";
          type  empty;
        }
      }

    }

    // router bgp * / address-family * / distance
    container distance {
      tailf:info "Define an administrative distance";
      container bgp {
        tailf:info "BGP distance";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf external {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<1-255>;;Distance for routes external to the AS";
            range "1..255";
          }
        }
        leaf internal {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<1-255>;;Distance for routes internal to the AS";
            range "1..255";
          }
        }
        leaf local {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<1-255>;;Distance for local routes";
            range "1..255";
          }
        }
      }
    }

    // router bgp * / address-family * / nexthop
    container nexthop {
      tailf:info "Nexthop";
      container resolution {
        tailf:info "Nexthop resolution";
        container prefix-length {
          tailf:info "Nexthop resolution prefix-length";
          leaf minimum {
            tailf:info "Set minimum prefix-length for nexthop resolution";
            type uint16 {
              tailf:info "<0-32|128>;;Prefix-length value (only 0 and 32|128 are supported)";
            }
          }
        }
      }
      leaf route-policy {
        tailf:info "Policy to filter out nexthop notification";
        tailf:cli-suppress-leafref-in-diff;
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:route-policy/name";
        }
        type string {
          tailf:info "WORD;;Name of the policy";
        }
      }
      container trigger-delay {
        tailf:info "Processing trigger delay";
        leaf critical {
          tailf:info "For critical notification";
          type uint32 {
            tailf:info "<0-4294967295>;;Delay in milliseconds";
          }
        }
        leaf non-critical {
          tailf:info "For non-critical notification";
          type uint32 {
            tailf:info "<0-4294967295>;;Delay in milliseconds";
          }
        }
      }
    }

    // router bgp * / address-family * / domain-distinguisher
    leaf domain-distinguisher {
      tailf:info "Globally unique identifier for IGP domain";
      tailf:cli-full-command;
      type string {
        tailf:info "<1-4294967295>:;;4 octet ASN";
      }
    }
  }

  // bgp-address-family-post-grouping
  grouping bgp-address-family-post-grouping {

    // router bgp * / address-family * / allow vpn default-originate
    container allow {
      tailf:info "Allow sending default originate route to VPN neighbor";
      container vpn {
        tailf:info "Originate default route to VPN neighbor";
        leaf default-originate {
          tailf:info "Originate default route to VPN neighbor";
          type empty;
        }
      }
    }

    // router bgp * / address-family * / aggregate-address *
    list aggregate-address {
      tailf:info "Configure BGP aggregate entries";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key prefix;
      leaf prefix {
        type union {
          type ipv4-prefix {
            tailf:info "A.B.C.D/length;;IPv4 Aggregate address and mask or masklength";
          }
          type tailf:ipv6-address-and-prefix-length {
            tailf:info "X:X::X/length;;IPv6 Aggregate address and mask or masklength";
          }
        }
      }
      leaf as-set {
        tailf:info "Generate AS set path information";
        type empty;
      }
      leaf as-confed-set {
        tailf:info "Generate AS confed set path information";
        type empty;
      }
      leaf summary-only {
        tailf:info "Filter more specific routes from updates";
        type empty;
      }
      container route-policy {
        tailf:info "Policy to condition advertisement, suppression, and attributes";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf name {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-leafref-in-diff;
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:route-policy/name";
          }
          type string {
            tailf:info "WORD;;Name of the policy";
          }
        }
      }
    }

    // router bgp * / address-family * / redistribute
    container redistribute {
      tailf:info "Redistribute information from another routing protocol";

      // router bgp * / address-family * / redistribute connected
      container connected {
        tailf:info "Connected routes";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-af-redistribute-grouping;
      }

      // router bgp * / address-family * / redistribute static
      container static {
        tailf:info "Static routes";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-af-redistribute-grouping;
      }

      // router bgp * / address-family * / redistribute rip
      container rip {
        tailf:info "Routing Information Protocol (RIP)";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-af-redistribute-grouping;
      }

      // router bgp * / address-family * / redistribute mobile
      container mobile {
        tailf:info "Mobile routes";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-af-redistribute-grouping;
      }

      // router bgp * / address-family * / redistribute subscriber
      container subscriber {
        tailf:info "subscriber routes";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-af-redistribute-grouping;
      }

      // router bgp * / address-family * / redistribute ospf *
      list ospf {
        tailf:info "Open Shortest Path First (OSPF)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;OSPF router tag";
          }
        }
        leaf match {
          tailf:info "Redistribution of OSPF routes";
          type empty;
        }
        leaf internal {
          tailf:info "Redistribute OSPF internal routes";
          when "../match";
          type empty;
        }
        leaf external {
          tailf:info "Redistribute OSPF external routes";
          when "../match";
          type empty;
        }
        leaf external-type {
          tailf:cli-drop-node-name;
          when "../external";
          type enumeration {
            enum "1" {
              tailf:info "Redistribute external type 1 routes";
            }
            enum "2" {
              tailf:info "Redistribute external type 2 routes";
            }
          }
        }
        leaf nssa-external {
          tailf:info "Redistribute OSPF NSSA external routes";
          when "../match";
          type empty;
        }
        leaf nssa-external-type {
          tailf:cli-drop-node-name;
          when "../nssa-external";
          type enumeration {
            enum "1" {
              tailf:info "Redistribute NSSA external type 1 routes";
            }
            enum "2" {
              tailf:info "Redistribute NSSA external type 2 routes";
            }
          }
        }
        uses router-af-redistribute-grouping;
      }

      // router bgp * / address-family * / redistribute ospfv3 *
      list ospfv3 {
        tailf:info "IPv6 Open Shortest Path First (OSPFv3)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;OSPFv3 router tag";
          }
        }
        leaf match {
          tailf:info "Redistribution of OSPF routes";
          type empty;
        }
        leaf internal {
          tailf:info "Redistribute OSPF internal routes";
          when "../match";
          type empty;
        }
        leaf external {
          tailf:info "Redistribute OSPF external routes";
          when "../match";
          type empty;
        }
        leaf external-type {
          tailf:cli-drop-node-name;
          when "../external";
          type enumeration {
            enum "1" {
              tailf:info "Redistribute external type 1 routes";
            }
            enum "2" {
              tailf:info "Redistribute external type 2 routes";
            }
          }
        }
        leaf nssa-external {
          tailf:info "Redistribute OSPF NSSA external routes";
          when "../match";
          type empty;
        }
        leaf nssa-external-type {
          tailf:cli-drop-node-name;
          when "../nssa-external";
          type enumeration {
            enum "1" {
              tailf:info "Redistribute NSSA external type 1 routes";
            }
            enum "2" {
              tailf:info "Redistribute NSSA external type 2 routes";
            }
          }
        }
        uses router-af-redistribute-grouping;
      }

      // router bgp * / address-family * / redistribute isis *
      list isis {
        tailf:info "ISO IS-IS";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;IS-IS instance name";
          }
        }
        leaf level {
          tailf:info "Redistribute routes from the specified ISIS levels";
          tailf:cli-optional-in-sequence;
          type enumeration {
            enum "1" {
              tailf:info "Redistribute ISIS level 1 routes";
            }
            enum "1-inter-area" {
              tailf:info "Redistribute ISIS level 1 inter-area routes";
            }
            enum "2" {
              tailf:info "Redistribute ISIS level 2 ISIS routes";
            }
          }
        }
        container second-level {
          tailf:cli-drop-node-name;
          tailf:cli-flatten-container;
          tailf:cli-optional-in-sequence;
          when "../level";
          leaf level {
            tailf:info "Redistribute routes from the specified ISIS levels";
            type enumeration {
              enum "1" {
                tailf:info "Redistribute ISIS level 1 routes";
              }
              enum "1-inter-area" {
                tailf:info "Redistribute ISIS level 1 inter-area routes";
              }
              enum "2" {
                tailf:info "Redistribute ISIS level 2 ISIS routes";
              }
            }
          }
        }
        container third-level {
          tailf:cli-drop-node-name;
          tailf:cli-flatten-container;
          tailf:cli-optional-in-sequence;
          when "../second-level/level";
          leaf level {
            tailf:info "Redistribute routes from the specified ISIS levels";
            type enumeration {
              enum "1" {
                tailf:info "Redistribute ISIS level 1 routes";
              }
              enum "1-inter-area" {
                tailf:info "Redistribute ISIS level 1 inter-area routes";
              }
              enum "2" {
                tailf:info "Redistribute ISIS level 2 ISIS routes";
              }
            }
          }
        }
        uses router-af-redistribute-grouping {
          refine metric {
            tailf:cli-optional-in-sequence;
          }
        }
      }

      // router bgp * / address-family * / redistribute eigrp *
      list eigrp {
        tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;EIGRP instance name";
          }
        }
        leaf match {
          tailf:info "EIGRP route type for redistribution";
          type empty;
        }
        leaf internal {
          tailf:info "Redistribute EIGRP internal routes";
          when "../match";
          type empty;
        }
        leaf external {
          tailf:info "Redistribute EIGRP external routes";
          when "../match";
          type empty;
        }
        uses router-af-redistribute-grouping;
      }
    }

    // router bgp * / address-family * / allocate-label
    container allocate-label {
      tailf:info "Allocate label for selected prefixes";
      choice allocate-label-choice {
        leaf all {
          tailf:info "Allocate labels for all prefixes";
          type empty;
        }
        leaf route-policy {
          tailf:info "Use a route policy to select prefixes for label allocation";
          tailf:cli-suppress-leafref-in-diff;
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:route-policy/name";
          }
          type string {
            tailf:info "WORD;;Name of the policy";
          }
        }
      }
    }

    // router bgp * / address-family * / as-path-loopback
    container as-path-loopcheck {
      tailf:info "Configure AS Path loop checking";
      leaf out {
        type enumeration {
          enum "disable";
        }
      }
    }

    // router bgp * / address-family * / dynamic-med interval
    container dynamic-med {
      tailf:info "Dynamic MED Interval";
      leaf interval {
        tailf:info "Update generation delay (in minutes) after a MED change";
        type uint8 {
          tailf:info "<0-10>;;Update generation delay in minutes";
          range "0..10";
        }
      }
    }

    // router bgp * / address-family * / global-table-multicast
    leaf global-table-multicast {
      tailf:info "Enable global table multicast";
      type empty;
    }

    // router bgp * / address-family * / vrf all
    container vrf {
      tailf:info "Specify configurations to be inherited to all vrfs";
      container all {
        tailf:info "Specify configurations to be inherited to all vrfs";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-bgp-af-vrfall";
        presence true;

        // router bgp * / address-family * / vrf all / label mode
        container label {
          tailf:info "Label-related configuration";
          container mode {
            tailf:info "Select label mode";
            choice mode-choice {
              leaf per-ce  {
                tailf:info "Set per CE label mode";
                type empty;
              }
              leaf per-prefix {
                tailf:info "Set per perfix label mode";
                type empty;
              }
              leaf per-vrf {
                tailf:info "Set per VRF label mode";
                type empty;
              }
              leaf route-policy {
                tailf:info "Use a route policy to select prefixes for label allocation mode";
                type string {
                  tailf:info "WORD;;Name of the policy";
                }
              }
            }
          }
        }

        // router bgp * / address-family * / vrf all / source rt import-policy
        container source {
          tailf:info "Source import route-targets from import-policy";
          container rt {
            tailf:info "Source import route-targets from import-policy";
            leaf import-policy {
              tailf:info "Source import route-targets from import-policy";
              type empty;
            }
          }
        }
      }
    }

    // router bgp * / address-family * / segment-routing
    container segment-routing {
      tailf:info "Specify Segment-routing configurations";

      // router bgp * / address-family * / segment-routing prefix-sid-map
      leaf prefix-sid-map {
        tailf:info "Retrieve prefix id mapping from SRMS";
        type empty;
      }

      // router bgp * / address-family * / segment-routing srv6
      container srv6 {
        tailf:info "Specify SRv6 configurations";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-bgp-af-srv6";
        presence true;

        // router bgp * / address-family * / segment-routing srv6 / locator
        leaf locator {
          tailf:info "Specify locator";
          tailf:cli-suppress-leafref-in-diff;
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:segment-routing/srv6/locators/locator/name";
          }
          type string {
            tailf:info "WORD;;locator name";
          }
        }

        // router bgp * / address-family * / segment-routing srv6 / alloc mode
        container alloc {
          tailf:info "SID Allocation";
          leaf mode {
            tailf:info "SID Allocation mode";
            type enumeration {
              enum per-ce {
                tailf:info "Set per CE label mode";
              }
              enum per-vrf {
                tailf:info "Set per VRF label mode";
              }
            }
          }
        }
      }
    }
  }

  // bgp-address-family-ipv4-grouping
  grouping bgp-address-family-ipv4-grouping {
    uses bgp-address-family-pre-grouping;

    // router bgp * / address-family * / network *
    list network {
      tailf:info "Specify a network to announce via BGP";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key net;
      leaf net {
        type ipv4-prefix {
          tailf:info "A.B.C.D/length;;IPv4 network and mask or masklength";
        }
      }
      leaf backdoor {
        tailf:info "Specify a BGP backdoor route";
        type empty;
      }
      leaf route-policy {
        tailf:info "Route-policy to modify the attributes";
        tailf:cli-suppress-leafref-in-diff;
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:route-policy/name";
        }
        type string {
          tailf:info "WORD;;Name of the policy";
        }
      }
    }

    uses bgp-address-family-post-grouping;
  }

  // bgp-address-family-ipv6-grouping
  grouping bgp-address-family-ipv6-grouping {
    uses bgp-address-family-pre-grouping;

    // router bgp * / address-family * / network *
    list network {
      tailf:info "Specify a network to announce via BGP";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key net;
      leaf net {
        type tailf:ipv6-address-and-prefix-length {
          tailf:info "X:X::X/length;;IPv6 network and mask or masklength";
        }
      }
      leaf backdoor {
        tailf:info "Specify a BGP backdoor route";
        type empty;
      }
      leaf route-policy {
        tailf:info "Route-policy to modify the attributes";
        tailf:cli-suppress-leafref-in-diff;
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:route-policy/name";
        }
        type string {
          tailf:info "WORD;;Name of the policy";
        }
      }
    }

    uses bgp-address-family-post-grouping;
  }

  // router bgp * / address-family * /
  grouping bgp-address-family-grouping {

    // router bgp * / address-family * / optimal-route-reflection *
    list optimal-route-reflection {
      tailf:info "Configure optimal-route-reflection group";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-incomplete-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;ORR group name - maximum 32 characters";
        }
      }
      leaf primary {
        tailf:cli-drop-node-name;
        type union {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IPv4 primary address";
          }
          type inet:ipv6-address {
            tailf:info "X:X::X;;IPv6 primary address";
          }
        }
      }
      leaf secondary {
        tailf:cli-drop-node-name;
        type union {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IPv4 secondary address";
          }
          type inet:ipv6-address {
            tailf:info "X:X::X;;IPv6 secondary address";
          }
        }
      }
      leaf tertiary {
        tailf:cli-drop-node-name;
        type union {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IPv4 tertiary address";
          }
          type inet:ipv6-address {
            tailf:info "X:X::X;;IPv6 tertiary address";
          }
        }
      }
    }
  }


  // router bgp * / neighbor * / address-family * /
  // router bgp * / af-group * /
  grouping router-bgp-neighbor-af-grouping {

    // router bgp * / neighbor * / address-family * / multipath
    leaf multipath {
      tailf:info "Paths from this neighbor is eligible for multipath";
      tailf:cli-full-command;
      type empty;
    }

    // router bgp * / neighbor * / address-family * / route-policy * in|out
    uses route-policy-list-grouping;

    // router bgp * / neighbor * / address-family * / encapsulation-type
    leaf encapsulation-type {
      tailf:info "Specify encapsulation type";
      tailf:cli-full-command;
      type enumeration {
        enum mpls {
          tailf:info "MPLS encapsulation";
        }
        enum vxlan {
          tailf:info "VxLAN encapsulation";
        }
      }
    }

    // router bgp * / neighbor * / address-family * / remove-private-AS
    container remove-private-AS {
      tailf:info "Remove private AS number from outbound updates";
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      presence true;
      choice remove-choice {
        leaf entire-aspath {
          tailf:info "remove only if all ASes in the path are private";
          type empty;
        }
        leaf inheritance-disable {
          tailf:info "Prevent remove-private-AS from being inherited from the parent";
          type empty;
        }
      }
    }

    // router bgp * / neighbor * / address-family * / remove-private-AS inbound
    container remove-private-AS-inbound {
      tailf:cli-drop-node-name;
      container remove-private-AS {
        tailf:info "Remove private AS number from outbound updates";
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        container inbound {
          tailf:info "Remove private AS number from inbound updates";
          tailf:cli-delete-when-empty;
          presence true;
          choice remove-choice {
            leaf entire-aspath {
              tailf:info "remove only if all ASes in the path are private";
              type empty;
            }
            leaf inheritance-disable {
              tailf:info "Prevent remove-private-AS from being inherited from the parent";
              type empty;
            }
          }
        }
      }
    }

    // router bgp * / neighbor * / address-family * / soft-reconfiguration inbound
    container soft-reconfiguration {
      tailf:info "Per neighbor soft reconfiguration";
      container inbound {
        tailf:info "Allow inbound soft reconfiguration for this neighbor";
        tailf:cli-compact-syntax;
        presence true;
        leaf type {
          tailf:cli-drop-node-name;
          type enumeration {
            enum always {
              tailf:info "Always use soft reconfig, even if route refresh is supported";
            }
            enum inheritance-disable {
              tailf:info "Prevent soft-reconfiguration from being inherited from the parent";
            }
          }
        }
      }
    }

    // router bgp * / address-family * / allowas-in
    container allowas-in {
      tailf:info "Allow as-path with my AS present in it";
      leaf as-occurrence-number {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-10>;;Number of occurences of AS number";
          range "1..10";
        }
      }
    }

    // router bgp * / neighbor * / address-family * / site-of-origin
    leaf site-of-origin {
      tailf:info "Site-of-Origin extended community associated with the neighbor";
      type string {
        tailf:info "WORD;;AS number or IPV4 address:index";
      }
    }

    // router bgp * / neighbor * / address-family * / import
    container import {
      tailf:info "Import options for neighbor address-family routes";
      choice import-choice {

        // router bgp * / neighbor * / address-family * / import stitching-rt
        container stitching-rt {
          tailf:info "Import routes using stitching RTs";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-delete-when-empty;
          presence true;
          choice re-originate-choice {
            leaf re-originate {
              tailf:info "Reoriginate imported routes";
              type empty;
            }
            // Note: Different version of ASR9k wherein the leaf does not have hyphen
            leaf reoriginate {
              tailf:info "Reoriginate imported routes, version 5.3.x";
              type empty;
            }
          }
          leaf stitching-rt {
            tailf:info "Reoriginate imported routes by attaching stitching RTs";
            type empty;
          }
        }

        // router bgp * / neighbor * / address-family * / import re-originate
        container re-originate {
          tailf:info "Re-originate imported routes";
          tailf:cli-delete-when-empty;
          presence true;
          leaf stitching-rt {
            tailf:info "Reoriginate imported routes by attaching stitching RTs";
            type empty;
          }
        }
      }
    }

    // router bgp * / neighbor * / address-family * / accept-own
    container accept-own {
      tailf:info "Handle self-originated routes with Accept-Own community";
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      presence true;
      leaf inheritance-disable {
        tailf:info "Prevent item being inherited from a parent group";
        type empty;
      }
    }

    // router bgp * / neighbor * / address-family * / as-override
    container as-override {
      tailf:info "Override matching AS-number while sending update";
      tailf:cli-compact-syntax;
      tailf:cli-delete-when-empty;
      presence true;
      leaf inheritance-disable {
        tailf:info "Prevent as-override from being inherited from the parent";
        type empty;
      }
    }

    // router bgp * / neighbor * / address-family * / maximum-prefix
    container maximum-prefix {
      tailf:info "Maximum number of prefixes to accept from this peer";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-reset-container;
      leaf max-prefix-limit {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<1-4294967295>;;maximum no. of prefix limit";
          range "1..4294967295";
        }
      }
      leaf threshold {
        tailf:cli-drop-node-name;
        tailf:cli-break-sequence-commands;
        type uint8 {
          tailf:info "<1-100>;;Threshold value (%) at which to generate a warning msg";
          range "1..100";
        }
      }
      leaf restart {
        tailf:info "Restart time interval";
        type uint16 {
          tailf:info "<1-65535>;;Time interval (min) after which peering session will be reestablished";
          range "1..65535";
        }
      }
      leaf warning-only {
        tailf:info "Only give warning message when limit is exceeded";
        tailf:cli-full-command;
        type empty;
      }
      leaf discard-extra-paths {
        tailf:info "Discard extra paths when limit is exceeded";
        tailf:cli-full-command;
        type empty;
      }
    }

    // router bgp * / neighbor * / address-family * / next-hop-self
    container next-hop-self {
      tailf:info "Disable the next hop calculation for this neighbor";
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      presence true;
      leaf inheritance-disable {
        tailf:info "Prevent next-hop-self from being inherited from the parent";
        type empty;
      }
    }

    // router bgp * / neighbor * / address-family * / next-hop-unchanged
    container next-hop-unchanged {
      tailf:info "Do not overwrite next hop before advertising to eBGP peers";
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      presence true;
      leaf inheritance-disable {
        tailf:info "Prevent next-hop-unchanged from being inherited from the parent";
        type empty;
      }
    }

    // router bgp * / neighbor * / address-family * / next-hop-unchanged multipath
    container next-hop-unchanged-multipath {
      tailf:cli-drop-node-name;
      container next-hop-unchanged {
        tailf:info "Do not overwrite next hop before advertising to eBGP peers";
        leaf multipath {
          tailf:info "Do not overwrite nexthop before advertising multipaths";
          type empty;
        }
      }
    }

    // router bgp * / neighbor * / address-family * / route-reflector-client
    leaf route-reflector-client {
      tailf:info "Configure a neighbor as Route Reflector client";
      type empty;
    }

    // router bgp * / neighbor * / address-family * / default-originate
    container default-originate {
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      presence true;
      choice default-originate-choice {
        // router bgp * / neighbor * / address-family * / default-originate route-policy
        leaf route-policy {
          tailf:info "Route policy to specify criteria to originate default";
          type string {
            tailf:info "WORD;;Name of the policy";
          }
        }
        // router bgp * / neighbor * / address-family * / default-originate inheritance-disable
        leaf inheritance-disable {
          tailf:info "Prevent default-originate being inherited from a parent group";
          type empty;
        }
      }
    }

    // router bgp * / neighbor * / address-family * / send-community-ebgp
    container send-community-ebgp {
      tailf:info "Send community attribute to this external neighbor";
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      presence true;
      leaf inheritance-disable {
        tailf:info "Prevent send-community-ebgp from being inherited from the parent";
        type empty;
      }
    }

    // router bgp * / neighbor * / address-family * / send-extended-community-ebgp
    container send-extended-community-ebgp {
      tailf:info "Send extended community attribute to this external neighbor";
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      presence true;
      leaf inheritance-disable {
        tailf:info "Prevent send-extended-community-ebgp from being inherited from the parent";
        type empty;
      }
    }

    // router bgp * / neighbor * / address-family * / send-community-gshut-ebgp
    container send-community-gshut-ebgp  {
      tailf:info "Allow the g-shut community to be sent to this external neighbor";
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      presence true;
      leaf inheritance-disable {
        tailf:info "Prevent send-community-gshut-ebgp from being inherited from the parent";
        type empty;
      }
    }

    // router bgp * / neighbor * / address-family * / orf route-policy
    container orf {
      tailf:info "Specify ORF and inbound filering criteria";
      leaf route-policy {
        tailf:info "Route policy to specify ORF and inbound filter";
        type string {
          tailf:info "WORD;;Name of the policy";
        }
      }
    }

    // router bgp * / neighbor * / address-family * / use af-group
    container use {
      tailf:info "Inherit configuration from a group";
      leaf af-group {
        tailf:info "Inherit configuration for this address-family from an af-group";
        tailf:cli-full-command;
        type string;
      }
    }

    // router bgp * / neighbor * / address-family * / capability
    container capability {
      tailf:info "Advertise capability to the peer";
      container orf {
        tailf:info "Advertise ORF capability to the peer";
        leaf prefix {
          tailf:info "Advertise address prefix ORF capability to this neighbor";
          type enumeration {
            enum both {
              tailf:info "Capability to RECEIVE and SEND the ORF from/to this neighbor";
            }
            enum none {
              tailf:info "No capability to RECEIVE or SEND the ORF from/to this neighbor";
            }
            enum receive {
              tailf:info "Capability to RECEIVE the ORF from this neighbor";
            }
            enum send {
              tailf:info "Capability to SEND the ORF to this neighbor";
            }
          }
        }
      }
    }

    // router bgp * / neighbor * / address-family * / Signalling
    container Signalling {
      tailf:info "Signalling protocols to disable, BGP or LDP";
      choice signalling-choice {
        container bgp {
          tailf:info "Select BGP to disable";
          leaf disable {
            tailf:info "Disable Signalling type";
            type empty;
          }
        }
        container ldp {
          tailf:info "Select LDP to disable";
          leaf disable {
            tailf:info "Disable Signalling type";
            type empty;
          }
        }
      }
    }

    // router bgp * / neighbor * / address-family * / aigp
    choice agp-choice {
      container aigp-enable {
        tailf:cli-drop-node-name;
        leaf aigp {
          tailf:info "Enable AIGP for this neighbor";
          tailf:cli-full-command;
          type empty;
        }
      }
      // router bgp * / neighbor * / address-family * / aigp disable
      container aigp-disable {
        tailf:cli-drop-node-name;
        container aigp {
          tailf:info "Enable AIGP for this neighbor";
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          leaf disable {
            tailf:info "Disable AIGP";
            type empty;
          }
        }
      }
    }

    // router bgp * / neighbor * / address-family * / aigp send
    container aigp {
      tailf:info "Enable AIGP for this neighbor";
      tailf:cli-incomplete-command;
      tailf:cli-incomplete-no;
      container send {
        tailf:info "Copy AIGP";

        // router bgp * / neighbor * / address-family * / aigp send cost-community
        container cost-community {
          tailf:info "Send AIGP value in Cost Community";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          choice cc-choice {
            // router bgp * / neighbor * / address-family * / aigp send cost-community disable
            leaf disable {
              tailf:info "Disable aigp send cost-community";
              type empty;
            }
            // router bgp * / neighbor * / address-family * / aigp send cost-community <id>
            case id-case {
              leaf id {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type uint8 {
                  tailf:info "<0-255>;;Cost community ID";
                }
              }
              leaf poi {
                tailf:info "Point of insertion for bestpath calculation";
                type enumeration {
                  enum igp-cost {
                    tailf:info "Cost community is used after IGP distance to next hop";
                  }
                  enum pre-bestpath {
                    tailf:info "Cost community is first step in best path calculation";
                  }
                }
              }
              leaf transitive {
                tailf:info "Enable transitive cost community";
                type empty;
              }
            }
          }
        }

        // router bgp * / neighbor * / address-family * / aigp send med
        container med {
          tailf:info "Send AIGP value in MED";
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          presence true;
          leaf disable {
            tailf:info "Disable aigp send med";
            type empty;
          }
        }
      }
    }

    // router bgp * / neighbor * / address-family * / optimal-route-reflection
    leaf optimal-route-reflection {
      tailf:info "Configure optiomal-route-reflection for this neighbor";
      type string {
        tailf:info "WORD;;ORR group name - maximum 32 characters";
      }
    }
  }


  // router bgp * / neighbor *
  // router bgp * / neighbor-group *
  grouping bgp-neighbor-grouping {

    // router bgp * / neighbor * / remote-as
    leaf remote-as {
      tailf:info "Specify a BGP neighbor";
      type union {
        type uint32 {
          tailf:info "<1-4294967295>;;AS of remote neighbor";
          range "1..4294967295";
        }
        type string {
          tailf:info "<1.0-XX.YY>;;AS of remote neighbor";
          pattern '[0-9]+\.[0-9]+';
        }
      }
    }

    // router bgp * / neighbor * / local address
    container local {
      tailf:info "Configure local parameter";
      container address {
        tailf:info "use configured local address for bgp peering";
        leaf ip {
          tailf:cli-drop-node-name;
          type inet:host {
            tailf:info "A.B.C.D or X:X::X;;address";
          }
        }
      }
    }

    // router bgp * / neighbor * / local-as
    container local-as {
      tailf:info "Specify local AS number";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      choice local-as-choice {
        leaf inheritance-disable {
          tailf:info "Prevent local AS from being inherited from parent";
          type empty;
        }
        case as-number-case {
          leaf as-number {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;AS number in 2-byte, 4-byte asdot and asplain";
            }
          }
          leaf no-prepend {
            tailf:info "Do not prepend local AS to announcements from this neighbor";
            type empty;
          }
          leaf replace-as {
            tailf:info "Prepend only local AS to announcements to this neighbor";
            type empty;
          }
          leaf dual-as {
            tailf:info "Dual-AS mode";
            type empty;
          }
        }
      }
    }

    // router bgp * / neighbor * / bfd
    uses bfd-common-parameters-grouping;

    // router bgp * / neighbor * / ao
    uses bgp-common-group-grouping;

    // router bgp * / neighbor * / ebgp-multihop
    container ebgp-multihop {
      tailf:info "Allow EBGP neighbors not on directly connected networks";
      tailf:cli-compact-syntax;
      leaf ttl-value {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-255>;;maximum hop count";
          range "1..255";
        }
      }
      leaf mpls {
        tailf:info "Disable BGP MPLS forwarding";
        type empty;
      }
    }

    // router bgp * / neighbor * / egress-engineering
    container egress-engineering {
      tailf:info "Enable egress peer engineering for this neighbor";
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      presence true;
      leaf inheritance-disable {
        tailf:info "Do not inherit egress-engineering from the parent";
        type empty;
      }
    }

    // router bgp * / neighbor * / enforce-first-as
    container enforce-first-as {
      tailf:info "Enforce the first AS for EBGP routes";
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      presence true;
      leaf disable {
        tailf:info "Do not enforce the first AS for EBGP routes";
        type empty;
      }
    }

    // router bgp * / neighbor * / precedence
    // router bgp * / neighbor * / dscp
    choice precedence-choice {
      leaf precedence {
        tailf:info "Set precedence";
        type precedence-type;
      }
      leaf dscp {
        tailf:info "Set IP DSCP (DiffServ CodePoint)";
        type dscp-type;
      }
    }

    // router bgp * / neighbor * / advertisement-interval
    container advertisement-interval {
      tailf:info "Minimum interval between sending BGP routing updates";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf seconds {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<0-600>;;time in seconds";
          range "0..600";
        }
      }
      leaf milliseconds {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<0-999>;;time in milliseconds";
          range "0..999";
        }
      }
    }

    // router bgp * / neighbor * / bmp-activate server *
    container bmp-activate {
      tailf:info "Enable BMP logging for this neighbor";
      list server {
        tailf:info "Enable BMP connection to particular server";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key id;
        leaf id {
          type uint8 {
            tailf:info "<1-8>;;Enable BMP connection to particular server";
            range "1..8";
          }
        }
      }
    }

    // router bgp * / neighbor * / timers
    container timers {
      tailf:info "BGP per neighbor timers";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf keepalive {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint16 {
          tailf:info "<0-65535>;;Keepalive interval";
        }
      }
      leaf holdtime {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<0|3-65535>;;Holdtime (0=disable)";
        }
      }
      leaf min-holdtime {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<3-65535>;;Minimum acceptable holdtime from neighbor";
        }
      }
    }

    // router bgp * / neighbor * / tcp mss
    container tcp {
      tailf:info "TCP session configuration commands";
      leaf mss {
        tailf:info "Maximum Segment Size";
        type union {
          type uint16 {
            tailf:info "<68-10000>;;TCP initial maximum segment size";
          }
          type enumeration {
            enum inheritance-disable {
              tailf:info "Prevent tcp mss from being inherited from the parent";
            }
          }
        }
      }
    }

    // router bgp * / neighbor * / description
    leaf description {
      tailf:info "Neighbor specific description";
      tailf:cli-multi-value;
      tailf:cli-preformatted;
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;Up to 80 characters describing this neighbor";
      }
    }

    // router bgp * / neighbor * / dmz-link-bandwidth
    container dmz-link-bandwidth {
      tailf:info "Propagate the DMZ link bandwidth";
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      presence true;
      leaf inheritance-disable {
        tailf:info "Prevent dmz-link-bandwidth from being inherited from the parent";
        type empty;
      }
    }

    // router bgp * / neighbor * / password
    container password {
      tailf:info "Set a password";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf enc-type {
        tailf:cli-drop-node-name;
        type enumeration {
          enum clear {
            tailf:info "Specifies an UNENCRYPTED password will follow";
          }
          enum encrypted {
            tailf:info "Specifies an ENCRYPTED password will follow";
          }
          enum inheritance-disable {
            tailf:info "Prevent password from being inherited from parent";
          }
        }
      }
      leaf password {
        tailf:cli-drop-node-name;
        tailf:cli-multi-value;
        cli:secret;
        type NEDCOM_SECRET_TYPE {
          tailf:info "LINE;;The password";
        }
      }
    }

    // router bgp * / neighbor * / ttl-security
    container ttl-security {
      tailf:info "Enable EBGP TTL security";
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      presence true;
      leaf inheritance-disable {
        tailf:info "Prevent ttl-security from being inherited from the parent";
        type empty;
      }
    }

    // router bgp * / neighbor * / update in filtering
    container update {
      tailf:info "BGP Update configuration";
      container in {
        tailf:info "Inbound update message handling";
        container filtering {
          tailf:info "Inbound update message filtering";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-vrf-nbr-upd-filter";
          presence true;

          // router bgp * / neighbor * / update in filtering / attribute-filter
          container attribute-filter {
            tailf:info "Attribute-filter configuration";
            leaf group {
              tailf:info "Attribute-filter group configuration";
              type string {
                tailf:info "WORD;;Attribute-filter group name";
              }
            }
          }

          // router bgp * / neighbor * / update in filtering / message
          container message {
            tailf:info "Filtered update messages";
            leaf buffers {
              tailf:info "Filtered update message buffers";
              type uint8 {
                tailf:info "<0-25>;;Number of buffers to store filtered update messages (resizing does not take effect after filtering action has started)";
              }
            }
          }
        }
      }
    }

    // router bgp * / neighbor * / update-source
    container update-source {
      tailf:info "Source of routing updates";
      uses interface-name-grouping;
    }

    // router bgp * / neighbor * /  ignore-connected-check
    container ignore-connected-check {
      tailf:info "Ignore check for directly connected peer";
      presence true;
    }

    // router bgp * / neighbor * / cluster-id
    leaf cluster-id {
      tailf:info "Enter cluster id for this neighbor";
      tailf:cli-full-command;
      type union {
        type uint32 {
          tailf:info "<1-4294967295>;;Route-Reflector Cluster-id as 32 bit quantity";
        }
        type inet:host {
          tailf:info "A.B.C.D;;Route-Reflector Cluster-id in IP address format";
        }
      }
    }

    // router bgp * / neighbor * / graceful-maintenance
    container graceful-maintenance {
      tailf:info "Announce routes with the g-shut community and other attributes as configured under the neighbors.";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-nbr-gshut";
      presence true;

      // router bgp * / neighbor * / graceful-maintenance / local-preference
      leaf local-preference {
        tailf:info "local preference with which to advertise routes to ibgp neigbors";
        type union {
          type uint32 {
            tailf:info "<0-4294967295>;;Range of values for Local Preference";
          }
          type enumeration {
            enum inheritance-disable {
              tailf:info "Prevent local preference from being inherited from the parent";
            }
          }
        }
      }

      // router bgp * / neighbor * / graceful-maintenance / as-prepends
      leaf as-prepends {
        tailf:info "Number of times to prepend the local AS number to the AS path of routes. Default=0";
        type union {
          type uint8 {
            tailf:info "<0-6>;;Range of number of AS prepends";
            range "0..6";
          }
          type enumeration {
            enum inheritance-disable {
              tailf:info "Prevent AS prepends from being inherited from the parent";
            }
          }
        }
      }

      // router bgp * / neighbor * / graceful-maintenance / activate
      container activate {
        tailf:info "Routes will be announced with the graceful maintenance attributes";
        tailf:cli-delete-when-empty;
        tailf:cli-reset-container;
        presence true;

        // router bgp * / neighbor * / graceful-maintenance / activate inheritance-disable
        leaf inheritance-disable {
          tailf:info "Prevent activate from being inherited from the parent";
          type empty;
        }
      }
    }

    // router bgp * / neighbor * / graceful-restart
    container graceful-restart {
      tailf:info "Enable graceful restart support for this neighbor";
      presence true;
      leaf suppress {
        tailf:cli-reset-container;
        tailf:cli-full-command;
        type empty;
      }
      leaf disable {
        tailf:info "Disable graceful restart support for this neighbor";
        tailf:cli-reset-container;
        tailf:cli-full-command;
        type empty;
      }
      leaf restart-time {
        tailf:info "Restart time advertised to the neighbor";
        type uint16 {
          tailf:info "<1-4095>;;Max time (seconds)";
        }
      }
      leaf stalepath-time {
        tailf:info "Maximum time to wait for restart of GR capable peer";
        type uint16 {
          tailf:info "<1-4095>;;Max time (seconds)";
        }
      }
    }

    // router bgp * / neighbor * / capability
    container capability {
      tailf:info "Advertise capability to the peer";

      // router bgp * / neighbor * / capability additional-paths
      container additional-paths {
        tailf:info "Additional paths capability";

        // router bgp * / neighbor * / capability additional-paths receive
        container receive {
          tailf:info "Additional paths Receive capability";
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          presence true;
          leaf disable {
            tailf:info "Do not advertise additional paths Receive capability";
            type empty;
          }
        }

        // router bgp * / neighbor * / capability additional-paths send
        container send {
          tailf:info "Additional paths Send capability";
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          presence true;
          leaf disable {
            tailf:info "Do not advertise additional paths Send capability";
            type empty;
          }
        }
      }

      // router bgp * / neighbor * / capability suppress
      container suppress {
        tailf:info "Suppress advertising capability to the peer";

        // router bgp * / neighbor * / capability suppress all
        container all {
          tailf:info "All capabilities";
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          presence true;
          leaf inheritance-disable {
            tailf:info "Do not inherit this configuration from parent group";
            type empty;
          }
        }

        // router bgp * / neighbor * / capability suppress 4-byte-as
        container four-byte-as {
          tailf:alt-name "4-byte-as";
          tailf:info "4-byte-as capability";
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          presence true;
          leaf inheritance-disable {
            tailf:info "Prevent capability suppress 4-type-as being inherited from the parent";
            type empty;
          }
        }
      }
    }

    // router bgp * / neighbor * / log message *
    container log {
      tailf:info "Logging update messages per neighbor";
      list message {
        tailf:info "Logging update/notification messages per neighbor";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key direction;
        leaf direction {
          type enumeration {
            enum in {
                     tailf:info "Inbound log messages";
            }
            enum out {
                      tailf:info "Outbound log messages";
            }
          }
        }
        choice logging-choice {
          leaf range {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-100>;;Range for message log buffer size";
              range "1..100";
            }
          }
          leaf disable {
            tailf:info "Disable inbound message logging";
            type empty;
          }
          leaf inheritance-diable {
            tailf:info "Prevents the msg log from being inherited from the parent";
            type empty;
          }
        }
      }
    }

    // router bgp * / neighbor * / internal-vpn-client
    leaf internal-vpn-client {
      tailf:info "Preserve iBGP CE neighbor path in ATTR_SET across VPN core";
      type empty;
    }

    // router bgp * / neighbor * / local-address-subnet
    leaf local-address-subnet {
      tailf:info "Local address subnet of routing updates";
      type union {
        type ipv4-prefix {
          tailf:info "A.B.C.D/length;;IPv4 address and mask or masklength";
        }
        type tailf:ipv6-address-and-prefix-length {
          tailf:info "X:X::X/length;;IPv6 address and mask or masklength";
        }
      }
    }

    // router bgp * / neighbor * / send-buffer-size
    container send-buffer-size {
      tailf:info "Set socket and BGP send buffer size";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf socket-size {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<4096-131072>;;Send socket buffer size in bytes";
          range "4096..131072";
        }
      }
      leaf bgp-size {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<4096-131072>;;BGP Write buffer size in bytes";
          range "4096..131072";
        }
      }
    }

    // router bgp * / neighbor * / receive-buffer-size
    container receive-buffer-size {
      tailf:info "Set socket and BGP receive buffer size";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf socket-size {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<512-131072>;;Receive socket buffer size in bytes";
          range "512..131072";
        }
      }
      leaf bgp-size {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<512-131072>;;BGP Read buffer size in bytes";
          range "512..131072";
        }
      }
    }

    // router bgp * / neighbor * / address-family
    container address-family {
      tailf:info "Enter Address Family command mode";

      // router bgp * / neighbor * / address-family ipv4
      container ipv4 {
        tailf:info "IPv4 Address Family";

        // router bgp * / neighbor * / address-family ipv4 unicast
        container unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-nbr-af";
          presence true;
          uses bgp-address-family-ipv4-grouping;
          uses router-bgp-neighbor-af-grouping;
        }

        // router bgp * / neighbor * / address-family ipv4 multicast
        container multicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-nbr-af";
          presence true;
          uses bgp-address-family-ipv4-grouping;
          uses router-bgp-neighbor-af-grouping;
        }

        // router bgp * / neighbor * / address-family ipv4 labeled-unicast
        container labeled-unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-nbr-af";
          presence true;
          uses bgp-address-family-ipv4-grouping;
          uses router-bgp-neighbor-af-grouping;
        }

        // router bgp * / neighbor * / address-family ipv4 mdt
        container mdt {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-nbr-af";
          presence true;
          uses bgp-address-family-ipv4-grouping;
          uses router-bgp-neighbor-af-grouping;
        }

        // router bgp * / neighbor * / address-family ipv4 rt-filter
        container rt-filter {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-nbr-af";
          presence true;
          uses bgp-address-family-ipv4-grouping;
          uses router-bgp-neighbor-af-grouping;
        }

        // router bgp * / neighbor * / address-family ipv4 flowspec
        container flowspec {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-nbr-af";
          presence true;
          // router bgp * / neighbor * / address-family ipv4 flowspec / validation
          container validation {
            tailf:info "Flowspec Validation for this neighbor";
            tailf:cli-reset-container;
            tailf:cli-delete-when-empty;
            presence true;
            choice validation-choice {
              leaf disable {
                tailf:info "Disable Flowspec Validation";
                type empty;
              }
              container redirect {
                tailf:info "Flowspec Redirect nexthop Validation";
                leaf disable {
                  tailf:info "Disable Flowspec Redirect nexthop Validation";
                  type empty;
                }
              }
            }
          }
          uses bgp-address-family-ipv4-grouping;
          uses router-bgp-neighbor-af-grouping;
        }

        // router bgp * / neighbor * / address-family ipv4 mvpn
        container mvpn {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-nbr-af";
          presence true;
          uses bgp-address-family-ipv4-grouping;
          uses router-bgp-neighbor-af-grouping;
        }

        // router bgp * / neighbor * / address-family ipv4 sr-policy
        container sr-policy {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-nbr-af";
          presence true;
          uses bgp-address-family-ipv4-grouping;
          uses router-bgp-neighbor-af-grouping;
        }
      }

      // router bgp * / neighbor * / address-family l2vpn
      container l2vpn {
        tailf:info "L2VPN Address Family";

        // router bgp * / neighbor * / address-family l2vpn vpls-vpws
        container vpls-vpws {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence true;
          uses bgp-address-family-ipv4-grouping;
          uses router-bgp-neighbor-af-grouping;
        }

        // router bgp * / neighbor * / address-family l2vpn evpn
        container evpn {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence true;
          uses bgp-address-family-ipv4-grouping;
          uses router-bgp-neighbor-af-grouping;
        }

        // router bgp * / neighbor * / address-family l2vpn mspw
        container mspw {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence true;
          uses bgp-address-family-ipv4-grouping;
          uses router-bgp-neighbor-af-grouping;
        }
      }

      // router bgp * / neighbor * / address-family vpnv4
      container vpnv4 {
        tailf:info "VPNv4 Address Family";

        // router bgp * / neighbor * / address-family vpnv4 unicast
        container unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-nbr-af";
          presence true;
          uses bgp-address-family-ipv4-grouping;
          uses router-bgp-neighbor-af-grouping;
        }

        // router bgp * / neighbor * / address-family vpnv4 multicast
        container multicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-nbr-af";
          presence true;
          uses bgp-address-family-ipv4-grouping;
          uses router-bgp-neighbor-af-grouping;
        }

        // router bgp * / neighbor * / address-family vpnv4 flowspec
        container flowspec {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-nbr-af";
          presence true;
          uses bgp-address-family-ipv4-grouping;
          uses router-bgp-neighbor-af-grouping;
        }
      }

      // router bgp * / neighbor * / address-family ipv6
      container ipv6 {
        tailf:info "IPv6 Address Family";

        // router bgp * / neighbor * / address-family ipv6 unicast
        container unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-nbr-af";
          presence true;
          uses bgp-address-family-ipv6-grouping;
          uses router-bgp-neighbor-af-grouping;
        }

        // router bgp * / neighbor * / address-family ipv6 multicast
        container multicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-nbr-af";
          presence true;
          uses bgp-address-family-ipv6-grouping;
          uses router-bgp-neighbor-af-grouping;
        }

        // router bgp * / neighbor * / address-family ipv6 labeled-unicast
        container labeled-unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-nbr-af";
          presence true;
          uses bgp-address-family-ipv6-grouping;
          uses router-bgp-neighbor-af-grouping;
        }

        // router bgp * / neighbor * / address-family ipv6 mvpn
        container mvpn {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-nbr-af";
          presence true;
          uses bgp-address-family-ipv6-grouping;
          uses router-bgp-neighbor-af-grouping;
        }

        // router bgp * / neighbor * / address-family ipv6 sr-policy
        container sr-policy {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-nbr-af";
          presence true;
          uses bgp-address-family-ipv6-grouping;
          uses router-bgp-neighbor-af-grouping;
        }

        // router bgp * / neighbor * / address-family ipv6 flowspec
        container flowspec {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-nbr-af";
          presence true;
          uses bgp-address-family-ipv6-grouping;
          uses router-bgp-neighbor-af-grouping;
        }
      }

      // router bgp * / neighbor * / address-family vpnv6
      container vpnv6 {
        tailf:info "IPv6 Address Family";

        // router bgp * / neighbor * / address-family vpnv6 unicast
        container unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-nbr-af";
          presence true;
          uses bgp-address-family-ipv6-grouping;
          uses router-bgp-neighbor-af-grouping;
        }

        // router bgp * / neighbor * / address-family vpnv6 multicast
        container multicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-nbr-af";
          presence true;
          uses bgp-address-family-ipv6-grouping;
          uses router-bgp-neighbor-af-grouping;
        }

        // router bgp * / neighbor * / address-family vpnv6 flowspec
        container flowspec {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-nbr-af";
          presence true;
          uses bgp-address-family-ipv6-grouping;
          uses router-bgp-neighbor-af-grouping;
        }
      }

      // router bgp * / neighbor * / address-family link-state link-state
      container link-state {
        tailf:info "Link-state Address Family";
        container link-state {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-nbr-af";
          presence true;
          uses bgp-address-family-ipv6-grouping;
          uses router-bgp-neighbor-af-grouping;
        }
      }
    }

    // router bgp * / neighbor * / keychain
    leaf keychain {
      tailf:info "Set keychain based authentication";
      tailf:cli-suppress-leafref-in-diff;
      tailf:non-strict-leafref {
        path "/cisco-ios-xr:key/chain/name";
      }
      type string {
        tailf:info "WORD;;The Key Chain name";
      }
    }

    // router bgp * / neighbor * / peer-group
    container peer-group {
      tailf:info "Configure peer-group";
      tailf:cli-compact-syntax;
      tailf:cli-delete-when-empty;
      presence true;
      leaf group-name {
        // Note: only applicable to ipv4 neighbours
        tailf:cli-drop-node-name;
        type string {
          tailf:info "WORD;;peer-group name";
        }
      }
    }

    // router bgp * / neighbor * / use
    container use {
      tailf:info "Inherit configuration from a group";

      // router bgp * / neighbor * / use af-group
      leaf af-group {
        tailf:info "Inherit configuration from an af-group";
        type string {
          tailf:info "WORD;;AF-group name";
        }
      }

      // router bgp * / neighbor * / use neighbor-group
      leaf neighbor-group {
        tailf:info "Inherit configuration from a neighbor-group";
        type string {
          tailf:info "WORD;;Neighbor-group name";
        }
      }

      // router bgp * / neighbor * / use session-group
      leaf session-group {
        tailf:info "Inherit address-family independent config from a session-group";
        type string {
          tailf:info "WORD;;Session group name";
        }
      }
    }

    // router bgp * / neighbor * / session-open-mode
    leaf session-open-mode {
      tailf:info "Establish BGP session using this TCP open mode";
      type enumeration {
        enum active-only {
          tailf:info "Active only";
        }
        enum both {
                   tailf:info "Prevent session-open-mode being inherited from the parent";
        }
        enum passive-only {
          tailf:info "Passive only";
        }
      }
    }

    // router bgp * / neighbor * / shutdown
    container shutdown {
      tailf:info "Administratively shut down this neighbor";
      presence true;
    }
  }


  // grouping router-bgp-vrf-grouping
  grouping router-bgp-vrf-grouping {

    // router bgp * / bfd
    container bfd {
      tailf:info "Configure BFD parameters";

      // router bgp * / bfd multiplier
      leaf multiplier {
        tailf:info "Detect multiplier";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<2-16>;;Detect multiplier";
          range "2..16";
        }
      }

      // router bgp * / bfd minimum-interval
      leaf minimum-interval {
        tailf:info "Hello interval";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<3-30000>;;hello interval in milli-seconds";
          range "3..30000";
        }
      }
    }

    // router bgp * / timers bgp
    container timers {
      tailf:info "Adjust routing timers";
      container bgp {
        tailf:info "BGP timers";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf keepalive {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<0-65535>;;Keepalive interval";
            range "0..65535";
          }
        }
        leaf holdtime {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<3-65535>;;Holdtime (0 Disable keepalives/hold time)";
            range "0|3..65535";
          }
        }
        leaf min-neighbor-holdtime {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<3-65535>;;Minimum acceptable holdtime from neighbor (0 to disable)";
            range "0|3..65535";
          }
        }
      }
    }

    // router bgp * / mvpn
    leaf mvpn {
      tailf:info "Connect to PIM/PIM6";
      type empty;
    }

    // router bgp * / bgp
    container bgp {
      tailf:info "BGP specific commands";

      // router bgp * / bgp router-id
      leaf router-id {
        tailf:info "Configure Router-id";
        tailf:cli-full-command;
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Manually configured router identifier";
        }
      }

      // router bgp * / bgp confederation
      container confederation {
        tailf:info "AS confederation parameters";

        // router bgp * / bgp confederation identifier
        leaf identifier {
          tailf:info "Set routing domain confederation AS";
          type string {
            tailf:info "WORD;;AS number in 2-byte, 4-byte asdot and asplain";
          }
        }

        // router bgp * / bgp confederation peers / *
        container peers {
          tailf:info "Enter peer ASs in BGP confederation mode";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-confed-peers";
          list as-number {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key id;
            leaf id {
              type string {
                tailf:info "WORD;;AS number in 2-byte, 4-byte asdot or asplain";
                pattern "[0-9]+.*";
              }
            }
          }
        }
      }

      // router bgp * / bgp cluster-id
      leaf cluster-id {
        tailf:info "Configure Route-Reflector Cluster-id";
        tailf:cli-full-command;
        type union {
          type uint32 {
            tailf:info "<1-4294967295>;;Route-Reflector Cluster-id as 32 bit quantity";
          }
          type inet:host {
            tailf:info "A.B.C.D;;Route-Reflector Cluster-id in IP address format";
          }
        }
      }

      // router bgp * / bgp scan-time
      leaf scan-time {
        tailf:info "Configure background scanner interval for generic scanner";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<5-3600>;;Scanner interval (seconds)";
          range "5..3600";
        }
      }

      // router bgp * / bgp update-delay
      container update-delay {
        tailf:info "Set the max initial delay for sending updates";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf update-delay-value {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-3600>;;Delay value (seconds)";
            range "0..3600";
          }
        }
        leaf always {
          tailf:info "Keepalive trigger bestpath is disabled and delay is enforced";
          type empty;
        }
      }

      // router bgp * / bgp redistribute-internal
      leaf redistribute-internal {
        tailf:info "Allow redistribution of iBGP into IGPs (dangerous)";
        type empty;
      }

      // router bgp * / bgp graceful-restart
      container graceful-restart {
        tailf:info "Graceful restart capability parameters";
        tailf:cli-display-separated;
        presence true;

        // router bgp * / bgp graceful-restart extended
        leaf extended {
          tailf:info "Enable Graceful-Restart Extension";
          type empty;
        }

        // router bgp * / bgp graceful-restart restart-time
        leaf restart-time {
          tailf:info "Set the max time needed to restart and come back up";
          type uint16 {
            tailf:info "<1-4095>;;Max time (seconds)";
            range "1..4095";
          }
        }

        // router bgp * / bgp graceful-restart stalepath-time
        leaf stalepath-time {
          tailf:info "Set the max time to hold onto restarting peer's stale paths";
          type uint16 {
            tailf:info "<1-3600>;;Delay value (seconds)";
            range "1..3600";
          }
        }

        // router bgp * / bgp graceful-restart purge-time
        leaf purge-time {
          tailf:info "Time before stale routes are purged.";
          type uint16 {
            tailf:info "<1-6000>;;Max time (seconds)";
            range "1..6000";
          }
        }

        // router bgp * / bgp graceful-restart graceful-reset
        leaf graceful-reset {
          tailf:info "Reset gracefully if configuration change forces a peer reset";
          type empty;
        }
      }

      // router bgp * / bgp bestpath
      container bestpath {
        tailf:info "Change default route selection criteria";

        // router bgp * / bgp bestpath compare-routerid
        leaf compare-routerid {
          tailf:info "Compare router-id for identical EBGP paths";
          tailf:cli-full-command;
          type empty;
        }

        // router bgp * / bgp bestpath cost-community ignore
        container cost-community {
          tailf:info "Cost community";
          leaf ignore {
            tailf:info "Ignore cost-community comparison";
            type empty;
          }
        }

        // router bgp * / bgp bestpath aigp ignore
        container aigp {
          tailf:info "AIGP attribute";
          leaf ignore {
            tailf:info "Ignore AIGP attribute";
            type empty;
          }
        }

        // router bgp * / bgp bestpath med
        container med {
          tailf:info "MED related";

          // router bgp * / bgp bestpath med always
          leaf always {
            tailf:info "Allow comparing MED from different neighbors";
            tailf:cli-full-command;
            type empty;
          }

          // router bgp * / bgp bestpath med confed
          leaf confed {
            tailf:info "Compare MED among confederation paths";
            tailf:cli-full-command;
            type empty;
          }

          // router bgp * / bgp bestpath med missing-as-worst
          leaf missing-as-worst {
            tailf:info "Treat missing MED as the least preferred one";
            tailf:cli-full-command;
            type empty;
          }
        }

        // router bgp * / bgp bestpath as-path
        container as-path {
          tailf:info "AS path length";

          // router bgp * / bgp bestpath as-path ignore
          leaf ignore {
            tailf:info "Ignore as-path length";
            type empty;
          }

          // router bgp * / bgp bestpath as-path multipath-relax
          leaf multipath-relax {
            tailf:info "Relax as-path check for multipath selection";
            type empty;
          }
        }

        // router bgp * / bgp bestpath origin-as
        uses bgp-bestpath-origin-as-grouping;
      }

      // router bgp * / bgp log
      container log {
        tailf:info "Log bgp info";
        container neighbor {
          tailf:info "Log neighbor state info";
          leaf changes {
            tailf:info "Log neighbor up/down and reset reason";
            type enumeration {
              enum detail {
                tailf:info "Include extra detail in change messages";
              }
              enum disable {
                tailf:info "Disable logging";
              }
            }
          }
        }
      }

      // router bgp * / bgp default
      container default {
        tailf:info "Configure default value";
        leaf local-preference {
          tailf:info "Local preference";
          type uint32 {
            tailf:info "<0-4294967295>;;Higher = more preferred";
          }
        }
      }

      // router bgp * / bgp auto-policy-soft-reset disable
      container auto-policy-soft-reset {
        tailf:info "Enable automatic soft peer reset on policy reconfiguration";
        leaf disable {
          tailf:info "Disable automatic soft peer reset on policy reconfiguration";
          type empty;
        }
      }

      // router bgp * / bgp label-delay
      container label-delay {
        tailf:info "Specify delay for batching label processing";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf seconds {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<0-10>;;Delay, seconds part";
            range "0..10";
          }
        }
        leaf milliseconds {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-999>;;Delay, milliseconds part";
            range "0..999";
          }
        }
      }

      // router bgp * / bgp import-delay
      container import-delay {
        tailf:info "Specify delay for import processing";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf seconds {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<0-10>;;Delay, seconds part";
            range "0..10";
          }
        }
        leaf milliseconds {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-999>;;Delay, milliseconds part";
            range "0..999";
          }
        }
      }

      // router bgp * / bgp fast-external-fallover disable
      container fast-external-fallover {
        tailf:info "Immediately reset session if a link to a directly connected external peer goes down";
        leaf disable {
          tailf:info "Disable";
          type empty;
        }
      }

      // router bgp * / bgp unsafe-ebgp-policy
      leaf unsafe-ebgp-policy {
        tailf:info "Make eBGP neighbors with no policy pass all routes(cisco-support)";
        type empty;
      }

      // router bgp * / bgp origin-as validation
      container origin-as {
        tailf:info "BGP origin-AS knobs";
        container validation {
          tailf:info "BGP origin-AS validation knobs";

          // router bgp * / bgp origin-as validation time
          leaf time {
            tailf:info "Time to wait between an RPKI update and a BGP table walk";
            type union {
              type uint8 {
                tailf:info "<5-60>;;Prefix validation time (in seconds)";
                range "5..60";
              }
              type enumeration {
                enum off {
                  tailf:info "No automatic prefix validation after an RPKI update";
                }
              }
            }
          }

          // router bgp * / bgp origin-as validation signal ibgp
          container signal {
            tailf:info "Signal origin-AS validity towards peers";
            leaf ibgp {
              tailf:info "Signal origin-AS validity towards iBGP peers";
              type empty;
            }
          }

          // router bgp * / bgp origin-as validation disable
          leaf disable {
            tailf:info "Disable RPKI origin-AS validation";
            type empty;
          }
        }
      }

      // router bgp * / bgp enforce-first-as
      // router bgp * / vrf * / bgp enforce-first-as
      container enforce-first-as {
        tailf:info "Enforce the first AS for EBGP routes";
        leaf disable {
          tailf:info "Do not enforce the first AS for EBGP routes";
          type empty;
        }
      }
    }

    // router bgp * / rpki
    container rpki {
      tailf:info "Configure RPKI";

      // router bgp * / rpki server *
      list server {
        tailf:info "Configure RPKI cache-servers";
        tailf:cli-mode-name "config-bgp-rpki-server";
        key name;
        leaf name {
          type inet:host {
            tailf:info "WORD;;Hostname or IP address";
          }
        }

        // router bgp * / rpki server * / shutdown
        leaf shutdown {
          tailf:info "Shutdown the RPKI cache-server";
          type empty;
        }

        // router bgp * / rpki server * / username
        leaf username {
          tailf:info "Specify a (SSH) username for the RPKI cache-server";
          type string {
            tailf:info "WORD;;RPKI cache (SSH) username";
          }
        }

        // router bgp * / rpki server * / bind-source interface
        container bind-source {
          tailf:info "Specify a bind source for RPKI cache-server";
          container interface {
            tailf:info "Specify a source interface to bind the cache-server transport";
            uses interface-name-grouping;
          }
        }

        // router bgp * / rpki server * / transport
        container transport {
          tailf:info "Specify a transport method for the RPKI cache-server";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf protocol {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type enumeration {
              enum ssh {
                tailf:info "Connect to the RPKI cache-server using SSH";
              }
              enum tcp {
                tailf:info "Connect to the RPKI cache-server using TCP (unencrypted)";
              }
            }
          }
          leaf port {
            tailf:info "Specify a port number for the RPKI cache-server transport";
            type uint16 {
              tailf:info "<1-65535>;;Specify a port number for the RPKI cache-server transport";
              range "1..65535";
            }
          }
        }

        // router bgp * / rpki server * / purge-time
        leaf purge-time {
          tailf:info "Time to wait after a cache goes down to clean up stale routes";
          type uint16 {
            tailf:info "<30-360>;;Purge time (in seconds)";
            range "30..360";
          }
        }

        // router bgp * / rpki server * / refresh-time
        leaf refresh-time {
          tailf:info "Time between sending serial-queries for the RPKI cache-server";
          type union {
            type uint16 {
              tailf:info "<15-3600>;;Refresh time (in seconds)";
            }
            type enumeration {
              enum off {
               tailf:info "Do not send serial-queries periodically";
              }
            }
          }
        }

        // router bgp * / rpki server * / response-time
        leaf response-time {
          tailf:info "Time to wait for a response from the RPKI cache-server";
          type union {
            type uint16 {
              tailf:info "<15-3600>;;Response time (in seconds)";
              range "15..3600";
            }
            type enumeration {
              enum off {
               tailf:info "Wait indefinitely for a response";
              }
            }
          }
        }
      }
    }

    // router bgp * / default-information originate
    container default-information {
      tailf:info "Control distribution of default information";
      leaf originate {
        tailf:info "Distribute a default route";
        type empty;
      }
    }

    // router bgp * / mpls activate
    container mpls {
      tailf:info "Enable mpls parameters";
      container activate {
        tailf:info "Enter mpls interfaces in BGP mpls activate mode";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-bgp-mpls";

        // router bgp * / mpls activate / interface *
        list interface {
          tailf:info "Interface to enable mpls";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Interface Name";
            }
          }
        }
      }
    }

    // router bgp * / update
    container update {
      tailf:info "BGP Update configuration";
      leaf limit {
        tailf:info "Upper bound on transient memory usage for update generation";
        type uint16 {
          tailf:info "<16-2048>;;Update limit in MegaBytes(MB); default is 512 MB";
          range "16..2048";
        }
      }
    }

    // router bgp * / ibgp policy out enforce-modifications
    container ibgp {
      tailf:info "Set options for iBGP peers";
      container policy {
        tailf:info "Set options for route-policy";
        container out {
          tailf:info "Set options for outbound policy";
          leaf enforce-modifications {
            tailf:info "Allow policy to modify all attributes";
            type empty;
          }
        }
      }
    }

    // router bgp * / segment-routing srv6
    container segment-routing {
      tailf:info "Specify Segment-routing configurations";
      container srv6 {
        tailf:info "Specify SRv6 configurations";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-bgp-gbl-srv6";
        presence true;

        // router bgp * / segment-routing srv6 / locator
        leaf locator {
          tailf:info "pecify locator";
          type string {
            tailf:info "ORD;;locator name";
          }
        }
      }
    }

    // router bgp * / address-family
    container address-family {
      tailf:info "Enter Address Family command mode";

      // router bgp * / address-family ipv4
      container ipv4 {
        tailf:info "IPv4 Address Family";

        // router bgp * / address-family ipv4 unicast
        container unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence true;
          uses bgp-address-family-grouping;
          uses bgp-address-family-ipv4-grouping;
        }

        // router bgp * / address-family ipv4 multicast
        container multicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence true;
          uses bgp-address-family-grouping;
          uses bgp-address-family-ipv4-grouping;
        }

        // router bgp * / address-family ipv4 labeled-unicast
        container labeled-unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence true;
          uses bgp-address-family-grouping;
          uses bgp-address-family-ipv4-grouping;
        }

        // router bgp * / address-family ipv4 mdt
        container mdt {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence true;
          uses bgp-address-family-grouping;
          uses bgp-address-family-ipv4-grouping;
        }

        // router bgp * / address-family ipv4 rt-filter
        container rt-filter {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence true;
          uses bgp-address-family-grouping;
          uses bgp-address-family-ipv4-grouping;
        }

        // router bgp * / address-family ipv4 flowspec
        container flowspec {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence true;
          uses bgp-address-family-grouping;
          uses bgp-address-family-ipv4-grouping;
        }

        // router bgp * / address-family ipv4 mvpn
        container mvpn {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence true;
          uses bgp-address-family-grouping;
          uses bgp-address-family-ipv4-grouping;
        }

        // router bgp * / address-family ipv4 sr-policy
        container sr-policy {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence true;
          uses bgp-address-family-grouping;
          uses bgp-address-family-ipv4-grouping;
        }
      }

      // router bgp * / address-family ipv6
      container ipv6 {
        tailf:info "IPv6 Address Family";

        // router bgp * / address-family ipv6 unicast
        container unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence true;
          uses bgp-address-family-grouping;
          uses bgp-address-family-ipv6-grouping;
        }

        // router bgp * / address-family ipv6 multicast
        container multicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence true;
          uses bgp-address-family-grouping;
          uses bgp-address-family-ipv6-grouping;
        }

        // router bgp * / address-family ipv6 mvpn
        container mvpn {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence true;
          uses bgp-address-family-grouping;
          uses bgp-address-family-ipv6-grouping;
        }

        // router bgp * / address-family ipv6 sr-policy
        container sr-policy {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence true;
          uses bgp-address-family-grouping;
          uses bgp-address-family-ipv6-grouping;
        }

        // router bgp * / address-family ipv6 flowspec
        container flowspec {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence true;
          uses bgp-address-family-grouping;
          uses bgp-address-family-ipv6-grouping;
        }
      }

      // router bgp * / address-family vpnv4
      container vpnv4 {
        tailf:info "VPNv4 Address Family";

        // router bgp * / address-family vpnv4 unicast
        container unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence true;
          uses bgp-address-family-grouping;
          uses bgp-address-family-ipv4-grouping;
        }

        // router bgp * / address-family vpnv4 multicast
        container multicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence true;
          uses bgp-address-family-grouping;
          uses bgp-address-family-ipv4-grouping;
        }

        // router bgp * / address-family vpnv4 flowspec
        container flowspec {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence true;
          uses bgp-address-family-grouping;
          uses bgp-address-family-ipv4-grouping;
        }
      }

      // router bgp * / address-family vpnv6
      container vpnv6 {
        tailf:info "VPNv6 Address Family";

        // router bgp * / address-family vpnv6 unicast
        container unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence true;
          uses bgp-address-family-grouping;
          uses bgp-address-family-ipv6-grouping;
        }

        // router bgp * / address-family vpnv6 multicast
        container multicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence true;
          uses bgp-address-family-grouping;
          uses bgp-address-family-ipv6-grouping;
        }

        // router bgp * / address-family vpnv6 flowspec
        container flowspec {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence true;
          uses bgp-address-family-grouping;
          uses bgp-address-family-ipv6-grouping;
        }
      }

      // router bgp * / address-family l2vpn
      container l2vpn {
        tailf:info "L2VPN Address Family";

        // router bgp * / address-family l2vpn vpls-vpws
        container vpls-vpws {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence true;
          uses bgp-address-family-grouping;
          uses bgp-address-family-ipv4-grouping;
        }

        // router bgp * / address-family l2vpn evpn
        container evpn {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence true;
          uses bgp-address-family-grouping;
          uses bgp-address-family-ipv4-grouping;
        }

        // router bgp * / address-family l2vpn mspw
        container mspw {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence true;
          uses bgp-address-family-grouping;
          uses bgp-address-family-ipv4-grouping;
        }
      }

      // router bgp * / address-family link-state link-state
      container link-state {
        tailf:info "Link-state Address Family";
        container link-state {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-bgp-af";
          presence true;
          uses bgp-address-family-grouping;
          uses bgp-address-family-pre-grouping;
        }
      }
    }

    // router bgp * / af-group *
    list af-group {
      tailf:info "Specify a AF group";
      tailf:cli-mode-name "config-bgp-afgrp";
      key "name address-family af-modifier";
      leaf name {
        type string {
          tailf:info "WORD;;AF group name";
        }
      }
      leaf address-family {
        tailf:info "Enter Address Family command mode";
        tailf:cli-expose-key-name;
        type enumeration {
          enum ipv4 {
            tailf:info "IPv4 Address Family";
          }
          enum ipv6 {
            tailf:info "IPv6 Address Family";
          }
          enum l2vpn {
            tailf:info "L2VPN Address Family";
          }
          enum vpnv4 {
            tailf:info "VPNv4 Address Family";
          }
          enum vpnv6 {
            tailf:info "VPNv6 Address Family";
          }
        }
      }
      leaf af-modifier {
        type enumeration {
          enum labeled-unicast {
            tailf:info "Address Family modifier";
          }
          enum mdt {
            tailf:info "Address Family modifier";
          }
          enum multicast {
            tailf:info "Address Family modifier";
          }
          enum mvpn {
            tailf:info "Address Family modifier";
          }
          enum rt-filter {
            tailf:info "Address Family modifier";
          }
          enum tunnel {
            tailf:info "Address Family modifier";
          }
          enum unicast {
            tailf:info "Address Family modifier";
          }
          enum vpls-vpws {
            tailf:info "Address Family modifier";
          }
        }
      }

      // router bgp * / af-group * /
      uses router-bgp-neighbor-af-grouping;
    }

    // router bgp * / neighbor-group *
    list neighbor-group {
      tailf:info "Specify a Neighbor-group";
      tailf:cli-mode-name "config-bgp-nbrgrp";
      key name;
      leaf name {
        tailf:info "Neighbor-group name";
        type string {
          tailf:info "WORD;;Neighbor-group name";
        }
      }
      uses bgp-neighbor-grouping;
    }

    // router bgp * / neighbor *
    list neighbor {
      tailf:info "Specify a neighbor router";
      tailf:cli-mode-name "config-bgp-nbr";
      key id;
      leaf id {
        tailf:cli-suppress-range;
        type union {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Neighbor address";
          }
          type inet:ipv6-address {
            tailf:info "X:X:X:X::X;;Neighbor IPv6 address";
          }
          type ipv4-prefix {
            tailf:info "A.B.C.D/length;;Dynamic Neighbor Range";
          }
          type tailf:ipv6-address-and-prefix-length {
            tailf:info "X:X::X/length;;Dynamic Neighbor Range";
          }
        }
      }
      leaf activate {
        tailf:cli-hide-in-submode;
        type empty;
      }
      uses bgp-neighbor-grouping;
    }

    // router bgp * / socket
    container socket {
      tailf:info "set socket parameters";

      // router bgp * / socket receive-buffer-size
      container receive-buffer-size {
        tailf:info "socket receive buffer size";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf socket-size {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<512-131072>;;Receive socket buffer size in bytes";
            range "512..131072";
          }
        }
        leaf bgp-size {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "BGP Read buffer size in bytes";
            range "512..131072";
          }
        }
      }

      // router bgp * / socket send-buffer-size
      container send-buffer-size {
        tailf:info "socket send buffer size";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf socket-size {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<4096-131072>;;Send socket buffer size in bytes";
            range "512..131072";
          }
        }
        leaf bgp-size {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<4096-131072>;;BGP Write buffer size in bytes";
            range "512..131072";
          }
        }
      }
    }
  }

  grouping bgp-bestpath-origin-as-grouping {
    container origin-as {
      tailf:info "BGP origin-AS knobs";

      // router bgp * / bgp bestpath origin-as use validity
      container use {
        tailf:info "BGP origin-AS knobs";
        leaf validity {
          tailf:info "BGP bestpath selection will use origin-AS validity";
          type empty;
        }
      }

      // router bgp * / bgp bestpath origin-as allow invalid
      container allow {
        tailf:info "BGP origin-AS knobs";
        leaf invalid {
          tailf:info "BGP bestpath selection will allow 'invalid' origin-AS";
          type empty;
        }
      }
    }
  }

  // grouping router-bgp-grouping
  grouping router-bgp-grouping {

    // router bgp * / apply-group
    uses apply-group-grouping;

    // router bgp * / nsr
    container nsr {
      tailf:info "Enable non-stop-routing support for all neighbors";
      tailf:cli-delete-when-empty;
      presence true;
      // router bgp * / nsr disable
      leaf disable {
        tailf:info "Disable non-stop-routing support for all neighbors";
        type empty;
      }
    }

    uses router-bgp-vrf-grouping {
      // router bgp * / rpki server * / password
      augment rpki/server {
        container password {
          tailf:info "Specify a (SSH) password for the RPKI cache-server";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf enc-type {
            tailf:cli-drop-node-name;
            type enumeration {
              enum clear {
                tailf:info "Specifies an UNENCRYPTED password will follow";
              }
              enum encrypted {
                tailf:info "Specifies an ENCRYPTED password will follow";
              }
            }
          }
          leaf password {
            tailf:cli-drop-node-name;
            tailf:cli-multi-value;
            cli:secret;
            type NEDCOM_SECRET_TYPE {
              tailf:info "LINE;;The password";
            }
          }
        }
      }
    }

    // router bgp * / session-group *
    list session-group {
      tailf:info "Specify a Session group";
      tailf:cli-mode-name "config-bgp-sngrp";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Session group name";
        }
      }

      // router bgp * / session-group * / remote-as
      leaf remote-as {
        tailf:info "Set remote AS";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;AS number in 2-byte, 4-byte asdot and asplain";
        }
      }

      // router bgp * / session-group * / use
      container use {
        tailf:info "Inherit configuration from a group";
        leaf session-group {
          tailf:info "Inherit address-family independent config from a session-group";
          type string {
            tailf:info "WORD;;Session group name";
          }
        }
      }

      // router bgp * / session-group * / ebgp-multihop
      container ebgp-multihop {
        tailf:info "Allow EBGP neighbors not on directly connected networks";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf ttl-value {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<1-255>;;maximum hop count";
          }
        }
        leaf mpls {
          tailf:info "Disable BGP MPLS forwarding";
          type empty;
        }
      }

      // router bgp * / session-group * / advertisement-interval
      container advertisement-interval {
        tailf:info "Minimum interval between sending BGP routing updates";
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        leaf seconds {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-600>;;time in seconds";
            range "0..600";
          }
        }
        leaf milliseconds {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-999>;;time in milliseconds";
            range "0..999";
          }
        }
      }

      // router bgp * / session-group * / maximum-peers
      leaf maximum-peers {
        tailf:info "Maximum dynamic neighbors";
        type uint16 {
          tailf:info "<1-4095>;;Maximum number of peers";
          range "1..4095";
        }
      }

      // router bgp * / session-group / ao
      uses bgp-common-group-grouping;

      // router bgp * / session-group / local-as
      container local-as {
        tailf:info "Specify a local-as number";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        choice local-as-choice {
          case a {
            leaf inheritance-disable {
              tailf:info "Prevent local AS from being inherited from parent";
              type empty;
            }
          }
          case b {
            leaf as-number {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "WORD;;AS number in 2-byte, 4-byte asdot and asplain";
              }
            }
            leaf no-prepend {
              tailf:info "Do not prepend local AS to announcements from this neighbor";
              type empty;
            }
            leaf replace-as {
              tailf:info "Prepend only local AS to announcements to this neighbor";
              type empty;
            }
            leaf dual-as {
              tailf:info "Dual-AS mode";
              type empty;
            }
          }
        }
      }

      // router bgp * / session-group * / egress-engineering
      container egress-engineering {
        tailf:info "Enable egress peer engineering for this neighbor";
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        leaf inheritance-disable {
          tailf:info "Do not inherit egress-engineering from the parent";
          type empty;
        }
      }

      // router bgp * / session-group * / password
      container password {
        tailf:info "Set a password";
        cli:secret " password <SECRET>";
        choice password-choice {
          leaf clear {
            tailf:info "Specifies an unencrypted password will follow";
            type NEDCOM_SECRET_TYPE {
              tailf:info "LINE;;The UNENCRYPTED (cleartext) neighbor password";
            }
          }
          leaf encrypted {
            tailf:info "Specifies an encrypted password will follow";
            type string {
              tailf:info "WORD;;The ENCRYPTED neighbor password string";
            }
          }
          leaf inheritance-disable {
            tailf:info "Prevent password from being inherited from parent";
            type empty;
          }
        }
      }

      // router bgp * / session-group * / shutdown
      leaf shutdown {
        tailf:info "Administratively shut down this neighbor";
        type empty;
      }

      // router bgp * / session-group * / dmz-link-bandwidth
      container dmz-link-bandwidth {
        tailf:info "Propagate the DMZ link bandwidth";
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        leaf inheritance-disable {
          tailf:info "Prevent dmz-link-bandwidth from being inherited from the parent";
          type empty;
        }
      }

      // router bgp * / session-group * / description
      leaf description {
        tailf:info "Neighbor specific description";
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE;;Up to 80 characters describing this neighbor";
        }
      }

      // router bgp * / session-group * / ttl-security
      container ttl-security {
        tailf:info "Enable EBGP TTL security";
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        leaf inheritance-disable {
          tailf:info "Prevent ttl-security from being inherited from the parent";
          type empty;
        }
      }

      // router bgp * / session-group * / bmp-activate server *
      container bmp-activate {
        tailf:info "Enable BMP logging for this neighbor";
        list server {
          tailf:info "Enable BMP connection to particular server";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key id;
          leaf id {
            type uint8 {
              tailf:info "<1-8>;;Enable BMP connection to particular server";
              range "1..8";
            }
          }
        }
      }

      // router bgp * / session-group * / update-source
      container update-source {
        tailf:info "Source of routing updates";
        uses interface-name-grouping;
      }

      // router bgp * / session-group * / ignore-connected-check
      container ignore-connected-check {
        tailf:info "Bypass the directly connected nexthop check for single-hop eBGP peering";
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        leaf inheritance-disable {
          tailf:info "Prevent ignore-connected-check from being inherited from the parent";
          type empty;
        }
      }

      // router bgp * / session-group * / session-open-mode
      leaf session-open-mode {
        tailf:info "Establish BGP session using this TCP open mode";
        type enumeration {
          enum active-only {
            tailf:info "Active only";
          }
          enum both {
            tailf:info "Prevent session-open-mode being inherited from the parent";
          }
          enum passive-only {
            tailf:info "Passive only";
          }
        }
      }

      // router bgp * / session-group * / send-buffer-size
      leaf send-buffer-size {
        tailf:info "Set socket and BGP send buffer size";
        type uint32 {
          tailf:info "<4096-131072>;;Send socket buffer size in bytes";
        }
      }

      // router bgp * / session-group * / receive-buffer-size
      leaf receive-buffer-size {
        tailf:info "Set socket and BGP receive buffer size";
        type uint32 {
          tailf:info "<512-131072>;;Receive socket buffer size in bytes";
        }
      }

      // router bgp * / session-group * / timers
      container timers {
        tailf:info "BGP per neighbor timers";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf keepalive {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<0-65535>;;Keepalive interval";
          }
        }
        leaf holdtime {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-65535>;;Holdtime (0 = Disable keepalives/hold time)";
          }
        }
        leaf min-holdtime {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<3-65535>;;Minimum acceptable holdtime from neighbor";
          }
        }
      }

      // router bgp * / session-group * / bfd
      uses bfd-common-parameters-grouping;
    }

    // router bgp * / vrf *
    list vrf {
      tailf:info "Specify a vrf name";
      tailf:cli-mode-name "config-bgp-vrf";
      cisco-ios-xr:bgp-vrf-rd-modify;
      key name;
      leaf name {
        tailf:info "VRF name";
        type string {
          tailf:info "WORD;;VRF name - maximum length 32 characters";
        }
      }

      // router bgp * / vrf * / rd
      leaf rd {
        tailf:info "route distinguisher";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;AS-number, IPv4 address:index or 'auto'";
        }
      }

      // router bgp * / vrf * / label-allocation-mode
      // NOTE: Warning, deprecated and may be a marco to below, i.e. will cause a diff
      leaf label-allocation-mode {
        tailf:info "Set MPLS/VPN label allocation mode";
        tailf:cli-full-command;
        type enumeration {
          enum  per-ce {
            tailf:info "Set per CE label mode";
          }
          enum per-vrf {
            tailf:info "Set per VRF label mode";
          }
        }
      }

      // router bgp * / vrf * / label
      container label {
        tailf:info "Label-related configuration";
        leaf mode {
          tailf:info "Select label mode";
          type enumeration  {
            enum per-ce  {
              tailf:info "Set per CE label mode";
            }
            enum per-vrf {
              tailf:info "Set per VRF label mode";
            }
          }
        }
      }

      // router bgp * / vrf * / XXX
      uses router-bgp-vrf-grouping;
    }

    // router bgp * / attribute-filter group *
    container attribute-filter {
      tailf:info "Attribute-filter configuration";
      list group {
        tailf:info "Attribute-filter group command mode";
        tailf:cli-mode-name "config-bgp-attrfg";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Attribute-filter group name";
          }
        }

        // router bgp * / attribute-filter group * / attribute *
        container attribute {
          tailf:info "Attribute code";
          list explicit {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            tailf:cli-incomplete-command;
            key code;
            leaf code {
              type union {
                type enumeration {
                  enum AGGREGATOR {
                                   tailf:info "Aggregator attribute (7)";
                                   value 7;
                  }
                  enum AIGP {
                             tailf:info "AIGP attribute (26)";
                             value 26;
                  }
                  enum AS4-AGGREGATOR {
                    tailf:info "AS4_AGGREGATOR attribute (18)";
                    value 18;
                  }
                  enum AS4-PATH {
                    tailf:info "AS4_PATH attribute (17)";
                    value 17;
                  }
                  enum ATOMIC-AGGREGATE {
                    tailf:info "Atomic aggrgate attribute (6)";
                    value 6;
                  }
                  enum CLUSTER-LIST {
                    tailf:info "Cluster List attribute (10)";
                    value 10;
                  }
                  enum COMMUNITY {
                                  tailf:info "Community attribute (8)";
                                  value 8;
                  }
                  enum CONNECTOR {
                                  tailf:info "Connector attribute (20)";
                                  value 20;
                  }
                  enum EXTENDED-COMMUNITIES {
                    tailf:info "Extended community attribute (16)";
                    value 16;
                  }
                  enum LOCAL-PREF {
                    tailf:info "Local Preference attribute (5)";
                    value 5;
                  }
                  enum LSATTR {
                               tailf:info "Link-state attribute (99)";
                               value 29;
                  }
                  enum MULTI-EXIT-DISC {
                    tailf:info "MED attribute (4)";
                    value 4;
                  }
                  enum ORIGINATOR-ID {
                    tailf:info "Originator attribute (9)";
                    value 9;
                  }
                  enum PMSI-TUNNEL {
                    tailf:info "PMSI Tunnel attribute (22)";
                    value 22;
                  }
                  enum PPMP {
                             tailf:info "PPMP attribute (70)";
                             value 70;
                  }
                  enum SSA {
                            tailf:info "SAFI specific attribute (19)";
                            value 19;
                  }
                  enum unrecognized {
                                     tailf:info "All unrecognized attributes";
                                     value 255;
                  }
                  enum ATTRSET {
                                tailf:info "ATTR_SET attribute (128)";
                                value 128;
                  }
                  enum LARGE-COMMUNITY {
                    tailf:info "Large Community attribute (32)";
                    value 32;
                  }
                  enum TUNNEL-ENCAP {
                    tailf:info "Tunnel-encap attribute (23)";
                    value 23;
                  }
                }
                type uint8 {
                  tailf:info "Attribute code";
                }
              }
            }
            choice config-choice {
              leaf discard {
                tailf:info "Discard this attribute";
                type empty;
              }
              leaf treat-as-withdraw {
                tailf:info "Treat the update message as a Withdraw";
                type empty;
              }
            }
          }
          list range {
            tailf:info "Attribute code range";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key code-range;
            leaf code-range {
              type string {
                tailf:info "<start>-<end>;;Range start/end of range";
                pattern "[0-9]+-[0-9]+";
              }
            }
            choice config-choice {
              leaf discard {
                tailf:info "Discard this attribute";
                type empty;
              }
              leaf treat-as-withdraw {
                tailf:info "Treat the update message as a Withdraw";
                type empty;
              }
            }
          }
        }
      }
    }
  }

  // policy-map * / class * / set
  // policy-map * / class * / police * / conform-action set
  // policy-map * / class * / police * / exceed-action set
  // policy-map * / class * / police * / violate-action set
  grouping police-set-grouping {

    // policy-map * / class * / set atm-clp
    leaf atm-clp {
      tailf:info "Set atm cell-loss-priority bit";
      tailf:cli-full-command;
      type empty;
    }

    // policy-map * / class * / set cos
    container cos {
      tailf:info "Set Class Of Service values";
      leaf cos-value {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<0-7>;;COS value";
          range "0..7";
        }
      }
      leaf inner {
        tailf:info "COS inner value";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<0-7>;;COS value";
          range "0..7";
        }
      }
    }

    // policy-map * / class * / set dei
    leaf dei {
      tailf:info "Set DEI";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<0-1>;;DEI value";
        range "0..1";
      }
    }

    // policy-map * / class * / set discard-class
    leaf discard-class {
      tailf:info "Set discard-class";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<0-63>;;Discard Class value";
        range "0..63";
      }
    }

    // policy-map * / class * / set traffic-class
    leaf traffic-class {
      tailf:info "Set traffic-class";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<0-63>;;Traffic class value";
        range "0..63";
      }
    }

    // policy-map * / class * / set dscp
    container dscp {
      tailf:info "Set IP DSCP (DiffServ CodePoint)";
      leaf outer {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        type dscp-type;
      }
      leaf tunnel {
        tailf:info "Set DSCP Tunnel(for ipsec tunnels)";
        tailf:cli-full-command;
        type dscp-type;
      }
    }

    // policy-map * / class * / set fr-de
    leaf fr-de {
      tailf:info "Set FR DE value";
      tailf:cli-full-command;
      type enumeration {
        enum "1" {
          tailf:info "<1-1>;;FR DE value";
        }
      }
    }

    // policy-map * / class * / set mpls
    container mpls {
      tailf:info "Set MPLS specific values";
      container experimental {
        tailf:info "Set Experimental value";
        leaf imposition {
          tailf:info "Set Experimental value at tag imposition";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<0-7>;;Experimental value";
            range "0..7";
          }
        }
        leaf topmost {
          tailf:info "Set Experimental value on topmost label";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<0-7>;;Experimental value";
            range "0..7";
          }
        }
      }
    }

    // policy-map * / class * / set precedence
    container precedence {
      tailf:info "Set IP Precedence";
      leaf outer {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        type precedence-type;
      }
      leaf tunnel {
        tailf:info "Set Precedence tunnel (for ipsec tunnels)";
        tailf:cli-full-command;
        type precedence-type;
      }
    }

    // policy-map * / class * / set qos-group
    leaf qos-group {
      tailf:info "Set qos-group";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<0-63>;;QoS group value";
        range "0..63";
      }
    }

    // policy-map * / class * / set forward-class
    leaf forward-class {
      tailf:info "Set forward class";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<1-7>;;Forward class value";
        range "1..7";
      }
    }

    // policy-map * / class * / set srp-priority
    leaf srp-priority {
      tailf:info "Set SRP priority";
      type uint8 {
        tailf:info "<0-7>;;SRP priority value";
        range "0..7";
      }
    }

    // policy-map * / class * / set df
    leaf df {
      tailf:info "Set DF bit";
      type uint8 {
        tailf:info "<0-1>;;DF bit";
        range "0..1";
      }
    }
  }


  // policy-map * / class * / police * /
  grouping police-action-grouping {

    // policy-map * / class * / police * / child-conform-aware
    leaf child-conform-aware {
      tailf:cli-break-sequence-commands;
      tailf:info "Enable coupled policing";
      type empty;
    }

    // policy-map * / class * / police * / conform-action
    container conform-action {
      tailf:info "Action for conforming traffic";
      leaf drop {
        tailf:info "Drop packet";
        tailf:cli-full-command;
        type empty;
      }
      container set {
        tailf:info "Conditional marking";
        uses police-set-grouping;
      }
      leaf transmit {
        tailf:info "Transmit packet";
        tailf:cli-full-command;
        type empty;
      }
    }

    // policy-map * / class * / police * / exceed-action
    container exceed-action {
      tailf:info "Action for conforming traffic";
      leaf drop {
        tailf:info "Drop packet";
        tailf:cli-full-command;
        type empty;
      }
      container set {
        tailf:info "Conditional marking";
        uses police-set-grouping;
      }
      leaf transmit {
        tailf:info "Transmit packet";
        tailf:cli-full-command;
        type empty;
      }
    }

    // policy-map * / class * / police * / violate-action
    container violate-action {
      tailf:info "Action for conforming traffic";
      leaf drop {
        tailf:info "Drop packet";
        tailf:cli-full-command;
        type empty;
      }
      container set {
        tailf:info "Conditional marking";
        uses police-set-grouping;
      }
      leaf transmit {
        tailf:info "Transmit packet";
        tailf:cli-full-command;
        type empty;
      }
    }
  }

  // policy-map-class-grouping
  grouping policy-map-class-grouping {

    // policy-map * / class type traffic *
    leaf type {
      tailf:info "The type of classmap";
      tailf:cli-prefix-key;
      type enumeration {
        enum traffic {
          tailf:info "Traffic classmap";
        }
      }
    }

    // policy-map * / class * / drop
    leaf drop {
      tailf:info "Drop the packet";
      type empty;
    }

    // policy-map * / class * / transmit
    leaf transmit {
      tailf:info "Transmit the packet";
      type empty;
    }

    // policy-map * / class * / redirect
    container redirect {
      tailf:info "Configure PBF redirect feature";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }

      // policy-map * / class * / redirect ipv4 nexthop
      // policy-map * / class * / redirect ipv6 nexthop
      leaf af {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        tailf:cli-incomplete-command;
        type enumeration {
          enum ipv4 {
            tailf:info "Enter IPv4 configurations";
          }
          enum ipv6 {
            tailf:info "Enter IPv6 configurations";
          }
        }
      }

      // policy-map * / class * / redirect nexthop
      uses policy-map-class-redirect-nexthop-grouping;

      // policy-map * / class * / redirect nexthop ? nexthop
      container nexthop2 {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        uses policy-map-class-redirect-nexthop-grouping;
      }
    }

    // policy-map * / class * / http-redirect
    leaf http-redirect {
      tailf:info "Configure HTTP redirect";
      type string {
        tailf:info "WORD;;Specify the URL HTTP requests should be redirected to";
      }
    }

    // policy-map * / class * / shape
    container shape {
      tailf:info "Configure shaping for this class";

      // policy-map * / class * / shape average
      container average {
        tailf:info "Average rate shaping";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        choice average-choice {
          case percent-case {
            leaf percent {
              tailf:info "Configure shape rate in percentage";
              type uint8 {
                tailf:info "<1-100>;;Shape rate as percentage of available bandwidth";
                range "1..100";
              }
            }
          }
          case unit-case {
            leaf rate {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint32 {
                tailf:info "<1-4294967295>;;Shape rate";
                range "1..4294967295";
              }
            }
            leaf rate-unit {
              tailf:cli-drop-node-name;
              type enumeration {
                enum bps {
                  tailf:info "Bits per second (default)";
                }
                enum cellsps {
                  tailf:info "Cells per second";
                }
                enum gbps {
                  tailf:info "Gigabits per second";
                }
                enum kbps {
                  tailf:info "Kilobits per second";
                }
                enum mbps {
                  tailf:info "Megabits per second";
                }
              }
            }
          }
          case variable-case {
            leaf variable {
              tailf:cli-drop-node-name;
              tailf:cli-multi-value;
              tailf:cli-preformatted;
              tailf:cli-full-command;
              type string {
                tailf:info "LINE;;shape average $<name> = <value> <unit> [$<name> = <value> <unit>]";
                pattern "[$].+[ ]+[=][ ]+.*";
              }
            }
          }
          case per-thousand {
            leaf per-thousand {
              tailf:info "Configure shape rate in per-thousand";
              type uint16 {
                tailf:info "<1-1000>;;Shape rate as parts per-thousand of available bandwidth";
                range "1..1000";
              }
            }
          }
          case per-million {
            leaf per-million {
              tailf:info "Configure shape rate in per-million";
              type uint32 {
                tailf:info "<1-1000000>;;Shape rate as parts per-million of available bandwidth";
                range "1..1000000";
              }
            }
          }
        }
        leaf burst {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<1-4294967295>;;Excess burst size";
            range "1..4294967295";
          }
        }
        leaf burst-unit {
          tailf:cli-drop-node-name;
          type police-burst-units-type;
        }
      }
    }

    // policy-map * / class * / bandwidth
    container bandwidth {
      tailf:info "Configure bandwidth for this class";
      container bandwidth-units {
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf rate {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-4294967295>;;Bandwidth value";
          }
        }
        leaf units {
          tailf:cli-drop-node-name;
          type police-rate-units-type;
        }
      }
      leaf percent {
        tailf:info "configure a percentage bandwidth";
        type percentage-type;
      }
      container remaining {
        tailf:info "Allocate left over bandwidth";
        leaf percent {
          tailf:info "Allocate remaining bandwidth as percentage";
          type percentage-type;
        }
        leaf ratio {
          tailf:info "Allocate remaining bandwidth as a ratio";
          type uint16 {
            tailf:info "<1-1020>;;Bandwidth ratio";
            range "1..1020";
          }
        }
      }
    }

    // policy-map * / class * / police ?
    choice police-choice {

      // policy-map * / class * / police rate
      case police-rate-unit-case {
        container police-rate-unit {
          tailf:cli-no-keyword;
          tailf:cli-drop-node-name;
          container police {
            container rate {
              tailf:info "Committed Information Rate";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-pmap-c-police";
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }

              // { <value> [<units>] | percent <percentage> }
              choice rate-choice {
                case units-case {
                  leaf cir {
                    tailf:cli-drop-node-name;
                    //TRIGGERS NSO 4.6.x BUG: tailf:cli-delete-container-on-delete;
                    tailf:cli-hide-in-submode;
                    tailf:cli-incomplete-command;
                    type uint64 {
                      tailf:info "<1-4294967295>;;Committed Information Rate";
                    }
                  }
                  leaf cir-unit {
                    tailf:cli-drop-node-name;
                    tailf:cli-hide-in-submode;
                    type police-rate-units-type;
                  }
                }
                case percent-case {
                  leaf percent {
                    tailf:info "Percent of the link bandwidth";
                    tailf:cli-hide-in-submode;
                    type uint8 {
                      tailf:info "<1-100>;;Committed Information Rate in percentage of link bandwidth";
                      range "0..100";
                    }
                  }
                }
                leaf per-million {
                  tailf:info "Parts per-million of the link bandwidth";
                  tailf:cli-hide-in-submode;
                  type uint32 {
                    tailf:info "<1-1000000>;;Committed Information Rate in per-million of link bandwidth";
                    range "1..1000000";
                  }
                }
                leaf per-thousand {
                  tailf:info "Parts per-thousand of the link bandwidth";
                  tailf:cli-hide-in-submode;
                  type uint16 {
                    tailf:info "<1-1000>;;Committed Information Rate in per-thousand of link bandwidth";
                  }
                }
              }

              // [ burst burst-size [burst-units] ]
              leaf burst {
                tailf:info "Burst size (BC)";
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                type uint32 {
                  tailf:info "<1-4294967295>;;Burst size (BC)";
                  range "1..4294967295";
                }
              }
              leaf burst-units {
                when "../burst";
                tailf:cli-drop-node-name;
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                type police-burst-units-type;
              }

              // [ peak-rate { value [units] | percent percentage } ]
              leaf peak-rate {
                tailf:info "Peak Information Rate";
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                type uint64 {
                  tailf:info "WORD;;Peak-rate value in range 1-10,000,000,000";
                  range "1..10000000000";
                }
              }
              leaf peak-rate-units {
                when "../peak-rate";
                tailf:cli-drop-node-name;
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                type police-rate-units-type;
              }
              container peak-rate-percent {
                when "not(../peak-rate)" {
                  tailf:dependency "../peak-rate";
                }
                tailf:cli-drop-node-name;
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                tailf:cli-flatten-container;
                container peak-rate {
                  tailf:cli-flatten-container;
                  tailf:cli-hide-in-submode;
                  leaf percent {
                    tailf:info "Percent of the link bandwidth";
                    type percentage-type;
                  }
                }
              }

              // [ peak-burst peak-burst [burst-units] ]
              leaf peak-burst {
                tailf:info "Excess Burst size (BE)";
                tailf:cli-hide-in-submode;
                tailf:cli-optional-in-sequence;
                type uint32 {
                  tailf:info "<1-4294967295>;;Excess burst size (BE)";
                }
              }
              leaf peak-burst-units {
                when "../peak-burst";
                tailf:cli-drop-node-name;
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                type police-burst-units-type;
              }

              // conform-action | exceed-action | violate-action
              uses police-action-grouping;
            }
          }
        }
      }

      // policy-map * / class * / police <unit>
      case police-unit-case {
        container police-unit {
          tailf:cli-no-keyword;
          tailf:cli-drop-node-name;
          container police {
            // To cover also the syntax where cir, bc and be
            // doesn't have to be explicitly specified
            tailf:info "Police traffic";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-pmap-c-police";
            tailf:cli-flatten-container;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf cir {
              tailf:info "Committed information rate";
              tailf:cli-hide-in-submode;
              type uint32 {
                range "8000..2000000000";
                tailf:info "<8000-2000000000>;;Bits per second";
              }
            }
            leaf bc {
              tailf:info "Conform burst";
              tailf:cli-hide-in-submode;
              tailf:cli-optional-in-sequence;
              type uint32 {
                range "1000..512000000";
                tailf:info "<1000-512000000>;;Burst bytes";
              }
            }
            leaf be {
              tailf:info "Excess burst";
              tailf:cli-hide-in-submode;
              tailf:cli-optional-in-sequence;
              type uint32 {
                range "1000..512000000";
                tailf:info "<1000-512000000>;;Burst bytes";
              }
            }
            // conform-action | exceed-action | violate-action
            uses police-action-grouping;
          }
        }
      }
    }

    // policy-map * / class * / set
    container set {
      tailf:info "Configure marking for this class";
      uses police-set-grouping;
    }

    // policy-map * / class * / priority
    container priority {
      tailf:info "Assign priority to this class";
      leaf level {
        tailf:info "Configure a priority level";
        type uint8 {
          tailf:info "<1-8>;;Priority level";
          range "1..8";
        }
      }
    }

    // policy-map * / class * / queue-limit
    container queue-limit {
      tailf:info "Configure queue-limit (taildrop threshold) for this class";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      choice queue-limit-choice {
        case percent {
          leaf percent {
            tailf:info "Configure queue limit value in percentage";
            type uint8 {
              tailf:info "<1-100>;;Percentage value";
              range "1..100";
            }
          }
        }
        case value {
          leaf queue-limit-value {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-4294967295>;;Max Threshold for tail drop";
              range "1..4294967295";
            }
          }
          leaf queue-limit-unit {
            tailf:cli-drop-node-name;
            type enumeration {
              enum bytes {
                tailf:info "Bytes";
              }
              enum kbytes {
                tailf:info "Kilobytes";
              }
              enum mbytes {
                tailf:info "Megabytes";
              }
              enum ms {
                tailf:info "Milliseconds";
              }
              enum packets {
                tailf:info "Packets (default)";
              }
              enum us {
                tailf:info "Microseconds";
              }
            }
          }
        }
      }
    }

    // policy-map * / class * / service-function-path
    container service-function-path {
      tailf:info "Configure NSH service function action";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf id {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint32 {
          tailf:info "<1-16777215>;;Service function path id";
          range "1..16777215";
        }
      }
      leaf index {
        tailf:info "Specify service path index";
        type uint8 {
          tailf:info "<1-255>;;Service function path index";
          range "1..255";
        }
      }
      leaf metadata {
        tailf:info "service-function metadata";
        type string {
          tailf:info "WORD;;Specify metadata name";
        }
      }
    }

    // policy-map * / class * / service-policy
    container service-policy {
      tailf:info "Configure a child service policy";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      leaf type {
        tailf:info "The type of policymap";
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum accounting {
            tailf:info "Accounting policymap";
          }
          enum control {
            tailf:info "Control policy-map";
          }
          enum none {
            tailf:info "Untyped policymap";
          }
          enum pbr {
            tailf:info "PBR policymap";
          }
          enum performance-traffic {
            tailf:info "Realtime Application Flow Monitoring policymap";
          }
          enum qos {
            tailf:info "QoS policymap (default)";
          }
          enum redirect {
            tailf:info "Redirect policymap";
          }
          enum traffic {
            tailf:info "Traffic policy-map";
          }
        }
      }
      leaf name {
        tailf:cli-drop-node-name;
        tailf:cli-remove-before-change;
        tailf:cli-suppress-leafref-in-diff;
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:policy-map/name";
        }
        type string {
          tailf:info "WORD;;Name of the child service policy";
        }
      }
    }

    // policy-map * / class * / random-detect
    container random-detect {
      tailf:info "Enable Random Early Detection";

      // policy-map * / class * / random-detect default
      leaf default {
        tailf:info "Enable RED with default min and max thresholds";
        tailf:cli-full-command;
        type empty;
      }



      // policy-map * / class * / random-detect cos
      list cos {
        tailf:info "COS based WRED (upto 8 values)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        key name;
        leaf name {
          type string {
            tailf:info "<0-7>;;COS value";
          }
        }
        uses class-random-detect-grouping;
      }

      // policy-map * / class * / random-detect dei
      list dei {
        tailf:info "DEI based WRED";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        key name;
        leaf name {
          type string {
            tailf:info "<0-1>;;DEI value";
          }
        }
        uses class-random-detect-grouping;
      }

      // policy-map * / class * / random-detect dscp
      list dscp {
        tailf:info "DSCP based WRED (upto 8 values or ranges)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        key name;
        leaf name {
          type string {
            tailf:info "<0-63>;;Differentiated services codepoint value\n"+
              "af11,af12,af13,af21,af22,af23,af31,af32,af33,af41,af42,af43\n"+
              "cs1-cs7,default,ef and ',' for ranges";
          }
        }
        uses class-random-detect-grouping;
      }

      // policy-map * / class * / random-detect exp
      list exp {
        tailf:info "MPLS Experimental value based WRED (upto 8 values)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        key name;
        leaf name {
          type string {
            tailf:info "<0-7>;;MPLS Experimental value and ',' for ranges";
          }
        }
        uses class-random-detect-grouping;
      }

      // policy-map * / class * / random-detect precedence
      list precedence {
        tailf:info "Precedence based WRED (upto 8 values)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        key name;
        leaf name {
          type string {
            tailf:info "<0-7>;;Precedence value, critical,flash,flash-override,immediate,"
              +"internet,network,priority,routine and ',' for ranges";
          }
        }
        uses class-random-detect-grouping;
      }

      // policy-map * / class * / random-detect discard-class *
      list discard-class {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        key name;
        leaf name {
          type uint8 {
            tailf:info "<0-7>;;Discard Class  value";
            range "0..7";
          }
        }
        uses class-random-detect-grouping;
      }

      // policy-map * / class * / random-detect ?
      container default-values {
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        uses class-random-detect-grouping;
      }
    }

    // policy-map * / class * / monitor
    container monitor {
      tailf:info "traffic performance monitoring configuration";

      // policy-map * / class * / monitor parameters
      container parameters {
        tailf:info "Flow monitoring parameters";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-pmap-c-mparm";

        // policy-map * / class * / monitor parameters / flows
        leaf flows {
          tailf:info "Limit num concurrent monitored flows in this policy class";
          type uint16 {
            tailf:info "<1-4096>;;maximum number of concurrent flows";
            range "1..4096";
          }
        }

        // policy-map * / class * / monitor parameters / interval duration
        container interval {
          tailf:info "Monitoring interval for the metric computation";
          leaf duration {
            tailf:info "Duration of the fixed interval";
            type uint16 {
              tailf:info "<10-300>;;duration in seconds";
              range "10..300";
            }
          }
        }

        // policy-map * / class * / monitor parameters / history
        leaf history {
          tailf:info "Limit num history intervals for each flow in this policy class";
          type uint8 {
            tailf:info "<1-60>;;Num intervals of history";
            range "1..60";
          }
        }

        // policy-map * / class * / monitor parameters / timeout
        leaf timeout {
          tailf:info "Time-out an inactive flow";
          type uint8 {
            tailf:info "<2-60>;;Timeout in multiples of Monitoring intervals";
            range "2..60";
          }
        }
      }

      // policy-map * / class * / monitor metric
      container metric {
        tailf:info "Configure a monitoring metric";

        // policy-map * / class * / monitor metric ip-cbr
        container ip-cbr {
          tailf:info "IP-CBR monitoring metric parameters";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-pmap-c-ipcbr";

          // policy-map * / class * / monitor metric ip-cbr / rate
          container rate {
            tailf:info "Nominal per-flow data rate";

            // policy-map * / class * / monitor metric ip-cbr / rate layer3
            container layer3 {
              tailf:info "Nominal rate specified at the L3 (IP)";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf packet {
                tailf:info "Nominal IP layer packet rate (in pps)";
                type uint32 {
                  tailf:info "<1-1000000>;;packet rate for flow in pps";
                  range "1..1000000";
                }
              }
              leaf pps {
                tailf:info "units - packets per second";
                type empty;
              }
            }

            // policy-map * / class * / monitor metric ip-cbr / rate media
            container media {
              tailf:info "Nominal data rate of the media flow (ip payload)";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf value {
                tailf:cli-drop-node-name;
                type uint32 {
                  tailf:info "<1-4294967294>;;Media data rate for the flow in kbps|mbps|..";
                }
              }
              leaf units {
                tailf:cli-drop-node-name;
                type police-rate-units-type;
                default kbps;
              }
            }
          }
        }

        // policy-map * / class * / monitor metric mdi mpeg
        container mdi {
          tailf:info "MDI monitoring";
          container mpeg {
            tailf:info "MDI MPEG monitoring metric parameters";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-pmap-c-mdi";
            presence true;

            // policy-map * / class * / monitor metric mdi mpeg / filter packet-rate
            container filter {
              tailf:info "packet filtering";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf packet-rate {
                tailf:info "Enable packet filtering based on lower bound of stream rate";
                tailf:cli-incomplete-command;
                type uint32 {
                  tailf:info "<1-4294967294>;;The lower bound of stream rate";
                  range "1..4294967294";
                }
              }
              leaf pps {
                tailf:info "units - packets per second";
                type empty;
              }
            }

            // policy-map * / class * / monitor metric mdi mpeg / rate layer3 packet
            container rate {
              tailf:info "Nominal per-flow data rate";
              container layer3 {
                tailf:info "Nominal rate specified at the L3 (IP)";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                leaf packet {
                  tailf:info "Nominal IP layer packet rate (in pps)";
                  tailf:cli-incomplete-command;
                  type uint32 {
                    tailf:info "<1-4294967294>;;packet rate for flow in pps";
                  }
                }
                leaf pps {
                  tailf:info "units - packets per second";
                  type empty;
                }
              }
            }
          }
        }
      }
    }

    // policy-map * / class * / react *
    list react {
      tailf:info "Generate alert on the specified event";
      tailf:cli-mode-name "config-pmap-c-react";
      key "id type";
      leaf id {
        type uint32 {
          tailf:info "<1-4294967294>;;Specify an operation id (num)";
          range "1..4294967294";
        }
      }
      leaf type {
        type enumeration {
          enum delay-factor {
            tailf:info "Delay Factor";
          }
          enum flow-count {
            tailf:info "Flow Count";
          }
          enum mdi-error-seconds {
            tailf:info "MDI error seconds";
          }
          enum mdi-jitter {
            tailf:info "MDI Jitter";
          }
          enum mdi-mdc {
            tailf:info "MDI Media Disc. Count";
          }
          enum mdi-mlr {
            tailf:info "MDI Media Loss Rate";
          }
          enum mdi-transport-availability {
            tailf:info "MDI transport availability";
          }
          enum media-stop {
            tailf:info "Media Stop Event";
          }
          enum mpeg-loss-pkts {
            tailf:info "MPEG loss packets";
          }
          enum mrv {
            tailf:info "Media Rate Variation";
          }
          enum packet-rate {
            tailf:info "Packet Rate";
          }
          enum rtp-error-seconds {
            tailf:info "RTP error seconds";
          }
          enum rtp-jitter {
            tailf:info "RTP jitter";
          }
          enum rtp-loss-fraction {
            tailf:info "RTP loss fraction";
          }
          enum rtp-loss-pkts {
            tailf:info "RTP loss packets";
          }
          enum rtp-max-jitter {
            tailf:info "RTP max jitter";
          }
          enum rtp-out-of-order {
            tailf:info "RTP out-of-order packets";
          }
          enum rtp-transport-availability {
            tailf:info "RTP transport availability";
          }
        }
      }

      // policy-map * / class * / react * / threshold
      container threshold {
        tailf:info "Set the event trigger";

        // policy-map * / class * / react * / threshold type immediate
        container type {
          tailf:info "Set the trigger type";
          leaf immediate {
            tailf:info "Immediate trigger";
            type empty;
          }
        }

        // policy-map * / class * / react * / threshold value
        container value {
          tailf:info "Set the trigger criterion";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf operator {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type enumeration {
              enum ge {
                tailf:info "trigger only if metric is greater than or equal to the given value";
              }
              enum gt {
                tailf:info "trigger only if metric is greater than the given value";
              }
              enum le {
                tailf:info "trigger only if metric is less than or equal to the given value";
              }
              enum lt {
                tailf:info "trigger only if metric is less than the given value";
              }
              enum "range" {
                tailf:info "trigger only if metric is in the inclusive range";
              }
            }
          }
          leaf value {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;Limit as a number";
            }
          }
        }
      }

      // policy-map * / class * / react * / action
      container action {
        tailf:info "Set the event action";

        // policy-map * / class * / react * / action syslog
        leaf syslog {
          tailf:info "Report via syslog";
          type empty;
        }

        // policy-map * / class * / react * / action snmp
        leaf snmp {
          tailf:info "Report via syslog";
          type empty;
        }
      }

      // policy-map * / class * / react * / alarm
      container alarm {
        tailf:info "Configure alarms";

        // policy-map * / class * / react * / alarm severity
        leaf severity {
          tailf:info "Set the alarm severity";
          type enumeration {
            enum error {
              tailf:info "Error level alarm";
            }
            enum critical {
              tailf:info "Critical level alarm";
            }
            enum alert {
              tailf:info "Alert level alarm";
            }
            enum emergency {
              tailf:info "Emergency level alarm";
            }
          }
        }

        // policy-map * / class * / react * / alarm type
        container type {
          tailf:info "Set the alarm type";
          leaf discrete {
            tailf:info "Discrete alarms";
            type empty;
          }
        }
      }
    }
  }

  grouping policy-map-class-redirect-nexthop-grouping {
    container nexthop {
      tailf:info "Forward to specified nexthop";
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf vrf {
        tailf:info "Enter specific VRF Name for this nexthop";
        tailf:cli-optional-in-sequence;
        type vrf-type;
      }
      choice nexthop-choice {
        leaf IPv4-address  {
          tailf:cli-drop-node-name;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Input IPv4 Nexthop address";
          }
        }
        leaf IPv6-address {
          tailf:cli-drop-node-name;
          tailf:cli-disallow-value "route-target";
          type string {
          tailf:info "X:X::X%zone;;Input IPv6 Nexthop address";
          }
        }
        leaf route-target {
          tailf:info "Enter specific route-target string";
          type string {
            tailf:info "WORD;;IPAddress:index or 2-byte ASN or 4-byte ASN";
          }
        }
      }
    }
  }

  // performance-mgmt-grouping
  grouping performance-mgmt-grouping {

    choice case-choice {
      container AverageCpuUsed {
        tailf:info "Average %CPU utilization";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        uses average-cpu-used-grouping;
      }
      container AverageCPUUsed {
        tailf:info "Average %CPU utilization";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        uses average-cpu-used-grouping;
      }
    }

    leaf sample-size {
      tailf:info "Number of samples to be taken";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<1-60>;;Number of samples";
        range "1..60";
      }
    }

    leaf sample-interval {
      tailf:info "Frequency of sampling in minutes";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<1-60>;;Frequency of samples";
        range "1..60";
      }
    }
  }

  grouping performance-mgmt-template-grouping {
    list template {
      tailf:info "Specify template";
      tailf:cli-mode-name "config-stats-cntr";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Template name";
        }
      }
      uses performance-mgmt-grouping;
    }
  }

  // ipv4
  // ipv6
  grouping ipv4-ipv6-common-grouping {

    // ipv4 conflict-policy
    // ipv6 conflict-policy
    leaf conflict-policy {
      tailf:info "ip address conflict algorithm selection";
      tailf:cli-full-command;
      type enumeration {
        enum highest-ip {
          tailf:info "Keeps the highest ip address in the conflict set UP";
        }
        enum longest-prefix {
          tailf:info "Keeps the longest prefix match in the conflict set UP";
        }
        enum static {
          tailf:info "Keeps the existing interface UP across new address configs";
        }
      }
    }

    // ipv4 prefix-list *
    // ipv6 prefix-list *
    list prefix-list {
      tailf:info "Prefix-list command";
      tailf:cli-mode-name "config-ipv_pfx";
      tailf:cli-full-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Name of a prefix list - maximum 32 characters";
          length "1..32";
        }
      }

      // ipv4 prefix-list * / *
      // ipv6 prefix-list * / *
      list rule {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          type uint32 {
            tailf:info "<1-2147483646>;;Sequence number";
          }
        }
        leaf line {
          tailf:cli-drop-node-name;
          tailf:cli-multi-value;
          type string {
            tailf:info "deny|permit|remark <parameters>";
            pattern "(deny.*)|(permit.*)|(remark.*)|(no.*)";
          }
        }
      }
    }
  }

  // arp-grouping
  grouping arp-grouping {
    list arp-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      key address;
      leaf address {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;IP Address";
        }
      }
      leaf mac {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type string {
          tailf:info "H.H.H;;MAC address";
          pattern '[0-9a-fA-F]+\.[0-9a-fA-F]+\.[0-9a-fA-F]+';
        }
      }
      leaf type {
        tailf:cli-drop-node-name;
        type enumeration {
          enum ARPA {
            tailf:info "Encapsulation type ARPA";
          }
          enum SRP {
            tailf:info "Encapsulation type SRP";
          }
          enum SRPA {
            tailf:info "Encapsulation type SRPA";
          }
          enum SRPB {
            tailf:info "Encapsulation type SRPB";
          }
        }
      }
      leaf alias {
        tailf:info "Configure an Alias ARP entry";
        tailf:cli-optional-in-sequence;
        type empty;
      }
      leaf interface {
        tailf:info "Specify a Interface";
        type string {
          tailf:info "WORD;;Interface Name";
        }
      }
    }
  }


  // tftp-server-grouping
  grouping tftp-server-grouping {
    list tftp-server-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      key af;
      leaf af {
        type enumeration {
          enum ipv4 {
            tailf:info "Global ipv4 specific TFTP server commands";
          }
          enum ipv6 {
            tailf:info "Global ipv6 specific TFTP server commands";
          }
        }
      }
      leaf server {
        tailf:info "TFTP server configuration commands";
        tailf:cli-incomplete-command;
        type empty;
      }
      leaf homedir {
        tailf:info "Home directory for TFTP server";
        type string {
          tailf:info "WORD;;Name of home directory (e.g. disk0:)";
        }
      }
      leaf max-servers {
        tailf:cli-break-sequence-commands;
        tailf:info "Set maximum number of concurrent tftp servers";
        type union {
          type uint32 {
            tailf:info "<1-2147483647>;;Set number of allowable tftp server processes";
            range "1..2147483647";
          }
          type enumeration {
            enum no-limit {
              tailf:info "No limit to number of allowable tftp server processes";
            }
          }
        }
      }
      leaf access-list {
        tailf:info "Access list for TFTP server";
        type string {
          tailf:info "WORD;;Name of access list";
        }
      }
    }
  }


  // telnet-server-grouping
  grouping telnet-server-grouping {
    list telnet-server-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      tailf:cli-compact-syntax;
      key af;
      leaf af {
        type enumeration {
          enum ipv4 {
            tailf:info "IPv4 configuration";
          }
          enum ipv6 {
            tailf:info "IPv6 configuration";
          }
        }
      }
      leaf dscp {
        tailf:info "dscp";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<0-63>;;dscp value";
        }
      }
      container server {
        tailf:info "Telnet server configuration commands";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf max-servers {
          tailf:info "Set number of allowable telnet sessions";
          type uint8 {
            tailf:info "<1-100>;;Set number of allowable telnet sessions";
            range "1..100";
          }
        }
        leaf access-list {
          tailf:info "Access list for telnet server";
          type string {
            tailf:info "WORD;;Name of access list";
          }
        }
      }
    }
  }


  // ntp server *
  grouping ntp-server-grouping {
    list server-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      key name;
      leaf name {
        tailf:cli-disallow-value "vrf";
        type inet:host {
          tailf:info "Hostname or A.B.C.D or X:X::X;;Peer/server address";
        }
      }
      leaf ip-version {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        type enumeration {
          enum ipv4 {
            tailf:info "Specify IPv4 address or hostname";
          }
          enum ipv6 {
            tailf:info "Specify IPv6 address or host name";
          }
        }
      }

      // ntp server * version
      leaf version {
        tailf:info "Configure NTP version";
        type uint8 {
          tailf:info "<1-4>;;NTP version number";
          range "1..4";
        }
      }

      // ntp server * minpoll
      leaf minpoll {
        tailf:info "Configure minimum polling rate";
        type uint8 {
          tailf:info "<4-17>;;Minimum poll rate, default 6, less than maxpoll";
          range "4..17";
        }
      }

      // ntp server * maxpoll
      leaf maxpoll {
        tailf:info "Configure maximum polling rate";
        type uint8 {
          tailf:info "<4-17>;;Maximum poll rate, default 10, greater than minpoll";
          range "4..17";
        }
      }

      // ntp server * prefer
      leaf prefer {
        tailf:info "Prefer this peer when possible";
        type empty;
      }

      // ntp server * burst
      leaf burst {
        tailf:info "Use burst mode";
        type empty;
      }

      // ntp server * iburst
      leaf iburst {
        tailf:info "Use initial burst mode";
        type empty;
      }

      // ntp server * source
      container source {
        tailf:info "Interface for source address";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        uses interface-name-grouping;
      }

      // ntp server * key
      leaf key {
        tailf:info "Configure peer authentication key";
        type uint16 {
          tailf:info "<1-65535>;;Peer key number";
          range "1..65535";
        }
      }
    }
  }


  // router static / address-family ipv6 unicast
  // router static / address-family ipv6 multicast
  grouping router-static-ipv6-grouping {

    // router static / address-family ipv6 unicast / *
    list routes {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      key "net interface address";
      leaf net {
        tailf:info "Destination prefix";
        type tailf:ipv6-address-and-prefix-length {
          tailf:info "X:X::X/length;;Destination prefix";
        }
      }
      leaf interface {
        tailf:info "Interface Name";
        type string {
          tailf:info "WORD;;Interface Name";
          pattern '[A-Za-z].+[0-9]';
        }
      }
      leaf address {
        tailf:info "Forwarding router's address";
        type inet:ipv6-address {
          tailf:info "X:X::X;;Forwarding router's address";
        }
      }
      uses router-static-options-grouping;
    }

    // router static / address-family ipv6 unicast / *
    list routes-ip {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      key "net address";
      leaf net {
        tailf:info "Destination prefix";
        type tailf:ipv6-address-and-prefix-length {
          tailf:info "X:X::X/length;;Destination prefix";
        }
      }
      leaf address {
        tailf:info "Forwarding router's address";
        type inet:ipv6-address {
          tailf:info "X:X::X;;Forwarding router's address";
        }
      }
      uses router-static-options-grouping;
    }

    // router static / address-family ipv6 unicast / *
    list routes-if {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      key "net interface";
      leaf net {
        tailf:info "Destination prefix";
        type tailf:ipv6-address-and-prefix-length {
          tailf:info "X:X::X/length;;Destination prefix";
        }
      }
      leaf interface {
        tailf:info "Interface Name";
        tailf:cli-disallow-value "vrf";
        type string {
          tailf:info "WORD;;Interface Name";
        }
      }
      uses router-static-options-grouping;
    }

    // router static / address-family ipv6 unicast / * vrf *
    list routes-vrf {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      key "net vrf interface address";
      leaf net {
        tailf:info "Destination prefix";
        type tailf:ipv6-address-and-prefix-length {
          tailf:info "X:X::X/length;;Destination prefix";
        }
      }
      leaf vrf {
        tailf:info "Destination VRF";
        tailf:cli-expose-key-name;
        type string {
          tailf:info "WORD;;Destination VRF";
        }
      }
      leaf interface {
        tailf:info "Interface Name";
        type string {
          tailf:info "WORD;;Interface Name";
          pattern '[A-Za-z].+[0-9]';
        }
      }
      leaf address {
        tailf:info "Forwarding router's address";
        type inet:ipv6-address {
          tailf:info "X:X::X;;Forwarding router's address";
        }
      }
      uses router-static-options-grouping;
    }

    // router static / address-family ipv6 unicast / * vrf *
    list routes-base-vrf {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      key "net vrf";
      leaf net {
        tailf:info "Destination prefix";
        type tailf:ipv6-address-and-prefix-length {
          tailf:info "X:X::X/length;;Destination prefix";
        }
      }
      leaf vrf {
        tailf:info "Destination VRF";
        tailf:cli-expose-key-name;
        type string {
          tailf:info "WORD;;Destination VRF";
        }
      }
      uses router-static-options-grouping;
    }

    // router static / address-family ipv6 unicast / * vrf *
    list routes-ip-vrf {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      key "net vrf address";
      leaf net {
        tailf:info "Destination prefix";
        type tailf:ipv6-address-and-prefix-length {
          tailf:info "X:X::X/length;;Destination prefix";
        }
      }
      leaf vrf {
        tailf:info "Destination VRF";
        tailf:cli-expose-key-name;
        type string {
          tailf:info "WORD;;Destination VRF";
        }
      }
      leaf address {
        tailf:info "Forwarding router's address";
        type inet:ipv6-address {
          tailf:info "X:X::X;;Forwarding router's address";
        }
      }
      uses router-static-options-grouping;
    }

    // router static / address-family ipv6 unicast / * vrf *
    list routes-if-vrf {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      key "net vrf interface";
      leaf net {
        tailf:info "Destination prefix";
        type tailf:ipv6-address-and-prefix-length {
          tailf:info "X:X::X/length;;Destination prefix";
        }
      }
      leaf vrf {
        tailf:info "Destination VRF";
        tailf:cli-expose-key-name;
        type string {
          tailf:info "WORD;;Destination VRF";
        }
      }
      leaf interface {
        tailf:info "Interface Name";
        type string {
          tailf:info "WORD;;Interface Name";
          pattern '[A-Za-z].+[0-9]';
        }
      }
      uses router-static-options-grouping;
    }
  }


  // router static / address-family ipv4 unicast
  // router static / address-family ipv6 unicast
  // router static / address-family ipv6 multicast
  grouping router-static-options-grouping {

    // router static / address-family ipv4 unicast / * bfd fast-detect
    leaf bfd {
      tailf:info "Configure BFD paramenters";
      tailf:cli-no-name-on-delete;
      tailf:cli-no-value-on-delete;
      type enumeration {
        enum fast-detect {
          tailf:info "Enable Fast detection";
        }
      }
    }

    // router static / address-family ipv4 unicast / * minimum-interval
    leaf minimum-interval {
      when "../bfd";
      tailf:info "Hello interval";
      tailf:cli-no-name-on-delete;
      tailf:cli-no-value-on-delete;
      type uint16 {
        tailf:info "<3-30000>;;interval in milli-seconds";
        range "3..30000";
      }
    }

    // router static / address-family ipv4 unicast / * multiplier
    leaf multiplier {
      when "../bfd";
      tailf:info "Detect multiplier";
      tailf:cli-no-name-on-delete;
      tailf:cli-no-value-on-delete;
      type uint8 {
        tailf:info "<1-10>;;Detect multiplier";
        range "1..10";
      }
    }

    // router static / address-family ipv4 unicast / * <metric>
    leaf metric {
      tailf:info "Distance metric for this route";
      tailf:cli-drop-node-name;
      tailf:cli-no-value-on-delete;
      tailf:ned-ignore-compare-config;
      type uint8 {
        tailf:info "<1-254>;;Distance metric for this route";
        range "1..254";
      }
    }

    // router static / address-family ipv4 unicast / * tag
    leaf tag {
      tailf:info "Set tag for this route";
      tailf:cli-no-name-on-delete;
      tailf:cli-no-value-on-delete;
      type uint32 {
        tailf:info "<1-4294967295>;;Set tag for this route";
      }
    }

    // router static / address-family ipv4 unicast / * permanent
    leaf permanent {
      tailf:info "Permanent route";
      tailf:cli-no-name-on-delete;
      type empty;
    }

    // router static / address-family ipv4 unicast / * vrflabel
    leaf vrflabel {
      tailf:info "VRF label";
      tailf:cli-no-name-on-delete;
      tailf:cli-no-value-on-delete;
      type uint32 {
        tailf:info "<0-4294967295>;;VRF label";
      }
    }

    // router static / address-family ipv4 unicast / * tunnel-id
    leaf tunnel-id {
      tailf:info "Tunnel ID";
      tailf:cli-no-name-on-delete;
      tailf:cli-no-value-on-delete;
      type uint32 {
        tailf:info "<0-4294967295>;;Tunnel ID";
      }
    }

    // router static / address-family ipv4 unicast / * track
    leaf track {
      tailf:info "Enable object tracking for static route";
      tailf:cli-no-name-on-delete;
      tailf:cli-no-value-on-delete;
      type string {
        tailf:info "WORD;;Object to be tracked";
      }
    }

    // router static / address-family ipv4 unicast / * metric
    container metric2 {
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      leaf metric {
        tailf:info "Set metric for this route";
        tailf:cli-no-name-on-delete;
        tailf:cli-no-value-on-delete;
        type uint32 {
          tailf:info "<1-16777214>;;Set metric for this route";
          range "1..16777214";
        }
      }
    }

    // router static / address-family ipv4 unicast / * description
    leaf description {
      tailf:info "description of the static route";
      tailf:cli-no-name-on-delete;
      tailf:cli-no-value-on-delete;
      type string {
        tailf:info "WORD;;short description of static route";
      }
    }
  }


  // router static
  // router static / vrf *
  grouping router-static-grouping {

    // router static / maximum path
    container maximum {
      tailf:info "Limit the number of static paths which may be configured";
      container path {
        tailf:info "Limit the number of static paths which may be configured";

        // router static / maximum path ipv4
        leaf ipv4 {
          tailf:info "IPv4 commands";
          type uint32 {
            tailf:info "<1-140000>;;The maximum number of static paths which can be configured";
            range "1..140000";
          }
        }

        // router static / maximum path ipv6
        leaf ipv6 {
          tailf:info "IPv6 commands";
          type uint32 {
            tailf:info "<1-140000>;;The maximum number of static paths which can be configured";
            range "1..140000";
          }
        }
      }
    }

    // router static / address-family
    container address-family {
      tailf:info "Static route address family configuration subcommands";

      // router static / address-family ipv4
      container ipv4 {
        tailf:info "IPv4 commands";

        // router static / address-family ipv4 unicast
        container unicast {
          tailf:info "Unicast commands";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-static-afi";
          uses router-static-ipv4-grouping;
        }

        // router static / address-family ipv4 multicast
        container multicast {
          tailf:info "Multicast commands";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-static-afi";
          uses router-static-ipv4-grouping;
        }
      }

      // router static / address-family ipv6
      container ipv6 {
        tailf:info "IPv6 commands";

        // router static / address-family ipv6 unicast
        container unicast {
          tailf:info "Unicast commands";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-static-afi";
          uses router-static-ipv6-grouping;
        }

        // router static / address-family ipv6 multicast
        container multicast {
          tailf:info "Multicast commands";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-static-afi";
          uses router-static-ipv6-grouping;
        }
      }
    }
  }


  // router static / address-family ipv4 unicast /
  // router static / address-family ipv4 multicast /
  grouping router-static-ipv4-grouping {

    // router static / address-family ipv4 unicast / *
    list routes {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      cisco-ios-xr:remove-and-commit-before-change {
        when "/tailfned/ned-settings/auto/router-static-patch = 'true'";
      }
      key "net interface address";
      leaf net {
        tailf:info "Destination prefix";
        type ipv4-prefix {
          tailf:info "A.B.C.D/length;;Destination prefix";
        }
      }
      leaf interface {
        tailf:info "Interface Name";
        type string {
          tailf:info "WORD;;Interface Name";
          pattern '[A-Za-z].+[0-9]';
        }
      }
      leaf address {
        tailf:info "Forwarding router's address";
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Forwarding router's address";
        }
      }
      uses router-static-options-grouping;
    }

    // router static / address-family ipv4 unicast / *
    list routes-ip {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      cisco-ios-xr:remove-and-commit-before-change {
        when "/tailfned/ned-settings/auto/router-static-patch = 'true'";
      }
      key "net address";
      leaf net {
        tailf:info "Destination prefix";
        type ipv4-prefix {
          tailf:info "A.B.C.D/length;;Destination prefix";
        }
      }
      leaf address {
        tailf:info "Forwarding router's address";
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Forwarding router's address";
        }
      }
      uses router-static-options-grouping;
    }

    // router static / address-family ipv4 unicast / *
    list routes-if {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      cisco-ios-xr:remove-and-commit-before-change {
        when "/tailfned/ned-settings/auto/router-static-patch = 'true'";
      }
      key "net interface";
      leaf net {
        tailf:info "Destination prefix";
        type ipv4-prefix {
          tailf:info "A.B.C.D/length;;Destination prefix";
        }
      }
      leaf interface {
        tailf:info "Interface Name";
        type string {
          tailf:info "WORD;;Interface Name";
          pattern '[A-Za-z].+[0-9]';
        }
      }
      uses router-static-options-grouping;
    }

    // router static / address-family ipv4 unicast / * vrf *
    list routes-vrf {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      cisco-ios-xr:remove-and-commit-before-change {
        when "/tailfned/ned-settings/auto/router-static-patch = 'true'";
      }
      key "net vrf interface address";
      leaf net {
        tailf:info "Destination prefix";
        type ipv4-prefix {
          tailf:info "A.B.C.D/length;;Destination prefix";
        }
      }
      leaf vrf {
        tailf:info "Destination VRF";
        tailf:cli-expose-key-name;
        type string {
          tailf:info "WORD;;Destination VRF";
        }
      }
      leaf interface {
        tailf:info "Interface Name";
        type string {
          tailf:info "WORD;;Interface Name";
          pattern '[A-Za-z].+[0-9]';
        }
      }
      leaf address {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Forwarding router's address";
        }
      }
      uses router-static-options-grouping;
    }

    // router static / address-family ipv4 unicast / * vrf *
    list routes-ip-vrf {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      cisco-ios-xr:remove-and-commit-before-change {
        when "/tailfned/ned-settings/auto/router-static-patch = 'true'";
      }
      key "net vrf address";
      leaf net {
        tailf:info "Destination prefix";
        type ipv4-prefix {
          tailf:info "A.B.C.D/length;;Destination prefix";
        }
      }
      leaf vrf {
        tailf:info "Destination VRF";
        tailf:cli-expose-key-name;
        type string {
          tailf:info "Destination VRF";
        }
      }
      leaf address {
        tailf:info "Forwarding router's address";
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Forwarding router's address";
        }
      }
      uses router-static-options-grouping;
    }

    // router static / address-family ipv4 unicast / * vrf *
    list routes-if-vrf {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      cisco-ios-xr:remove-and-commit-before-change {
        when "/tailfned/ned-settings/auto/router-static-patch = 'true'";
      }
      key "net vrf interface";
      leaf net {
        tailf:info "Destination prefix";
        type ipv4-prefix {
          tailf:info "A.B.C.D/length;;Destination prefix";
        }
      }
      leaf vrf {
        tailf:info "Destination VRF";
        tailf:cli-expose-key-name;
        type string {
          tailf:info "Destination VRF";
        }
      }
      leaf interface {
        tailf:info "Interface Name";
        type string {
          tailf:info "WORD;;Interface Name";
          pattern '[A-Za-z].+[0-9]';
        }
      }
      uses router-static-options-grouping;
    }

    // router static / address-family ipv4 unicast / * vrf *
    list routes-net-vrf {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      key "net vrf";
      leaf net {
        tailf:info "Destination prefix";
        type ipv4-prefix {
          tailf:info "A.B.C.D/length;;Destination prefix";
        }
      }
      leaf vrf {
        tailf:info "Destination VRF";
        tailf:cli-expose-key-name;
        type string {
          tailf:info "Destination VRF";
        }
      }
      uses router-static-options-grouping;
    }
  }


  // router igmp
  // router igmp / vrf *
  grouping router-igmp-grouping {

    // router igmp / interface *
    list interface {
      tailf:info "IGMP interface configuration subcommands";
      tailf:cli-mode-name "config-igmp-default-if";
      key name;
      leaf name {
        tailf:cli-disallow-value "all";
        type string {
          tailf:info "WORD;;Interface Name";
        }
      }

      // router igmp / interface * / apply-group
      uses apply-group-grouping;

      // router igmp / interface * / access-group
      leaf access-group {
        tailf:info "IGMP group access group";
        type string {
          tailf:info "WORD;;IP Named Standard Access list";
        }
      }

      // router igmp / interface * / explicit-tracking
      container explicit-tracking {
        tailf:info "IGMPv3 explicit host tracking";
        tailf:cli-delete-when-empty;
        tailf:cli-reset-container;
        presence true;

        // router igmp / interface * / explicit-tracking disable
        leaf disable {
          tailf:info "Disable IGMPv3 explicit host tracking";
          type empty;
        }
      }

      // router igmp / interface * / version
      leaf version {
        tailf:info "IGMP version";
        type uint8 {
          tailf:info "<1-3>;;version number";
        }
      }

      // router igmp / interface * / router
      leaf router {
        tailf:info "Enable/Disable Router side functionality in IGMP";
        type enumeration {
          enum disable {
            tailf:info "Disable Router side functionality in IGMP";
          }
          enum enable {
            tailf:info "Enable Router side functionality in IGMP";
          }
        }
      }

      // router igmp / interface * / join-group *
      list join-group {
        tailf:info "IGMP join multicast group";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key address;
        leaf address {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP group address";
          }
        }
        choice source-choice {
          leaf source-address {
            tailf:cli-drop-node-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Source address to include";
            }
          }
          leaf exclude {
            tailf:info "Exclude the only following source address";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Source address to exclude";
            }
          }
        }
      }

      // router igmp / interface * / static-group *
      container static-group-address {
        tailf:cli-drop-node-name;
        list static-group {
          tailf:info "IGMP static multicast group";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key address;
          leaf address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP group address";
            }
          }
          leaf suppress-reports {
            tailf:info "Suppress IGMP reports";
            type empty;
          }
        }
      }

      // router igmp / interface * / static-group *
      list static-group {
        tailf:info "IGMP static multicast group";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "address source-address";
        leaf address {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP group address";
          }
        }
        leaf source-address {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Source address to join";
          }
        }
      }

      // router igmp / interface * / static-group * inc-mask * *
      container static-group-inc-mask {
        tailf:cli-drop-node-name;
        list static-group {
          tailf:info "IGMP static multicast group";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          key "address inc-mask source-address";
          leaf address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP group address";
            }
          }
          leaf inc-mask {
            tailf:info "Increment mask for group address";
            tailf:cli-expose-key-name;
            tailf:cli-incomplete-command;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Increment mask for group address";
            }
          }
          leaf count {
            tailf:info "No. of group addresses to join";
            tailf:cli-prefix-key {
              tailf:cli-before-key 3;
            }
            type uint16 {
              tailf:info "<1-512>;;No. of group addresses to join";
              range "1..512";
            }
          }
          leaf source-address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Source address to join";
            }
          }
        }
      }

      // router igmp / interface * / static-group * inc-mask * * inc-mask *
      container static-group-inc-mask-source {
        tailf:cli-drop-node-name;
        list static-group {
          tailf:info "IGMP static multicast group";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          key "address inc-mask source-address source-inc-mask";
          leaf address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP group address";
            }
          }
          leaf inc-mask {
            tailf:info "Increment mask for group address";
            tailf:cli-expose-key-name;
            tailf:cli-incomplete-command;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Increment mask for group address";
            }
          }
          leaf count {
            tailf:info "No. of group addresses to join";
            tailf:cli-prefix-key {
              tailf:cli-before-key 3;
            }
            type uint16 {
              tailf:info "<1-512>;;No. of group addresses to join";
              range "1..512";
            }
          }
          leaf source-address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Source address to join";
            }
          }
          leaf source-inc-mask {
            tailf:info "Increment mask for source address";
            tailf:cli-expose-key-name;
             type inet:ipv4-address {
              tailf:info "A.B.C.D;;Increment mask for source address";
            }
          }
          leaf source-count {
            tailf:info "No. of source address to join";
            type uint16 {
              tailf:info "<1-512>;;No. of source address to join";
              range "1..512";
            }
          }
          leaf suppress-reports {
            tailf:info "Suppress IGMP reports";
            type empty;
          }
        }
      }
    }

    // router igmp / interface all router disable
    container interface-all {
      tailf:cli-drop-node-name;
      container interface {
        tailf:info "IGMP interface configuration subcommands";
        container all {
          tailf:info "All interfaces";
          container router {
            tailf:info "Router side functionality in IGMP";
            leaf disable {
              tailf:info "Disable Router side functionality in IGMP";
              type empty;
            }
          }
        }
      }
    }

    // router igmp / ssm map
    container ssm {
      tailf:info "Configure SSM specific options";
      container map {
        tailf:info "Configure mappings of SSM group membership to sources";

        // router igmp / ssm map static *
        list static {
          tailf:info "Configure a static mapping of a source to a set of SSM groups";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          key address;
          leaf address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Source address";
            }
          }
          leaf acl {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;Access list of ssm groups that should map to the given source";
            }
          }
        }
      }
    }

    // router igmp / explicit-tracking
    container explicit-tracking {
      tailf:info "IGMPv3 explicit host tracking";
      presence true;
    }

    // router igmp / version
    leaf version {
      tailf:info "IGMP version";
      type uint8 {
        tailf:info "<1-3>;;version number";
        range "1..3";
      }
    }

    // router igmp / access-group
    leaf access-group {
      tailf:info "IGMP group access group";
      type string {
        tailf:info "WORD;;IP Named Standard Access list";
      }
    }

    // router igmp / query-interval
    leaf query-interval {
      tailf:info "IGMP host query interval";
      type uint16 {
        tailf:info "<1-3600>;;Query interval in seconds";
        range "1..3600";
      }
    }

    // router igmp / query-max-response-time
    leaf query-max-response-time {
      tailf:info "IGMP max query response value";
      type uint8 {
        tailf:info "<1-12>;;query response value in seconds";
        range "1..12";
      }
    }

    // router igmp / robustness-count
    leaf robustness-count {
      tailf:info "IGMP robustness variable";
      type uint8 {
        tailf:info "<2-10>;;Robustness variable count";
        range "2..10";
      }
    }

    // router igmp / traffic profile
    container traffic {
      tailf:info "IGMP traffic variables";
      leaf profile {
        tailf:info "Configure route-policy to be used to map the bandwidth profile";
        type string {
          tailf:info "WORD;;Name of the policy";
        }
      }
    }

    // router igmp / maximum
    container maximum {
      leaf groups {
        tailf:info "Maximum number of groups accepted by this router";
        type uint32 {
          tailf:info "<1-75000>;;Maximum number of groups accepted by this router";
        }
      }
      leaf groups-per-interface {
        tailf:info "Maximum number of groups accepted per interface by this router";
        type uint32 {
          tailf:info "<1-40000>;;Maximum number of groups accepted per interface by this router";
        }
      }
    }
  }

  // l2vpn / bridge group * / bridge-domain * / mac
  // l2vpn / bridge group * / bridge-domain * / interface * / mac
  grouping l2vpn-bridge-domain-mac-grouping {

    // l2vpn / bridge group * / bridge-domain * / mac / aging
    container aging {
      tailf:info "MAC-Aging configuration commands";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-l2vpn-bg-bd-mac-aging";

      // l2vpn / bridge group * / bridge-domain * / mac / aging / time
      leaf time {
        tailf:info "Mac aging";
        type uint16 {
          tailf:info "<300-30000>;;MAC address aging time in seconds";
          range "300..30000";
        }
      }

      // l2vpn / bridge group * / bridge-domain * / mac / aging / type
      leaf type {
        tailf:info "MAC address aging type";
        type enumeration {
          enum absolute {
            tailf:info "Absolute aging type";
          }
          enum inactivity {
            tailf:info "Inactivity aging type";
          }
        }
      }
    }

    // l2vpn / bridge group * / bridge-domain * / mac / learning
    container learning {
      tailf:info "MAC learning";
      tailf:cli-delete-when-empty;
      presence true;
      leaf disable {
        tailf:info "Disable MAC learning";
        type empty;
      }
    }

    // l2vpn / bridge group * / bridge-domain * / mac / limit
    container limit {
      tailf:info "MAC-Limit configuration commands";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-l2vpn-bg-bd-ac-mac-limit";

      // l2vpn / bridge group * / bridge-domain * / mac / limit maximum
      leaf maximum {
        tailf:info "Number of MAC addresses after which MAC limit action is taken";
        type uint32 {
          tailf:info "<1-512000>;;Number of MAC addresses after which MAC limit action is taken";
          range "1..512000";
        }
      }

      // l2vpn / bridge group * / bridge-domain * / mac / limit action
      leaf action {
        tailf:info "MAC address limit enforcement action";
        type enumeration {
          enum flood {
            tailf:info "Stop learning but continue flooding";
          }
          enum no-flood {
            tailf:info "Stop learning and stop flooding";
          }
          enum none {
            tailf:info "No action";
          }
          enum shutdown {
            tailf:info "Stop forwarding";
          }
        }
      }

      // l2vpn / bridge group * / bridge-domain * / mac / limit notification
      leaf notification {
        tailf:info "MAC address limit notification action";
        type enumeration {
          enum both {
            tailf:info "Generate syslog message and SNMP trap";
          }
          enum none {
            tailf:info "No notification";
          }
          enum syslog {
            tailf:info "Generate syslog message";
          }
          enum trap {
            tailf:info "Generate SNMP trap";
          }
        }
      }
    }

    // l2vpn / bridge group * / bridge-domain * / mac / secure
    container secure {
      tailf:info "MAC Secure configuration commands";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-l2vpn-bg-bd-mac-secure";
      tailf:cli-delete-when-empty;
      presence true;

      // l2vpn / bridge group * / bridge-domain * / mac / secure / action
      leaf action {
        tailf:info "MAC secure enforcement action";
        type enumeration {
          enum none {
            tailf:info "Forward the violating packet and allow the MAC to be relearned";
          }
          enum shutdown {
            tailf:info "Shutdown the violating bridge port";
          }
          enum restrict {
            tailf:info "Drop the violating packet and not allow the MAC to be relearned";
          }
        }
      }

      // l2vpn / bridge group * / bridge-domain * / mac / secure / logging
      leaf logging {
        tailf:info "Enable Logging";
        type empty;
      }
    }
  }


  // l2vpn / bridge group * / bridge-domain * /
  // l2vpn / bridge group * / bridge-domain * / neighbor *
  grouping l2vpn-bridge-domain-grouping {

    // l2vpn / bridge group * / bridge-domain * / transport-mode vlan passthrough
    container transport-mode {
      tailf:info "Bridge domain transport mode";
      container vlan {
        tailf:info "Vlan tagged mode";
        leaf passthrough {
          tailf:info "passthrough incoming tags";
          type empty;
        }
      }
    }

    // l2vpn / bridge group * / bridge-domain * / storm-control
    uses storm-control-grouping;

    // l2vpn / bridge group * / bridge-domain * / coupled-mode
    leaf coupled-mode {
      tailf:info "Enable coupled mode for the Bridge Domain";
      type empty;
    }

    // l2vpn / bridge group * / bridge-domain * / igmp snooping profile
    container igmp {
      tailf:info "IGMP protocol";
      container snooping {
        tailf:info "Set the snooping profile";
        leaf profile {
          tailf:info "Attach an IGMP profile";
          type string {
            tailf:info "WORD;;IGMP Snooping profile name";
          }
        }
      }
    }

    // l2vpn / bridge group * / bridge-domain * / mac
    container mac {
      tailf:info "MAC configuration commands";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-l2vpn-bg-bd-mac";

      // l2vpn / bridge group * / bridge-domain * / mac / learning
      // l2vpn / bridge group * / bridge-domain * / mac / limit
      // l2vpn / bridge group * / bridge-domain * / mac / secure
      uses l2vpn-bridge-domain-mac-grouping;

      // l2vpn / bridge group * / bridge-domain * / mac / withdraw
      container withdraw {
        tailf:info "MAC withdraw";
        choice withdraw-choice {
          leaf state-down {
            tailf:info "MAC withdraw sent on bridge port down";
            type empty;
          }
          leaf optimize {
            tailf:info "Optimized LDP MAC withdraw (when port goes down)";
            type empty;
          }
          leaf disable {
            tailf:info "Disable MAC withdraw";
            type empty;
          }
        }
      }
    }

    // l2vpn / bridge group * / bridge-domain * / flooding
    container flooding {
      tailf:info "Traffic flooding";

      // l2vpn / bridge group * / bridge-domain * / flooding disable
      leaf disable {
        tailf:info "Disable flooding";
        type empty;
      }

      // l2vpn / bridge group * / bridge-domain * / flooding unknown-unicast disable
      container unknown-unicast {
        tailf:info "Traffic flooding unknown unicast";
        leaf disable {
          tailf:info "Disable Unknown Unicast flooding";
          type empty;
        }
      }
    }
  }


  grouping freqsync-quality-grouping {

    choice quality-type {
      leaf exact {
        tailf:info "Specify the exact QL value to use";
        type empty;
      }
      leaf highest {
        tailf:info "Specify the highest acceptable QL value";
        type empty;
      }
      leaf lowest {
        tailf:info "Specify the lowest acceptable QL value";
        type empty;
      }
    }

    container itu-t {
      tailf:info "ITU-T QL options";
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf option {
        tailf:info "ITU-T QL options";
        type enumeration {
          enum "1" {
            tailf:info "ITU-T QL option 1";
          }
          enum "2" {
            tailf:info "ITU-T QL option 2";
          }
        }
      }
      leaf generation {
        tailf:info "ITU-T QL option 2 generation";
        tailf:cli-incomplete-command;
        when "../option = '2'";
        type enumeration {
          enum "1" {
            tailf:info "ITU-T QL option 2, generation 1";
          }
          enum "2" {
            tailf:info "ITU-T QL option 2, generation 2";
          }
        }
      }
      leaf ql1 {
        tailf:cli-drop-node-name;
        when "../option = '1'";
        type enumeration {
          enum PRC {
          }
          enum SSU-A {
          }
          enum SSU-B {
          }
          enum SEC {
          }
          enum DNU {
          }
        }
      }
      leaf ql2 {
        tailf:cli-drop-node-name;
        when "../option = '2'";
        type enumeration {
          enum DUS {
            tailf:info "This signal should not be used for synchronization";
          }
          enum PRS {
            tailf:info "ITU-T Option 2, Primary reference source";
          }
          enum SMC {
            tailf:info "ITU-T Option 2, SONET clock self timed";
          }
          enum ST2 {
            tailf:info "ITU-T Option 2, Stratum 2";
          }
          enum ST3 {
            tailf:info "ITU-T Option 2, Stratum 3";
          }
          enum ST3E {
            tailf:info "ITU-T Option 2, Stratum 3E";
          }
          enum STU {
            tailf:info "ITU-T Option 2, Synchronized - traceability unknown";
          }
          enum TNC {
            tailf:info "ITU-T Option 2, Transit node clock";
          }
          enum ST4 {
          }
          enum PROV {
          }
        }
      }
    }
  }

  // router hsrp / interface * / address-family * / hsrp
  grouping router-hsrp-group-grouping {

    // router hsrp / interface * / address-family ipv4 / hsrp / name
    leaf name {
      tailf:info "MGO session name";
      tailf:cli-full-command;
      type string {
        tailf:info "WORD;;MGO session name";
      }
    }

    // router hsrp / interface * / address-family ipv4 / hsrp / authentication
    leaf authentication {
      tailf:info "Authentication string";
      tailf:cli-full-command;
      type string {
        tailf:info "WORD;;Authentication string";
      }
    }

    // router hsrp / interface * / address-family ipv4 / hsrp / timers
    container timers {
      tailf:info "Set hello and hold timers";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      choice hello-timer-choice {
        leaf hello-seconds {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<1-255>;;hello time in seconds";
            range "1..255";
          }
        }
        leaf msec {
          tailf:info "Specify hellotime in milliseconds";
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<100-3000>;;Hellotime in msecs";
            range "100..3000";
          }
        }
      }
      choice hold-timer-choice {
        leaf hold-seconds {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<1-255>;;hold time in seconds";
            range "1..255";
          }
        }
        container hold {
          tailf:cli-drop-node-name;
          tailf:cli-flatten-container;
          leaf msec {
            tailf:info "Specify holdtime in milliseconds";
            type uint16 {
              tailf:info "<100-3000>;;Holdtime in msecs";
              range "100..3000";
            }
          }
        }
      }
    }

    // router hsrp / interface * / address-family ipv4 / hsrp / mac-address
    leaf mac-address {
      tailf:info "Use specified mac address for the virtual router";
      tailf:cli-full-command;
      type string {
        tailf:info "H.H.H;;48-bit hardware address of ARP entry";
      }
    }

    // router hsrp / interface * / address-family ipv4 / hsrp / preempt
    container preempt {
      tailf:info "Force active if higher priority";
      tailf:cli-delete-when-empty;
      presence true;
      leaf delay {
        tailf:info "Wait before preempting";
        type uint16 {
          tailf:info "<0-3600>;;Number of seconds to delay";
          range "0..3600";
        }
        default 0;
      }
    }

    // router hsrp / interface * / address-family ipv4 / hsrp / priority
    leaf priority {
      tailf:info "Priority level";
      type uint8 {
        tailf:info "<0-255>;;Priority value";
      }
    }

    // router hsrp / interface * / address-family ipv4 / hsrp / track *
    list track {
      tailf:info "Configure tracking";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key name;
      // router hsrp / interface * / address-family ipv4 / hsrp / track object *
      leaf object {
        tailf:info "Object tracking";
        tailf:cli-prefix-key;
        type empty;
      }
      leaf name {
        tailf:cli-disallow-value "object";
        type string {
          tailf:info "WORD;;Interface or Object name";
        }
      }
      leaf priority-decrement {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-255>;;Priority decrement";
          range "1..255";
        }
        default 10;
      }
    }

    // router hsrp / interface * / address-family ipv4 / hsrp / bfd
    container bfd {
      tailf:info "Configure BFD parameters";

      // router hsrp / interface * / address-family ipv4 / hsrp / bfd fast-detect
      container fast-detect {
        tailf:info "Enable Fast detection";
        tailf:cli-delete-when-empty;
        presence true;
        container peer {
          tailf:info "Information about HSRP peer for BFD monitoring";
          container ipv4 {
            tailf:info "BFD peer interface IPv4 address";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf ipv4-address {
              tailf:cli-drop-node-name;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;HSRP BFD remote interface IP address";
              }
            }
            container interface {
              tailf:cli-drop-node-name;
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              uses interface-name-grouping;
            }
          }
          container ipv6 {
            tailf:info "BFD peer interface IPv6 address";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf ipv6-address {
              tailf:cli-drop-node-name;
              type inet:ipv6-address {
                tailf:info "X:X::X;;HSRP BFD remote interface IP address";
              }
            }
            container interface {
              tailf:cli-drop-node-name;
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              uses interface-name-grouping;
            }
          }
        }
      }

      // router hsrp / interface * / address-family ipv4 / hsrp / bfd minimum-interval
      leaf minimum-interval {
        tailf:info "Hello interval";
        type uint16 {
          tailf:info "<3-30000>;;hello interval in milli-seconds";
          range "3..30000";
        }
      }

      // router hsrp / interface * / address-family ipv4 / hsrp / bfd multiplier
      leaf multiplier {
        tailf:info "Detect multiplier";
        type uint8 {
          tailf:info "<2-50>;;Detect multiplier";
          range "2..50";
        }
      }
    }
  }

  // router hsrp / interface * / hsrp
  // router hsrp / interface * / hsrp *
  grouping router-hsrp-old-group-grouping {

    // router hsrp / interface * / hsrp X
    uses router-hsrp-group-grouping;

    // router hsrp / interface * / hsrp ipv4
    container ipv4 {
      tailf:info "Enable hot standby protocol for IP";
      leaf address {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        tailf:cli-full-no;
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Hot standby IP address";
        }
      }
      list secondary {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        key address;
        leaf address {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Hot standby IP address";
          }
        }
        leaf secondary {
          tailf:info "Set secondary hot standby IP address";
          type empty;
        }
      }
    }
  }

  grouping router-hsrp-ipv4-address-grouping {
    leaf address {
      tailf:info "Enable hot standby protocol for IP";
      tailf:cli-full-command;
      type union {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Hot standby IP address";
        }
        type enumeration {
          enum learn {
            tailf:info "Learn virtual IP address from peer";
          }
        }
      }
    }
    container address-secondary-list {
      tailf:cli-drop-node-name;
      list address {
        tailf:cli-suppress-mode;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-no;
        key address;
        leaf address {
          tailf:info "Enable hot standby protocol for IP";
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Hot standby IP address";
          }
        }
        leaf secondary {
          tailf:info "Set secondary hot standby IP address";
          type empty;
        }
      }
    }
  }

  // router hsrp / interface * / address-family ipv4 / hsrp /
  grouping router-hsrp-ipv4-group-grouping {

    // router hsrp / interface * / address-family ipv4 / hsrp / address
    uses router-hsrp-ipv4-address-grouping;

    uses router-hsrp-group-grouping;
  }

  // router hsrp / interface * / address-family ipv4 / hsrp * slave /
  grouping router-hsrp-ipv4-slave-group-grouping {
    leaf follow {
      tailf:info "Follow specified MGO session";
      tailf:cli-full-command;
      type string {
        tailf:info "WORD;;MGO session";
      }
    }
    leaf mac-address {
      tailf:info "Use specified mac address for the virtual router";
      tailf:cli-full-command;
      type string {
        tailf:info "H.H.H;;48-bit hardware address of ARP entry";
      }
    }
    uses router-hsrp-ipv4-address-grouping;
  }


  grouping router-hsrp-ipv6-address-grouping {
    container address {
      tailf:info "Enable hot standby protocol for IP";

      // router hsrp / interface * / address-family ipv6 / hsrp / address global *
      leaf-list global {
        tailf:info "Global HSRP IPv6 address";
        tailf:cli-list-syntax;
        type inet:ipv6-address {
          tailf:info "X:X::X;;Set Global HSRP IPv6 address";
        }
      }

      // router hsrp / interface * / address-family ipv6 / hsrp / address linklocal
      container linklocal {
        tailf:info "HSRP IPv6 linklocal address";
        choice linklocal-choice {
          leaf address {
            tailf:cli-drop-node-name;
            type inet:ipv6-address {
              tailf:info "X:X::X;;HSRP IPv6 linklocal address";
            }
          }
          container autoconfig {
            tailf:info "Autoconfigure the HSRP IPv6 linklocal address";
            tailf:cli-delete-when-empty;
            presence true;
            leaf legacy-compatible {
              tailf:info "Autoconfigure for Legacy compatibility (with IOS/NX-OS)";
              type empty;
            }
          }
        }
      }
    }
  }

  // router hsrp / interface * / address-family ipv6 / hsrp /
  grouping router-hsrp-ipv6-group-grouping {

    uses router-hsrp-group-grouping;

    // router hsrp / interface * / address-family ipv6 / hsrp / address
    uses router-hsrp-ipv6-address-grouping;
  }

  // router hsrp / interface * / address-family ipv6 / hsrp * slave /
  grouping router-hsrp-ipv6-slave-group-grouping {
    leaf follow {
      tailf:info "Follow specified MGO session";
      tailf:cli-full-command;
      type string {
        tailf:info "WORD;;MGO session";
      }
    }
    leaf mac-address {
      tailf:info "Use specified mac address for the virtual router";
      tailf:cli-full-command;
      type string {
        tailf:info "H.H.H;;48-bit hardware address of ARP entry";
      }
    }
    uses router-hsrp-ipv6-address-grouping;
  }


  // interface ATM* /
  grouping interface-atm-grouping {

    // interface ATM* / atm
    container atm {
      tailf:info "Global ATM interface configuration subcommands";

      // interface ATM* / atm mcpt-timers
      container mcpt-timers {
        tailf:info "Configure Maximum cell Packing Timeout Values";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf timer-1 {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<50-4095>;;MCPT timer1 value in microsecond (CEoP min value is 101)";
            range "50..4095";
          }
        }
        leaf timer-2 {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<50-4095>;;MCPT timer2 value in microsecond";
            range "50..4095";
          }
        }
        leaf timer-3 {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<60-4095>;;MCPT timer3 value in microsecond";
            range "60..4095";
          }
        }
      }

      // interface ATM* / atm ilmi-keepalive
      container ilmi-keepalive {
        tailf:info "ILMI keepalive configuration";
        presence true;
      }
    }

    // interface ATM* / pvc *
    list pvc {
      tailf:info "Configure a pvc on this interface";
      tailf:cli-mode-name "config-atm-l2transport-pvc";
      key vpi-vci;
      leaf vpi-vci {
        type string {
          tailf:info "WORD;;VPI/VCI";
        }
      }

      // interface ATM* / pvc * / service-policy
      uses interface-service-policy-grouping;

      // interface ATM* / pvc * / shape
      container shape {
        tailf:info "ATM Traffic Shaping";
        choice shape-choice {

          // interface ATM* / pvc * / shape vbr-nrt
          container vbr-nrt {
            tailf:info "Variable Bit Rate - Non Real Time";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf peak-output-rate {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint32 {
                tailf:info "<8-599040>;;Peak output rate in kbps (max:OC12 599040; OC3 149760; T1 1544; T3 44736)";
              }
            }
            leaf sustained-output-rate {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint32 {
                tailf:info "<8-599040>;;Sustained output rate (kbps)";
              }
            }
            leaf burst-size {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<1-8192>;;Burst size (cells)";
              }
            }
          }

          // interface ATM* / pvc * / shape cbr
          leaf cbr {
            tailf:info "Constant Bit Rate";
            type uint32 {
              tailf:info "<8-599040>;;Peak output rate in kbps (max:OC12 599040; OC3 149760; T1 1544; T3 44736)";
              range "8..599040";
            }
          }
        }
      }

      // interface ATM* / pvc * / encapsulation
      leaf encapsulation {
        tailf:info "Configure encapsulation on this PVC";
        tailf:cli-full-command;
        type enumeration {
          enum aal0 {
            tailf:info "Use aal0 encapsulation on this PVC";
          }
          enum aal5 {
            tailf:info "Use aal5 encapsulation on this PVC";
          }
          enum aal5mux {
            tailf:info "Use aal5mux encapsulation on this PVC";
          }
          enum aal5nlpid {
            tailf:info "Use aal5nlpid encapsulation on this PVC";
          }
          enum aal5snap {
            tailf:info "Use aal5snap encapsulation on this PVC";
          }
        }
      }

      // interface ATM* / pvc * / oam
      container oam {
        tailf:info "Configure ATM OAM VC commands";

        // interface ATM* / pvc * / oam retry
        container retry {
          tailf:info "Enter OAM to configure retry freq";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          presence true;
          leaf up-count {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<1-600>;;OAM retry count before declaring a VC as up";
            }
          }
          leaf down-count {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<1-600>;;OAM retry count before declaring a VC as down";
            }
          }
          leaf retry-frequency {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<1-1000>;;OAM retry polling frequency in seconds";
            }
          }
        }
      }

      // interface ATM* / pvc * / oam-pvc manage
      container oam-pvc {
        tailf:info "Enter OAM to generate OAM cells";
        container manage {
          tailf:info "OAM PVC management";
          tailf:cli-delete-when-empty;
          presence true;
          // interface ATM* / pvc * / oam-pvc manage disable
          leaf disable {
            tailf:info "Disable OAM PVC management";
            tailf:cli-reset-container;
            tailf:cli-full-command;
            type empty;
          }
          leaf frequency {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<0-600>;;OAM loopback frequency (seconds)";
              range "0..600";
            }
          }
        }
      }

      // interface ATM* / pvc * / cell-packing
      container cell-packing {
        tailf:info "Configure L2VPN cell packing parameters";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf cells {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<2-255>;;Maximum number of cells to be packed in a packet";
            range "2..255";
          }
        }
        leaf timer {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<1-3>;;Which cell packing timer to use";
            range "1..3";
          }
        }
      }
    }
  }


  // ipsla / operation * / type udp *
  // ipsla / operation * / type icmp *
  // ipsla / operation * / type mpls lsp *
  grouping ipsla-operation-type-grouping {

    // ipsla / operation * / type * / tag
    leaf tag {
      tailf:info "Add a tag for this operation";
      type string {
        tailf:info "WORD;;Tag string";
      }
    }

    // ipsla / operation * / type * / timeout
    leaf timeout {
      tailf:info "Probe/Control timeout interval";
      type uint32 {
        tailf:info "<1-604800000>;;Probe/Control timeout in ms (default 5000 ms)";
        range "1..604800000";
      }
    }

    // ipsla / operation * / type * / vrf
    leaf vrf {
      tailf:info "Configure IPSLA for a VPN Routing/Forwarding instance";
      type string {
        tailf:info "WORD;;VPN Routing/Forwarding instance name";
      }
    }

    // ipsla / operation * / type * / history
    container history {
      tailf:info "Configure the history parameters for this operation";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-ipsla-op-hist";

      // ipsla / operation * / type * / history / lives
      leaf lives {
        tailf:info "Lives of history kept";
        type uint8 {
          tailf:info "<0-2>;;Specify number of lives to be kept (default 0)";
          range "0..2";
        }
      }

      // ipsla / operation * / type * / history / filter failures
      leaf filter {
        tailf:info "Criteria to add operation data to history";
        type enumeration {
          enum all {
            tailf:info "Store history data for all operations";
          }
          enum failures {
            tailf:info "Store data for operations that failed";
          }
        }
      }

      // ipsla / operation * / type * / history / buckets
      leaf buckets {
        tailf:info "Buckets of history kept";
        type uint8 {
          tailf:info "<1-60>;;Specify number of buckets (default 15)";
          range "1..60";
        }
      }
    }

    // ipsla / operation * / type * / source
    container source {
      tailf:info "Address/port of the source device";

      // ipsla / operation * / type * / source address
      leaf address {
        tailf:info "IPv4 address of the source device";
        tailf:cli-full-command;
        type union {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Enter IPv4 address of the source device";
          }
          type inet:ipv6-address {
            tailf:info "X:X::X;;Enter IPv6 address of the source device";
          }
        }
      }

      // ipsla / operation * / type * / source port
      leaf port {
        tailf:info "Port number on source device";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<1-65535>;;Specify the port number";
          range "1..65535";
        }
      }
    }

    // ipsla / operation * / type * / destination
    container destination {
      tailf:info "Address/port of the target device";

      // ipsla / operation * / type * / destination address
      leaf address {
        tailf:info "IPv4 address of the target device";
        tailf:cli-full-command;
        type union {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Enter IPv4 address of the target device";
          }
          type inet:ipv6-address {
            tailf:info "X:X::X;;Enter IPv6 address of the target device";
          }
        }
      }

      // ipsla / operation * / type * / destination port
      leaf port {
        tailf:info "Port number on target device";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<1-65535>;;Specify the port number";
          range "1..65535";
        }
      }
    }

    // ipsla / operation * / type * / statistics hourly
    container statistics {
      tailf:info "Statistics collection parameters for this operation";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-ipsla-op-stats";
      tailf:cli-incomplete-command;
      leaf hourly {
        tailf:info "Statistics collection aggregated over an hour";
        tailf:cli-hide-in-submode;
        type empty;
      }

      // ipsla / operation * / type * / statistics hourly / buckets
      leaf buckets {
        tailf:info "Number of Hours for which statistics are kept";
        type uint8 {
          tailf:info "<0-25>;;Specify number of hours (default 2)";
          range "0..25";
        }
      }
    }

    // ipsla / operation * / type * / packet
    container packet {
      tailf:info "Probe packet configuration parameters";
      // ipsla / operation * / type * / packet count
      leaf count {
        tailf:info "Number of packets to be transmitted during a probe";
        type uint16 {
          tailf:info "<1-60000>;;Packet count (default 10)";
          range "1..60000";
        }
      }
      // ipsla / operation * / type * / packet interval
      leaf interval {
        tailf:info "Inter packet interval";
        type uint16 {
          tailf:info "<1-60000>;;Packet interval (default 20 ms)";
          range "1..60000";
        }
      }
    }

    // ipsla / operation * / type * / tos
    leaf tos {
      tailf:info "Type of service setting in probe packet";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<0-255>;;Type of service number";
      }
    }

    // ipsla / operation * / type * / datasize request
    container datasize {
      tailf:info "Protocol data size in payload of probe packets";
      leaf request {
        tailf:info "Payload size in request probe packet";
        type uint16 {
          tailf:info "<16-1500>;;Enter request datasize in byte";
        }
      }
    }

    // ipsla / operation * / type * / target
    container target {
      tailf:info "Target for the MPLS LSP operation";

      // ipsla / operation * / type * / target traffic-eng tunnel
      container traffic-eng {
        tailf:info "Traffic engineering target";
        leaf tunnel {
          tailf:info "TE tunnel interface";
          type uint16 {
            tailf:info "<0-65535>;;Tunnel interface number";
          }
        }
      }

      // ipsla / operation * / type * / target pseudowire
      container pseudowire {
        tailf:info "Pseudowire target";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf address {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Target address";
          }
        }
        leaf pw-id {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-4294967295>;;Virtual Circuit ID";
          }
        }
      }

      // ipsla / operation * / type * / target ipv4
      leaf ipv4 {
        tailf:info "Target specified as an IPv4 address";
        tailf:cli-full-command;
        type ipv4-prefix {
          tailf:info "A.B.C.D/prefix;;Target FEC address with mask";
        }
      }
    }

    // ipsla / operation * / type * / frequency
    leaf frequency {
      tailf:info "Frequency of the probing";
      type uint32 {
        tailf:info "<1-604800>;;Probe interval in seconds (default 60)";
        range "1..604800";
      }
    }

    // ipsla / operation * / type * / statistics interval *
    container statistics-interval {
      tailf:cli-drop-node-name;
      container statistics {
        tailf:info "Statistics collection parameters for this operation";
        list interval {
          tailf:info "Statistics collection over specified time interval";
          tailf:cli-mode-name "config-ipsla-op-stats";
          key seconds;
          leaf seconds {
            type uint16 {
              tailf:info "<1-3600>;;Interval in seconds";
              range "1..3600";
            }
          }

          // ipsla / operation * / type * / statistics interval * buckets
          leaf buckets {
            tailf:info "Maximum number of buckets to keep";
            type uint8 {
              tailf:info "<1-100>;;Buckets of enhanced statistics kept";
              range "1..100";
            }
          }
        }
      }
    }
  }


  grouping storm-control-grouping {
    container storm-control {
      tailf:info "Storm Control";
      container broadcast {
        tailf:info "Broadcast Storm Control";
        leaf kbps {
          tailf:info "Set the storm control kbps";
          type uint32 {
            tailf:info "<64-1280000>;;storm control kbps value";
            range "64..1280000";
          }
        }
        leaf pps {
          tailf:info "Set the storm control pps";
          type uint32 {
            tailf:info "<1-160000>;;storm control pps value";
            range "1..160000";
          }
        }
      }
      container multicast {
        tailf:info "Multicast Storm Control";
        leaf kbps {
          tailf:info "Set the storm control kbps";
          type uint32 {
            tailf:info "<64-1280000>;;storm control kbps value";
            range "64..1280000";
          }
        }
        leaf pps {
          tailf:info "Set the storm control pps";
          type uint32 {
            tailf:info "<1-160000>;;storm control pps value";
            range "1..160000";
          }
        }
      }
      container unknown-unicast {
        tailf:info "Unknown-unicast Storm Control";
        leaf kbps {
          tailf:info "Set the storm control kbps";
          type uint32 {
            tailf:info "<64-1280000>;;storm control kbps value";
            range "64..1280000";
          }
        }
        leaf pps {
          tailf:info "Set the storm control pps";
          type uint32 {
            tailf:info "<1-160000>;;storm control pps value";
            range "1..160000";
          }
        }
      }
    }
  }


  // vrf * / address-family ipv4 unicast
  // vrf * / address-family ipv4 flowspec
  grouping vrf-af-ipv4-grouping {

    // vrf * / address-family ipv4 unicast / import
    container import {
      tailf:info "VRF import";

      // vrf * / address-family ipv4 unicast / import route-policy
      leaf route-policy {
        tailf:info "Use route-policy for import filtering";
        tailf:cli-suppress-leafref-in-diff;
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:route-policy/name";
        }
        type string {
          tailf:info "WORD;;Name of the policy";
        }
      }

      // vrf * / address-family ipv4 unicast / import route-target
      container route-target {
        tailf:info "Specify import route target extended communities";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-vrf-import-rt";
        uses vrf-af-route-target-grouping;
      }

      // vrf * / address-family ipv4 unicast / import from
      container from {
        tailf:info "Import routes from a VRF";

        // vrf * / address-family ipv4 unicast / import from vrf advertise-as-vpn
        container vrf {
          tailf:info "VRF import";
          leaf advertise-as-vpn {
            tailf:info "Advertise imported routes to PEs";
            type empty;
          }
        }

        // vrf * / address-family ipv4 unicast / import from default-vrf
        container default-vrf {
          tailf:info "Import routes from the default VRF";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf route-policy {
            tailf:info "Use route-policy for import filtering";
            type string {
              tailf:info "WORD;;Name of the policy";
            }
          }
          leaf advertise-as-vpn {
            tailf:info "Advertise imported routes to PE";
            type empty;
          }
        }
      }
    }

    // vrf * / address-family ipv4 unicast / export
    container export {
      tailf:info "VRF export";

      // vrf * / address-family ipv4 unicast / export route-policy
      leaf route-policy {
        tailf:info "Use route-policy for export filtering";
        tailf:cli-suppress-leafref-in-diff;
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:route-policy/name";
        }
        type string {
          tailf:info "WORD;;Name of the policy";
        }
      }

      // vrf * / address-family ipv4 unicast / export route-target
      container route-target {
        tailf:info "Specify export route target extended communities";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-vrf-export-rt";
        uses vrf-af-route-target-grouping;
      }

      // vrf * / address-family ipv4 unicast / export to
      container to {
        tailf:info "Export routes to a VRF";

        // vrf * / address-family ipv4 unicast / export to vrf
        container vrf {
          tailf:info "VRF export";
          leaf allow-imported-vpn {
            tailf:info "Allow export of imported VPN routes to non-default VRF";
            type empty;
          }
        }

        // vrf * / address-family ipv4 unicast / export to default-vrf
        container default-vrf {
          tailf:info "Export routes to the default VRF";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf route-policy {
            tailf:info "Use route-policy for export";
            type string {
              tailf:info "WORD;;Name of the policy";
            }
          }
          leaf allow-imported-vpn {
            tailf:info "Export imported VPN routes to default VRF";
            type empty;
          }
        }
      }
    }

    // vrf * / address-family ipv4 unicast / maximum
    container maximum {
      tailf:info "Set maximum prefix limit";
      container prefix {
        tailf:info "Set table's maximum prefix limit";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        leaf limit {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<32-5000000>;;Maximum table's prefix limit";
            range "32..5000000";
          }
        }
        leaf mid-thresh {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<1-100>;;mid-thresh (% of max)";
            range "1..100";
          }
        }
      }
    }
  }

  // vrf * / address-family ipv6 unicast
  grouping vrf-af-ipv6-grouping {

    // vrf * / address-family ipv6 unicast / import
    container import {
      tailf:info "VRF import";

      // vrf * / address-family ipv6 unicast / import route-policy
      leaf route-policy {
        tailf:info "Use route-policy for import filtering";
        tailf:cli-suppress-leafref-in-diff;
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:route-policy/name";
        }
        type string {
          tailf:info "WORD;;Name of the policy";
        }
      }

      // vrf * / address-family ipv6 unicast / import route-target
      container route-target {
        tailf:info "Specify import route target extended communities";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-vrf-import-rt";
        uses vrf-af-route-target-grouping;
      }

      // vrf * / address-family ipv6 unicast / import from default-vrf
      container from {
        tailf:info "Import routes from a VRF";
        container default-vrf {
          tailf:info "Import routes from the default VRF";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf route-policy {
            tailf:info "Use route-policy for import filtering";
            type string {
              tailf:info "WORD;;Name of the policy";
            }
          }
          leaf advertise-as-vpn {
            tailf:info "Advertise imported routes to PE";
            type empty;
          }
        }
      }
    }

    // vrf * / address-family ipv6 unicast / export
    container export {
      tailf:info "VRF export";

      // vrf * / address-family ipv6 unicast / export route-policy
      leaf route-policy {
        tailf:info "Use route-policy for export filtering";
        tailf:cli-suppress-leafref-in-diff;
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:route-policy/name";
        }
        type string {
          tailf:info "WORD;;Name of the policy";
        }
      }

      // vrf * / address-family ipv6 unicast / export route-target
      container route-target {
        tailf:info "Specify export route target extended communities";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-vrf-export-rt";
        uses vrf-af-route-target-grouping;
      }

      // vrf * / address-family ipv6 unicast / export to
      container to {
        tailf:info "Export routes to a VRF";

        // vrf * / address-family ipv6 unicast / export to vrf
        container vrf {
          tailf:info "VRF export";
          leaf allow-imported-vpn {
            tailf:info "Allow export of imported VPN routes to non-default VRF";
            type empty;
          }
        }

        // vrf * / address-family ipv6 unicast / export to default-vrf
        container default-vrf {
          tailf:info "Export routes to the default VRF";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf route-policy {
            tailf:info "Use route-policy for export";
            type string {
              tailf:info "WORD;;Name of the policy";
            }
          }
          leaf allow-imported-vpn {
            tailf:info "Export imported VPN routes to default VRF";
            type empty;
          }
        }
      }
    }

    // vrf * / address-family ipv6 unicast / maximum prefix
    container maximum {
      tailf:info "Set maximum prefix limit";
      container prefix {
        tailf:info "Set table's maximum prefix limit";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        leaf limit {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<32-5000000>;;Maximum table's prefix limit";
            range "32..5000000";
          }
        }
        leaf mid-thresh {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<1-100>;;mid-thresh (% of max)";
            range "1..100";
          }
        }
      }
    }
  }

  // snmp-server host *
  grouping snmp-server-host-grouping {
    list host {
      tailf:info "Specify hosts to receive SNMP notifications";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      cli:ned-diff-move-before ">snmp-server host" {
        cli:arguments "when-delete";
      }
      key "address type community-string";
      leaf address {
        type string {
          tailf:info "A.B.C.D or X:X::X;;IP address of SNMP notification host";
        }
      }
      leaf type {
        type enumeration {
          enum traps {
            tailf:info "Send Trap messages to this host";
          }
          enum informs {
            tailf:info "Send Inform messages to this host";
          }
        }
      }
      leaf version {
        tailf:info "SNMP version to use for notification messages";
        tailf:cli-optional-in-sequence;
        tailf:cli-prefix-key {
          tailf:cli-before-key 3;
        }
        type enumeration {
          enum "1" {
            tailf:info "WORD;;Use 1 for SNMPv1";
          }
          enum "2c" {
            tailf:info "WORD;;Use 2c for SNMPv2c";
          }
          enum "3" {
            tailf:info "WORD;;Use 3 for SNMPv3";
          }
        }
      }
      leaf security-level {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        when "../version = '3'" {
          tailf:dependency "../version";
        }
        tailf:cli-prefix-key {
          tailf:cli-before-key 3;
        }
        type enumeration {
          enum auth {
            tailf:info "Using authNoPriv Security Level";
          }
          enum noauth {
            tailf:info "Using noAuthNoPriv Security Level";
          }
          enum priv {
            tailf:info "Using authPriv Security Level";
          }
        }
      }
      leaf enc {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        tailf:cli-prefix-key {
          tailf:cli-before-key 3;
        }
        cli:secret " host \\S+ (?:traps|informs)(?: version \\S+)?(?: auth| priv| noauth)? ((?:clear|encrypted) \\S+)" {
          cli:arguments "use-cli-id";
        }
        type enumeration {
          enum clear {
            tailf:info "Save the community string in encrypted form";
          }
          enum encrypted {
            tailf:info "Specifies an ENCRYPTED community string";
          }
        }
      }
      leaf community-string {
        tailf:cli-disallow-value "traps|informs|version|auth|noauth|clear|encrypted";
        // ISSUE: not possible to have aes128 type due to list key and NSO behaviour
        cisco-ios-xr:string-remove-quotes "<STRING>";
        type string {
          tailf:info "WORD;;The UNENCRYPTED (cleartext) community string";
        }
      }
      leaf udp-port {
        tailf:info "udp port to which notifications should be sent";
        tailf:cli-optional-in-sequence;
        type uint16 {
          tailf:info "<1-65535>;;udp port number";
          range "1..65535";
        }
      }
      leaf dying-gasp {
        tailf:info "This host will receive dying gasp trap";
        type empty;
      }
    }
  }

  grouping multicast-routing-af-grouping {

    // multicast-routing / address-family ipv4 / interface *
    list interface {
      tailf:info "Multicast interface configuration subcommands";
      tailf:cli-mode-name "config-mcast-default-ipv4-if";
      key name;
      leaf name {
        tailf:cli-disallow-value "all";
        type string {
          tailf:info "WORD;;Interface Name";
        }
      }

      // multicast-routing / address-family ipv4 / interface * / apply-group
      uses apply-group-grouping;

      // multicast-routing / address-family ipv4 / interface * / enable
      // multicast-routing / address-family ipv4 / interface * / disable
      choice status-choice {
        leaf enable {
          tailf:info "Enable IP multicast";
          tailf:cli-full-command;
          type empty;
        }
        leaf disable {
          tailf:info "Disable IP multicast";
          tailf:cli-full-command;
          type empty;
        }
      }

      // multicast-routing / address-family ipv4 / interface * / boundary
      leaf boundary {
        tailf:info "Boundary for administratively scoped multicast addresses";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;Access list specifying scoped multicast groups";
        }
      }
    }

    // multicast-routing / address-family ipv4 / interface-inheritance
    container interface-inheritance {
      tailf:info "Knob to separate enabling/disabling multicast routing & forwarding";
      leaf disable {
        tailf:info "Disable inheriting En/Dis config";
        tailf:cli-full-command;
        type empty;
      }
    }

    // multicast-routing / address-family ipv4 / nsf
    leaf nsf {
      tailf:info "Enable Cisco Non Stop Forwarding";
      tailf:cli-full-command;
      type empty;
    }

    // multicast-routing / address-family ipv4 / static
    container static {
      tailf:info "Configure a static Policy";

      // multicast-routing / address-family ipv4 / static sr-policy *
      list sr-policy {
        tailf:info "SR P2MP Policy for Multicast";
        tailf:cli-reset-container;
        tailf:cli-suppress-mode;

        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of the SR P2MP Policy";
          }
        }

        // multicast-routing / address-family ipv4 / static sr-policy * ingress
        leaf ingress {
          tailf:info "Ingress Node address of traffic (for strict-rpf)";
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Address of ingress node";
          }
        }
      }
    }

    // multicast-routing / address-family ipv4 / mdt
    container mdt {
      tailf:info "MVPN configuration";

      // multicast-routing / address-family ipv4 / mdt mtu
      leaf mtu {
        tailf:info "MDT mtu configuration";
        type uint16 {
          tailf:info "<1401-65535>;;MTU value";
          range "1401..65535";
        }
      }

      // multicast-routing / address-family ipv4 / mdt source
      container source {
        tailf:info "Interface used to set MDT source address";
        uses interface-name-grouping;
      }

      // multicast-routing / address-family ipv4 / mdt partitioned
      container partitioned {
        tailf:info "MDT Partitioned distribution tree";

        // multicast-routing / address-family ipv4 / mdt partitioned mldp
        container mldp {
          tailf:info "mLDP signaled distribution tree";
          leaf ipv4 {
            tailf:info "IPv4 core";
            type enumeration {
              enum mp2mp {
                tailf:info "Enable mLDP MP2MP core tree";
              }
              enum p2mp {
                tailf:info "Enable mLDP P2MP core tree";
              }
            }
          }
        }
      }

      // multicast-routing / address-family ipv4 / mdt static p2mp-te tunnel-mte*
      container static {
        tailf:info "Interface used to set MDT source address";
        container p2mp-te {
          tailf:info "static p2mp-te";
          list tunnel-mte {
            tailf:info "MPLS Traffic Engineering P2MP Tunnel interface(s) | short name";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-allow-join-with-key;
            key id;
            leaf id {
              tailf:info "tunnel-mte interface id";
              type uint16 {
                tailf:info "<0-65535>";
              }
            }
          }
        }

        // multicast-routing / address-family ipv4 / mdt static segment-routing
        container segment-routing {
          tailf:info "Set segment routing as MDT core";
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          presence true;

          // multicast-routing / address-family ipv4 / mdt static segment-routing strict-rpf
          leaf strict-rpf {
            tailf:info "Enable strict RPF check";
            type empty;
          }
        }
      }

      // multicast-routing / address-family ipv4 / mdt mldp in-band-signaling ipv4
      container mldp {
        tailf:info "mLDP distribution tree";
        container in-band-signaling {
          tailf:info "Enable mLDP in-band-signalling";
          leaf ipv4 {
            tailf:info "Enable IPv4-core tree";
            type empty;
          }
        }
      }

      // multicast-routing / address-family ipv4 / mdt data
      container data {
        tailf:info "Data MDT configuration";

        // multicast-routing / address-family ipv4 / mdt data <max-data-mdts>
        container value {
          tailf:cli-drop-node-name;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf max-data-mdts {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-4294967295>;;Maximum number of data-mdts to be triggered";
              range "1..4294967295";
            }
          }
          uses multicast-routing-af-mdt-data-grouping;
        }

        // multicast-routing / address-family ipv4 / mdt data a.b.c.d
        container address {
          tailf:cli-drop-node-name;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf mdt-group-address {
            tailf:cli-drop-node-name;
            type ipv4-prefix {
              tailf:info "A.B.C.D/length;;Data MDT group IP address/prefix length";
            }
          }
          uses multicast-routing-af-mdt-data-grouping;
        }

        // multicast-routing / address-family ipv4 / mdt data p2mp-te
        container p2mp-te {
          tailf:info "P2MPTE Data MDT core";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf max-data-mdts {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-4294967295>;;Maximum number of data-mdts to be triggered";
              range "1..4294967295";
            }
          }
          uses multicast-routing-af-mdt-data-grouping;
        }

        // multicast-routing / address-family ipv4 / mdt data mldp
        container mldp {
          tailf:info "MLDP Data MDT";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf max-data-mdts {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-4294967295>;;Maximum number of data-mdts to be triggered";
              range "1..4294967295";
            }
          }
          uses multicast-routing-af-mdt-data-grouping;
        }
      }

      // multicast-routing / address-family ipv4 / mdt default
      container default {
        tailf:info "MDT Default distribution tree";

        // multicast-routing / address-family ipv4 / mdt default ipv4
        leaf ipv4 {
          tailf:info "IPv4 encapsulated MDT";
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IPv4 address MDT default group";
          }
        }

        // multicast-routing / address-family ipv4 / mdt default mldp
        container mldp {
          tailf:info "mLDP default distribution tree";

          // multicast-routing / address-family ipv4 / mdt default mldp ipv4 *
          list ipv4 {
            tailf:info "MP2MP core-tree with IPv4 Root Address";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            key address;
            leaf address {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Root address";
              }
            }
            container partitioned {
              tailf:info "mLDP Partitioned MDT";
              leaf bidir {
                tailf:info "Enable Exclusive Partitioned MDT for Bidir";
                type empty;
              }
            }
          }

          // multicast-routing / address-family ipv4 / mdt default mldp p2mp
          container p2mp {
            tailf:info "P2MP core-tree";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            tailf:cli-delete-when-empty;
            presence true;
            container partitioned {
              tailf:info "mLDP Partitioned MDT";
              leaf bidir {
                tailf:info "Enable Exclusive Partitioned MDT for Bidir";
                type empty;
              }
            }
          }
        }

        // multicast-routing / address-family ipv4 / mdt default p2mp-te
        container p2mp-te {
          tailf:info "P2MP-TE default distribution tree";
          tailf:cli-delete-when-empty;
          presence true;

          // multicast-routing / address-family ipv4 / mdt default p2mp-te attribute-set
          leaf attribute-set {
            tailf:info "The Attribute Set template to be used with the TE tunnel request";
            type string {
              tailf:info "WORD;;Name of template describing the Attribute Set";
            }
          }

          // multicast-routing / address-family ipv4 / mdt default p2mp-te static
          container static {
            tailf:info "Static P2MP-TE Tunnel";
            leaf tunnel-mte {
              tailf:cli-allow-join-with-value {
                tailf:cli-display-joined;
              }
              type uint16 {
                tailf:info "<0-65535>;;MPLS Traffic Engineering P2MP Tunnel interface(s)";
              }
            }
          }
        }
      }
    }

    // multicast-routing / address-family ipv4 / export-rt
    leaf export-rt {
      tailf:info "Configure Export Route-Target";
      type string {
        tailf:info "WORD;;AS number in 2-byte, 4-byte asplain or IPv4Address:index";
      }
    }

    // multicast-routing / address-family ipv4 / import-rt
    leaf import-rt {
      tailf:info "Configure Import Route-Target";
      type string {
        tailf:info "WORD;;AS number in 2-byte, 4-byte asplain or IPv4Address:index";
      }
    }

    // multicast-routing / address-family ipv4 / log-traps
    leaf log-traps {
      tailf:info "Enable logging trap events";
      type empty;
    }

    // multicast-routing / address-family ipv4 / maximum disable
    container maximum {
      tailf:info "Maximum state limits(cisco-support)";
      leaf disable {
        tailf:info "Disable all multicast state limit checks(cisco-support)";
        type empty;
      }
    }

    // multicast-routing / address-family ipv4 / bgp
    container bgp {
      tailf:info "Enable BGP MVPN Discovery";

      // multicast-routing / address-family ipv4 / bgp auto-discovery
      container auto-discovery {
        tailf:info "Enable BGP Auto-Discovery";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-mcast-vrf-ipv4-bgp-ad";
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        leaf ad-tree {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum ingress-replication {
              tailf:info "IR core tree";
            }
            enum mldp {
              tailf:info "mLDP core tree";
            }
            enum p2mp-te {
              tailf:info "RSVP P2MP-TE core tree";
            }
            enum pim {
              tailf:info "PIM core tree";
            }
          }
        }

        // multicast-routing / address-family ipv4 / bgp auto-discovery / inter-as
        leaf inter-as {
          tailf:info "Inter-AS MVPN";
          tailf:cli-break-sequence-commands;
          type empty;
        }

        // multicast-routing / address-family ipv4 / bgp auto-discovery / receiver-site
        leaf receiver-site {
          tailf:info "Receiver-only site";
          type empty;
        }

        // multicast-routing / address-family ipv4 / bgp auto-discovery / leaf-info-required
        leaf leaf-info-required {
          tailf:info "Explicit tracking of S-PMSI core trees";
          type empty;
        }

        // multicast-routing / address-family ipv4 / bgp auto-discovery / anycast-rp
        container anycast-rp {
          tailf:info "Enable Anycast RP using MVPN SAFI";
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          presence true;
          leaf route-policy {
            tailf:info "Policy for filtering routes";
            type string {
              tailf:info "WORD;;Policy name";
            }
          }
        }
      }
    }

    // multicast-routing / address-family ipv4 / multipath
    container multipath {
      tailf:info "Enable equal-cost multipath routing";
      tailf:cli-delete-when-empty;
      presence true;

      // multicast-routing / address-family ipv4 / multipath hash
      leaf hash {
        tailf:info "Enter a hashing algorithm";
        type enumeration {
          enum source {
            tailf:info "Enable source based multipath hashing (Compatible with IOS versions)";
          }
          enum source-group {
            tailf:info "Enable source, group based multipath hashing";
          }
          enum source-nexthop {
            tailf:info "Enable source with next-hop multipath hashing (better distribution)";
          }
        }
      }
    }

    // multicast-routing / address-family ipv4 / core-tree-protocol rsvp-te
    container core-tree-protocol {
      tailf:info "Configure Core-tree-protocol";
      container rsvp-te {
        tailf:info "Configure P2MP-TE as the Core-tree-protocol";
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        leaf group-list {
          tailf:info "ACL for group-list";
          type string {
            tailf:info "WORD;;Access list specifying group range";
          }
        }
      }
    }

    // multicast-routing / address-family ipv4 / ssm
    container ssm {
      tailf:info "Configure a group range for Source-Specific use";

      // multicast-routing / address-family ipv4 / ssm range
      leaf range {
        tailf:info "Provide ACL that specifies non-standard SSM range";
        tailf:cli-suppress-leafref-in-diff;
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:ipv4/access-list/named-acl/name";
        }
        type string {
          tailf:info "WORD;;Access list specifying SSM group range";
        }
      }

      // multicast-routing / address-family ipv4 / ssm allow-override
      leaf allow-override {
        tailf:info "Allow SSM ranges to be overridden by more specific ranges";
        type empty;
      }
    }

    // multicast-routing / address-family ipv4 / oom-handling
    container oom-handling {
      tailf:info "Enable out-of-memory handling";
      presence true;
    }

    // multicast-routing / address-family ipv4 / rate-per-route
    leaf rate-per-route {
      tailf:info "Enable/disable per (S,G) rate calculation";
      tailf:cli-full-command;
      type empty;
    }

    // multicast-routing / address-family ipv4 / interface all enable
    container interface-all {
      tailf:cli-drop-node-name;
      container interface {
        tailf:info "Multicast interface configuration subcommands";
        container all {
          tailf:info "Inherited by all interfaces";
          leaf enable {
            tailf:info "Enable IP Multicast";
            type empty;
          }
        }
      }
    }

    // multicast-routing / address-family ipv4 / accounting per-prefix
    container accounting {
      tailf:info "Enable/disable Accounting";
      container per-prefix {
        tailf:info "Enable per (S,G) accounting.";
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        // multicast-routing / address-family ipv4 / accounting per-prefix forward-only
        leaf forward-only {
          tailf:info "Enable per (S,G) forward-only accounting.";
          type empty;
        }
      }
    }

    // multicast-routing / address-family ipv4 / mdt mldp in-band-signaling ipv4
  }

  // multicast-routing /
  // multicast-routing / vrf /
  grouping multicast-routing-grouping {

    // multicast-routing / address-family
    container address-family {
      tailf:info "Enter Address Family command mode";

      // multicast-routing / address-family ipv4
      container ipv4 {
        tailf:info "IPv6 Address Family";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-mcast-ipv4";
        presence true;
        uses multicast-routing-af-grouping;
      }

      // multicast-routing / address-family ipv6
      container ipv6 {
        tailf:info "IPv6 Address Family";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-mcast-ipv6";
        presence true;
        uses multicast-routing-af-grouping;
      }
    }
  }


  // router mld  /
  // router mld  / vrf * /
  grouping router-mld-grouping {

    // router mld / version
    leaf version {
      tailf:info "MLD version";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<1-2>;;version number";
        range "1..2";
      }
    }

    // router mld / interface *
    list interface {
      tailf:info "MLD interface configuration subcommands";
      tailf:cli-mode-name "config-mld-default-if";
      key name;
      leaf name {
        type ifname;
      }

      // router mld / interface * / apply-group
      uses apply-group-grouping;

      // router mld / interface * / version
      leaf version {
        tailf:info "MLD version";
        type uint8 {
          tailf:info "<1-2>;;version number";
          range "1..2";
        }
      }

      // router mld / interface * / router
      leaf router {
        tailf:info "Enable/Disable Router side functionality in MLD";
        tailf:cli-full-command;
        type enumeration {
          enum enable {
            tailf:info "Enable Router side functionality in MLD";
          }
          enum disable {
            tailf:info "Disable Router side functionality in MLD";
          }
        }
      }

      // router mld / interface * / static-group *
      list static-group {
        tailf:info "MLD static multicast group";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key "group-address source-address";
        leaf group-address {
          type inet:ipv6-address {
            tailf:info "X:X::X;;IP group address";
          }
        }
        leaf inc-mask {
          tailf:info "Increment mask for group address";
          tailf:cli-optional-in-sequence;
          tailf:cli-prefix-key {
            tailf:cli-before-key 2;
          }
          type inet:ipv6-address {
            tailf:info "X:X::X;;Increment mask for group address";
          }
        }
        leaf count {
          tailf:info "No. of group addresses to join";
          when "../inc-mask";
          type uint16 {
            tailf:info "<1-512>;;No. of group addresses to join";
          }
        }
        leaf source-address {
          type inet:ipv6-address {
            tailf:info "X:X::X;;Source address to join";
          }
        }
      }
    }
  }

  // router pim / address-family ipv4 /
  // router pim / address-family ipv6 /
  // router pim / address-family * / interface * /
  grouping router-pim-if-grouping {

    // router pim / address-family ipv4 / hello-interval
    leaf hello-interval  {
      tailf:info "Inherited by all interfaces : Hello interval in seconds";
      type uint16 {
        tailf:info "<1-3600>;;Hello interval in seconds";
        range "1..3600";
      }
    }

    // router pim / address-family ipv4 / dr-priority
    leaf dr-priority {
      tailf:info "PIM Hello DR priority";
      tailf:cli-full-command;
      type uint32 {
        tailf:info "<0-4294967295>;;Hello DR priority, preference given to larger value";
      }
    }

    // router pim / address-family ipv4 / neighbor-filter
    leaf neighbor-filter {
      tailf:info "Neighbor filter";
      type string {
        tailf:info "WORD;;IP named access list";
      }
    }

    // router pim / address-family ipv4 / join-prune-mtu
    leaf join-prune-mtu {
      tailf:info "Inherited by all interfaces : Join-Prune MTU";
      type uint16 {
        tailf:info "<576-65535>;;Join-Prune MTU in bytes";
        range "576..65535";
      }
    }
  }

  // router pim / address-family ipv4 /
  // router pim / address-family ipv6 /
  grouping router-pim-af-grouping {

    // router pim / address-family * / allow-rp
    container allow-rp {
      tailf:info "Sparse-Mode RP addresses to be allowed";
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      presence true;
      leaf rp-list {
        tailf:info "Access-list for allowed RP addresses";
        type string {
          tailf:info "WORD;;ACL Name for rp-list";
        }
      }
      leaf group-list {
        tailf:info "Access-list for allowed group ranges";
        type string {
          tailf:info "WORD;;Access name for group-list";
        }
      }
    }

    // router pim / address-family * / register-source
    container register-source {
      tailf:info "Source address to use for register messages";
      uses interface-name-grouping;
    }

    // router pim / address-family * / rpf topology route-policy *
    container rpf {
      tailf:info "RPF commands";
      container topology {
        tailf:info "Select RPF topology";
        leaf route-policy {
          tailf:info "Route policy to select RPF topology";
          tailf:cli-suppress-leafref-in-diff;
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:route-policy/name";
          }
          type string {
            tailf:info "WORD;;Name of the policy";
          }
        }
      }
    }

    // router pim / address-family * / rpf-vector
    container rpf-vector {
      tailf:info "Enable PIM RPF Vector";
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      presence true;
      leaf allow-ebgp {
        tailf:info "Allow origination of RPF vector over an eBGP session";
        type empty;
      }
      leaf disable-ibgp {
        tailf:info "Disable origination of RPF vector over an iBGP session";
        type empty;
      }
      leaf use-standard-encoding {
        tailf:info "Use RFC standard encode type";
        type empty;
      }
    }

    // router pim / address-family * / mdt
    container mdt {
      tailf:info "Multicast Distribution Tree commands";

      // router pim / address-family * / mdt c-multicast-routing
      container c-multicast-routing {
        tailf:info "MVPN customer routing commands";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-pim-default-ipv4-mdt-cmcast";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        choice protocol-choice {
          leaf bgp {
            tailf:info "BGP customer multicast routing";
            tailf:cli-hide-in-submode;
            tailf:cli-full-command;
            type empty;
          }
          leaf pim {
            tailf:info "PIM customer multicast routing";
            tailf:cli-hide-in-submode;
            tailf:cli-full-command;
            type empty;
          }
        }

        // router pim / address-family * / mdt c-multicast-routing * / migration
        container migration {
          tailf:cli-break-sequence-commands;
          tailf:info "customer routing migration";
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          presence true;
          leaf route-policy {
            tailf:info "Route policy to select customer routing";
            type string {
              tailf:info "WORD;;Name of the policy";
            }
          }
        }

        // router pim / address-family * / mdt c-multicast-routing * / unicast-reachability
        container unicast-reachability {
          tailf:info "Control addition of Extended Communities to Unicast VPN-IP routes";
          tailf:cli-compact-syntax;
          // router pim / address-family * / mdt c-multicast-routing * / unicast-reachability connector
          leaf connector {
            tailf:info "Enable/Disable Connector";
            type enumeration {
              enum disable {
                tailf:info "Disable Connector Attribute";
              }
              enum enable {
                tailf:info "Enable Connector Attribute";
              }
            }
          }
        }

        // router pim / address-family * / mdt c-multicast-routing * / announce-pim-join-tlv
        leaf announce-pim-join-tlv {
          tailf:info "Announce PIM MDT Join TLVs";
          tailf:cli-full-command;
          type empty;
        }
      }
    }

    // router pim / address-family * / accept-register
    leaf accept-register {
      tailf:info "Registers accept filter";
      type string {
        tailf:info "WORD;;IP named access list";
      }
    }

    // router pim / address-family * / spt-threshold
    container spt-threshold {
      tailf:info "Configure threshold for switching to SPT on last-hop";
      container infinity {
        tailf:info "Always stay on shared-tree";
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        leaf group-list {
          tailf:info "Only stay on the shared-tree for specified groups";
          type string {
            tailf:info "WORD;;Access-list of threshold limited groups";
          }
        }
      }
    }

    // router pim / address-family * / maximum
    uses router-pim-af-maximum-grouping;

    // router pim / address-family * / global maximum
    container global {
      tailf:info "Global maximum limit";
      uses router-pim-af-maximum-grouping;
    }

    // router pim / address-family * / neighbor-check-on-recv
    container neighbor-check-on-recv {
      tailf:info "Check for PIM neighbor before rcv'ing control messages";
      leaf enable {
        tailf:info "Enable this feature";
        type empty;
      }
    }

    // router pim / address-family * / neighbor-check-on-send
    container neighbor-check-on-send {
      tailf:info "Check for PIM neighbor before sending control messages";
      leaf enable {
        tailf:info "Enable this feature";
        type empty;
      }
    }

    // router pim / address-family * / log neighbor changes
    container log {
      tailf:info "Enable PIM logging";
      container neighbor {
        tailf:info "Enable PIM neighbor logging";
        leaf changes {
          tailf:info "Enable PIM neighbor state logging";
          type empty;
        }
      }
    }

    // router pim / address-family * / old-register-checksum
    leaf old-register-checksum {
      tailf:info "Generate registers compatible with older IOS versions";
      type empty;
    }

    // router pim / address-family * / multipath
    container multipath {
      tailf:info "Enable equal-cost multipath routing";
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      presence true;
      leaf hash {
        tailf:info "Enter a hashing algorithm";
        type enumeration {
          enum source {
            tailf:info "Enable source based multipath hashing (Compatible with IOS versions)";
          }
          enum source-group {
            tailf:info "Enable source, group based multipath hashing (Compatible with IOS versions)";
          }
          enum source-nexthop {
            tailf:info "Enable source with next-hop multipath hashing (better distribution)";
          }
        }
      }
    }

    // router pim / address-family * / ssm range
    container ssm {
      tailf:info "Configure a group range for Source-Specific use";
      leaf range {
        tailf:info "Provide ACL that specifies non-standard SSM range";
        type string {
          tailf:info "WORD;;Access list specifying SSM group range";
        }
      }
    }

    uses router-pim-if-grouping;

    // router pim / address-family * / interface *
    list interface {
      tailf:info "PIM interface configuration subcommands";
      tailf:cli-mode-name "config-pim-ipv4-if";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Interface Name";
        }
      }

      // router pim / address-family * / interface * / apply-group
      uses apply-group-grouping;

      // router pim / address-family * / interface * / bfd
      uses bfd-common-parameters-grouping;

      // router pim / address-family * / interface * / bsr-border
      leaf bsr-border {
        tailf:info "Do not fwd BSR messages on this interface";
        type empty;
      }

      // router pim / address-family * / interface * / enable
      // router pim / address-family * / interface * / disable
      choice status-choice {
        leaf enable {
          tailf:info "Enable PIM processing on this interface";
          tailf:cli-full-command;
          type empty;
        }
        leaf disable {
          tailf:info "Disable PIM processing on this interface";
          tailf:cli-full-command;
          type empty;
        }
      }

      uses router-pim-if-grouping;
    }
  }

  // router pim / address-family * / maximum
  // router pim / address-family * / global maximum
  grouping router-pim-af-maximum-grouping {
    container maximum {
      tailf:info "Maximum state limits";

      // router pim / address-family * / maximum route-interfaces
      container route-interfaces {
        tailf:info "PIM total interfaces on routes for all VRFs";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf value {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-1100000>;;Maximum PIM route-interfaces";
            range "1..1100000";
          }
        }
        leaf threshold {
          tailf:info "Set threshold to print warning";
          type uint32 {
            tailf:info "<1-1100000>;;Threshold value";
            range "1..1100000";
          }
        }
      }

      // router pim / address-family * / maximum routes
      container routes {
        tailf:info "PIM routes for all VRFs";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf value {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-200000>;;Maximum PIM routes";
            range "1..200000";
          }
        }
        leaf threshold {
          tailf:info "Set threshold to print warning";
          type uint32 {
            tailf:info "<1-200000>;;Threshold value";
            range "1..200000";
          }
        }
      }

      // router pim / address-family * / maximum group-mappings
      container group-mappings {
        tailf:info "PIM group-to-RP mapping ranges";

        // router pim / address-family * / maximum group-mappings bsr
        container bsr {
          tailf:info "Learned through the BSR distribution mechanism";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf value {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<1-10000>;;Maximum PIM group-mapping learnt from BSR";
              range "1..10000";
            }
          }
          leaf threshold {
            tailf:info "Set threshold to print warning";
            type uint16 {
              tailf:info "<1-10000>;;Threshold value";
              range "1..10000";
            }
          }
        }
      }

      // router pim / address-family * / maximum bsr
      container bsr {
        tailf:info "BSR maximum C-RP cache setting";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf crp-cache {
          tailf:info "Set maximum number of C-RP cache in BSR";
          type uint16 {
            tailf:info "<1-10000>;;Maximum number of C-RP cache";
            range "1..10000";
          }
        }
        leaf threshold {
          tailf:info "Set threshold to print warning";
          type uint16 {
            tailf:info "<1-uint16>;;Threshold value";
          }
        }
      }

      // router pim / address-family * / maximum register-states
      container register-states {
        tailf:info "PIM source register states for all VRFs";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf source {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<0-75000>;;Maximum PIM sparse-mode source register states";
          }
        }
        leaf threshold {
          tailf:info "Set threshold to print warning";
          type uint8 {
            tailf:info "<0-100>;;Threshold value";
          }
        }
      }
    }
  }

  // router pim / address-family ipv4 /
  grouping router-pim-af4-grouping {
    uses router-pim-af-grouping;

    // router pim / address-family ipv4 / rp-address *
    list rp-address {
      tailf:info "Configure Rendezvous Point";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      key name;
      leaf name {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;IP name or address of Rendezvous Point";
        }
      }
      leaf group-access-list {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        tailf:cli-disallow-value "override|bidir";
        type string {
          tailf:info "WORD;;Access list of groups that should map to given RP";
        }
      }
      leaf override {
        tailf:info "Static RP config overrides auto-rp and BSR";
        tailf:cli-optional-in-sequence;
        type empty;
      }
      leaf bidir {
        tailf:info "Specify keyword bidir to configure a bidir RP";
        type empty;
      }
    }

    // router pim / address-family ipv4 / bsr
    container bsr {
      tailf:info "BSR Configurations";

      // router pim / address-family ipv4 / bsr candidate-bsr
      container candidate-bsr {
        tailf:info "configure candidate BSR";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf address {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "A.B.C.D;;IP address of configured BSR";
          }
        }
        leaf hash-mask-len {
          tailf:info "BSR Hash Mask Length";
          tailf:cli-optional-in-sequence;
          type uint8 {
            tailf:info "<0-32>;;mask length";
            range "0..32";
          }
        }
        leaf priority {
          tailf:info "BSR Priority";
          type uint8 {
            tailf:info "<1-255>;;priority";
            range "1..255";
          }
        }
      }

      // router pim / address-family ipv4 / bsr candidate-rp *
      list candidate-rp {
        tailf:info "BSR Candidate RP Configurations";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-incomplete-command;
        key address;
        leaf address {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP address of BSR Candidate-RP";
          }
        }
        leaf group-list {
          tailf:info "Group List access-list";
          tailf:cli-optional-in-sequence;
          type string {
            tailf:info "WORD;;access-list";
          }
        }
        leaf priority {
          tailf:info "C-RP Priority";
          tailf:cli-optional-in-sequence;
          type uint8 {
            tailf:info "<1-255>;;priority";
            range "1..255";
          }
        }
        leaf interval {
          tailf:info "C-RP Advertisement interval";
          tailf:cli-optional-in-sequence;
          type uint16 {
            tailf:info "<30-600>;;interval in second";
            range "30..600";
          }
        }
        leaf bidir {
          tailf:info "To specify group ranges as Bidir";
          type empty;
        }
      }
    }

    // router pim / address-family ipv4 / sr-p2mp-policy * /
    list sr-p2mp-policy {
      tailf:info "Segment-routing P2MP policy";
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Name of the P2MP policy";
        }
      }

      // router pim / address-family ipv4 / sr-p2mp-policy * / static-group * *
      list static-group {
        tailf:info "ipv4 static multicast group";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "address source-address";
        leaf address {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP group address";
          }
        }
        leaf source-address {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Source address to join";
          }
        }
      }

      // router pim / address-family ipv4 / sr-p2mp-policy * / static-group * inc-mask *
      container static-group-inc-mask {
        tailf:cli-drop-node-name;
        list static-group {
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          key "address inc-mask";
          leaf address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP group address";
            }
          }
          leaf inc-mask {
            tailf:cli-expose-key-name;
            tailf:info "Increment mask for group address";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Increment mask for group address";
            }
          }
          leaf count {
            tailf:info "No. of group addresses to join";
            type uint16 {
              tailf:info "<1-512>;;No. of group addresses to join";
            }
          }
        }
      }

      // router pim / address-family ipv4 / sr-p2mp-policy * / static-group * * inc-mask *
      container static-group-src-inc-mask {
        tailf:cli-drop-node-name;
        list static-group {
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          key "address source-address inc-mask";
          leaf address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP group address";
            }
          }
          leaf source-address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Source address to join";
            }
          }
          leaf inc-mask {
            tailf:cli-expose-key-name;
            tailf:info "Increment mask for source address";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Increment mask for group address";
            }
          }
          leaf count {
            tailf:info "No. of source addresses to join";
            type uint16 {
              tailf:info "<1-512>;;No. of source addresses to join";
            }
          }
        }
      }
    }
  }

  // router pim / address-family ipv6 /
  grouping router-pim-af6-grouping {
    uses router-pim-af-grouping;
    // router pim / address-family ipv6 / rp-address *
    list rp-address {
      tailf:info "Configure Rendezvous Point";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      key name;
      leaf name {
        type inet:ipv6-address {
          tailf:info "X:X::X;;IP name or address of Rendezvous Point";
        }
      }
      leaf group-access-list {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        tailf:cli-disallow-value "override|bidir";
        type string {
          tailf:info "WORD;;Access list of groups that should map to given RP";
        }
      }
      leaf override {
        tailf:info "Static RP config overrides auto-rp and BSR";
        tailf:cli-optional-in-sequence;
        type empty;
      }
      leaf bidir {
        tailf:info "Specify keyword bidir to configure a bidir RP";
        type empty;
      }
    }
  }

  grouping router-pim-grouping {

    // router pim / address-family
    container address-family {
      tailf:info "Enter Address Family command mode";

      // router pim / address-family ipv4
      container ipv4 {
        tailf:info "Enter ipv4 Address Family command mode";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-pim-default-ipv4";

        // router pim / address-family ipv4 / auto-rp
        container auto-rp {
          tailf:info "Auto-RP Commands";

          // router pim / address-family ipv4 / auto-rp candidate-rp *
          list candidate-rp {
            tailf:info "Configure as a Candidate RP";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            tailf:cli-incomplete-command;
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;Interface Name";
              }
            }
            leaf scope {
              tailf:info "TTL for the announcement";
              type uint8 {
                tailf:info "<1-255>;;TTL in hops";
                range "1..255";
              }
            }
            leaf group-list {
              tailf:info "Be a candidate RP for groups specified by the acl";
              type string {
                tailf:info "WORD;;Access-list of groups to be RP for";
              }
            }
            leaf interval {
              tailf:info "number of seconds between announcements";
              type uint16 {
                tailf:info "<1-600>;;time between announcements <in seconds>";
                range "1..600";
              }
            }
            leaf bidir {
              tailf:info "to specify group ranges as bidir, default is pim-sm";
              type empty;
            }
          }

          // router pim / address-family ipv4 / auto-rp listen disable
          container listen {
            tailf:info "RP discovery through AUTORP protocol";
            leaf disable {
              tailf:info "Disable RP discovery through the AUTORP protocol";
              type empty;
            }
          }
        }

        // router pim / address-family ipv4 / nsf lifetime
        container nsf {
          tailf:info "Configure Non-stop forwarding (NSF) options(cisco-support)";
          leaf lifetime {
            tailf:info "Override default maximum lifetime for PIM NSF mode";
            type uint16 {
              tailf:info "<10-600>;;Maximum time for PIM NSF mode in seconds";
              range "10..600";
            }
          }
        }

        // router pim / address-family ipv4 / X
        uses router-pim-af4-grouping;
      }

      // router pim / address-family ipv6
      container ipv6 {
        tailf:info "Enter ipv6 Address Family command mode";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-pim-default-ipv6";

        // router pim / address-family ipv6 / X
        uses router-pim-af6-grouping;
      }
    }
  }

  grouping router-rip-redistribute-grouping {
    leaf route-policy {
      tailf:info "Route policy reference";
      tailf:cli-suppress-leafref-in-diff;
      tailf:non-strict-leafref {
        path "/cisco-ios-xr:route-policy/name";
      }
      type string {
        tailf:info "WORD;;Name of the policy";
      }
    }
  }


  // router rip /
  // router rip / interface * /
  grouping router-rip-if-grouping {

    // router rip / broadcast-for-v2
    leaf broadcast-for-v2 {
      tailf:info "Specify broadcast address for RIP v2 output packet";
      type empty;
    }

    // router rip / route-policy * in|out
    uses route-policy-list-grouping;
  }

  grouping router-rip-grouping {

    // router rip / interface *
    list interface {
      tailf:info "Enter the RIP interface configuration submode";
      tailf:cli-mode-name "config-rip-if";
      key name;
      leaf name {
        type ifname;
      }

      // router rip / interface * / apply-group
      uses apply-group-grouping;

      // router rip / interface * / authentication keychain
      container authentication {
        tailf:info "Authentication control";
        container keychain {
          tailf:info "Configure an authentication key chain";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf name {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;Name of the key chain";
            }
          }
          leaf mode {
            tailf:info "Authentication mode";
            type enumeration {
              enum md5 {
                tailf:info "Keyed message digest";
              }
              enum text {
                tailf:info "Clear text authentication";
              }
            }
          }
        }
      }

      // router rip / interface * / passive-interface
      leaf passive-interface {
        tailf:info "Suppress routing updates on this interface";
        tailf:cli-full-command;
        type empty;
      }

      container send {
        tailf:info "Advertisement transmission";
        // router rip / interface * / send version
        leaf version {
          tailf:info "Version control";
          type enumeration {
            enum "1" {
              tailf:info "RIP version 1";
            }
            enum "2" {
              tailf:info "RIP version 2";
            }
          }
        }
      }

      uses router-rip-if-grouping;
    }

    // router rip / timers basic
    container timers {
      tailf:info "Adjust routing timers";
      container basic {
        tailf:info "Basic routing protocol update timers";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf update {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<5-50000>;;Interval between updates";
          }
        }
        leaf invalid {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<15-200000>;;Invalid";
          }
        }
        leaf holddown {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<15-200000>;;Holddown";
          }
        }
        leaf flush {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<16-250000>;;Flush";
          }
        }
      }
    }

    // router rip / redistribute
    container redistribute {
      tailf:info "Redistribute information from another routing protocol";

      // router rip / redistribute connected
      container connected {
        tailf:info "Connected";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-rip-redistribute-grouping;
      }

      // router rip / redistribute static
      container static {
        tailf:info "Static";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-rip-redistribute-grouping;
      }

      // router rip / redistribute bgp
      list bgp {
        tailf:info "Border Gateway Protocol (BGP)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;AS number in 2-byte, 4-byte asdot and asplain";
          }
        }
        uses router-rip-redistribute-grouping;
      }
    }

    // router rip / auto-summary
    leaf auto-summary {
      tailf:info "Enable automatic network number summarization";
      tailf:cli-full-command;
      type empty;
    }

    // router rip / maximum-paths
    leaf maximum-paths {
      tailf:info "Maximum number of paths allowed per route";
      type uint8 {
        tailf:info "<1-128>;;Number of paths";
        range "1..128";
      }
    }

    // router rip / default-metric
    leaf default-metric {
      tailf:info "Set metric of redistributed routes";
      type uint8 {
        tailf:info "<1-15>;;Default metric";
        range "1..15";
      }
    }

    uses router-rip-if-grouping;
  }


  // router vrrp / interface * / address-family ipv4 / vrrp * /
  // router vrrp / interface * / address-family ipv6 / vrrp * /
  grouping router-vrrp-if-af-vrrp-grouping {

    // router vrrp / interface * / address-family ipv4 / vrrp * / name
    leaf name {
      tailf:info "Configure VRRP Session name";
      type string {
        tailf:info "WORD;;VRRP Session name, 15 chars max";
      }
    }

    // router vrrp / interface * / address-family ipv4 / vrrp * / priority
    leaf priority {
      tailf:info "Set priority level";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<1-254>;;Priority value";
      }
    }

    // router vrrp / interface * / address-family ipv4 / vrrp * / preempt
    container preempt {
      tailf:info "Preempt Master router if higher priority";
      choice preempt-choice {
        leaf delay {
          tailf:info "Wait before preempting";
          tailf:cli-optional-in-sequence;
          type uint16 {
            tailf:info "<1-3600>;;Number of seconds to delay";
            range "1..3600";
          }
        }
        leaf disable {
          tailf:info "Disable preemption";
          type empty;
        }
      }
    }

    // router vrrp / interface * / address-family ipv4 / vrrp * / timer
    container timer {
      tailf:info "Set advertisement timer";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      choice timer-choice {
        leaf time-value {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<1-255>;;Advertisement time in seconds";
          }
        }
        leaf msec {
          tailf:info "Configure in milliseconds";
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<100-3000>;;Advertisement time in milliseconds (100-3000)";
          }
        }
      }
      leaf force {
        tailf:info "Force the configured values to be used (required for msec)";
        type empty;
      }
    }

    // router vrrp / interface * / address-family ipv4 / vrrp * / track
    container track {
      tailf:info "Track an item, reducing priority if it goes down";

      // router vrrp / interface * / address-family ipv4 / vrrp * / track interface *
      list interface {
        tailf:info "Track an interface";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Interface Name";
          }
        }
        leaf priority {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<1-254>;;Priority decrement";
            range "1..254";
          }
        }
      }

      // router vrrp / interface * / address-family ipv4 / vrrp * / track object *
      list object {
        tailf:info "Object Tracking";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Object to be tracked";
          }
        }
        leaf priority {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<1-254>;;Priority decrement";
            range "1..254";
          }
        }
      }
    }
  }

  // router vrrp / interface * / address-family ipv4 / vrrp * /
  grouping router-vrrp-if-af4-vrrp-grouping {

    uses router-vrrp-if-af-vrrp-grouping;

    // router vrrp / interface * / address-family ipv4 / vrrp * / address *
    list address {
      tailf:info "Enable VRRP and specify IP address(es)";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key ip;
      leaf ip {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;VRRP IPv4 address";
        }
      }
      leaf secondary {
        tailf:info "Set Secondary VRRP IP address";
        type empty;
      }
    }

    // router vrrp / interface * / address-family ipv4 / vrrp * / bfd
    container bfd {
      tailf:info "Configure BFD parameters";
      container fast-detect {
        tailf:info "Enable Fast detection";
        container peer {
          tailf:info "Information about VRRP peer for BFD monitoring";
          leaf ipv4 {
            tailf:info "BFD peer interface IPv4 address";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;VRRP BFD remote interface IP address";
            }
          }
        }
      }
    }

    // router vrrp / interface * / address-family ipv4 / vrrp * / text-authentication
    leaf text-authentication {
      tailf:info "Set plain text authentication string";
      type string {
        tailf:info "WORD;;Authentication password, 8 chars max";
        length "1..8";
      }
    }
  }


  // router bgp * / address-family * / advertise
  grouping router-bgp-af-advertise-grouping {

    // router bgp * / address-family * / advertise * re-originated
    container re-originated {
      tailf:info "Advertise Re-orignated routes only";
      tailf:cli-delete-when-empty;
      presence true;
      leaf route-target {
        tailf:cli-drop-node-name;
        type enumeration {
          enum regular-rt {
            tailf:info "Advertise re-originated routes with regular (non-stitching) Route-Targets";
          }
          enum stitching-rt {
            tailf:info "Advertise re-originated routes with stitching Route-Targets";
          }
        }
      }
    }

    // router bgp * / address-family * / advertise * local
    container local {
      tailf:info "Advertisement of local routes";
      tailf:cli-delete-when-empty;
      presence true;
      leaf route-target {
        tailf:cli-drop-node-name;
        type enumeration {
          enum regular-rt {
            tailf:info "Advertise re-originated routes with regular (non-stitching) Route-Targets";
          }
          enum stitching-rt {
            tailf:info "Advertise re-originated routes with stitching Route-Targets";
          }
        }
      }
    }

    // router bgp * / address-family * / advertise * disable
    leaf disable {
      tailf:info "Disable Advertisement of selected SAFI";
      tailf:cli-full-command;
      type empty;
    }

    // router bgp * / address-family * / advertise * imported-from-vrf
    container imported-from-vrf {
      tailf:info "VRF extranet imported routes";
      leaf disable {
        tailf:info "Disable advertisement of VRF extranet imported routes";
        type empty;
      }
    }

    // router bgp * / address-family * / advertise * imported-from-default-vrf
    container imported-from-default-vrf {
      tailf:info "Default VRF imported routes";
      leaf disable {
        tailf:info "Disable advertisement of default VRF imported routes";
        type empty;
      }
    }
  }


  grouping controller-dwdm-grouping {

    // controller dwdm *
    list dwdm {
      tailf:info "DWDM controller(s)";
      tailf:cli-allow-join-with-key;
      key id;
      leaf id {
        type string {
          tailf:info "dwdm Interface Instance";
          pattern "[0-9]+(/[0-9]+)*";
        }
      }

      // controller dwdm * / description
      uses description-grouping;

      // controller dwdm * / proactive
      leaf proactive {
        tailf:info "Enable Proactive Protection Feature";
        tailf:cli-full-command;
        type empty;
      }

      // controller dwdm * / proactive X
      container proactive-conf {
        tailf:cli-drop-node-name;
        container proactive {
          tailf:info "Enable Proactive Protection Feature";
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;

          // controller dwdm * / proactive revert
          container revert {
            tailf:info "Configure Revert thresholds";

            // controller dwdm * / proactive revert threshold
            container threshold {
              tailf:info "Set values x and y of xE-y";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              leaf x-coefficient {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type uint8 {
                  tailf:info "<1-9>;;Bit error rate coefficient (x of xE-y) (Revert threshold cannot be > 1E-3";
                  range "1..9";
                }
              }
              leaf y-power {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<3-10>;;Bit error rate power (y of xE-y) (Revert threshold cannot be > 1E-3)";
                  range "3..10";
                }
              }
            }

            // controller dwdm * / proactive revert window
            leaf window {
              tailf:info "Number of times threshold crossing is tested";
              type uint32 {
                tailf:info "<500-100000>;;Integration window for FRR revert in MS";
                range "500..100000";
              }
            }
          }

          // controller dwdm * / proactive trigger
          container trigger {
            tailf:info "Configure trigger threshold";

            // controller dwdm * / proactive trigger threshold
            container threshold {
              tailf:info "Set values x and y of xE-y";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              leaf x-coefficient {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type uint8 {
                  tailf:info "<1-9>;;Bit error rate coefficient (x of xE-y) (Trigger threshold cannot be > 1E-2)";
                  range "1..9";
                }
              }
              leaf y-power {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<2-9>;;Bit error rate power (y of xE-y) (Trigger threshold cannot be > 1E-3)";
                  range "2..9";
                }
              }
            }

            // controller dwdm * / proactive trigger window
            leaf window {
              tailf:info "Number of times threshold crossing is tested";
              type uint32 {
                tailf:info "<10-10000>;;Integration window for FRR trigger in MS";
                range "10..10000";
              }
            }
          }
        }
      }

      // controller dwdm * / g709
      container g709 {
        tailf:info "Configure G709 parameters";

        // controller dwdm * / g709 enable
        leaf enable {
          tailf:info "Enable G709 function";
          tailf:cli-full-command;
          type empty;
        }

        // controller dwdm * / g709 fec
        container fec {
          tailf:info "Configure FEC mode";
          choice fec-choice {
            leaf ci-bch {
              tailf:info "Continuously Interleaved BCH FEC";
              tailf:cli-full-command;
              type empty;
            }
            leaf disable {
              tailf:info "Disable FEC";
              tailf:cli-full-command;
              type empty;
            }
            leaf enhanced {
              tailf:info "Enhanced FEC mode";
              type enumeration {
                enum "i.4" {
                  tailf:info "efec i.4";
                }
                enum "i.7" {
                  tailf:info "efec i.7";
                }
              }
            }
            leaf high-gain-hd-fec {
              tailf:info "7% HD FEC (Staircase FEC)";
              type empty;
            }
            leaf high-gain-multivendor-hd-fec {
              tailf:info "7% HD FEC (Staircase FEC) Multivendor Interoperable";
              type empty;
            }
            leaf high-gain-sd-fec {
              tailf:info "7% CISCO SD FEC (Etna Soft-Decision FEC)";
              type empty;
            }
            leaf long-haul-hd-fec {
              tailf:info "20% HD FEC (Staircase FEC)";
              type empty;
            }
            leaf long-haul-sd-fec {
              tailf:info "20% CISCO SD FEC (Etna Soft-Decision FEC)";
              type empty;
            }
            leaf standard {
              tailf:info "Standard FEC mode";
              type empty;
            }
          }
        }

        // controller dwdm * / g709 framing
        leaf framing {
          tailf:info "Configure Framing mode";
          type enumeration {
            enum "opu1e" {
              tailf:info "opu1e framing mode";
            }
            enum "opu2e" {
              tailf:info "opu2e framing mode";
            }
          }
        }

        // controller dwdm * / g709 odu
        container odu {
          tailf:info "Configure ODU parameters";

          // controller dwdm * / g709 otu overhead tti
          container overhead {
            tailf:info "Configure ODU overhead";
            container tti {
              tailf:info "Configure ODU Trail Trace Identifier buffer";

              // controller dwdm * / g709 otu overhead tti expected
              container expected {
                tailf:info "Set expected TTI";
                leaf ascii {
                  tailf:info "Enter ASCII string";
                  tailf:cli-multi-value;
                  type string {
                    tailf:info "LINE;;ASCII text (Max 64 characters)";
                  }
                }
              }

              // controller dwdm * / g709 otu overhead tti sent
              container sent {
                tailf:info "Set transmit TTI";
                leaf ascii {
                  tailf:info "Enter ASCII string";
                  tailf:cli-multi-value;
                  type string {
                    tailf:info "LINE;;ASCII text (Max 64 characters)";
                  }
                }
              }
            }
          }
        }

        // controller dwdm * / g709 otu
        container otu {
          tailf:info "Configure OTU parameters";

          // controller dwdm * / g709 otu overhead
          container overhead {
            tailf:info "Configure OTU overhead";
            container tti {
              tailf:info "Configure OTU Trail Trace Identifier buffer";

              // controller dwdm * / g709 otu overhead tti expected
              container expected {
                tailf:info "Set expected TTI";
                leaf ascii {
                  tailf:info "Enter ASCII string";
                  tailf:cli-multi-value;
                  type string {
                    tailf:info "LINE;;ASCII text (Max 64 characters)";
                  }
                }
              }

              // controller dwdm * / g709 otu overhead tti sent
              container sent {
                tailf:info "Set transmit TTI";
                leaf ascii {
                  tailf:info "Enter ASCII string";
                  tailf:cli-multi-value;
                  type string {
                    tailf:info "LINE;;ASCII text (Max 64 characters)";
                  }
                }
              }
            }
          }

          // controller dwdm * / g709 otu threshold
          container threshold {
            tailf:info "Configure OTU threshold value";

            // controller dwdm * / g709 otu threshold prefec-sd-ber
            leaf prefec-sd-ber {
              tailf:info "Set PreFec Signal Degrate BER threshold";
              type uint8 {
                tailf:info "<2-9>;;Bit error rate (10 to the minus n) (default 6)";
                range "2..9";
              }
            }

            // controller dwdm * / g709 otu threshold prefec-sf-ber
            leaf prefec-sf-ber {
              tailf:info "Set PreFec Signal fail BER threshold";
              type uint8 {
                tailf:info "<2-9>;;Bit error rate (10 to the minus n) (default 4)";
                range "2..9";
              }
            }

            // controller dwdm * / g709 otu threshold sd-ber
            leaf sd-ber {
              tailf:info "Set Signal Degrade BER threshold";
              type uint8 {
                tailf:info "<1-9>;;Bit error rate (10 to the minus n) (default 6)";
                range "1..9";
              }
            }

            // controller dwdm * / g709 otu threshold sf-ber
            leaf sf-ber {
              tailf:info "Set Signal Failure BER threshold";
              type uint8 {
                tailf:info "<1-9>;;Bit error rate (10 to the minus n)";
                range "1..9";
              }
            }
          }
        }

        // controller dwdm * / g709 tti-processing
        leaf tti-processing {
          tailf:info "Enable Trail Trace Identifier processing";
          tailf:cli-full-command;
          type empty;
        }
      }

      // controller dwdm * / loopback
      leaf loopback {
        tailf:info "Configure loopback mode";
        tailf:cli-full-command;
        type enumeration {
          enum "internal" {
            tailf:info "Select internal loopback mode";
          }
          enum "line" {
            tailf:info "Select line loopback mode";
          }
        }
      }

      // controller dwdm * / wavelength
      container wavelength {
        tailf:info "Configure ITU Channel, Wavelength and Frequency";
        choice wave-length-choice {
          leaf channel-number {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-100>;;Select an ITU channel number; C Band: 1-89";
              range "1..100";
            }
          }

          // controller dwdm * / wavelength frequency
          leaf frequency {
            tailf:info "Configure Frequency and Map to ITU Channel";
            type uint16 {
              tailf:info "<19115-19610>;;Enter 5-digit Frequency data; e.g. 19580 for 195.8 THz";
              range "19115..19610";
            }
          }

          // controller dwdm * / wavelength update
          leaf update {
            tailf:info "Configure Wavelength and Map to ITU Channel";
            type uint32 {
              tailf:info "<1528773-1568362>;;Enter 7-digit Wavelength data; e.g. 1532290 for 1532.29 nm";
            }
          }

          // controller dwdm * / wavelength 100MHz-Grid
          container hundred-Grid {
            tailf:alt-name "100MHz-Grid";
            tailf:info "Specify frequency directly instead of wave channel numbers";
            leaf frequency {
              tailf:info "Configure frequency in steps of 100MHz";
              type string {
                tailf:info "WORD;;Enter Frequency Data in THz (e.g. 195.7314)";
              }
            }
          }

          // controller dwdm * / wavelength 50GHz-Grid
          container fifty-Grid {
            tailf:alt-name "50GHz-Grid";
            tailf:info "Configure Wavelength / Frequency / Channel Number";
            choice config-choice {
              leaf itu-ch {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<1-100>;;Select an ITU channel number; C Band: 1-100";
                  range "1..100";
                }
              }
              leaf frequency {
                tailf:info "Configure Frequency and Map to ITU Channel";
                type uint16 {
                  tailf:info "<19115-19610>;;Enter 5-digit Frequency data; e.g. 19580 for 195.8 THz";
                  range "19115..19610";
                }
              }
              leaf update {
                tailf:info "Configure Wavelength and Map to ITU Channel";
                type uint32 {
                  tailf:info "<0-uint32>;;Enter 7-digit Wavelength data; e.g. 1532290 for 1532.29 nm";
                }
              }
            }
          }
        }
      }

      // controller dwdm * / network
      container network {
        tailf:info "Configure DWDM network information";

        // controller dwdm * / network port id
        container port {
          tailf:info "Configure the port ID for this DWDM port";
          leaf id {
            tailf:info "Configure the port ID for this DWDM port";
            tailf:cli-multi-value;
            tailf:cli-preformatted;
            tailf:cli-full-command;
            type string {
              tailf:info "LINE;;Enter a port ID (string, max length 64)";
            }
          }
        }
      }

      // controller dwdm * / admin-state
      leaf admin-state {
        tailf:info "Configure the transport admin state of the controller";
        type enumeration {
          enum in-service {
            tailf:info "change the admin-state to In-service (IS)";
          }
          enum maintenance {
            tailf:info "change the admin-state to Out-of-service-Maintenance (OOS-MT)";
          }
          enum out-of-service {
            tailf:info "change the admin-state to Out-of-service (OOS)";
          }
          enum in-service-config-allowed {
            tailf:info "change the admin-state to In-service-config-allowed (IS-CFG)";
          }
        }
      }

      // controller dwdm * / transmit-power
      leaf transmit-power {
        tailf:info "Configure transponder transmit power";
        tailf:cli-full-command;
        type int16 {
          tailf:info "<-190,+10>;;Select power level (in units of 0.1dBm)";
          range "-190..10";
        }
      }

      // controller dwdm * / shutdown
      leaf shutdown {
        tailf:info "Disable dwdm controller processing";
        type empty;
      }
    }
  }


  // controller *
  // controller preconfigure *
  grouping controller-grouping {

    // controller dwdm *
    uses controller-dwdm-grouping;

    // controller MgmtMultilink *
    list MgmtMultilink {
      tailf:info "Controller for the management of multilink interfacess";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-mgmtmultilink";
      key id;
      leaf id {
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
          pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+";
        }
      }
      // controller MgmtMultilink * / bundle *
      list bundle {
        tailf:info "Configure a multilink bundle interface";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key id;
        leaf id {
          type uint32 {
            tailf:info "<1-999999999>;;Bundle Id";
          }
        }
      }
    }

    // controller T1 *
    list T1 {
      tailf:info "T1 Port controller(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-t1";
      key id;
      leaf id {
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
          pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+.*";
        }
      }

      // controller T1 * / description
      uses description-grouping;

      // controller T1 * / mode
      leaf mode {
        tailf:info "Configure mode for the port";
        type enumeration {
          enum atm {
            tailf:info "clear channel carrying atm";
          }
        }
      }

      // controller T1 * / framing
      leaf framing {
        tailf:info "Configure T1E1 framing";
        type enumeration {
          enum esf {
            tailf:info "esf framing: default";
          }
          enum sf {
            tailf:info "sf framing mode";
          }
        }
      }

      // controller T1 * / linecode
      leaf linecode {
        tailf:info "Specify the line encoding method for a DS1 link";
        tailf:cli-full-command;
        type enumeration {
          enum ami {
            tailf:info "AMI encoding";
          }
          enum b8zs {
            tailf:info "B8ZS encoding";
          }
        }
      }

      // controller T1 * / carrier-delay
      container carrier-delay {
        tailf:info "Set the carrier delay on a T1/E1 controller";
        choice carrier-delay-choice {
          leaf seconds {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<0-60>;;Carrier Transitions delay in seconds";
              range "0..60";
            }
          }
          leaf msec {
            tailf:info "Set time in milliseconds";
            type uint16 {
              tailf:info "<0-1000>;;Carrier Transitions delay in milliseconds";
              range "0..1000";
            }
          }
        }
      }

      // controller T1 * / channel-group *
      list channel-group {
        tailf:info "Configure channel group on T1E1";
        tailf:cli-mode-name "config-t1-channel_group";
        key id;
        leaf id {
          type uint8 {
            tailf:info "<0-23>;;channel group number";
            range "0..23";
          }
        }
        // controller T1 * / channel-group * / speed
        leaf speed {
          tailf:info "speed of the ds0 channel";
          tailf:cli-full-command;
          type enumeration {
            enum "56" {
              tailf:info "56 Kbits";
            }
            enum "64" {
              tailf:info "64 Kbits";
            }
          }
        }
        // controller T1 * / channel-group * / timeslots
        leaf timeslots {
          tailf:info "List of timeslots in the channel group";
          type string {
            tailf:info "WORD;;timeslot string seprated by (:) or (-) "+
              "from 1 to 24. (:) indicates individual timeslot and (-) "+
              "represent range";
          }
        }
      }

      // controller T1 * / clock
      container clock {
        tailf:info "Configure clock source";
        container source {
          tailf:info "Configure t1/e1  TX clock source";
          choice source-choice {
            leaf internal {
              tailf:info "Select internal clock";
              type empty;
            }
            leaf line {
              tailf:info "Select clock recovered from line";
              type empty;
            }
          }
        }
      }

      // controller T1 * / bert
      container bert {
        tailf:info "Configure BERT parameters";

        // controller T1 * / bert / error
        leaf error {
          tailf:info "Insert errors into BERT bit stream";
          tailf:cli-full-command;
          type uint8{
            tailf:info "<1-255>;;Number of errors to generate";
            range "1..255";
          }
        }

        // controller T1 * / bert / interval
        leaf interval {
          tailf:info "Duration of BERT in minutes";
          tailf:cli-full-command;
          type uint16{
            tailf:info "<1-1440>;;Duration of BERT in minutes";
            range "1..1440";
          }
        }

        // controller T1 * / bert / pattern
        leaf pattern {
          tailf:info "BERT pattern";
          tailf:cli-full-command;
          type enumeration {
            enum "0s" {
              tailf:info "All 0's test pattern";
            }
            enum "1in8" {
              tailf:info "1 in 8 test pattern";
            }
            enum "1s" {
              tailf:info "All 1's test pattern";
            }
            enum "2e11" {
              tailf:info "2^11-1 O.150 test pattern";
            }
            enum "2e15" {
              tailf:info "2^15-1 O.151 test pattern";
            }
            enum "2e20" {
              tailf:info "2^20-1 O.153 test pattern";
            }
            enum "2e20-QRSS" {
              tailf:info "2^20-1 QRSS O.151 test pattern";
            }
            enum "2e23" {
              tailf:info "2^23-1 O.151 test pattern";
            }
            enum "2e9" {
              tailf:info "2^9-1 O.150 test pattern";
            }
            enum "3in24" {
              tailf:info "3 in 24 test pattern";
            }
            enum "55Daly" {
              tailf:info "55 Daly test pattern";
            }
            enum "55Octet" {
              tailf:info "55 Octect test pattern";
            }
            enum "alt-0-1" {
              tailf:info "Alternating 0's and 1's test pattern";
            }
          }
        }
      }

      // controller T1 * / shutdown
      leaf shutdown {
        // Note: default to "no shutdown" in order to be able to bring if up.
        tailf:info "Shutdown the selected controller";
        tailf:cli-full-command;
        tailf:cli-show-no;
        type empty;
      }

      // controller T1 * / loopback
      container loopback {
        tailf:info "Configure T1 loopback mode";

        // controller T1 * / loopback / local
        leaf local {
          tailf:cli-full-command;
          tailf:info "Put near end in local loopback";
          type empty;
        }

        // controller T1 * / loopback / network
        leaf network {
          tailf:info "Network loopback";
          tailf:cli-full-command;
          type enumeration {
            enum "line" {
              tailf:info "Put line network loopback";
            }
            enum "payload" {
              tailf:info "Put payload network loopback";
            }
          }
        }

        // controller T1 * / loopback / remote
        container remote {
          tailf:info "Remote loopback (put far end in loopback)";
          tailf:cli-compact-syntax;
          choice line-payload {
            // controller T1 * / loopback / remote / line
            container line {
              tailf:info "Put far end line loop";
              leaf fdl {
                tailf:info "loopback using fdl";
                tailf:cli-full-command;
                type enumeration {
                  enum "ansi" {
                    tailf:info "loopback using ansi fdl";
                  }
                  enum "bellcore" {
                    tailf:info "loopback using Bellcore fdl (SmartJack loopback)";
                  }
                }
              }
              leaf inband {
                tailf:info "loopback using inband code";
                tailf:cli-full-command;
                type empty;
              }
            }
            // controller T1 * / loopback / remote / payload
            container payload {
              tailf:info "Put far end payload loop";
              leaf fdl {
                tailf:info "loopback using fdl";
                tailf:cli-full-command;
                type enumeration {
                  enum "ansi" {
                    tailf:info "loopback using ansi fdl";
                  }
                }
              }
            }
          }
        }
      }
    }

    // controller T3 *
    list T3 {
      tailf:info "T3 Port controller(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-t3";
      key id;
      leaf id {
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
          pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+.*";
        }
      }

      // controller T3 * / description
      uses description-grouping;

      // controller T3 * / mode
      leaf mode {
        tailf:info "Configure mode for the port";
        tailf:cli-full-command;
        type enumeration {
          enum atm {
            tailf:info "clear channel carrying atm";
          }
          enum e1 {
            tailf:info "channelize into 21 E1s";
          }
          enum serial {
            tailf:info "clear channel carrying hdlc like payload";
          }
          enum t1 {
            tailf:info "channelized into 28 T1s";
          }
        }
      }

      // controller T3 * / dsu
      container dsu {
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-t3-dsu";

        // controller T3 * / dsu / bandwidth
        leaf bandwidth {
          tailf:info "Configure DSU bandwidth";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<75-44210>;;DSU subrate bandwidth range";
            range "75..44210";
          }
        }
        // controller T3 * / dsu / mode
        leaf mode {
          tailf:info "Configure DSU mode";
          tailf:cli-full-command;
          type enumeration {
            enum "adtran" {
              tailf:info "Set DSU mode to Adtran";
            }
            enum "digital-link" {
              tailf:info "Set DSU mode to Digital link";
            }
            enum "kentrox" {
              tailf:info "Set DSU mode to Kentrox";
            }
            enum "larscom" {
              tailf:info "Set DSU mode to Larscom";
            }
            enum "verilink" {
              tailf:info "Set DSU mode to Verilink";
            }
          }
        }
        // controller T3 * / dsu / remote
        leaf remote {
          tailf:info "Specify commands associated with the remote end";
          tailf:cli-full-command;
          type enumeration {
            enum "disable" {
              tailf:info "Deny incoming remote requests to reset bandwidth to fullrate";
            }
            enum "fullrate" {
              tailf:info "Request that the farend set its bandwidth to fullrate";
            }
          }
        }
      }

      // controller T3 * / framing
      leaf framing {
        tailf:info "Configure T3/E3 framing";
        type enumeration {
          enum auto-detect {
            tailf:info "Application Identification Channel Signal";
          }
          enum c-bit {
            tailf:info "C-bit framing (T3 default)";
          }
          enum m23 {
            tailf:info "M23 Framing Format";
          }
        }
      }

      // controller T3 * / delay
      container delay {
        leaf trigger {
          tailf:info "trigger time";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<0-60000>;;time in msec to soak before declaring the alarm";
            range "0..60000";
          }
        }
      }

      // controller T3 * / cablelength
      leaf cablelength {
        tailf:info "Length of the T3/E3 cable in feet";
        type uint16 {
          tailf:info "<0-450>;;Length of the cable in feet";
          range "0..450";
        }
      }

      // controller T3 * / clock
      container clock {
        tailf:info "Configure clock source";
        container source {
          tailf:info "Configure t3/e3  TX clock source";
          choice source-choice {
            leaf internal {
              tailf:info "Select internal clock";
              type empty;
            }
            leaf line {
              tailf:info "Select clock recovered from line";
              type empty;
            }
          }
        }
      }

      // controller T3 * / bert
      container bert {
        tailf:info "Configure BERT parameters";

        // controller T3 * / bert / error
        leaf error {
          tailf:info "Insert errors into BERT bit stream";
          tailf:cli-full-command;
          type uint8{
            tailf:info "<1-255>;;Number of errors to generate";
            range "1..255";
          }
        }

        // controller T3 * / bert / interval
        leaf interval {
          tailf:info "Duration of BERT in minutes";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<1-1440>;;Duration of BERT in minutes";
            range "1..1440";
          }
        }

        // controller T3 * / bert / pattern
        leaf pattern {
          tailf:info "BERT pattern";
          tailf:cli-full-command;
          type enumeration {
            enum "0s" {
              tailf:info "All 0's test pattern";
            }
            enum "1in8" {
              tailf:info "1 in 8 test pattern";
            }
            enum "1s" {
              tailf:info "All 1's test pattern";
            }
            enum "2e11" {
              tailf:info "2^11-1 O.150 test pattern";
            }
            enum "2e15" {
              tailf:info "2^15-1 O.151 test pattern";
            }
            enum "2e20" {
              tailf:info "2^20-1 O.153 test pattern";
            }
            enum "2e20-QRSS" {
              tailf:info "2^20-1 QRSS O.151 test pattern";
            }
            enum "2e23" {
              tailf:info "2^23-1 O.151 test pattern";
            }
            enum "2e9" {
              tailf:info "2^9-1 O.150 test pattern";
            }
            enum "3in24" {
              tailf:info "3 in 24 test pattern";
            }
            enum "55Daly" {
              tailf:info "55 Daly test pattern";
            }
            enum "55Octet" {
              tailf:info "55 Octect test pattern";
            }
            enum "alt-0-1" {
              tailf:info "Alternating 0's and 1's test pattern";
            }
          }
        }
      }

      // controller T3 * / shutdown
      leaf shutdown {
        // Note: default to "no shutdown" in order to be able to bring if up.
        tailf:info "Shutdown the selected controller";
        tailf:cli-full-command;
        tailf:cli-show-no;
        type empty;
      }

      // controller T3 * / loopback
      container loopback {
        tailf:info "Configure T3 loopback mode";

        // controller T3 * / loopback / local
        leaf local {
          tailf:info "Put near end in local loopback";
          tailf:cli-full-command;
          type empty;
        }

        // controller T3 * / loopback / network
        leaf network {
          tailf:info "Put near end in network loopback";
          tailf:cli-full-command;
          type enumeration {
            enum "line" {
              tailf:info "Put line network loopback";
            }
            enum "payload" {
              tailf:info "Put payload network loopback";
            }
          }
        }

        // controller T3 * / loopback / remote
        leaf remote {
          tailf:info "Remote loopback (put far end in loopback by sending FEAC)";
          tailf:cli-full-command;
          type enumeration {
            enum "line" {
              tailf:info "Remote line loopback";
            }
            enum "payload" {
              tailf:info "Remote payload loopback";
            }
          }
        }
      }
    }

    // controller E1 *
    list E1 {
      tailf:info "E1 Port controller(s)";
      tailf:cli-mode-name "config-e1";
      key name;
      leaf name {
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
          pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+.*";
        }
      }

      // controller E1 * / description
      uses description-grouping;

      // controller E1 * / cem-group
      container cem-group {
        tailf:info "Configure CEM interface on T1/E1";

        // controller E1 * / cem-group unframed
        leaf unframed {
          tailf:info "Configure a unframed CEM interface on T1/E1";
          type empty;
        }

        // controller E1 * / cem-group framed *
        list framed {
          tailf:info "Configure a framed CEM interface on T1/E1";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          key id;
          leaf id {
            type uint8 {
              tailf:info "<0-30>;;CEM group number";
            }
          }
          leaf timeslots {
            tailf:info "List of timeslots in the CEM group";
            type string {
              tailf:info "WORD;;timeslot string seprated by (:) or (-) from 1 to 31. "+
                "(:) indicates individual timeslot and (-) represent range";
            }
          }
        }
      }

      // controller E1 * / framing
      leaf framing {
        tailf:info "Configure T1E1 framing";
        type enumeration {
          enum crc4 {
            tailf:info "E1 with CRC: default";
          }
          enum no-crc4 {
            tailf:info "E1";
          }
          enum unframed {
            tailf:info "unframed";
          }
        }
      }

      // controller E1 * / linecode
      leaf linecode {
        tailf:info "Specify the line encoding method for a DS1 link";
        tailf:cli-full-command;
        type enumeration {
          enum ami {
            tailf:info "AMI encoding";
          }
          enum hdb3 {
            tailf:info "high-density bipolar 3";
          }
        }
      }

      // controller E1 * / channel-group *
      list channel-group {
        tailf:info "Configure channel group on T1E1";
        tailf:cli-mode-name "config-e1-channel_group";
        key id;
        leaf id {
          type uint8 {
            tailf:info "<0-30>;;channel group number";
            range "0..30";
          }
        }

        // controller E1 * / channel-group * / timeslots
        leaf timeslots {
          tailf:info "List of timeslots in the channel group";
          type string {
            tailf:info "WORD;;timeslot string seprated by (:) or (-) "+
              "from 1 to 31. (:) indicates individual timeslot and (-) "+
              "represent range";
          }
        }
      }

      // controller E1 * / down-when-looped
      leaf down-when-looped {
        tailf:info "Configure t1e1 controller into down-when-looped mode";
        type empty;
      }

      // controller E1 * / clock source
      container clock {
        tailf:info "Configure clock source";
        container source {
          tailf:info "Configure t1/e1  TX clock source";
          choice source-choice {
            leaf internal {
              tailf:info "Select internal clock";
              type empty;
            }
            leaf line {
              tailf:info "Select clock recovered from line";
              type empty;
            }
            leaf recovered {
              tailf:info "Select Recovered clock";
              type uint8 {
                tailf:info "<0-23>;;Clock number";
                range "0..23";
              }
            }
          }
        }
      }

      // controller E1 * / shutdown
      leaf shutdown {
        // Note: default to "no shutdown" in order to be able to bring if up.
        tailf:info "Shutdown the selected controller";
        tailf:cli-full-command;
        tailf:cli-show-no;
        type empty;
      }
    }

    // controller E3 *
    list E3 {
      tailf:info "E3 Port controller(s)";
      tailf:cli-mode-name "config-e3";
      key name;
      leaf name {
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
          pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+.*";
        }
      }

      // controller E3 * / description
      uses description-grouping;

      // controller E3 * / mode
      leaf mode {
        tailf:info "Configure mode for the port";
        tailf:cli-full-command;
        type enumeration {
          enum atm {
            tailf:info "clear channel carrying atm";
          }
          enum e1 {
            tailf:info "channelize into 21 E1s";
          }
          enum serial {
            tailf:info "clear channel carrying hdlc like payload";
          }
          enum t1 {
            tailf:info "channelized into 28 T1s";
          }
        }
      }

      // controller E3 * / framing
      leaf framing {
        tailf:info "Configure T3/E3 framing";
        tailf:cli-full-command;
        type enumeration {
          enum g751 {
            tailf:info "E3 Framing G.751 (E3 default)";
          }
          enum g832 {
            tailf:info "E3 Framing G.832";
          }
        }
      }

      // controller E3 * / dsu
      container dsu {
        tailf:info "Configure T3/E3 subrate(dsu)";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-e3-dsu";

        // controller E3 * / dsu / mode
        leaf mode {
          tailf:info "Configure DSU mode";
          type enumeration {
            enum cisco {
              tailf:info "Set DSU mode to Cisco";
            }
            enum digital-link {
              tailf:info "Set DSU mode to Digital link";
            }
            enum kentrox {
              tailf:info "Set DSU mode to Kentrox";
            }
          }
        }

        // controller E3 * / dsu / bandwidth
        leaf bandwidth {
          tailf:info "Configure DSU bandwidth";
          type uint16 {
            tailf:info "<300-34010>;;DSU subrate bandwidth range";
            range "300..34010";
          }
        }
      }

      // controller E3 * / down-when-looped
      leaf down-when-looped {
        tailf:info "Configure T3/E3 controller into down-when-looped mode";
        tailf:cli-full-command;
        type empty;
      }

      // controller E3 * / clock source
      container clock {
        tailf:info "Configure clock source";
        container source {
          tailf:info "Configure t3/e3  TX clock source";
          choice source-choice {
            leaf internal {
              tailf:info "Select internal clock";
              type empty;
            }
            leaf line {
              tailf:info "Select clock recovered from line";
              type empty;
            }
            leaf recovered {
              tailf:info "Select Recovered clock";
              type uint8 {
                tailf:info "<0-23>;;Clock number";
                range "0..23";
              }
            }
          }
        }
      }

      // controller E3 * / shutdown
      leaf shutdown {
        // Note: default to "no shutdown" in order to be able to bring if up.
        tailf:info "Shutdown the selected controller";
        tailf:cli-full-command;
        tailf:cli-show-no;
        type empty;
      }
    }

    // controller SONET *
    list SONET {
      tailf:info "SONET/SDH Port controller(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-sonet";
      key id;
      leaf id {
        tailf:cli-case-insensitive;
        type string {
          tailf:info "WORD;;SONET Interface Instance";
          pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+.*";
        }
      }

      // controller SONET * / description
      uses description-grouping;

      // controller SONET * / ais-shut
      leaf ais-shut {
        tailf:info "Enable sending SONET/SDH LAIS when shutdown";
        tailf:cli-full-command;
        type empty;
      }

      // controller SONET * / line
      container line {
        tailf:info "Configure SONET/SDH line parameters";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-sonet-line";

        // controller SONET * / line / delay
        container delay {
          tailf:info "alarm soaking";

          // controller SONET * / line / delay clear
          leaf clear {
            tailf:info "clear time";
            type uint32 {
              tailf:info "<1000-180000>;;Time in msec to soak before clearing the alarm (Default 10 seconds)";
              range "1000..180000";
            }
          }

          // controller SONET * / line / delay trigger
          leaf trigger {
            tailf:info "trigger time";
            type uint16 {
              tailf:info "<0-60000>;;Time in msec to soak before declaring the alarm (Default No Delay)";
              range "0..60000";
            }
          }
        }
      }

      // controller SONET * / path
      container path {
        tailf:info "Configure SONET/SDH path parameters";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-sonet-path";

        // controller SONET * / path / report
        container report {
          tailf:info "Configure SONET/SDH path alarm reporting";

          // controller SONET * / path / report pais
          leaf pais {
            tailf:info "Set Path Alarm Indication Signal reporting status";
            type empty;
          }

          // controller SONET * / path / report prdi
          leaf prdi {
            tailf:info "Set Path Remote Defect Indication reporting status";
            type empty;
          }
        }

        // controller SONET * / path / ais-shut
        leaf ais-shut {
          tailf:info "Enable sending SONET/SDH PAIS when shutdown";
          type empty;
        }

        // controller SONET * / path / delay
        container delay {
          tailf:info "alarm soaking";

          // controller SONET * / path / delay trigger
          leaf clear {
            tailf:info "clear time";
            type uint32 {
              tailf:info "<1000-180000>;;Time in msec to soak before clearing the alarm (Default 10 seconds)";
              range "1000..180000";
            }
          }

          // controller SONET * / path / delay trigger
          leaf trigger {
            tailf:info "trigger time";
            type uint16 {
              tailf:info "<0-60000>;;Time in msec to soak before declaring the alarm (Default No Delay)";
              range "0..60000";
            }
          }
        }

        // controller SONET * / path / scrambling
        leaf scrambling {
          tailf:info "Configure SONET/SDH SPE scrambling";
          type enumeration {
            enum disable;
            enum enable;
          }
        }

        // controller SONET * / path / threshold b3-tca
        container threshold {
          tailf:info "Configure SONET/SDH path BER threshold values";
          leaf b3-tca {
            tailf:info "Set B3 BER Threshold Crossing Alert (TCA) threshold";
            type uint8 {
              tailf:info "<3-9>;;Bit error rate (10 to the minus n) (default 6)";
            }
          }
        }
      }

      // controller SONET * / framing
      leaf framing {
        tailf:info "Configure SONET/SDH framing";
        tailf:cli-full-command;
        type enumeration {
          enum sdh {
            tailf:info "Select SDH framing";
          }
          enum sonet {
            tailf:info "Select SONET framing (default)";
          }
        }
      }

      // controller SONET * / report
      container report {
        tailf:info "Configure SONET/SDH section/line alarm reporting";

        // controller SONET * / report lais
        leaf lais {
          tailf:info "Set Line Alarm Indication Signal reporting status";
          type empty;
        }

        // controller SONET * / report lrdi
        leaf lrdi {
          tailf:info "Set Line Remote Defect Indication reporting status";
          type empty;
        }

        // controller SONET * / report sd-ber
        leaf sd-ber {
          tailf:info "Set LBIP BER in excess of SD threshold reporting status";
          type empty;
        }
      }

      // controller SONET * / overhead
      container overhead {
        tailf:info "Configure SONET/SDH SOH/LOH byte/bit values";
        // controller SONET * / overhead j0
        leaf j0 {
          tailf:info "Specify STS identifier (J0/C1) byte";
          type uint8 {
            tailf:info "<0-255>;;J0/C1 byte value (default 0x01)";
            range "0..255";
          }
        }
        // controller SONET * / overhead s1s0
        leaf s1s0 {
          tailf:info "Specify bits s1 and s0 of H1 byte";
          type uint8 {
            tailf:info "<0-3>;;s1 & s0 bits value (default 0x0)";
            range "0..3";
          }
        }
      }

      // controller SONET * / sts *
      list sts {
        tailf:info "Configure SONET path parameters";
        tailf:cli-mode-name "config-stsPath";
        key id;
        leaf id {
          type uint32 {
            tailf:info "<1-48>;;Possible range is 1-3 for OC3, 1-12 for OC12.";
          }
        }

        // controller SONET * / sts * / width
        leaf width {
          tailf:info "Configure width for the path";
          type uint16 {
            tailf:info "<1-768>;;Valid width(1,3,12,48..), natural sts boundaries(1,4,7,10,13..)";
            range "1..768";
          }
        }

        // controller SONET * / sts * / mode
        container mode {
          tailf:info "Configure mode for the path";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf carrying {
            tailf:cli-drop-node-name;
            type enumeration {
              enum atm {
                tailf:info "clear channel carrying atm";
              }
              enum pos {
                tailf:info "Configure pos mode for the path";
              }
              enum t3 {
                tailf:info "sonet path carrying T3";
              }
              enum vt15 {
                tailf:info "sonet path carrying VT15";
              }
              enum vt15-t1 {
                tailf:info "sonet path carrying VT15 T1";
              }
              enum vt2 {
                tailf:info "sonet path carrying VT2";
              }
            }
          }
          leaf pos-option {
            tailf:cli-drop-node-name;
            when "../carrying = 'pos'";
            type enumeration {
              enum scramble {
                tailf:info "clear channel carrying POS scramble";
              }
              enum unscramble {
                tailf:info "clear channel carrying POS unscramble";
              }
            }
          }
        }

        // controller SONET * / sts * / delay trigger
        container delay {
          tailf:info "alarm soaking";
          leaf trigger {
            tailf:info "trigger time";
            type uint16 {
              tailf:info "<0-60000>;;Time in msec to soak before declaring the alarm (Default No Delay)";
              range "0..60000";
            }
          }
        }

        // controller SONET * / sts * / report
        container report {
          tailf:info "Configure SONET/SDH path alarm reporting";

          // controller SONET * / sts * / report pais
          leaf pais {
            tailf:info "Set Path Alarm Indication Signal reporting status";
            type empty;
          }

          // controller SONET * / sts * / report puneq
          leaf puneq {
            tailf:info "Set Path Unequipped Defect Indication reporting status";
            type empty;
          }
        }
      }

      // controller SONET * / threshold
      container threshold {
        tailf:info "Configure SONET/SDH section/line BER threshold values";

        // controller SONET * / threshold sf-ber
        leaf sf-ber {
          tailf:info "Set Signal Fail BER threshold";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<3-9>;;Bit error rate (10 to the minus n) (default 3)";
            range "3..9";
          }
        }

        // controller SONET * / threshold b1-tca
        leaf b1-tca {
          tailf:info "Set B1 BER Threshold Crossing Alert (TCA) threshold";
          type uint8 {
            tailf:info "<3-9>;;Bit error rate (10 to the minus n) (default 6)";
            range "3..9";
          }
        }

        // controller SONET * / threshold b2-tca
        leaf b2-tca {
          tailf:info "Set B2 BER Threshold Crossing Alert (TCA) threshold";
          type uint8 {
            tailf:info "<3-9>;;Bit error rate (10 to the minus n) (default 6)";
            range "3..9";
          }
        }
      }

      // controller SONET * / down-when-looped
      leaf down-when-looped {
        tailf:info "Configure SONET/SDH controller into down-when-looped mode";
        type empty;
      }

      // controller SONET * / au *
      list au {
        tailf:info "Configure SDH path parameters";
        tailf:cli-mode-name "config-auPath";
        key id;
        leaf id {
          type uint8 {
            tailf:info "<1-48>;;au3 or au4 path range";
            range "1..48";
          }
        }

        // controller SONET * / au * / width
        leaf width {
          tailf:info "Configure width for the path";
          type uint16 {
            tailf:info "<1-768>;;Valid width(1,3,12,48..), natural au boundaries(1,4,7,10,13..)";
            range "1..768";
          }
        }

        // controller SONET * / au * / mode
        container mode {
          tailf:info "Configure mode for the au path";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf carrying {
            tailf:cli-drop-node-name;
            type enumeration {
              enum atm {
                tailf:info "clear channel carrying atm";
              }
              enum c11 {
                tailf:info "au3 path carrying c11";
              }
              enum c11-t1 {
                tailf:info "au3 path carrying c11 t1";
              }
              enum c12 {
                tailf:info "au3 path carrying c12";
              }
              enum c12-e1 {
                tailf:info "au3 path carrying c12 e1";
              }
              enum e3 {
                tailf:info "au3 path carrying E3";
              }
              enum pos {
                tailf:info "Configure pos mode for au path";
              }
              enum t3 {
                tailf:info "au3 path carrying T3";
              }
              enum tug3 {
                tailf:info "au4 path carries TUG3";
              }
            }
          }
          leaf pos-option {
            tailf:cli-drop-node-name;
            when "../carrying = 'pos'";
            type enumeration {
              enum scramble {
                tailf:info "clear channel carrying POS scramble";
              }
              enum unscramble {
                tailf:info "clear channel carrying POS unscramble";
              }
            }
          }
        }

        // controller SONET * / au * / tug3 *
        list tug3 {
          tailf:info "Configure tug3 path parameters";
          tailf:cli-mode-name "config-tug3Path";
          key id;
          leaf id {
            type uint8 {
              tailf:info "<1-3>;;tug3 number range";
              range "1..3";
            }
          }

          // controller SONET * / au * / tug3 * / mode
          container mode {
            tailf:info "Configure mode for the tug3 path";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf carrying {
              tailf:cli-drop-node-name;
              type enumeration {
                enum c11 {
                  tailf:info "tug3 path carrying TU-11";
                }
                enum c11-t1 {
                  tailf:info "tug3 path carrying TU-11 to t1";
                }
                enum c12 {
                  tailf:info "tug3 path carrying TU-12";
                }
                enum c12-e1 {
                  tailf:info "tug3 path carrying TU-12 to e1";
                }
                enum e3 {
                  tailf:info "au3 or all tug3 path carrying E3";
                }
                enum t3 {
                  tailf:info "au3 or all tug3 path carrying T3";
                }
              }
            }
          }
        }
      }

      // controller SONET * / clock source
      container clock {
        tailf:info "Configure SONET/SDH port clock";
        leaf source {
          tailf:info "Configure SONET/SDH port TX clock source";
          type enumeration {
            enum internal {
              tailf:info "Select internal clock";
            }
            enum line {
              tailf:info "Select clock recovered from line (default)";
            }
          }
        }
      }

      // controller SONET * / s1byte ignore
      container s1byte {
        tailf:info "Configure SONET/SDH controller to s1byte ignore mode";
        leaf ignore {
          tailf:info "Ignore S1 byte";
          type empty;
        }
      }

      // controller SONET * / shutdown
      leaf shutdown {
        // Note: default to "no shutdown" in order to be able to bring if up.
        tailf:info "Shutdown the selected controller";
        tailf:cli-full-command;
        tailf:cli-show-no;
        type empty;
      }
    }

    // controller wanphy *
    list wanphy {
      tailf:info "WANPHY controller(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-wanphy";
      key id;
      leaf id {
        type string {
          tailf:info "R/S/I/P;;Rack/Slot/Instance/Port format";
          pattern "[0-9]+(/[0-9]+)*";
        }
      }

      // controller wanphy * / lanmode on
      container lanmode {
        tailf:info "Configure Lan Mode On/Off";
        leaf on {
          tailf:info "Turn LanMode On";
          type empty;
        }
      }

      // controller wanphy * / wanmode on
      container wanmode {
        tailf:info "Configure Wan Mode On/Off";
        leaf on {
          tailf:info "Turn WanMode On";
          type empty;
        }
      }
    }

    // controller Optics *
    list Optics {
      tailf:info "OPTICS controller | short name is Op";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-Optics";
      key id;
      leaf id {
        type string {
          tailf:info "R/S/I/P;;Rack/Slot/Instance/Port format";
          pattern "[0-9]+(/[0-9]+)*";
        }
      }

      // controller Optics * / shutdown
      leaf shutdown {
        tailf:info "Disable optics controller processing";
        type empty;
      }

      // controller Optics * / description
      uses description-grouping;

      // controller Optics * / transmit-power
      leaf transmit-power {
        tailf:info "Configure transponder transmit power";
        tailf:cli-full-command;
        type int16 {
          tailf:info "<-190,+20>;;Select power level (in units of 0.1dBm)";
          range "-190..20";
        }
      }

      // controller Optics * / fec
      leaf fec {
        tailf:info "Configure Forward Error Correction mode";
        tailf:cli-full-command;
        type enumeration {
          enum CFEC {
            tailf:info "Forward Error Correction C_FEC";
          }
          enum EnhancedHG15 {
            tailf:info "Forward Error Correction Enhanced_HG15";
          }
          enum EnhancedHG15DE {
            tailf:info "Forward Error Correction Enhanced_HG15_DE";
          }
          enum EnhancedHG20 {
            tailf:info "Forward Error Correction Enhanced_HG20";
          }
          enum EnhancedHG25 {
            tailf:info "Forward Error Correction Enhanced_HG25";
          }
          enum EnhancedHG25DE {
            tailf:info "Forward Error Correction Enhanced_HG25_DE";
          }
          enum EnhancedHG7 {
            tailf:info "Forward Error Correction Enhanced_HG7";
          }
          enum EnhancedI4 {
            tailf:info "Forward Error Correction Enhanced_I_4";
          }
          enum EnhancedI7 {
            tailf:info "Forward Error Correction Enhanced_I_7";
          }
          enum EnhancedSD15 {
            tailf:info "Forward Error Correction Soft-Decision 15";
          }
          enum EnhancedSD15DE {
            tailf:info "Forward Error Correction Soft-Decision 15 with DE";
          }
          enum EnhancedSD20 {
            tailf:info "Forward Error Correction Soft-Decision 20";
          }
          enum EnhancedSD27 {
            tailf:info "Forward Error Correction Soft-Decision 27";
          }
          enum EnhancedSD7 {
            tailf:info "Forward Error Correction Soft-Decision 7";
          }
          enum EnhancedStaircaseDE {
            tailf:info "Forward Error Correction Enhanced Staircase FEC with DE";
          }
          enum EnhancedSwizzle {
            tailf:info "Forward Error Correction Enhanced_Swizzle";
          }
          enum None {
            tailf:info "Forward Error Correction None";
          }
          enum OFEC {
            tailf:info "Forward Error Correction O_FEC";
          }
          enum Standard {
            tailf:info "Forward Error Correction Standard";
          }
        }
      }

      // controller Optics * / modulation
      leaf modulation {
        tailf:info "Configure modulation types";
        tailf:cli-full-command;
        type enumeration {
          enum 16Qam {
            tailf:info "Select 16QAM modulation type";
          }
          enum 16Qam-32Qam {
            tailf:info "Select 16QAM_32QAM modulation type";
          }
          enum 32Qam {
            tailf:info "Select 32QAM modulation type";
          }
          enum 32Qam-64Qam {
            tailf:info "Select 32QAM_64QAM modulation type";
          }
          enum 64Qam {
            tailf:info "Select 64QAM modulation type";
          }
          enum 8Qam {
            tailf:info "Select 8QAM modulation type";
          }
          enum 8Qam-16Qam {
            tailf:info "Select 8QAM_16QAM modulation type";
          }
          enum Bpsk {
            tailf:info "Select BPSK modulation type";
          }
          enum Bpsk-Qpsk {
            tailf:info "Select BPSK_QPSK modulation type";
          }
          enum Qpsk {
            tailf:info "Select QPSK modulation type";
          }
          enum Qpsk-8Qam {
            tailf:info "Select QPSK_8QAM modulation type";
          }
        }
      }

      // controller Optics * / dwwm-carrier
      container dwdm-carrier {
        tailf:info "Configure the DWDM Carrier Channel";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf grid {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type enumeration {
            enum "50GHz-grid" {
              tailf:info "Configure Wavelength in 50GHz grid";
            }
            enum "100MHz-grid" {
              tailf:info "Configure Wavelength in 100MHz Grid";
            }
          }
        }
        choice config-choice {
          leaf frequency {
            tailf:info "Configure Frequency";
            tailf:cli-break-sequence-commands;
            type uint32 {
              tailf:info "NUM;;Enter Frequency";
            }
          }
          leaf itu-ch {
            tailf:info "Configure the ITU 50GHz Grid ITU Channel";
            type uint8 {
              tailf:info "<1-100>;;Select an ITU channel number; C Band: 1-100";
              range "1..100";
            }
          }
          leaf wavelength {
            tailf:info "Configure Wavelength and Map to ITU Channel";
            type uint32 {
              tailf:info "<1528773-1568362>;;Enter 7-digit Wavelength data; e.g. 1532290 for 1532.29 nm";
              range "1528773..1568362";
            }
          }
        }
      }

      // controller Optics * / breakout
      leaf breakout {
        tailf:info "Configure breakout mode";
        type string {
          tailf:info "WORD;;breakout mode: 4x10 | 4x25 | 2x50";
        }
      }

      // controller Optics * / port-mode
      container port-mode {
        tailf:info "Configure the port-mode";

        // controller Optics * / port-mode Otn framing
        container Otn {
          tailf:info "Otn portmode type";
          leaf framing {
            tailf:info "framing for portmode";
            type enumeration {
              enum opu1 {
                tailf:info "opu1 for framing";
              }
              enum opu1e {
                tailf:info "opu1e for framing";
              }
              enum opu1f {
                tailf:info "opu1f for framming";
              }
              enum opu2 {
                tailf:info "opu2 for framing";
              }
              enum opu2e {
                tailf:info "opu2e for framing";
              }
              enum opu2f {
                tailf:info "opu2f for framming";
              }
              enum opu3 {
                tailf:info "opu3 for framing";
              }
              enum opu3e1 {
                tailf:info "opu3e1 for framing";
              }
              enum opu3e2 {
                tailf:info "opu3e2 for framing";
              }
              enum opu4 {
                tailf:info "opu4 for framing";
              }
              enum opuc2 {
                tailf:info "opuc2 for framing";
              }
              enum opuc4 {
                tailf:info "opuc4 for framing";
              }
              enum opuflex {
                tailf:info "opuflex for framing";
              }
            }
          }
        }

        // controller Optics * / port-mode Ethernet framing
        container Ethernet {
          tailf:info "Ethernet portmode type";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf framing {
            tailf:info "framing for portmode";
            type enumeration {
              enum opu0 {
                tailf:info "opu0 for framing";
              }
              enum opu1e {
                tailf:info "opu1e for framing";
              }
              enum opu2 {
                tailf:info "opu2 for framing";
              }
              enum opu2e {
                tailf:info "opu2e for framing";
              }
              enum opu3 {
                tailf:info "opu3 for framing";
              }
              enum opu3e1 {
                tailf:info "opu3e1 for framing";
              }
              enum opu3e2 {
                tailf:info "opu3e2 for framing";
              }
              enum opu4 {
                tailf:info "opu4 for framing";
              }
              enum opuflex {
                tailf:info "opuflex for framing";
              }
              enum packet {
                tailf:info "packet for framing";
              }
            }
          }
          leaf rate {
            tailf:info "Portmode rate";
            tailf:cli-full-command;
            when "../framing = 'packet'";
            type enumeration {
              enum 10GE {
                tailf:info "10GE rate";
              }
              enum 40GE {
                tailf:info "40GE for rate";
              }
              enum 100GE {
                tailf:info "100GE for rate";
              }
            }
          }
          leaf mapping {
            tailf:info "mapping for portmode";
            type enumeration {
              enum gmp {
                tailf:info "gmp for mapping";
              }
              enum bmp {
                tailf:info "bmp for mapping";
              }
              enum GfpF {
                tailf:info "gfp_f for mapping";
              }
              enum GfpF-Ext {
                tailf:info "gfp_f_ext for mapping";
              }
              enum wis {
                tailf:info "wis for mapping";
              }
            }
          }
        }

        // controller Optics * / port-mode speed
        container speed {
          tailf:info "optics speed";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf speed {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type enumeration {
              enum 100G {
                tailf:info "Speed 100";
              }
              enum 150G {
                tailf:info "Speed 150";
              }
              enum 200G {
                tailf:info "Speed 200";
              }
            }
          }
          leaf mod {
            tailf:info "modulation value";
            tailf:cli-incomplete-command;
            type enumeration {
              enum 16qam {
                tailf:info "select 16qam for modulation";
              }
              enum 8qam {
                tailf:info "select 8qam for modulation";
              }
              enum qpsk {
                tailf:info "select qpsk for modulation";
              }
            }
          }
          leaf fec {
            tailf:info "optics fec";
            tailf:cli-incomplete-command;
            type enumeration {
              enum 15sdfec {
                tailf:info "15%-SD Forward Error Correction";
              }
              enum 15sdfecde {
                tailf:info "15%-SD Forward Error Correction with Diff";
              }
              enum 25sdfec {
                tailf:info "25%-SD Forward Error Correction";
              }
              enum otu7staircase {
                tailf:info "7%-STAIRCASE Forward Error Correction";
              }
            }
          }
          leaf diff {
            tailf:info "differential value";
            type enumeration {
              enum disable {
                tailf:info "disable differential";
              }
              enum enable {
                tailf:info "enable differential";
              }
            }
          }
        }
      }
    }

    // controller pse
    container pse {
      tailf:info "pse";
      container tcam {
        tailf:info "tcam";
        // controller pse tcam location *
        list location {
          tailf:info "Specify a location";
          tailf:cli-mode-name "config-TCAM";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Fully qualified location specification";
            }
          }
          // controller pse tcam location * / compression
          container compression {
            tailf:info "compression";
            container ipv6 {
              tailf:info "ipv6";
              leaf anchor-prefix {
                tailf:info "compression anchor prefix length. Original values are 32, 48, 64, and 96. 128 is a placeholder and is not used as an anchor";
                tailf:cli-multi-value;
                type string {
                  pattern "[0-9]+( [0-9]+)*";
                }
              }
            }
          }
        }
      }
    }

    // controller OTUC2*
    list OTUC2 {
      tailf:info "OTUC2 controller(s) | short name is Oc2";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-otuc2";
      key id;
      leaf id {
        tailf:cli-suppress-range;
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
          pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+.*";
        }
      }
      uses controller-oxu-grouping;
    }

    // controller ODU4*
    list ODU4 {
      tailf:info "ODUC4 controller(s) | short name is O4";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-odu4";
      key id;
      leaf id {
        tailf:cli-suppress-range;
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
          pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+.*";
        }
      }
      uses controller-oxu-grouping;
    }

    // controller OTU4*
    list OTU4 {
      tailf:info "OTUC4 controller(s) | short name is Oc4";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name "config-otu4";
      key id;
      leaf id {
        tailf:cli-suppress-range;
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
          pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+.*";
        }
      }
      uses controller-oxu-grouping;
    }
  }


  // controller OTUC2*
  // controller ODU4*
  // controller OTU4*
  grouping controller-oxu-grouping {

    // controller OTUC2* / description
    uses description-grouping;

    // controller OTUC2* / secondary-admin-state
    leaf secondary-admin-state {
      tailf:info "Configure the secondary admin state of the controller";
      type enumeration {
        enum maintenance {
          tailf:info "Maintenance, Admin-state under maintenance";
        }
        enum normal {
          tailf:info "Normal, Admin-state in normal";
        }
      }
    }

    // controller OTUC2* / gcc0
    leaf gcc0 {
      tailf:info "Configure GCC0(General Communication Channel)";
      type empty;
    }
  }


  // extcommunity-set rt *
  // extcommunity-set soo *
  // rd-set *
  // prefix-set *
  // as-path-set *
  // community-set *
  grouping set-list-grouping {
    list set {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-show-long-obu-diffs;
      //tailf:cli-show-obu-comments;
      ordered-by user;
      key value;
      leaf value {
        tailf:cli-multi-word-key;
        tailf:cli-disallow-value "end-set|abort|exit";
        type string {
          tailf:info "WORD;;set line";
          pattern ".*[^,]";
        }
      }
    }
  }

  grouping ipsla-reaction-operation-react-grouping {

    // ipsla / reaction operation * / react rtt / action
    container action {
      tailf:info "Type of action to be taken on threshold violation(s)";

      // ipsla / reaction operation * / react rtt / action logging
      leaf logging {
        tailf:info "Generate a syslog alarm on threshold violation";
        type empty;
      }

      // ipsla / reaction operation * / react rtt / action trigger
      leaf trigger {
        tailf:info "Generate trigger to active reaction triggered operation(s)";
        type empty;
      }
    }

    // ipsla / reaction operation * / react rtt / threshold
    container threshold {
      tailf:info "Configure threshold parameters on monitored element";

      // ipsla / reaction operation * / react rtt / threshold type
      container type {
        tailf:info "Threshold type";

        choice type-choice {
          // ipsla / reaction operation * / react rtt / threshold type immediate
          leaf immediate {
            tailf:info "Take action immediately upon threshold violation";
            type empty;
          }

          // ipsla / reaction operation * / react rtt / threshold type consecutive
          leaf consecutive {
            tailf:info "Take action after a number of consecutive violations";
            type uint8 {
              tailf:info "<1-16>;;Number of consecutive violations";
              range "1..16";
            }
          }

          // ipsla / reaction operation * / react rtt / threshold type average
          leaf average {
            tailf:info "Take action on average values violate threshold";
            type uint8 {
              tailf:info "<1-16>;;Number of probes to average over";
              range "1..16";
            }
          }
        }
      }

      // ipsla / reaction operation * / react rtt / threshold lower-limit
      container limit {
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf lower-limit {
          tailf:info "Threshold lower limit";
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<1-4294967295>;;Threshold lower limit value";
            range "1..4294967295";
          }
        }
        leaf upper-limit {
          tailf:info "Threshold upper limit";
          type uint32 {
            tailf:info "<1-4294967295>;;Threshold upper limit value";
            range "1..4294967295";
          }
        }
      }
    }
  }

  grouping interface-tunnel-te-auto-bw-threshold-grouping {
    container threshold {
      tailf:info "Set the bandwidth change percent to trigger an underflow/overflow";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf percentage {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint8 {
          tailf:info "<1-100>;;Bandwidth change percent to trigger an overflow";
          range "1..100";
        }
      }
      leaf min {
        tailf:info "Set the bandwidth change value to trigger an overflow";
        tailf:cli-optional-in-sequence;
        type uint32 {
          tailf:info "<10-4294967295>;;Bandwidth change value to trigger an overflow (kbps)";
          range "10..4294967295";
        }
      }
      leaf limit {
        tailf:info "Set the number of consecutive collections exceeding threshold";
        type uint8 {
          tailf:info "<1-10>;;Number of consecutive collections exceeding threshold";
          range "1..10";
        }
      }
    }
  }

  // interface * /
  // interface * / l2transport /
  grouping interface-monitor-session-grouping {
    list monitor-session {
      tailf:info "Monitor-session configuration commands";
      tailf:cli-mode-name "config-if-mon";
      key name;
      leaf name {
        tailf:cli-suppress-leafref-in-diff;
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:monitor-session/name";
        }
        type string {
          tailf:info "WORD;;Session Name";
        }
      }
      leaf ethernet {
        tailf:info "Replicate Ethernet traffic";
        tailf:cli-hide-in-submode;
        type empty;
      }
      leaf port-level {
        tailf:info "Replicate traffic on all interfaces of a main interface";
        tailf:cli-hide-in-submode;
        type empty;
      }

      // interface * / monitor-session * ipv4
      leaf ipv4 {
        tailf:info "Replicate IPv4 traffic";
        tailf:cli-hide-in-submode;
        type empty;
      }

      // interface * / monitor-session * direction
      leaf direction {
        tailf:info "Specify the direction of traffic to replicate";
        tailf:cli-hide-in-submode;
        type enumeration {
          enum rx-only {
            tailf:info "Replicate only received (ingress) traffic";
          }
          enum tx-only {
            tailf:info "Replicate only transmitted (egress) traffic";
          }
        }
      }

      // interface * / monitor-session * / acl
      leaf acl {
        tailf:info "Enable acl based mirroring";
        type empty;
      }

      // interface * / monitor-session * / mirror
      container mirror {
        tailf:info "Set the mirroring properties of this interface";

        // interface * / monitor-session * / mirror first
        leaf first {
          tailf:info "Enable mirroring on the first portion of a packet";
          type uint16 {
            tailf:info "<1-10000>;;Specify the number of bytes to mirror";
            range "1..10000";
          }
        }
      }
    }
  }

  grouping router-ospf-domain-id-grouping {
    leaf type {
      tailf:info "OSPF domain ID type in Hex format";
      tailf:cli-incomplete-command;
      type enumeration {
        enum "0005" {
          tailf:info "Type 0x0005";
        }
        enum "0105" {
          tailf:info "Type 0x0105";
        }
        enum "0205" {
          tailf:info "Type 0x0205";
        }
        enum "8005" {
          tailf:info "Type 0x8005";
        }
      }
    }
    leaf value {
      tailf:info "OSPF domain ID value in Hex format";
      type string {
        tailf:info "WORD;;OSPF domain ID ext. community value in Hex (6 octets)";
      }
    }
  }


  // explicit-path name * /
  // explicit-path identifier * /
  grouping explicit-path-index-list-grouping {
    list index {
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      key index-id;
      leaf index-id {
        type uint16 {
          tailf:info "<1-65535>;;Index number";
          range "1..65535";
        }
      }
      // explicit-path name * / index * next-address
      leaf keyword {
        tailf:cli-drop-node-name;
        type enumeration {
          enum exclude-address {
            tailf:info "Specify the next address to be excluded";
          }
          enum exclude-srlg {
            tailf:info "Specify an IP Addr to get SRLGs from for exclusion";
          }
          enum next-address {
            tailf:info "Specify the next (adjacent) address in the path";
          }
          enum next-label {
            tailf:info "Specify the next (adjacent) address in the path";
          }
        }
      }
      // explicit-path name * / index * next-address loose
      // explicit-path name * / index * next-address strict
      leaf hop-type {
        when "../keyword = 'next-address'";
        tailf:cli-optional-in-sequence;
        tailf:cli-drop-node-name;
        type enumeration {
          enum loose {
            tailf:info "Specify the next address in the path as a loose hop";
          }
          enum strict {
            tailf:info "Specify the next address in the path as a strict hop";
          }
        }
      }
      leaf label {
        when "../keyword = 'next-label'";
        tailf:cli-optional-in-sequence;
        tailf:cli-drop-node-name;
        type uint32;
      }
      // explicit-path name * / index * ipv4 unicast
      container ipv4 {
        tailf:info "Specify the address AFI";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf unicast {
          tailf:info "Specify the address SAFI";
          type union {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Enter IP address (A.B.C.D)";
            }
            type enumeration {
              enum unnumbered {
                tailf:info "Enter Router Id (A.B.C.D) and Ifindex";
              }
            }
          }
        }
        leaf router-id {
          tailf:cli-drop-node-name;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Enter Router ID";
          }
        }
        leaf ifindex {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-4294967295>;;Enter Ifindex";
            range "1..4294967295";
          }
        }
      }
    }
  }


  // l2vpn / bridge group * / bridge-domain * / vfi * / autodiscovery bgp / route-target *
  // l2vpn / xconnect group * / mp2mp * / auto-discovery bgp / route-target
  grouping route-target-import-export-grouping {
    container route-target {
      tailf:info "Route Target";

      // l2vpn / xconnect group * / mp2mp * / auto-discovery bgp / route-target *
      list route-target-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Two or Four Byte AS number or IP:nn";
          }
        }
      }

      // l2vpn / xconnect group * / mp2mp * / auto-discovery bgp / route-target import *
      leaf-list import {
        tailf:info "Import Route Target";
        tailf:cli-list-syntax;
        type string {
          tailf:info "WORD;;AS-number or IPv4 address:index";
        }
      }

      // l2vpn / xconnect group * / mp2mp * / auto-discovery bgp / route-target export *
      leaf-list export {
        tailf:info "Export Route Target";
        tailf:cli-list-syntax;
        type string {
          tailf:info "WORD;;AS-number or IPv4 address:index";
        }
      }
    }
  }


  // admin / username *
  // username *
  grouping username-grouping {
    list username {
      tailf:info "Configure user name";
      tailf:cli-mode-name "config-un";
      tailf:cli-explicit-exit;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;User name";
        }
      }

      // username * / group *
      list group {
        tailf:info "User group in which this user will be a member of";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of the user group";
          }
        }
      }

      // username * / policy
      leaf policy {
        tailf:info "Specify the policy common to password and secret for the user";
        tailf:cli-suppress-leafref-in-diff;
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:aaa/password-policy/name";
        }
        type string {
          tailf:info "WORD;;Specify the password policy name";
        }
      }

      // username * / secret
      container secret {
        tailf:info "Specify the secure password for the user";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf encryption {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type enumeration {
            enum "0" {
              tailf:info "Specifies an UNENCRYPTED password will follow";
            }
            enum "5" {
              tailf:info "Specifies that an encrypted password will follow";
            }
            enum "8" {
              tailf:info "Specifies that SHA-256 encrypted password will follow";
            }
            enum "9" {
              tailf:info "Specifies that scrypt encrypted password will follow";
            }
            enum "10" {
              tailf:info "Specifies that an encrypted password will follow";
            }
          }
        }
        leaf password {
          tailf:cli-drop-node-name;
          tailf:cli-reset-container;
          cli:secret " secret <SECRET>";
          type NEDCOM_SECRET_TYPE {
            tailf:info "WORD;;The user password string";
          }
        }
      }

      // username * / password
      container password {
        tailf:info "Specify the password for the user";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf encryption {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type enumeration {
            enum 0 {
              tailf:info "Specifies an UNENCRYPTED password will follow";
            }
            enum 7 {
              tailf:info "Specifies a HIDDEN password will follow";
            }
          }
        }
        leaf password {
          tailf:cli-drop-node-name;
          tailf:cli-reset-container;
          cli:secret " password <SECRET>";
          type NEDCOM_SECRET_TYPE {
            tailf:info "WORD;;The HIDDEN user password string";
          }
        }
      }

      // username * / password-policy
      container password-policy {
        tailf:info "Specify the password policy for the user";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf policy-name {
          tailf:cli-drop-node-name;
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:aaa/password-policy/name";
          }
          type string {
            tailf:info "WORD;;Specify the password policy name";
          }
        }
        container password {
          tailf:info "Specify the password for the user";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-flatten-container;
          leaf encryption {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type enumeration {
              enum 0 {
                tailf:info "Specifies an UNENCRYPTED password will follow";
              }
              enum 7 {
                tailf:info "Specifies a HIDDEN password will follow";
              }
            }
          }
          leaf password {
            tailf:cli-drop-node-name;
            tailf:cli-reset-container;
            cli:secret " password <SECRET>";
            type NEDCOM_SECRET_TYPE {
              tailf:info "WORD;;The HIDDEN user password string";
            }
          }
        }
      }
    }
  }

  // admin / clock
  // clock
  grouping clock-grouping {

    container clock {
      tailf:info "Configure time-of-day clock";
      tailf:cli-explicit-exit;

      // clock calendar-valid
      leaf calendar-valid {
        tailf:info "Calendar time is authoritative";
        type empty;
      }

      // clock summer-time
      container summer-time {
        tailf:info "Configure summer (daylight savings) time";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf zone {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;name of time zone in summer";
          }
        }
        choice summer {
          case a {
            container date {
              tailf:info "Configure absolute summer time";
            }
          }
          case b {
            leaf recurring {
              type empty;
            }
            leaf start {
              tailf:cli-drop-node-name;
              type union {
                type uint8 {
                  tailf:info "<1-4>;;Week number to start";
                  range "1..4";
                }
                type enumeration {
                  enum first {
                    tailf:info "First week of the month";
                  }
                  enum last {
                    tailf:info "Last week of the month";
                  }
                }
              }
            }
            leaf start-day {
              tailf:cli-drop-node-name;
              type enumeration {
                enum monday;
                enum tuesday;
                enum wednesday;
                enum thursday;
                enum friday;
                enum saturday;
                enum sunday;
              }
            }
            leaf start-month {
              tailf:cli-drop-node-name;
              type month-type;
            }
            leaf start-time {
              tailf:cli-drop-node-name;
              type string {
                pattern "[0-9][0-9]:[0-9][0-9]";
              }
            }
            leaf end {
              tailf:cli-drop-node-name;
              type union {
                type uint8 {
                  tailf:info "<1-4>;;Week number to end";
                  range "1..4";
                }
                type enumeration {
                  enum first {
                    tailf:info "First week of the month";
                  }
                  enum last {
                    tailf:info "Last week of the month";
                  }
                }
              }
            }
            leaf end-day {
              tailf:cli-drop-node-name;
              type enumeration {
                enum monday;
                enum tuesday;
                enum wednesday;
                enum thursday;
                enum friday;
                enum saturday;
                enum sunday;
              }
            }
            leaf end-month {
              tailf:cli-drop-node-name;
              type month-type;
            }
            leaf end-time {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "<0-23>:<0-59>;;Time to end (hh:mm)";
                pattern "[0-9][0-9]:[0-9][0-9]";
              }
            }
            leaf end-offset {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<1-1440>;;Offset to add in minutes";
                range "1..1440";
              }
            }
          }
        }
      }

      // clock timezone
      container timezone {
        tailf:info "Configure time zone";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf zone {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type string {
            tailf:info "WORD;;name of time zone";
          }
        }
        choice timezone-choice {
          leaf region {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;Region";
              pattern '[a-zA-Z].*';
            }
          }
          case offset {
            leaf hours-offset {
              tailf:cli-drop-node-name;
              type int8 {
                tailf:info "<-23 - 23>;;Hours offset from UTC";
                range "-23..23";
              }
            }
            leaf minutes-offset {
              tailf:cli-drop-node-name;
              type int8 {
                tailf:info "<0-59>;;Minutes offset from UTC";
                range "0..59";
              }
            }
          }
        }
      }
    }
  }

  // admin / exception
  // exception
  grouping exception-grouping {
    container exception {
      tailf:info "Coredump configuration commands";
      tailf:cli-explicit-exit;

      // exception choice *
      list choice {
        tailf:info "Preference for the following dump location";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-incomplete-command;
        key order;
        leaf order {
          type uint8 {
            tailf:info "<1-3>;;Order of preference";
            range "1..3";
          }
        }
        // exception choice * compress
        leaf compress {
          tailf:info "Compress the dump files";
          type enumeration {
            enum off {
              tailf:info "Do not compress core files dumped on this path";
            }
            enum on {
              tailf:info "Compress core files dumped on this path";
            }
          }
        }
        // exception choice * filename
        container filename {
          tailf:info "Dump file name";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          leaf name {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type string {
              tailf:info "WORD;;Filename";
            }
          }
          leaf limit {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "lowlimit-highlimit";
              pattern '[0-4]\-[0-9]+';
            }
          }
        }
        // exception choice * filepath
        leaf filepath {
          tailf:info "Give the dump location next";
          type string {
            tailf:info "WORD;;Protocol and directory";
          }
        }
      }

      // exception sparse
      leaf sparse {
        tailf:info "control sparse core dump";
        tailf:cli-full-command;
        type enumeration {
          enum off {
            tailf:info "Disable sparse core dump";
          }
          enum on {
            tailf:info "Enable sparse core dump by default";
          }
        }
      }

      // exception sprsize
      leaf sprsize {
        tailf:info "Switch to sparse core dump at this size";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<1-4095>;;Switch to sparse core dump size in MB";
          range "1..4095";
        }
      }

      // exception coresize
      leaf coresize {
        tailf:info "Only print out stack trace and create no core file beyond this size";
        tailf:cli-full-command;
        type uint32 {
          tailf:info "<1-4095>;;Core file size max limit in MB";
          range "1..4095";
        }
      }

      // exception pakmem
      leaf pakmem {
        tailf:info "control pakmem in core";
        tailf:cli-full-command;
        type enumeration {
          enum off {
            tailf:info "Disable dump of packet memory by default";
          }
          enum on {
            tailf:info "Dump packet memory for all process";
          }
        }
      }
    }
  }

  grouping average-cpu-used-grouping {
    leaf op {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type operator-type;
    }
    leaf threshold {
      tailf:cli-drop-node-name;
      type uint8 {
        tailf:info "<0-100>;;Threshold value";
        range "0..100";
      }
    }
    leaf percent {
      tailf:info "Specify that threshold value is percent of previous sample";
      tailf:cli-optional-in-sequence;
      type empty;
    }
    container rearm {
      tailf:info "Specify Rearm parameters (default - always)";
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      choice rearm-choice {
        leaf toggle {
          tailf:info "Rearm after the first period when condition is not met";
          type empty;
        }
        leaf window {
          tailf:info "Rearm after the window of sampling periods";
          type uint8 {
            tailf:info "<1-100>;;Rearm window size";
            range "1..100";
          }
        }
      }
    }
  }


  // evpn / timers
  // evpn / interface * / timers
  // evpn / virtual neighbor * pw-id * / timers
  grouping evpn-timers-grouping {

    // evpn /  timers
    container timers {
      tailf:info "Configure EVPN timers";
      tailf:cli-add-mode;
      tailf:cli-delete-when-empty;
      presence true;

      // evpn /  timers peering
      leaf peering {
        tailf:info "Peering timer";
        type uint16 {
          tailf:info "<0-300>;;Value in seconds, default is 3 seconds";
          range "0..300";
        }
      }

      // evpn /  timers recovery
      leaf recovery {
        tailf:info "Recovery timer";
        type uint16 {
          tailf:info "<20-3600>;;Value in seconds, default is 30 seconds";
          range "20..3600";
        }
      }
    }
  }

  // evpn / virtual neighbor * pw-id *
  // evpn / virtual vfi *
  grouping evpn-virtual-grouping {

    // evpn / virtual neighbor * pw-id * / ethernet-segment
    container ethernet-segment {
      tailf:info "Ethernet Segment configuration commands";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-evpn-ac-es";

      // evpn / virtual neighbor * pw-id * / ethernet-segment / identifier
      container identifier {
        tailf:info "Ethernet Segment identifier (ESI)";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf type {
          tailf:info "ESI Type";
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "0;;Type 0 (arbitrary 9-octet ESI value)";
            range "0";
          }
        }
        leaf esi-value {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "<0-ff>.;;9-octet ESI value";
            pattern '[0-9a-f]{2}(\.[0-9a-f]{2}){8}';
          }
        }
      }

      // evpn / virtual neighbor * pw-id * / ethernet-segment / bgp route-target
      container bgp {
        tailf:info "Configure BGP";
        leaf route-target {
          tailf:info "Set ES-Import Route Target";
          type string {
            tailf:info "H.H.H;;Route Target value (6-octet)";
            pattern '[0-9a-f]{4}\.[0-9a-f]{4}\.[0-9a-f]{4}';
          }
        }
      }
    }

    // evpn / virtual neighbor * pw-id * / timers
    uses evpn-timers-grouping;
  }

  // evpn / vni * / bgp
  // evpn / evi * / bgp
  grouping evpn-bgp-grouping {
    leaf rd {
      tailf:info "Set the Route Distinguisher";
      tailf:cli-full-command;
      type string {
        tailf:info "WORD;;AS-number or IPv4 address:index";
      }
    }

    container route-target {
      tailf:info "Set the Route Target";

      // evpn / evi * / bgp / route-target *
      list route-target-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          tailf:cli-disallow-value "import|export";
          type string {
            tailf:info "WORD;;Two or Four Byte AS number or IP:nn";
          }
        }
      }

      // evpn / evi * / bgp / route-target import *
      list import {
        tailf:info "Import Route Target";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;AS-number or IPv4 address:index";
          }
        }
        leaf stitching {
          tailf:info " Route Target for Fabric side";
          type empty;
        }
      }

      // evpn / evi * / bgp / route-target export *
      list export {
        tailf:info "Export Route Target";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;AS-number or IPv4 address:index";
          }
        }
        leaf stitching {
          tailf:info " Route Target for Fabric side";
          type empty;
        }
      }
    }
  }


  grouping pppoe-bba-group-grouping {

    // pppoe bba-group / mtu
    leaf mtu {
      tailf:info "Change default maximum payload";
      type uint16 {
        tailf:info "<500-2000>;;Default maximum payload";
        range "500..2000";
      }
    }

    // pppoe bba-group / ac name
    container ac {
      tailf:info "Modify Access Concentrator config";
      leaf name {
        tailf:info "Change the name to include in the AC tag";
        type string {
          tailf:info "WORD;;New name";
        }
      }
    }

    // pppoe bba-group / tag ppp-max-payload
    container tag {
      tailf:info "Change tag configuration";
      container ppp-max-payload {
        tailf:info "Change the ppp-max-payload configuration";

        // pppoe bba-group / tag ppp-max-payload minimum
        container minimum {
          tailf:info "Configure minimum payload";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf value {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<500-2000>;;Minimum payload";
              range "500..2000";
            }
          }
          leaf maximum {
            tailf:info "Configure maximum payload";
            type uint16 {
              tailf:info "<500-2000>;;Maximum payload";
              range "500..2000";
            }
          }
        }
      }
    }

    // pppoe bba-group / pado
    container pado {
      tailf:info "Configure the PADO response to PADIs";

      // pppoe bba-group / pado delay
      container delay {
        tailf:info "Delay the PADO response";
        leaf delay {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-10000>;;PADO delay (in milliseconds)";
            range "0..10000";
          }
        }

        // pppoe bba-group / pado delay service-name
        container service-name {
          tailf:info "Configure PADO delay dependent on the received Service Name";

          // pppoe bba-group / pado delay service-name string *
          list string {
            tailf:info "Delay the PADO response when there is an exact match onthe received Service Name";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;The string to exactly match the received Service Name";
              }
            }
            leaf delay {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<0-10000>;;PADO delay (in milliseconds)";
                range "0..10000";
              }
            }
          }
        }
      }
    }

    // pppoe bba-group / service
    container service {
      tailf:info "Modify service config";

      // pppoe bba-group / service selection disable
      container selection {
        tailf:info "Disable advertising of unrequested service names";
        leaf disable {
          tailf:info "Disable advertising of unrequested service names";
          type empty;
        }
      }
    }

    // pppoe bba-group / sessions
    container sessions {
      tailf:info "Change sessions configuration";

      // pppoe bba-group / sessions mac
      container mac {
        tailf:info "Limit or throttle PPPoE sessions from any one MAC address";
        uses pppoe-bba-group-sessions-grouping;
      }

      // pppoe bba-group / sessions vlan
      container vlan {
        tailf:info "Limit or throttle PPPoE sessions with matching vlan IDs";
        uses pppoe-bba-group-sessions-grouping;
      }

      // pppoe bba-group / sessions inner-vlan
      container inner-vlan {
        tailf:info "Limit or throttle PPPoE sessions with any one inner vlan ID";
        uses pppoe-bba-group-sessions-grouping;
      }

      // pppoe bba-group / sessions outer-vlan
      container outer-vlan {
        tailf:info "Limit or throttle PPPoE sessions with any one outer vlan ID";
        uses pppoe-bba-group-sessions-grouping;
      }

      // pppoe bba-group / sessions max limit
      container max {
        tailf:info "Set a per-card session limit";
        container limit {
          tailf:info "PPPoE sessions limit";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf value {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<1-65535>;;MAC session limit";
              range "1..65535";
            }
          }
          leaf threshold {
            tailf:info "Specify the threshold after which a warning will be displayed";
            type uint16 {
              tailf:info "<1-65535>;;Warning message threshold";
            }
          }
        }
      }

      // pppoe bba-group / sessions circuit-id
      container circuit-id {
        tailf:info "Limit or throttle PPPoE sessions with any one circuit ID";
        uses pppoe-bba-group-sessions-grouping;
      }

      // pppoe bba-group / sessions circuit-id-and-remote-id
      container circuit-id-and-remote-id {
        tailf:info "Limit or throttle PPPoE sessions by circuit ID and remote ID";
        uses pppoe-bba-group-sessions-grouping;
      }
    }

    // pppoe bba-group / control-packets priority
    container control-packets {
      tailf:info "Change control-packets configuration";
      leaf priority {
        tailf:info "Set the CoS Priority to use in PPPoE and PPP control packets.";
        type uint8 {
          tailf:info "<0-7>;;Priority bits for outgoing PPPoE and PPP control packets";
          range "0..7";
        }
      }
    }

    // pppoe bba-group / invalid-session-id
    leaf invalid-session-id {
      tailf:info "Specify behaviour for when a packet with an invalid session ID is received";
      type enumeration {
        enum drop {
          tailf:info "Silently drop packets with an invalid session ID.";
        }
        enum log {
          tailf:info "Log packets with an invalid session ID.";
        }
      }
    }
  }

  // pppoe bba-group / sessions mac
  // pppoe bba-group / sessions inner-vlan
  grouping pppoe-bba-group-sessions-grouping {

    // pppoe bba-group / sessions mac limit
    container limit {
      tailf:info "PPPoE sessions limit";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf value {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<1-65535>;;MAC session limit";
          range "1..65535";
        }
      }
      leaf threshold {
        tailf:info "Specify the threshold after which a warning will be displayed";
        type uint16 {
          tailf:info "<1-65535>;;Warning message threshold";
        }
      }
    }

    // pppoe bba-group / sessions mac throttle
    container throttle {
      tailf:info "Throttle PPPoE sessions";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf limit {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint16 {
          tailf:info "<1-65535>;;Number of requests at which to throttle";
          range "1..65535";
        }
      }
      leaf request-period {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint8 {
          tailf:info "<1-100>;;Throttle request period";
          range "1..100";
        }
      }
      leaf block-period {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-100>;;Throttle blocking period";
        }
      }
    }
  }

  // router eigrp * / address-family * /
  // router eigrp * / address-family * / interface *
  grouping router-eigrp-if-grouping {

  }

  // router eigrp * / address-family ipv4 /
  // router eigrp * / address-family ipv6 /
  grouping router-eigrp-af-grouping {

    // router eigrp * / address-family * / passive-interface default
    container passive-interface {
      tailf:info "Suppress routing updates on all interfaces";
      leaf default {
        tailf:info "Interfaces passive by default";
        type empty;
      }
    }

    // router eigrp * / address-family * / stub
    container stub {
      tailf:info "EIGRP stub";
      tailf:cli-compact-syntax;
      tailf:cli-delete-when-empty;
      tailf:cli-reset-container;
      presence true;
      leaf connected {
        tailf:info "Do advertise connected routes";
        type empty;
      }
      leaf redistributed {
        tailf:info "Do advertise redistributed routes";
        type empty;
      }
      leaf static {
        tailf:info "Do advertise static routes";
        type empty;
      }
      leaf summary {
        tailf:info "Do advertise summary routes";
        type empty;
      }
    }

    // router eigrp * / address-family * / timers
    container timers {
      tailf:info "Configure EIGRP timers";

      // router eigrp * / address-family * / timers nsf
      container nsf {
        tailf:info "Configure NSF timers";

        // router eigrp * / address-family * / timers nsf route-hold
        leaf route-hold {
          tailf:info "Route hold time for inactive peer";
          type uint16 {
            tailf:info "<20-6000>;;Hold time (in seconds)";
            range "20..6000";
          }
        }
      }
    }

    // router eigrp * / address-family * / distance
    container distance {
      tailf:info "Set distance for EIGRP routes";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf internal {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint8 {
          tailf:info "<1-255>;;Internal routes' distance";
          range "1..255";
        }
      }
      leaf external {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-255>;;External routes' distance";
          range "1..255";
        }
      }
    }

    // router eigrp * / address-family * / maximum-paths
    leaf maximum-paths {
      tailf:info "Maximum paths";
      type uint8 {
        tailf:info "<1-32>;;number of paths";
        range "1..32";
      }
    }

    // router eigrp * / address-family * / router-id
    leaf router-id {
      tailf:info "Set router ID";
      type inet:ipv4-address {
        tailf:info "A.B.C.D;;Router ID";
      }
    }

    // router eigrp * / address-family * / route-policy * in|out
    uses route-policy-list-grouping;

    // router eigrp * / address-family * / metric
    container metric {
      tailf:info "Modify EIGRP routing metrics and parameters";

      // router eigrp * / address-family * / metric maximum-hops
      leaf maximum-hops {
        tailf:info "Advertise EIGRP routes greater than <hops> as unreachable";
        type uint8 {
          tailf:info "<1-255>;;Hop count";
          range "1..255";
        }
      }

      // router eigrp * / address-family * / metric weights
      container weights {
        tailf:info "EIGRP metric coefficients";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf tos {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<0-0>;;Type of Service (Only TOS 0 supported)";
            range "0";
          }
        }
        leaf k1 {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<0-255>;;K1";
          }
        }
        leaf k2 {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<0-255>;;K2";
          }
        }
        leaf k3 {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<0-255>;;K3";
          }
        }
        leaf k4 {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<0-255>;;K4";
          }
        }
        leaf k5 {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<0-255>;;K5";
          }
        }
      }

      // router eigrp * / address-family * / metric version
      leaf version {
        tailf:info "Change the EIGRP metric version";
        type enumeration {
          enum "32bit" {
            tailf:info "Change to 32-bit metric version";
          }
        }
      }
    }

    // router eigrp * / address-family * / default-metric
    container default-metric {
      tailf:info "Set metric of redistributed routes";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf bandwidth {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint32 {
          tailf:info "<1-4294967295>;;Bandwidth in Kbits per second";
          range "1..4294967295";
        }
      }
      leaf delay {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint32 {
          tailf:info "<1-4294967295>;;Delay metric, in 10 microsecond units";
          range "1..4294967295";
        }
      }
      leaf reliability {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint8 {
          tailf:info "<0-255>;;Reliability metric where 255 is 100% reliable";
        }
      }
      leaf loading {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint8 {
          tailf:info "<1-255>;;Effective bandwidth metric (Loading) where 255 is 100% loaded";
          range "1..255";
        }
      }
      leaf mtu {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<1-65535>;;Maximum Transmission Unit metric of the path";
        }
      }
    }

    // router eigrp * / address-family * / log-neighbor-changes
    leaf log-neighbor-changes {
      tailf:info "Enable/Disable EIGRP neighbor logging";
      type empty;
    }

    // router eigrp * / address-family * / log-neighbor-warnings
    leaf log-neighbor-warnings {
      tailf:info "Enable/Disable EIGRP neighbor warnings";
      type empty;
    }

    // router eigrp * / address-family * / autonomous-system
    leaf autonomous-system {
      tailf:info "Set the autonomous system of VRF";
      type uint16 {
        tailf:info "<1-65535>;;Autonomous system number";
        range "1..65535";
      }
    }

    // router eigrp * / address-family * / redistribute
    container redistribute {
      tailf:info "Redistribute another protocol";

      // router eigrp * / address-family * / redistribute bgp *
      // router eigrp * / address-family * / redistribute isis *
      // router eigrp * / address-family * / redistribute ospf *
      // router eigrp * / address-family * / redistribute eigrp *
      list protocol-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "protocol id";
        leaf protocol {
          type enumeration {
            enum bgp {
              tailf:info "Border Gateway Protocol (BGP) routes";
            }
            enum isis {
              tailf:info "Intermediate System-to-Intermediate System (IS-IS) routes";
            }
            enum ospf {
              tailf:info "Open Shortest Path First (OSPF) routes";
            }
            enum eigrp {
              tailf:info "EIGRP routes";
            }
          }
        }
        leaf id {
          type string {
            tailf:info "WORD;;Process ID (AS number, instance name or number";
          }
        }
        leaf route-policy {
          tailf:info "Filter using an RPL policy";
          tailf:cli-suppress-leafref-in-diff;
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:route-policy/name";
          }
          type string {
            tailf:info "WORD;;Name of the policy";
          }
        }
      }

      // router eigrp * / address-family * / redistribute connected
      // router eigrp * / address-family * / redistribute rip
      // router eigrp * / address-family * / redistribute static
      // router eigrp * / address-family * / redistribute subscriber
      list name-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type enumeration {
            enum connected {
              tailf:info "Connected routes";
            }
            enum rip {
              tailf:info "Routing Information Protocol (RIP) routes";
            }
            enum static {
              tailf:info "Static routes";
            }
            enum subscriber {
              tailf:info "Subscriber routes";
            }
          }
        }
        leaf route-policy {
          tailf:info "Filter using an RPL policy";
          tailf:cli-suppress-leafref-in-diff;
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:route-policy/name";
          }
          type string {
            tailf:info "WORD;;Name of the policy";
          }
        }
      }
    }

    // router eigrp * / address-family * / interface *
    list interface {
      tailf:info "EIGRP interface configuration submode";
      tailf:cli-mode-name "config-eigrp-vrf-af-if";
      key name;
      leaf name {
        type ifname;
      }

      // router eigrp * / address-family * / interface * / authentication keychain
      container authentication {
        tailf:info "Authentication configuration";
        leaf keychain {
          tailf:info "Authentication keychain configuration";
          type string {
            tailf:info "WORD;;Authentication keychain name";
          }
        }
      }

      // router eigrp * / address-family * / interface * / metric
      container metric {
        tailf:info "Metric";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        leaf bandwidth {
          tailf:info "Interface bandwidth";
          type uint32 {
            tailf:info "<1-4294967295>;;Bandwidth in Kbits per second";
            range "1..4294967295";
          }
        }
        leaf delay {
          tailf:info "Interface delay";
          type uint32 {
            tailf:info "<1-4294967295>;;Delay metric, in 10 microsecond units";
          }
        }
        leaf picoseconds {
          tailf:info "Interpret configured delay to be in picosecond units";
          when "../delay";
          type empty;
        }
        leaf reliability {
          tailf:info "Interface reliability";
          type uint8 {
            tailf:info "<0-255>;;Reliability metric where 255 is 100% reliable";
          }
        }
        leaf load {
          tailf:info "Interface load";
          type uint8 {
            tailf:info "<1-255>;;Load metric where 255 is 100% loaded";
          }
        }
      }

      // router eigrp * / address-family * / interface * / hello-interval
      leaf hello-interval {
        tailf:info "Hello interval";
        type uint16 {
          tailf:info "<1-65535>;;Interval (in seconds)";
          range "1..65535";
        }
      }

      // router eigrp * / address-family * / interface * / hold-time
      leaf hold-time {
        tailf:info "Hold Time";
        type uint16 {
          tailf:info "<1-65535>;;Neighbor hold time (in seconds)";
          range "1..65535";
        }
      }

      // router eigrp * / address-family * / interface * / neighbor *
      list neighbor {
        tailf:info "Configure Neighbor";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key address;
        leaf address {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Neighbor IPv4 address";
          }
        }
        leaf remote {
          tailf:info "Configure max-hop count";
          type uint8 {
            tailf:info "<2-100>;;Maxhops range";
            range "2..100";
          }
        }
      }

      // router eigrp * / address-family * / interface * / summary-address *
      list summary-address {
        tailf:info "Summary address";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key prefix;
        leaf prefix {
          type union {
            type ipv4-prefix {
              tailf:info "A.B.C.D/length;;IPv4 Prefix/length or Prefix and Mask";
            }
            type tailf:ipv6-address-and-prefix-length {
              tailf:info "X:X::X/length;;IPv6 Prefix";
            }
          }
        }
        leaf admin-distance {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<1-255>;;Administrative distance";
            range "1..255";
          }
        }
      }

      // router eigrp * / address-family * / interface * / bandwidth-percent
      leaf bandwidth-percent {
        tailf:info "Bandwidth limit";
        type uint32 {
          tailf:info "<1-999999>;;Percent";
          range "1..999999";
        }
      }

      // router eigrp * / address-family * / interface * / passive-interface
      container passive-interface {
        tailf:info "Suppress routing updates on an interface";
        tailf:cli-delete-when-empty;
        tailf:cli-reset-container;
        presence true;
        leaf disable {
          tailf:info "disable";
          type empty;
        }
      }

      // router eigrp * / address-family * / interface * / route-policy * in|out
      uses route-policy-list-grouping;

      // router eigrp * / address-family * / interface * / site-of-origin
      leaf site-of-origin {
        tailf:info "Configure Site-of-origin";
        type asn-ip-type;
      }
    }
  }

  // router eigrp * /
  // router eigrp * / vrf *
  grouping router-eigrp-grouping {

    // router eigrp * / address-family
    container address-family {
      tailf:info "EIGRP address-family configuration submode";

      // router eigrp * / address-family ipv4
      container ipv4 {
        tailf:info "IPv4 Address Family";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-eigrp-af";
        presence true;
        uses router-eigrp-af-grouping;
      }

      // router eigrp * / address-family ipv6
      container ipv6 {
        tailf:info "IPv6 Address Family";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-eigrp-af";
        presence true;
        uses router-eigrp-af-grouping;
      }
    }
  }


  // router msdp
  // router msdp / vrf *
  grouping router-msdp-grouping {

    // router msdp / connect-source
    container connect-source {
      tailf:info "Configure source address used for MSDP connection";
      uses interface-name-grouping;
    }

    // router msdp / originator-id
    leaf originator-id {
      tailf:info "Configure MSDP Originator ID";
      tailf:cli-no-value-on-delete;
      type ifname;
    }

    // router msdp / cache-sa-state
    container cache-sa-state {
      tailf:info "Configure this systems SA cache access-lists";

      // router msdp / cache-sa-state rp-list
      leaf rp-list {
        tailf:info "Access-list for originating RP";
        type string {
          tailf:info "WORD;;Access list name";
        }
      }

      // router msdp / cache-sa-state list
      leaf list {
        tailf:info "Access-list";
        type string {
          tailf:info "WORD;;Access list name";
        }
      }
    }

    // router msdp / cache-sa-holdtime
    leaf cache-sa-holdtime {
      tailf:info "Configure Cache SA State holdtime period";
      type uint16 {
        tailf:info "<150-3600>;;Holdtime period in secs";
        range "150..3600";
      }
    }

    // router msdp / peer *
    list peer {
      tailf:info "MSDP Peer configuration subcommands";
      tailf:cli-mode-name "config-msdp-peer";
      key address;
      leaf address {
        type inet:host {
          tailf:info "Hostname or A.B.C.D;;Peer name or address";
        }
      }

      // router msdp / peer * / connect-source
      leaf connect-source {
        tailf:info "Configure source address used for MSDP connection";
        tailf:cli-no-value-on-delete;
        type ifname;
      }

      // router msdp / peer * / description
      uses description-grouping;

      // router msdp / peer * / mesh-group
      leaf mesh-group {
        tailf:info "Configure an MSDP mesh-group";
        type string {
          tailf:info "WORD;;Name of mesh-group";
        }
      }

      // router msdp / peer * / sa-filter *
      list sa-filter {
        tailf:info "Filter SA messages from peer";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key direction;
        leaf direction {
          type enumeration {
            enum in {
              tailf:info "Enable incoming SA filtering";
            }
            enum out {
              tailf:info "Enable outgoing SA filtering";
            }
          }
        }

        // router msdp / peer * / sa-filter * list
        leaf list {
          tailf:info "Access-list";
          type string {
            tailf:info "WORD;;Access list name";
          }
        }

        // router msdp / peer * / sa-filter * rp-list
        leaf rp-list {
          tailf:info "Access-list for originating RP";
          type string {
            tailf:info "WORD;;Access list name";
          }
        }
      }

      // router msdp / peer * / maximum
      container maximum {
        tailf:info "maximum number of SA accepted by this peer";
        leaf external-sa {
          tailf:info "maximum number of SA accepted by this peer";
          type uint32 {
            tailf:info "<1-75000>;;maximum number of SA accepted by this peer";
          }
        }
      }


      // router msdp / peer * / maximum
      container password {
        tailf:info "Configure password used for MSDP connection";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf enc-type {
          tailf:cli-drop-node-name;
          type enumeration {
            enum clear {
              tailf:info "Specifies an UNENCRYPTED password will follow";
            }
            enum encrypted {
              tailf:info "Specifies an ENCRYPTED password will follow";
            }
          }
        }
        leaf password {
          tailf:cli-drop-node-name;
          tailf:cli-multi-value;
          cli:secret;
          type NEDCOM_SECRET_TYPE {
            tailf:info "LINE;;The password";
          }
        }
      }

      // router msdp / peer * / remote-as
      leaf remote-as {
        tailf:info "Configure the remote AS of this peer";
        type union {
          type uint32 {
            tailf:info "<1-4294967295>;;AS of peer";
          }
          type string {
            tailf:info "<1.0-XX.YY>;;AS of peer";
            pattern '[0-9]+\.[0-9]+';
          }
        }
      }
    }
    container sa-filter {
      tailf:info "Filter SA messages from peer";
      grouping access-list-grouping {
        leaf list {
          tailf:info "Access-list";
          type string {
            tailf:info "WORD;;Access list name";
          }
        }
        leaf rp-list {
          tailf:info "Access-list for originating RP";
          type string {
            tailf:info "WORD;;Access list name";
          }
        }
      }
      container in {
        tailf:info "Enable incoming SA filtering";
        uses access-list-grouping;
      }
      container out {
        tailf:info "Enable outgoing SA filtering";
        uses access-list-grouping;
      }
    }
  }


  // router rip / route-policy * in|out
  // router ospf * / area * / route-policy
  // router bgp * / neighbor * / address-family * / route-policy * in|out
  // router eigrp * / address-family * / route-policy * in|out
  grouping route-policy-list-grouping {
    list route-policy {
      tailf:info "Apply route policy";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-remove-before-change;
      key direction;
      leaf direction {
        type enumeration {
          enum in {
            tailf:info "Apply route policy to inbound routes";
          }
          enum out {
            tailf:info "Apply route policy to outbound routes";
          }
        }
      }
      leaf name {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        cisco-ios-xr:string-remove-quotes "route-policy <STRING>";
        tailf:cli-suppress-leafref-in-diff;
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:route-policy/name";
        }
        type string {
          tailf:info "WORD;;Name of the policy";
        }
      }
    }
  }


  grouping telemetry-policy-driven-encoder-grouping {

    // telemetry policy-driven / encoder * / policy group *
    container policy {
      tailf:info "policy";
      list group {
        tailf:info "group";
        tailf:cli-mode-name "config-policy-group";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;policy group name";
          }
        }

        // telemetry policy-driven / encoder * / policy group * / policy *
        list policy {
          tailf:info "Policy name";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Policy name";
            }
          }
        }

        // telemetry policy-driven / encoder * / policy group * / source interface
        container source {
          tailf:info "Bind point for destinations in this policy group";
          container interface {
            tailf:info "Source interface name";
            uses interface-name-grouping;
          }
        }

        // telemetry policy-driven / encoder * / policy group * / transport
        container transport {
          tailf:info "Encoder configuration";

          // telemetry policy-driven / encoder * / policy group * / transport tcp
          container tcp {
            tailf:info "Encoder configuration";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-telem-plcy-driven-gpb";
            presence true;

            // telemetry policy-driven / encoder * / policy group * / transport tcp / encoding-format gpb-compact
            container encoding-format {
              tailf:info "Encoding Format configuration";
              leaf gpb-compact {
                tailf:info "GPB compact format";
                type empty;
              }
            }
          }
        }

        // telemetry policy-driven / encoder * / policy group * / destination
        container destination {
          tailf:info "Destination";

          // telemetry policy-driven / encoder * / policy group * / destination ipv4 *
          list ipv4 {
            tailf:info "IPv4 destination";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key "address port";
            leaf address {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Destination IP address";
              }
            }
            leaf port {
              tailf:info "Destination port number";
              tailf:cli-expose-key-name;
              type uint16 {
                tailf:info "<1-65535>;;Destination port number";
                range "1..65535";
              }
            }
          }

          // telemetry policy-driven / encoder * / policy group * / destination ipv6 *
          list ipv6 {
            tailf:info "IPv6 destination";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key "address port";
            leaf address {
              type inet:ipv6-address {
                tailf:info "X:X::X;;Destination IP address";
              }
            }
            leaf port {
              tailf:info "Destination port number";
              tailf:cli-expose-key-name;
              type uint16 {
                tailf:info "<1-65535>;;Destination port number";
                range "1..65535";
              }
            }
          }
        }
      }
    }
  }

  grouping telemetry-model-driven-dest-addr-grouping {

    // telemetry model-driven / destination-group * / address family ipv4 * / encoding
    leaf encoding {
      tailf:info "Transport Protocol Encoding configuration";
      type enumeration {
        enum gpb {
          tailf:info "gpb encoding";
        }
        enum self-describing-gpb {
          tailf:info "self describing gpb encoding";
        }
        enum json {
          tailf:info "json encoding";
        }
      }
    }

    // telemetry model-driven / destination-group * / address family ipv4 * / protocol
    container protocol {
      tailf:info "Transport Protocol configuration";
      choice protocol-choice {
        container udp {
          tailf:info "udp";
          tailf:cli-delete-when-empty;
          tailf:cli-reset-container;
          presence true;
          leaf packetsize {
            tailf:info "Packet Size";
            type uint16 {
              tailf:info "<484-65507>;;PacketSize";
              range "484..65507";
            }
          }
        }
        container tcp {
          tailf:info "tcp";
          presence true;
        }

        // telemetry model-driven / destination-group * / address family ipv4 * / protocol grpc
        container grpc {
          tailf:info "grpc";
          tailf:cli-compact-syntax;
          tailf:cli-delete-when-empty;
          tailf:cli-reset-container;
          presence true;
          leaf no-tls {
            tailf:info "no tls";
            type empty;
          }
          leaf tls-hostname {
            tailf:info "tls hostname";
            type string {
              tailf:info "WORD;;hostname";
            }
          }
        }
      }
    }
  }

  // interface tunnel-te* / affinity-value
  // mpls traffic-eng / attribute-set * affinity
  grouping affinity-grouping {
    container affinity {
      tailf:info "Link attributes for links traversed by tunnel";

      // interface tunnel-te* / affinity
      container affinity-value {
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf value {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type string {
            tailf:info "<0x0-0xffffffff>;;Affinity value";
            pattern "0x[0-9a-fA-F]+";
          }
        }
        leaf mask {
          type string {
            tailf:info "<0x0-0xffffffff>;;Affinity mask value";
            pattern "0x[0-9a-fA-F]+";
          }
        }
      }

      // interface * / affinity include *
      list include {
        tailf:info "Affinity to include in the loose sense";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          tailf:cli-multi-word-key;
          type string {
            tailf:info "WORD;;Affinity name";
          }
        }
      }

      // interface * / affinity include-strict *
      list include-strict {
        tailf:info "Affinity to include in the strict sense";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          tailf:cli-multi-word-key;
          type string {
            tailf:info "WORD;;Affinity name";
          }
        }
      }

      // interface * / affinity exclude *
      list exclude {
        tailf:info "Affinity to exclude";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          tailf:cli-multi-word-key;
          type string {
            tailf:info "WORD;;Affinity name";
          }
        }
      }

      // interface * / affinity ignore
      leaf ignore {
        tailf:info "All links are included in path calculation regardless of attributes";
        type empty;
      }
    }
  }


  grouping hw-module-location-list-grouping {

    // hw-module location *
    list location-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key id;
      leaf id {
        type string {
          tailf:info "WORD;;Fully qualified line card specification";
        }
      }

      // hw-module location * port-mode
      leaf port-mode {
        tailf:info "RXS: Configure R(consecutive N number of same speed ports)xS(speed 1 for 1G or 10 for 10G):48x10";
        type string {
          tailf:info "WORD;;Input a string with number of characters between 4 and 64";
        }
      }

      // hw-module location * qos-mode
      container qos-mode {
        tailf:info "Configure qos mode in HW Module port(s)";

        // hw-module location * qos-mode lowburst-enabled
        leaf lowburst-enabled {
          tailf:info "Configure lowburst mode";
          type empty;
        }
      }

      // hw-module location * tcp-mss-adjust np * value
      list tcp-mss-adjust {
        tailf:info "Configure TCP MSS Adjust for an NP";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key np;
        leaf np {
          tailf:info "NP to configure";
          tailf:cli-expose-key-name;
          type uint8 {
            tailf:info "<0-7>;;Number between 0-7";
            range "0..7";
          }
        }
        leaf value {
          tailf:info "TCP MSS adjust value";
          type uint16 {
            tailf:info "<1280-1535>;;TCP MSS Adjust value for all interfaces on this NP";
            range "1280..1535";
          }
        }
      }
    }

    // hw-module location * bay * port * breakout
    list location-bay-breakout-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      key "id bay port";
      leaf id {
        type string {
          tailf:info "WORD;;Fully qualified line card specification";
        }
      }
      leaf bay {
        tailf:info "Breakout bay configuration";
        tailf:cli-expose-key-name;
        type uint8 {
          tailf:info "<uint8>;;Breakout port number";
        }
      }
      leaf port {
        tailf:info "port number";
        tailf:cli-expose-key-name;
        type uint8 {
          tailf:info "<uint8>;;Breakout port number";
        }
      }
      leaf breakout {
        tailf:info "breakout interface types";
        type string {
          tailf:info "WORD;;Interface mode";
        }
      }
    }

    // hw-module location * port * breakout
    list location-breakout-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      key "id port";
      leaf id {
        type string {
          tailf:info "WORD;;Fully qualified line card specification";
        }
      }
      leaf port {
        tailf:info "port number";
        tailf:cli-expose-key-name;
        type uint8 {
          tailf:info "<uint8>;;port number";
        }
      }
      leaf breakout {
        tailf:info "breakout interface types";
        type string {
          tailf:info "WORD;;Interface mode";
        }
      }
    }

    // hw-module location * slice * breakout
    list location-slice-breakout {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      key "name slice";
      leaf name {
        type string {
          tailf:info "WORD;;Fully qualified location specification";
        }
      }
      leaf slice {
        tailf:cli-expose-key-name;
        tailf:info "Target slice";
        type uint8 {
          tailf:info "WORD;;Slice number 0 to 4";
          range "0..4";
        }
      }
      leaf breakout {
        tailf:info "breakout interface types";
        type string {
          tailf:info "WORD;;Interface mode";
        }
      }
    }

    // hw-module location * slice *
    list location-slice-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-incomplete-command;
      key "name slice";
      leaf name {
        type string {
          tailf:info "WORD;;Fully qualified location specification";
        }
      }
      leaf slice {
        tailf:cli-expose-key-name;
        tailf:info "Target slice";
        type uint8 {
          tailf:info "WORD;;Slice number 0 to 3";
          range "0..3";
        }
      }
      // hw-module location * slice * client bitrate
      container client {
        tailf:info "client side parameters";
        tailf:cli-flatten-container;
        leaf bitrate {
          tailf:info "bit rate";
          tailf:cli-incomplete-command;
          type enumeration {
            enum 100G {
              tailf:info "client bitrate 100G";
            }
            enum 10G {
              tailf:info "client bitrate 10G";
            }
            enum 40G {
              tailf:info "client bitrate 40G";
            }
          }
        }
      }
      // hw-module location * slice * trunk bitrate
      container trunk {
        tailf:info "trunk side parameters";
        tailf:cli-flatten-container;
        leaf bitrate {
          tailf:info "bit rate";
          type enumeration {
            enum 100G {
              tailf:info "trunk bitrate 100G";
            }
            enum 200G {
              tailf:info "trunk bitrate 200G";
            }
            enum 250G {
              tailf:info "trunk bitrate 250G";
            }
          }
        }
      }
      leaf fec {
        tailf:info "Forward Error Correction mode";
        type enumeration {
          enum SoftDecision7 {
            tailf:info "Forward Error Correction SoftDecision7";
          }
          enum SoftDecision20 {
            tailf:info "Forward Error Correction SoftDecision20";
          }
        }
      }
      leaf encrypted {
        tailf:info "Enable MACSec mode of operation";
        type empty;
      }
    }
  }

  // ipv6 mobile pmipv6-lma * domain * / heartbeat
  // ipv6 mobile pmipv6-lma * domain * / mobility-service mobile-local-loop / customer * vrf * / heartbeat
  grouping ipv6-mobile-heartbeat-grouping {
    container heartbeat {
      tailf:info "heartbeat config for this Customer";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf interval {
        tailf:info "interval value";
        tailf:cli-incomplete-command;
        type uint16 {
          tailf:info "<10-3600>;;Specify the interval value in second";
          range "10..3600";
        }
      }
      leaf retries {
        tailf:info "retry value";
        tailf:cli-incomplete-command;
        type uint8 {
          tailf:info "<1-10>;;Specify the retry value";
          range "1..10";
        }
      }
      leaf timeout {
        tailf:info "timeout value";
        type uint16 {
          tailf:info "<1-3600>;;Specify the timeout value";
          range "1..3600";
        }
      }
    }
  }

  grouping ipv6-mobile-mnp-maximum-grouping {

    // ipv6 mobile pmipv6-lma * domain * / mobility-service mobile-local-loop / mnp afi-all logical-mn
    container logical-mn {
      tailf:info "mnp limit config for all logical mn's";
      leaf maximum {
        tailf:info "Maximum Prefixes for all Logical MN's";
        type uint8 {
          tailf:info "<1-32>;;Number of MNPs";
          range "1..32";
        }
      }
    }

    // ipv6 mobile pmipv6-lma * domain * / mobility-service mobile-local-loop / mnp afi-all customer
    container customer {
      tailf:info "mnp limit config for customer";
      leaf maximum {
        tailf:info "Maximum Prefixes for this customer";
        type uint32 {
          tailf:info "<1-4000000>;;Number of MNPs";
          range "1..4000000";
        }
      }
    }
  }

  // ipv6 mobile pmipv6-lma * domain * / mobility-service mobile-local-loop / mnp
  grouping ipv6-mobile-mnp-grouping {
    container mnp {
      tailf:info "configure mobile node prefix limits";

      // ipv6 mobile pmipv6-lma * domain * / mobility-service mobile-local-loop / mnp afi-all
      container afi-all {
        tailf:info "configure mobile node prefix limits";
        uses ipv6-mobile-mnp-maximum-grouping;
      }

      // ipv6 mobile pmipv6-lma * domain * / mobility-service mobile-local-loop / mnp ipv4
      container ipv4 {
        tailf:info "configure mobile node IPv4 prefix limits";
        uses ipv6-mobile-mnp-maximum-grouping;
      }

      // ipv6 mobile pmipv6-lma * domain * / mobility-service mobile-local-loop / mnp ipv6
      container ipv6 {
        tailf:info "configure mobile node IPv6 prefix limits";
        uses ipv6-mobile-mnp-maximum-grouping;
      }
    }
  }

  grouping ssh-server-vrf-grouping {
    list vrf {
      tailf:info "Cisco VRF name";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Enter vrf name";
        }
      }
      container ipv4 {
        tailf:info "IPv4 access list for ssh server";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf access-list {
          tailf:info "Configure IPv4 access-list";
          tailf:cli-suppress-leafref-in-diff;
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:ipv4/access-list/named-acl/name";
          }
          type string {
            tailf:info "WORD;;Name of IPv4 access list - Max 32 characters";
          }
        }
      }
      container ipv6 {
        tailf:info "IPv6 access list for ssh server";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf access-list {
          tailf:info "Configure IPv6 access-list";
          tailf:cli-suppress-leafref-in-diff;
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:ipv6/access-list/named-acl/name";
          }
          type string {
            tailf:info "WORD;;Name of IPv6 access list - Max 32 characters";
          }
        }
      }
    }
  }

  // aaa radius attribute
  grouping aaa-radius-attribute-grouping {

    // aaa radius attribute ? format
    leaf format {
      tailf:info "AAA nas-port-id attribute format";
      tailf:cli-full-command;
      type string {
        tailf:info "WORD;;nas-port-id attribute format name";
      }
    }

    // aaa radius attribute ? format ? type *
    list nas-port-type-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      key type;
      leaf type {
        tailf:info "AAA nas-port attribute format";
        tailf:cli-expose-key-name;
        type uint8 {
          tailf:info "<0-44>;;Nas-Port-Type value to apply format name on";
          range "0..44";
        }
      }
      leaf format {
        tailf:info "AAA nas-port-id attribute format";
        tailf:cli-prefix-key;
        type string {
          tailf:info "WORD;;nas-port-id attribute format name";
        }
      }
    }
  }

  // aaa accounting exec *
  grouping aaa-accounting-grouping {
    leaf notice {
      tailf:cli-drop-node-name;
      type enumeration {
        enum start-stop {
          tailf:info "start and stop records";
        }
        enum stop-only {
          tailf:info "stop records only";
        }
      }
    }
    leaf group {
      tailf:info "Use Server-group";
      tailf:cli-optional-in-sequence;
      type union {
        type string {
          tailf:info "WORD;;server-group name";
        }
        type enumeration {
          enum radius {
            tailf:info "Use list of all Radius hosts";
          }
          enum "tacacs+" {
            tailf:info "Use list of all TACACS+ hosts";
          }
        }
      }
    }
    container group2 {
      when "../group" {
        tailf:dependency "../group";
      }
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      tailf:cli-optional-in-sequence;
      leaf group {
        tailf:info "Use Server-group 2";
        type string {
          tailf:info "WORD;;server-group2 name";
        }
      }
    }
    leaf local {
      tailf:info "Local command accounting using syslog";
      tailf:cli-optional-in-sequence;
      type empty;
    }
    leaf none {
      tailf:info "No accounting";
      type empty;
    }
  }


  grouping if-l2transport-l2protocol-grouping {
    leaf policy {
      tailf:cli-drop-node-name;
      type enumeration {
        enum drop {
          tailf:info "Drop this protocol's packets";
        }
        enum forward {
          tailf:info "Forward this protocol's packets";
        }
        enum tunnel {
          tailf:info "Tunnel this protocol's packets";
        }
      }
    }
    leaf experimental {
      tailf:info "Modify the MPLS Experimental bits";
      type uint8 {
        tailf:info "<0-7>;;Set the MPLS experimental bits for this interface";
        range "0..7";
      }
    }
  }


  // multicast-routing / address-family ipv4 / mdt data a.b.c.d
  // multicast-routing / address-family ipv4 / mdt data <max-data-mdts>
  // multicast-routing / address-family ipv4 / mdt data mldp
  grouping multicast-routing-af-mdt-data-grouping {
    leaf route-policy {
      tailf:info "DATA MDT Route policy";
      tailf:cli-optional-in-sequence;
      tailf:cli-suppress-leafref-in-diff;
      tailf:non-strict-leafref {
        path "/cisco-ios-xr:route-policy/name";
      }
      type string {
        tailf:info "WORD;;Route policy name";
      }
    }
    leaf attribute-set {
      tailf:info "The Attribute Set template to be used with the TE tunnel request";
      tailf:cli-optional-in-sequence;
      type string {
        tailf:info "WORD;;Name of template describing the Attribute Set";
      }
    }
    leaf threshold {
      tailf:info "Traffic rate threshold in Kbps to trigger Data MDT";
      tailf:cli-optional-in-sequence;
      type uint32 {
        tailf:info "<0-4294967295>;;Threshold value (kbps). Default 1kbps";
      }
      default 1;
    }
    leaf acl-name {
      tailf:cli-drop-node-name;
      tailf:cli-optional-in-sequence;
      tailf:cli-disallow-value "threshold|immediate-switch|route-policy";
      tailf:cli-suppress-leafref-in-diff;
      tailf:non-strict-leafref {
        path "/cisco-ios-xr:ipv4/access-list/named-acl/name";
      }
      type string {
        tailf:info "WORD;;ACL for Customer VRF groups allowed to do Data MDT";
      }
    }
    leaf immediate-switch {
      tailf:info "Switch to Data MDT immediately";
      type empty;
    }
  }


  grouping key-duration-grouping {
    leaf start-time {
      tailf:cli-drop-node-name;
      type string {
        tailf:info "hh:mm:ss;;Time to start";
        pattern "[0-9][0-9]:[0-9][0-9]:[0-9][0-9]";
      }
    }
    leaf start-month {
      tailf:cli-drop-node-name;
      type month-type;
    }
    leaf start-day {
      tailf:cli-drop-node-name;
      type uint8 {
        tailf:info "<1-31>;;Day of the month to start";
        range "1..31";
      }
    }
    leaf start-year {
      tailf:cli-drop-node-name;
      type uint16 {
        tailf:info "<1993-2035>;;Year to start";
        range "1993..2035";
      }
    }

    choice stop-choice {
      case duration {
        leaf duration {
          tailf:info "Lifetime duration";
          type uint32 {
            tailf:info "<1-2147483646>;;duration in seconds";
            range "1..2147483646";
          }
        }
      }
      case infinite {
        leaf infinite {
          tailf:info "Never expires";
          type empty;
        }
      }
      case stop-time {
        leaf stop-time {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "hh:mm:ss;;Time to stop";
            pattern "[0-9][0-9]:[0-9][0-9]:[0-9][0-9]";
          }
        }
        leaf stop-month {
          tailf:cli-drop-node-name;
          type month-type;
        }
        leaf stop-day {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<1-31>;;Day of the month to stop";
            range "1..31";
          }
        }
        leaf stop-year {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1993-2035>;;Year to stop";
            range "1993..2035";
          }
        }
      }
    }
  }


  // tpa / vrf * /
  grouping tpa-af-grouping {

    // tpa / vrf * / address-family * / default-route mgmt
    container default-route {
      tailf:info "Linux default route configuration";
      leaf mgmt {
        tailf:info "Set if default should be routed via the RP.";
        type empty;
      }
    }

    // tpa / vrf * / address-family * / update-source
    container update-source {
      tailf:info "Update the Source for Third Party";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf dataports {
        tailf:info "Set the update source for all dataports";
        tailf:cli-optional-in-sequence;
        type empty;
      }
      leaf active-management {
        tailf:info "Use the management port on the Active RP";
        tailf:cli-optional-in-sequence;
        tailf:cli-full-command;
        type empty;
      }
      uses interface-name-grouping;
    }

    // tpa / vrf * / address-family * / protection
    container protection {
      tailf:info "Configure traffic protection for Third Party Applications";
      tailf:cli-add-mode;
      list allow {
        tailf:info "TPA filtering entry to restrict incoming traffic";
        tailf:cli-suppress-mode;
        key "protocol local-port interface local-address remote-address";
        leaf protocol {
          tailf:info "L4 protocol";
          tailf:cli-expose-key-name;
          type enumeration {
            enum tcp {
              tailf:info "Transmission Control Protocol, RFC 793. (6)";
            }
            enum udp {
              tailf:info "User Datagram Protocol, RFC 768. (17)";
            }
          }
        }
        leaf local-port {
          tailf:info "local L4 port";
          tailf:cli-expose-key-name;
          type uint16 {
            tailf:info "<1-65535>;;Enter local Port number";
          }
        }
        leaf interface {
          tailf:info "Select an interface to restrict traffic to";
          tailf:cli-expose-key-name;
          tailf:key-default "";
          cisco-ios-xr:trim-empty-key;
          type string {
            tailf:info "WORD;;Select an interface to restrict traffic to";
          }
        }
        leaf local-address {
          tailf:info "Local address to filter against";
          tailf:cli-expose-key-name;
          tailf:key-default "";
          cisco-ios-xr:trim-empty-key;
          type union {
            type tailf:ipv4-address-and-prefix-length {
              tailf:info "A.B.C.D/length;;Enter local IPv4 address";
            }
            type tailf:ipv6-address-and-prefix-length {
              tailf:info "X:X::X/length;;Enter local IPv6 address";
            }
            type string {
              length "0";
            }
          }
        }
        leaf remote-address {
          tailf:info "Remote address to filter against";
          tailf:cli-expose-key-name;
          tailf:key-default "";
          cisco-ios-xr:trim-empty-key;
          type union {
            type tailf:ipv4-address-and-prefix-length {
              tailf:info "A.B.C.D/length;;Enter remote IPv4 address";
            }
            type tailf:ipv6-address-and-prefix-length {
              tailf:info "X:X::X/length;Enter remote IPv6 address";
            }
            type string {
              length "0";
            }
          }
        }
      }
    }
  }


  grouping call-home-profile-subscribe-to-alert-group-grouping {
    leaf periodic {
      tailf:info "Periodic call-home message";
      tailf:cli-incomplete-command;
      type empty;
    }
    choice frequency-choice {
      leaf daily {
        tailf:info "Daily call-home message";
        tailf:cli-incomplete-command;
        type empty;
      }
      leaf monthly {
        tailf:info "Monthly call-home message";
        tailf:cli-incomplete-command;
        type uint8 {
          tailf:info "<1-31>;;Day of month";
          range "1..31";
        }
      }
      leaf weekly {
        tailf:info "Weekly call-home message";
        tailf:cli-incomplete-command;
        type enumeration {
          enum monday;
          enum tuesday;
          enum wednesday;
          enum thursday;
          enum friday;
          enum saturday;
          enum sunday;
        }
      }
    }
    leaf time {
      tailf:cli-drop-node-name;
      type string {
        tailf:info "<0-23>:<0-59>;;HH:mm";
      }
    }
  }


  grouping router-isis-lsp-gen-interval-level-grouping {
    leaf maximum-wait {
      tailf:info "Maximum delay before generating an LSP";
      tailf:cli-optional-in-sequence;
      tailf:cli-incomplete-command;
      type uint32 {
        tailf:info "<0-120000>;;Delay in milliseconds";
        range "0..120000";
      }
    }
    leaf initial-wait {
      tailf:info "Initial delay before generating an LSP";
      tailf:cli-optional-in-sequence;
      tailf:cli-incomplete-command;
      type uint32 {
        tailf:info "<0-120000>;;Delay in milliseconds";
        range "0..120000";
      }
    }
    leaf secondary-wait {
      tailf:info "Secondary delay before generating an LSP";
      tailf:cli-optional-in-sequence;
      tailf:cli-incomplete-command;
      type uint32 {
        tailf:info "<0-120000>;;Delay in milliseconds";
        range "0..120000";
      }
    }
  }


  // rsvp / authentication
  // rsvp / interface * / authentication
  // rsvp / neighbor * / authentication
  grouping rsvp-authentication-grouping {
    container authentication {
      tailf:info "Configure RSVP authentication parameters";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-rsvp-if-auth";

      // rsvp / authentication / key-source key-chain
      container key-source {
        tailf:info "Specify key-source for authenticating RSVP signalling messages";
        leaf key-chain {
          tailf:info "Use key-chain to authenticate RSVP signalling messages";
          type string {
            tailf:info "WORD;;Name of key-chain";
          }
        }
      }

      // rsvp / authentication / window-size
      leaf window-size {
        tailf:info "Use window-size to limit number of out-of-order messages";
        type uint8 {
          tailf:info "<1-64>;;Window-size to restrict out of order messages";
          range "1..64";
        }
      }
    }
  }


  // ethernet oam profile * / link-monitor / frame /
  // ethernet oam profile * / link-monitor / frame-period /
  // ethernet oam profile * / link-monitor / frame-seconds /
  // ethernet oam profile * / link-monitor / symbol-period /
  grouping ethernet-oam-profile-link-monitor-frame-grouping {

    // ethernet oam profile * / link-monitor / frame window
    leaf window {
      tailf:info "window size for event configuration";
      tailf:cli-full-command;
      type uint32 {
        tailf:info "<uint32>;;Size of the window in milliseconds";
      }
    }

    // ethernet oam profile * / link-monitor / frame threshold
    container threshold {
      tailf:info "threshold for events";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf unit {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        tailf:cli-incomplete-command;
        type enumeration {
          enum frames {
            tailf:info "Use frames as the units for the frame-period threshold";
          }
          enum ppm {
            tailf:info "Use parts-per-million as the units for the threshold";
          }
          enum symbols {
            tailf:info "Use symbols as the units for the symbol-period threshold";
          }
        }
      }
      leaf low {
        tailf:info "low threshold for events";
        tailf:cli-optional-in-sequence;
        type uint32 {
          tailf:info "<1-4294967295>;;The low threshold for events";
        }
      }
      leaf low-unit {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        when "../low";
        type enumeration {
          enum thousand {
            tailf:info "Use thousands of the specified units";
          }
          enum million {
            tailf:info "Use millions of the specified units";
          }
          enum billion {
            tailf:info "Use billions of the specified units";
          }
        }
      }
      leaf high {
        tailf:info "high threshold for events";
        type uint32 {
          tailf:info "<1-4294967295>;;The high threshold for events";
        }
      }
      leaf high-unit {
        tailf:cli-drop-node-name;
        when "../high";
        type enumeration {
          enum thousand {
            tailf:info "Use thousands of the specified units";
          }
          enum million {
            tailf:info "Use millions of the specified units";
          }
          enum billion {
            tailf:info "Use billions of the specified units";
          }
        }
      }
    }
  }


  // ptp / profile * /
  // interface * / ptp /
  grouping ptp-profile-grouping {

    // ptp / profile * / multicast
    container multicast {
      tailf:info "Allow multicast messages to be sent";
      tailf:cli-delete-when-empty;
      tailf:cli-reset-container;
      presence true;

      // ptp / profile * / multicast target-address ethernet
      container target-address {
        tailf:info "Configure a target address";
        leaf ethernet {
          tailf:info "Configure ethernet target address";
          type enumeration {
            enum 01-1B-19-00-00-00 {
              tailf:info "Forwardable mac-address";
            }
            enum 01-80-C2-00-00-0E {
              tailf:info "Non-forwardable mac-address";
            }
          }
        }
      }
    }

    // ptp / profile * / transport
    leaf transport {
      tailf:info "PTP transport type to use on this interface";
      type enumeration {
        enum ethernet {
          tailf:info "Ethernet transport";
        }
        enum ipv4 {
          tailf:info "IPv4 transport";
        }
        enum ipv6 {
          tailf:info "IPv6 transport";
        }
      }
    }

    // ptp / profile * / port state
    container port {
      tailf:info "PTP port options";
      leaf state {
        tailf:info "Restrict the port state of this interface";
        type enumeration {
          enum any {
            tailf:info "Unrestrict the port state on this interface";
          }
          enum master-only {
            tailf:info "Restrict the port state to master";
          }
          enum slave-only {
            tailf:info "Restrict the port state to slave";
          }
        }
      }
    }

    // ptp / profile * / sync frequency
    container sync {
      tailf:info "Configure how often Sync messages are sent";
      leaf frequency {
        tailf:info "Send Sync messages one or more times a second";
        type enumeration {
          enum 1 {
            tailf:info "One per second frequency";
          }
          enum 2 {
            tailf:info "Two per second frequency";
          }
          enum 4 {
            tailf:info "Four per second frequency";
          }
          enum 8 {
            tailf:info "Eight per second frequency";
          }
          enum 16 {
            tailf:info "Sixteen per second frequency";
          }
          enum 32 {
            tailf:info "Thirty Two per second frequency";
          }
          enum 64 {
            tailf:info "Sixty Four second frequency";
          }
          enum 128 {
            tailf:info "One Hundred and Twenty Eight second frequency";
          }
        }
      }
    }

    // ptp / profile * / clock operation
    container clock {
      tailf:info "PTP clock-operation to use";
      leaf operation {
        tailf:info "PTP clock-operation to use";
        type enumeration {
          enum one-step {
            tailf:info "One-step clock-operation";
          }
          enum two-step {
            tailf:info "Two-step clock-operation";
          }
        }
      }
    }

    // ptp / profile * / announce
    container announce {
      tailf:info "Announce message options";

      // ptp / profile * / announce timeout
      leaf timeout {
        tailf:info "Configure the announce timeout value";
        type uint8 {
          tailf:info "<2-10>;;The number of announce intervals before timeout";
          range "2..10";
        }
      }

      // ptp / profile * / announce frequency
      leaf frequency {
        tailf:info "Send Announce messages one or more times a second";
        type enumeration {
          enum 1 {
            tailf:info "One per second frequency";
          }
          enum 2 {
            tailf:info "Two per second frequency";
          }
          enum 4 {
            tailf:info "Four per second frequency";
          }
          enum 8 {
            tailf:info "Eight per second frequency";
          }
          enum 16 {
            tailf:info "Sixteen per second frequency";
          }
          enum 32 {
            tailf:info "Thirty Two per second frequency";
          }
          enum 64 {
            tailf:info "Sixty Four second frequency";
          }
        }
      }
      // ptp / profile * / announce grant-duration
      leaf grant-duration {
        tailf:info "Configure the announce unicast grant duration value";
        type uint16 {
          tailf:info "<60-1000>;;The grant duration, in seconds";
        }
      }
      // ptp / profile * / announce interval
      leaf interval {
        tailf:info "Send Announce messages once every one or more seconds";
        type enumeration {
          enum 1 {
            tailf:info "One second interval";
          }
          enum 2 {
            tailf:info "Two second interval";
          }
          enum 4 {
            tailf:info "Four second interval";
          }
          enum 8 {
            tailf:info "Eight second interval";
          }
          enum 16 {
            tailf:info "Sixteen second interval";
          }
        }
      }
    }

    // ptp / profile * / delay-request
    container delay-request {
      tailf:info "Configure the sending of delay-request messages";

      // ptp / profile * / delay-request frequency
      leaf frequency {
        tailf:info "Set the interval to one or more times a second";
        type enumeration {
          enum 1 {
            tailf:info "One per second frequency";
          }
          enum 2 {
            tailf:info "Two per second frequency";
          }
          enum 4 {
            tailf:info "Four per second frequency";
          }
          enum 8 {
            tailf:info "Eight per second frequency";
          }
          enum 16 {
            tailf:info "Sixteen per second frequency";
          }
          enum 32 {
            tailf:info "Thirty Two per second frequency";
          }
          enum 64 {
            tailf:info "Sixty Four second frequency";
          }
          enum 128 {
            tailf:info "One Hundred and Twenty Eight second frequency";
          }
        }
      }
    }
  }

  // service ipv4 tcp-small-servers
  // service ipv4 udp-small-servers
  // service ipv6 tcp-small-servers
  // service ipv6 udp-small-servers
  grouping max-servers-grouping {
    leaf max-servers {
      tailf:info "Set number of allowable TCP small servers";
      type union {
        type uint32 {
          tailf:info "<1-2147483647>;;Maximum TCP small servers";
          range "1..2147483647";
        }
        type enumeration {
          enum "no-limit" {
            tailf:info "No limit to number of allowable TCP small servers";
          }
        }
      }
    }
    leaf access-list {
      tailf:cli-drop-node-name;
      type string {
        tailf:info "WORD;;Access list";
      }
    }
  }

  grouping tcp-small-servers-grouping {
    container tcp-small-servers {
      tailf:info "Enable small TCP servers (e.g., ECHO)";
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-compact-syntax;
      uses max-servers-grouping;
    }
  }

  grouping udp-small-servers-grouping {
    container udp-small-servers {
      tailf:info "Enable small UDP servers (e.g., ECHO)";
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-compact-syntax;
      uses max-servers-grouping;
    }
  }

  grouping pce-disjoint-path-group-id-grouping {
    // pce / disjoint-path / group-id * / strict
    leaf strict {
      tailf:info "Disable Fallback";
      type empty;
    }

    // pce / disjoint-path / group-id * / lsp * pcc ipv4
    list lsp {
      tailf:info "Configure lsps in the association";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-incomplete-command;
      key id;
      leaf id {
        type enumeration {
          enum "1" {
            tailf:info "Configure first lsp in the association";
          }
          enum "2" {
            tailf:info "Configure second lsp in the association";
          }
        }
      }
      container pcc {
        tailf:info "PCC address";
        tailf:cli-flatten-container;
        leaf ipv4 {
          tailf:info "IPV4";
          tailf:cli-incomplete-command;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IPv4 address of PCC";
          }
        }
      }
      leaf lsp-name {
        tailf:info "Name of MPLS label switched path";
        type string {
          tailf:info "WORD;;Identifying name for LSP";
        }
      }
      leaf shortest-path {
        tailf:info "Set LSP to follow shortest-path";
        type empty;
      }
    }
  }


  // =========================================================================
  //                        MODEL
  // =========================================================================


  /// ========================================================================
  /// admin
  /// ========================================================================
  // NOTE: admin config (admin show running-config)
  //       to enter: 'admin' in exec mode, then configure

  container admin {
    tailf:info "Enter administrator/owner plane config";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-admin";
    tailf:cli-full-command;
    tailf:cli-exit-command "exit-admin-config";

    // admin / username *
    uses username-grouping;

    // admin / fpd auto-upgrade
    container fpd {
      tailf:info "FPD firmware configuration";
      container auto-upgrade {
        tailf:info "FPD auto-upgrade configuration";
        tailf:cli-delete-when-empty;
        tailf:cli-reset-container;
        presence true;

        // admin / fpd auto-upgrade disable
        // admin / fpd auto-upgrade enable
        leaf status {
          tailf:cli-drop-node-name;
          type enumeration {
            enum disable {
              tailf:info "Disable fpd auto upgrade`";
              tailf:code-name "admin_fpd_disable";
            }
            enum enable {
              tailf:info "Enable fpd auto upgrade`";
              tailf:code-name "admin_fpd_enable";
            }
          }
        }
      }
    }

    // admin / logging console
    container logging {
      tailf:info "logging group";
      leaf console {
        tailf:info "Modify message logging facilities";
        type enumeration {
          enum disable {
            tailf:info "Disable logging";
            value -1;
          }
          enum emergency {
             tailf:info "System is unusable (severity=0)";
             value 0;
          }
          enum alert {
            tailf:info "Immediate action needed (severity=1)";
            value 1;
          }
          enum critical {
            tailf:info "Critical conditions (severity=2)";
            value 2;
          }
          enum error {
            tailf:info "Error conditions (severity=3)";
            value 3;
          }
          enum warning {
            tailf:info "Warning conditions (severity=4) [default]";
            value 4;
          }
          enum notice {
            tailf:info "Normal but significant conditions (severity=5)";
            value 5;
          }
          enum informational {
            tailf:info "Informational messages (severity=6)";
            value 6;
          }
          enum debug {
            tailf:info "Debugging messages (severity=7)";
            value 7;
          }
        }
      }
    }

    // admin / fault-manager
    container fault-manager {
      tailf:info "Global Fault Manager configuration subcommands";
      container datapath {
        tailf:info "Data path faults";
        container port {
          tailf:info "Port status";

          // admin / fault-manager datapath port shutdown
          leaf shutdown {
            tailf:info "Enable auto shutdown";
            type empty;
          }
        }
      }
    }

    // admin / fabric enable mode
    container fabric {
      tailf:info "Configure Fabric";
      container enable {
        tailf:info "Enable fabric operation mode";
        leaf mode {
          tailf:info "Choose mode";
          type enumeration {
            enum A99-highbandwidth {
              tailf:info "A99 High bandwidth cards only";
            }
            enum highbandwidth {
              tailf:info "High bandwidth cards only";
            }
          }
        }
      }
    }

    // admin / power
    container power {
      tailf:info "Power management configuration";
      container budget {
        tailf:info "Power budget configuration";
        container reservation {
          tailf:info "Power budget reservations";
          container standby-rsp {
            tailf:info "Power budget reservation for the standby RSP";
            leaf disable {
              tailf:info "Disable power budget reservation for the standby RSP";
              type empty;
            }
          }
        }
      }
    }

    // admin / environment altitude ? rack *
    container environment {
      tailf:info "Global environment configuration subcommands";
      list altitude {
        tailf:info "altitude of the chassis in meters";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key rack;
        leaf rack {
          tailf:info "Show list of racks";
          tailf:cli-expose-key-name;
          type uint8 {
            tailf:info "<0-1>;;Specify a rack";
          }
        }
        leaf value {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type uint16 {
            tailf:info "<0-4000>;;meters";
            range "0..4000";
          }
        }
      }
    }

    // admin / hw-module
    container hw-module {
      tailf:info "Configure h/w module";

      // admin / hw-module profile
      container profile {
        tailf:info "Configure memory resource profile";

        // admin / hw-module feature
        container feature {
          tailf:info "Configure feature profile";
          choice feature-choice {
            leaf default {
              tailf:info "Default feature profile";
              type empty;
            }
            leaf l2 {
              tailf:info "L2 feature profile";
              type empty;
            }
          }
        }

        // admin / hw-module scale
        leaf scale {
          tailf:info "Configure scale profile";
          tailf:cli-full-command;
          type enumeration {
            enum bng-max {
              tailf:info "BNG max scale profile";
            }
            enum "default" {
              tailf:info "Default scale profile";
            }
            enum l2 {
              tailf:info "L2 scale profile";
            }
            enum l3 {
              tailf:info "L3 scale profile (depricated)";
            }
            enum l3xl {
              tailf:info "L3 XL scale profile";
            }
            enum lsr {
              tailf:info "LSR scale profile";
            }
            enum sat {
              tailf:info "nV Satellite scale profile";
            }
          }
        }
      }

      // admin / hw-module power
      container power {
        tailf:info "power state (for non-RP node only)";

        // admin / hw-module power disable location *
        container disable {
          tailf:info "Disable this feature";
          list location {
            tailf:info "Node number";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;Fully qualified location specification";
              }
            }
          }
        }

        // admin / hw-module power saving location * slice
        container saving {
          tailf:info "LC slice power saving mode";
          list location {
            tailf:info "Node number";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key id;
            leaf id {
              type string {
                tailf:info "WORD;;Fully qualified location specification";
              }
            }
            leaf slice {
              tailf:info "slice power configuration";
              type uint8 {
                tailf:info "<1-5>;;slice number";
                range "1..5";
              }
            }
          }
        }
      }

      // admin / hw-module bfd-hw-offload enable location
      container bfd-hw-offload {
        tailf:info "Configure BFD hw offload parameters";
        container enable {
          tailf:info "Enable BFD hw offload mode";
          leaf location {
            tailf:info "Configure line card location";
            type string {
              tailf:info "WORD;;Fully qualified line card specification";
            }
          }
        }
      }

      // admin / hw-module location *
      container location  {
        tailf:info "Fully qualified location specification";
        uses hw-module-location-list-grouping;
      }

      // admin / hw-module shutdown location *
      container shutdown {
        tailf:info "shutdown state (not applied to RSP cards)";
        list location {
          tailf:info "Node number";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key id;
          leaf id {
            type string {
              tailf:info "WORD;;Fully qualified location specification";
            }
          }
        }
      }

      // admin / hw-module reset auto
      container reset {
        tailf:info "monitor state";
        container auto {
          tailf:info "auto monitor";

          // admin / hw-module reset auto disable location *
          container disable {
            tailf:info "Disable this feature";
            list location {
              tailf:info "Node number";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key name;
              leaf name {
                type string {
                  tailf:info "WORD;;Fully qualified location specification";
                }
              }
            }
          }
        }
      }
    }

    // admin / license
    container license {
      tailf:info "license";

      // admin / license smart enable
      container smart {
        tailf:info "Smart Licensing";
        leaf enable {
          tailf:info "Enable Smart Licensing";
          type empty;
        }
      }

      // admin / license *
      list feature {
        tailf:cli-drop-node-name;
        tailf:cli-mode-name "admin-config-feat";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Feature/Package name";
          }
        }

        // admin / license * / location *
        list location {
          tailf:info "specify a location";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            tailf:cli-disallow-value "smart";
            type string {
              tailf:info "WORD;;Fully qualified location specification";
            }
          }
        }
      }
    }

    // admin / nv / edge
    container nv {
      tailf:info "Network Virtualization Configurations";
      tailf:cli-add-mode;
      tailf:cli-mode-name "admin-config-nV";
      container edge {
        tailf:info "Edge Network Virtualization Configurations";
        tailf:cli-add-mode;
        tailf:cli-mode-name "admin-config-nV-Edge";

        // admin / nv / edge / control
        container control {
          tailf:info "Edge nV Control Plane Configurations";
          tailf:cli-add-mode;
          tailf:cli-mode-name "admin-config-nV-Edge-Control";

          // admin / nv / edge / control / serial *
          list serial {
            tailf:info "serial ID to configure rack number to";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            key rack;
            unique id;
            leaf id {
              tailf:cli-drop-node-name;
              tailf:cli-prefix-key;
              type string {
                tailf:info "WORD;;(upto) 16 character serial id";
                length "1..16";
              }
            }
            leaf rack {
              tailf:info "rack number for the above serial ID";
              tailf:cli-expose-key-name;
              type uint8 {
                tailf:info "<0-1>;;enter rack number";
                range "0..1";
              }
            }
          }

          // admin / nv / edge / control / control-link
          container control-link {
            tailf:info "Parameters affecting front panel port behaviour";

            // admin / nv / edge / control / control-link disable *
            list disable {
              tailf:info "Disable front panel control link port";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key "port location";
              leaf port {
                type uint8 {
                  tailf:info "<0-1>;;Front panel port 0 or 1";
                  range "0..1";
                }
              }
              leaf location {
                tailf:info "Location of the node";
                tailf:cli-expose-key-name;
                type string {
                  tailf:info "WORD;;Fully qualified location specification";
                }
              }
            }
          }
        }
      }
    }

    // admin / clock
    uses clock-grouping;

    // admin / exception
    uses exception-grouping;

    // admin / diagnostic
    container diagnostic {
      tailf:info "Configure diagnostic information";

      // admin / diagnostic bootup
      container bootup {
        tailf:info "Configure diagnostic for bootup";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf level {
          tailf:info "Select diagnostic level";
          tailf:cli-incomplete-command;
          type enumeration {
            enum complete {
              tailf:info "Complete level";
            }
            enum minimal {
              tailf:info "Minimal level";
            }
            enum bypass {
              tailf:info "Bypass diagnostic";
            }
          }
        }
        leaf location {
          tailf:info "Select location";
          type string {
            tailf:info "WORD;;Enter Location";
          }
        }
      }

      // admin / diagnostic monitor
      container monitor {
        tailf:info "Configure diagnostic monitoring tests";

        // admin / diagnostic monitor syslog
        leaf syslog {
          tailf:info "Configure diagnostic monitoring syslog";
          type empty;
        }

        // admin / diagnostic monitor threshold location * / test * / failure-count
        container threshold {
          tailf:info "Configure diagnostic monitoring failure threshold";
          list location {
            tailf:info "Select location";
            key location;
            leaf location {
              type string {
                tailf:info "Select location";
              }
            }
            list test {
              tailf:info "Select a test name";
              key name;
              leaf name {
                type string {
                  tailf:info "WORD;;Name of the test";
                }
              }
              leaf failure-count {
                tailf:info "Setting failure threshold count";
                type uint8 {
                  tailf:info "<1 to 99>;;Enter the Threshold";
                }
              }
            }
          }
        }
      }

      // admin / diagnostic test-parameters
      container test-parameters {
        tailf:info "Configure diagnostic test specific parameters";
        tailf:cli-add-mode;
        container FabricUcastMcastTest {
          tailf:info "FabricUcastMcastTest";
          tailf:cli-add-mode;
          grouping node-failure-config-grouping {
            container reload {
              tailf:info "Node reload on specified consecutive failures";
              leaf threshold {
                tailf:info "Consecutive failures threshold";
                type uint8 {
                  tailf:info "<2-255>;;Number of consecutive failures";
                }
              }
            }
            container shutdown {
              tailf:info "Node shutdown on specified consecutive failures";
              leaf threshold {
                tailf:info "Consecutive failures threshold";
                type uint8 {
                  tailf:info "<2-255>;;Number of consecutive failures";
                }
              }
            }
          }
          container single-DRP-node-failure  {
            tailf:info "Single DRP node failure";
            tailf:cli-add-mode;
            uses node-failure-config-grouping;
          }
          container single-LC-node-failure {
            tailf:info "Single LC node failure";
            tailf:cli-add-mode;
            uses node-failure-config-grouping;
          }
          container single-RP-node-failure {
            tailf:info "Single RP node failure";
            tailf:cli-add-mode;
            uses node-failure-config-grouping;
          }
        }
      }

      // admin / diagnostic schedule location *
      container schedule {
        tailf:info "Configure diagnostic schedule for a card";
        list location {
          tailf:info "Select location";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-incomplete-command;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Enter Location";
            }
          }
          leaf test {
            tailf:info "Diagnostic test selection";
            cisco-ios-xr:string-remove-quotes "test <STRING>";
            type string {
              tailf:info "WORD;;Name of the test|test ID|all|..";
            }
          }
          leaf daily {
            tailf:info "Daily schedule";
            type string {
              tailf:info "<0-23>:;;Begin time(hour:)";
            }
          }
          leaf card-type {
            type string;
          }
        }
      }
    }

    // admin / disk_status_config
    container disk_status_config {
      leaf minor {
        type uint8 {
          tailf:info "<0-100>;;Minor value";
          range "0..100";
        }
      }
      leaf severe {
        type uint8 {
          tailf:info "<0-100>;;Severe value";
          range "0..100";
        }
      }
      leaf critical {
        type uint8 {
          tailf:info "<0-100>;;Critical value";
          range "0..100";
        }
      }
    }

    // admin / memory_status_config
    container memory_status_config {
      leaf minor {
        type uint8 {
          tailf:info "<0-100>;;Minor value";
          range "0..100";
        }
      }
      leaf severe {
        type uint8 {
          tailf:info "<0-100>;;Severe value";
          range "0..100";
        }
      }
      leaf critical {
        type uint8 {
          tailf:info "<0-100>;;Critical value";
          range "0..100";
        }
      }
      leaf recovery_enabled {
        type enumeration {
          enum false;
          enum true;
        }
      }
    }

    // admin / aaa
    container aaa {
      tailf:info "AAA information";

      // admin / aaa admin-accounting enable
      container admin-accounting {
        tailf:info "Enable/Disable Admin Accounting via XR";
        leaf enable {
          tailf:info "Enable Admin Accounting via XR";
          type boolean;
        }
      }

      // admin / aaa authentication
      container authentication {
        tailf:info "Authentication information";

        // admin / aaa authentication users user *
        container users {
          tailf:info "Users information";
          list user {
            tailf:info "User information";
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;User name";
              }
            }

            // admin / aaa authentication users user * / uid
            leaf uid {
              tailf:info "User id";
              type uint32 {
                tailf:info "<unsignedInt>;;User id";
              }
            }

            // admin / aaa authentication users user * / gid
            leaf gid {
              tailf:info "Group id";
              type int32 {
                tailf:info "<unsignedInt>;;Group id";
              }
            }

            // admin / aaa authentication users user * / password
            leaf password {
              tailf:info "User password";
              cli:secret;
              type NEDCOM_SECRET_TYPE {
                tailf:info "WORD;;MD5 Digest or plain text password";
              }
            }

            // admin / aaa authentication users user * / ssh_keydir
            leaf ssh_keydir {
              tailf:info "SSH directory";
              type string {
                tailf:info "WORD;;SSH directory";
              }
            }

            // admin / aaa authentication users user * / homedir
            leaf homedir {
              tailf:info "Home directory";
              type string {
                tailf:info "WORD;;Home directory";
              }
            }
          }
        }

        // admin / aaa authentication groups group *
        container groups {
          tailf:info "Groups information";
          list group {
            tailf:info "Group information";
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;Group name";
              }
            }

            // admin / aaa authentication groups group * / gid
            leaf gid {
              tailf:info "Group id";
              type int32 {
                tailf:info "<unsignedInt>;;Group id";
              }
            }

            // admin / aaa authentication groups group * / users *
            leaf-list users {
              tailf:info "Users leaf-list (quoting/dequoting handled by the NED)";
              tailf:cli-flat-list-syntax;
              cisco-ios-xr:string-add-quotes "  users <STRING>";
              type string {
                tailf:info "WORD;;User name";
              }
            }
          }
        }

        // admin / aaa authentication login *
        list login {
          tailf:info "Set authentication lists for logins";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-remove-before-change;
          tailf:cli-incomplete-command;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Named authentication list (max 31 characters)";
              length "1..31";
            }
          }
          leaf methods {
            tailf:cli-drop-node-name;
            tailf:cli-multi-value;
            tailf:cli-no-value-on-delete;
            type string {
              tailf:info "WORD;;ordered list of methods: none|local|group ldap|group radius|group tacacs|group <srv>";
            }
          }
        }
      }

      // admin / aaa authorization
      container authorization {
        tailf:info "Authorization information";

        // admin / aaa authorization cmdrules cmdrule *
        list cmdrules {
          tailf:info "Command rules information";
          key cmdrule;
          leaf cmdrule {
            tailf:info "Command rule information";
            tailf:cli-expose-key-name;
            type uint32 {
              tailf:info "NUM;;Index number";
            }
          }

          // admin / aaa authorization cmdrules cmdrule * / context
          leaf context {
            tailf:info "Configuration context";
            type string {
              tailf:info "WORD;;Context";
            }
          }

          // admin / aaa authorization cmdrules cmdrule * / command
          leaf command {
            tailf:info "Command";
            type string {
              tailf:info "WORD;;Command";
            }
          }

          // admin / aaa authorization cmdrules cmdrule * / group
          leaf group {
            tailf:info "Group name";
            type string {
              tailf:info "WORD;;Group name";
            }
          }

          // admin / aaa authorization cmdrules cmdrule * / ops
          leaf ops {
            tailf:info "Type of operation";
            type string {
              tailf:info "WORD;;Type of operation";
            }
          }

          // admin / aaa authorization cmdrules cmdrule * / action
          leaf action {
            tailf:info "Type of action";
            type enumeration {
              enum reject;
              enum accept;
              enum accept_log;
            }
          }
        }

        // admin / aaa authorization datarules datarule *
        list datarules {
          tailf:info "Data rules information";
          key datarule;
          leaf datarule {
            tailf:info "Data rule information";
            tailf:cli-expose-key-name;
            type uint32 {
              tailf:info "NUM;;Index number";
            }
          }

          // admin / aaa authorization datarules datarule * / namespace
          leaf namespace {
            tailf:info "Namespace";
            type string {
              tailf:info "WORD;;Namespace";
            }
          }

          // admin / aaa authorization datarules datarule * / context
          leaf context {
            tailf:info "Configuration context";
            type string {
              tailf:info "WORD;;Context";
            }
          }

          // admin / aaa authorization datarules datarule * / keypath
          leaf keypath {
            tailf:info "Keypath of item";
            type string {
              tailf:info "WORD;;Keypath";
            }
          }

          // admin / aaa authorization datarules datarule * / group
          leaf group {
            tailf:info "Group name";
            type string {
              tailf:info "WORD;;Group name";
            }
          }

          // admin / aaa authorization datarules datarule * / ops
          leaf ops {
            tailf:info "Type of operation";
            type string {
              tailf:info "WORD;;Type of operation";
            }
          }

          // admin / aaa authorization datarules datarule * / action
          leaf action {
            tailf:info "Type of action";
            type enumeration {
              enum reject;
              enum accept;
              enum accept_log;
            }
          }
        }
      }

      // admin / aaa disaster-recovery
      container disaster-recovery {
        tailf:info "Disaster Recovery user information";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf username {
          tailf:info "The username with which you can login to system in case of normal authentication failure case.";
          tailf:cli-incomplete-command;
          type string {
            tailf:info "WORD;;username";
          }
        }
        leaf password {
          tailf:info "The password with which you can login to system in case of normal authentication failure case.";
          cli:secret;
          type NEDCOM_SECRET_TYPE {
            tailf:info "WORD;;MD5 digest string";
          }
        }
      }
    }

    // admin / confdConfig cli
    container confdConfig {
      tailf:info "ConfD configuration.";
      container cli {
        tailf:info "CLI parameters.";

        // admin / confdConfig cli maxLineLength
        leaf maxLineLength {
          tailf:info "When set to a number larger than zero, this number will be the maximum line length which can be entered into the CLI.";
          type uint32;
        }

        // admin / confdConfig cli timezone
        leaf timezone {
          tailf:info "Time in the CLI can be either local, as configured on the device, or UTC.";
          type string {
            tailf:info "WORD;;Timezone (local, utc etc)";
          }
        }

        // admin / confdConfig cli utcOffset
        leaf utcOffset {
          tailf:info "If the timezone is set to UTC this can be set to specify the UTC offset measured in minutes.";
          type int32;
        }

        // admin / confdConfig cli idleTimeout
        leaf idleTimeout {
          tailf:info "Maximum idle time before terminating a CLI session.";
          type string {
            tailf:info "WORD;;duration (nYnMnDnHnMnS)";
          }
        }

        // admin / confdConfig cli timestamp
        container timestamp {
          tailf:info "Default value for the timstamps in the CLI.";
          choice enabled-choice {
            leaf enabled {
              type empty;
            }
            leaf disabled {
              type empty;
            }
          }

          // admin / confdConfig cli timestamp clock24
          leaf clock24 {
            type boolean;
          }

          // admin / confdConfig cli timestamp format
          leaf format {
            tailf:info "Specifies the format of the timestamp.";
            type string {
              tailf:info "WORD;;timestamp format";
            }
          }
        }

        // admin / confdConfig cli suppressCommitMessages
        container suppressCommitMessages {
          presence true;
        }

        // admin / confdConfig cli historySave
        leaf historySave {
          tailf:info "If set to 'true' then the CLI history will be saved between CLI sessions.";
          type boolean;
        }

        // admin / confdConfig cli allOrNothingLoad
        leaf allOrNothingLoad {
          tailf:info "allOrNothingLoad is either true or false.";
          type boolean;
        }

        // admin / confdConfig cli enableLoadMergeLeafList
        leaf enableLoadMergeLeafList {
          tailf:info "enableLoadMergeLeafList is either 'true' or 'false'.";
          type boolean;
        }
      }
    }

    // admin / console attach-sdr location *
    container console {
      container attach-sdr {
        list location {
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Node Location";
              pattern '[0-9a-zA-Z]+/[0-9a-zA-Z]+';
            }
          }

          // admin / console attach-sdr location * / tty-name *
          list tty-name {
            tailf:info "TTY name";
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;Enter TTY name";
              }
            }

            // admin / console attach-sdr location * / tty-name * / sdr-name
            leaf sdr-name {
              tailf:info "Enter SDR name";
              type string {
                tailf:info "WORD;;SDR name string";
              }
            }
          }
        }
      }
    }

    // admin / connect sdr * * csi-id *
    container connect {
      tailf:info "Secure Domain Router connect config command";
      list sdr {
        tailf:info "Secure Domain Router connect config commands";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "name remote-name csi-id";
        leaf name {
          type string {
            tailf:info "WORD;;sdr name (1 to 30 characters(0-9,a-z,A-Z,-,_))";
          }
        }
        leaf remote-name {
          type string {
            tailf:info "WORD;;remote sdr name (1 to 30 characters(0-9,a-z,A-Z,-,_))";
          }
        }
        leaf csi-id {
          tailf:info "Index unique for each SDR connection pair";
          tailf:cli-expose-key-name;
          type uint8 {
            tailf:info "<csi-id:unsignedInt, 1 .. 15>";
            range "1..15";
          }
        }
      }
    }

    // admin / sdr *
    list sdr {
      tailf:info "Secure Domain Router config/exec commands";
      tailf:cli-explicit-exit;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;sdr name (1 to 30 characters(0-9,a-z,A-Z,-,_))";
        }
      }

      // admin / sdr * / initial-image *
      leaf-list initial-image {
        tailf:info "Initial Image for a Secure Domain Router";
        tailf:cli-flat-list-syntax;
        type string;
      }

      // admin / sdr * / pairing-mode
      leaf pairing-mode {
        tailf:info "Specify pairing mode intra-rack/inter-rack";
        type enumeration {
          enum inter-rack;
          enum intra-rack;
        }
      }

      // admin / sdr * / resources
      container resources {
        tailf:info "Resources for a Secure Domain Router";

        // admin / sdr * / resources mgmt_ext_vlan
        leaf mgmt_ext_vlan {
          tailf:info "Management External VLAN for Secure Domain Router";
          type uint16 {
            tailf:info "<unsignedInt, 2 .. 4094>";
            range "0..4094";
          }
        }

        // admin / sdr * / resources card-type *
        list card-type {
          tailf:info "Specify card-type";
          key name;
          leaf name {
            tailf:info "Specify card-type";
            type enumeration {
              enum CC;
              enum LC;
              enum RP;
            }
          }

          // admin / sdr * / resources card-type * / vm-cpu
          leaf vm-cpu {
            tailf:info "VM Number of CPUs";
            type uint8 {
              tailf:info "<unsignedInt, 1 .. 128>";
              range "1..128";
            }
          }

          // admin / sdr * / resources card-type * / vm-memory
          leaf vm-memory {
            tailf:info "VM Memory Size in units of [GB]";
            type uint8 {
              tailf:info "<unsignedInt, 1 .. 128>";
              range "1..128";
            }
          }
        }
      }

      // admin / sdr * / location *
      list location {
        tailf:info "Enter list of nodes locations for the SDR";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Node Location";
            pattern 'all|([0-9a-zA-Z]+/[0-9a-zA-Z]+)';
          }
        }
      }
    }

    // admin / service cli interactive
    container service {
      tailf:info "Modify use of network based services";
      container cli {
        tailf:info "CLI configuration services";
        leaf interactive {
          tailf:info "Change interactive behavior of commands";
          type enumeration {
            enum disabled;
            enum enabled;
          }
        }
      }
    }

    // admin / vm
    container vm {
      tailf:info "vm information";

      // admin / vm memory
      container memory {
        tailf:info "xrv9k vm memory allocation";
        leaf admin {
          tailf:info "xrv9k admin vm memory allocation";
          type uint32;
        }
        leaf rp {
          tailf:info "xrv9k rp vm memory allocation";
          type uint32;
        }
        leaf lc {
          tailf:info "xrv9k lc vm memory allocation";
          type uint32;
        }
      }

      // admin / vm cpu assign
      container cpu {
        tailf:info "xrv9k cpu pinning allocation";
        leaf assign {
          tailf:info "assign cpu cores to control/data plane in <cp-cpu-list>/<dp-cpu-list> format";
          type string {
            tailf:info "<cp-cpu-list>/<dp-cpu-list>;;assign cpu cores to control/data plane[]";
          }
        }
      }
    }

    // admin / chassis serial *
    container chassis {
      tailf:info "Configure Chassis Serial Number";
      list serial {
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Chassis Serial Number String";
          }
        }

        // admin / chassis serial * / rack
        leaf rack {
          tailf:info "Chassis Rack Number";
          type string {
            tailf:info "WORD;;LINE of FABRIC rack";
          }
        }
      }
    }

    // admin / interface MgmtEth*
    container interface {
      tailf:info "Configure Interface";
      tailf:cli-explicit-exit;
      list MgmtEth {
        tailf:info "Configure Management Ethernet Interface";
        tailf:cli-allow-join-with-key;
        key id;
        leaf id {
          tailf:info "Location/InterfaceNum/Port";
          type string {
            tailf:info "Location/InterfaceNum/Port";
          }
        }

        // admin / interface MgmtEth* / ipv4 address
        container ipv4 {
          tailf:info "IPv4 parameters";
          container address {
            tailf:info "IPv4 address and netmask: A.B.C.D/E or A.B.C.D E.F.G.H";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf ip {
              tailf:cli-drop-node-name;
              tailf:cli-remove-before-change;
              tailf:cli-incomplete-command;
              tailf:cli-incomplete-no;
              type string {
                tailf:info "A.B.C.D;;IP address";
                pattern '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}'
                  +'([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])';
              }
            }
            leaf mask {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "A.B.C.D or /X;;IP subnet mask or /prefix";
                pattern '((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}'
                          +'([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]))|(/[0-9]+)';
              }
            }
          }
        }

        // admin / interface MgmtEth* / default-gw
        leaf default-gw {
          tailf:info "Default Gateway address: A.B.C.D";
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Default Gateway address";
          }
        }
      }
    }

    // admin / alias *
    container alias {
      tailf:info "Create an alias for entity";

      // alias *
      list alias-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          tailf:cli-disallow-value "exec|config";
          type string {
            tailf:info "WORD;;Alias name";
          }
        }
        leaf line {
          tailf:cli-drop-node-name;
          tailf:cli-multi-value;
          tailf:cli-preformatted;
          tailf:cli-no-value-on-delete;
          tailf:cli-full-command;
          type string {
            tailf:info "LINE;;Alias body with optional parameters e.g,(name) show $name";
          }
        }
      }
    }

    // admin / SNMP-COMMUNITY-MIB snmpCommunityTable snmpCommunityEntry *
    container SNMP-COMMUNITY-MIB {
      container snmpCommunityTable {
        list snmpCommunityEntry {
          key "snmpCommunityIndex";
          tailf:sort-order "snmp-implied";
          tailf:snmp-oid "1.3.6.1.6.3.18.1.1";
          leaf snmpCommunityIndex {
            type snmpCommunityIndexType;
            tailf:snmp-oid "1.3.6.1.6.3.18.1.1.1.1";
          }
          leaf snmpCommunityName {
            type snmpCommunityNameType;
            mandatory true;
            tailf:snmp-oid "1.3.6.1.6.3.18.1.1.1.2";
          }
          leaf snmpCommunitySecurityName {
            type snmpCommunitySecurityNameType;
            mandatory true;
            tailf:snmp-oid "1.3.6.1.6.3.18.1.1.1.3";
          }
          leaf snmpCommunityContextEngineID {
            type SNMP_FRAMEWORK_MIB_SnmpEngineID;
            mandatory true;
            tailf:snmp-oid "1.3.6.1.6.3.18.1.1.1.4";
          }
          leaf snmpCommunityContextName {
            type snmpCommunityContextNameType;
            tailf:snmp-oid "1.3.6.1.6.3.18.1.1.1.5";
            default "";
          }
          leaf snmpCommunityTransportTag {
            type SNMP_TARGET_MIB_SnmpTagValue;
            tailf:snmp-oid "1.3.6.1.6.3.18.1.1.1.6";
            default "";
          }
          leaf snmpCommunityStorageType {
            type SNMPv2_TC_StorageType;
            tailf:snmp-oid "1.3.6.1.6.3.18.1.1.1.7";
            default "permanent";
          }
        }
      }
    }

    // admin / SNMP-NOTIFICATION-MIB snmpNotifyTable snmpNotifyEntry *
    container SNMP-NOTIFICATION-MIB {
      container snmpNotifyTable {
        list snmpNotifyEntry {
          key "snmpNotifyName";
          tailf:sort-order "snmp-implied";
          tailf:snmp-oid "1.3.6.1.6.3.13.1.1";
          leaf snmpNotifyName {
            type snmpNotifyNameType;
            tailf:snmp-oid "1.3.6.1.6.3.13.1.1.1.1";
          }
          leaf snmpNotifyTag {
            type SNMP_TARGET_MIB_SnmpTagValue;
            tailf:snmp-oid "1.3.6.1.6.3.13.1.1.1.2";
          }
          leaf snmpNotifyType {
            type snmpNotifyTypeType;
            tailf:snmp-oid "1.3.6.1.6.3.13.1.1.1.3";
            default "trap";
          }
          leaf snmpNotifyStorageType {
            type SNMPv2_TC_StorageType;
            tailf:snmp-oid "1.3.6.1.6.3.13.1.1.1.4";
            default "nonVolatile";
          }
        }
      }
    }

    // admin / SNMP-TARGET-MIB
    container SNMP-TARGET-MIB {
      container snmpTargetObjects {
        tailf:snmp-oid "1.3.6.1.6.3.12.1";
        config false;
        leaf snmpUnavailableContexts {
          type yang:counter32;
          tailf:snmp-oid "1.3.6.1.6.3.12.1.4";
          config false;
        }
        leaf snmpUnknownContexts {
          type yang:counter32;
          tailf:snmp-oid "1.3.6.1.6.3.12.1.5";
          config false;
        }
      }
      container snmpTargetAddrTable {
        list snmpTargetAddrEntry {
          key "snmpTargetAddrName";
          tailf:sort-order "snmp-implied";
          tailf:snmp-oid "1.3.6.1.6.3.12.1.2";
          tailf:snmp-name "snmpTargetAddrTable";
          tailf:snmp-name "SNMP-COMMUNITY-MIB:snmpTargetAddrExtTable";

          leaf snmpTargetAddrName {
            type snmpTargetAddrNameType;
            tailf:snmp-oid "1.3.6.1.6.3.12.1.2.1.1";
          }
          leaf snmpTargetAddrTDomain {
            type SNMPv2_TC_TDomain;
            mandatory true;
            tailf:snmp-oid "1.3.6.1.6.3.12.1.2.1.2";
          }
          leaf snmpTargetAddrTAddress {
            type UDPTAddress;
            mandatory true;
            tailf:snmp-oid "1.3.6.1.6.3.12.1.2.1.3";
          }
          leaf snmpTargetAddrTimeout {
            type SNMPv2_TC_TimeInterval;
            tailf:snmp-oid "1.3.6.1.6.3.12.1.2.1.4";
            default "1500";
          }
          leaf snmpTargetAddrRetryCount {
            type snmpTargetAddrRetryCountType;
            tailf:snmp-oid "1.3.6.1.6.3.12.1.2.1.5";
            default "3";
          }
          leaf snmpTargetAddrTagList {
            type SnmpTagList;
            tailf:snmp-oid "1.3.6.1.6.3.12.1.2.1.6";
            default "";
          }
          leaf snmpTargetAddrParams {
            type snmpTargetAddrParamsType;
            mandatory true;
            tailf:snmp-oid "1.3.6.1.6.3.12.1.2.1.7";
          }
          leaf snmpTargetAddrStorageType {
            type SNMPv2_TC_StorageType;
            tailf:snmp-oid "1.3.6.1.6.3.12.1.2.1.8";
            default "nonVolatile";
          }
          leaf snmpTargetAddrEngineID {
            type snmpTargetAddrEngineIDType;
            default "";
          }
          leaf snmpTargetAddrTMask {
            type UDPTMask;
            // tailf:snmp-oid "1.3.6.1.6.3.18.1.2.1.1";
            tailf:snmp-name "SNMP-COMMUNITY-MIB:snmpTargetAddrExtTable:snmpTargetAddrTMask";
            default "";
          }
          leaf snmpTargetAddrMMS {
            type snmpTargetAddrMMSType;
            // tailf:snmp-oid "1.3.6.1.6.3.18.1.2.1.2";
            tailf:snmp-name "SNMP-COMMUNITY-MIB:snmpTargetAddrExtTable:snmpTargetAddrMMS";
            default "2048";
          }
          leaf enabled {
            //NSO YANG: type boolean; default "true";
            type empty; // real device
          }
        }
      }
      container snmpTargetParamsTable {
        list snmpTargetParamsEntry {
          key "snmpTargetParamsName";
          tailf:sort-order "snmp-implied";
          tailf:snmp-oid "1.3.6.1.6.3.12.1.3";
          leaf snmpTargetParamsName {
            type snmpTargetParamsNameType;
            tailf:snmp-oid "1.3.6.1.6.3.12.1.3.1.1";
          }
          leaf snmpTargetParamsMPModel {
            type SNMP_FRAMEWORK_MIB_SnmpMessageProcessingModel;
            mandatory true;
            tailf:snmp-oid "1.3.6.1.6.3.12.1.3.1.2";
          }
          leaf snmpTargetParamsSecurityModel {
            type snmpTargetParamsSecurityModelType;
            mandatory true;
            tailf:snmp-oid "1.3.6.1.6.3.12.1.3.1.3";
          }
          leaf snmpTargetParamsSecurityName {
            type SNMP_FRAMEWORK_MIB_SnmpAdminString;
            mandatory true;
            tailf:snmp-oid "1.3.6.1.6.3.12.1.3.1.4";
          }
          leaf snmpTargetParamsSecurityLevel {
            type SNMP_FRAMEWORK_MIB_SnmpSecurityLevel;
            mandatory true;
            tailf:snmp-oid "1.3.6.1.6.3.12.1.3.1.5";
          }
          leaf snmpTargetParamsStorageType {
            type SNMPv2_TC_StorageType;
            tailf:snmp-oid "1.3.6.1.6.3.12.1.3.1.6";
            default "nonVolatile";
          }
        }
      }
    }

    // admin / SNMP-USER-BASED-SM-MIB
    container SNMP-USER-BASED-SM-MIB {
      container usmStats {
        tailf:snmp-oid "1.3.6.1.6.3.15.1.1";
        config false;
        leaf usmStatsUnsupportedSecLevels {
          type yang:counter32;
          tailf:snmp-oid "1.3.6.1.6.3.15.1.1.1";
          config false;
        }
        leaf usmStatsNotInTimeWindows {
          type yang:counter32;
          tailf:snmp-oid "1.3.6.1.6.3.15.1.1.2";
          config false;
        }
        leaf usmStatsUnknownUserNames {
          type yang:counter32;
          tailf:snmp-oid "1.3.6.1.6.3.15.1.1.3";
          config false;
        }
        leaf usmStatsUnknownEngineIDs {
          type yang:counter32;
          tailf:snmp-oid "1.3.6.1.6.3.15.1.1.4";
          config false;
        }
        leaf usmStatsWrongDigests {
          type yang:counter32;
          tailf:snmp-oid "1.3.6.1.6.3.15.1.1.5";
          config false;
        }
        leaf usmStatsDecryptionErrors {
          type yang:counter32;
          tailf:snmp-oid "1.3.6.1.6.3.15.1.1.6";
          config false;
        }
      }
      container usmUserTable {
        list usmUserEntry {
          key "usmUserEngineID usmUserName";
          unique "usmUserEngineID usmUserSecurityName";
          tailf:sort-order "snmp";
          tailf:snmp-oid "1.3.6.1.6.3.15.1.2.2";
          leaf usmUserEngineID {
            type SNMP_FRAMEWORK_MIB_SnmpEngineID;
            tailf:snmp-oid "1.3.6.1.6.3.15.1.2.2.1.1";
          }
          leaf usmUserName {
            type usmUserNameType;
            tailf:snmp-oid "1.3.6.1.6.3.15.1.2.2.1.2";
          }
          leaf usmUserSecurityName {
            type SNMP_FRAMEWORK_MIB_SnmpAdminString;
            mandatory true;
            tailf:snmp-oid "1.3.6.1.6.3.15.1.2.2.1.3";
          }
          leaf usmUserCloneFrom {
            type SNMPv2_TC_RowPointer;
            tailf:snmp-oid "1.3.6.1.6.3.15.1.2.2.1.4";
          }
          leaf usmUserAuthProtocol {
            type SNMPv2_TC_AutonomousType;
            tailf:snmp-oid "1.3.6.1.6.3.15.1.2.2.1.5";
            default "1.3.6.1.6.3.10.1.1.1";
          }
          leaf usmUserAuthKeyChange {
            type KeyChange;
            tailf:snmp-oid "1.3.6.1.6.3.15.1.2.2.1.6";
          }
          leaf usmUserOwnAuthKeyChange {
            type KeyChange;
            tailf:snmp-oid "1.3.6.1.6.3.15.1.2.2.1.7";
          }
          leaf usmUserPrivProtocol {
            type SNMPv2_TC_AutonomousType;
            tailf:snmp-oid "1.3.6.1.6.3.15.1.2.2.1.8";
            default "1.3.6.1.6.3.10.1.2.1";
          }
          leaf usmUserPrivKeyChange {
            type KeyChange;
            tailf:snmp-oid "1.3.6.1.6.3.15.1.2.2.1.9";
          }
          leaf usmUserOwnPrivKeyChange {
            type KeyChange;
            tailf:snmp-oid "1.3.6.1.6.3.15.1.2.2.1.10";
          }
          leaf usmUserPublic {
            type usmUserPublicType;
            tailf:snmp-oid "1.3.6.1.6.3.15.1.2.2.1.11";
          }
          leaf usmUserStorageType {
            type SNMPv2_TC_StorageType;
            tailf:snmp-oid "1.3.6.1.6.3.15.1.2.2.1.12";
            default "nonVolatile";
          }
          leaf usmUserAuthKey {
            type KeyChange;
          }
          leaf usmUserPrivKey {
            type KeyChange;
          }
        }
      }
    }

    // admin / SNMP-VIEW-BASED-ACM-MIB
    container SNMP-VIEW-BASED-ACM-MIB {
      container vacmSecurityToGroupTable {
        list vacmSecurityToGroupEntry {
          key "vacmSecurityModel vacmSecurityName";
          tailf:sort-order "snmp";
          tailf:snmp-oid "1.3.6.1.6.3.16.1.2";
          leaf vacmSecurityModel {
            type vacmSecurityModelType;
            tailf:snmp-oid "1.3.6.1.6.3.16.1.2.1.1";
          }
          leaf vacmSecurityName {
            type vacmSecurityNameType;
            tailf:snmp-oid "1.3.6.1.6.3.16.1.2.1.2";
          }
          leaf vacmGroupName {
            type vacmGroupNameType;
            mandatory true;
            tailf:snmp-oid "1.3.6.1.6.3.16.1.2.1.3";
          }
          leaf vacmSecurityToGroupStorageType {
            type SNMPv2_TC_StorageType;
            tailf:snmp-oid "1.3.6.1.6.3.16.1.2.1.4";
            default "nonVolatile";
          }
        }
      }
      container vacmAccessTable {
        list vacmAccessEntry {
          key "vacmGroupName vacmAccessContextPrefix vacmAccessSecurityModel vacmAccessSecurityLevel";
          tailf:sort-order "snmp";
          tailf:snmp-oid "1.3.6.1.6.3.16.1.4";
          leaf vacmGroupName {
            type vacmGroupNameType;
            tailf:snmp-oid "1.3.6.1.6.3.16.1.2.1.3";
          }
          leaf vacmAccessContextPrefix {
            type vacmAccessContextPrefixType;
            tailf:snmp-oid "1.3.6.1.6.3.16.1.4.1.1";
          }
          leaf vacmAccessSecurityModel {
            type SNMP_FRAMEWORK_MIB_SnmpSecurityModel;
            tailf:snmp-oid "1.3.6.1.6.3.16.1.4.1.2";
          }
          leaf vacmAccessSecurityLevel {
            type SNMP_FRAMEWORK_MIB_SnmpSecurityLevel;
            tailf:snmp-oid "1.3.6.1.6.3.16.1.4.1.3";
          }
          leaf vacmAccessContextMatch {
            type vacmAccessContextMatchType;
            tailf:snmp-oid "1.3.6.1.6.3.16.1.4.1.4";
            default "exact";
          }
          leaf vacmAccessReadViewName {
            type vacmAccessReadViewNameType;
            tailf:snmp-oid "1.3.6.1.6.3.16.1.4.1.5";
          }
          leaf vacmAccessWriteViewName {
            type vacmAccessWriteViewNameType;
            tailf:snmp-oid "1.3.6.1.6.3.16.1.4.1.6";
          }
          leaf vacmAccessNotifyViewName {
            type vacmAccessNotifyViewNameType;
            tailf:snmp-oid "1.3.6.1.6.3.16.1.4.1.7";
          }
          leaf vacmAccessStorageType {
            type SNMPv2_TC_StorageType;
            tailf:snmp-oid "1.3.6.1.6.3.16.1.4.1.8";
            default "nonVolatile";
          }
        }
      }
      container vacmViewTreeFamilyTable {
        list vacmViewTreeFamilyEntry {
          key "vacmViewTreeFamilyViewName vacmViewTreeFamilySubtree";
          tailf:sort-order "snmp";
          tailf:snmp-oid "1.3.6.1.6.3.16.1.5.2";
          leaf vacmViewTreeFamilyViewName {
            type vacmViewTreeFamilyViewNameType;
            tailf:snmp-oid "1.3.6.1.6.3.16.1.5.2.1.1";
          }
          leaf vacmViewTreeFamilySubtree {
            type yang:object-identifier;
            tailf:snmp-oid "1.3.6.1.6.3.16.1.5.2.1.2";
          }
          leaf vacmViewTreeFamilyMask {
            type vacmViewTreeFamilyMaskType;
            tailf:snmp-oid "1.3.6.1.6.3.16.1.5.2.1.3";
          }
          leaf vacmViewTreeFamilyType {
            type vacmViewTreeFamilyTypeType;
            tailf:snmp-oid "1.3.6.1.6.3.16.1.5.2.1.4";
            default "included";
          }
          leaf vacmViewTreeFamilyStorageType {
            type SNMPv2_TC_StorageType;
            tailf:snmp-oid "1.3.6.1.6.3.16.1.5.2.1.5";
            default "nonVolatile";
          }
        }
      }
    }

    // admin / SNMPv2-MIB
    container SNMPv2-MIB {
      container system {
        tailf:snmp-oid "1.3.6.1.2.1.1";
        leaf sysContact {
          type sysContactType;
          tailf:snmp-oid "1.3.6.1.2.1.1.4";
          default "";
        }
        leaf sysName {
          type sysNameType;
          tailf:snmp-oid "1.3.6.1.2.1.1.5";
          default "";
        }
        leaf sysLocation {
          type sysLocationType;
          tailf:snmp-oid "1.3.6.1.2.1.1.6";
          default "";
        }
      }
      container snmp {
        tailf:snmp-oid "1.3.6.1.2.1.11";
        leaf snmpEnableAuthenTraps {
          type snmpEnableAuthenTrapsType;
          tailf:snmp-oid "1.3.6.1.2.1.11.30";
          default "disabled";
        }
      }
    }

    // admin / controllers fabric
    container controllers {
      tailf:info "Access to hardware controller data";
      container fabric {
        tailf:info "Fabric configuration";

        // admin / controllers fabric link port ? location *
        list link {
          tailf:info "Link configuration commands(cisco-support)";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          key location;
          leaf location {
            type string {
              tailf:info "WORD;;Port location <Rack>/<Slot>/<Module>/<Asic#>/<Port#>";
            }
          }
          leaf port {
            tailf:info "Set admin state of a fabric link port";
            tailf:cli-prefix-key;
            type enumeration {
              enum fabricqrx {
                              tailf:info "Set admin state of a fabricq receive port";
              }
              enum ingressqtx {
                               tailf:info "Set admin state of an ingressq transmit port";
              }
              enum s1rx {
                         tailf:info "Set admin state of an s1 receive port";
              }
              enum s1tx {
                         tailf:info "Set admin state of an s1 transmit port";
              }
              enum s2rx {
                         tailf:info "Set admin state of an s2 receive port";
              }
              enum s2tx {
                         tailf:info "Set admin state of an s2 transmit port";
              }
              enum s3rx {
                         tailf:info "Set admin state of an s3 receive port";
              }
              enum s3tx {
                         tailf:info "Set admin state of an s3 transmit port";
              }
            }
          }
          leaf shutdown {
            tailf:info "Shut down state.";
            type empty;
          }
        }

        // admin / controllers fabric plane *
        list plane {
          tailf:info "Set state of fabric plane";
          tailf:cli-mode-name "admin-config-plane";
          key id;
          leaf id {
            type uint8 {
              tailf:info "<0-7>;;Fabric plane number.";
            }
          }

          // admin / controllers fabric plane * / oim
          container oim {
            tailf:info "Properties of optical interface modules (OIMs) in this plane";

            // admin / controllers fabric plane * / oim count
            leaf count {
              tailf:info "Number of optical interface modules (OIMs) used in this plane";
              type enumeration {
                enum 1 {
                  tailf:info "All cables in plane connect to the same OIM";
                }
                enum 3 {
                  tailf:info "The cables from each FC/M card connect to different OIMs";
                }
              }
            }

            // admin / controllers fabric plane * / oim width
            leaf width {
              tailf:info "Width of optical interface modules (OIMs) in this plane";
              type enumeration {
                enum 1 {
                  tailf:info "Single-width - each OIM covers one slot";
                }
                enum 2 {
                  tailf:info "Dual-width - each OIM covers two slots";
                }
              }
            }

            // admin / controllers fabric plane * / oim instance *
            list instance {
              tailf:info "Specify properties of one OIM";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-incomplete-command;
              key id;
              leaf id {
                type uint8 {
                  tailf:info "<0-2>;;Specify OIM instance number";
                }
              }
              leaf location {
                tailf:info "Specify location of the OIM";
                type string {
                  tailf:info "WORD;;Location of optical interface module in format Fx/SMy/FM";
                }
              }
            }
          }
        }
      }
    }

    // admin / dsc serial *
    container dsc {
      tailf:info "configure designated SC information";
      list serial {
        tailf:info "serial ID to configure rack number to";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-remove-before-change;
        tailf:cli-incomplete-command;
        key serial;
        leaf serial {
          type string {
            tailf:info "WORD;;(upto) 16 character serial id";
          }
        }
        leaf rack {
          tailf:info "rack number for the above serial ID";
          type uint8 {
            tailf:info "<0-247>;;enter LCC rack number";
          }
        }
      }
    }

    // admin / session
    grouping session-grouping {
      container session {
        tailf:info "Global default CLI session parameters";
        leaf complete-on-space {
          tailf:info "Enable/disable completion on space";
          type boolean;
        }
      }
    }
    uses session-grouping;

    // admin / crs16 set min-power-modules ? location *
    container crs16 {
      tailf:info "Set minimum number of Modular power supplies for CRS16";
      container set {
        tailf:info "Set minimum number of Modular power supplies for CRS16";
        list min-power-modules {
          tailf:info "Minimum number of power modules";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          key location;
          leaf location {
            tailf:info "Location to set minimum number of Modular power modules";
            tailf:cli-expose-key-name;
            type string {
              tailf:info "WORD;;Location to set minimum number of power modules; only locations specific to alarm cards should be used";
            }
          }
          leaf value {
            tailf:cli-drop-node-name;
            tailf:cli-prefix-key;
            type uint8 {
              tailf:info "<0-8>;;Minimum number of power modules";
            }
          }
        }
      }
    }

    // admin / user *
    list user {
      tailf:info "User alias and session parameters";
      key name;
      leaf name {
        type string {
          tailf:info "<name:string>";
        }
      }
      // admin / user / session
      uses session-grouping;
    }

    // admin / bad-config
    leaf bad-config {
      tailf:info "Used to debug bad config, do not set unless developer";
      type empty;
    }

    // admin / xyzroot
    leaf xyzroot {
      tailf:info "Internal state variable, do not modify.";
      tailf:cli-run-template "";
      tailf:cli-show-with-default;
      type uint16;
      default "0";
    }
  }


  /// ========================================================================
  /// developer "config" - DO NOT MODIFY
  /// ========================================================================

  container tailfned {
    tailf:info "DO NOT MODIFY, contents here are set by ned-settings only";
    leaf raw-run {
      type empty;
    }
    container api {
      tailf:info "DO NOT MODIFY, contents here are set by ned-settings only";
      leaf edit-route-policy {
        tailf:info "DO NOT MODIFY, this leaf is set by ned-settings only";
        type empty;
      }
      leaf service-policy-list {
        tailf:info "DO NOT MODIFY, this leaf is set by ned-settings only";
        type empty;
      }
      leaf class-map-match-access-group-list {
        tailf:info "DO NOT MODIFY, this leaf is set by ned-settings only";
        type empty;
      }
      leaf group-modeled {
        tailf:info "DO NOT MODIFY, this leaf is set by ned-settings only";
        type empty;
      }
      leaf snmp-server-enable-all-traps {
        tailf:info "DO NOT MODIFY, this leaf is set by ned-settings only";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// group
  /// ========================================================================

  // group *
  list group {
    tailf:info "config group definition mode";
    tailf:cli-mode-name "config-GRP";
    tailf:cli-exit-command "end-group";
    tailf:cli-full-command;
    cli:ned-diff-move-last {
      cli:arguments "when-delete";
    }
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;config group name";
      }
    }
    leaf line {
      tailf:cli-drop-node-name;
      cli:parse-global-when;
      when "not(/cisco-ios-xr:tailfned/api/group-modeled)" {
        tailf:dependency "/cisco-ios-xr:tailfned/api/group-modeled";
      }
      type string {
        tailf:info "WORD;;group contents as a single quoted string.";
      }
    }
    container config {
      tailf:cli-drop-node-name;
      cli:parse-global-when;
      when "/cisco-ios-xr:tailfned/api/group-modeled" {
        tailf:dependency "/cisco-ios-xr:tailfned/api/group-modeled";
      }
      uses segment-routing-grouping;
      uses evpn-config-grouping;
    }
  }


  /// ========================================================================
  /// configuration
  /// ========================================================================

  // configuration
  container configuration {
    tailf:info "Configuration related settings";

    // configuration commit auto-save filename
    container commit {
      tailf:info "auto-save the running configuration";
      container auto-save {
        tailf:info "auto-save the running configuration";
        leaf filename {
          tailf:info "filename to auto-save";
          type string {
            tailf:info "WORD;;Save to file";
          }
        }
      }
    }

    // configuration display interface slot-order
    container display {
      tailf:info "Display mode";
      container interface {
        tailf:info "hardware interfaces";
        leaf slot-order {
          tailf:info "Display interfaces in the slot-order in show run output";
          type empty;
        }
      }
    }
  }


  /// ========================================================================
  /// hostname
  /// ========================================================================

  leaf hostname {
    tailf:info "Set system's network name";
    type string {
      tailf:info "WORD;;This system's network name";
    }
  }


  /// ========================================================================
  /// license
  /// ========================================================================

  // license smart flexible-consumption enable
  container license {
    tailf:info "license";
    container smart {
      tailf:info "Smart Licensing";
      container flexible-consumption {
        tailf:info "flexible-consumption(Vortex) model";
        leaf enable {
          tailf:info "Enable flexible-consumption model";
          type empty;
        }
      }
    }
  }


  /// ========================================================================
  /// locale
  /// ========================================================================

  container locale {
    tailf:info "Define the geographical locale";

    // locale language
    leaf language {
      tailf:info "Define the language";
      type string {
        tailf:info "WORD;;Locale language abbrev";
      }
    }

    // locale country
    leaf country {
      tailf:info "Define the country";
      type string {
        tailf:info "WORD;;Locale country abbrev (warning: may take long time to commit)";
      }
    }
  }


  /// ========================================================================
  /// apply-group
  /// ========================================================================

  // apply-group
  uses apply-group-grouping;


  /// ========================================================================
  /// clock
  /// ========================================================================

  uses clock-grouping;


  /// ========================================================================
  /// banner
  /// ========================================================================

  container banner {
    tailf:info "Define a login banner";

    // banner exec
    container exec {
      tailf:info "Set EXEC process creation banner";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      uses banner-grouping;
    }

    // banner incoming
    container incoming {
      tailf:info "Set incoming terminal line banner";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      uses banner-grouping;
    }

    // banner motd
    container motd {
      tailf:info "Set Message of the Day banner";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      uses banner-grouping;
    }

    // banner login
    container login {
      tailf:info "Set login banner";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      uses banner-grouping;
    }

    // banner slip-ppp
    container slip-ppp {
      tailf:info "Set Message for SLIP/PPP";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      uses banner-grouping;
    }

    // banner prompt-timeout
    container prompt-timeout {
      tailf:info "Set Message for login authentication timeout";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      uses banner-grouping;
    }
  }


  /// ========================================================================
  /// exception
  /// ========================================================================

  uses exception-grouping;


  /// ========================================================================
  /// address-family
  /// ========================================================================

  container address-family {
    tailf:info "AFI/SAFI configuration";
    tailf:cli-explicit-exit;

    // address-family ipv4
    container ipv4 {
      tailf:info "IPv4 address family";

      // address-family ipv4 unicast
      container unicast {
        tailf:info "Unicast topology";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-af";
        presence true;
      }

      // address-family ipv4 multicast topology *
      container multicast {
        tailf:info "Multicast topology";
        list topology {
          tailf:info "Specify a non-default topology";
          tailf:cli-mode-name "config-af";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Topology name";
            }
          }
        }
      }
    }

    // address-family ipv6
    container ipv6 {
      tailf:info "IPv6 address family";

      // address-family ipv6 unicast
      container unicast {
        tailf:info "Unicast topology";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-af";
        presence true;
      }

      // address-family ipv6 multicast topology *
      container multicast {
        tailf:info "Multicast topology";
        list topology {
          tailf:info "Specify a non-default topology";
          tailf:cli-mode-name "config-af";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Topology name";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// cef
  /// ========================================================================

  container cef {
    tailf:info "CEF related commands";

    // cef adjacency
    container adjacency {
      tailf:info "Adjacency configuration";

      // cef adjacency route
      container route {
        tailf:info "Adjacency route configuration";

        // cef adjacency route override
        leaf override {
          tailf:info "Set override options for adjacency routes";
          type enumeration {
            enum "rib" {
              tailf:info "Set options for adjacency routes overriding RIB routes";
            }
          }
        }
      }
    }

    // cef load-balancing
    container load-balancing {
      tailf:info "Load balance";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-load-balancing";

      // cef load-balancing / algorithm adjust
      container algorithm {
        tailf:info "hash algorithm";
        leaf adjust {
          tailf:info "Specify adjust count to rotate the resultant hash of hash algo";
          type uint8 {
            tailf:info "<0-31>;;Adjust count - configure up to 31 for Typhoon & Tomahawk";
            range "0..31";
          }
        }
      }

      // cef load-balancing / fields
      container fields {
        tailf:info "hash fields";

        // cef load-balancing / fields l3
        container l3 {
          tailf:info "Exclude L4 port info from hash calculation";
          tailf:cli-delete-when-empty;
          presence true;
          leaf global {
            tailf:info "configure globally system wide";
            type empty;
          }
        }

        // cef load-balancing / fields l4
        container l4 {
          tailf:info "Load balancing at layer 4";
          tailf:cli-delete-when-empty;
          presence true;
          leaf gtp {
            tailf:info "Includes GTP TEID for hash calculation";
            type empty;
          }
        }
      }
    }

    // cef load-balancing fields L3|L4
    // cef load-balancing payload L2
    // Note: NCS-6000 API
    container load-balancing-non-mode {
      tailf:cli-drop-node-name;
      container load-balancing {
        tailf:info "Specify load balancing algorithm";
        leaf fields {
          tailf:info "Specify number of fields used for the load balancing";
          type enumeration {
            enum L3 {
                     tailf:info "Layer 3 load balancing";
            }
            enum L4 {
                     tailf:info "Layer 3 and Layer 4 load balancing";
            }
          }
        }
        leaf payload {
          tailf:info "Specify type of payload used for the load balancing";
          type enumeration {
            enum L2 {
                     tailf:info "Ethernet data";
            }
          }
        }
      }
    }

    // cef fast-reroute follow bgp-pic
    container fast-reroute {
      tailf:info "Modify fast-reroute handling behaviour";
      container follow {
        tailf:info "Override default timer";
        leaf bgp-pic {
          tailf:info "by BGP PIC update";
          type empty;
        }
      }
    }

    // cef encap-sharing disable
    container encap-sharing {
      tailf:info "Disable MPLS encapsulation sharing";
      leaf disable {
        tailf:info "Use this in conjunction with BGP per-prefix label mode";
        type empty;
      }
    }

    // cef proactive-arp-nd enable
    container proactive-arp-nd {
      tailf:info "Proactive ARP/ND";
      leaf enable {
        tailf:info "Enable proactive ARP/ND feature";
        type empty;
      }
    }

  }


  /// ========================================================================
  /// explicit-path
  /// ========================================================================

  container explicit-path {
    tailf:info "Explicit-path config commands";

    // explicit-path name *
    list name {
      tailf:info "Specify explicit path by name";
      tailf:cli-mode-name "config-expl-path";
      key pathname;
      leaf pathname {
        type string {
          tailf:info "WORD;;Enter name";
        }
      }

      // explicit-path name * / index *
      uses explicit-path-index-list-grouping;
    }

    // explicit-path identifier *
    list identifier {
      tailf:info "Specify explicit path by number";
      tailf:cli-mode-name "config-expl-path";
      key identifier;
      leaf identifier {
        type uint16 {
          tailf:info "<1-65535>;;Enter number";
          range "1..65535";
        }
      }

      // explicit-path identifier * / index *
      uses explicit-path-index-list-grouping;
    }
  }


  /// ========================================================================
  /// selective-vrf-download
  /// ========================================================================

  container selective-vrf-download {
    tailf:cli-add-mode;
    tailf:cli-explicit-exit;
    leaf disable {
      type empty;
    }
  }


  /// ========================================================================
  /// lcc
  /// ========================================================================

  container lcc {
    tailf:info "Label Consistency Checker";

    // lcc ipv4
    container ipv4 {
      tailf:info "IPv4 Configuration";
      container unicast {
        tailf:info "Unicast table";

        // lcc ipv4 unicast enable
        leaf enable {
          tailf:info "Enable background scan";
          type empty;
        }

        // lcc ipv4 unicast period
        leaf period {
          tailf:info "Period of checks in milliseconds";
          type uint32 {
            tailf:info "<100-600000>;;Period between buffers in scans in milliseconds";
            range "100..600000";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// vrf
  /// ========================================================================

  container vrf {
    tailf:info "VRF configuration commands";
    tailf:cli-explicit-exit;

    // vrf *
    list vrf-list {
      tailf:cli-mode-name "config-vrf";
      tailf:cli-drop-node-name;
      key name;
      leaf name {
        tailf:info "VRF name";
        type string {
          tailf:info "WORD;;VRF name";
        }
      }

      // vrf * / description
      leaf description {
        tailf:info "A description for the VRF";
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE;;Description for this VRF";
        }
      }

      // vrf * / fallback-vrf
      leaf fallback-vrf {
        tailf:info "Fallback vrf for this VRF";
        type string {
          tailf:info "WORD;;Fallback VRF name";
        }
      }

      // vrf * / rd
      leaf rd {
        tailf:info "Specify Route Distinguisher";
        tailf:cli-full-command;
        type union {
          type inet:ipv4-address;
          type string {
            tailf:info "ASN:nn or IP-address:nn;;VPN Route Distinguisher";
          }
        }
      }

      // vrf * / vpn id
      container vpn {
        tailf:info "VPN ID for the VRF";
        leaf id {
          tailf:info "VPN ID for the VRF";
          type string {
            tailf:info "<0-ffffff>:;;VPN ID, (OUI:VPN-Index) format(hex), 3 bytes OUI Part";
          }
        }
      }

      // vrf * / mode big
      container mode {
        tailf:info "VRF mode which determines the max prefix scale";
        leaf big {
          tailf:info "big to set max prefix scale more than 64 K";
          type empty;
        }
      }

      // vrf * / address-family
      container address-family {
        tailf:info "AFI/SAFI configuration";

        // vrf * / address-family ipv4
        container ipv4 {
          tailf:info "IPv4 address family";

          // vrf * / address-family ipv4 unicast
          container unicast {
            tailf:info "Unicast topology";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-vrf-af";
            presence true;
            uses vrf-af-ipv4-grouping;
          }

          // vrf * / address-family ipv4 multicast
          container multicast {
            tailf:info "Multicast topology";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-vrf-af";
            presence true;
            uses vrf-af-ipv4-grouping;
          }

          // vrf * / address-family ipv4 flowspec
          container flowspec {
            tailf:info "Flowspec sub address family";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-vrf-af";
            presence true;
            uses vrf-af-ipv4-grouping;
          }
        }

        // vrf * / address-family ipv6
        container ipv6 {
          tailf:info "IPv6 address family";

          // vrf * / address-family ipv6 unicast
          container unicast {
            tailf:info "Unicast topology";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-vrf-af";
            presence true;
            uses vrf-af-ipv6-grouping;
          }

          // vrf * / address-family ipv6 multicast
          container multicast {
            tailf:info "Multicast topology";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-vrf-af";
            presence true;
            uses vrf-af-ipv6-grouping;
          }

          // vrf * / address-family ipv6 flowspec
          container flowspec {
            tailf:info "Flowspec sub address family";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-vrf-af";
            presence true;
            uses vrf-af-ipv6-grouping;
          }
        }
      }
    }
  }


  /// ========================================================================
  /// ethernet
  /// ========================================================================

  container ethernet {
    tailf:info "Ethernet configuration commands";
    tailf:cli-explicit-exit;

    // ethernet egress-filter strict
    container egress-filter {
      tailf:info "Egress-filter commands";
      leaf strict {
        tailf:info "Strict egress-filtering on by default";
        type empty;
      }
    }

    // ethernet sla
    container sla {
      tailf:info "Service-Level Agreement configuration";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-sla";

      // ethernet sla / profile *
      list profile {
        tailf:info "Per-profile configuration";
        tailf:cli-mode-name "config-sla-prof";
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Profile name";
          }
        }
        leaf type {
          tailf:info "Type of packet that operations using this profile will send";
          tailf:cli-hide-in-submode;
          type enumeration {
            enum cfm-delay-measurement {
              tailf:info "CFM delay measurement packets";
            }
            enum cfm-delay-measurement-version-0 {
              tailf:info "CFM delay measurement version 0 packets";
            }
            enum cfm-loopback {
              tailf:info "CFM loopback packets";
            }
            enum cfm-loss-measurement {
              tailf:info "CFM loss measurement packets";
            }
            enum cfm-synthetic-loss-measurement {
              tailf:info "CFM synthetic loss measurement packets";
            }
          }
        }

        // ethernet sla / profile * / probe
        container probe {
          tailf:info "SLA Probe configuration";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-sla-prof-pb";

          // ethernet sla / profile * / probe / send
          container send {
            tailf:info "Configure properties of packets to send";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf type {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type enumeration {
                enum burst {
                   tailf:info "Send bursts of packets";
                }
                enum packet {
                   tailf:info "Send single packets";
                }
              }
            }
            choice once-or-interval {
              leaf once {
                tailf:info "Send a single packet/burst";
                type empty;
              }
              case interval {
                leaf every {
                  tailf:info "Specify how often packets within a probe should be sent";
                  type uint16 {
                    tailf:info "<1-10000>;;Interval between packets";
                  }
                }
                leaf every-time {
                  tailf:cli-drop-node-name;
                  type enumeration {
                    enum seconds {
                      tailf:info "Time is in seconds";
                    }
                    enum minutes {
                      tailf:info "Time is in minutes";
                    }
                    enum hours {
                      tailf:info "Time is in hours";
                    }
                  }
                }
              }
            }
            container packet {
              tailf:info "Configure properties of packets within each burst";
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              when "../type = 'burst'" {
                tailf:dependency "../type";
              }
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf count {
                tailf:info "Specify the number of packets in each burst";
                tailf:cli-incomplete-command;
                type uint16 {
                  tailf:info "<2-1200>;;Number of packets in each burst";
                  range "2..1200";
                }
              }
              leaf interval {
                tailf:info "Specify the interval between packets in each burst";
                tailf:cli-incomplete-command;
                type uint16 {
                  tailf:info "<1-30000>;;Interval between packets in each burst";
                  range "1..30000";
                }
              }
              choice time-choice {
                leaf seconds {
                  tailf:info "Time is in seconds";
                  tailf:cli-optional-in-sequence;
                  type empty;
                }
                leaf milliseconds {
                  tailf:info "Time is in milliseconds";
                  type empty;
                }
              }
            }
          }

          // ethernet sla / profile * / probe / priority
          leaf priority {
            tailf:info "Specify the priority to use when sending packets";
            type uint8 {
              tailf:info "<0-7>;;Packet priority of each packet in the probe";
              range "0..7";
            }
          }

          // ethernet sla / profile * / probe / packet size
          container packet {
            tailf:info "Configure properties of the packet";
            leaf size {
              tailf:info "Specify the minimum size of each packet in the probe (packets will be padded if needed)";
              type uint16 {
                tailf:info "<1-9000>;;Size of each packet in the probe";
                range "1..9000";
              }
            }
          }

          // ethernet sla / profile * / probe / synthetic loss calculation packets
          container synthetic {
            tailf:info "Specify the number of packets used in each FLR calculation";
            container loss {
              tailf:info "Specify the number of packets used in each FLR calculation";
              container calculation {
                tailf:info "Specify the number of packets used in each FLR calculation";
                leaf packets {
                  tailf:info "Specify the number of packets used in each FLR calculation";
                  type uint32 {
                    tailf:info "<10-12096000>;;Number of packets to use in each FLR calculation";
                    range "10..12096000";
                  }
                }
              }
            }
          }
        }

        // ethernet sla / profile * / schedule
        container schedule {
          tailf:info "SLA Schedule configuration";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-sla-prof-schedule";

          // ethernet sla / profile * / schedule / every
          container every {
            tailf:info "Specify scheduling frequency";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf number {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint8 {
                tailf:info "<1-90>;;Interval between operations (hours or minutes)";
                range "1..90";
              }
            }
            leaf every-time {
              tailf:cli-drop-node-name;
              type enumeration {
                enum minutes {
                  tailf:info "Time is in minutes";
                }
                enum hours {
                  tailf:info "Time is in hours";
                }
              }
            }
            leaf for {
              tailf:info "Specify how long operations should keep running for";
              tailf:cli-incomplete-command;
              type uint16 {
                tailf:info "<1-3600>;;Duration of operation (may be seconds, minutes, hours, days, or weeks)";
                range "1..3600";
              }
            }
            leaf for-time {
              tailf:cli-drop-node-name;
              type enumeration {
                enum seconds {
                  tailf:info "Time is in seconds";
                }
                enum minutes {
                  tailf:info "Time is in minutes";
                }
              }
            }
          }
        }

        // ethernet sla / profile * / statistics
        container statistics {
          tailf:info "SLA Statistics-collection configuration";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-sla-prof-stat";

          // ethernet sla / profile * / statistics / measure *
          list measure {
            tailf:info "Specify the type of statistics to collect";
            tailf:cli-mode-name "config-sla-prof-stat-cfg";
            key id;
            leaf id {
              type enumeration {
                enum one-way-delay-ds {
                  tailf:info "Collect one-way (destination-to-source) delay";
                }
                enum one-way-delay-sd {
                  tailf:info "Collect one-way (source-to-destination) delay";
                }
                enum one-way-jitter-ds {
                  tailf:info "Collect one-way (destination-to-source) jitter";
                }
                enum one-way-jitter-sd {
                  tailf:info "Collect one-way (source-to-destination) jitter";
                }
                enum round-trip-delay {
                  tailf:info "Collect round-trip delay";
                }
                enum round-trip-jitter {
                  tailf:info "Collect round-trip jitter";
                }
                enum one-way-loss-ds {
                  tailf:info "Collect one-way (destination-to-source) loss";
                }
                enum one-way-loss-sd {
                  tailf:info "Collect one-way (source-to-destination) loss";
                }
              }
            }

            // ethernet sla / profile * / statistics / measure * / aggregate
            container aggregate {
              tailf:info "Specify how results should be aggregated";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              choice aggregate-choice {
                case none {
                  leaf none {
                    tailf:info "Perform no aggregation";
                    type empty;
                  }
                }
                case bins-width {
                  leaf bins {
                    tailf:info "Aggregate results into a number of bins";
                    tailf:cli-incomplete-command;
                    type uint8 {
                      tailf:info "<2-100>;;Number of bins to distribute results between";
                      range "2..100";
                    }
                  }
                  leaf width {
                    tailf:info "Specify the width of each bin (in milliseconds for delay or percentage points for loss)";
                    type uint16 {
                      tailf:info "<1-10000>;;Width (in milliseconds for delay or percentage points for loss)";
                      range "1..10000";
                    }
                  }
                }
              }
            }

            // ethernet sla / profile * / statistics / measure * / buckets
            container buckets {
              tailf:info "Bucket configuration";

              // ethernet sla / profile * / statistics / measure * / buckets size
              container size {
                tailf:info "Configure the size of each bucket";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                leaf number {
                  tailf:cli-drop-node-name;
                  type uint8 {
                    tailf:info "<1-100>;;Size of each bucket (number of probes-per-bucket)";
                    range "1..100";
                  }
                }
                leaf probes {
                  tailf:info "Buckets span multiple probes";
                  type empty;
                }
              }

              // ethernet sla / profile * / statistics / measure * / buckets archive
              leaf archive {
                tailf:info "Configure the number of buckets to store internally";
                type uint8 {
                  tailf:info "<1-100>;;Number of buckets to store internally";
                  range "1..100";
                }
              }
            }
          }
        }
      }
    }

    // ethernet cfm
    container cfm {
      tailf:info "802.1ag Connectivity Fault Management configuration";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-cfm";

      // ethernet cfm / traceroute cache
      container traceroute {
        tailf:info "Traceroute configuration";
        container cache {
          tailf:info "Configure traceroute cache parameters";
          tailf:cli-compact-syntax;
          tailf:cli-reset-container;
          leaf hold-time {
            tailf:info "Traceroute cache hold-time";
            type uint32 {
              tailf:info "<1-525600>;;Hold-time, in minutes";
            }
          }
          leaf size {
            tailf:info "Traceroute cache size (number of replies)";
            type uint32 {
              tailf:info "<1-4294967295>;;Number of replies in the traceroute cache";
            }
          }
        }
      }

      // ethernet cfm / domain *
      list domain {
        tailf:info "Per domain configuration";
        tailf:cli-mode-name "config-cfm-dmn";
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Domain name (up to 80 chars)";
          }
        }
        leaf level {
          tailf:info "Level of this domain";
          tailf:cli-hide-in-submode;
          type uint8 {
            tailf:info "<0-7>;;Level";
          }
        }
        container id {
          tailf:info "Maintenance Domain Identifier";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-hide-in-submode;
          choice id-choice {
            leaf null {
              tailf:info "No MDID value";
              type empty;
            }
            leaf string {
              tailf:info "String";
              type string {
                tailf:info "WORD;;String (up to 43 chars)";
              }
            }
            leaf dns {
              tailf:info "DNS Name";
              type string {
                tailf:info "WORD;;DNS Name";
              }
            }
            leaf mac-address {
              tailf:info "MAC Address";
              type string {
                tailf:info "H.H.H;;48-bit MAC address";
              }
            }
          }
        }

        // ethernet cfm / domain * / service *
        list service {
          tailf:info "Per service configuration";
          tailf:cli-mode-name "config-cfm-dmn-svc";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-incomplete-command;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Service name (up to 80 chars)";
            }
          }

          choice service-type {
            // ethernet cfm / domain * / service * bridge
            container bridge {
              tailf:info "Use a Bridge Domain. All MEPs will be Up MEPs; MIPs are permitted";
              tailf:cli-hide-in-submode;
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              leaf group {
                tailf:info "Bridge Domain Group";
                tailf:cli-incomplete-command;
                type string {
                  tailf:info "WORD;;Bridge Domain Group Name";
                }
              }
              leaf bridge-domain {
                tailf:info "Bridge Domain";
                type string {
                  tailf:info "WORD;;Bridge Domain Name";
                }
              }
              container id {
                tailf:info "Short Maintenance Association Name";
                tailf:cli-flatten-container;
                tailf:cli-compact-syntax;
                choice id-choice {
                  container icc-based {
                    tailf:info "ICC-based format, as defined by ITU-T Y.1731";
                    tailf:cli-flatten-container;
                    tailf:cli-compact-syntax;
                    tailf:cli-sequence-commands {
                      tailf:cli-reset-siblings;
                    }
                    leaf icc-string {
                      tailf:cli-drop-node-name;
                      type string {
                        tailf:info "WORD;;ITU Carrier Code (ICC)";
                      }
                    }
                    leaf umc-string {
                      tailf:cli-drop-node-name;
                      type string {
                        tailf:info "WORD;;Unique MEG ID Code (UMC)";
                      }
                    }
                  }
                }
              }
            }

            // ethernet cfm / domain * / service * xconnect group * p2p *
            container xconnect {
              tailf:info "Use a Cross Connect. All MEPs will be Up MEPs; MIPs are permitted";
              tailf:cli-hide-in-submode;
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              leaf group {
                tailf:info "Cross Connect Group";
                tailf:cli-incomplete-command;
                type string {
                  tailf:info "WORD;;Cross Connect Group Name";
                }
              }
              leaf p2p {
                tailf:info "Point-to-Point Cross Connect";
                type string {
                  tailf:info "WORD;;Cross Connect Name";
                }
              }
              container id {
                tailf:info "Short Maintenance Association Name";
                tailf:cli-flatten-container;
                tailf:cli-compact-syntax;
                choice id-choice {
                  leaf number {
                    tailf:info "Number";
                    type uint16 {
                      tailf:info "<0-65535>;;Number ID";
                    }
                  }
                  leaf string {
                    tailf:info "String";
                    type string {
                      tailf:info "WORD;;String ID (up to 45 chars)";
                      length "1..45";
                    }
                  }
                  leaf vlanid {
                    tailf:info "VLAN ID";
                    type uint16 {
                      tailf:info "<1-4094>;;VLAN ID";
                      range "1..4094";
                    }
                  }
                  container icc-based {
                    tailf:info "ICC-based format, as defined by ITU-T Y.1731";
                    tailf:cli-flatten-container;
                    tailf:cli-compact-syntax;
                    tailf:cli-sequence-commands {
                      tailf:cli-reset-siblings;
                    }
                    leaf icc-string {
                      tailf:cli-drop-node-name;
                      type string {
                        tailf:info "WORD;;ITU Carrier Code (ICC)";
                      }
                    }
                    leaf umc-string {
                      tailf:cli-drop-node-name;
                      type string {
                        tailf:info "WORD;;Unique MEG ID Code (UMC)";
                      }
                    }
                  }
                }
              }
            }

            // ethernet cfm / domain * / service * down-meps
            container down-meps {
              tailf:info "Down MEPs; no MIPs permitted";
              tailf:cli-hide-in-submode;
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              presence true;

              // ethernet cfm / domain * / service * down-meps id
              container id {
                tailf:info "Short Maintenance Association Name";
                tailf:cli-flatten-container;
                tailf:cli-compact-syntax;
                tailf:cli-hide-in-submode;
                choice id-choice {
                  leaf number {
                    tailf:info "Number";
                    type uint16 {
                      tailf:info "<0-65535>;;Number ID";
                    }
                  }
                  leaf string {
                    tailf:info "String";
                    type string {
                      tailf:info "WORD;;String ID (up to 45 chars)";
                      length "1..45";
                    }
                  }
                }
              }
            }

            // ethernet cfm / domain * / service * flexible-xconnect vlan-aware evi
            container flexible-xconnect {
              tailf:info "Use a Flexible Cross Connect. All MEPs will be Up MEPs; MIPs are permitted";
              tailf:cli-hide-in-submode;
              tailf:cli-flatten-container;
              container vlan-aware {
                tailf:info "VLAN-aware Flexible Cross Connect";
                tailf:cli-flatten-container;
                leaf evi {
                  tailf:info "Set the Ethernet VPN Identifier";
                  type uint16 {
                    tailf:info "<1-65534>;;Ethernet VPN Identifier";
                    range "1..65534";
                  }
                }
              }
            }
          }

          // ethernet cfm / domain * / service * / continuity-check
          container continuity-check {
            tailf:cli-break-sequence-commands;
            tailf:info "Continuity-check configuration";
            // ethernet cfm / domain * / service * / continuity-check interval
            container interval {
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              leaf value {
                tailf:info "Set the continuity-check interval";
                tailf:cli-drop-node-name;
                type string {
                  tailf:info "WORD;;Interval of 3.3ms|10ms|100ms|1s|10s|1m|10m";
                }
              }
              // ethernet cfm / domain * / service * / continuity-check interval loss-threshold
              leaf loss-threshold {
                tailf:info "Set the continuity-check loss threshold";
                type uint8 {
                  tailf:info "<2-255>;;Loss threshold (in number of CCMs)";
                }
              }
            }
            // ethernet cfm / domain * / service * / continuity-check archive
            container archive {
              tailf:info "Set the continuity-check archive hold time";
              leaf hold-time {
                tailf:info "Set the continuity-check archive hold time";
                type uint16 {
                  tailf:info "<1-65535>;;Hold time (in minutes)";
                  range "1..65535";
                }
              }
            }
            // ethernet cfm / domain * / service * / continuity-check loss
            container loss {
              tailf:info "Loss threshold actions";
              leaf auto-traceroute {
                tailf:info "Automatically trigger a traceroute when a MEP times out";
                type empty;
              }
            }
          }

          // ethernet cfm / domain * / service * / log
          container log {
            tailf:info "Enable logging for particular types of event";

            // ethernet cfm / domain * / service * / log continuity-check
            container continuity-check {
              tailf:info "Enable continuity-check logging";
              leaf errors {
                tailf:info "Enable logging when continuity-check errors are detected";
                type empty;
              }
              container mep {
                tailf:info "Enable MEP continuity-check logging";
                leaf changes {
                  tailf:info "Enable logging on peer MEP state changes";
                  type empty;
                }
              }
            }

            // ethernet cfm / domain * / service * / log ais
            leaf ais {
              tailf:info "Enable logging when AIS or LCK messages are received";
              type empty;
            }

            // ethernet cfm / domain * / service * / log crosscheck
            container crosscheck {
              tailf:info "Enable crosscheck logging";
              leaf errors {
                tailf:info "Enable logging when crosscheck errors are detected";
                type empty;
              }
            }
          }

          // ethernet cfm / domain * / service * / mip auto-create
          container mip {
            tailf:info "MIP configuration";
            container auto-create {
              tailf:info "MIP auto-creation policy";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              choice create-choice {
                leaf all {
                  tailf:info "Create MIPs on all interfaces";
                  tailf:cli-optional-in-sequence;
                  type empty;
                }
                leaf lower-mep-only {
                  tailf:info "Create MIPs only on interfaces with a MEP at a lower level";
                  type empty;
                }
              }
              leaf ccm-learning {
                tailf:info "Enable CCM learning at MIPs created in this service";
                type empty;
              }
            }
          }

          // ethernet cfm / domain * / service * / mep crosscheck
          container mep {
            tailf:info "MEP configuration";
            container crosscheck {
              tailf:info "Statically define the Maintenence End Points with a Maintenance Association to be cross-checked";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-cfm-xcheck";

              // ethernet cfm / domain * / service * / mep crosscheck / auto
              leaf auto {
                tailf:info "Treat all remote MEPs for which CCMs are received as cross-check MEPs";
                type empty;
              }

              // ethernet cfm / domain * / service * / mep crosscheck / mep-id *
              list mep-id {
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                key id;
                leaf id {
                  type uint16 {
                    tailf:info "<1-8191>;;MEP ID";
                    range "1..8191";
                  }
                }
                leaf mac-address {
                  tailf:info "Expected MAC Address for the specified MEP";
                  type string {
                    tailf:info "H.H.H;;48-bit MAC address";
                  }
                }
              }
            }
          }

          // ethernet cfm / domain * / service * / efd
          container efd {
            tailf:info "Enable EFD to bring down ports when MEPs detect errors";
            tailf:cli-reset-container;
            tailf:cli-delete-when-empty;
            presence true;
            leaf protection-switching {
              tailf:info "Enable protection switching notifications when triggering EFD";
              type empty;
            }
          }
        }
      }
    }

    // ethernet oam profile *
    container oam {
      tailf:info "Configure information relating to Ethernet Link OAM";
      list profile {
        tailf:info "802.3 OAM profiles";
        tailf:cli-mode-name "config-eoam";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;The name of the profile";
          }
        }

        // ethernet oam profile * / mode
        leaf mode {
          tailf:info "OAM mode";
          type enumeration {
            enum active {
              tailf:info "Active mode";
            }
            enum passive {
              tailf:info "Passive mode";
            }
          }
        }

        // ethernet oam profile * / connection timeout
        container connection {
          tailf:info "OAM connection configuration";
          leaf timeout {
            tailf:info "OAM connection session timeout period";
            type uint8 {
              tailf:info "<2-30>;;Connection timeout period in number of lost periodic Information OAMPDUs";
              range "2..30";
            }
          }
        }

        // ethernet oam profile * / hello-interval
        leaf hello-interval {
          tailf:info "Hello interval time";
          tailf:cli-full-command;
          type enumeration {
            enum "100ms" {
              tailf:info "100 millisecond hello interval";
            }
            enum "1s" {
              tailf:info "1 second hello interval";
            }
          }
        }

        // ethernet oam profile * / mib-retrieval
        container mib-retrieval {
          tailf:info "MIB retrieval support";
          tailf:cli-delete-when-empty;
          tailf:cli-reset-container;
          presence true;
          leaf disable {
            tailf:info "Disable MIB retrieval support";
            type empty;
          }
        }

        // ethernet oam profile * / uni-directional link-fault detection
        container uni-directional {
          tailf:info "Uni-directional link-fault detection support";
          container link-fault {
            tailf:info "Uni-directional link-fault detection support";
            container detection {
              tailf:info "Uni-directional link-fault detection support";
              tailf:cli-delete-when-empty;
              tailf:cli-reset-container;
              presence true;
              leaf disable {
                tailf:info "Disable uni-directional link-fault detection support";
                type empty;
              }
            }
          }
        }

        // ethernet oam profile * / remote-loopback
        container remote-loopback {
          tailf:info "Remote-loopback support";
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          presence true;
          leaf disable {
            tailf:info "Disable remote loopback support";
            type empty;
          }
        }

        // ethernet oam profile * / link-monitor
        container link-monitor {
          tailf:info "Enter link-monitor submode";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-eoam-lm";

          // ethernet oam profile * / link-monitor / frame
          container frame {
            tailf:info "Frame event configuration";
            uses ethernet-oam-profile-link-monitor-frame-grouping;
          }

          // ethernet oam profile * / link-monitor / frame-period
          container frame-period {
            tailf:info "frame-period event configuration";
            uses ethernet-oam-profile-link-monitor-frame-grouping;
          }

          // ethernet oam profile * / link-monitor / frame-seconds
          container frame-seconds {
            tailf:info "frame-seconds event configuration";
            uses ethernet-oam-profile-link-monitor-frame-grouping;
          }

          // ethernet oam profile * / link-monitor / symbol-period
          container symbol-period {
            tailf:info "Symbol-period event configuration";
            uses ethernet-oam-profile-link-monitor-frame-grouping;
          }

          // ethernet oam profile * / link-monitor / monitoring
          container monitoring {
            tailf:info "Monitoring support";
            tailf:cli-reset-container;
            tailf:cli-delete-when-empty;
            presence true;
            leaf disable {
              tailf:info "Disable monitoring";
              type empty;
            }
          }
        }

        // ethernet oam profile * / require-remote
        container require-remote {
          tailf:info "Enter require-remote submode";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-eoam-require";

          // ethernet oam profile * / require-remote / link-monitoring
          leaf link-monitoring {
            tailf:info "Requirement of Link monitoring support";
            type empty;
          }

          container mib-retrieval {
            tailf:info "Requirement of MIB retrieval support";
            tailf:cli-delete-when-empty;
            tailf:cli-reset-container;
            presence true;
            leaf disabled {
              tailf:info "Disable the requirement of MIB retrieval support";
              type empty;
            }
          }

          leaf mode {
            tailf:info "Requirement of a specific OAM mode";
            type enumeration {
              enum active {
                tailf:info "Require active mode";
              }
              enum disabled {
                tailf:info "Disable the requirement of a specific mode";
              }
              enum passive {
                tailf:info "Require passive mode";
              }
            }
          }
        }

        // ethernet oam profile * / action
        container action {
          tailf:info "Enter action submode";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-eoam-action";

          // ethernet oam profile * / action / critical-event
          leaf critical-event {
            tailf:info "Action to perform when a critical event occurs";
            type enumeration {
              enum disable {
                            tailf:info "Perform no action";
              }
              enum log {
                        tailf:info "Log the event";
                        value 2;
              }
              enum error-disable-interface {
                tailf:info "Error-disable the interface";
                value 3;
              }
            }
          }

          // ethernet oam profile * / action / wiring-conflict
          leaf wiring-conflict {
            tailf:info "Action to perform when a wiring conflict occurs";
            type if-eth-oam-action-type;
          }

          // ethernet oam profile * / action / discovery-timeout
          leaf discovery-timeout {
            tailf:info "Action to perform when discovery timeout occurs";
            type enumeration {
              enum disable {
                            tailf:info "Perform no action";
              }
              enum efd {
                        tailf:info "Enable EFD to bring down the interface";
              }
              enum error-disable-interface {
                tailf:info "disable the interface";
                value 3;
              }
            }
          }

          // ethernet oam profile * / action / high-threshold
          leaf high-threshold {
            tailf:info "Action to perform when a high-threshold is crossed";
            tailf:cli-full-command;
            type enumeration {
              enum log {
                        tailf:info "Log the event";
                        value 2;
              }
              enum error-disable-interface {
                tailf:info "disable the interface";
                value 3;
              }
            }
          }

          // ethernet oam profile * / action / session-down
          leaf session-down {
            tailf:info "Action to perform when a session goes down";
            type enumeration {
              enum disable {
                            tailf:info "Perform no action";
              }
              enum efd {
                        tailf:info "Enable EFD to bring down the interface";
              }
              enum error-disable-interface {
                tailf:info "disable the interface";
                value 3;
              }
            }
          }

          // ethernet oam profile * / action / remote-loopback
          leaf remote-loopback {
            tailf:info "Action to perform when a remote loopback event occurs";
            type enumeration {
              enum disable {
                            tailf:info "Perform no action";
              }
            }
          }

          // ethernet oam profile * / action / capabilities-conflict
          leaf capabilities-conflict {
            tailf:info "Action to perform when a capabilities conflict occurs";
            type if-eth-oam-action-type;
          }
        }
      }
    }

    // ethernet ring g8032 profile *
    container ring {
      tailf:info "Ethernet Ring Protection";
      container g8032 {
        tailf:info "G.8032 Ethernet Ring Protection";
        list profile {
          tailf:info "G.8032 ring profile configuration";
          tailf:cli-mode-name "config-g8032-ring-profile";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;ERP profile name string";
            }
          }

          // ethernet ring g8032 profile * / timer
          container timer {
            tailf:info "G.8032 timer";

            // ethernet ring g8032 profile * / timer wtr
            leaf wtr {
              tailf:info "Wait-to-Restore timer";
              type uint8 {
                tailf:info "<1-12>;;minutes";
                range "1..12";
              }
            }

            // ethernet ring g8032 profile * / timer guard
            leaf guard {
              tailf:info "Guard timer";
              type uint16 {
                tailf:info "<10-2000>;;milliseconds";
                range "10..2000";
              }
            }

            // ethernet ring g8032 profile * / timer hold-off
            leaf hold-off {
              tailf:info "Hold off timer";
              type uint8 {
                tailf:info "<0-10>;;seconds";
                range "0..10";
              }
            }
          }
        }
      }
    }

    // ethernet service-activation-test
    container service-activation-test {
      tailf:info "Service activation test config";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-ethsat";

      // ethernet service-activation-test / profile *
      list profile {
        tailf:info "Profile name to set config for";
        tailf:cli-mode-name "config-ethsat-prf";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;The name of the profile";
          }
        }

        // ethernet service-activation-test / profile * / outer-cos
        container cos {
          tailf:cli-drop-node-name;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf outer-cos {
            tailf:info "Set the CoS to use in test packets";
            type uint8 {
              tailf:info "<0-7>;;Outer CoS value";
              range "0..7";
            }
          }
          leaf inner-cos {
            type uint8 {
              tailf:info "<0-7>;;Inner CoS value";
              range "0..7";
            }
          }
        }

        // ethernet service-activation-test / profile * / mode two-way
        container mode {
          tailf:info "Set the mode for tests";
          leaf two-way {
            tailf:info "Two-way mode";
            type empty;
          }
        }

        // ethernet service-activation-test / profile * / duration
        container duration {
          tailf:info "Set the duration config for tests";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf value {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<1-1440>;;Duration to run the test for";
              range "1..1440";
            }
          }
          leaf unit {
            tailf:cli-drop-node-name;
            type enumeration {
              enum hours {
                tailf:info "Duration given in hours";
              }
              enum minutes {
                tailf:info "Duration given in minutes";
              }
            }
          }
          leaf per-step {
            tailf:info "Set duration to be duration of each step";
            type empty;
          }
        }

        // ethernet service-activation-test / profile * / color-aware
        container color-aware {
          tailf:info "Set the color-aware config";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf cir {
            tailf:info "Set the value of the committed information rate (CIR)";
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<1-4294967295>;;CIR value";
              range "1..4294967295";
            }
          }
          leaf unit {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type enumeration {
              enum gbps {
                tailf:info "Information rate given in gigabits per second";
              }
              enum kbps {
                tailf:info "Information rate given in kilobits per second";
              }
              enum mbps {
                tailf:info "Information rate given in megabits per second";
              }
            }
          }
          leaf eir-color {
            tailf:info "Set config for excess information rate (EIR) packets";
            tailf:cli-incomplete-command;
            type empty;
          }
          leaf set-dei {
            tailf:info "Set the drop-eligibility-indicator (DEI) bit for EIR packets";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          leaf cos {
            tailf:info "Set the CoS value for EIR packets";
            type uint8 {
              tailf:info "<0-7>;;CoS value for EIR packets";
              range "0..7";
            }
          }
        }

        // ethernet service-activation-test / profile * / packet-size
        container packet-size {
          tailf:info "Set the packet size and pattern to use for tests";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          choice packet-size-choice {
            leaf emix {
              tailf:info "Use packet size and contents configured in the EMIX profile";
              type empty;
            }
            leaf value {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<64-10236>;;Packet size in bytes";
                range "64..10236";
              }
            }
          }
        }

        // ethernet service-activation-test / profile * / information-rate
        container information-rate {
          tailf:info "Set the information rate to use in tests";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf value {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<1-4294967295>;;The fixed information rate to use";
              range "1..4294967295";
            }
          }
          leaf unit {
            tailf:cli-drop-node-name;
            type enumeration {
              enum gbps {
                tailf:info "Information rate given in gigabits per second";
              }
              enum kbps {
                tailf:info "Information rate given in kilobits per second";
              }
              enum mbps {
                tailf:info "Information rate given in megabits per second";
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// rcc
  /// ========================================================================

  container rcc {
    tailf:info "Route Consistency Checker";

    // rcc ipv4 unicast
    container ipv4 {
      tailf:info "IPv4 Configuration";
      container unicast {
        tailf:info "Unicast tables";

        // rcc ipv4 unicast enable
        leaf enable {
          tailf:info "Enable background scan";
          type empty;
        }

        // rcc ipv4 unicast period
        leaf period {
          tailf:info "Period of checks in milliseconds";
          type uint32 {
            tailf:info "<100-600000>;;Period between buffers in scans in milliseconds";
            range "100..600000";
          }
        }
      }
    }

    // rcc ipv6 unicast
    container ipv6 {
      tailf:info "Ipv6 Configuration";
      container unicast {
        tailf:info "Unicast tables";

        // rcc ipv6 unicast enable
        leaf enable {
          tailf:info "Enable background scan";
          type empty;
        }

        // rcc ipv6 unicast period
        leaf period {
          tailf:info "Period of checks in milliseconds";
          type uint32 {
            tailf:info "<100-600000>;;Period between buffers in scans in milliseconds";
            range "100..600000";
          }
        }
      }
    }
  }

  /// ========================================================================
  /// pce
  /// ========================================================================

  container pce {
    tailf:info "Path Computation Server configurations";
    tailf:cli-add-mode;
    tailf:cli-explicit-exit;
    presence true;

    // pce / address ipv4
    container address {
      tailf:info "Address of PCE server";

      // pce / address ipv4
      leaf ipv4 {
        tailf:info "IPv4 address";
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;IPv4 address of the PCE server";
        }
      }

      // pce / address ipv6
      leaf ipv6 {
        tailf:info "IPv6 address";
        type inet:ipv6-address {
          tailf:info "X:X::X;;IPv6 address of the PCE server";
        }
      }
    }

    // pce / disjoint-path
    container disjoint-path {
      tailf:info "Disjoint Path Configuration";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-pce-path";
      presence true;

      // pce / disjoint-path / group-id * type *
      list group-id {
        tailf:info "Group ID";
        tailf:cli-mode-name "config-pce-path-group";
        key "id type";
        leaf id {
          tailf:cli-suppress-range;
          type uint16 {
            tailf:info "<1-65535>;;Group ID";
            range "1..65535";
          }
        }
        leaf type {
          tailf:info "Disjointness type";
          tailf:cli-expose-key-name;
          type enumeration {
            enum link {
              tailf:info "Link Disjointness";
            }
            enum node {
              tailf:info "Node Disjointness";
            }
            enum srlg {
              tailf:info "SRLG Disjointness";
            }
            enum srlg-node {
              tailf:info "SRLG Node Disjointness";
            }
          }
        }
        uses pce-disjoint-path-group-id-grouping;
      }

      // pce / disjoint-path / group-id * type * sub-id *
      container group-sub-id {
        tailf:cli-drop-node-name;
        list group-id {
          tailf:info "Group ID";
          tailf:cli-mode-name "config-pce-path-group";
          key "id type sub-id";
          leaf id {
            tailf:cli-suppress-range;
            type uint16 {
              tailf:info "<1-65535>;;Group ID";
              range "1..65535";
            }
          }
          leaf type {
            tailf:info "Disjointness type";
            tailf:cli-expose-key-name;
            type enumeration {
              enum link {
                tailf:info "Link Disjointness";
              }
              enum node {
                tailf:info "Node Disjointness";
              }
              enum srlg {
                tailf:info "SRLG Disjointness";
              }
              enum srlg-node {
                tailf:info "SRLG Node Disjointness";
              }
            }
          }
          leaf sub-id {
            tailf:info "Sub ID";
            tailf:cli-expose-key-name;
            type uint16 {
              tailf:info "<1-65535>;;Sub ID";
              range "1..65535";
            }
          }
          uses pce-disjoint-path-group-id-grouping;
        }
      }
    }

    // pce / logging
    container logging {
      tailf:info "PCE logging configuration";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-pce-logging";

      // pce / logging / pcep pcerr-received
      container pcep {
        tailf:info "Path Computation Element Protocol (PCEP) logging";
        leaf pcerr-received {
          tailf:info "logging of received PCErr messages";
          type empty;
        }
      }

      // pce / logging / no-path
      leaf no-path {
        tailf:info "logging no-path messages";
        type empty;
      }

      // pce / logging / fallback
      leaf fallback {
        tailf:info "logging fallback messages";
        type empty;
      }
    }

    // pce / timers
    container timers {
      tailf:info "PCE timers configuration";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-pce-timers";

      // pce / timers / reoptimization
      leaf reoptimization {
        tailf:info "Topology reoptimization interval";
        type uint32 {
          tailf:info "<10-86400>;;Timer value in seconds; default is 60";
          range "10..86400";
        }
      }

      // pce / timers / keepalive
      leaf keepalive {
        tailf:info "Keepalive interval";
        type uint8 {
          tailf:info "<0-255>;;Time value in seconds. Use zero to disable; default is 30";
        }
      }

      // pce / timers / minimum-peer-keepalive
      leaf minimum-peer-keepalive {
        tailf:info "Minimum acceptable peer proposed keepalive interval";
        type uint8 {
          tailf:info "<0-255>;;Time value in seconds. Use zero to disable; default is 20";
        }
      }
    }

    // pce / state-sync ipv4 *
    container state-sync {
      tailf:info "Forward received reports to other PCE";
      list ipv4 {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key address;
        leaf address {
          tailf:cli-suppress-range;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IPv4 address of the PCE server";
          }
        }
      }
    }

    // pce / password
    container password {
      tailf:info "Configure password for MD5 authentication";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      uses password-grouping {
        refine "secret" {
          cli:secret " password <SECRET>";
        }
      }
    }

    // pce / backoff
    container backoff {
      tailf:info "PCE backoff configuration";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-pce-backoff";

      // pce / backoff / ratio
      leaf ratio {
        tailf:info "Backoff common ratio";
        type uint8 {
          tailf:info "<0-255>;;Backoff common ratio; default is 2";
        }
      }

      // pce / backoff / difference
      leaf difference {
        tailf:info "Backoff common difference";
        type uint8 {
          tailf:info "<0-255>;;Backoff common difference; default is 2";
        }
      }

      // pce / backoff / threshold
      leaf threshold {
        tailf:info "Backoff threshold";
        type uint16 {
          tailf:info "<0-3600>;;Threshold value in seconds. Use zero to disable; default is 0";
          range "0..3600";
        }
      }
    }

    // pce / segment-routing
    container segment-routing {
      tailf:info "PCE segment-routing configuration";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-pce-sr";

      // pce / segment-routing / traffic-eng
      container traffic-eng {
        tailf:info "Segment Routing Traffic Engineering";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-pce-sr-te";
        presence true;

        // pce / segment-routing / traffic-eng / p2mp
        container p2mp {
          tailf:info "P2MP configuration";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-pce-sr-te-p2mp";

          // pce / segment-routing / traffic-eng / p2mp / endpoint-set * /
          list endpoint-set {
        	tailf:info "Endpoint-set configuration";
        	tailf:cli-mode-name "config-pce-p2mp-ep-set";

        	key name;
        	leaf name {
        	  type string {
        		tailf:info "WORD;;Identifying name for endpoint-set with max 128 characters";
        	  }
        	}

        	// pce / segment-routing / traffic-eng / p2mp / endpoint-set * / ipv4 *
        	list ipv4 {
        	  tailf:info "Specify the address AFI";
        	  tailf:cli-suppress-mode;
        	  tailf:cli-delete-when-empty;

        	  key address;
        	  leaf address {
        		type inet:ipv4-address;
        	  }
        	}
          }

          // pce / segment-routing / traffic-eng / p2mp / policy * /
          list policy {
        	tailf:info "Policy configuration";
        	tailf:cli-mode-name "config-pce-p2mp-policy";

        	key name;
        	leaf name {
        	  type string {
        		tailf:info "WORD;;Identifying name for policy with max 128 characters";
        	  }
        	}

        	// pce / segment-routing / traffic-eng / p2mp / policy * / source
        	container source {
        	  tailf:info "Specify source IP address";
        	  tailf:cli-incomplete-command;

        	  // pce / segment-routing / traffic-eng / p2mp / policy * / source ipv4
        	  leaf ipv4 {
        		tailf:info "IPv4 address";
        		tailf:cli-full-command;
        		type inet:ipv4-address;
        	  }
        	}

        	// pce / segment-routing / traffic-eng / p2mp / policy * / color
        	container color {
        	  tailf:info "Specify color for policy";
        	  tailf:cli-compact-syntax;
        	  tailf:cli-sequence-commands;

        	  leaf value {
        		tailf:cli-drop-node-name;
        		tailf:cli-incomplete-command;
        		type uint32 {
        		  tailf:info "<1-4294967295>;;Color value";
        		  range "1..4294967295";
        		}
        	  }

        	  // pce / segment-routing / traffic-eng / p2mp / policy * / color endpoint-set
        	  leaf endpoint-set {
        		tailf:info "Policy endpoint-set";
        		type string {
        		  tailf:info "WORD;;Identifying name of the endpoint-set with max 128 characters";
        		}
        	  }
        	}

        	// pce / segment-routing / traffic-eng / p2mp / policy * / treesid
        	container treesid {
        	  tailf:info "Specify the TreeSID";

        	  // pce / segment-routing / traffic-eng / p2mp / policy * / treesid mpls
        	  leaf mpls {
        		tailf:info "MPLS label";
        		type uint32 {
        		  tailf:info "<16-1048575>;;Label value";
        		  range "16..1048575";
        		}
        	  }
        	}

        	// pce / segment-routing / traffic-eng / p2mp / policy * / candidate-paths /
        	container candidate-paths {
        	  tailf:info "Candidate-paths configuration";
        	  tailf:cli-add-mode;
        	  tailf:cli-mode-name "config-pce-p2mp-policy-path";

        	  // pce / segment-routing / traffic-eng / p2mp / policy * / candidate-paths /  preference * /
        	  list preference {
        		tailf:info "Policy path preference entry";
        		tailf:cli-mode-name "config-pce-p2mp-policy-path-preference";
        		key id;
        		leaf id {
        		  type enumeration {
        			enum 100 {
        			  tailf:info "<100-100>;;Path preference";
        			}
        		  }
        		}

        		// pce / segment-routing / traffic-eng / p2mp / policy * / candidate-paths /  preference * / dynamic /
        		container dynamic {
        		  tailf:info "Dynamically computed path";
        		  tailf:cli-add-mode;
        		  tailf:cli-mode-name "config-pce-p2mp-path-info";
        		  presence true;
                  container metric {
                    tailf:info "Path metric configuration";
                    tailf:cli-add-mode;
                    leaf type {
                      tailf:info "Metric type configuration";
                      type enumeration {
                        enum hopcount {
                          tailf:info "Use the least number of hops for path computation";
                        }
                        enum igp {
                          tailf:info "IGP metric type";
                        }
                        enum latency {
                          tailf:info "Latency metric type";
                        }
                        enum te {
                          tailf:info "TE metric type";
                        }
                      }
                    }
                  }
        		}
        	  }
        	}
          }
        }

        // pce / segment-routing / traffic-eng / segment-list name *
        list segment-list {
          tailf:info "Segment-list configuration";
          tailf:cli-mode-name "config-pce-sr-te-sl";
          key name;
          leaf name {
            tailf:info "Segment-list name";
            tailf:cli-expose-key-name;
            type string {
              tailf:info "WORD;;Identifying name for segment-list with max 128 characters";
              length "1..128";
            }
          }

          // pce / backoff / segment-routing / traffic-eng / segment-list name * / index *
          list index {
            tailf:info "Next entry index";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key id;
            leaf id {
              type uint16 {
                tailf:info "<1-65535>;;Index number";
                range "1..65535";
              }
            }
            // pce / backoff / segment-routing / traffic-eng / segment-list name * / index * mpls label
            // pce / backoff / segment-routing / traffic-eng / segment-list name * / index * mpls adjacency
            // pce / backoff / segment-routing / traffic-eng / segment-list name * / index * address ipv4
            choice config-choice {
              container mpls {
                tailf:info "MPLS configuration";
                leaf label {
                  tailf:info "MPLS label configuration";
                  type uint32 {
                    tailf:info "<0-1048575>;;MPLS label value";
                    range "1..1048575";
                  }
                }
                leaf adjacency {
                  tailf:info "Specify hop address";
                  type union {
                    type inet:ipv4-address {
                      tailf:info "A.B.C.D;;Ip Address";
                    }
                    type inet:ipv6-address {
                      tailf:info "X:X::X;;IPV6 address";
                    }
                  }
                }
              }
              container address {
                tailf:info "Specify hop address";
                leaf ipv4 {
                  tailf:info "Specify the address AFI";
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;IPv4 address (A.B.C.D)";
                  }
                }
              }
            }
          }
        }

        // pce / segment-routing / traffic-eng / peer ipv4 *
        container peer {
          tailf:info "PCEP peer to configure";
          list ipv4 {
            tailf:info "IPv4 address of the PCEP peer";
            tailf:cli-mode-name "config-pce-sr-te-peer";
            key address;
            leaf address {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Identifying IPv4 address of the PCEP peer";
              }
            }

            // pce / backoff / segment-routing / traffic-eng / peer ipv4 * / policy *
            list policy {
              tailf:info "Name of SR-TE Policy";
              tailf:cli-mode-name "config-pce-sr-te-policy";
              key name;
              leaf name {
                type string {
                  tailf:info "WORD;;Identifying name for policy with max 128 characters";
                }
              }

              // pce / backoff / segment-routing / traffic-eng / peer ipv4 * / policy * / binding-sid mpls
              container binding-sid {
                tailf:info "Bnding Segment Identifier";
                leaf mpls {
                  tailf:info "MPLS label";
                  type uint32 {
                    tailf:info "<16-1048575>;;MPLS label";
                    range "16..1048575";
                  }
                }
              }

              // pce / backoff / segment-routing / traffic-eng / peer ipv4 * / policy * / color
              container color {
                tailf:info "Specify color for policy";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands;
                leaf value {
                  tailf:cli-drop-node-name;
                  tailf:cli-incomplete-command;
                  type uint32 {
                    tailf:info "<1-4294967295>;;Color value";
                    range "1..4294967295";
                  }
                }
                container end-point {
                  tailf:info "Policy endpoint";
                  tailf:cli-flatten-container;
                  tailf:cli-compact-syntax;
                  leaf ipv4 {
                    tailf:info "IPv4 address";
                    type inet:ipv4-address {
                      tailf:info "A.B.C.D;;IPv4 endpoint address";
                    }
                  }
                }
              }

              // pce / backoff / segment-routing / traffic-eng / peer ipv4 * / policy * / shutdown
              leaf shutdown {
                tailf:info "Policy admin-shutdown";
                type empty;
              }

              // pce / backoff / segment-routing / traffic-eng / peer ipv4 * / policy * / candidate-paths
              container candidate-paths {
                tailf:info "Candidate-paths configuration";
                tailf:cli-add-mode;
                tailf:cli-mode-name "config-pce-sr-te-policy-path";
                presence true;

                // pce / backoff / segment-routing / traffic-eng / peer ipv4 * / policy * / candidate-paths / preference *
                list preference {
                  tailf:info "Policy path-option preference entry";
                  tailf:cli-mode-name "config-pce-sr-te-policy-path-preference";
                  key id;
                  leaf id {
                    type uint16 {
                      tailf:info "<1-65535>;;Path-option preference";
                      range "1..65535";
                    }
                  }

                  // pce / backoff / segment-routing / traffic-eng / peer ipv4 * / policy * / candidate-paths / preference * / explicit segment-list *
                  container explicit {
                    tailf:info "Preconfigured path";
                    list segment-list {
                      tailf:info "Specify Segment-list";
                      tailf:cli-mode-name "config-pce-sr-te-pp-info";
                      key name;
                      leaf name {
                        type string {
                          tailf:info "WORD;;Identifying name for Segment-list";
                        }
                      }
                    }
                  }

                  // pce / backoff / segment-routing / traffic-eng / peer ipv4 * / policy * / candidate-paths / preference * / dynamic mpls
                  container dynamic {
                    tailf:info "Dynamically allocated path";
                    container mpls {
                      tailf:info "MPLS path type";
                      tailf:cli-add-mode;
                      tailf:cli-mode-name "config-pce-sr-te-pp-info";
                      presence true;

                      // pce / backoff / segment-routing / traffic-eng / peer ipv4 * / policy * / candidate-paths / preference * / dynamic mpls / metric
                      container metric {
                        tailf:info "Path metric configuration";
                        tailf:cli-add-mode;
                        tailf:cli-mode-name "config-pce-sr-te-path-metric";
                        presence true;

                        // pce / backoff / segment-routing / traffic-eng / peer ipv4 * / policy * / candidate-paths / preference * / dynamic mpls / metric / type igp
                        leaf type {
                          tailf:info "Metric type configuration";
                          type enumeration {
                            enum igp {
                                      tailf:info "IGP metric type";
                            }
                            enum te {
                                     tailf:info "TE metric type";
                            }
                          }
                        }
                      }
                    }
                  }
                }

                // pce / backoff / segment-routing / traffic-eng / peer ipv4 * / policy * / candidate-paths / affinity
                container affinity {
                  tailf:info "Assign affinities to path";
                  tailf:cli-add-mode;
                  tailf:cli-mode-name "config-pce-sr-te-path-affinity";

                  // pce / backoff / segment-routing / traffic-eng / peer ipv4 * / policy * / candidate-paths / affinity / exclude
                  // pce / backoff / segment-routing / traffic-eng / peer ipv4 * / policy * / candidate-paths / affinity / include-all
                  // pce / backoff / segment-routing / traffic-eng / peer ipv4 * / policy * / candidate-paths / affinity / include-any
                  list attribute-list {
                    tailf:cli-drop-node-name;
                    tailf:cli-mode-name "config-pce-sr-te-path-affinity-rule";
                    tailf:cli-full-command;
                    key name;
                    leaf name {
                      type enumeration {
                        enum exclude {
                          tailf:info "Affinity attributes to exclude";
                        }
                        enum include-all {
                          tailf:info "Affinity attributes - all must be included";
                        }
                        enum include-any {
                          tailf:info "Affinity attributes - at least one must be included";
                        }
                      }
                    }

                    // pce / backoff / segment-routing / traffic-eng / peer ipv4 * / policy * / candidate-paths / affinity / * / *
                    list color {
                      tailf:cli-drop-node-name;
                      tailf:cli-suppress-mode;
                      tailf:cli-delete-when-empty;
                      key name;
                      leaf name {
                        tailf:cli-disallow-value "exit|xyzroot";
                        type string {
                          tailf:info "WORD;;Affinity color name";
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }

        // pce / segment-routing / traffic-eng / affinity bit-map
        container affinity {
          tailf:info "Affinity configuration(cisco-support)";
          container bit-map {
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-pce-sr-te-affinity-map";

            // pce / backoff / segment-routing / traffic-eng / affinity bit-map / *
            list color {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-incomplete-command;
              key name;
              leaf name {
                tailf:cli-disallow-value "exit|xyzroot";
                type string {
                  tailf:info "WORD;;Affinity color name";
                }
              }
              leaf bit-position {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<0-31>;;Affinity attribute bit position";
                  range "0..31";
                }
              }
            }
          }
        }
      }

      // pce / segment-routing / strict-sid-only
      leaf strict-sid-only {
        tailf:info "Use strict sids only";
        type empty;
      }

      // pce / segment-routing / te-latency
      leaf te-latency {
        tailf:info "Use te latency algorithm";
        type empty;
      }
    }

    // pce / rest
    container rest {
      tailf:info "REST Configuration";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-pce-rest";
      presence true;

      // pce / rest / user *
      list user {
        tailf:info "Name of the REST user";
        tailf:cli-mode-name "config-pce-rest-user";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of the REST user";
          }
        }

        // pce / rest / user * / password
        container password {
          tailf:info "Configure password for REST user";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          uses password-grouping {
            refine "secret" {
              cli:secret " password <SECRET>";
            }
          }
        }
      }

      // pce / rest / authentication
      leaf authentication {
        tailf:info "Configure desired REST authentication";
        type enumeration {
          enum basic {
            tailf:info "Use HTTP Basic authentication (plaintext)";
          }
          enum digest {
            tailf:info "Use HTTP Digest authentication (MD5)";
          }
        }
      }
    }

    // pce / api
    container api {
      tailf:info "Northbound API Configuration";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-pce-api";
      presence true;

      // pce / api / user *
      list user {
        tailf:info "Northbound API username";
        tailf:cli-mode-name "config-pce-api-user";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of the API user";
          }
        }

        // pce / api / user * / password
        container password {
          tailf:info "Configure password for API username";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          uses password-grouping {
            refine "secret" {
              cli:secret " password <SECRET>";
            }
          }
        }
      }

      // pce / api / authentication
      leaf authentication {
        tailf:info "Configure desired API authentication";
        type enumeration {
          enum basic {
            tailf:info "Use HTTP Basic authentication (plaintext)";
          }
          enum digest {
            tailf:info "Use HTTP Digest authentication (MD5)";
          }
        }
        default basic;
      }
    }
  }


  /// ========================================================================
  /// pppoe
  /// ========================================================================

  container pppoe {
    tailf:info "PPPoE";
    tailf:cli-explicit-exit;

    // pppoe bba-group *
    container bba-group-list {
      tailf:cli-drop-node-name;
      list bba-group {
        tailf:cli-mode-name "config-bbagroup";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;BBA Group Name";
          }
        }
        uses pppoe-bba-group-grouping;
      }
    }

    // pppoe bba-group
    container bba-group {
      tailf:info "BBA-Group";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-bbagroup";
      uses pppoe-bba-group-grouping;
    }

    // pppoe in-flight-window
    leaf in-flight-window {
      tailf:info "Set the PPPoE in-flight window size(cisco-support)";
      type uint16 {
        tailf:info "<1-20000>;;PPPoE in-flight window size";
        range "1..20000";
      }
    }
  }


  /// ========================================================================
  /// rp
  /// ========================================================================

  // rp mgmtethernet forwarding
  container rp {
    tailf:info "rp configuration commands";
    container mgmtethernet {
      tailf:info "Management ethernet configuration commands";
      leaf forwarding {
        tailf:info "LC to RP switching ON";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// logging
  /// ========================================================================

  container logging {
    tailf:info "Modify message logging facilities";
    tailf:cli-explicit-exit;

    // logging disable
    leaf disable {
      tailf:cli-full-command;
      type empty;
    }

    // logging ipv4 dscp
    container ipv4 {
      tailf:info "Mark the dscp/precedence bit for ipv4 packets";
      leaf dscp {
        tailf:info "Set IP DSCP (DiffServ CodePoint)";
        type dscp-type;
      }
    }

    // logging ipv6 dscp
    container ipv6 {
      tailf:info "Mark the dscp/precedence bit for ipv6 packets";
      leaf dscp {
        tailf:info "Set IP DSCP (DiffServ CodePoint)";
        type dscp-type;
      }
    }

    // logging trap
    leaf trap {
      tailf:info "Set syslog server logging level";
      tailf:cli-full-command;
      type severity-type;
    }

    // logging events
    container events {
      tailf:info "Configure event monitoring parameters";

      // logging events level
      leaf level {
        tailf:info "Log all events with equal or higher (lower level) severity";
        type severity-type;
      }

      // logging events link-status
      leaf link-status {
        tailf:info "Enable or disable UP/DOWN state notifications for all interfaces";
        type enumeration {
          enum disable {
                        tailf:info "Disable state UP/DOWN notifications for all interfaces";
          }
          enum software-interfaces {
            tailf:info "Enable state UP/DOWN notification for software interfaces";
          }
        }
      }

      // logging events threshold
      leaf threshold {
        tailf:info "Configure threshold (%) for capacity alarm";
        type uint8 {
          tailf:info "<10-100>;;Capacity alarm threshold";
        }
      }

      // logging events buffer-size
      leaf buffer-size {
        tailf:info "Set size of the local event buffer";
        type uint32 {
          tailf:info "<1024-1024000>;;Size of the local event buffer";
        }
      }

      // logging events display-location
      leaf display-location {
        tailf:info "Include alarm source location in message text";
        type empty;
      }

      // logging events filter
      container filter {
        tailf:info "Configure filter";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-logging_events-filter";

        // logging events filter / match *
        list match {
          tailf:info "Configure match string to filter";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;String to match with alarms";
            }
          }
        }
      }
    }

    // logging file * path
    list file {
      tailf:info "Set file logging";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-incomplete-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;File name";
        }
      }
      leaf path {
        tailf:info "Set file path";
        type string {
          tailf:info "WORD;;File path";
        }
      }
      leaf maxfilesize {
        tailf:info "Set max file size";
        tailf:cli-optional-in-sequence;
        type uint32 {
          tailf:info "<1-2097152>;;Max file size (in KB)";
          range "1..2097152";
        }
      }
      leaf severity {
        tailf:info "Set severity level";
        type severity-type;
      }
    }

    // logging archive
    container archive {
      tailf:info "logging to a persistent device(disk/harddisk)";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-logging-arch";

      // logging archive / device
      leaf device {
        tailf:info "Configure the archive device";
        type string {
          tailf:info "WORD;;Disk to use as the archive device";
        }
      }

      // logging archive / severity
      leaf severity {
        tailf:info "The minimum severity of log messages to archive";
        type severity-type;
      }

      // logging archive / file-size
      leaf file-size {
        tailf:info "The maximum file size for a single log file";
        type uint32 {
          tailf:info "<1-2047>;;Size in MB";
          range "1..2047";
        }
      }

      // logging archive / frequency
      leaf frequency {
        tailf:info "The collection interval for logs";
        type enumeration {
          enum daily {
                      tailf:info "Collect log in files on a daily basis";
          }
          enum weekly {
                       tailf:info "Collect log in files on a weekly basis";
          }
        }
      }

      // logging archive / archive-size
      leaf archive-size {
        tailf:info "The total size of the archive";
        type uint32 {
          tailf:info "<1-2047>;;Size in MB";
          range "1..2047";
        }
      }

      // logging archive / archive-length
      leaf archive-length {
        tailf:info "The maximum no of weeks of log to maintain";
        type uint32 {
          tailf:info "<0-4294967295>;;Number of weeks";
        }
      }
    }

    // logging monitor
    leaf monitor {
      tailf:info "Set terminal line (monitor) logging parameters";
      tailf:cli-full-command;
      type severity-type;
    }

    // logging buffered
    container buffered {
      tailf:info "Set buffered logging parameters";

      leaf size {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<4096-2147483647>;;Logging buffer size";
          range "4096..2147483647";
        }
      }

      leaf type {
        tailf:cli-drop-node-name;
        type severity-type;
      }

      // logging buffered discriminator
      container discriminator {
        tailf:info "Set logging buffer discriminator";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-logging-buffered-discr";

        // logging buffered discriminator / nomatch1
        leaf nomatch1 {
          tailf:info "Set no-match discriminator 1";
          type string {
            tailf:info "WORD;;no-match discriminator 1";
          }
        }
      }
    }

    // logging facility
    leaf facility {
      tailf:info "Facility parameter for syslog messages";
      tailf:cli-full-command;
      type union {
        type enumeration {
          enum local0;
          enum local1;
          enum local2;
          enum local3;
          enum local4;
          enum local5;
          enum local6;
          enum local7;
        }
        type string {
          tailf:info "WORDD;logging facility param";
        }
      }
    }

    // logging * vrf *
    list host {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key "address vrf";
      leaf address {
        type union {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IPv4 address of the logging host";
          }
          type inet:ipv6-address {
            tailf:info "X:X::X;;IPv6 address of the logging host";
          }
        }
      }
      leaf vrf {
        tailf:info "Set VRF option";
        tailf:cli-expose-key-name;
        type string {
          tailf:info "WORD;;VPN Routing/Forwarding instance name";
        }
      }

      // logging host * severity
      leaf severity {
        tailf:info "Set severity of  messages for particular remote host/vrf";
        type severity-type;
      }

      // logging host * port
      leaf port {
        tailf:info "Set UDP port for this remote host/vrf";
        type union {
          type enumeration {
            enum "default" {
              tailf:info "default Port";
            }
          }
          type uint32 {
            tailf:info "<0-4294967295>;;non-default Port";
            range "0..4294967295";
          }
        }
      }
    }

    // logging localfilesize
    leaf localfilesize {
      tailf:info "Set size of the local log file";
      type uint32 {
        tailf:info "<0-4294967295>;;Size of the local log file";
      }
    }

    // logging source-interface
    container source-interface {
      tailf:info "Specify interface for source address in logging transactions";
      cisco-ios-xr:remove-before-change;
      uses interface-name-grouping;
    }

    // logging source-interface ? vrf *
    container source-interface-vrf {
      tailf:cli-drop-node-name;
      list source-interface {
        tailf:info "Specify interface for source address in logging transactions";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        key vrf;
        leaf vrf {
          tailf:info "Specify non-default VRF";
          tailf:cli-expose-key-name;
          tailf:cli-suppress-range;
          type string {
            tailf:info "WORD;;Non-default VRF of peer";
          }
        }
        leaf interface {
          tailf:cli-drop-node-name;
          tailf:cli-remove-before-change;
          tailf:cli-prefix-key;
          type string {
            tailf:info "WORD;;Interface Name";
          }
        }
      }
    }

    // logging cns-events
    container cns-events {
      tailf:info "Set CNS Event logging level";
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      presence true;
      leaf severity {
        type severity-type;
      }
    }

    // logging format rfc5424
    container format {
      tailf:info "Specify syslog message format send to the server";
      leaf rfc5424 {
        tailf:info "Enable to send the syslog message rfc5424 format";
        type empty;
      }
    }

    // logging console
    leaf console {
      tailf:info "Set console logging parameters";
      tailf:cli-full-command;
      type union {
        type severity-type;
        type enumeration {
          enum disable {
                        tailf:info "Disable logging";
                        value -1;
          }
        }
      }
    }

    // logging count
    leaf count {
      tailf:info "Count every log message and timestamp last occurance";
      tailf:cli-full-command;
      type empty;
    }

    // logging history
    leaf history {
      tailf:info "Set history logging";
      tailf:cli-full-command;
      tailf:cli-full-no;
      type severity-type;
    }

    // logging history size
    container history-conf {
      tailf:cli-drop-node-name;
      container history {
        tailf:info "Set history logging";
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        leaf size {
          tailf:info "Logging history size";
          type uint16 {
            tailf:info "<1-500>;;Logging history size";
            range "1..500";
          }
        }
      }
    }

    // logging suppress
    container suppress {
      tailf:info "Configure properties for the event suppression";

      // logging suppress duplicates
      leaf duplicates {
        tailf:info "Suppress consecutive duplicate messages";
        tailf:cli-full-command;
        type empty;
      }

      // logging suppress rule *
      list rule {
        tailf:info "Configure a specified suppression rule";
        tailf:cli-mode-name "config-suppr-rule";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Rule name";
          }
        }
        list alarm {
          tailf:info "Specify alarm: Category/Group/Code combos";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key "msg-category group-name msg-code";
          leaf msg-category {
            type string {
              tailf:info "WORD;;Message category of the suppressed message";
            }
          }
          leaf group-name {
            type string {
              tailf:info "WORD;;Group name of suppressed message";
            }
          }
          leaf msg-code {
            type string {
              tailf:info "WORD;;Message code of suppressed message";
            }
          }
        }
      }

      // logging suppress apply
      container apply {
        tailf:info "Apply suppression rule";

        // logging suppress apply rule *
        list rule {
          tailf:info "Apply suppression rule";
          tailf:cli-mode-name "config-suppr-apply-rule";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Rule name";
            }
            tailf:cli-suppress-leafref-in-diff;
            tailf:non-strict-leafref {
              path "/cisco-ios-xr:logging/suppress/rule/name";
            }
          }

          // logging suppress apply rule * / all-of-router
          leaf all-of-router {
            tailf:info "Apply the rule to all of the router";
            tailf:cli-full-command;
            type empty;
          }

          // logging suppress apply rule * / source location
          container source {
            tailf:info "Apply rule to specified source";
            leaf location {
              tailf:info "Apply rule to specified location";
              type string {
                tailf:info "WORD;;Fully qualified source specification";
              }
            }
          }
        }
      }
    }

    // logging correlator
    container correlator {
      tailf:info "Configure properties of the event correlator";

      // logging correlator rule
      container rule {
        tailf:info "Configure a specified correlation rule";

        // logging correlator rule * timeout
        list timeout-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-incomplete-command;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Rule name";
            }
          }
          leaf timeout {
            tailf:info "Specify timeout";
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "1-7200000>;;Timeout (time the rule is to be active) in milliseconds";
            }
          }
          leaf msg-category {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type string {
              tailf:info "WORD;;Message category of the root message";
            }
          }
          leaf group-name {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;Group name of root message";
            }
          }
        }

        // logging correlator rule *
        list list {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          tailf:cli-mode-name "config-corr-rule";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Rule name";
            }
          }
          leaf type {
            tailf:info "type of rule - stateful or nonstatefu";
            tailf:cli-hide-in-submode;
            tailf:cli-remove-before-change;
            type enumeration {
              enum nonstateful {
                tailf:info "non-stateful rule type";
              }
              enum stateful {
                tailf:info "stateful rule type";
              }
            }
          }

          // logging correlator rule * / timeout
          leaf timeout {
            tailf:info "Specify timeout";
            type uint32 {
              tailf:info "<1-7200000>;;Timeout (time the rule is to be active) in milliseconds";
              range "1..7200000";
            }
          }

          // logging correlator rule * / rootcause
          container rootcause {
            tailf:info "Specify root cause alarm: Category/Group/Code combos";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf msg-category {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type string {
                tailf:info "WORD  Message category of the root message";
              }
            }
            leaf group-name {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type string {
                tailf:info "WORD;;Group name of root message";
              }
            }
            leaf msg-code {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "WORD;;Message code of root message";
              }
            }
          }

          // logging correlator rule * / nonrootcause
          container nonrootcause {
            tailf:info "nonrootcause alarm";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-corr-rule-nonrc";

            // logging correlator rule * / nonrootcause / alarm *
            list alarm {
              tailf:info "Specify non-root cause alarm: Category/Group/Code combos";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key "msg-category group-name msg-code";
              leaf msg-category {
                type string {
                  tailf:info "WORD;;Message category of the correlated message";
                }
              }
              leaf group-name {
                type string {
                  tailf:info "WORD;;Group name of correlated message";
                }
              }
              leaf msg-code {
                type string {
                  tailf:info "WORD;;Message code of correlated message";
                }
              }
            }
          }

          // logging correlator rule * / timeout-rootcause
          leaf timeout-rootcause {
            tailf:info "Specify timeout for root-cause";
            type uint32 {
              tailf:info "<1-7200000>;;Rootcause Timeout (time to wait for rootcause) in milliseconds";
              range "1..7200000";
            }
          }
        }
      }

      // logging correlator rule * timeout
      container rule-timeout {
        tailf:cli-drop-node-name;
        list rule {
          tailf:info "Configure a specified correlation rule";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-incomplete-command;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Rule name";
            }
          }
          leaf timeout {
            tailf:info "Specify timeout";
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<1-7200000>;;Timeout (time the rule is to be active) in millisecond";
            }
          }
          leaf msg-category {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;Message category of the root message";
            }
          }
          leaf group-name {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;Group name of root message";
            }
          }
          leaf msg-code {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;Message code of root message";
            }
          }
        }
      }

      // logging correlator apply
      container apply {
        tailf:info "Apply rule or ruleset";

        // logging correlator apply rule *
        list rule {
          tailf:info "Apply rule";
          tailf:cli-mode-name "config-corr-apply-rule";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Rule name";
            }
          }

          // logging correlator apply rule * / all-of-router
          leaf all-of-router {
            tailf:info "Apply the rule to all of the router";
            type empty;
          }
        }
      }

      // logging correlator apply-rule *
      list apply-rule {
        tailf:info "Apply rule";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Rule name";
          }
        }
        leaf-list location {
          tailf:info "Apply rule to specified location(s)";
          tailf:cli-flat-list-syntax;
          tailf:cli-replace-all;
          type string {
            tailf:info "WORD;;Fully qualified location specification";
          }
        }
      }

      // logging correlator buffer-size
      leaf buffer-size {
        tailf:info "Configure size of the correlator buffer";
        type uint32 {
          tailf:info "<1024-52428800>;;Size of the correlator buffer";
          range "1024..52428800";
        }
      }
    }

    // logging hostnameprefix
    leaf hostnameprefix {
      tailf:info "Hostname prefix to add on msgs to servers";
      tailf:cli-full-command;
      type string {
        tailf:info "WORD;;hostname prefix string";
      }
    }
  }


  /// ========================================================================
  /// service
  /// ========================================================================

  container service {
    tailf:info "Modify use of network based services";
    tailf:cli-explicit-exit;

    // service alignment
    container alignment {
      tailf:info "Control alignment correction and logging";

      // service alignment detection
      leaf detection {
        tailf:info "Enable detection of alignment issues";
        type empty;
      }

      // service alignment logging
      leaf logging {
        tailf:info "Enable logging of alignment issues";
        type empty;
      }
    }

    // service call-home
    leaf call-home {
      tailf:info "Enable call-home service";
      tailf:cli-full-command;
      type empty;
    }

    // service compress-config
    leaf compress-config {
      tailf:info "Compress the nvram configuration file";
      tailf:cli-full-command;
      type empty;
    }

    // service counters max age
    container counters {
      tailf:info "Control aging of interface counters";
      container max {
        tailf:info "Maximum counter aging threshold";
        leaf age {
          tailf:info "Aging threshold";
          type uint8 {
            tailf:info "<0-60>;;Aging threshold value in seconds";
          }
        }
      }
    }

    // service dhcp
    leaf dhcp {
      tailf:info "Enable DHCP server and relay agent";
      type empty;
    }

    // service disable-ip-fast-frag
    leaf disable-ip-fast-frag {
      tailf:info "Disable IP particle-based fast fragmentation";
      type empty;
    }

    // service exec-callback
    leaf exec-callback {
      tailf:info "Enable exec callback";
      type empty;
    }

    // service exec-wait
    leaf exec-wait {
      tailf:info "Delay EXEC startup on noisy lines";
      type empty;
    }

    // service finger
    leaf finger {
      tailf:info "Allow responses to finger requests";
      type empty;
    }

    // service heartbeat
    container heartbeat {
      tailf:info "Enable heartbeat processing";
      leaf fatal-count {
        tailf:info "Set heartbeat fatal count";
        type uint8 {
          range "1..60";
          tailf:info "<1-60>;;Number of timeouts until fatal error occurs";
        }
      }
      leaf interrupt-interval {
        tailf:info "Set heartbeat interrupt test interval";
        type uint8 {
          range "0..60";
          tailf:info "<0-60>;;Interval between interrupt level tests";
        }
      }
      leaf interrupt-max {
        tailf:info "Set maximum message count from interrupt test";
        type uint8 {
          tailf:info "<0-60>;;Maximum number of messages from interrupt test";
          range "0..60";
        }
      }
      leaf transmit-interval {
        tailf:info "Set heartbeat transmit interval";
        type uint8 {
          tailf:info "<1-30>;;Interval between heartbeat transmissions";
          range "1..30";
        }
      }
      leaf warning-timeout {
        tailf:info "Set heartbeat warning timeout interval";
        type uint8 {
          tailf:info "<5-60>;;Interval between heartbeat timeout warnings";
          range "5..60";
        }
      }
    }

    // service hide-telnet-addresses
    leaf hide-telnet-addresses {
      tailf:info "Hide destination addresses in telnet command";
      type empty;
    }

    // service ipv4
    container ipv4 {
      tailf:info "Ipv4 small servers";
      // service ipv4 tcp-small-servers
      uses tcp-small-servers-grouping;
      // service ipv4 udp-small-servers
      uses udp-small-servers-grouping;
    }

    // service ipv6
    container ipv6 {
      tailf:info "ipv6 small servers";
      // service ipv6 tcp-small-servers
      uses tcp-small-servers-grouping;
      // service ipv6 udp-small-servers
      uses udp-small-servers-grouping;
    }

    // service linenumber
    leaf linenumber {
      tailf:info "enable line number banner for each exec";
      type empty;
    }

    // service nagle
    leaf nagle {
      tailf:info "Enable Nagle's congestion control algorithm";
      type empty;
    }

    // service old-slip-prompts
    leaf old-slip-prompts {
      tailf:info "Allow old scripts to operate with slip/ppp";
      type empty;
    }

    // service pad
    container pad {
      tailf:info "Enable PAD commands";
      presence true;
      leaf cmns {
        tailf:info "Enable PAD over CMNS connections";
        type empty;
      }
      leaf from-xot {
        tailf:info "Accept XOT to PAD connections";
        type empty;
      }
      leaf to-xot {
        tailf:info "Allow outgoing PAD over XOT connections";
        type empty;
      }
    }

    // service password-encryption
    leaf password-encryption {
      tailf:info "Encrypt system passwords";
      type empty;
    }

    // service prompt config
    container prompt {
      tailf:info "Enable mode specific prompt";
      leaf config {
        tailf:info "Enable configuration mode prompt";
        type empty;
      }
    }

    // service pt-vty-logging
    leaf pt-vty-logging {
      tailf:info "Log significant VTY-Async events";
      type empty;
    }

    // service sequence-numbers
    leaf sequence-numbers {
      tailf:info "Stamp logger messages with a sequence number";
      type empty;
    }

    // service slave-log
    leaf slave-log {
      tailf:info "Enable log capability of slave IPs";
      type empty;
    }

    // service tcp-keepalives-in
    leaf tcp-keepalives-in {
      tailf:info "Generate keepalives on idle incoming network connections";
      type empty;
    }

    // service tcp-keepalives-out
    leaf tcp-keepalives-out {
      tailf:info "Generate keepalives on idle outgoing network connections";
      type empty;
    }

    // service tcp-small-servers
    container tcp-small-servers {
      tailf:info "Enable small TCP servers (e.g., ECHO)";
      presence true;
      leaf max-servers {
        tailf:info "Set number of allowable TCP small servers";
        type union {
          type uint32 {
            tailf:info "<1-2147483647>;;Maximum TCP small servers";
            range "1..2147483647";
          }
          type enumeration {
            enum "no-limit" {
              tailf:info "No limit to number of allowable TCP small servers";
            }
          }
        }
      }
    }

    // service telnet-zeroidle
    leaf telnet-zeroidle {
      tailf:info "Set TCP window 0 when connection is idle";
      type empty;
    }

    // service timestamps
    container timestamps {
      tailf:info "Timestamp debug/log messages";
      tailf:cli-compact-syntax;
      tailf:cli-delete-when-empty;
      presence true;

      // service timestamps debug
      container debug {
        tailf:info "Timestamp debug messages";
        choice log-time-choice {
          container datetime {
            tailf:info "Timestamp with date and time";
            tailf:cli-compact-syntax;
            tailf:cli-reset-container;
            tailf:cli-delete-when-empty;
            presence true;
            leaf localtime {
              tailf:info "Use local time zone for timestamps";
              type empty;
            }
            leaf msec {
              tailf:info "Include milliseconds in timestamp";
              type empty;
            }
            leaf show-timezone {
              tailf:info "Add time zone information to timestamp";
              type empty;
            }
            leaf year {
              tailf:info "Include year in timestamp";
              type empty;
            }
          }
          leaf uptime {
            tailf:info "Timestamp with system uptime";
            type empty;
          }
        }
      }

      // service timestamps log
      container log {
        tailf:info "Timestamp log messages";

        // service timestamps log uptime
        leaf uptime {
          tailf:info "Timestamp with system uptime";
          type empty;
        }

        // service timestamps log datetime
        container datetime {
          tailf:info "Timestamp with date and time";
          tailf:cli-compact-syntax;
          tailf:cli-delete-when-empty;
          tailf:cli-reset-container;
          presence true;
          leaf localtime {
            tailf:info "Use local time zone for timestamps";
            type empty;
          }
          leaf msec {
            tailf:info "Include milliseconds in timestamp";
            type empty;
          }
          leaf show-timezone {
            tailf:info "Add time zone information to timestamp";
            type empty;
          }
          leaf year {
            tailf:info "Include year in timestamp";
            type empty;
          }
        }
      }
    }

    // service udp-small-servers
    container udp-small-servers {
      tailf:info "Enable small UDP servers (e.g., ECHO)";
      presence true;
      leaf max-servers {
        tailf:info "Set number of allowable UDP small servers";
        type union {
          type uint32 {
            tailf:info "<1-2147483647>;;Maximum UDP small servers";
            range "1..2147483647";
          }
        }
      }
    }

    // service unsupported-transceiver
    leaf unsupported-transceiver {
      tailf:cli-full-command;
      type empty;
    }

    // service cli
    container cli {
      tailf:info "cli configuration services";

      // service cli configuration disable usergroup
      container configuration {
        tailf:info "allowing to configuration submode";
        container disable {
          tailf:info "disable for read-only access users";
          leaf usergroup {
            tailf:info "Disable config mode for usergroup";
            type string {
              tailf:info "WORD;;Usergroup name";
            }
          }
        }
      }

      // service cli history size
      container history {
        tailf:info "cli commands history";
        leaf size {
          tailf:info "maximum number of commands in history";
          type uint16 {
            tailf:info "<1000-5000>;;maximum number of entries";
            range "1000..5000";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// event
  /// ========================================================================

  container event {
    tailf:info "Event related commands";
    tailf:cli-explicit-exit;

    // event manager
    container manager {
      tailf:info "Event Manager configuration commands";

      // event manager directory user
      container directory {
        tailf:info "Set Embedded Event Manager directory information";
        container user {
          tailf:info "Set Embedded Event Manager user directory information";

          // event manager directory user policy
          leaf policy {
            tailf:info "Set Embedded Event Manager user policy directory";
            type string {
              tailf:info "WORD;;Path of the Embedded Event Manager user policy directory";
            }
          }

          // event manager directory library
          leaf library {
            tailf:info "Set Embedded Event Manager user library directory";
            type string {
              tailf:info "WORD;;Path of the Embedded Event Manager user library directory";
            }
          }
        }
      }

      // event manager refresh-time
      leaf refresh-time {
        tailf:info "Set refresh time (in seconds) for policy username's AAA taskmap";
        type uint32 {
          tailf:info "<10-4294967295>;;A valid positive integer greater than 9";
          range "10..4294967295";
        }
      }

      // event manager policy *
      list policy {
        tailf:info "Register an Event Manager policy";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of the policy file";
          }
        }
        // event manager policy * username
        leaf username {
          tailf:info "Username under whom this policy will execute";
          type string {
            tailf:info "WORD;;A Configured username";
          }
        }

        // event manager policy * persist-time
        leaf persist-time {
          tailf:cli-break-sequence-commands;
          tailf:info "Time of validity (in seconds) for cached AAA taskmap of username (default is 3600)";
          type union {
            type enumeration {
              enum infinite {
                             tailf:info "Cached AAA taskmap of username is always treated valid";
              }
            }
            type uint32 {
              tailf:info "<0-4294967294>;;Integer value for this policy's persist-time";
            }
          }
        }

        // event manager policy * type
        leaf type {
          tailf:info "The Event Manager type of this policy";
          type enumeration {
            enum system {
                         tailf:info "Event Manager system policy";
            }
            enum user {
                       tailf:info "Event Manager user policy";
            }
          }
        }
      }

      // event manager environment *
      list environment {
        tailf:info "Set an Embedded Event Manager global variable for policies";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of the global variable";
          }
        }
        leaf var-value {
          tailf:cli-drop-node-name;
          tailf:cli-multi-value;
          type string {
            tailf:info "LINE;;Value of the global variable";
          }
        }
      }

      // event manager scheduler
      container scheduler {
        tailf:info "Set Embedded Event Manager scheduler options";
        leaf suspend {
          tailf:info "Suspend Embedded Event Manager policy scheduling";
          type empty;
        }
      }

    }
  }


  /// ========================================================================
  /// domain
  /// ========================================================================

  container domain {
    tailf:info "Domain service related commands";
    tailf:cli-explicit-exit;

    // domain ipv4 host *
    container ipv4 {
      tailf:info "Ipv4 hosts";
      list host {
        tailf:info "Add an entry to the ip hostname table";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key host-name;
        leaf host-name {
          type string {
            tailf:info "WORD;;Name of host";
          }
        }
        leaf-list address {
          tailf:cli-drop-node-name;
          tailf:cli-flat-list-syntax;
          ordered-by user;
          max-elements 8;
          type string {
            tailf:info "A.B.C.D;;Host IP address (maximum of 8";
          }
        }
      }
    }

    // domain ipv6 host *
    container ipv6 {
      tailf:info "Ipv6 hosts";
      list host {
        tailf:info "Add an entry to the ipv6 hostname table";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key host-name;
        leaf host-name {
          type string {
            tailf:info "WORD;;Name of host";
          }
        }
        leaf-list address {
          tailf:cli-drop-node-name;
          tailf:cli-flat-list-syntax;
          ordered-by user;
          max-elements 4;
          type string {
            tailf:info "X:X::X;;IPv6 name or address (maximum four addresses";
          }
        }
      }
    }

    // domain lookup
    container lookup {
      tailf:info "Enable Domain Name System hostname translation";

      // domain lookup disable
      leaf disable {
        tailf:info "Disable Domain Name System hostname translation";
        tailf:cli-full-command;
        type empty;
      }

      // domain lookup source-interface
      container source-interface {
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        uses interface-name-grouping;
      }
    }

    // domain name
    leaf name {
      tailf:info "Define the default domain name";
      type string {
        tailf:info "WORD;;Default domain name";
      }
    }

    // domain list *
    leaf-list list {
      tailf:info "Domain name to complete unqualified host names";
      tailf:cli-list-syntax;
      tailf:cli-remove-before-change;
      //cisco-ios-xr:nso-patch-leaf-list-delete;
      ordered-by user;
      type string {
        tailf:info "WORD;;A domain name";
      }
    }

    // domain name-server *
    list name-server {
      tailf:info "Specify address of name server to use";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-show-long-obu-diffs;
      ordered-by user;
      key address;
      leaf address {
        type inet:host {
          tailf:info "A.B.C.D or X:X::X;;Domain server address";
        }
      }
    }

    // domain vrf *
    list vrf {
      tailf:info "VRF name for domain services";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key id;
      leaf id {
        tailf:info "VRF name";
        type string {
          tailf:info "WORD;;VRF name";
        }
      }

      // domain vrf * name
      leaf name {
        tailf:info "Define the default domain name";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;Default domain name";
        }
      }

      // domain vrf * list *
      leaf-list list {
        tailf:info "Domain name to complete unqualified host names";
        tailf:cli-list-syntax;
        tailf:cli-remove-before-change;
        ordered-by user;
        type string {
          tailf:info "WORD;;A domain name";
        }
      }

      // domain vrf * name-server *
      list name-server {
        tailf:info "Specify address of name server to use";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-show-long-obu-diffs;
        ordered-by user;
        key address;
        leaf address {
          type inet:host {
            tailf:info "A.B.C.D or X:X::X;;Domain server address";
          }
        }
      }

      // domain vrf * lookup
      container lookup {
        tailf:info "Enable Domain Name System hostname translation";

        // domain vrf * lookup disable
        leaf disable {
          tailf:info "Disable Domain Name System hostname translation";
          type empty;
        }

        // domain vrf * lookup source-interface
        container source-interface {
          tailf:info "Specify source interface for DNS resolver";
          uses interface-name-grouping;
        }
      }

      // domain vrf * ipv4
      container ipv4 {
        tailf:info "ipv4 hosts";

        // domain vrf * ipv4 host *
        list host {
          tailf:info "Add an entry to the ip hostname table";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;

          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Name of host";
            }
          }
          leaf-list address {
            tailf:cli-drop-node-name;
            tailf:cli-flat-list-syntax;
            ordered-by user;
            max-elements 8;
            type string {
              tailf:info "A.B.C.D;;Host IP address (maximum of 8)";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// forward-protocol
  /// ========================================================================

  // forward-protocol udp *
  container forward-protocol {
    tailf:info "Controls forwarding of physical and directed IP broadcasts";

    container udp {
      tailf:info "Packets to a specific UDP port";
      list port-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key port;
        leaf port {
          type union {
            type uint16 {
              tailf:info "<1-65535>;;Port number";
              range "1..65535";
            }
            type enumeration {
              enum domain {
                           tailf:info "Domain Name Service (DNS, 53)";
                           value 53;
              }
              enum nameserver {
                               tailf:info "IEN116 name service (obsolete, 42)";
                               value 42;
              }
              enum netbios-dgm {
                tailf:info "NetBios datagram service (138)";
                value 138;
              }
              enum netbios-ns {
                tailf:info "NetBios name service (137)";
                value 137;
              }
              enum tacacs {
                           tailf:info "TAC Access Control System (49)";
                           value 49;
              }
              enum tftp {
                         tailf:info "Trivial File Transfer Protocol (69)";
                         value 69;
              }
            }
          }
        }
        leaf disable {
          tailf:info "Disable IP Forward Protocol UDP for a specific port";
          type empty;
        }
      }
    }
  }


  /// ========================================================================
  /// taskgroup
  /// ========================================================================

  list taskgroup {
    tailf:info "Configure task group";
    tailf:cli-mode-name "config-tg";
    tailf:cli-explicit-exit;
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;Taskgroup name";
      }
    }

    // taskgroup * / task
    container task {
      tailf:info "Specify a task ID to be part of this group";

      // taskgroup * / task execute *
      list execute {
        tailf:info "Specify a execute-type task ID";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type task-type;
        }
      }

      // taskgroup * / task read *
      list read {
        tailf:info "Specify a read-type task ID";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type task-type;
        }
      }

      // taskgroup * / task write *
      list write {
        tailf:info "Specify a write-type task ID";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type task-type;
        }
      }

      // taskgroup * / task debug *
      list debug {
        tailf:info "Specify a debug-type task ID";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type task-type;
        }
      }
    }

    // taskgroup * / inherit
    container inherit {
      tailf:info "Inherit to include into this taskgroup";
      list taskgroup {
        tailf:info "Specify a taskgroup to inherit from";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of the task group to include";
          }
        }
      }
    }
    // taskgroup * / description
    leaf description {
      tailf:cli-multi-value;
      tailf:cli-preformatted;
      tailf:cli-full-command;
      type string {
        tailf:info "WORD;;description";
      }
    }
  }


  /// ========================================================================
  /// diameter
  /// ========================================================================

  container diameter {
    tailf:info "DIAMETER server definition";
    tailf:cli-explicit-exit;

    // diameter origin
    container origin {
      tailf:info "Origin sub commands";

      // diameter origin host
      leaf host {
        tailf:info "host information";
        type string {
          tailf:info "WORD;;Host name in FQDN format";
        }
      }

      // diameter realm
      leaf realm {
        tailf:info "Realm information";
        type string {
          tailf:info "WORD;;Origin realm string";
        }
      }
    }

    // diameter gx
    leaf gx {
      tailf:info "Start diameter policy-if";
      tailf:cli-full-command;
      type empty;
    }

    // diameter gy
    leaf gy {
      tailf:info "Start diameter prepaid service";
      tailf:cli-full-command;
      type empty;
    }


    // diameter source-interface
    container source-interface {
      tailf:info "Specify interface for source address in DIAMETER packets";
      uses interface-name-grouping;
    }

    // diameter timer
    container timer {
      tailf:info "Timers used for the peer";

      // diameter timer watchdog 300
      leaf watchdog {
        tailf:info "Watchdog timer";
        type uint16 {
          tailf:info "<6-1000>;;Timer value in seconds";
          range "6..1000";
        }
      }
    }


    // diameter gx X
    container gx-conf {
      tailf:cli-drop-node-name;
      container gx {
        tailf:info "Start diameter policy-if";
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;

        // diameter gx tx-timer
        leaf tx-timer {
          tailf:info "Set transaction timer";
          type uint16 {
            tailf:info "<6-1000>;;Timer value in seconds";
          }
        }

        // diameter gx retransmit
        leaf retransmit {
          tailf:info "Set retransmit count";
          type uint8 {
            tailf:info "<1-10>;;Timer value in seconds";
            range "1..10";
          }
        }
      }
    }

    // diameter vendor supported
    container vendor {
      tailf:info "Vendor specific";
      container supported {
        tailf:info "Supported vendors";
        leaf threegpp {
          tailf:info "3GPP attribute support";
          type empty;
        }
        leaf cisco {
          tailf:info "Cisco attribute support";
          type empty;
        }
        leaf vodafone {
          tailf:info "Vodafone attribute support";
          type empty;
        }
        leaf etsi {
          tailf:info "Etsi attribute support";
          type empty;
        }
      }
    }

    // diameter peer *
    list peer {
      tailf:info "Peer configuration";
      tailf:cli-mode-name "config-dia-peer";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Name for the diameter peer configuration";
        }
      }

      // diameter peer * / destination
      container destination {
        tailf:info "Peer information";

        // diameter peer * / destination host
        leaf host {
          tailf:info "host information";
          type string {
            tailf:info "WORD;;Host name in FQDN format";
          }
        }

        // diameter peer * / destination realm
        leaf realm {
          tailf:info "realm information";
          type string {
            tailf:info "WORD;;Realm to which the peer belongs to";
          }
        }
      }

      // diameter peer * / transport tcp
      container transport {
        tailf:info "Specify a Diameter transport";

        // diameter peer * / transport tcp port
        container tcp {
          tailf:info "Specify a Diameter transport protocol";
          leaf port {
            tailf:info "Port number on which the peer is running(default is 3868)";
            type uint16 {
              tailf:info "<1-65535>;;Port number";
              range "1..65535";
            }
          }
        }
      }

      // diameter peer * / address
      container address {
        tailf:info "Specify a Diameter peer address";

        // diameter peer * / address ipv4
        leaf ipv4 {
          tailf:info "IPv4 Address";
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IPv4 address of diameter server";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// radius
  /// ========================================================================

  container radius {
    tailf:info "RADIUS configuration commands";
    tailf:cli-explicit-exit;

    // radius source-interface
    container source-interface {
      tailf:info "Specify interface for source address in RADIUS packets";
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      uses interface-name-grouping;
      leaf vrf {
        tailf:info "VRF for this source interface configuration";
        type string {
          tailf:info "WORD;;Name of the VRF";
        }
      }
    }
  }


  /// ========================================================================
  /// radius-server
  /// ========================================================================

  container radius-server {
    tailf:info "RADIUS server definition";
    tailf:cli-explicit-exit;

    // radius-server vsa attribute ignore unknown
    container vsa {
      tailf:info "unknown vsa ignore configuration for RADIUS server";
      container attribute {
        tailf:info "Vendor Specific Attribute";
        container ignore {
          tailf:info "ignore the VSA";
          leaf unknown {
            tailf:info "ignore the VSA and no prefix will reject the unkown VSA";
            type empty;
          }
        }
      }
    }

    // radius-server host *
    list host {
      tailf:info "Specify a RADIUS server";
      tailf:cli-mode-name "config-radius-host";
      key id;
      leaf id {
        type inet:host {
          tailf:info "Hostname or A.B.C.D;;IP address of RADIUS server";
        }
      }
      // radius-server host * auth-port
      leaf auth-port {
        tailf:info "UDP port for RADIUS authentication server (default is 1645)";
        tailf:cli-hide-in-submode;
        type uint16 {
          tailf:info "<0-65535>;;Authentication port number";
          range "0..65535";
        }
      }

      // radius-server host * acct-port
      leaf acct-port {
        tailf:info "UDP port for RADIUS accounting server (default is 1646)";
        tailf:cli-hide-in-submode;
        type uint16 {
          tailf:info "<0-65535>;;Accounting port number";
          range "0..65535";
        }
      }

      // radius-server host * / key
      container key {
        tailf:info "per-server encryption key (overrides default)";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        uses key-grouping {
          refine "key" {
            cli:secret " key <SECRET>";
          }
        }
      }

      // radius-server host * / timeout
      leaf timeout {
        tailf:info "Time to wait for this RADIUS server to reply (overrides global timeout)";
        type uint16 {
          tailf:info "<1-1000>;;Timeout value in seconds to wait for server to reply";
          range "1..1000";
        }
      }

      // radius-server host * / retransmit
      leaf retransmit {
        tailf:info "Number of times a RADIUS request is re-sent to a server (overrides global retransmit value)";
        type uint8 {
          tailf:info "<1-100>;;Retransmit value";
        }
      }
    }

    // radius-server ipv4 dscp
    container ipv4 {
      tailf:info "Mark the dscp bit for ipv4 packets";
      leaf dscp {
        tailf:info "Set IP DSCP (DiffServ CodePoint)";
        type dscp-type;
      }
    }

    // radius-server ipv6 dscp
    container ipv6 {
      tailf:info "Mark the dscp bit for ipv6 packets";
      leaf dscp {
        tailf:info "Set IP DSCP (DiffServ CodePoint)";
        type dscp-type;
      }
    }

    // radius-server key
    container key {
      tailf:info "Set RADIUS encryption key";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      uses key-grouping {
        refine "key" {
          cli:secret " key <SECRET>";
        }
      }
    }

    // radius-server timeout
    leaf timeout {
      tailf:info "Time to wait for a RADIUS server to reply (default 5)";
      type uint16 {
        tailf:info "<1-1000>;;Timeout value in seconds to wait for server to reply";
        range "1..1000";
      }
    }

    // radius-server deadtime
    leaf deadtime {
      tailf:info "Time in minutes for which a RADIUS server will be marked dead";
      type uint16 {
        tailf:info "<1-1440>;;Deadtime limit in minutes (default 0)";
        range "1..1440";
      }
    }

    // radius-server disallow null-username
    container disallow {
      tailf:info "disallow null-username";
      leaf null-username {
        tailf:info "null-username";
        type empty;
      }
    }

    // radius-server throttle
    container throttle {
      tailf:info "Radius throttling options.";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-full-no;
      leaf access {
        tailf:info "To flow control the number of access requests sent to a radius server";
        tailf:cli-incomplete-command;
        tailf:cli-delete-container-on-delete;
        type uint16 {
          tailf:info "<0-65535>;;Number of outstanding access requests after which throttling"
            +" should be performed (Preferable value 100)";
        }
      }
      leaf access-timeout {
        tailf:info "Specify the number of timeouts exceeding which a throttled access request is dropped";
        tailf:cli-incomplete-command;
        tailf:cli-delete-container-on-delete;
        type uint8 {
          tailf:info "<1-10>;;Number of timeouts for a transaction (default is 3)";
        }
      }
      leaf accounting {
        tailf:info "To flow control the number of accounting requests sent to a radius server.";
        tailf:cli-delete-container-on-delete;
        type uint16 {
          tailf:info "<0-65535>;;Number of outstanding accounting transactions after"
            +" which throttling should be performed (Preferable value 100)";
        }
      }
    }

    // radius-server load-balance method least-outstanding
    container load-balance {
      tailf:info "Radius load-balancing options.";
      container method {
        tailf:info "Method by which the next host will be picked.";
        container least-outstanding {
          tailf:info "Pick the server with the least transactions outstanding.";
          tailf:cli-compact-syntax;
          leaf batch-size {
            tailf:info "Batch size for selection of the server.";
            type uint16 {
              tailf:info "<1-1500>;;Batch size for selection of the server (default 25)";
              range "1..1500";
            }
          }
          leaf ignore-preferred-server {
            tailf:info "Disable preferred server for this Server Group";
            type empty;
          }
        }
      }
    }

    // radius-server retransmit
    leaf retransmit {
      tailf:info "Specify the number of retries to active server";
      type union {
        type uint8 {
          tailf:info "<1-100>;;Number of retries for a transaction (default is 3)";
        }
        type enumeration {
          enum disable {
                        tailf:info "Disable Radius server retransmit";
          }
        }
      }
    }

    // radius-server attribute
    container attribute {
      tailf:info "Customize selected radius attributes";

      // radius-server attribute list *
      list list {
        tailf:info "List of Attribute Types";
        tailf:cli-mode-name "config-attribute-filter";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;List name";
          }
        }

        // radius-server attribute list * / attribute
        container attribute {
          tailf:info "Specify a list of RADIUS attributes";

          // radius-server attribute list * / attribute vendor-id *
          list vendor-id {
            tailf:info "vendor-id";
            tailf:cli-mode-name "config-attribute-filter-vsa";
            key id;
            leaf id {
              type uint32 {
                tailf:info "<0-4294967295>;;vendor-id";
              }
            }
          }

          // radius-server attribute list * / attribute ?
          leaf list {
            tailf:cli-drop-node-name;
            tailf:cli-disallow-value "vendor-id";
            type string {
              tailf:info "WORD;;Comma-delimited list of RADIUS attributes";
            }
          }
        }
      }
    }

    // radius-server source-port extended
    container source-port {
      tailf:info "Source-Port";
      leaf extended {
        tailf:info "Extended";
        type empty;
      }
    }

    // radius-server dead-criteria
    container dead-criteria {
      tailf:info "Dead server detection criteria for a configured RADIUS server";

      // radius-server dead-criteria time
      leaf time {
        tailf:info "Minimum time that must elapse since a response was received from this RADIUS server";
        type uint8 {
          tailf:info "<1-120>;;Time in seconds";
          range "1..120";
        }
      }

      // radius-server dead-criteria tries
      leaf tries {
        tailf:info "The minimum number of transmissions (original attempts plus retransmits) to this RADIUS server";
        type uint8 {
          tailf:info "<1-100>;;Number of tries";
          range "1..100";
        }
      }
    }
  }


  /// ========================================================================
  /// usergroup
  /// ========================================================================

  list usergroup {
    tailf:info "Configure user group";
    tailf:cli-mode-name "config-ug";
    tailf:cli-explicit-exit;
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;Usergroup name";
      }
    }

    // usergroup * / taskgroup
    leaf-list taskgroup {
      tailf:info "Task group associated with this group";
      tailf:cli-list-syntax;
      type string {
        tailf:info "WORD;;Name of the task group";
      }
    }

    // usergroup * / description
    leaf description {
      tailf:info "Description for the user group";
      tailf:cli-multi-value;
      tailf:cli-preformatted;
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;Description for this group";
      }
    }
  }


  /// ========================================================================
  /// http
  /// ========================================================================

  container http {
    tailf:info "Service for http server";

    // http client
    container client {
      tailf:info "HTTP Client Application";

      // http client source-interface ipv4|ipv6
      container source-interface {
        tailf:info "Specify interface for source address";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf af {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type enumeration {
            enum ipv4 {
                       tailf:info "Choose Ipv4 address from interface";
            }
            enum ipv6 {
                       tailf:info "Choose Ipv6 address from interface";
            }
          }
        }
        uses interface-name-grouping;
      }

      // http client vrf
      leaf vrf {
        tailf:info "Name of vrf";
        type string {
          tailf:info "WORD;;Name of vrf";
        }
      }
    }

    // http server
    container server {
      tailf:info "To enable http server";
      tailf:cli-delete-when-empty;
      tailf:cli-reset-container;
      presence true;
      leaf ssl {
        tailf:info "To run http server over a secure socket";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// netconf
  /// ========================================================================

  container xnetconf {
    tailf:info "NETCONF configuration commands";
    tailf:alt-name netconf;
    tailf:cli-explicit-exit;

    // netconf agent
    container agent {
      tailf:info "NETCONF agent configuration commands";

      // netconf agent tty
      container tty {
        tailf:info "Enable NETCONF agent over TTY";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-netconf-tty";
        presence true;

        // netconf agent tty / session timeout
        container session {
          tailf:info "Session timeout for transport agents";
          leaf timeout {
            tailf:info "Session timeout for agents";
            type uint16 {
              tailf:info "<1-1440>;;Timeout in minutes";
              range "1..1440";
            }
          }
        }

        // netconf agent tty / throttle
        container throttle {
          tailf:info "Configuration for throttling NETCONF agent";

          // netconf agent tty / throttle memory
          leaf memory {
            tailf:info "Memory usage";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<100-600>;;Size of the memory usage in Mbytes per session (default 300 Mbytes)";
              range "100..600";
            }
          }

          // netconf agent tty / throttle process-rate
          leaf process-rate {
            tailf:info "Process rate";
            type uint16 {
              tailf:info "<1000-30000>;;Number of tags to process per sec";
              range "1000..30000";
            }
          }
        }
      }

      // netconf agent ssh
      leaf ssh {
        tailf:info "Enable NETCONF agent over SSH connection";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// network-controller
  /// ========================================================================

  container network-controller {
    tailf:info "Configure Network Controller Functionality";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-net-ctrl";
    tailf:cli-explicit-exit;
    presence true;

    // network-controller / anycast-gateway
    container anycast-gateway {
      tailf:info "Anycast-gateway configuration";

      // network-controller / anycast-gateway mac
      leaf mac {
        tailf:info "MAC address of gateway";
        type string {
          tailf:info "H.H.H;;VSWitch MAC Address";
        }
      }
    }

    // network-controller / standby
    leaf standby {
      tailf:info "Set this network-controller in standby mode";
      tailf:cli-full-command;
      type empty;
    }

    // network-controller / dhcp-server
    leaf dhcp-server {
      tailf:info "Set the DHCP Server Address for this network-controller domain";
      tailf:cli-full-command;
      type inet:ipv4-address {
        tailf:info "A.B.C.D;;DHCP Server IP Address";
      }
    }

    // network-controller / switch *
    list switch {
      tailf:info "Switch to configure";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key "mac ip-address";
      leaf mac {
        tailf:info "MAC address of Switch";
        tailf:cli-expose-key-name;
        type string {
          tailf:info "H.H.H;;VSWitch MAC Address";
        }
      }
      leaf ip-address {
        tailf:info "VSwitch Nexthop Address";
        tailf:cli-expose-key-name;
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Switch IP Address";
        }
      }
    }
  }


  /// ========================================================================
  /// netconf-yang
  /// ========================================================================

  container netconf-yang {
    tailf:info "NETCONF YANG configuration commands";
    tailf:cli-explicit-exit;

    // netconf-yang agent
    container agent {
      tailf:info "NETCONF YANG agent configuration commands";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-ncy-agent";
      presence true;

      // netconf-yang agent / ssh
      leaf ssh {
        tailf:info "Enable NETCONF-YANG agent over SSH connection";
        type empty;
      }

      // netconf-yang agent / exclude-item
      container exclude-item {
        tailf:info "Negate a command or set its defaults";

        // netconf-yang agent / exclude-item ssh
        leaf ssh {
          tailf:info "Enable NETCONF-YANG agent over SSH connection";
          type empty;
        }

        // netconf-yang agent / exclude-item yfw idle-timeout
        container yfw {
          tailf:info "YANG Framework settings";
          container idle-timeout {
            tailf:info "Timeout after which not needed YANG models are released from memory";
            presence true;
          }
        }
      }

      // netconf-yang agent / yfw idle-timeout
      container yfw {
        tailf:info "YANG Framework settings";
        leaf idle-timeout {
          tailf:info "Timeout after which not needed YANG models are released from memory";
          type uint32 {
            tailf:info "<1-4294967295>;;Idle timeout (in seconds)";
            range "1..4294967295";
          }
        }
      }

      // netconf-yang agent / session
      container session {
        tailf:info "Session settings";

        // netconf-yang agent / session limit
        leaf limit {
          tailf:info "Maximum count of concurrent sessions (default = 50)";
          type uint8 {
            tailf:info "<1-50>;;Count of allowable concurrent netconf-yang sessions (default = 50)";
            range "1..50";
          }
        }

        // netconf-yang agent / session idle-timeout
        leaf idle-timeout {
          tailf:info "Non-active session lifetime";
          type uint16 {
            tailf:info "<1-1440>;;Idle timeout in minutes";
            range "1..1440";
          }
        }

        // netconf-yang agent / session absolute-timeout
        leaf absolute-timeout {
          tailf:info "Absolute session lifetime";
          type uint16 {
            tailf:info "<1-1440>;;Absolute timeout in minutes";
            range "1..1440";
          }
        }
      }

      // netconf-yang agent / rate-limit
      leaf rate-limit {
        tailf:info "Rate limit";
        type uint32 {
          tailf:info "<4096-4294967295>;;Number of bytes to process per sec";
          range "4096..4294967295";
        }
      }
    }
  }


  /// ========================================================================
  /// nsr
  /// ========================================================================

  container nsr {
    tailf:info "Global NSR configuration commands";
    tailf:cli-explicit-exit;

    leaf process-failures {
      tailf:info "Recovery action for Process failures on active RP/DRP";
      type enumeration {
        enum switchover {
                         tailf:info "Switch over to standby RP/DRP to maintain NSR";
        }
      }
    }
  }


  /// ========================================================================
  /// ftp
  /// ========================================================================

  container ftp {
    tailf:info "Global FTP configuration commands";
    tailf:cli-explicit-exit;

    container client {
      tailf:info "FTP client configuration commands";

      // ftp client passive
      leaf passive {
        tailf:info "Connect using passive mode";
        type empty;
      }

      // ftp client password
      container password {
        tailf:info "Specify password for ftp connection";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        uses password-grouping {
          refine "secret" {
            cli:secret " password <SECRET>";
          }
        }
      }

      // ftp client username
      leaf username {
        tailf:info "Specify username for FTP connections";
        type string {
          tailf:info "WORD;;FTP username";
        }
      }

      // ftp client vrf *
      list vrf {
        tailf:info "VRF name for FTP service";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of VRF";
          }
        }

        // ftp client vrf * passive
        leaf passive {
          tailf:info "Connect using passive mode";
          type empty;
        }

        // ftp client vrf * source-interface
        container source-interface {
          tailf:info "Specify interface for source address in FTP connections";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          uses interface-name-grouping;
        }

        // ftp client vrf * password
        container password {
          tailf:info "Specify password for ftp connection";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          uses password-grouping {
            refine "secret" {
              cli:secret " password <SECRET>";
            }
          }
        }

        // ftp client vrf * username
        leaf username {
          tailf:info "Specify username for FTP connections";
          type string {
            tailf:info "WORD;;FTP username";
          }
        }
      }

      // ftp client source-interface
      container source-interface {
        tailf:info "Specify interface for source address in FTP connections";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        uses interface-name-grouping;
      }
    }
  }


  /// ========================================================================
  /// icmp
  /// ========================================================================

  container icmp {
    tailf:info "ICMP options";
    tailf:cli-explicit-exit;

    container ipv4 {
      tailf:info "IPv4 specific";

      // icmp ipv4 source
      container source {
        tailf:info "source address selection policy";

        // icmp ipv4 source rfc
        leaf rfc {
          tailf:info "Enable RFC compliance for source address selection";
          tailf:cli-full-command;
          type empty;
        }

        // icmp ipv4 source vrf
        leaf vrf {
          tailf:info "Enable Strct VRF source address selection";
          tailf:cli-full-command;
          type empty;
        }
      }

      // icmp ipv4 rate-limit unreachable
      container rate-limit {
        tailf:info "rate limit generation of ICMP messages";
        container unreachable {
          tailf:info "Destination Unreachable (type3)";

          // icmp ipv4 rate-limit unreachable DF
          leaf DF {
            tailf:info "Fragmentation needed and DF set (code4)";
            type union {
              type uint32 {
                tailf:info "<1-4294967295>;;One ICMP unreachable message in x milliseconds(default is 500ms)";
              }
              type enumeration {
                enum disable {
                              tailf:info "Disable rate limit of ICMP messages";
                }
              }
            }
          }

          // icmp ipv4 rate-limit unreachable
          leaf milliseconds {
            tailf:cli-drop-node-name;
            type union {
              type uint32 {
                tailf:info "<1-4294967295>;;One ICMP unreachable message in x milliseconds(default is 500ms)";
              }
              type enumeration {
                enum disable {
                              tailf:info "Disable rate limit of ICMP messages";
                }
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// ntp
  /// ========================================================================

  container ntp {
    tailf:info "Go into NTP submode";
    tailf:cli-add-mode;
    tailf:cli-explicit-exit;

    // ntp / ipv4
    container ipv4 {
      tailf:info "Mark the dscp/precedence bit for ipv4 packets";
      choice ipv4-choice {
        // ntp / ipv4 dscp
        leaf dscp {
          tailf:info "Set IP DSCP (DiffServ CodePoint)";
          type dscp-type;
        }
        leaf precedence {
          tailf:info "Set precedence";
          type precedence-type;
        }
      }
    }

    // ntp / ipv6
    container ipv6 {
      tailf:info "Mark the dscp/precedence bit for ipv6 packets";
      choice ipv6-choice {
        // ntp / ipv6 dscp
        leaf dscp {
          tailf:info "Set IP DSCP (DiffServ CodePoint)";
          type dscp-type;
        }
        leaf precedence {
          tailf:info "Set precedence";
          type precedence-type;
        }
      }
    }

    // ntp / max-associations
    leaf max-associations {
      tailf:info "Set maximum number of associations";
      type uint32 {
        tailf:info "<0-4294967295>;;Number of associations";
      }
    }

    // ntp / peer *
    list peer {
      tailf:info "Configure NTP peer";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key address;
      leaf address {
        tailf:cli-disallow-value "ipv4|ipv6|vrf";
        type inet:host {
          tailf:info "Hostname or A.B.C.D or X:X::X;;Peer/server address";
        }
      }
      leaf af {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        type enumeration {
          enum ipv4 {
            tailf:info "Specify IPv4 address or hostname";
          }
          enum ipv6 {
            tailf:info "Specify IPv6 address or host name";
          }
        }
        default ipv4;
      }
    }

    // ntp / peer vrf * *
    container peer-vrf {
      tailf:cli-drop-node-name;
      list peer {
        tailf:info "Configure NTP peer";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "vrf address";
        leaf vrf {
          tailf:info "Specify non-default VRF";
          tailf:cli-expose-key-name;
          type string {
            tailf:info "WORD;;Name of the VRF";
          }
        }
        leaf address {
          tailf:cli-disallow-value "ipv4|ipv6|vrf";
          type inet:host {
            tailf:info "Hostname or A.B.C.D or X:X::X;;Peer/server address";
          }
        }
        leaf af {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key {
            tailf:cli-before-key 2;
          }
          type enumeration {
            enum ipv4 {
              tailf:info "Specify IPv4 address or hostname";
            }
            enum ipv6 {
              tailf:info "Specify IPv6 address or host name";
            }
          }
          default ipv4;
        }
      }
    }

    // ntp / server *
    container server {
      tailf:info "Configure NTP server";
      uses ntp-server-grouping;

      // ntp / server vrf *
      list vrf {
        tailf:info "Specify non-default VRF";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Non-default VRF of peer";
          }
        }
        uses ntp-server-grouping;
      }
    }

    // ntp / access-group *
    list access-group {
      tailf:info "Control NTP access";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-incomplete-command;
      key "version type";
      leaf version {
        type enumeration {
          enum ipv4 {
            tailf:info "Configure IPv4 access";
          }
          enum ipv6 {
            tailf:info "Configure IPv6 access";
          }
        }
      }
      leaf type {
        type enumeration {
          enum peer {
            tailf:info "Provide full access";
          }
          enum query-only {
            tailf:info "Allow only control queries";
          }
          enum serve {
            tailf:info "Provide server and query access";
          }
          enum serve-only {
            tailf:info "Provide only server access";
          }
        }
      }
      leaf name {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "WORD;;Access list name - maximum 64 characters";
        }
      }
    }

    // ntp / access-group vrf *
    container access-group-vrf {
      tailf:cli-drop-node-name;

      // ntp / access-group vrf *
      list access-group {
        tailf:info "Control NTP access";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-incomplete-command;
        key "vrf version type";
        leaf vrf {
          tailf:info "Specify non-default VRF";
          tailf:cli-expose-key-name;
          type string {
            tailf:info "WORD;;Non-default VRF of peer";
          }
        }
        leaf version {
          type enumeration {
            enum ipv4 {
              tailf:info "Configure IPv4 access";
            }
            enum ipv6 {
              tailf:info "Configure IPv6 access";
            }
          }
        }
        leaf type {
          type enumeration {
            enum peer {
              tailf:info "Provide full access";
            }
            enum query-only {
              tailf:info "Allow only control queries";
            }
            enum serve {
              tailf:info "Provide server and query access";
            }
            enum serve-only {
              tailf:info "Provide only server access";
            }
          }
        }
        leaf name {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;Access list name - maximum 64 characters";
          }
        }
      }
    }

    // ntp / interface *
    list interface {
      tailf:info "Configure NTP on an interface";
      tailf:cli-mode-name "config-ntp-int";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Interface Name";
        }
      }

      // ntp / interface * / broadcast
      container broadcast {
        tailf:info "Configure NTP broadcast service";
        tailf:cli-delete-when-empty;
        presence true;
        // ntp / interface * / broadcast version
        leaf version {
          tailf:info "Configure NTP version";
          type uint8 {
            tailf:info "<1-4>;;NTP version number";
            range "1..4";
          }
        }
      }
    }

    // ntp / master
    leaf master {
      tailf:info "Choose a refclock as master clock for NTP";
      tailf:cli-full-command;
      type uint16;
    }

    // ntp / source
    container source {
      tailf:info "Configure default interface";
      // ntp / source vrf *
      list vrf {
        tailf:info "Specify non-default VRF";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Specify non-default VRF";
          }
        }
        uses interface-name-grouping;
      }
      uses interface-name-grouping;
    }

    // ntp / update-calendar
    leaf update-calendar {
      tailf:info "Periodically update calendar with NTP time";
      tailf:cli-full-command;
      type empty;
    }

    // ntp / log-internal-sync
    leaf log-internal-sync {
      tailf:info "Logs internal synchronization changes";
      type empty;
    }

    // ntp / authentication-key * md5
    list authentication-key {
      tailf:info "Authentication key for trusted time sources";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      key id;
      leaf id {
        type uint16 {
          tailf:info "<1-65535>;;Key number";
          range "1..65535";
        }
      }
      container md5 {
        tailf:info "MD5 authentication";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        uses password-grouping {
          refine "secret" {
            cli:secret " md5 <SECRET>";
          }
        }
      }
    }

    // ntp / authenticate
    leaf authenticate {
      tailf:info "Authenticate time sources";
      type empty;
    }

    // ntp / trusted-key *
    leaf-list trusted-key {
      tailf:info "Key numbers for trusted time sources";
      tailf:cli-list-syntax;
      type uint16 {
        tailf:info "<1-65535>;;Key number";
      }
    }
  }


  /// ========================================================================
  /// rcp
  /// ========================================================================

  container rcp {
    tailf:info "Global RCP configuration commands";

    // rcp client
    container client {
      tailf:info "RCP client configuration commands";

      // rcp client username
      leaf username {
        tailf:info "Specify the local RCP username";
        type string {
          tailf:info "WORD;;RCP username";
        }
      }

      // rcp client source-interface
      container source-interface {
        tailf:info "Specify interface for source address in RCP connections";
        uses interface-name-grouping;
      }
    }
  }


  /// ========================================================================
  /// telnet
  /// ========================================================================

  container telnet {
    tailf:info "Global Telnet configuration commands";
    tailf:cli-explicit-exit;

    // telnet ipv4 client source-interface
    container ipv4 {
      tailf:info "IPv4 configuration";
      container client {
        tailf:info "Telnet client configuration commands";
        container source-interface {
          tailf:info "Source interface for telnet sessions";
          uses interface-name-grouping;
        }
      }
    }

    // telnet ipv6 client source-interface
    container ipv6 {
      tailf:info "IPv6 configuration";
      container client {
        tailf:info "Telnet client configuration commands";
        container source-interface {
          tailf:info "Source interface for telnet sessions";
          uses interface-name-grouping;
        }
      }
    }

    // telnet *
    uses telnet-server-grouping;

    // telnet vrf *
    list vrf {
      tailf:info "VRF name for telnet server";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      tailf:cli-incomplete-command;
      key name;
      leaf name {
        type vrf-type;
      }
      uses telnet-server-grouping;
    }
  }


  /// ========================================================================
  /// bfd
  /// ========================================================================

  container bfd {
    tailf:info "Global BFD configuration commands";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-bfd";
    tailf:cli-explicit-exit;

    // bfd / interface *
    list interface {
      tailf:info "Configure BFD on an interface";
      tailf:cli-mode-name "config-bfd-if";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Interface Name";
        }
      }

      // bfd / interface * / echo
      leaf echo {
        tailf:info "Configure BFD echo mode";
        tailf:cli-full-command;
        type empty;
      }

      // bfd / interface * / echo X
      container echo-conf {
        tailf:cli-drop-node-name;
        container echo {
          tailf:info "Configure BFD echo mode";
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;

          // bfd / interface * / echo disable
          leaf disable {
            tailf:info "Disable BFD echo mode for this interface";
            tailf:cli-full-command;
            type empty;
          }

          // bfd / interface * / echo ipv4 source
          container ipv4 {
            tailf:info "IPv4 commands";
            leaf source {
              tailf:info "BFD echo source IP addres";
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IPv4 address";
              }
            }
          }
        }
      }
    }

    // bfd / multihop ttl-drop-threshold
    container multihop {
      tailf:info "Configure BFD multihop";
      leaf ttl-drop-threshold {
        tailf:info "TTL Drop Threshold";
        type uint8 {
          tailf:info "<0-254>;;Drop Threshold";
          range "0..254";
        }
      }
    }

    // bfd / multipath include location *
    container multipath {
      tailf:info "Configure BFD multiple path";
      container include {
        tailf:info "Include a LC node";
        list location {
          tailf:info "Specify a location";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Fully qualified location specification";
            }
          }
        }
      }
    }

    // bfd / multipath bundle coexistence bob-blb
    container bundle {
      tailf:info "Option for BFD over Bundle";
      container coexistence {
        tailf:info "How BFD bundle features coexist";
        leaf bob-blb {
          tailf:info "Coexistence for BoB and BLB";
          type enumeration {
            enum inherit {
                          tailf:info "Use inheritence mechanism";
            }
            enum logical {
                          tailf:info "Use BFD logical Bundle natively";
            }
          }
        }
      }
    }

    // bfd / echo
    container echo {
      tailf:info "Configure BFD echo parameters";
      leaf disable {
        tailf:info "Disable BFD echo mode";
        tailf:cli-reset-container;
        tailf:cli-full-command;
        type empty;
      }
    }

    // bfd / trap
    container trap {
      tailf:info "Configure BFD trap parameters";
      container singlehop {
        tailf:info "Configure BFD mode";
        leaf pre-mapped {
          tailf:info "Configure BFD trap pre-mapped";
          type empty;
        }
      }
    }

    // bfd / dampening
    container dampening {
      tailf:info "Configure BFD dampening intervals";

      // bfd / dampening disable
      leaf disable {
        tailf:info "Disable BFD dampening";
        type empty;
      }

      // bfd / dampening bundle-member
      container bundle-member {
        tailf:info "Configure BFD dampening for bfd over bundle per member feature";

        // bfd / dampening bundle-member l3-only-mode
        leaf l3-only-mode {
          tailf:info "Apply immedite dampening and only when failure is L3 specific";
          type empty;
        }

        // bfd / dampening bundle-member secondary-wait
        leaf secondary-wait {
          tailf:info "Secondary delay before bringing up session";
          type uint32 {
            tailf:info "<1-518400000>;;Delay in milliseconds (default 20000)";
            range "1..518400000";
          }
        }

        // bfd / dampening bundle-member initial-wait
        leaf initial-wait {
          tailf:info "Initial delay before bringing up session";
          type uint32 {
            tailf:info "<1-518400000>;;Delay in milliseconds (default 16000)";
            range "1..518400000";
          }
        }

        // bfd / dampening bundle-member maximum-wait
        leaf maximum-wait {
          tailf:info "Maximum delay before bringing up session";
          type uint32 {
            tailf:info "<1-518400000>;;Delay in milliseconds (default 600000)";
            range "1..518400000";
          }
        }
      }

      // bfd / dampening secondary-wait
      leaf secondary-wait {
        tailf:info "Secondary delay before bringing up session";
        type uint32 {
          tailf:info "<1-3600000>;;Delay in milliseconds (default 5000)";
          range "1..3600000";
        }
      }

      // bfd / dampening initial-wait
      leaf initial-wait {
        tailf:info "Initial delay before bringing up session";
        type uint32 {
          tailf:info "<1-3600000>;;Delay in milliseconds (default 2000)";
          range "1..3600000";
        }
      }

      // bfd / dampening maximum-wait
      leaf maximum-wait {
        tailf:info "Maximum delay before bringing up session";
        type uint32 {
          tailf:info "<1-3600000>;;Delay in milliseconds (default 120000)";
          range "1..3600000";
        }
      }
    }
  }


  /// ========================================================================
  /// sbfd
  /// ========================================================================

  // sbfd
  container sbfd {
    tailf:info "Global SBFD configuration commands";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-sbfd";
    tailf:cli-explicit-exit;

    // sbfd / remote-target
    container remote-target {
      tailf:info "configure remote-target";

      // sbfd / remote-target ipv4 *
      list ipv4 {
        tailf:info "Ipv4 address only";
        tailf:cli-mode-name "config-sbfd-rtarget";
        key address;
        leaf address {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IPv4 address";
          }
        }

        // sbfd / remote-target ipv4 * / remote-discriminator
        leaf remote-discriminator {
          tailf:info "Configure remote-discriminator";
          type uint32 {
            tailf:info "<1-4294967295>;;32-bit remote-discriminator";
            range "1..4294967295";
          }
        }
      }
    }

    // sbfd / local-discriminator
    container local-discriminator {
      tailf:info "configure local-discriminator";

      // sbfd / local-discriminator *
      list address-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key ipv4;
        leaf ipv4 {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;ipv4 address as local-discriminator";
          }
        }
      }

      // sbfd / local-discriminator *
      list id-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key id;
        leaf id {
          type uint32 {
            tailf:info "<1-4294967295>;;32-bit local-discriminator";
          }
        }
      }

      // sbfd / local-discriminator dynamic
      leaf dynamic {
        tailf:info "configure local-discriminator dynamically";
        tailf:cli-full-command;
        type empty;
      }

      // sbfd / local-discriminator interface *
      list interface {
        tailf:info "Interface whose IPv4 address is to be used as local discriminator";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type ifname;
        }
      }
    }
  }


  /// ========================================================================
  /// tftp
  /// ========================================================================

  container tftp {
    tailf:info "Global TFTP configuration commands";
    tailf:cli-explicit-exit;

    // tftp client
    container client {
      tailf:info "TFTP client configuration commands";

      // tftp client vrf *
      list vrf {
        tailf:info "VRF name for TFTP service";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of VRF";
          }
        }

        // tftp client vrf * source-interface
        container source-interface {
          tailf:info "Specify interface for source address in TFTP connections";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          uses interface-name-grouping;
        }
      }

      // tftp client source-interface
      container source-interface {
        tailf:info "Specify interface for source address in TFTP connections";
        uses interface-name-grouping;
      }

      // tftp client retries
      leaf retries {
        tailf:info "Specify the number of retries when client requests TFTP connections";
        type uint16 {
          tailf:info "<0-256>;;TFTP initial maximum retry times";
          range "0..256";
        }
      }

      // tftp client timeout
      leaf timeout {
        tailf:info "Specify the timeout for every TFTP connection in seconds";
        type uint16 {
          tailf:info "<0-256>;;TFTP initial maximum timeout";
          range "0..256";
        }
      }

      // tftp client dscp
      leaf dscp {
        tailf:info "Set IP DSCP (DiffServ CodePoint) for TFTP Client Packets";
        type dscp-type;
      }
    }

    // tftp *
    uses tftp-server-grouping;

    // tftp vrf *
    list vrf {
      tailf:info "VRF name for tftp server";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      tailf:cli-incomplete-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Name of VRF";
        }
      }
      uses tftp-server-grouping;
    }
  }


  /// ========================================================================
  /// nv
  /// ========================================================================

  container nv {
    tailf:info "Network Virtualisation configuration";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-nV";
    tailf:cli-explicit-exit;

    // nv / optical
    container optical {
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-nV-optical";

      // nv / optical / satellite *
      list satellite {
        tailf:info "Satellite configuration";
        tailf:cli-mode-name "config-nV-optical-satellite";
        key id;
        leaf id {
          type uint32 {
            tailf:info "NUM;;Satellite ID";
          }
        }

        // nv / optical / satellite * / ipv6
        container ipv6 {
          leaf address {
            type inet:ipv6-address;
          }
        }

        // nv / optical / satellite * / username
        container username {
          tailf:cli-compact-syntax;
          leaf name {
            tailf:cli-drop-node-name;
            type string;
          }
          leaf password {
            type string;
          }
        }

        // nv / optical / satellite * / trunk slot *
        container trunk {
          list slot {
            key id;
            leaf id {
              type uint32;
            }
            leaf port {
              tailf:cli-hide-in-submode;
              type uint32;
            }
            leaf local-port {
              tailf:cli-hide-in-submode;
              type string;
            }
          }
        }
      }
    }

    // nv / controller
    container controller {
      tailf:info "Network Virtualisation controller configuration";

      // nv controller dwdm *
      // NOTE: Differs on g709 and proactive
      uses controller-dwdm-grouping;

      // nv controller HundredGigE *
      list HundredGigE {
        tailf:cli-allow-join-with-key;
        key id;
        leaf id {
          type string {
            pattern "[0-9]+(/[0-9]+)*";
          }
        }
        leaf admin-state {
          type enumeration {
            enum in-service;
            enum maintenance;
            enum out-of-service;
            enum in-service-config-allowed;
          }
        }
      }
    }

    // nv / satellite *
    list satellite {
      tailf:info "ICPE satellite configuration";
      tailf:cli-mode-name "config-satellite";
      key id;
      leaf id {
        type uint16 {
          tailf:info "<100-65534>;;Satellite ID";
          range "100..65534";
        }
      }

      // nv / satellite * / type
      leaf type {
        tailf:info "Satellite type";
        type string {
          tailf:info "WORD;;Satellite type";
        }
      }

      // nv / satellite * / ip address
      container ip {
        tailf:info "IP address";
        leaf address {
          tailf:info "IP address";
          type union {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IPv4 address";
            }
            type inet:ipv6-address {
              tailf:info "X:X::X;;IPv6 address";
            }
          }
        }
      }

      // nv / satellite * / ipv4 address
      container ipv4 {
        tailf:info "IPv4 address";
        leaf address {
          tailf:info "IPv4 address";
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IPv4 address";
          }
        }
      }

      // nv / satellite * / device-name
      leaf device-name {
        tailf:info "Satellite name";
        type string {
          tailf:info "WORD;;name for the satellite";
        }
      }

      // nv / satellite * / redundancy
      container redundancy {
        tailf:info "Redundancy configuration";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-nV-red";

        // nv / satellite * / redundancy / host-priority
        leaf host-priority {
          tailf:info "Priority of this host for the given satellite";
          type uint8 {
            tailf:info "<0-255>;;Priority. A lower number denotes a higher priority. (Default: 128)";
          }
        }
      }

      // nv / satellite * / description
      leaf description {
        tailf:info "Satellite description.";
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;description";
        }
      }

      // nv / satellite * / serial-number
      leaf serial-number {
        tailf:info "Serial number of the connected satellite";
        type string {
          tailf:info "WORD;;Satellite serial number";
        }
      }

      // nv / satellite * / upgrade on-connect
      container upgrade {
        tailf:info "Satellite upgrade configuration";
        leaf on-connect {
          tailf:info "Auto-upgrade on connection as required";
          type empty;
        }
      }

      // nv / satellite * / secret
      container secret {
        tailf:info "Secure";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf type {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type enumeration {
            enum "0" {
              tailf:info "Specifies an UNENCRYPTED password will follow";
            }
            enum "5" {
              tailf:info "Specifies an ENCRYPTED secret will follow";
            }
          }
        }
        leaf secret {
          tailf:cli-drop-node-name;
          tailf:cli-reset-container;
          cli:secret " secret <SECRET>";
          type NEDCOM_SECRET_TYPE {
            tailf:info "LINE;;The ENCRYPTED secret string";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// enable
  /// ========================================================================

  container enable {
    tailf:info "Modify enable password parameters";
    tailf:cli-explicit-exit;

    container password {
      tailf:info "Assign the privileged level password (MAX of 25 characters)";
    }

    container secret {
      tailf:info "Assign the privileged level secret (MAX of 25 characters)";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf type {
        tailf:cli-drop-node-name;
        type enumeration {
          enum "0" {
            tailf:info "Specifies an UNENCRYPTED password will follow";
          }
          enum "5" {
            tailf:info "Specifies an ENCRYPTED secret will follow";
          }
        }
      }
      leaf secret {
        tailf:cli-drop-node-name;
        cisco-ios-xr:maapi-encrypted;
        type NEDCOM_SECRET_TYPE {
          tailf:info "LINE;;The ENCRYPTED 'enable' secret string";
        }
      }
    }
  }


  /// ========================================================================
  /// username
  /// ========================================================================

  // username *
  uses username-grouping;


  /// ========================================================================
  /// tacacs-server
  /// ========================================================================

  container tacacs-server {
    tailf:info "TACACS+ server definition";
    tailf:cli-explicit-exit;

    // tacacs-server host *
    list host {
      tailf:info "Specify a TACACS+ server";
      tailf:cli-compact-syntax; //FIXME: remove me?
      tailf:cli-mode-name "config-tacacs-host";
      tailf:cli-show-long-obu-diffs;
      ordered-by "user";
      key "name port";
      leaf name {
        type inet:host {
          tailf:info "Hostname or A.B.C.D;;IP address of TACACS+ server";
        }
      }
      leaf port {
        tailf:info "TCP port for TACACS+ server (default is 49)";
        tailf:cli-expose-key-name;
        type uint16 {
          tailf:info "<1-65535>;;Port number";
          range "1..65535";
        }
      }

      // tacacs-server host * / key
      container key {
        tailf:info "per-server encryption key (overrides default)";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        uses key-grouping {
          refine "key" {
            cli:secret " key <SECRET>" {
              cli:arguments "always-encrypted";
            }
          }
        }
      }

      // tacacs-server host * / timeout
      leaf timeout {
        tailf:info "Time to wait for this TACACS server to reply (overrides default)";
        type uint16 {
          tailf:info "<1-1000>;;Timeout value in seconds to wait for server to reply";
          range "1..1000";
        }
      }

      // tacacs-server host * / single-connection
      leaf single-connection {
        tailf:info "Reuse connection to this server for all requests";
        type empty;
      }
    }

    // tacacs-server ipv4 dscp
    container ipv4 {
      tailf:info "Mark the dscp bit for ipv4 packets";
      leaf dscp {
        tailf:info "Set IP DSCP (DiffServ CodePoint)";
        type dscp-type;
      }
    }

    // tacacs-server ipv6 dscp
    container ipv6 {
      tailf:info "Mark the dscp bit for ipv6 packets";
      leaf dscp {
        tailf:info "Set IP DSCP (DiffServ CodePoint)";
        type dscp-type;
      }
    }

    // tacacs-server key
    container key {
      tailf:info "Set TACACS+ encryption key";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      uses key-grouping {
        refine "key" {
          cli:secret " key <SECRET>" {
            cli:arguments "always-encrypted";
          }
        }
      }
    }

    // tacacs-server timeout
    leaf timeout {
      tailf:info "Time to wait for a TACACS server to reply";
      type uint16 {
        tailf:info "<1-1000>;;Wait time (default 5 seconds)";
        range "1..1000";
      }
    }
  }


  /// ========================================================================
  /// tacacs
  /// ========================================================================

  container tacacs {
    tailf:info "TACACS+ configuration commands";
    tailf:cli-explicit-exit;

    // tacacs source-interface
    container source-interface {
      tailf:info "Specify interface for source address in TACACS+ packets";
      uses interface-name-grouping;
    }

    // tacacs source-interface ? vrf *
    container source-interface-vrf {
      tailf:cli-drop-node-name;
      list source-interface {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        key vrf;
        leaf vrf {
          tailf:info "VRF for this source interface configuration";
          tailf:cli-expose-key-name;
          tailf:cli-suppress-range;
          type string {
            tailf:info "WORD;;Name of the VRF";
          }
        }
        leaf interface {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type string {
            tailf:info "WORD;;Interface Name";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// tpa
  /// ========================================================================

  // tpa
  container tpa {
    tailf:info "Third Party Applications Subcommands";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-tpa";
    tailf:cli-explicit-exit;

    // tpa / vrf *
    list vrf {
      tailf:info "VRF name";
      tailf:cli-mode-name "config-tpa-vrf";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Name of VRF";
        }
      }

      // tpa / vrf * / address-family
      container address-family {
        tailf:info "Address-family configuration subcommands";

        // tpa / vrf * / address-family ipv4
        container ipv4 {
          tailf:info "IPv4 commands";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-tpa-vrf-afi";
          uses tpa-af-grouping;
        }

        // tpa / vrf * / address-family ipv6
        container ipv6 {
          tailf:info "IPv6 commands";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-tpa-vrf-afi";
          uses tpa-af-grouping;
        }
      }
      list east-west {
        tailf:info "Global interface East-West communication options";
        tailf:cli-suppress-mode;
        key name;
        leaf name {
          type string {
            tailf:info "Interface name";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// aaa
  /// ========================================================================

  container aaa {
    tailf:info "Authentication, Authorization and Accounting.";
    tailf:cli-explicit-exit;

    // aaa new-model
    leaf new-model {
      tailf:info "Enable NEW access control commands and functions (Disables OLD commands)";
      tailf:cli-full-command;
      type empty;
    }

    // aaa server radius dynamic-author
    container server {
      tailf:info "AAA Server";
      container radius {
        tailf:info "AAA Server - Radius Definition";
        container dynamic-author {
          tailf:info "Radius Dynamic Author Server Configurations";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-dynamic-author";

          // aaa server radius dynamic-author / port
          leaf port {
            tailf:info "Specify the COA Server port to listen on";
            type uint16 {
              tailf:info "<1000-5000>;;port number";
              range "1000..5000";
            }
          }

          // aaa server radius dynamic-author / ignore server-key
          container ignore {
            tailf:info "ignore options";
            leaf server-key {
              tailf:info "ignore  server-key";
              type empty;
            }
          }

          // aaa server radius dynamic-author / client * vrf *
          list client {
            tailf:info "COA client configuration";
            tailf:cli-mode-name "config-dynamic-author-client";
            key "address vrf";
            leaf address {
              type inet:host {
                tailf:info "A.B.C.D or X:X::X;;IP address of COA Client";
              }
            }
            leaf vrf {
              tailf:info "VRF to which COA Client belongs";
              tailf:cli-expose-key-name;
              type vrf-type;
            }

            // aaa server radius dynamic-author / client * vrf * / server-key
            container server-key {
              tailf:info "COA client shared secret key";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              uses key-grouping {
                refine "key" {
                  cli:secret " server-key <SECRET>";
                }
              }
            }
          }
        }
      }
    }

    // aaa group server
    container group {
      tailf:info "AAA group definitions";
      container server {
        tailf:info "AAA Server group definitions";

        // aaa group server radius *
        list radius {
          tailf:info "Radius server-group definition";
          tailf:cli-mode-name "config-sg-radius";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Server-group name";
            }
          }

          // aaa group server radius * / vrf
          leaf vrf {
            tailf:info "VRF to which this server group belongs to";
            type string {
              tailf:info "WORD;;Name of the VRF";
            }
          }

          // aaa group server radius * / authorization
          container authorization {
            tailf:info "Specify a RADIUS attribute filter for authorization";

            // aaa group server radius * / authorization reply
            container reply {
              tailf:info "Attribute filtering for Access-Reply";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf action {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type enumeration {
                  enum accept {
                               tailf:info "Accept only those attributes specified in this list";
                  }
                  enum reject {
                               tailf:info "Reject the attributes specified in this list";
                  }
                }
              }
              leaf attr-name {
                tailf:cli-drop-node-name;
                type string {
                  tailf:info "WORD;;Name of RADIUS attribute list";
                }
              }
            }

            // aaa group server radius * / authorization request
            container request {
              tailf:info "Attibute filtering for Access-Request";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf action {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type enumeration {
                  enum accept {
                               tailf:info "Accept only those attributes specified in this list";
                  }
                  enum reject {
                               tailf:info "Reject the attributes specified in this list";
                  }
                }
              }
              leaf attr-name {
                tailf:cli-drop-node-name;
                type string {
                  tailf:info "WORD;;Name of RADIUS attribute list";
                }
              }
            }
          }

          // aaa group server radius * / server *
          container server {
            tailf:info "Specify a RADIUS server";

            // aaa group server radius * / server name *
            list name {
              tailf:info "Radius server name";
              key name;
              leaf name {
                tailf:cli-suppress-leafref-in-diff;
                tailf:non-strict-leafref {
                  path "/cisco-ios-xr:aaa/group/server/radius/name";
                }
                type string {
                  tailf:info "WORD;;Name of radius server";
                }
              }
            }

            // aaa group server radius * / server *
            list direct {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              key name;
              leaf name {
                tailf:cli-disallow-value "name";
                type inet:host {
                  tailf:info "Hostname or A.B.C.D;;IP address of RADIUS server";
                }
              }
              leaf auth-port {
                tailf:info "UDP port for RADIUS authentication server (default is 1645)";
                type uint16 {
                  tailf:info "<0-65535>;;Port number";
                  range "0..65535";
                }
              }
              leaf acct-port {
                tailf:info "UDP port for RADIUS accounting server (default is 1646)";
                type uint16 {
                  tailf:info "<0-65535>;;Port number";
                  range "0..65535";
                }
              }
            }
          }

          // aaa group server radius * / ip vrf forwarding
          container ip {
            tailf:info "Internet Protocol config commands";
            container vrf {
              tailf:info "Set VPN Routing Forwarding to use with the servers";
              leaf forwarding {
                tailf:info "Configure forwarding table";
                type string {
                  tailf:info "WORD;;Table name";
                }
              }
            }
          }

          // aaa group server radius * / deadtime
          leaf deadtime {
            tailf:info "Time in minutes after which a RADIUS server will be marked UP after it has gone dead";
            type uint16 {
              tailf:info "<1-1440>;;Deadtime limit in minutes (default 0)";
              range "1..1440";
            }
          }

          // aaa group server radius * / source-interface
          container source-interface {
            tailf:info "Specify interface for source address in RADIUS packets";
            uses interface-name-grouping;
          }

          // aaa group server radius * / load-balance method least-outstanding
          container load-balance {
            tailf:info "Radius load-balancing options.";
            container method {
              tailf:info "Method by which the next host will be picked.";
              container least-outstanding {
                tailf:info "Pick the server with the least transactions outstanding.";
                tailf:cli-compact-syntax;
                leaf batch-size {
                  tailf:info "Batch size for selection of the server.";
                  type uint16 {
                    tailf:info "<1-1500>;;Batch size for selection of the server (default 25)";
                    range "1..1500";
                  }
                }
                leaf ignore-preferred-server {
                  tailf:info "Disable preferred server for this Server Group";
                  type empty;
                }
              }
            }
          }

          // aaa group server radius * / server-private *
          list server-private {
            tailf:info "Specify a private (to this server group) RADIUS server";
            tailf:cli-mode-name "config-sg-radius-private";
            key "address auth-port acct-port";
            leaf address {
              type inet:host {
                tailf:info "A.B.C.D or X:X::X;;IPv4/v6 address or Hostname of RADIUS server";
              }
            }
            leaf auth-port {
              tailf:info "RADIUS server authentication port";
              tailf:cli-expose-key-name;
              type uint16 {
                tailf:info "<0-65535>;;Authentication port number";
              }
            }
            leaf acct-port {
              tailf:info "RADIUS server accounting port";
              tailf:cli-expose-key-name;
              type uint16 {
                tailf:info "<0-65535>;;Accounting port number";
              }
            }

            // aaa group server radius * / server-private * / key
            container key {
              tailf:info "RADIUS server key";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              uses key-grouping {
                refine "key" {
                  cli:secret " key <SECRET>";
                }
              }
            }
          }
        }

        // aaa group server tacacs+ *
        list tacacs {
          tailf:alt-name "tacacs+";
          tailf:info "tacacs+;;TACACS+ server-group definition";
          tailf:cli-mode-name "config-sg-tacacs";
          cisco-ios-xr:list-modify-redeploy;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Server group name";
            }
          }

          // aaa group server tacacs+ * / server *
          leaf-list server {
            tailf:info "Specify a TACACS+ server";
            tailf:cli-list-syntax;
            tailf:cli-remove-before-change;
            ordered-by user;
            type inet:host {
              tailf:info "Hostname or A.B.C.D IP address or Hostname of TACACS+ server";
            }
          }

          // aaa group server tacacs+* / vrf
          leaf vrf {
            tailf:info "VRF to which this server group belongs to";
            tailf:cli-full-command;
            type string {
              tailf:info "WORD;;Name of the VRF";
            }
          }

          // aaa group server tacacs+ * / server-private *
          list server-private {
            tailf:info "Specify a private (to this server group) TACACS+ server";
            tailf:cli-mode-name "config-sg-tacacs-private";
            key "address port";
            leaf address {
              type inet:host {
                tailf:info "A.B.C.D or X:X::X;;IPv4/IPv6 address of TACACS+ server";
              }
            }
            leaf port {
              tailf:info "TCP port for TACACS+ server (default is 49)";
              tailf:cli-expose-key-name;
              tailf:key-default "49";
              type uint16 {
                tailf:info "<1-65535>;;Port number";
                range "1..65535";
              }
            }

            // aaa group server tacacs+ * / server-private * / key
            container key {
              tailf:info "Set TACACS+ encryption key";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              uses key-grouping {
                refine "key" {
                  cli:secret " key <SECRET>";
                }
              }
            }

            // aaa group server tacacs+ * / server-private * / timeout
            leaf timeout {
              tailf:info "Time to wait for a TACACS server to reply";
              type uint16 {
                tailf:info "<1-1000>;;Wait time (default 5 seconds)";
                range "1..1000";
              }
            }
            // aaa group server tacacs+ * / server-private * / single-connection
            leaf single-connection {
              tailf:info "Reuse connection to this server for all requests(2)";
              type empty;
            }
          }
        }
      }
    }

    // aaa authentication
    container authentication {
      tailf:info "Authentication configurations parameters.";

      // aaa authentication login *
      list login {
        tailf:info "Set authentication lists for logins.";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-remove-before-change;
        tailf:cli-incomplete-command;
        tailf:cli-diff-dependency "../../group/server/tacacs";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Named authentication list (max 31 characters)";
            length "1..31";
          }
        }
        leaf methods {
          tailf:cli-drop-node-name;
          tailf:cli-multi-value;
          tailf:cli-no-value-on-delete;
          type string {
            tailf:info "WORD;;ordered list of methods: none|local|group ldap|group radius|group tacacs|group <srv>";
          }
        }
      }

      // aaa authentication subscriber *
      list subscriber {
        tailf:info "Set authentication lists for Subscriber";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;List name for AAA authentication";
            length "1..31";
          }
        }
        leaf methods {
          tailf:cli-drop-node-name;
          tailf:cli-multi-value;
          type string {
            tailf:info "WORD;;ordered list of methods: none|local|group ldap|group radius|group tacacs|group <srv>";
          }
        }
      }

      // aaa authentication dot1x *
      list dot1x {
        tailf:info "Set authentication lists for Dot1x";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;List name for AAA authentication";
            length "1..31";
          }
        }
        leaf methods {
          tailf:cli-drop-node-name;
          tailf:cli-multi-value;
          type string {
            tailf:info "WORD;;ordered list of methods: none|local|group ldap|group radius|group tacacs|group <srv>";
          }
        }
      }
    }

    // aaa authorization
    container authorization {
      tailf:info "Authorization configurations parameters.";

      // aaa authorization commands *
      list commands {
        tailf:info "For EXEC (shell) commands";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;List name for AAA authorization";
          }
        }
        leaf methods {
          tailf:cli-drop-node-name;
          tailf:cli-multi-value;
          type string {
            tailf:info "WORD;;ordered list of methods: none|local|group ldap|group radius|group tacacs|group <srv>";
          }
        }
      }

      // aaa authorization exec *
      list exec {
        tailf:info "For starting an exec (shell).";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;List name for AAA authorization";
          }
        }
        leaf methods {
          tailf:cli-drop-node-name;
          tailf:cli-multi-value;
          type string {
            tailf:info "WORD;;ordered list of methods: none|local|group ldap|group radius|group tacacs|group <srv>";
          }
        }
      }

      // aaa authorization eventmanager *
      list eventmanager {
        tailf:info "For starting an exec (shell).";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;List name for AAA authorization";
          }
        }
        leaf methods {
          tailf:cli-drop-node-name;
          tailf:cli-multi-value;
          type string {
            tailf:info "WORD;;ordered list of methods: none|local|group ldap|group radius|group tacacs|group <srv>";
          }
        }
      }

      // aaa authorization subscriber *
      list subscriber {
        tailf:info "Set authorization lists for Subscriber";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;List name for AAA authorization";
          }
        }
        leaf methods {
          tailf:cli-drop-node-name;
          tailf:cli-multi-value;
          type string {
            tailf:info "WORD;;ordered list of methods: none|local|group ldap|group radius|group tacacs|group <srv>";
          }
        }
      }

      // aaa authorization network *
      list network {
        tailf:info "For network services (such as IKE)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;List name for AAA authorization";
          }
        }
        leaf methods {
          tailf:cli-drop-node-name;
          tailf:cli-multi-value;
          type string {
            tailf:info "WORD;;ordered list of methods: none|local|group ldap|group radius|group tacacs|group <srv>";
          }
        }
      }
    }

    // aaa accounting
    container accounting {
      tailf:info "Accounting configurations parameters.";

      // aaa accounting update
      container update {
        tailf:info "For starting Network UPDATE accounting";
        choice update-choice {
          leaf newinfo {
            tailf:info "Update records for new accountable information only";
            type empty;
          }
          leaf periodic {
            tailf:info "Update records at periodic intervals";
            type uint32 {
              tailf:info "<1-35791394>;;Periodic update interval in minutes";
              range "1..35791394";
            }
          }
        }
      }

      // aaa accounting exec *
      list exec {
        tailf:info "For starting an exec (shell).";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Named Accounting list";
          }
        }
        uses aaa-accounting-grouping;
      }

      // aaa accounting system *
      list system {
        tailf:info "For System events";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Named Accounting list";
          }
        }
        leaf start-stop {
          tailf:info "start and stop records";
          type empty;
        }
        leaf group {
          tailf:info "Use Server-group";
          tailf:cli-optional-in-sequence;
          type union {
            type string {
              tailf:info "WORD;;server-group name";
            }
            type enumeration {
              enum radius {
                           tailf:info "Use list of all Radius hosts";
              }
              enum "tacacs+" {
                tailf:info "Use list of all TACACS+ hosts";
              }
            }
          }
        }
        container group2 {
          when "../group" {
            tailf:dependency "../group";
          }
          tailf:cli-drop-node-name;
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-optional-in-sequence;
          leaf group {
            tailf:info "Use Server-group 2";
            type string {
              tailf:info "WORD;;server-group2 name";
            }
          }
        }
        leaf none {
          tailf:info "No accounting";
          type empty;
        }
      }

      // aaa accounting network *
      list network {
        tailf:info "For network services (such as IKE, PPP)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Named Accounting list";
          }
        }
        uses aaa-accounting-grouping;
      }

      // aaa accounting commands *
      list commands {
        tailf:info "For EXEC (shell) commands";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Named Accounting list";
          }
        }
        uses aaa-accounting-grouping;
      }

      // aaa accounting subscriber *
      list subscriber {
        tailf:info "Set accounting lists for Subscriber";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;List name for AAA accounting";
          }
        }
        leaf broadcast {
          tailf:info "Set broadcast accounting for Subscriber";
          tailf:cli-optional-in-sequence;
          type empty;
        }
        leaf group {
          tailf:info "Use Server-group";
          type string {
            tailf:info "WORD;;server-group name";
          }
        }
        container group2 {
          when "../group" {
            tailf:dependency "../group";
          }
          tailf:cli-drop-node-name;
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-optional-in-sequence;
          leaf group {
            tailf:info "Use Server-group 2";
            type string {
              tailf:info "WORD;;server-group2 name";
            }
          }
        }
      }

      // aaa accounting service *
      list service {
        tailf:info "Set accounting lists for Service";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;List name for AAA accounting";
          }
        }
        leaf methods {
          tailf:cli-drop-node-name;
          tailf:cli-multi-value;
          type string {
            tailf:info "WORD;;ordered list of methods: broadcast|<group diameter|radius|<server group>>";
          }
        }
      }
    }

    // aaa session-id
    leaf session-id {
      tailf:info "AAA Session ID";
      tailf:cli-full-command;
      type enumeration {
        enum common {
                     tailf:info "Common Session ID";
        }
        enum "unique" {
          tailf:info "Unique Session ID for different accounting types";
        }
      }
    }

    // aaa default-taskgroup
    leaf default-taskgroup {
      tailf:info "Default taskgroup to be used for remote authentication";
      tailf:cli-full-command;
      type string {
        tailf:info "WORD;;Name of the taskgroup to be used";
      }
    }

    // aaa attribute format *
    container attribute {
      tailf:info "AAA attribute";
      list format {
        tailf:info "AAA attribute format";
        tailf:cli-mode-name "config-id-format";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;identifier name";
          }
        }
        choice format-choice {
          // aaa attribute format * / format-string
          container format-string {
            tailf:info "extended format";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf length {
              tailf:info "length of the formatted string";
              tailf:cli-no-name-on-delete;
              tailf:cli-no-value-on-delete;
              tailf:cli-optional-in-sequence;
              type uint8 {
                tailf:info "<1-253>;;length of the formatted string";
                range "1..253";
              }
            }
            leaf format {
              tailf:cli-drop-node-name;
              tailf:cli-no-value-on-delete;
              type string {
                tailf:info "WORD;;format string (conversion specifier) enclosed in double quotes";
              }
            }
            leaf arguments {
              tailf:cli-drop-node-name;
              tailf:cli-multi-value;
              tailf:cli-no-value-on-delete;
              type string {
                tailf:info "WORD;;format argument(s)";
              }
            }
          }

          // aaa attribute format * / mac-address
          // aaa attribute format * / circuit-id
          // aaa attribute format * / remote-id
          // FIXME: add "plus"
          leaf-list format-list {
            tailf:cli-drop-node-name;
            tailf:cli-flat-list-syntax;
            tailf:cli-replace-all;
            ordered-by user;
            type enumeration {
              enum mac-address {
                tailf:info "Mac-address";
              }
              enum circuit-id {
                tailf:info "Circuit ID";
              }
              enum remote-id {
                tailf:info "Remote ID";
              }
            }
          }
        }
      }
    }

    // aaa radius attribute
    container radius {
      tailf:info "AAA radius attribute configuration";
      container attribute {
        tailf:info "AAA radius attribute";

        // aaa radius attribute nas-port-id
        container nas-port-id {
          tailf:info "AAA nas-port-id attribute";
          uses aaa-radius-attribute-grouping;
        }

        // aaa radius attribute calling-station-id
        container calling-station-id {
          tailf:info "AAA calling station id attribute";
          uses aaa-radius-attribute-grouping;
        }
      }
    }

    // aaa intercept
    container intercept {
      tailf:info "Global LI-MA enable disable";
      presence true;
    }

    // aaa password-policy *
    list password-policy {
      tailf:info "AAA password Policy";
      tailf:cli-mode-name "config-pp";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Password Policy name";
        }
      }

      // aaa password-policy * numeric
      leaf numeric {
        tailf:info "Number of numeric characters";
        type uint8 {
          tailf:info "<0-253>;;Number of numeric characters <0-253>, default is 0.";
          range "0..253";
        }
      }

      // aaa password-policy * lifetime
      container lifetime {
        tailf:info "Liftime of the password";

        // aaa password-policy * lifetime months
        leaf months {
          tailf:info "Number of months";
          type uint8 {
            tailf:info "<0-11>;;Number of months";
            range "0..11";
          }
        }
      }

      // aaa password-policy * lower-case 6
      leaf lower-case {
        tailf:info "Number of lower-case characters";
        type uint8 {
          tailf:info "<0-253>;;Number of lower-case characters <0-253>, default is 0.";
          range "0..253";
        }
      }

      // aaa password-policy * min-length
      leaf min-length {
        tailf:info "Specify the minimum length of the password";
        type uint8 {
          tailf:info "<2-253>;;Minimum length <2-253>, default is 2";
          range "2..253";
        }
      }

      // aaa password-policy * max-length
      leaf max-length {
        tailf:info "Specify the maximum length of the password";
        type uint8 {
          tailf:info "<2-253>;;Maximum length <2-253>, default is 253";
          range "2..253";
        }
      }

      // aaa password-policy * upper-case
      leaf upper-case {
        tailf:info "Number of upper-case characters";
        type uint8 {
          tailf:info "<0-253>;;Number of upper-case characters <0-253>, default is 0.";
          range "0..253";
        }
      }

      // aaa password-policy * special-char
      leaf special-char {
        tailf:info "Number of special characters";
        type uint8 {
          tailf:info "<0-253>;;Number of special characters <0-253>, default is 0.";
          range "0..253";
        }
      }

      // aaa password-policy * / lockout-time
      container lockout-time {
        tailf:info "Lockout time for the maximum authentication failures";

        // aaa password-policy * / lockout-time minutes
        leaf minutes {
          tailf:info "Number of minutes";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<0-59>;;Number of minutes";
            range "0..59";
          }
        }

        // aaa password-policy * / lockout-time days
        leaf days {
          tailf:info "Number of days";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<0-255>;;Number of days";
          }
        }

        // aaa password-policy * / lockout-time hours
        leaf hours {
          tailf:info "Number of hours";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<0-23>;;Number of hours";
            range 0..23;
          }
        }

        // aaa password-policy * / lockout-time seconds
        leaf seconds {
          tailf:info "Number of seconds";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<0-59>;;Number of seconds";
            range 0..59;
          }
        }
      }

      // aaa password-policy * / min-char-change
      leaf min-char-change {
        tailf:info "Number of characters change required between old and new passwords";
        tailf:cli-full-command;
        type uint32 {
          tailf:info "<0-253>;;Number of characters change required <0-253>, default is 4";
          range "0..253";
        }
        default 4;
      }

      // aaa password-policy * warn-interval
      container warn-interval {
        tailf:info "Warning interval to notify about expiring password";

        // aaa password-policy * warn-interval days
        leaf days {
          tailf:info "Number of days";
          type uint8 {
            tailf:info "<0-30>;;Number of days";
            range "0..30";
          }
        }
      }

      // aaa password-policy * restrict-username
      leaf restrict-username {
        tailf:info "Restricts the usage of associated username as password";
        type empty;
      }

      // aaa password-policy * restrict-old-count
      leaf restrict-old-count {
        tailf:info "Count on number of old passwords that cannot be reused";
        type uint8 {
          tailf:info "<0-10>;;Represents the history of passwords that cannot be reused now";
          range "0..10";
        }
      }

      // aaa password-policy * authen-max-attempts
      leaf authen-max-attempts {
        tailf:info "Maximum authentication failures to be allowed.";
        type uint8 {
          tailf:info "<1-24>;;Number of attempts, default is 0.";
          range "1..24";
        }
      }

      // aaa password-policy * max-char-repetition
      leaf max-char-repetition {
        tailf:info "Number of times consecutively a character can repeat in the password";
        type uint8 {
          tailf:info "<2-5>;;Number of times a character can repeat <2-5>, default is 0.";
          range "2..5";
        }
      }
    }
  }


  /// ========================================================================
  /// watchdog
  /// ========================================================================

  container watchdog {
    tailf:info "Watchdog configuration commands(cisco-support)";
    //overload   Watchdog monitor configurations(cisco-support)
    // restart    Watchdog restart configurations(cisco-support)
    container threshold {
      tailf:info "Watchdog threshold configuration(cisco-support)";
      container disk {
        tailf:info "Disk thresholds(cisco-support)";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf minor {
          tailf:info "Threshold for minor state(cisco-support)";
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<1-97>;;disk consumption in percentage";
          }
        }
        leaf severe {
          tailf:info "Threshold for severe state (cisco-support)";
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<50-98>;;disk consumption in percentage";
          }
        }
        leaf critical {
          tailf:info "Threshold for critical state (cisco-support)";
          type uint8 {
            tailf:info "<75-99>;;disk consumption in percentage";
          }
        }
      }
      container memory {
        tailf:info "Memory thresholds(cisco-support)";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf minor {
          tailf:info "Threshold for minor state(cisco-support)";
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<5-40>;;memory consumption in percentage";
          }
        }
        leaf severe {
          tailf:info "Threshold for severe state (cisco-support)";
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<4-40>  memory consumption in percentage";
          }
        }
        leaf critical {
          tailf:info "Threshold for critical state (cisco-support)";
          type uint8 {
            tailf:info "<4-40>;;memory consumption in percentage";
          }
        }
      }
    }
  }



  /// ========================================================================
  /// cdp
  /// ========================================================================

  container cdp {
    tailf:info "Enable CDP, or configure global CDP subcommands";
    tailf:cli-display-separated;
    presence true;

    // cdp timer
    leaf timer {
      tailf:info "Specify the rate at which CDP packets are sent (in sec)";
      type uint8 {
        tailf:info "<5-254>;;Rate at which CDP packets are sent (in sec)";
        range "5..254";
      }
    }

    // cdp log adjacency changes
    container log {
      tailf:info "Configure CDP to log Events";
      container adjacency {
        tailf:info "Configure CDP to log adjacency data";
        leaf changes {
          tailf:info "Configure CDP to log changes to adjacency table";
          type empty;
        }
      }
    }

    // cdp advertise v1
    container advertise {
      tailf:info "Specify the version of CDP advertisements";
      leaf v1 {
        tailf:info "CDP sends version-1 advertisements only";
        type empty;
      }
    }

    // cdp holdtime
    leaf holdtime {
      tailf:info "Specify the holdtime (in sec) to be sent in packets";
      type uint8 {
        tailf:info "<10-255>;;Length of time (in sec) that receiver must keep this packet";
        range "10..255";
      }
    }
  }


  /// ========================================================================
  /// grpc
  /// ========================================================================

  // grpc
  container grpc {
    tailf:info "grpc configuration commands";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-grpc";
    tailf:cli-explicit-exit;
    presence true;

    // grpc / port
    leaf port {
      tailf:info "Server listening port";
      type uint16 {
        tailf:info "<10000-57999>;;Server listening port";
        range "10000..57999";
      }
    }

    // grpc / no-tls
    leaf no-tls {
      tailf:info "No TLS";
      type empty;
    }

    // grpc / address-family
    leaf address-family {
      tailf:info "Address family identifier type";
      type enumeration {
        enum ipv4 {
          tailf:info "IPv4 address-family";
        }
        enum ipv6 {
          tailf:info "IPv6 address-family";
        }
        enum dual {
          tailf:info "dual stackaddress-family";
        }
      }
    }

    // grpc / service-layer
    container service-layer {
      tailf:info "grpc service layer configuration";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-grpc-sl";
      presence true;
    }

    // grpc / dscp
    leaf dscp {
      tailf:info "QoS marking DSCP to be set on transmitted gRPC";
      type dscp-type;
    }

    // grpc / vrf
    leaf vrf {
      tailf:info "Server vrf";
      type string {
        tailf:info "WORD;;vrf name";
      }
    }
  }


  /// ========================================================================
  /// fabric
  /// ========================================================================

  // fabric enable mode
  container fabric {
    tailf:info "Configure Fabric";
    container enable {
      tailf:info "Enable fabric operation mode";
      leaf mode {
        tailf:info "Choose mode";
        type enumeration {
          enum A99-highbandwidth {
            tailf:info "A99 High bandwidth cards only";
          }
          enum highbandwidth {
                              tailf:info "High bandwidth cards only";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// ptp
  /// ========================================================================

  // ptp
  container ptp {
    tailf:info "Precision Time Protocol config";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-ptp";
    tailf:cli-explicit-exit;
    presence true;

    // ptp / clock
    container clock {
      tailf:info "PTP Clock Configuration";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-ptp-clock";

      // ptp / clock / domain
      leaf domain {
        tailf:info "The domain number to use for this clock";
        type uint8 {
          tailf:info "<0-255>;;The domain number to use";
        }
      }

      // ptp / clock / profile
      container profile {
        tailf:info "PTP profile configuration";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf name {
          tailf:cli-drop-node-name;
          type enumeration {
            enum "g.8265.1" {
              tailf:info "G.8265.1 telecom profile";
            }
            enum "g.8275.1" {
              tailf:info "G.8275.1 telecom profile";
            }
            enum "g.8275.2" {
              tailf:info "G.8275.2 telecom profile";
            }
          }
        }
        leaf clock-type {
          tailf:info "Clock type for G.8265/G.8275 telecom profiles";
          type enumeration {
            enum T-BC {
              tailf:info "Configure telecom boundary clock";
            }
            enum T-GM {
              tailf:info "Configure telecom grandmaster clock";
            }
            enum T-TSC {
              tailf:info "Configure telecom slave clock";
            }
            enum master {
              tailf:info "Configure master clock";
            }
            enum slave {
              tailf:info "Configure telecom slave clock";
            }
          }
        }
      }

      // ptp / clock / clock-class
      leaf clock-class {
        tailf:info "The clock class to use when advertising this clock";
        type uint8 {
          tailf:info "<0-255>;;The clock class to use";
        }
      }
    }

    // ptp / profile *
    list profile {
      tailf:info "PTP Profile Configuration";
      tailf:cli-mode-name "config-ptp-profile";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Name of Profile";
        }
      }
      uses ptp-profile-grouping;
    }

    // ptp / utc-offset *
    container utc-offset {
      tailf:info "Configure the UTC offset";
      list list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type union {
            type enumeration {
              enum baseline {
                tailf:info "Configure the baseline UTC offset";
              }
            }
            type string {
              tailf:info "WORD;;Date to apply the UTC offset, in ISO 8601 format (YYYY-MM-DD)";
              pattern "[0-9]+.*";
            }
          }
        }
        leaf offset-value {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-32767>;;The UTC offset, in seconds";
            range "0..32767";
          }
        }
      }
    }

    // ptp / frequency priority
    container frequency {
      tailf:info "Precision Time Protocol frequency configuration";
      leaf priority {
        tailf:info "Frequency priority";
        type uint8 {
          tailf:info "<1-254>;;Enter the frequency priority";
          range "1..254";
        }
      }
    }

    // ptp / time-of-day priority
    container time-of-day {
      tailf:info "Precision Time Protocol time-of-day configuration";
      leaf priority {
        tailf:info "Time-of-day priority";
        type uint8 {
          tailf:info "<1-254>;;Enter the time-of-day priority";
          range "1..254";
        }
      }
    }

    // ptp / physical-layer-frequency
    leaf physical-layer-frequency {
      tailf:info "Disable PTP as a source for frequency as only physical layer frequency sources are used";
      type empty;
    }

    // ptp / log
    container log {
      tailf:info "Precision Time Protocol logging configuration";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-ptp-log";

      // ptp / log / servo events
      container servo {
        tailf:info "Servo logging options";
        leaf events {
          tailf:info "Log servo events";
          type empty;
        }
      }

      // ptp / log / best-master-clock
      container best-master-clock {
        tailf:info "Best master clock logging options";
        leaf changes {
          tailf:info "Log best master clock changes";
          type empty;
        }
      }
    }
  }


  /// ========================================================================
  /// tcp
  /// ========================================================================

  container tcp {
    tailf:info "Global TCP configuration commands";
    tailf:cli-explicit-exit;

    // tcp mss
    leaf mss {
      tailf:info "Set the TCP initial maximum segment size";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<68-10000>;;TCP initial maximum segment size";
        range "68..10000";
      }
    }

    // tcp selective-ack
    leaf selective-ack {
      tailf:info "Enable TCP selective-ACK";
      type empty;
    }

    // tcp path-mtu-discovery
    container path-mtu-discovery {
      tailf:info "Enable Path MTU Discovery on new TCP connections";
      tailf:cli-delete-when-empty;
      tailf:cli-reset-container;
      presence true;
      leaf age-timer {
        type union {
          type uint8 {
            tailf:info "<10-30>;;Aging time (in minutes)";
          }
          type enumeration {
            enum infinite {
                           tailf:info "Disable Path MTU aging timer";
            }
          }
        }
      }
    }

    // tcp timestamp
    leaf timestamp {
      tailf:info "Enable TCP timestamp option";
      type empty;
    }

    // tcp directory
    container directory {
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf directory {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "WORD;;Place debug files in this directory";
        }
      }
      leaf files {
        tailf:cli-break-sequence-commands;
        tailf:info "Set maximum debug files";
        type uint16 {
          tailf:info "<1-10000>;;Maximum debug files";
        }
      }
      leaf size {
        tailf:info "Set maximum file size";
        type uint32 {
          tailf:info "<1024-4294967295>;;Maximum file size in bytes";
          range "1024..4294967295";
        }
      }
    }

    // tcp window-size
    leaf window-size {
      tailf:info "TCP receive window size";
      type uint32 {
        tailf:info "<2048-65535>;;Window size (bytes)";
      }
    }

    // tcp synwait-time
    leaf synwait-time {
      tailf:info "Set time to wait on new TCP connections";
      type uint8 {
        tailf:info "<5-30>;;Wait time in seconds";
        range "5..30";
      }
    }

    // tcp accept-rate
    leaf accept-rate {
      tailf:info "Set the maximum TCP connection accept rate(cisco-support)";
      type uint16 {
        tailf:info "<1-1000>;;Connections accepted per second per listen socket (default: 500)";
        range "1..1000";
      }
    }

    // tcp ao
    container ao {
      tailf:info "Enter into TCP authentication option configuration mode";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-tcp-ao";
      presence true;

      // tcp ao / keychain *
      list keychain {
        tailf:info "TCP AO keychain mode";
        tailf:cli-mode-name "config-tcp-ao-keychain";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of the key chain";
          }
        }

        // tcp ao / keychain * / key *
        list key {
          tailf:info "Configure TCP-AO IDs for a Key";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-incomplete-command;
          key id;
          leaf id {
            type string {
              tailf:info "WORD;;Enter 48-bit integer [0 - 281474976710655]";
            }
          }
          leaf SendID {
            tailf:info "Configure SendID to be used for this key";
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-255>;;Value of SendID";
            }
          }
          leaf ReceiveID {
            tailf:info "Configure ReceiveID to be used for this key";
            type uint8 {
              tailf:info "<0-255>;;Value of ReceiveID";
            }
          }
        }
      }
    }

    // tcp num-thread
    container num-thread {
      tailf:info "Set number of threads (takes effect only on process restart)(cisco-support)";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf ingress-threads {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint8 {
          tailf:info "<1-16>;;Ingress threads created by TCP (default: 8)";
        }
      }
      leaf max-threads {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-16>;;max threads in thread pool created by TCP (default: 8)";
        }
      }
    }

    // tcp receive-queue
    leaf receive-queue {
      tailf:info "TCP receive packet queue size(cisco-support)";
      type uint16 {
        tailf:info "<40-800>;;Number of packets in receive queue";
      }
    }

  }


  /// ========================================================================
  /// line
  /// ========================================================================

  container line {
    tailf:info "Line subcommands";
    tailf:cli-explicit-exit;

    // line console
    container console {
      tailf:info "console template";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-line";
      uses line-grouping;
    }

    // line default
    container default {
      tailf:info "default template";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-line";
      uses line-grouping;
    }

    // line template *
    list template {
      tailf:info "user defined template";
      tailf:cli-mode-name "config-line";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Name of template to configure";
        }
      }
      uses line-grouping;
    }
  }


  /// ========================================================================
  /// pool
  /// ========================================================================

  container pool {
    tailf:info "Distributed Address Pool Service";
    tailf:cli-explicit-exit;

    // pool vrf * ipv4 *
    list vrf {
      tailf:info "Specify VRF name";
      tailf:cli-mode-name "config-pool-ipv4";
      key "vrf ipv4";
      leaf vrf {
        type string {
          tailf:info "WORD;;Enter the VRF name";
        }
      }
      leaf ipv4 {
        tailf:info "Specify IPv4 Pool name";
        tailf:cli-expose-key-name;
        type string {
          tailf:info "WORD;;Enter the IPv4 Pool name";
        }
      }

      // pool vrf * ipv4 * / network *
      list network {
        tailf:info "Specify network for allocation";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key prefix;
        leaf prefix {
          type ipv4-prefix {
            tailf:info "A.B.C.D/length;;IP Network";
          }
        }
        leaf default-router {
          tailf:info "Default Gateway for subnet";
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IPv4 Address";
          }
        }
        leaf block {
          tailf:info "block subnet test";
          type empty;
        }
      }

      // pool vrf * ipv4 * / address-range *
      list address-range {
        tailf:info "Specify address range for allocation";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-incomplete-command;
        key first_range;
        leaf first_range {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Specify first address in range";
          }
        }
        leaf last_range {
          tailf:cli-drop-node-name;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Specify last address in range";
          }
        }
        leaf block {
          tailf:info "block address-range";
          type empty;
        }
      }

      // pool vrf * ipv4 * / exclude *
      list exclude {
        tailf:info "Exclude addresses";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-remove-before-change;
        tailf:cli-incomplete-command;
        key first;
        leaf first {
          tailf:cli-suppress-range;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;First exclude address in range";
          }
        }
        leaf last {
          tailf:cli-drop-node-name;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Last exclude address in range (0.0.0.0 means 1 address)";
          }
        }
      }

      // pool vrf * ipv4 * / utilization-mark
      container utilization-mark {
        tailf:info "Specify utilization mark";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf high {
          tailf:info "Specify high mark";
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<0-100>;;Specify numerical value as percentage";
            range "0..100";
          }
        }
        leaf low {
          tailf:info "Specify low mark";
          type uint8 {
            tailf:info "<0-100>;;Specify numerical value as percentage";
            range "0..100";
          }
        }
      }
    }

    // pool vrf * ipv6 *
    container pool-ipv6 {
      tailf:cli-drop-node-name;
      list vrf {
        tailf:info "Specify VRF name";
        tailf:cli-mode-name "config-pool-ipv6";
        key "vrf ipv6";
        leaf vrf {
          type string {
            tailf:info "WORD;;Enter the VRF name";
          }
        }
        leaf ipv6 {
          tailf:info "Specify IPv6 Pool name";
          tailf:cli-expose-key-name;
          type string {
            tailf:info "WORD;;Enter the IPv6 Pool name";
          }
        }

        // pool vrf * ipv6 * / address-range *
        list address-range {
          tailf:info "Specify address range for allocation";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-incomplete-command;
          key first_range;
          leaf first_range {
            tailf:cli-suppress-range;
            type inet:ipv6-address {
              tailf:info "X:X::X;;Enter the first IPv6 address in range";
            }
          }
          leaf last_range {
            tailf:cli-drop-node-name;
            type inet:ipv6-address {
              tailf:info "X:X::X;;Enter the last IPv6 address in range";
            }
          }
          leaf block {
            tailf:info "block address-range";
            type empty;
          }
        }

        // pool vrf * ipv6 * / prefix-length
        leaf prefix-length {
          tailf:info "Specify prefix-length to be used";
          type uint8 {
            tailf:info "<1-128>;;Enter the prefix-length";
            range "1..128";
          }
        }

        // pool vrf * ipv6 * / prefix-range *
        list prefix-range {
          tailf:info "Specify prefix range for allocation";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-remove-before-change;
          key "first last";
          leaf first {
            tailf:cli-suppress-range;
            type inet:ipv6-address {
              tailf:info "X:X::X;;Enter the last IPv6 prefix in range";
            }
          }
          leaf last {
            tailf:cli-suppress-range;
            type inet:ipv6-address {
              tailf:info "X:X::X;;Enter the last IPv6 prefix in range";
            }
          }
        }

        // pool vrf * ipv6 * / network
        leaf network {
          tailf:info "Specify network for allocation";
          type tailf:ipv6-address-and-prefix-length {
            tailf:info "X:X::X/length;;Enter IPv6 prefix";
          }
        }

        // pool vrf * ipv6 * / utilization-mark
        container utilization-mark {
          tailf:info "Specify utilization mark";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf high {
            tailf:info "Specify high mark";
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-100>;;Specify numerical value as percentage";
              range "0..100";
            }
          }
          leaf low {
            tailf:info "Specify low mark";
            type uint8 {
              tailf:info "<0-100>;;Specify numerical value as percentage";
              range "0..100";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// vty-pool
  /// ========================================================================

  container vty-pool {
    tailf:info "VTY Pools";
    tailf:cli-explicit-exit;

    // vty-pool default
    container default {
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      uses vty-pool-grouping;
    }

    // vty-pool eem
    container eem {
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      uses vty-pool-grouping;
    }

    // vty-pool *
    list pool-name-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-incomplete-command;
      key pool-name;
      leaf pool-name {
        tailf:cli-disallow-value "(eem|default)";
        type string {
          tailf:info "WORD;;VTY range";
        }
      }
      uses vty-pool-grouping;
    }
  }


  /// ========================================================================
  /// aps
  /// ========================================================================

  container aps {
    tailf:info "Configure SONET Automatic Protection Switching (APS)";
    tailf:cli-explicit-exit;

    // aps group *
    list group {
      tailf:info "APS group to configure";
      tailf:cli-mode-name "config-aps";
      key id;
      leaf id {
        type uint8 {
          tailf:info "<1-255>;;Group number";
          range "1..255";
        }
      }

      // aps group * / revert
      leaf revert {
        tailf:info "Set revertive operation";
        type uint8 {
          tailf:info "<0-255>;;Revert time in minutes (default = 0 - non-revertive APS)";
        }
      }

      // aps group * / timers
      container timers {
        tailf:info "Set APS W-P communication timers";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf hello {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<1-255>;;Hello timer in seconds (default 1)";
            range "1..255";
          }
        }
        leaf hold {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<1-255>;;Hold timer in seconds (default 3)";
            range "1..255";
          }
        }
      }

      // aps group * / channel *
      list channel {
        tailf:info "Assign a channel to an APS group";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands  {
          tailf:cli-reset-siblings;
        }
        key "id location";
        leaf id {
          type uint8 {
            tailf:info "<0-1>;;Channel number (0 = Protect, 1 = Working)";
            range "0..1";
          }
        }
        leaf location {
          type enumeration {
            enum local {
                        tailf:info "Channel assignment to a local port";
            }
            enum remote {
                         tailf:info "Channel assignment to a remote router port";
            }
          }
        }
        leaf preconfigure {
          tailf:info "Specify a preconfig";
          tailf:cli-optional-in-sequence;
          type empty;
        }
        leaf data {
          tailf:cli-drop-node-name;
          type union {
            type string {
              tailf:info "SONET;;SONET/SDH Port controller(s)";
            }
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Remote router IP address";
            }
          }
        }
      }
    }

    // aps rprplus
    leaf rprplus {
      tailf:info "APS extend hold timer for failover";
      tailf:cli-full-command;
      type empty;
    }
  }


  /// ========================================================================
  /// platform
  /// ========================================================================

  container platform {
    tailf:info "platform specific configuration";
    tailf:cli-explicit-exit;

    // platform ip
    container ip {
      tailf:info "ip keyword";
      container cef {
        tailf:info "cef keyword";
        leaf load-sharing {
          tailf:info "load balancing";
          type enumeration {
            enum dst-only {
              tailf:info "load balancing algorithm to include destination IP/L4 port";
            }
            enum full {
                       tailf:info "default load balancing algorithm to include src/dst IPs/L4 ports";
            }
            enum ip-only {
              tailf:info "load balancing algorithm to include src/dst IP";
            }
          }
        }
      }
    }
    container qos {
      tailf:info "qos keyword";
      leaf "qos-10g-only" {
        tailf:alt-name "10g-only";
        tailf:info "qos pure 10G mode";
        type empty;
      }
      list protocol {
        tailf:info "protocol keyword";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        key proto;
        leaf proto {
          type enumeration {
            enum isis;
            enum eigrp;
            enum ldp;
            enum ospf;
            enum rip;
            enum bgp;
            enum hsrp;
            enum bfd;
            enum ospfv3;
            enum bgpv2;
            enum ripng;
            enum neigh-discover;
            enum wlccp;
            enum rsvp;
            enum rsvpv6;
            enum arp;
            enum gre {
                      tailf:info "gre (ipv4 and ipv6)";
            }
            enum mpls {
                       tailf:info "mpls packet";
            }
          }
        }

        choice proto-choice {
          leaf pass-through {
            tailf:info "pass-through keyword";
            type empty;
          }
          container police {
            tailf:info "police keyword";
            tailf:cli-compact-syntax;
            tailf:cli-reset-container;
            tailf:cli-sequence-commands;
            leaf bit-rate {
              tailf:cli-drop-node-name;
              type uint64 {
                tailf:info "<32000-128000000000>;;Target Bit Rate (bits per second) "
                  +"(postfix k, m, g optional; decimal point allo";
                range "32000..128000000000";
              }
            }

            leaf burst {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<1-2000000000>;;Normal burst bytes";
                range "1..2000000000";
              }
            }
          }
          container precedence {
            tailf:info "change ip-precedence(used to map the dscp to cos value)";
            tailf:cli-compact-syntax;
            tailf:cli-reset-container;
            tailf:cli-sequence-commands;
            leaf cos {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<0-7>;;new cos value";
                range "0..7";
              }
            }
            leaf bit-rate {
              tailf:cli-drop-node-name;
              type uint64 {
                tailf:info "<32000-128000000000>;;Target Bit Rate (bits per second) "
                  +"(postfix k, m, g optional; decimal point allo";
                range "32000..128000000000";
              }
            }
            leaf burst {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<1-2000000000>;;Normal burst bytes";
                range "1..2000000000";
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// control-plane
  /// ========================================================================

  container control-plane {
    tailf:info "Configure Control Plane";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-ctrl";
    tailf:cli-explicit-exit;

    // control-plane / management-plane
    container management-plane {
      tailf:info "Configure management plane protection";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-mpp";

      // control-plane / management-plane / inband
      container inband {
        tailf:info "Configure an inband interface/protocol";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-mpp-inband";

        // control-plane / management-plane / inband / interface *
        list interface {
          tailf:info "Configure an inband interface";
          tailf:cli-mode-name "config-mpp-inband-xxx";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Interface Name";
            }
          }

          // control-plane / management-plane / inband / interface * / allow *
          list allow {
            tailf:info "Allow a protocol on this interface";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-full-command;
            key proto;
            leaf proto {
              type control-plane-proto;
            }
          }

          // control-plane / management-plane / inband / interface * / allow * peer
          uses mpp-ioband-if-allow-peer-grouping;
        }
      }

      // control-plane / management-plane / out-of-band
      container out-of-band {
        tailf:info "Configure an out-of-band interface/protocol";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-mpp-outband";

        // control-plane / management-plane / out-of-band / vrf
        leaf vrf {
          tailf:info "configure mpp outband vrf";
          type string {
            tailf:info "WORD;;Enter vrf name";
          }
        }

        // control-plane / management-plane / out-of-band / interface *
        list interface {
          tailf:info "Configure an outband interface";
          tailf:cli-mode-name "config-mpp-outband-if";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Interface Name";
            }
          }

          // control-plane / management-plane / out-of-band / interface * / allow *
          list allow {
            tailf:info "Allow a protocol on this interface";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key proto;
            leaf proto {
              type control-plane-proto;
            }
          }

          // control-plane / management-plane / out-of-band / interface * / allow * peer
          uses mpp-ioband-if-allow-peer-grouping;
        }
      }
    }

    // control-plane / local control-packets
    container local {
      tailf:info "Locally originated packets";
      container control-packets {
        tailf:info "Control packets generated by OSPF etc";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-locp";

        // control-plane / local control-packets / copy precedence qos-group
        container copy {
          tailf:info "Copy the field from the packet header";
          container precedence {
            tailf:info "Precedence value in the packet header";
            leaf qos-group {
              tailf:info "Set the qos-group field in locally originated control packets";
              type empty;
            }
          }
        }
      }
    }
  }

  typedef control-plane-proto {
    type enumeration {
      enum HTTP {
        tailf:info "HTTP(S)";
      }
      enum NETCONF {
        tailf:info "NETCONF version 1.1 protocol";
      }
      enum SNMP {
        tailf:info "SNMP (all versions)";
      }
      enum SSH {
        tailf:info "Secure Shell (v1 & v2)";
      }
      enum TFTP {
        tailf:info "Enable TFTP";
      }
      enum Telnet {
        tailf:info "Telnet";
      }
      enum XML {
        tailf:info "XML";
      }
      enum all {
        tailf:info "All Protocols";
      }
    }
  }

  // control-plane / management-plane / inband / interface * /
  // control-plane / management-plane / out-of-band / interface * /
  grouping mpp-ioband-if-allow-peer-grouping {
    container allow-peer {
      tailf:cli-drop-node-name;
      container allow {
        tailf:info "Allow a protocol on this interface";
        container HTTP {
          tailf:info "HTTP(S)";
          uses mpp-ioband-if-allow-addr-grouping;
        }
        container NETCONF {
          tailf:info "NETCONF version 1.1 protocol";
          uses mpp-ioband-if-allow-addr-grouping;
        }
        container SNMP {
          tailf:info "SNMP (all versions)";
          uses mpp-ioband-if-allow-addr-grouping;
        }
        container SSH {
          tailf:info "Secure Shell (v1 & v2)";
          uses mpp-ioband-if-allow-addr-grouping;
        }
        container TFTP {
          tailf:info "Enable TFTP";
          uses mpp-ioband-if-allow-addr-grouping;
        }
        container Telnet {
          tailf:info "Telnet";
          uses mpp-ioband-if-allow-addr-grouping;
        }
        container XXML {
          tailf:info "XML";
          tailf:alt-name XML;
          uses mpp-ioband-if-allow-addr-grouping;
        }
        container all {
          tailf:info "All Protocols";
          uses mpp-ioband-if-allow-addr-grouping;
        }
      }
    }
  }


  // control-plane / management-plane / inband / interface * / allow * peer /
  grouping mpp-ioband-if-allow-addr-grouping {
    container peer {
      tailf:info "Configure peer address on this interface";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-mpp-band-allow-peer";

      // control-plane / management-plane / inband / interface * / allow * peer / address ipv4 *
      // control-plane / management-plane / inband / interface * / allow * peer / address ipv6 *
      container address {
        tailf:info "Configure peer address on this interface";
        list ipv4 {
          tailf:info "Configure peer IPv4 address on this interface";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key prefix;
          leaf prefix {
            type union {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Enter IPv4 address";
              }
              type ipv4-prefix {
                tailf:info "A.B.C.D/length;;Enter IPv4 address with prefix";
              }
            }
          }
        }
        list ipv6 {
          tailf:info "Configure peer IPv6 address on this interface";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key prefix;
          leaf prefix {
            type union {
              type inet:ipv6-address {
                tailf:info "X:X::X;;Enter IPv6 address";
              }
              type tailf:ipv6-address-and-prefix-length {
                tailf:info "X:X::X/length;;Enter IPv6 address with prefix";
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// ip
  /// ========================================================================

  container ip {
    tailf:info "Global IP configuration subcommands";
    tailf:cli-explicit-exit;

    // no ip domain-lookup
    container domain-lookup {
      tailf:info "Enable IP Domain Name System hostname translation";
      leaf do-lookup {
        tailf:cli-drop-node-name;
        type boolean;
        tailf:cli-boolean-no;
        default true;
      }
      leaf nsap {
        tailf:info "Enable IP DNS queries for CLNS NSAP addresses";
        type empty;
      }
    }

    // ip domain-name
    leaf domain-name {
      tailf:info "Define the default domain name";
      type string {
        tailf:info "WORD;;Default domain name";
      }
    }

    // ip forward-protocol
    container forward-protocol {
      tailf:info "Controls forwarding of physical and directed IP broadcasts";
      leaf nd {
        tailf:info "Sun's Network Disk protocol";
        type empty;
      }
      leaf sdns {
        tailf:info "Network Security Protocol";
        type empty;
      }
      leaf spanning-tree {
        tailf:info "Use transparent bridging to flood UDP broadcasts";
        type empty;
      }
      leaf turbo-flood {
        tailf:info "Fast flooding of UDP broadcasts";
        type empty;
      }
      leaf udp {
        tailf:info "Packets to a specific UDP port";
        type empty;
      }


    }

    // ip http
    container http {
      tailf:info "HTTP server configuration";
      leaf server {
        tailf:info "Enable http server";
        tailf:cli-boolean-no;
        type boolean;
        default true;
      }

      leaf secure-server {
        tailf:info "Enable https server";
        tailf:cli-boolean-no;
        type boolean;
        default true;
      }
    }

    // ip pim
    container pim {
      tailf:info "PIM global commands";
      container ssm {
        tailf:info "Configure Source Specific Multicast";
        choice ssm-choice {
          leaf default {
            tailf:info "Use 232/8 group range for SSM";
            type empty;
          }
          leaf range {
            tailf:info "ACL for group range to be used for SSM";
            type union {
              type uint8 {
                tailf:info "<1-99>;;Access list number";
                range "1..99";
              }
              type string {
                tailf:info "WORD;;IP named access list";
              }
            }
          }
        }
      }
    }

    // ip route
    container route {
      tailf:info "Establish static routes";
      container vrf {
        tailf:info "Configure static route for a VPN Routing/Forwarding instance";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf name {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;VPN Routing/Forwarding instance name";
          }
        }
        leaf dest {
          tailf:cli-drop-node-name;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Destination prefix";
          }
        }
        leaf dest-mask {
          tailf:cli-drop-node-name;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Destination prefix mask";
          }
        }
        choice vrf-choice {
          leaf forwarding-address {
            tailf:cli-drop-node-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Forwarding router's address";
            }
          }
          leaf GigabitEthernet {
            tailf:info "GigabitEthernet IEEE 802.3z";
            tailf:cli-allow-join-with-value {
              tailf:cli-display-joined;
            }
            tailf:cli-suppress-leafref-in-diff;
            tailf:non-strict-leafref {
              path "/cisco-ios-xr:interface/GigabitEthernet/id";
            }
            type string {
              tailf:info "WORD;;interface id";
            }
          }
        }
      }
    }

    // ip multicast-routing
    container multicast-routing {
      tailf:info "Enable IP multicast forwarding";
      presence true;
      tailf:cli-display-separated;
      leaf-list vrf {
        tailf:info "Select VPN Routing/Forwarding instance";
        tailf:cli-list-syntax;
        type string {
          tailf:info "WORD;;VPN Routing/Forwarding instance name";
        }
      }
    }

    // ip multicast
    container multicast {
      tailf:info "Global IP Multicast Commands";
      list vrf {
        tailf:info "Select VPN Routing/Forwarding instance";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;VPN Routing/Forwarding instance name";
          }
        }
        container route-limit {
          tailf:info "Maximum number of multicast routes";
          tailf:cli-sequence-commands  {
            tailf:cli-reset-siblings;
          }
          tailf:cli-compact-syntax;
          leaf nr-routes {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-2147483647>;;number of routes";
              range "1..2147483647";
            }
          }
          leaf threshold {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-2147483647>;;Threshold at which to generate warning message";
              range "1..2147483647";
            }
          }
        }
      }
    }

    // ip tftp
    container tftp {
      tailf:info "tftp configuration commands";
      container source-interface {
        tailf:info "Specify interface for source address in TFTP connections";
        uses interface-name-grouping;
      }
    }

    // ip ssh
    container ssh {
      tailf:info "Configure ssh options";
      leaf logging {
        tailf:info "Configure logging for SSH";
        type enumeration {
          enum events {
                       tailf:info "Log SSH events";
          }
        }
      }
      leaf version {
        tailf:info "Specify protocol version to be supported";
        type uint8 {
          tailf:info "<1-2>;;Protocol version";
          range "1..2";
        }
      }
    }

  }


  /// ========================================================================
  /// mirror
  /// ========================================================================

  container mirror {
    tailf:info "disk mirror enable command";

    // mirror location *
    list location {
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        tailf:cli-multi-word-key;
        type string {
          tailf:info "WORD;;Fully qualified location specification";
        }
      }
    }
  }


  /// ========================================================================
  /// ipv4
  /// ========================================================================

  container ipv4 {
    tailf:info "Global IPv4 configuration commands";
    tailf:cli-explicit-exit;

    // ipv4 netmask-format bit-count
    container netmask-format {
      tailf:info "Display mode of ipv4 address mask";
      leaf bit-count {
        tailf:info "Display ipaddess mask in prefix length format";
        type empty;
      }
    }

    // ipv4 assembler
    container assembler {
      tailf:info "IPv4 Fragmented Packet Assembler";

      // ipv4 assembler max-packets
      leaf max-packets {
        tailf:info "Maxinum packets allowed in assembly queues";
        type uint8 {
          tailf:info "<1-50>;;Percentage of total packets available in the system (default: 1000 packets)";
          range "1..50";
        }
      }

      // ipv4 assembler timeout
      leaf timeout {
        tailf:info "Number of seconds an assembly queue will hold before timeout";
        type uint8 {
          tailf:info "<1-120>;;Number of seconds an assembly queue will hold before timeout";
          range "1..120";
        }
      }
    }

    // ipv4 access-list
    container access-list {
      tailf:info "Configure access lists";

      // ipv4 access-list log-update
      container log-update {
        tailf:info "Control access lists log updates";

        // ipv4 access-list log-update rate
        leaf rate {
          tailf:info "Set access-list logging rate (num. logs per second)";
          type uint16 {
            tailf:info "<1-1000>;;rate (num. logs per second)";
            range "1..1000";
          }
        }

        // ipv4 access-list log-update threshold
        leaf threshold {
          tailf:info "Set access-list logging threshold";
          type uint32 {
            tailf:info "<1-2147483647>;;Log update threshold (number of hits)";
            range "1..2147483647";
          }
        }
      }

      // ipv4 access-list *
      list named-acl {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        tailf:cli-no-key-completion;
        tailf:cli-mode-name "config-ipv4-acl";
        key name;
        leaf name {
          tailf:cli-disallow-value "log-update";
          type string {
            tailf:info "WORD;;User selected string identifying this access list";
          }
        }

        // ipv4 access-list * / apply-group
        uses apply-group-grouping;

        // ipv4 access-list * / *
        list rule {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key id;
          leaf id {
            type uint32 {
              tailf:info "<1-2147483644>;;Sequence number for this entry";
            }
          }
          leaf line {
            tailf:cli-drop-node-name;
            tailf:cli-multi-value;
            type string {
              tailf:info "deny|permit|remark <parameters>";
              pattern "(deny.*)|(permit.*)|(remark.*)|(no.*)";
            }
          }
        }
      }
    }

    // ipv4 unnumbered
    container unnumbered {
      tailf:info "Enable IPv4 processing without an explicit address";
      container mpls {
        tailf:info "Configure MPLS routing protocol parameters";
        container traffic-eng {
          tailf:info "IPv4 commands for MPLS Traffic Engineering";
          uses interface-name-grouping;
        }
      }
    }

    // ipv4 virtual
    container virtual {
      tailf:info "IPv4 virtual address for management interfaces options";

      // ipv4 virtual address *
      container address {
        tailf:info "IPv4 virtual address for management interfaces";
        list address-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key "address mask";
          leaf address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IPv4 address";
            }
          }
          leaf mask {
            type inet:ipv4-address {
              tailf:info "IP subnet mask";
            }
          }
        }
        list cidr-address-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key prefix;
          leaf prefix {
            type ipv4-prefix {
              tailf:info "A.B.C.D/length;;IPv4 Prefix";
            }
          }
        }

        // ipv4 virtual address use-as-src-addr
        leaf use-as-src-addr {
          tailf:info "Use as default src address on sourced packets?";
          type empty;
        }

        // ipv4 virtual address vrf * *
        list vrf {
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type string {
              tailf:info "Select VRF for which the virtual ip address is configured";
            }
          }
          list address-list {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key "address mask";
            leaf address {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IPv4 address";
              }
            }
            leaf mask {
              type inet:ipv4-address {
                tailf:info "IP subnet mask";
              }
            }
          }
          list cidr-address-list {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key prefix;
            leaf prefix {
              type ipv4-prefix {
                tailf:info "A.B.C.D/length;;IPv4 Prefix";
              }
            }
          }
        }
      }
    }

    // ipv4 conflict-policy
    // ipv4 prefix-list *
    uses ipv4-ipv6-common-grouping;

    // ipv4 source-route
    leaf source-route {
      tailf:info "Process packets with source routing header options";
      tailf:cli-full-command;
      type empty;
    }


  }


  /// ========================================================================
  /// ipv6
  /// ========================================================================

  container ipv6 {
    tailf:info "Global IPv6 configuration commands";
    tailf:cli-explicit-exit;

    // ipv6 assembler
    container assembler {
      tailf:info "IPv6 Fragmented Packet Assembler";

      // ipv6 assembler max-packets
      leaf max-packets {
        tailf:info "Maxinum packets allowed in assembly queues";
        type uint8 {
          tailf:info "<1-50>;;Percentage of total packets available in the system (default: 1000 packets)";
          range "1..50";
        }
      }

      // ipv6 assembler timeout
      leaf timeout {
        tailf:info "Number of seconds an assembly queue will hold before timeout";
        type uint8 {
          tailf:info "<1-120>;;Number of seconds an assembly queue will hold before timeout";
          range "1..120";
        }
      }
    }

    // ipv6 unicast-routing
    leaf unicast-routing {
      tailf:info "Enable unicast routing";
      type empty;
    }

    // ipv6 icmp error-interval
    container icmp {
      tailf:info "Configure ICMP parameters";
      container error-interval {
        tailf:info "Interval between ICMP error messages";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf interval {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<0-2147483647>;;Interval between tokens in milliseconds";
            range "0..2147483647";
          }
        }
        leaf size {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-200>;;Bucket size";
            range "1..200";
          }
        }
      }
    }

    // ipv6 hop-limit
    leaf hop-limit {
      tailf:info "Configure hop count limit";
      type uint8 {
        tailf:info "<1-255>;;Hop Limit value";
        range "1..255";
      }
    }

    // ipv6 path-mtu
    container path-mtu {
      tailf:info "IPv6 path-mtu configuration";

      // ipv6 path-mtu enable
      leaf enable {
        tailf:info "Enable ipv6 path-mtu feature";
        type empty;
      }

      // ipv6 path-mtu timeout
      leaf timeout {
        tailf:info "Configure path-mtu timeout value";
        type uint8 {
          tailf:info "<1-15>;;path-mtu timeout value in minutes";
          range "1..15";
        }
      }
    }

    // ipv6 virtual address
    container virtual {
      tailf:info "virtual address for management interfaces options";
      container address {
        tailf:info "virtual address for management interfaces";

        // ipv6 virtual address ?
        leaf address {
          tailf:cli-drop-node-name;
          tailf:cli-full-command;
          type tailf:ipv6-address-and-prefix-length {
            tailf:info "X:X::X/length;;IPv6 address/prefix";
          }
        }

        // ipv6 virtual address use-as-src-addr
        leaf use-as-src-addr {
          tailf:info "Use as default src address on sourced packets?";
          type empty;
        }

        // ipv6 virtual address vrf *
        list vrf {
          tailf:info "Select VRF for which the virtual ip address is configured";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;A VRF name";
            }
          }
          leaf address {
            tailf:cli-drop-node-name;
            tailf:cli-full-command;
            type tailf:ipv6-address-and-prefix-length {
              tailf:info "X:X::X/length;;IPv6 address/prefix";
            }
          }
        }
      }
    }

    // ipv6 access-list
    container access-list {
      tailf:info "Configure access lists";

      // ipv6 access-list log-update
      container log-update {
        tailf:info "Control access lists log updates";

        // ipv6 access-list log-update rate
        leaf rate {
          tailf:info "Set access-list packet match logging rate";
          type uint16 {
            tailf:info "<1-1000>;;rate (num. logs per second)";
            range "1..1000";
          }
        }

        // ipv6 access-list log-update threshold
        leaf threshold {
          tailf:info "Set access-list logging threshold";
          type uint32 {
            tailf:info "<1-2147483647>;;Access list log-update threshold (number of hits)";
            range "1..2147483647";
          }
        }
      }

      // ipv6 access-list *
      list named-acl {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        tailf:cli-no-key-completion;
        tailf:cli-mode-name "config-ipv6-acl";
        key name;
        leaf name {
          tailf:cli-disallow-value "log-update";
          type string {
            tailf:info "WORD;;User selected string identifying this access list";
          }
        }
        list rule {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key id;
          leaf id {
            type uint32 {
              tailf:info "<1-2147483644>;;Sequence number for this entry";
            }
          }
          leaf line {
            tailf:cli-drop-node-name;
            tailf:cli-multi-value;
            type string {
              tailf:info "deny|permit|remark <parameters>";
              pattern "(deny.*)|(permit.*)|(remark.*)|(no.*)";
            }
          }
        }
      }
    }

    // ipv6 multicast
    container multicast {
      tailf:info "Configure multicast related commands";
      container rpf {
        tailf:info "Configure multicast RPF related commands";
        container backoff {
          tailf:info "Backoff delay after unicast routing change";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf initial {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<200-65535>;;Initial RPF backoff delay in milliseconds";
              range "200..65535";
            }
          }
          leaf max-backoff-delay {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<200-65535>;;Maximum RPF backoff delay in milliseconds";
              range "200..65535";
            }
          }
        }
        leaf use-bgp {
          tailf:info "Use BGP routes for multicast RPF lookup";
          type empty;
        }
      }
    }

    // ipv6 conflict-policy
    // ipv6 prefix-list *
    uses ipv4-ipv6-common-grouping;

    // ipv6 mobile
    container mobile {
      tailf:info "MobileIP configuration";

      // ipv6 mobile pmipv6-domain *
      list pmipv6-domain {
        tailf:info "PMIPv6 domain configuration";
        tailf:cli-mode-name "config-pmipv6-domain";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Domain Name";
          }
        }

        // ipv6 mobile pmipv6-domain * / nai *
        list nai {
          tailf:info "Network access identifier or Realm";
          tailf:cli-mode-name "config-pmipv6-domain-nai";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;MN Identifier";
            }
          }

          // ipv6 mobile pmipv6-domain * / nai * / network
          leaf network {
            tailf:info "Network name (Address pool) for this MN";
            type string {
              tailf:info "WORD;;Network name";
            }
          }

          // ipv6 mobile pmipv6-domain * / nai * / service
          leaf service {
            tailf:info "Service type for this MN";
            type enumeration {
              enum dual {
                tailf:info "dual service type";
              }
              enum ipv4 {
                tailf:info "ipv4 service type";
              }
              enum ipv6 {
                tailf:info "ipv6 service type";
              }
            }
          }

          // ipv6 mobile pmipv6-domain * / nai * / customer
          leaf customer {
            tailf:info "Customer name for this MN";
            type string {
              tailf:info "WORD;;Customer name";
            }
          }
        }
      }

      // ipv6 mobile pmipv6-lma * domain *
      list pmipv6-lma {
        tailf:info "PMIPv6 LMA configuration";
        tailf:cli-mode-name "config-pmipv6-lma";
        key "name domain";
        leaf name {
          type string {
            tailf:info "WORD;;LMA name";
          }
        }
        leaf domain {
          tailf:cli-expose-key-name;
          tailf:info "PMIPv6 domain for this LMA";
          type string {
            tailf:info "WORD;;Domain name";
          }
        }

        // ipv6 mobile pmipv6-lma * domain * / heartbeat
        uses ipv6-mobile-heartbeat-grouping;

        // ipv6 mobile pmipv6-lma * domain * / aaa accounting
        container aaa {
          tailf:info "aaa config attributes for this LMA";
          container accounting {
            tailf:info "AAA accounting for this LMA";
            tailf:cli-delete-when-empty;
            presence true;
            // ipv6 mobile pmipv6-lma * domain * / aaa accounting interim
            leaf interim {
              tailf:info "Send interim accounting update messages";
              type uint32 {
                tailf:info "<1-86400>;;Interim acounting interval(in minutes)";
                range "1..86400";
              }
            }
          }
        }

        // ipv6 mobile pmipv6-lma * domain * / bce
        container bce {
          tailf:info "LMA binding attributes";
          // ipv6 mobile pmipv6-lma * domain * / bce maximum
          leaf maximum {
            tailf:info "Maximum bindings permitted";
            type uint32 {
              tailf:info "<1-128000>;;Specify max. number of bindings";
              range "1..128000";
            }
          }
          // ipv6 mobile pmipv6-lma * domain * / bce lifetime
          leaf lifetime {
            tailf:info "Maximum bce lifetime permitted";
            type uint16 {
              tailf:info "<10-65535>;;Specify in seconds";
              range "10..65535";
            }
          }
        }

        // ipv6 mobile pmipv6-lma * domain * / dscp control-plane
        container dscp {
          tailf:info "DSCP for packets originating from this LMA";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf control-plane {
            tailf:info "DSCP value for control plane messages";
            type uint8 {
              tailf:info "<1-63>;;Specify the DSCP value";
              range "1..63";
            }
          }
          leaf force {
            tailf:info "Force DSCP from incoming packets into outgoing packets";
            type empty;
          }
        }

        // ipv6 mobile pmipv6-lma * domain * / redistribute home-address
        container redistribute {
          tailf:info "Redistribute routes";
          leaf home-address {
            tailf:info "Redistribute HoA/HNP routes";
            type enumeration {
              enum disable {
                tailf:info "Disable redistribution of HoA/HNP host and pool refix routes";
              }
              enum host-prefix {
                tailf:info "Redistribute HoA/HNP host prefix routes";
              }
            }
          }
        }

        // ipv6 mobile pmipv6-lma * domain * / dynamic mag learning
        container dynamic {
          tailf:info "enable dynamic mag learning for LMA";
          container mag {
            tailf:info "learn mag dynamically for this LMA";
            leaf learning {
              tailf:info "learn mag dynamically for this LMA";
              type empty;
            }
          }
        }

        // ipv6 mobile pmipv6-lma * domain * / enforce heartbeat-to-mag
        container enforce {
          tailf:info "enforce heartbeat values to MAG";
          leaf heartbeat-to-mag {
            tailf:info "send heartbeat values to MAG";
            type empty;
          }
        }

        // ipv6 mobile pmipv6-lma * domain * / mobility-service mobile-local-loop
        container mobility-service {
          tailf:info "Service of this LMA";
          container mobile-local-loop {
            tailf:info "Wireless Private Routing service";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-ipv6-lma-mll";
            presence true;

            // ipv6 mobile pmipv6-lma * domain * / mobility-service mobile-local-loop / ignore home-address
            container ignore {
              tailf:info "ignore options for mobile local loop service";
              leaf home-address {
                tailf:info "ignore home address option with mobile local loop service";
                type empty;
              }
            }

            // ipv6 mobile pmipv6-lma * domain * / mobility-service mobile-local-loop / mnp
            uses ipv6-mobile-mnp-grouping;

            // ipv6 mobile pmipv6-lma * domain * / mobility-service mobile-local-loop / customer * vrf *
            list customer {
              tailf:info "customer configuration on this mobile local loop service";
              tailf:cli-mode-name "config-ipv6-pmipv6-mll-cust";
              key "name vrf";
              leaf name {
                type string {
                  tailf:info "WORD;;Customer name";
                }
              }
              leaf vrf {
                tailf:cli-expose-key-name;
                tailf:info "Vrf for this customer";
                type vrf-type;
              }

              // ipv6 mobile pmipv6-lma * domain * / mobility-service mobile-local-loop / customer * vrf * / bce lifetime
              container bce {
                tailf:info "Customer specific binding attributes";
                leaf lifetime {
                  tailf:info "Maximum bce lifetime permitted";
                  type uint16 {
                    tailf:info "<10-65535>;;Specify in seconds";
                    range "10..65535";
                  }
                }
              }

              // ipv6 mobile pmipv6-lma * domain * / mobility-service mobile-local-loop / customer * vrf * / gre-key symmetric
              container gre-key {
                tailf:info "Customer specific GRE key";
                leaf symmetric {
                  tailf:info "Customer specific symmetric GRE key";
                  type uint32 {
                    tailf:info "<1-4294967295>;;GRE key value";
                  }
                }
              }

              // ipv6 mobile pmipv6-lma * domain * / mobility-service mobile-local-loop / customer * vrf * / bandwidth aggregate
              container bandwidth {
                tailf:info "Bandwidth allocated to this customer";
                leaf aggregate {
                  tailf:info "Aggregate bandwidth across all logical MNs";
                  type uint32 {
                    tailf:info "<1-4294967295>;;Bandwidth in kbps";
                  }
                }
              }

              // ipv6 mobile pmipv6-lma * domain * / mobility-service mobile-local-loop / customer * vrf * / mnp
              uses ipv6-mobile-mnp-grouping;

              // ipv6 mobile pmipv6-lma * domain * / mobility-service mobile-local-loop / customer * vrf * / network
              container network {
                tailf:info "network parameters for the customer";

                // ipv6 mobile pmipv6-lma * domain * / mobility-service mobile-local-loop / customer * vrf * / network authorized *
                list authorized {
                  tailf:info "not authorize the network prefixes";
                  tailf:cli-mode-name "config-pmipv6-mll-cust-network";
                  key name;
                  leaf name {
                    type string {
                      tailf:info "WORD;;ASCII string";
                    }
                  }

                  // ipv6 mobile pmipv6-lma * domain * / mobility-service mobile-local-loop / customer * vrf * / network authorized * / pool
                  container pool {
                    tailf:info "Pool configs for this network";

                    // ipv6 mobile pmipv6-lma * domain * / mobility-service mobile-local-loop / customer * vrf * / network authorized * / pool mobile-node
                    container mobile-node {
                      tailf:info "pool configs for the mobile nodes";
                      container ipv4 {
                        tailf:info "ipv4 pool";
                        tailf:cli-compact-syntax;
                        tailf:cli-sequence-commands;
                        leaf start-address {
                          tailf:info "ipv4 pool start address";
                          tailf:cli-incomplete-command;
                          type inet:ipv4-address {
                            tailf:info "A.B.C.D;;Pool IPv4 start address";
                          }
                        }
                        leaf pool-prefix {
                          tailf:info "ipv4 pool prefix";
                          type uint8 {
                            tailf:info "<8-30>;;IPv4 Pool Prefix value";
                            range "8..30";
                          }
                        }
                      }
                      container ipv6 {
                        tailf:info "ipv6 pool";
                        tailf:cli-compact-syntax;
                        tailf:cli-sequence-commands;
                        leaf start-address {
                          tailf:info "ipv6 pool start address";
                          tailf:cli-incomplete-command;
                          type inet:ipv6-address {
                            tailf:info "X:X::X;;Pool IPv6 start address";
                          }
                        }
                        leaf pool-prefix {
                          tailf:info "ipv6 pool prefix";
                          type uint8 {
                            tailf:info "<8-62>;;IPv6 Pool Prefix value";
                            range "8..62";
                          }
                        }
                      }
                    }

                    // ipv6 mobile pmipv6-lma * domain * / mobility-service mobile-local-loop / customer * vrf * / network authorized * / pool mobile-network
                    container mobile-network {
                      tailf:info "pool configs for the mobile network";
                      container ipv4 {
                        tailf:info "ipv4 pool";
                        tailf:cli-compact-syntax;
                        tailf:cli-sequence-commands;
                        leaf start-address {
                          tailf:info "ipv4 network pool start address";
                          tailf:cli-incomplete-command;
                          type inet:ipv4-address {
                            tailf:info "A.B.C.D;;Pool IPv4 start address";
                          }
                        }
                        leaf pool-prefix {
                          tailf:info "ipv4 pool prefix";
                          tailf:cli-incomplete-command;
                          type uint8 {
                            tailf:info "<8-30>;;IPv4 Pool Prefix value";
                            range "8..30";
                          }
                        }
                        leaf network-prefix {
                          tailf:info "ipv4 network prefix";
                          type uint8 {
                            tailf:info "<8-32>;;IPv4 Network Prefix value";
                            range "8..32";
                          }
                        }
                      }
                      container ipv6 {
                        tailf:info "ipv6 pool";
                        tailf:cli-compact-syntax;
                        tailf:cli-sequence-commands;
                        leaf start-address {
                          tailf:info "ipv6 network pool start address";
                          tailf:cli-incomplete-command;
                          type inet:ipv6-address {
                            tailf:info "X:X::X;;Pool IPv6 start address";
                          }
                        }
                        leaf pool-prefix {
                          tailf:info "ipv6 pool prefix";
                          tailf:cli-incomplete-command;
                          type uint8 {
                            tailf:info "<8-64>;;IPv6 Pool Prefix value";
                            range "8..64";
                          }
                        }
                        leaf network-prefix {
                          tailf:info "ipv6 network prefix";
                          type uint8 {
                            tailf:info "<8-64>;;IPv4 Network Prefix value";
                            range "8..64";
                          }
                        }
                      }
                    }
                  }
                }

                // ipv6 mobile pmipv6-lma * domain * / mobility-service mobile-local-loop / customer * vrf * / network unauthorized
                leaf unauthorized {
                  tailf:info "not authorize the network prefixes";
                  type empty;
                }
              }

              // ipv6 mobile pmipv6-lma * domain * / mobility-service mobile-local-loop / customer * vrf * / auth-option
              container auth-option {
                tailf:info "Authentication option between PMIPV6 entities";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                leaf spi {
                  tailf:info "Security parameter index";
                  tailf:cli-incomplete-command;
                  type string {
                    tailf:info "<0-ffffffff>;;SPI in hex value";
                  }
                }
                container key {
                  tailf:info "Security Key";
                  tailf:cli-flatten-container;
                  tailf:cli-compact-syntax;
                  leaf ascii {
                    tailf:info "Key in ASCII string";
                    type string {
                      tailf:info "WORD;;ASCII string";
                    }
                  }
                }
              }

              // ipv6 mobile pmipv6-lma * domain * / mobility-service mobile-local-loop / customer * vrf * / mobile-route admin-distance
              container mobile-route {
                tailf:info "Configuration related to M Route";
                leaf admin-distance {
                  tailf:info "Admin Distance of the M Route";
                  type uint8 {
                    tailf:info "<1-254>;;Specify the Admin Distance value";
                    range "1..254";
                  }
                }
              }

              // ipv6 mobile pmipv6-lma * domain * / mobility-service mobile-local-loop / customer * vrf * / transport
              container transport {
                tailf:info "Customer transport attributes";

                // ipv6 mobile pmipv6-lma * domain * / mobility-service mobile-local-loop / customer * vrf * / transport vrf *
                list vrf {
                  tailf:info "vrf for this transport";
                  tailf:cli-mode-name "config-ipv6-pmipv6-mll-cust-tpt";
                  key name;
                  leaf name {
                    type string {
                      tailf:info "WORD;;Name of VRF";
                    }
                  }

                  // ipv6 mobile pmipv6-lma * domain * / mobility-service mobile-local-loop / customer * vrf * / transport vrf * / address *
                  container address {
                    tailf:info "Specify LMAs IPv4 and IPv6 address";
                    leaf ipv4 {
                      tailf:info "Configure IPv4 address for this LMA";
                      type inet:ipv4-address {
                        tailf:info "A.B.C.D;;Transport IPv4 address";
                      }
                    }
                    leaf ipv6 {
                      tailf:info "Configure IPv6 address for this LMA";
                      type inet:ipv6-address {
                        tailf:info "X:X::X;;Transport IPv6 address";
                      }
                    }
                  }
                }
              }

              // ipv6 mobile pmipv6-lma * domain * / mobility-service mobile-local-loop / customer * vrf * / heartbeat
              uses ipv6-mobile-heartbeat-grouping;
            }
          }
        }

        // ipv6 mobile pmipv6-lma * domain * / pgw subscriber continuity
        container pgw {
          tailf:info "Feature related to interface with PGW";
          container subscriber {
            tailf:info "Enable Subscriber Continuity";
            leaf continuity {
              tailf:info "Enable Subscriber Continuity";
              type empty;
            }
          }
        }

        // ipv6 mobile pmipv6-lma * domain * / mobile-route admin-distance
        container mobile-route {
          tailf:info "Configuration related to M Route";
          leaf admin-distance {
            tailf:info "Admin Distance of the M Route";
            type uint8 {
              tailf:info "<1-254>;;Specify the Admin Distance value";
              range "1..254";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// frequency
  /// ========================================================================

  container frequency {
    tailf:info "Frequency Synchronization configuration";
    tailf:cli-explicit-exit;

    // frequency synchronization
    container synchronization {
      tailf:info "Frequency Synchronization configuration";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-freqsync";
      presence true;

      // frequency synchronization / quality
      container quality {
        tailf:info "Quality level option selection";
        container itu-t {
          tailf:info "ITU-T QL options";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf option {
            tailf:info "ITU-T QL options";
            type enumeration {
              enum "1" {
                tailf:info "ITU-T QL option 1";
              }
              enum "2" {
                tailf:info "ITU-T QL option 2";
              }
            }
          }
          leaf generation {
            tailf:info "ITU-T QL option 2 generation";
            when "../option = '2'";
            type enumeration {
              enum "1" {
                tailf:info "ITU-T QL option 2, generation 1";
              }
              enum "2" {
                tailf:info "ITU-T QL option 2, generation 2";
              }
            }
          }
        }
      }

      // frequency synchronization /  clock-interface
      container clock-interface {
        tailf:info "Clock interface configuration";
        leaf timing-mode {
          tailf:info "Clock interface timing mode";
          type enumeration {
            enum independent {
              tailf:info "Use the line interfaces for clock-interface output,"+
              " which is not looped back to the clock-interface input";
            }
            enum system {
              tailf:info "Use the system's selected timing source for lock-interface output";
            }
          }
        }
      }

      // frequency synchronization / system
      container system {
        tailf:info "System timing configuration";
        leaf timing-mode {
          tailf:info "System timing mod";
          type enumeration {
            enum clock-only {
              tailf:info "Use only clock-interfaces for system timing";
            }
            enum line-only {
              tailf:info "Use only line-interfaces for system timing";
            }
          }
        }
      }

      // frequency synchronization / log selection
      container log {
        tailf:info "Logging options";
        leaf selection {
          tailf:info "Selection logging options";
          type enumeration {
            enum changes {
              tailf:info "Log selection changes";
            }
            enum errors {
              tailf:info "Log selection errors";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// cem
  /// ========================================================================

  container cem {
    tailf:info "Configure CEM parameters";
    tailf:cli-explicit-exit;

    // cem class *
    list class {
      tailf:info "Configure a CEM class";
      tailf:cli-mode-name "config-cem-class";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;CEM class name";
        }
      }

      // cem class * / payload
      leaf payload {
        tailf:info "Configure payload size of CEM frames";
        type uint16 {
          tailf:info "<32-1312>;;Payload size in bytes";
          range "32..1312";
        }
      }

      // cem class * / dejitter
      leaf dejitter {
        tailf:info "Configure dejitter buffer";
        type uint16 {
          tailf:info "<1-500>;;buffer size in milliseconds";
          range "1..500";
        }
      }
    }
  }


  /// ========================================================================
  /// error-disable
  /// ========================================================================

  container error-disable {
    tailf:info "Configure error-disable";
    container recovery {
      tailf:info "Configure auto-recovery";

      // error-disable recovery cause
      container cause {
        tailf:info "Configure auto-recovery for a specific cause";

        // error-disable recovery cause stp-bpdu-guard
        container stp-bpdu-guard {
          tailf:info "Used when an STP BPDU is received on a port on which BPDU Guard is configured";
          presence true;
        }

        // error-disable recovery cause stp-legacy-bpdu
        container stp-legacy-bpdu {
          tailf:info "Used when a legacy BPDU is received on a port. Only MSTP and RSTP BPDUs are supported";
          presence true;
        }

        // error-disable recovery cause link-oam-miswired
        container link-oam-miswired {
          tailf:info "Used when a mis-wiring is detected with Ethernet Link OAM";
          presence true;
        }

        // error-disable recovery cause link-oam-dying-gasp
        container link-oam-dying-gasp {
          tailf:info "Used when a dying gasp is detected by Ethernet Link OAM";
          presence true;
        }

        // error-disable recovery cause link-oam-link-fault
        container link-oam-link-fault {
          tailf:info "Used when a unidirectional link is detected by Ethernet Link OAM";
          presence true;
        }

        // error-disable recovery cause link-oam-session-down
        container link-oam-session-down {
          tailf:info "Used when an Ethernet Link OAM session goes down";
          presence true;
        }

        // error-disable recovery cause link-oam-critical-event
        container link-oam-critical-event {
          tailf:info "Used when a critical event is detected by Ethernet Link OAM";
          presence true;
        }

        // error-disable recovery cause link-oam-discovery-timeout
        container link-oam-discovery-timeout {
          tailf:info "Used when an Ethernet Link OAM session fails to come up in time";
          presence true;
        }

        // error-disable recovery cause link-oam-threshold-breached
        container link-oam-threshold-breached {
          tailf:info "Used when a configured error threshold has been breached";
          presence true;
        }

        // error-disable recovery cause link-oam-capabilities-conflict
        container link-oam-capabilities-conflict {
          tailf:info "Used when Ethernet Link OAM configuration conflicts with the peer";
          presence true;
        }

        // error-disable recovery cause link-oam-dampening
        container link-oam-dampening {
          tailf:info "Used when Ethernet Link-OAM forces an interface down due to too many EFD down events.";
          presence true;
        }

        // error-disable recovery cause udld-timeout
        container udld-timeout {
          tailf:info "Used when all UDLD neigbors on the link have timed out";
          tailf:cli-delete-when-empty;
          tailf:cli-reset-container;
          presence true;
          leaf interval {
            tailf:info "Configure an interval for the auto-recovery period";
            type uint32 {
              tailf:info "<30-1000000>;;Specify an interval for the auto-recovery period in seconds";
              range "30..1000000";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// vtp
  /// ========================================================================

  container vtp {
    tailf:info "Configure global VTP state";
    tailf:cli-explicit-exit;

    // vtp mode
    leaf mode {
      tailf:info "Configure VTP device mode";
      type enumeration {
        enum client {
                     tailf:info "Set the device to client mode.";
        }
        enum off {
                  tailf:info "Set the device to off mode.";
        }
        enum server {
                     tailf:info "Set the device to server mode.";
        }
        enum transparent {
                          tailf:info "Set the device to transparent mode.";
        }
      }
    }
  }


  /// ========================================================================
  /// arp
  /// ========================================================================

  container arp {
    tailf:info "Global ARP configuration for Static and Alias ARP entries";
    tailf:cli-explicit-exit;

    // arp inner-cos
    leaf inner-cos {
      tailf:info "Configure inner cos values for arp packets";
      type uint8 {
        tailf:info "<0-7>;;inner cos value";
        range "0..7";
      }
    }

    // arp outer-cos
    leaf outer-cos {
      tailf:info "Configure outer cos values for arp packets";
      type uint8 {
        tailf:info "<0-7>;;Outer cos value";
        range "0..7";
      }
    }

    // arp *
    uses arp-grouping;

    // arp redundancy
    container redundancy {
      tailf:info "Configure parameter for ARP Geo redundancy";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-arp-red";
      presence true;

      // arp redundancy / group *
      list group {
        tailf:info "Redundancy Group configuration";
        tailf:cli-mode-name "config-arp-red-group";
        key id;
        leaf id {
          type uint8 {
            tailf:info "<1-32>;;Group ID";
            range "1..32";
          }
        }

        // arp redundancy / group * / peer
        leaf peer {
          tailf:info "Peer Address for this Group";
          tailf:cli-remove-before-change;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Neighbor IPv4 address";
          }
        }

        // arp redundancy / group * / source-interface
        container source-interface {
          tailf:info "Source interface for Redundancy Peer Communication";
          uses interface-name-grouping;
        }

        // arp redundancy / group * / interface-list
        container interface-list {
          tailf:info "List of Interfaces for this Group";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-arp-red-grp-intf";
          presence true;

          // arp redundancy / group * / interface-list / interface *
          list interface {
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;Interface Name";
              }
            }
            leaf id {
              tailf:info "Map Identifier";
              type uint16 {
                tailf:info "<1-65535>;;ID for the interface to be mapped on to peer";
                range "1..65535";
              }
            }
          }
        }
      }
    }

    // arp max-entries
    leaf max-entries {
      tailf:info "Configure maximum number of safe ARP entries per line card";
      type uint32 {
        tailf:info "<1-256000>;;entries";
        range "1..256000";
      }
    }

    // arp vrf *
    list vrf {
      tailf:info "vrf;;Specify a non-default VRF";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      tailf:cli-incomplete-command;
      key name;
      leaf name {
        tailf:info "VRF name";
        type string {
          tailf:info "WORD;;VRF name";
        }
      }
      uses arp-grouping;
    }
  }


  /// ========================================================================
  /// cinetd
  /// ========================================================================

  container cinetd {
    tailf:info "Global Cisco inetd configuration commands";
    tailf:cli-explicit-exit;

    leaf rate-limit {
      tailf:info "Cisco inetd rate-limit of service requests";
      type uint8 {
        tailf:info "<1-100>;;Number of service requests accepted per second (default 1)";
        range "1..100";
      }
    }
  }


  /// ========================================================================
  /// xml
  /// ========================================================================

  container xxml {
    tailf:info "Configuration for XML related services";
    tailf:alt-name xml;
    tailf:cli-explicit-exit;

    // xml agent tty
    container tty-agent {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-no;
      container agent {
        tailf:info "Enable default agent for XML requests";
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        container tty {
          tailf:info "Enable tty agent for XML requests";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-xml-tty";
          presence true;

          // xml agent tty / iteration
          container iteration {
            tailf:info "Iterator of the xml response";
            leaf off {
              tailf:info "Turn off the xml response iterator";
              type empty;
            }
          }

          // xml agent tty / ipv4
          leaf ipv4 {
            tailf:info "IPv4 Transport";
            type enumeration {
              enum enable;
              enum disable;
            }
          }

          // xml agent tty / ipv6
          leaf ipv6 {
            tailf:info "IPv6 Transport";
            type enumeration {
              enum enable;
              enum disable;
            }
          }

          // xml agent tty / session timeout
          container session {
            tailf:info "session timeout for transport agents";
            leaf timeout {
              tailf:info "session timeout for agents";
              type uint16 {
                tailf:info "<1-1440>;;Timeout in minutes";
                range "1..1440";
              }
            }
          }
        }
      }
    }

    // xml agent ssl
    container ssl-agent {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-no;
      container agent {
        tailf:info "Enable default agent for XML requests";
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        container ssl {
          tailf:info "Enable ssl agent for XML requests";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-xml-ssl";
          presence true;

          // xml agent ssl / session timeout
          container session {
            tailf:info "session timeout for transport agents";
            leaf timeout {
              tailf:info "session timeout for agents";
              type uint16 {
                tailf:info "<1-1440>;;Timeout in minutes";
                range "1..1440";
              }
            }
          }

          // xml agent ssl / iteration
          container iteration {
            tailf:info "Iterator of the xml response";
            choice iteration-choice {
              // xml agent ssl / iteration off
              leaf off {
                tailf:info "Turn off the xml response iterator";
                type empty;
              }
              // xml agent ssl / iteration on size
              container on {
                tailf:info "Turn on the xml response iterator";
                leaf size {
                  tailf:info "Iterator size of the xml response";
                  type uint32 {
                    tailf:info "<1-100000>;;Size of the Iteration in Kbytes (default 48 Kbytes)";
                    range "1..100000";
                  }
                }
              }
            }
          }
        }
      }
    }

    // xml agent
    container other-agent {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-no;
      container agent {
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-xml-agent";
        presence true;

        // xml agent / ipv4
        leaf ipv4 {
          tailf:info "IPv4 Transport";
          type enumeration {
            enum enable;
            enum disable {
              tailf:info "Disable IPv4 Transport";
            }
          }
        }

        // xml agent / ipv6
        leaf ipv6 {
          tailf:info "IPv6 Transport";
          type enumeration {
            enum enable;
            enum disable;
          }
        }

        // xml agent / iteration
        container iteration {
          tailf:info "Iterator of the xml response";
          choice iteration-choice {
            container on {
              tailf:info "Turn on the xml response iterator";
              leaf size {
                tailf:info "Iterator size of the xml response";
                type uint32 {
                  tailf:info "<1-100000>;;Size of the Iteration in Kbytes (default 48 Kbytes)";
                  range "1..100000";
                }
              }
            }
            leaf off {
              tailf:info "Turn off the xml response iterator";
              type empty;
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// switch
  /// ========================================================================

  container switch {
    tailf:info "Configure switch command";
    tailf:cli-explicit-exit;

    container virtual {
      tailf:info "Virtual switch configuration mode";
      list domain {
        tailf:info "Virtual switch domain";
        key id;

        leaf id {
          type uint8 {
            tailf:info "<1-255>;;Virtual switch domain number";
            range "1..255";
          }
        }
        leaf mac-address {
          tailf:info "router mac address scheme";
          type union {
            type string {
              tailf:info "H.H.H;;Manually set router mac address";
            }
            type enumeration {
              enum use-virtual {
                tailf:info "Use mac-address range reserved for Virtual Switch System";
              }
            }
          }
        }
        container switch {
          tailf:info "Configure switch command";
          leaf mode {
            type enumeration {
              enum virtual;
            }
          }
          list nr {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key id;
            leaf id {
              type uint8 {
                tailf:info "<1-2>;;Virtual switch number";
                range "1..2";
              }
            }
            leaf location {
              tailf:info "Virtual switch location";
              type string {
                tailf:info "WORD;;Virtual switch location string. If you "
                  +"include spaces, you must enclose your entry in quotes (\"\").";
              }
            }
            leaf priority {
              tailf:info "Virtual switch priority";
              type uint8 {
                tailf:info "<1-255>;;Virtual switch priority value";
                range "1..255";
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// password6
  /// ========================================================================

  // password6 encryption aes
  container password6 {
    tailf:info "Configure a key password";
    container encryption {
      tailf:info "Configure a key encryption";
      leaf aes {
        tailf:info "Configure a key type aes";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// key
  /// ========================================================================

  container key {
    tailf:info "Key management";
    tailf:cli-explicit-exit;

    // key chain *
    list chain {
      tailf:info "Key-chain management";
      key name;
      leaf name {
        tailf:cli-suppress-range;
        type string {
          tailf:info "WORD;;Key-chain name";
        }
      }

      // key chain * / macsec
      container macsec {
        tailf:info "Configures as macsec key chain";
        tailf:cli-add-mode;
        presence true;

        // key chain * / macsec / key *
        list key {
          tailf:info "Configure CKN as hex string of even length & max 64 bytes";
          tailf:cli-full-command;
          key id;
          leaf id {
            tailf:cli-suppress-range;
            type string {
              tailf:info "WORD;;Enter CKN as hex string of even length & max 64 bytes";
            }
          }

          // key chain * / macsec / key * / key-string
          container key-string {
            tailf:info "Configure CAK as hex of length of 32 or 64 bytes";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf type {
              tailf:cli-drop-node-name;
              tailf:cli-optional-in-sequence;
              tailf:cli-incomplete-command;
              type enumeration {
                enum clear {
                  tailf:info "Enter cleartext CAK as hex string of length 32 or 64 bytes";
                }
                enum password {
                  tailf:info "Enter encrypted CAK as hex string";
                }
                enum password6 {
                  tailf:info "Enter encrypted type6 password";
                }
              }
            }
            leaf secret {
              tailf:cli-drop-node-name;
              tailf:cli-reset-container;
              tailf:cli-disallow-value "clear|password|password6";
              tailf:cli-incomplete-command;
              cli:secret " key-string <SECRET> cryptographic-algorithm";
              type NEDCOM_SECRET_TYPE {
                tailf:info "WORD;;Specify an unencrypted password";
              }
            }
            leaf cryptographic-algorithm {
              tailf:info "Choose cryptographic algorithm";
              type enumeration {
                enum aes-128-cmac {
                  tailf:info "AES-128-CMAC authentication algorithm";
                }
                enum aes-256-cmac {
                  tailf:info "AES-256-CMAC authentication algorithm";
                }
              }
            }
          }

          // key chain * / macsec / key * / lifetime
          container lifetime {
            tailf:info "Configure lifetime";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            uses key-duration-grouping;
          }
        }
      }

      // key chain * / key *
      list key {
        tailf:info "Configure a key";
        tailf:cli-full-command;
        key id;
        leaf id {
          tailf:cli-suppress-range;
          type uint32 {
            tailf:info "<0-2147483647>;;Key identifier";
            range "0..2147483647";
          }
        }

        // key chain * / key * / accept-lifetime
        container accept-lifetime {
          tailf:info "Set accept lifetime of key";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf local {
            tailf:info "Specify time in local timezone";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          uses key-duration-grouping;
        }

        // key chain * / key * / key-string
        container key-string {
          tailf:info "Configure a key value";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf type {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            tailf:cli-incomplete-command;
            type enumeration {
              enum clear {
                tailf:info "Enter key string in cleartext form";
              }
              enum password {
                tailf:info "Encrypted key string";
              }
              enum password6 {
                tailf:info "Enter encrypted CAK as hex string";
              }
            }
          }
          leaf password {
            tailf:info "Encrypted key string";
            tailf:cli-drop-node-name;
            tailf:cli-reset-container;
            tailf:cli-disallow-value "clear|password|password6";
            cli:secret " key-string <SECRET>";
            type NEDCOM_SECRET_TYPE {
              tailf:info "LINE;;Cleartext key";
            }
          }
        }

        // key chain * / key * / send-lifetime
        container send-lifetime {
          tailf:info "Set send lifetime of key";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf local {
            tailf:info "Specify time in local timezone";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          uses key-duration-grouping;
        }

        // key chain * / key * / cryptographic-algorithm
        leaf cryptographic-algorithm {
          tailf:info "Choose cryptographic algorithm";
          type enumeration {
            enum HMAC-MD5 {
              tailf:info "Configure HMAC-MD5 as cryptographic algorithm";
            }
            enum HMAC-SHA1-12 {
              tailf:info "Configure HMAC-SHA1-12 as cryptographic algorithm";
            }
            enum HMAC-SHA1-20 {
              tailf:info "Configure HMAC-SHA1-20 as cryptographic algorithm";
            }
            enum MD5 {
              tailf:info "Configure MD5 as cryptographic algorithm";
            }
            enum SHA-1 {
              tailf:info "Configure SHA-1-20 as cryptographic algorithm";
            }
            enum HMAC-SHA1-96 {
              tailf:info "Configure HMAC-SHA1-96 as cryptographic algorithm";
            }
            enum AES-128-CMAC-96 {
              tailf:info "Configure AES-128-CMAC-96 as cryptographic algorithm";
            }
            enum HMAC-SHA-256 {
              tailf:info "Configure HMAC-SHA-256 as cryptographic algorithm";
            }
          }
        }
      }

      // key chain * / accept-tolerance
      leaf accept-tolerance {
        tailf:info "Configure a tolerance value for accept keys of this keychain";
        type union {
          type uint32 {
            tailf:info "<1-8640000>;;Configure a tolerance-value";
          }
          type enumeration {
            enum infinite {
              tailf:info "Never expires";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// dhcp
  /// ========================================================================

  container dhcp {
    tailf:info "Dynamic Host Configuration Protocol";
    tailf:cli-explicit-exit;

    // dhcp ipv4
    container ipv4 {
      tailf:info "Configure IPv4 DHCP";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-dhcpv4";
      presence true;

      // dhcp ipv4 / vrf *
      list vrf {
        tailf:info "Assign a profile to VRF";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          tailf:info "VRF name";
          type string {
            tailf:info "WORD;;VRF name";
          }
        }
        // dhcp ipv4 / vrf * relay
        leaf relay {
          tailf:info "Assign a relay profile to VRF";
          type empty;
        }
        // dhcp ipv4 / vrf * profile
        leaf profile {
          tailf:info "Enter profile name";
          type string {
            tailf:info "WORD;;Profile name";
          }
        }
      }

      // dhcp ipv4 / profile *
      list profile {
        tailf:info "Create or enter a profile";
        tailf:cli-mode-name "config-dhcpv4-profile";
        key "name type";
        leaf name {
          type string {
            tailf:info "WORD;;Profile name";
          }
        }
        leaf type {
          type enumeration {
            enum relay {
              tailf:info "Create or enter relay profile";
            }
            enum proxy {
              tailf:info "Create or enter proxy profile";
            }
            enum server {
              tailf:info "Create or enter server profile";
            }
            enum snoop {
              tailf:info "Create or enter snoop profile";
            }
          }
        }

        // dhcp ipv4 / profile * / trusted
        leaf trusted {
          tailf:info "Trusted sources";
          type empty;
        }

        // dhcp ipv4 / profile * / allow-move
        leaf allow-move {
          tailf:info "Allow dhcp subscriber move";
          type empty;
        }

        // dhcp ipv4 / profile * / aaa dhcp-option force-insert
        container aaa {
          tailf:info "Enable aaa dhcp option force-insert";
          container dhcp-option {
            tailf:info "Enable aaa dhcp option force-insert";
            leaf force-insert {
              tailf:info "Enable aaa dhcp option force-insert";
              type empty;
            }
          }
        }

        // dhcp ipv4 / profile * / pool
        leaf pool {
          tailf:info "Specify the Pool name";
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;Dap's pool name";
          }
        }

        // dhcp ipv4 / profile * / dns-server *
        leaf-list dns-server {
          tailf:info "DNS servers";
          tailf:cli-flat-list-syntax;
          tailf:cli-replace-all;
          ordered-by user;
          max-elements 8;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;DNS Server's IP address";
          }
        }

        // dhcp ipv4 / profile * / default-router *
        leaf-list default-router {
          tailf:info "default routers";
          tailf:cli-flat-list-syntax;
          tailf:cli-replace-all;
          ordered-by user;
          //max-elements 8;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Router's IP address";
          }
        }

        // dhcp ipv4 / profile * / giaddr policy
        container giaddr {
          tailf:info "Specify gateway address policy";
          leaf policy {
            tailf:info "Specify gateway address policy";
            type enumeration {
              enum drop {
                tailf:info "Drop client requests with non-zero gateway address";
              }
              enum replace {
                tailf:info "Replace existing gateway address in client request";
              }
            }
          }
        }

        // dhcp ipv4 / profile * / broadcast-flag policy check
        container broadcast-flag {
          tailf:info "Specify broadcast flag policy";
          container policy {
            tailf:info "Specify broadcast flag policy";
            leaf check {
              tailf:info "Check the broadcast flag in packets";
              type empty;
            }
          }
        }

        // dhcp ipv4 / profile * / helper-address vrf * *
        list helper-address {
          tailf:info "Specify the server address to relay packets";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key "vrf address";
          leaf vrf {
            tailf:cli-expose-key-name;
            tailf:info "Specify server VRF";
            type vrf-type;
          }
          leaf address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Server address";
            }
          }
          // dhcp ipv4 / profile * / helper-address vrf * * giaddr
          leaf giaddr {
            tailf:info "Specify gateway address to use in packets relayed to server";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Gateway address";
            }
          }
        }

        // dhcp ipv4 / profile * / dhcp-to-aaa option list
        container dhcp-to-aaa {
          tailf:info "Enable to provide the list of options need to send to aaa";
          container option {
            tailf:info "option type";
            leaf list {
              tailf:info "List of options";
              tailf:cli-full-command;
              tailf:cli-multi-value;
              type string {
                tailf:info "LINE;;Option number(s) or 'all'";
                pattern 'all|([0-9 ]+)';
              }
            }
          }
        }

        // dhcp ipv4 / profile * / lease
        container lease {
          tailf:info "Specify lease";
          when "../type != 'proxy'";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          choice lease-choice {
            case infinite {
              leaf infinite {
                tailf:info "Infinite lease";
                type empty;
              }
            }
            case duration {
              leaf days {
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<0-365>;;Days";
                  range "0..365";
                }
              }
              leaf hours {
                tailf:cli-drop-node-name;
                tailf:cli-optional-in-sequence;
                type uint8 {
                  tailf:info "<0-23>;;Hours";
                  range "0..23";
                }
              }
              leaf minutes {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<0-59>;;Minutes";
                  range "0..59";
                }
              }
            }
          }
        }

        // dhcp ipv4 / profile * / lease proxy
        container proxy {
          tailf:cli-drop-node-name;
          when "../type = 'proxy'";
          container lease {
            tailf:info "Specify lease";
            container proxy {
              tailf:info "Specify lease proxy";

              // dhcp ipv4 / profile * / lease proxy client-lease-time
              leaf client-lease-time {
                tailf:info "Specify the lease proxy client lease time";
                type uint32 {
                  tailf:info "<300-4294967295>;;Value of lease proxy client-time in seconds";
                  range "300..4294967295";
                }
              }
            }
          }
        }

        // dhcp ipv4 / profile * / relay information
        container relay {
          tailf:info "Specify Relay Agent Information Option configuration";
          container information {
            tailf:info "Specify Relay Agent Information Option configuration";

            // dhcp ipv4 / profile * / relay information check
            leaf check {
              tailf:info "Check Relay Agent Information Option in server reply";
              type empty;
            }

            // dhcp ipv4 / profile * / relay information option X
            container option {
              tailf:info "Insert Relay Agent Information circuit ID and remote ID suboptions in client request";
              tailf:cli-incomplete-command;
              tailf:cli-incomplete-no;

              // dhcp ipv4 / profile * / relay information option vpn
              leaf vpn {
                tailf:info "Insert Relay Agent Information VPN suboptions in client request";
                type empty;
              }

              // dhcp ipv4 / profile * / relay information option vpn-mode
              leaf vpn-mode {
                tailf:info "Relay Agent Information VPN suboptions mode";
                type enumeration {
                  enum cisco {
                    tailf:info "Relay Agent Information VPN suboptions in CISCO proprietary";
                  }
                  enum rfc {
                    tailf:info "Relay Agent Information VPN suboptions in RFC compliance";
                  }
                }
              }

              // dhcp ipv4 / profile * / relay information option remote-id
              container remote-id {
                tailf:info "Enter remote-id value";
                leaf suppress {
                  tailf:info "Suppress remote id";
                  type empty;
                }
                leaf value {
                  tailf:cli-drop-node-name;
                  tailf:cli-disallow-value "suppress|enable|format-type";
                  cisco-ios-xr:string-remove-quotes "relay information option remote-id <STRING>";
                  type string {
                    tailf:info "WORD;;Remote id value";
                  }
                }
                leaf enable {
                  tailf:info "Enable";
                  type empty;
                }

                // dhcp ipv4 / profile * / relay information option remote-id format-type
                container format-type {
                  when "../../../../../type = 'relay'";
                  tailf:info "Enter the format-type of remote-id";
                  tailf:cli-compact-syntax;
                  tailf:cli-sequence-commands {
                    tailf:cli-reset-siblings;
                  }
                  leaf format {
                    tailf:cli-drop-node-name;
                    tailf:cli-incomplete-command;
                    type enumeration {
                      enum ascii {
                        tailf:info "Choose the ascii string format";
                      }
                      enum hex {
                        tailf:info "Choose the hex string format";
                      }
                    }
                  }
                  leaf value {
                    tailf:cli-drop-node-name;
                    type string {
                      tailf:info "WORD;;remote-id value";
                    }
                  }
                }
              }

              // dhcp ipv4 / profile * / relay information option allow-untrusted
              leaf allow-untrusted {
                tailf:info "Forward untrusted packets";
                type empty;
              }
            }

            // dhcp ipv4 / profile * / relay information option
            container option-base {
              tailf:cli-drop-node-name;
              leaf option {
                tailf:info "Insert Relay Agent Information circuit ID and remote ID suboptions in client request";
                type empty;
              }
            }

            // dhcp ipv4 / profile * / relay information policy
            leaf policy {
              tailf:info "Specify Relay Agent Information Option policy";
              type enumeration {
                enum drop {
                  tailf:info "Drop client request packets with Relay Agent Information Option";
                }
                enum encapsulate {
                  tailf:info "Encapsulate existing Relay Agent Information Option in client request";
                }
                enum keep {
                  tailf:info "Keep existing Relay Agent Information Option in client request";
                }
                enum replace {
                  tailf:info "Replace existing Relay Agent Information Option in client request";
                }
              }
            }
          }
        }

        // dhcp ipv4 / profile * / subnet-mask
        leaf subnet-mask {
          tailf:info "Configure Subnet Mask";
          tailf:cli-full-command;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Subnet Mask";
          }
        }

        // dhcp ipv4 / profile * / class *
        list class {
          tailf:info "Create or enter proxy profile class";
          tailf:cli-mode-name "config-dhcpv4-proxy-profile-class";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;class name";
            }
          }

          // dhcp ipv4 / profile * / class * / match
          container match {
            tailf:info "Insert match keyword";

            // dhcp ipv4 / profile * / class * / match vrf
            leaf vrf {
              tailf:info "Specify match VRF";
              type string {
                tailf:info "WORD;;VRF name";
              }
            }

            // dhcp ipv4 / profile * / class * / match option *
            list option {
              tailf:info "Specify match option";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              tailf:cli-incomplete-command;
              key id;
              leaf id {
                type enumeration {
                  enum 60 {
                    tailf:info "Match option 60 vendor class id";
                  }
                  enum 77 {
                    tailf:info "Match option 77 user class";
                  }
                  enum 124 {
                    tailf:info "Match option 124 vendor-identifying vendor class";
                  }
                  enum 125 {
                    tailf:info "Match option 125 vendor-indentifying vendor-specific info";
                  }
                  enum circuitid {
                    tailf:info "Match circuit id of option 82 Relay-agent specific class";
                  }
                  enum remoteid {
                    tailf:info "Match remote id of option 82 Relay-agent specific class";
                  }
                }
              }
              leaf hex {
                tailf:info "Insert hex pattern string";
                type string {
                  tailf:info "WORD;;Enter hex pattern string";
                }
              }
              leaf mask {
                tailf:info "Insert bit mask pattern";
                type string {
                  tailf:info "WORD;;Enter bit mask pattern string";
                }
              }
            }
          }

          // dhcp ipv4 / profile * / class * / pool
          leaf pool {
            tailf:info "Specify the pool";
            type string {
              tailf:info "WORD;;Pool name";
            }
          }

          // dhcp ipv4 / profile * / class * / subnet-mask
          leaf subnet-mask {
            tailf:info "Configure Subnet Mask";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Subnet Mask";
            }
          }

          // dhcp ipv4 / profile * / class * / default-router *
          leaf-list default-router {
            tailf:info "default routers";
            tailf:cli-flat-list-syntax;
            tailf:cli-replace-all;
            ordered-by user;
            max-elements 8;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Router's IP address";
            }
          }

          // dhcp ipv4 / profile * / class * / helper-address *
          list helper-address {
            tailf:info "Specify the server address to relay packets";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            key "vrf address";
            leaf vrf {
              tailf:cli-expose-key-name;
              tailf:info "Specify server VRF";
              type vrf-type;
            }
            leaf address {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Server address";
              }
            }
            // dhcp ipv4 / profile * / helper-address vrf * * giaddr
            leaf giaddr {
              tailf:info "Specify gateway address to use in packets relayed to server";
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Gateway address";
              }
            }
          }
        }
      }

      // dhcp ipv4 / interface * information option format-type
      container interface-option {
        tailf:cli-drop-node-name;
        list interface {
          tailf:info "Assign a profile to interface";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-incomplete-command;
          key "name type";
          leaf name {
            type string {
              tailf:info "WORD;;Interface Name";
            }
          }
          leaf type {
            type enumeration {
              enum proxy {
                tailf:info "Assign a proxy profile to interface";
              }
              enum relay {
                tailf:info "Assign a relay profile to interface";
              }
              enum server {
                tailf:info "Assign a server profile to interface";
              }
            }
          }
          container information {
            tailf:info "Information";
            container option {
              tailf:info "Insert option 82 for this interface";
              container format-type {
                tailf:info "Format type";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                container circuit-id {
                  tailf:info "Enter circuit-id value";
                  tailf:cli-flatten-container;
                  tailf:cli-compact-syntax;
                  choice format-choice {
                    leaf value {
                      tailf:cli-drop-node-name;
                      tailf:cli-disallow-value "format-string";
                      type string {
                        tailf:info "WORD;;circuit id value";
                      }
                    }
                    leaf format-string {
                      tailf:info "Extended format";
                      type string {
                        tailf:info "WORD;;format string (conversion specifier)";
                      }
                    }
                  }
                }
                leaf-list args {
                  tailf:cli-drop-node-name;
                  tailf:cli-flat-list-syntax;
                  ordered-by user;
                  type enumeration {
                    enum inner-vlan-id {
                      tailf:info "Inner vlan id tag";
                    }
                    enum outer-vlan-id {
                      tailf:info "Outer vlan id tag";
                    }
                    enum physical-chassis {
                      tailf:info "Rack";
                    }
                    enum physical-port {
                      tailf:info "Port";
                    }
                    enum physical-slot {
                      tailf:info "Slot";
                    }
                    enum physical-subport {
                      tailf:info "Subport";
                    }
                    enum physical-subslot {
                      tailf:info "Subslot";
                    }
                    enum l2-interface {
                      tailf:info "Ingress L2 Interface";
                    }
                    enum l3-interface {
                      tailf:info "Ingress L3 Interface";
                    }
                    enum hostname {
                      tailf:info "host name";
                    }
                  }
                }
              }
            }
          }
        }
      }

      // dhcp ipv4 / interface *
      list interface {
        tailf:info "Assign a profile to interface";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key "name type";
        leaf name {
          type string {
            tailf:info "WORD;;Interface Name";
          }
        }
        leaf type {
          type enumeration {
            enum proxy {
              tailf:info "Assign a proxy profile to interface";
            }
            enum relay {
              tailf:info "Assign a relay profile to interface";
            }
            enum server {
              tailf:info "Assign a server profile to interface";
            }
          }
        }
        leaf profile {
          tailf:info "Enter profile name";
          type string {
            tailf:info "WORD;;Profile name";
          }
        }
      }

      // dhcp ipv4 / duplicate-mac-allowed
      container duplicate-mac-allowed {
        tailf:info "Clients with duplicate  mac allowed";
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        // dhcp ipv4 / duplicate-mac-allowed exclude-vlan
        leaf exclude-vlan {
          tailf:info "Exclude-vlan";
          type empty;
        }
      }

      // dhcp ipv4 / database
      container database {
        tailf:info "Enable DHCP binding database storage to file system";
        presence true;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        leaf proxy {
          tailf:info "Enable DHCP proxy binding database storage to file system";
          tailf:cli-optional-in-sequence;
          type empty;
        }
        leaf server {
          tailf:info "Enable DHCP server binding database storage to file system";
          tailf:cli-optional-in-sequence;
          type empty;
        }
        leaf snoop {
          tailf:info "Enable DHCP snoop binding database storage to file system";
          tailf:cli-optional-in-sequence;
          type empty;
        }
        leaf full-write-interval {
          tailf:info "Full file write interval (default 10 minutes)";
          tailf:cli-optional-in-sequence;
          type uint16 {
            tailf:info "<1-1440>;;Enter full file write interval (minutes)";
            range "1..1440";
          }
        }
        leaf incremental-write-interval {
          tailf:info "Incremental file write interval (default 1 minute)";
          type uint16 {
            tailf:info "<1-1440>;;Enter incremental file write interval (minutes)";
            range "1..1440";
          }
        }
      }

      // dhcp ipv4 / inner-cos
      leaf inner-cos {
        tailf:info "Configure inner cos values for dhcp packets";
        type uint8 {
          tailf:info "<0-7>;;Inner cos value";
        }
      }
      // dhcp ipv4 / outer-cos
      leaf outer-cos {
        tailf:info "Configure outer cos values for dhcp packets";
        type uint8 {
          tailf:info "<0-7>;;Outer cos value";
        }
      }
    }

    // dhcp ipv6
    container ipv6 {
      tailf:info "Configure IPv6 DHCP";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-dhcpv6";
      presence true;

      // dhcp ipv6 / database
      container database {
        tailf:info "Enable DHCP binding database storage to file system";
        presence true;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        leaf proxy {
          tailf:info "Enable DHCP proxy binding database storage to file system";
          tailf:cli-optional-in-sequence;
          type empty;
        }
        leaf server {
          tailf:info "Enable DHCP server binding database storage to file system";
          tailf:cli-optional-in-sequence;
          type empty;
        }
        leaf relay {
          tailf:info "Enable DHCP relay binding database storage to file system";
          tailf:cli-optional-in-sequence;
          type empty;
        }
        leaf full-write-interval {
          tailf:info "Full file write interval (default 10 minutes)";
          tailf:cli-optional-in-sequence;
          type uint16 {
            tailf:info "<1-1440>;;Enter full file write interval (minutes)";
            range "1..1440";
          }
        }
        leaf incremental-write-interval {
          tailf:info "Incremental file write interval (default 1 minute)";
          type uint16 {
            tailf:info "<1-1440>;;Enter incremental file write interval (minutes)";
          }
        }
      }

      // dhcp ipv6 / profile *
      list profile {
        tailf:info "Create or enter a profile";
        tailf:cli-mode-name "config-dhcpv6-profile";
        key "name type";
        leaf name {
          type string {
            tailf:info "WORD;;Profile name";
          }
        }
        leaf type {
          type enumeration {
            enum relay {
              tailf:info "Create or enter relay profile";
            }
            enum proxy {
              tailf:info "Create or enter proxy profile";
            }
            enum server {
              tailf:info "Create or enter server profile";
            }
            enum snoop {
              tailf:info "Create or enter snoop profile";
            }
          }
        }

        // dhcp ipv6 / profile * / interface *
        list interface {
          tailf:info "Specify physical interface for interface-id option";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          key name;
          leaf name {
            type ifname;
          }
          leaf interface-id {
            tailf:info "Physical interface ID";
            type string {
              tailf:info "WORD;;Interface ID";
            }
          }
        }

        // dhcp ipv6 / profile * / helper-address vrf *
        list helper-address {
          tailf:info "Configure relay destination";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key "vrf address";
          leaf vrf {
            tailf:cli-expose-key-name;
            tailf:info "Specify server VRF";
            type vrf-type;
          }
          leaf address {
            type inet:ipv6-address {
              tailf:info "X:X::X;;Server Global unicast address";
            }
          }
        }

        // dhcp ipv6 / profile * / link-address
        leaf link-address {
          tailf:info "Link Address";
          tailf:cli-full-command;
          type inet:ipv6-address {
            tailf:info "X:X::X;;IPv6 address to be filled in link-address";
          }
        }

        // dhcp ipv6 / profile * / route-add-disable
        leaf route-add-disable {
          tailf:info "Disable route add if interface is down";
          tailf:cli-full-command;
          type empty;
        }

        // dhcp ipv6 / profile * / source-interface
        container source-interface {
          tailf:info "Create or enter proxy profile Source Interface Name";
          uses interface-name-grouping;
        }

        // dhcp ipv6 / profile * / lease
        container lease {
          tailf:info "lease";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          choice lease-choice {
            leaf infinite {
              tailf:info "Infinite lease";
              type empty;
            }
            case duration {
              leaf days {
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<0-365>;;Days";
                  range "0..365";
                }
              }
              leaf hours {
                tailf:cli-drop-node-name;
                tailf:cli-optional-in-sequence;
                type uint8 {
                  tailf:info "<0-23>;;Hours";
                  range "0..23";
                }
              }
              leaf minutes {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<0-59>;;Minutes";
                  range "0..59";
                }
              }
            }
          }
        }

        // dhcp ipv6 / profile * / relay option
        container relay {
          tailf:info "Specify relay configuration";
          container option {
            tailf:info "Specify relay option configuration";

            // dhcp ipv6 / profile * / relay option remote-id
            leaf remote-id {
              tailf:info "Enter remote-id value";
              type string {
                tailf:info "WORD;;Remote ID";
              }
            }

            // relay option interface-id insert local
            container interface-id {
              tailf:info "Interface Id option";
              leaf insert {
                tailf:info "Insert options for Interface Id";
                type enumeration {
                  enum local {
                    tailf:info "Insert locally generated/configured Interface ID value";
                  }
                  enum pppoe {
                    tailf:info "Insert received Interface ID value from SADB";
                  }
                  enum received {
                    tailf:info "Insert received Interface ID value";
                  }
                }
              }
            }

            // relay option link-layer-addr set
            container link-layer-addr {
              tailf:info "Enter link-layer-addr value";
              leaf set {
                tailf:info "Insert Received LinkLayerAddr Value from SADB";
                type empty;
              }
            }
          }
        }

        // dhcp ipv6 / profile * / prefix-pool
        leaf prefix-pool {
          tailf:info "Prefix pool";
          type string {
            tailf:info "WORD;;Prefix pool name";
          }
        }

        // dhcp ipv6 / profile * / address-pool
        leaf address-pool {
          tailf:info "Address pool";
          type string {
            tailf:info "WORD;;Address pool name";
          }
        }

        // dhcp ipv6 / profile * / rapid-commit
        leaf rapid-commit {
          tailf:info "Allow RAPID Commi";
          type empty;
        }

        // dhcp ipv6 / profile * / option
        container option {
          tailf:info "DHCPv6 options";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }

          // dhcp ipv6 / option 17
          leaf options {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type enumeration {
              enum "17" {
                tailf:info "Vendor options";
              }
            }
          }

          // dhcp ipv6 / option 17 hex
          leaf hex {
            tailf:info "Input value in hex format";
            type string {
              tailf:info "WORD;;Vendor options";
            }
          }
        }

        // dhcp ipv6 / profile * / class *
        list class {
          tailf:info "Create or enter proxy profile class";
          tailf:cli-mode-name "config-dhcpv6-proxy-profile-class";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;class name";
            }
          }

          // dhcp ipv6 / profile * / class * / helper-address *
          list helper-address {
            tailf:info "Configure relay destination";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key "vrf address";
            leaf vrf {
              tailf:cli-expose-key-name;
              tailf:info "Specify server VRF";
              type vrf-type;
            }
            leaf address {
              type inet:ipv6-address {
                tailf:info "X:X::X;;Server Global unicast address";
              }
            }
          }

          // dhcp ipv6 / profile * / class * / link-address
          leaf link-address {
            tailf:info "Link Address";
            tailf:cli-full-command;
            type inet:ipv6-address {
              tailf:info "X:X::X;;IPv6 address to be filled in link-address";
            }
          }

          // dhcp ipv6 / profile * / class * / dns-server *
          leaf-list dns-server {
            tailf:info "DNS servers";
            tailf:cli-flat-list-syntax;
            tailf:cli-replace-all;
            ordered-by user;
            max-elements 8;
            type inet:ipv6-address {
              tailf:info "X:X::X;;Server's IPv6 address";
            }
          }

          // dhcp ipv6 / profile * / class * / preference
          leaf preference {
            tailf:info "DHCP Server Preference";
            type uint8 {
              tailf:info "<1-255>;;Preference value";
              range "1..255";
            }
          }

          // dhcp ipv6 / profile * / class * / prefix-pool
          leaf prefix-pool {
            tailf:info "Prefix pool";
            type string {
              tailf:info "WORD;;Prefix pool name";
            }
          }

          // dhcp ipv6 / profile * / class * / address-pool
          leaf address-pool {
            tailf:info "Address pool";
            type string {
              tailf:info "WORD;;Address pool name";
            }
          }
        }
      }

      // dhcp ipv6 / interface * proxy profile
      // dhcp ipv6 / interface * relay profile
      // dhcp ipv6 / interface * server profile
      list interface {
        tailf:info "Enable IPv6 DHCP on an interface";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-remove-before-change;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Interface Name";
          }
        }
        leaf type {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type enumeration {
            enum proxy {
            }
            enum relay {
              tailf:info "Act as an IPv6 DHCP stateless relay agent";
            }
            enum server {
              tailf:info "Act as an IPv6 DHCP server";
            }
          }
        }
        leaf profile {
          tailf:info "Create or enter a profile";
          type string {
            tailf:info "WORD;;Enter profile Name";
          }
        }
      }

      // dhcp ipv6 / interface subscriber-pppoe profile
      container interface-ppoe {
        tailf:cli-drop-node-name;
        container interface {
          tailf:info "Enable IPv6 DHCP on an interface";
          container subscriber-pppoe {
            tailf:info "PPPoE subscriber interface";
            leaf profile {
              tailf:info "Enter profile name";
              type string {
                tailf:info "WORD;;Profile name";
              }
            }
          }
        }
      }

      // dhcp ipv6 / inner-cos
      leaf inner-cos {
        tailf:info "Inner cos values for DHCPv6 packets to wards clients";
        type uint8 {
          tailf:info "<0-7>;;Inner cos value 0-7";
        }
      }
      // dhcp ipv6 / outer-cos
      leaf outer-cos {
        tailf:info "Configure outer cos values for DHCPv6 packet to wards client";
        type uint8 {
          tailf:info "<0-7>;;Outer cos value 0-7";
        }
      }
    }
  }


  /// ========================================================================
  /// lacp
  /// ========================================================================

  container lacp {
    tailf:info "Link Aggregation Control Protocol commands";

    // lacp system
    container system {
      tailf:info "Set the default system parameters for LACP bundles";

      // lacp system mac
      leaf mac {
        tailf:info "The system ID to use in LACP negotiations.";
        type string {
          tailf:info "H.H.H;;Unique ID for this system.";
        }
      }

      // lacp system priority
      leaf priority {
        tailf:info "The system priority to use in LACP negotiations.";
        type uint16 {
          tailf:info "<1-65535>;;Priority for this system. Lower value is higher priority.";
          range "1..65535";
        }
      }
    }
  }


  /// ========================================================================
  /// object-group
  /// ========================================================================

  container object-group {
    tailf:info "Object-group configuration";
    tailf:cli-explicit-exit;

    // object-group network
    container network {
      tailf:info "Network object group";

      // object-group network ipv4 *
      list ipv4 {
        tailf:info "IPv4 object group";
        tailf:cli-mode-name "config-object-group-ipv4";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;IPv4 object group name - maximum 64 characters";
          }
        }

        // object-group network ipv4 * / *
        list prefix-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key prefix;
          leaf prefix {
            type ipv4-prefix {
              tailf:info "A.B.C.D/length;;IPv4 address/prefix";
            }
          }
        }

        // object-group network ipv4 * / host *
        list host {
          tailf:info "A single host address";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key address;
          leaf address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Host ipv4 address";
            }
          }
        }

        // object-group network ipv4 * / description
        uses description-grouping;
      }

      // object-group network ipv6 *
      list ipv6 {
        tailf:info "IPv6 object group";
        tailf:cli-mode-name "config-object-group-ipv6";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;IPv6 object group name - maximum 64 characters";
          }
        }

        // object-group network ipv6 * / *
        list prefix-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key prefix;
          leaf prefix {
            type tailf:ipv6-address-and-prefix-length {
              tailf:info "X:X::X/length;;IPv6 prefix x:x::x/y";
            }
          }
        }

        // object-group network ipv6 * / host *
        list host {
          tailf:info "A single host address";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key address;
          leaf address {
            type inet:ipv6-address {
              tailf:info "X:X::X;;host ipv6 address";
            }
          }
        }

        // object-group network ipv6 * / description
        uses description-grouping;
      }
    }

    // object-group port *
    list port  {
      tailf:info "Port object group";
      tailf:cli-mode-name "config-object-group-port";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Port object group name - maximum 64 characters";
        }
      }

      // object-group port * / eq *
      leaf-list eq {
        tailf:info "Match packets on ports equal to entered port number";
        tailf:cli-list-syntax;
        type string {
          tailf:info "WORD;;Port in number or name (must match device show run)";
        }
      }

      // object-group port * / range *
      list range {
        tailf:info "Match only packets on a given port range";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key start;
        leaf start {
          type string {
            tailf:info "WORD;;Port start in number or name (must match device show run)";
          }
        }
        leaf end {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;Port end in number or name (must match device show run)";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// as-format
  /// ========================================================================

  container as-format {
    tailf:info "Autonomous system number format";
    leaf asdot {
      tailf:info "AS Dot format";
      type empty;
    }
  }


  /// ========================================================================
  /// udf
  /// ========================================================================

  // udf
  container udf {
    tailf:info "UDF configuration";

    // udf *
    list udf-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-incomplete-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;UDF name - maximum 16 characters";
        }
      }
      leaf header {
        tailf:info "Header for UDF";
        tailf:cli-incomplete-command;
        type empty;
      }
      leaf start {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type enumeration {
          enum inner {
                      tailf:info "Inner header for UDF";
          }
          enum outer {
                      tailf:info "Outer header for UDF";
          }
        }
      }
      leaf layer {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type enumeration {
          enum l2 {
                   tailf:info "L2 layer for UDF";
          }
          enum l3 {
                   tailf:info "L3 layer for UDF";
          }
          enum l4 {
                   tailf:info "L4 layer for UDF";
          }
        }
      }
      leaf offset {
        tailf:info "Configure the offset (bytes) in the header";
        tailf:cli-incomplete-command;
        type uint16 {
          tailf:info "<0-65535>;;Configure the offset value (bytes)";
        }
      }
      leaf length {
        tailf:info "Configure the length (bytes) in the header";
        type uint16 {
          tailf:info "<0-65535>;;Configure the length (bytes)";
        }
      }
    }
  }


  /// ========================================================================
  /// onep
  /// ========================================================================

  container onep {
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-onep";
    tailf:cli-explicit-exit;
    presence true;
  }


  /// ========================================================================
  /// install
  /// ========================================================================

  container install {
    tailf:info "Install configuration";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-install";
    tailf:cli-explicit-exit;

    // install / repository *
    list repository {
      tailf:info "Per repository configuration";
      tailf:cli-mode-name "config-repository";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Repository ID (up to 80 characters)";
        }
      }

      // install / repository * / url
      leaf url {
        tailf:info "Repository URL - path to local repository or ftp, http, or https path to remote repository, optionally containing the name of a VRF for the repository";
        cisco-ios-xr:string-remove-quotes "url <STRING>";
        type string {
          tailf:info "WORD;;Other|FTP|Local File|HTTP|HTTPS repository";
        }
      }
    }
  }


  /// ========================================================================
  /// snmp-server
  /// ========================================================================

  container snmp-server {
    tailf:info "SNMP configuration subcommands";
    tailf:cli-explicit-exit;

    // snmp-server ifmib
    container ifmib {
      tailf:info "IF-MIB configuration commands";

      // snmp-server ifmib ifalias
      container ifalias {
        tailf:info "Modify parameters for ifAlias object";
        leaf long {
          tailf:info "Enable support for ifAlias values longer than 64 characters";
          type empty;
        }
      }

      // snmp-server ifmib internal cache max-duration
      container internal {
        tailf:info "IFMIB internal lookahead cache";
        container cache {
          tailf:info "Cached data";
          leaf max-duration {
            tailf:info "Change the max duration";
            type uint8 {
              tailf:info "<0-60>;;Cache timeout";
              range "0..60";
            }
          }
        }
      }

      // snmp-server ifmib stats
      container stats {
        tailf:info "Modify IF-MIB statistics parameters";
        leaf cache {
          tailf:info "Get cached interface statistics";
          tailf:cli-full-command;
          type empty;
        }
      }

      // snmp-server ifmib ipsubscriber
      leaf ipsubscriber {
        tailf:info "Enable ipsubscriber interfaces in IFMIB";
        type empty;
      }
    }

    // snmp-server packetsize
    leaf packetsize {
      tailf:info "Message packet size";
      tailf:cli-full-command;
      type uint32 {
        tailf:info "<484-65500>;;Packet size (default 1500)";
        range "484..65500";
      }
    }

    // snmp-server ifindex
    leaf ifindex {
      tailf:info "Enable ifindex persistence";
      tailf:cli-full-command;
      type enumeration {
        enum persist {
           tailf:info "Persist interface indices";
        }
      }
    }

    // snmp-server engineID
    container engineID {
      tailf:info "Configure a local or remote SNMPv3 engineID";

      // snmp-server engineID local
      leaf local {
        tailf:info "engineID of the local agent";
        type string {
          tailf:info "WORD;;engine ID octet string";
        }
      }

      // snmp-server engineID remote *
      list remote {
        tailf:info "engineID of the remote agent";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key ip-address;
        leaf ip-address {
          type string {
            tailf:info "A.B.C.D or X:X::X;;IP address of remote SNMP notification host";
          }
        }
        leaf engine-id {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;engine ID octet string";
          }
        }
        leaf udp-port {
          tailf:info "The remote notification host's UDP port number";
          type uint16 {
            tailf:info "<1-65535>;;UDP port number";
            range "1..65535";
          }
        }
      }
    }

    // snmp-server host *
    uses snmp-server-host-grouping;

    // snmp-server entityindex
    container entityindex {
      tailf:info "Configuration pertaining to entity indices";
      leaf persist {
        tailf:info "Persist indices";
        type empty;
      }
    }

    // snmp-server vrf *
    list vrf {
      tailf:info "SNMP VRF configuration commands";
      tailf:cli-mode-name "config-snmp-vrf";
      key name;
      leaf name {
        tailf:info "VRF name";
        type string {
          tailf:info "WORD;;VRF name";
        }
      }

      // snmp-server vrf * / host *
      uses snmp-server-host-grouping;

      // snmp-server vrf * / context *
      list context {
        tailf:info "SNMP Context Name";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Context Name";
          }
        }
      }
    }

    // snmp-server ipv4
    container ipv4 {
      tailf:info "Mark the dscp/precedence bit for ipv4 packets";
      choice ipv4-choice {
        leaf dscp {
          tailf:info "Set IP DSCP (DiffServ CodePoint)";
          type dscp-type;
        }
        leaf precedence {
          tailf:info "Set precedence";
          type precedence-type;
        }
      }
    }

    // snmp-server ipv6
    container ipv6 {
      tailf:info "Mark the dscp/precedence bit for ipv6 packets";
      choice ipv6-choice {
        leaf dscp {
          tailf:info "Set IP DSCP (DiffServ CodePoint)";
          type dscp-type;
        }
        leaf precedence {
          tailf:info "Set precedence";
          type precedence-type;
        }
      }
    }

    // snmp-server context
    container context {
      tailf:info "Configure SNMP context";

      // snmp-server context *
      list context-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          tailf:cli-disallow-value "mapping";
          type string {
            tailf:info "WORD;;Context Name";
          }
        }
      }
    }

    // snmp-server community *
    list community {
      tailf:info "Enable SNMP; set community string and access privs";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      cli:secret "snmp-server community ((?:clear |encrypted )?\\S+)" {
        cli:arguments "use-cli-id";
      }
      key name;
      leaf name {
        tailf:cli-disallow-value "clear|encrypted";
        // ISSUE: not possible to have aes128 type due to list key and NSO behaviour
        type string {
          tailf:info "WORD;;The UNENCRYPTED (cleartext) community string";
        }
      }
      leaf type {
        tailf:cli-prefix-key;
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        tailf:cli-incomplete-command;
        type enumeration {
          enum clear {
             tailf:info "Save the community string in encrypted form";
          }
          enum encrypted {
             tailf:info "Specifies an ENCRYPTED community string";
          }
        }
      }

      // snmp-server community * view
      leaf view {
        tailf:info "Restrict this community to a named MIB view";
        tailf:cli-optional-in-sequence;
        type string {
          tailf:info "WORD;;MIB view to which this community has access";
        }
      }

      // snmp-server community * RO
      // snmp-server community * RW
      choice access-choice {
        leaf RO {
          tailf:info "Read-only access with this community string";
          tailf:cli-optional-in-sequence;
          type empty;
        }
        leaf RW {
          tailf:info "Read-write access with this community string";
          tailf:cli-optional-in-sequence;
          type empty;
        }
      }

      // snmp-server community * SDROwner
      // snmp-server community * SystemOwner
      choice owner-choice {
        leaf SDROwner {
          tailf:info "SDR Owner permissions for MIB Objects";
          tailf:cli-optional-in-sequence;
          type empty;
        }
        leaf SystemOwner {
          tailf:info "System Owner permissions for MIB objects";
          tailf:cli-optional-in-sequence;
          type empty;
        }
      }

      // snmp-server community * IPv4 <access-list>
      leaf access-list-type {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        tailf:cli-incomplete-command;
        type enumeration {
          enum IPv4 {
             tailf:info "Type of Access-list";
          }
        }
      }
      leaf access-list {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        tailf:cli-disallow-value "IPv4|IPv6|SDROwner|SystemOwner|RO|RW|view";
        type string {
          tailf:info "WORD;;V4 Access-list name";
        }
      }

      // snmp-server community * IPv6 <access-list>
      leaf IPv6 {
        tailf:info "Type of Access-list";
        tailf:cli-disallow-value "IPv4|IPv6|SDROwner|SystemOwner|RO|RW|view";
        type string {
          tailf:info "WORD;;V6 Access-list name";
        }
      }
    }

    // snmp-server community-map
    container community-map {
      tailf:info "Community Mapping as per RFC-2576";

      // snmp-server community-map *
      list community-map-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;The UNENCRYPTED (cleartext) community string";
          }
        }
        // snmp-server community-map * context
        leaf context {
          tailf:info "Context Name for the community mapping";
          type string {
            tailf:info "WORD;;SNMP Context Name";
          }
        }
      }
    }

    // snmp-server queue-length
    leaf queue-length {
      tailf:info "Message queue length for each TRAP host";
      tailf:cli-full-command;
      type uint32 {
        tailf:info "<1-5000>;;Queue length (default 100)";
        range "1..5000";
      }
    }

    // snmp-server trap-timeout
    leaf trap-timeout {
      tailf:info "Set timeout for TRAP message retransmissions";
      type uint16 {
        tailf:info "<1-1000>;;Timeout (default 30 seconds)";
        range "1..1000";
      }
      default 30;
    }

    // snmp-server contact
    leaf contact {
      tailf:info "Text for mib Object sysContact";
      tailf:cli-no-value-on-delete;
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;identification of the contact person for this managed node";
      }
    }

    // snmp-server location
    leaf location {
      tailf:info "Text for mib Object sysLocation";
      tailf:cli-no-value-on-delete;
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;The physical location of this node";
      }
    }

    // snmp-server logging threshold
    container logging {
      tailf:info "Configuration for logging operations";
      container threshold {
        tailf:info "Configure thresholds for SNMP data logging";

        // snmp-server logging threshold oid-processing
        leaf oid-processing {
          tailf:info "Configure threshold to start logging slow OID requests processing";
          type uint16 {
            tailf:info "<0-20000>;;Threshold in ms (default 500). Set 0 to log every transaction";
            range "0..20000";
          }
        }

        // snmp-server logging threshold pdu-processing
        leaf pdu-processing {
          tailf:info "Configure threshold to start logging slow PDU requests processing";
          type uint16 {
            tailf:info "<0-20000>;;Threshold in ms (default 20000). Set 0 to log every transaction, "
              +"set to 20000 to disable logging PDU processing time";
            range "0..20000";
          }
        }
      }
    }

    // snmp-server trap-source
    container trap-source {
      tailf:info "Assign an interface for the source address of all traps";

      // snmp-server trap-source IPv4
      container IPv4 {
        tailf:info "IPv4 address of the interface";
        uses interface-name-grouping;
      }

      // snmp-server trap-source IPv6
      container IPv6 {
        tailf:info "IPv6 address of the interface";
        uses interface-name-grouping;
      }

      // snmp-server trap-source <interface>
      uses interface-name-grouping;

      // snmp-server trap-source port
      leaf port {
        tailf:info "Change the source port of all traps (default 161).";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<1024-65535>;;UDP port number";
          range "1024..65535";
        }
      }
    }

    // snmp-server oid-poll-stats
    leaf oid-poll-stats {
      tailf:info "Enable OID poll stats oper CLI";
      type empty;
    }

    // snmp-server overload-control
    container overload-control {
      tailf:info "Set overload-control params for handling incoming messages in critical processing mode";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf drop-time {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint16 {
          tailf:info "<0-300>;;Overload drop time (in seconds) for incoming queue (default 1 sec)";
          range "0..300";
        }
      }
      leaf throttle-rate {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<0-1000>;;Overload throttle rate for incoming queue (default 500 msec)";
          range "0..1000";
        }
      }
    }

    // snmp-server mroutemib send-all-vrf
    container mroutemib {
      tailf:info "Configurations related to IPMROUTE-MIB";
      leaf send-all-vrf {
        tailf:info "enable sending all vrf interface info for cIpMRouteInterfaceTable";
        type empty;
      }
    }

    // snmp-server mibs
    container mibs {
      tailf:info "MIB for configurations";

      // snmp-server mibs cbqosmib cache
      container cbqosmib {
        tailf:info "Configure CBQoSMIB parameters";

        // snmp-server mibs cbqosmib persist
        leaf persist {
          tailf:info "Persist CBQoSMIB config, service-policy and object indices";
          type empty;
        }

        // snmp-server mibs cbqosmib cache
        container cache {
          tailf:info "Enable CBQoSMIB stats data caching";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-cbqosmibcache";
          presence true;
          // snmp-server mibs cbqosmib cache / refresh
          container refresh {
            tailf:info "Cache refresh interval";
            leaf time {
              tailf:info "Cache refresh time in seconds";
              type uint16 {
                tailf:info "<5-60>;;Refresh time in secs";
                range "5..60";
              }
            }
          }

          // snmp-server mibs cbqosmib cache / service-policy
          container service-policy {
            tailf:info "Maximum number of service policies to cache the statistics for";
            leaf count {
              tailf:info "Number of service-policy stats";
              type uint16 {
                tailf:info "<1-5000>;;Number of service-policys";
                range "1..5000";
              }
            }
          }
        }

        // snmp-server mibs cbqosmib member-stats
        leaf member-stats {
          tailf:info "Enable bundle member interface statistics retrieval";
          type empty;
        }
      }

      // snmp-server mibs eventmib
      container eventmib {
        tailf:info "Event MIB configuration";

        // snmp-server mibs eventmib packet-loss *
        list packet-loss {
          tailf:info "Packet Loss threshold monitoring";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-incomplete-command;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Interface Name";
            }
          }
          leaf rising {
            tailf:info "Upper threshold value";
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<0-2147483647>;;Trigger Trap when Delta above this value";
            }
          }
          leaf falling {
            tailf:info "Lower threshold value";
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<0-2147483647>;;Trigger Trap when Delta below this value";
            }
          }
          leaf interval {
            tailf:info "Packet loss sampling interval in multiples of 5 mins";
            type uint16 {
              tailf:info "<5-1440>;;Interval in multiples of 5 mins";
            }
          }
        }
      }

      // snmp-server mibs sensormib cache
      container sensormib {
        tailf:info "sensormib related config";
        leaf cache {
          tailf:info "Enables sensormib caching";
          type empty;
        }
      }
    }

    // snmp-server trap
    container trap {
      tailf:info "MIB trap configurations";
      leaf link {
        tailf:info "Link up/down trap configuration";
        tailf:cli-full-command;
        type enumeration {
          enum ietf {
                     tailf:info "Set the varbind of linkupdown trap to the RFC specified varbinds (default cisco)";
          }
        }
      }
      leaf throttle-time {
        tailf:info "Set throttle time for handling more traps";
        default "250";
        type uint16 {
          tailf:info "<10-500>;;Time in msec (default 250 msecs)";
        }
      }
      container authentication {
        tailf:info "Configure authentication trap";
        container vrf {
          tailf:info "VRF configuration";
          leaf disable {
            tailf:info "Disable authentication traps for packets on a vrf";
            type empty;
          }
        }
      }
    }

    // snmp-server drop
    container drop {
      tailf:info "Drop packets";

      // snmp-server drop unknown-user
      leaf unknown-user {
        tailf:info "Silently drop unknown v3 user packets";
        type empty;
      }
    }

    // snmp-server user *
    list user {
      tailf:info "Define a user who can access the SNMP engine";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-incomplete-command;
      key username;
      leaf username {
        type string {
          tailf:info "WORD;;Name of the user";
        }
      }

      leaf groupname {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type string {
          tailf:info "WORD;;Group to which the user belongs";
        }
      }

      leaf remote {
        tailf:info "Specify a remote SNMP entity to which the user belongs";
        tailf:cli-optional-in-sequence;
        type inet:host {
          tailf:info "A.B.C.D or X:X::X;;IP address of remote SNMP entity";
        }
      }
      leaf udp-port {
        tailf:info "The remote SNMP entity's UDP port number";
        tailf:cli-optional-in-sequence;
        when "../remote";
        type uint16 {
          tailf:info "<1-65535>;;The remote SNMP entity's UDP port number";
        }
      }

      leaf version {
        tailf:cli-drop-node-name;
        type enumeration {
          enum v1 {
            tailf:info "user using the v1 security model";
          }
          enum v2c {
            tailf:info "user using the v2c security model";
          }
          enum v3 {
            tailf:info "user using the v3 security model";
          }
        }
      }

      // auth { md5 | sha } { clear | encrypted } auth-password
      container auth {
        when "../version = 'v3'";
        tailf:info "authentication parameters for the user";
        tailf:cli-optional-in-sequence;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        cli:secret " auth (?:md5|sha) ((?:clear |encrypted )?\\S+)";
        leaf level {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type enumeration {
            enum md5 {
              tailf:info "Use HMAC MD5 algorithm for authentication";
            }
            enum sha {
              tailf:info "Use HMAC SHA algorithm for authentication";
            }
          }
        }
        choice password-choice {
          leaf auth-password {
            tailf:cli-drop-node-name;
            tailf:cli-disallow-value "clear|encrypted";
            type NEDCOM_SECRET_TYPE {
              tailf:info "LINE;;The UNENCRYPTED (cleartext) authentication password";
            }
          }
          leaf clear {
            tailf:info "Specifies an UNENCRYPTED password will follow";
            type NEDCOM_SECRET_TYPE {
              tailf:info "LINE;;The UNENCRYPTED (cleartext) authentication password";
            }
          }
          leaf encrypted {
            tailf:info "Specifies an ENCRYPTED password will follow";
            type string {
              tailf:info "LINE;;The ENCRYPTED authentication password";
            }
          }
        }
      }

      // priv { 3des | aes <bits> | des56 } { clear | encrypted } priv-password
      container priv {
        when "../auth";
        tailf:info "encryption parameters for the user";
        tailf:cli-optional-in-sequence;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        cli:secret " priv (?:3des|des56|(?:aes (?:128|192|256))) ((?:clear |encrypted )?\\S+)";
        choice priv-level {
          leaf threedes {
            tailf:alt-name "3des";
            tailf:info "Use 168 bit 3DES algorithm for encryption";
            tailf:cli-incomplete-command;
            type empty;
          }
          leaf aes {
            tailf:info "AES - Advanced Encryption Standard.";
            tailf:cli-incomplete-command;
            type enumeration {
              enum "128" {
                tailf:info "Use AES 128 bit encryption";
              }
              enum "192" {
                tailf:info "Use AES 192 bit encryption";
              }
              enum "256" {
                tailf:info "Use AES 256 bit encryption";
              }
            }
          }
          leaf des56 {
            tailf:info "Use 56 bit DES algorithm for encryption";
            tailf:cli-incomplete-command;
            type empty;
          }
        }
        choice password-choice {
          leaf priv-password {
            tailf:cli-drop-node-name;
            tailf:cli-disallow-value "clear|encrypted";
            type NEDCOM_SECRET_TYPE {
              tailf:info "LINE;;The UNENCRYPTED (cleartext) privacy password";
            }
          }
          leaf clear {
            tailf:info "Specifies an UNENCRYPTED password will follow";
            type NEDCOM_SECRET_TYPE {
              tailf:info "LINE;;The UNENCRYPTED (cleartext) privacy password";
            }
          }
          leaf encrypted {
            tailf:info "Specifies an ENCRYPTED password will follow";
            type string {
              tailf:info "LINE;;The ENCRYPTED privacy password";
            }
          }
        }
      }

      leaf access-list-type {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        tailf:cli-incomplete-command;
        type enumeration {
          enum IPv4 {
             tailf:info "Type of Access-list";
          }
          enum IPv6 {
             tailf:info "Type of Access-list";
          }
        }
      }

      leaf access-list {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        tailf:cli-disallow-value "SDROwner|SystemOwner";
        type string {
          tailf:info "WORD;;Access-list name";
        }
      }

      choice owner-choice {
        leaf SDROwner {
          tailf:info "SDR Owner permissions for MIB Objects";
          type empty;
        }
        leaf SystemOwner {
          tailf:info "System Owner permissions for MIB objects";
          type empty;
        }
      }
    }

    // snmp-server view *
    list view {
      tailf:info "Define an SNMPv2 MIB view";
      tailf:cli-suppress-mode;
      tailf:cli-incomplete-command;
      tailf:cli-compact-syntax;
      tailf:cli-delete-when-empty;
      key view-name;
      leaf view-name {
        type string {
          tailf:info "WORD;;Name of the view";
        }
      }
      list oid-list {
        tailf:cli-suppress-mode;
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        key oid-tree;
        leaf oid-tree {
          type string {
            tailf:info "WORD;;MIB view family name";
          }
        }
        leaf viewmode {
          tailf:cli-drop-node-name;
          type enumeration {
            enum excluded {
                           tailf:info "MIB family is excluded from the view";
            }
            enum included {
                           tailf:info "MIB family is included in the view";
            }
          }
        }
      }
    }

    // snmp-server group *
    list group {
      tailf:info "Define a User Security Model group";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      tailf:cli-incomplete-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Name of the group";
        }
      }
      choice version-choice {
        leaf v1 {
          tailf:info "group using the v1 security model";
          type empty;
        }
        leaf v2c {
          tailf:info "group using the v2c security model";
          type empty;
        }
        leaf v3 {
          tailf:info "group using the User Security Model (SNMPv3)";
          type enumeration {
            enum auth {
                       tailf:info "group using the authNoPriv Security Level";
            }
            enum noauth {
                         tailf:info "group using the noAuthNoPriv Security Level";
            }
            enum priv {
                       tailf:info "group using authPriv Security Level";
            }
          }
        }
      }

      // snmp-server group * read
      leaf read {
        tailf:cli-break-sequence-commands;
        tailf:info "specify a notify view for the group";
        type string {
          tailf:info "WORD;;read view name";
          length "1..64";
        }
      }

      // snmp-server group * write
      leaf write {
        tailf:info "specify a write view for this group";
        type string {
          tailf:info "WORD;;write view name";
          length "1..64";
        }
      }

      // snmp-server group * notify
      leaf notify {
        tailf:info "specify a notify view for the group";
        type string {
          tailf:info "WORD;;notify view name";
          length "1..64";
        }
      }

      // snmp-server group * context
      leaf context {
        tailf:info "Attach a SNMP context";
        type string {
          tailf:info "WORD;;SNMP Context Name";
        }
      }

      // snmp-server group * IPv4
      leaf access-list-type {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type enumeration {
          enum IPv4 {
              tailf:info "Type of Access-list";
          }
        }
      }
      leaf access-list {
        tailf:cli-drop-node-name;
        tailf:cli-disallow-value "v1|v2c|v3|read|write|notify|context|IPv4|IPv6";
        type string {
          tailf:info "WORD;;V4 Access-list name";
          length "1..64";
        }
      }

      // snmp-server group * IPv6
      leaf IPv6 {
        tailf:info "Type of Access-list";
        type string {
          tailf:info "WORD;;V6 Access-list name";
        }
      }
    }

    // snmp-server interface
    container interface {
      tailf:info "Enter the SNMP interface configuration commands";

      // snmp-server interface subset *
      list subset {
        tailf:info "Add configuration for an interface subset";
        tailf:cli-mode-name "config-snmp-if-subset";
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          type uint8 {
            tailf:info "<1-255>;;The interface subset number";
            range "1..255";
          }
        }
        leaf regular-expression {
          tailf:info "Interfaces matching regular expression";
          tailf:cli-hide-in-submode;
          cisco-ios-xr:regex-string;
          tailf:cli-no-value-on-delete;
          type string {
            tailf:info "WORD;;Regular expression to match ifName";
          }
        }

        // snmp-server interface subset */ notification linkupdown
        container notification {
          tailf:cli-break-sequence-commands;
          tailf:info "Allow an SNMP notification type";
          container linkupdown {
            tailf:info "SNMP linkUp and linkDown notifications";
            tailf:cli-delete-when-empty;
            presence true;

            // snmp-server interface subset * / notification linkupdown disable
            leaf disable {
              tailf:info "Disable linkUp and linkDown notification";
              type empty;
            }
          }
        }
      }

      // snmp-server interface *
      list interface-name {
        tailf:cli-drop-node-name;
        tailf:cli-mode-name "config-snmp-if";
        key ifname;
        leaf ifname {
          tailf:cli-disallow-value "subset";
          type ifname;
        }

        // snmp-server interface * / index persistence
        container index {
          tailf:info "Configure ifIndex attributes";
          leaf persistence {
            tailf:info "Persistency across system reloads";
            type empty;
          }
        }

        // snmp-server interface */ notification linkupdown
        container notification {
          tailf:info "Allow an SNMP notification type";
          container linkupdown {
            tailf:info "SNMP linkUp and linkDown notifications";
            tailf:cli-delete-when-empty;
            presence true;

            // snmp-server interface * / notification linkupdown disable
            leaf disable {
              tailf:info "Disable linkUp and linkDown notification";
              type empty;
            }
          }
        }

      }
    }

    // snmp-server chassis-id
    leaf chassis-id {
      tailf:info "String to uniquely identify this chassis";
      tailf:cli-full-command;
      tailf:cli-multi-value;
      type string {
        tailf:info "LINE;;Unique ID string";
      }
    }

    // snmp-server traps
    container traps {
      tailf:info "Enable SNMP traps";

      // snmp-server traps *
      list traps-list {
        when "not(../../../tailfned/api/snmp-server-enable-all-traps)" {
          tailf:dependency "../../../tailfned/api/snmp-server-enable-all-traps";
        }
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          tailf:cli-multi-word-key;
          tailf:cli-disallow-value "all-traps"; // to avoid accidental misconfiguration
          type string {
            tailf:info "WORD;;snmp-server traps <entry>";
          }
        }
      }

      // snmp-server traps all-traps
      leaf all-traps {
        tailf:info "use with 'api/snmp-server-enable-all-traps' ned-setting to enable all traps on device";
        when "../../../tailfned/api/snmp-server-enable-all-traps" {
          tailf:dependency "../../../tailfned/api/snmp-server-enable-all-traps";
        }
        cisco-ios-xr:snmp-server-all-traps;
        type empty;
      }
    }

    // snmp-server timeouts
    container timeouts {
      tailf:info "SNMP timeouts";

      // snmp-server timeouts duplicate
      leaf duplicate {
        tailf:info "Duplicate request feature timeout";
        type uint8 {
          tailf:info "<0-20>;;timeout in secs (default 1)";
          range "0..20";
        }
        default 1;
      }

      // snmp-server timeouts subagent
      leaf subagent {
        tailf:info "Sub-Agent Request timeout";
        type uint8 {
          tailf:info "<1-20>;;timeout in secs (default 10)";
          range "1..20";
        }
        default 10;
      }

      // snmp-server timeouts inQdrop
      leaf inQdrop {
        tailf:info "incoming queue drop feature";
        default 10;
        type uint8 {
          tailf:info "<0-20>;;timeout in secs (default 10)";
        }
      }

      // snmp-server timeouts threshold
      leaf threshold {
        tailf:info "threshold incoming queue drop feature";
        default 50000;
        type uint32 {
          tailf:info "<0-100000>;;Max number of packets in Pre processing Q(default 50000)";
        }
      }

    }
  }


  /// ========================================================================
  /// virtual-service
  /// ========================================================================

  container virtual-service {
    tailf:info "Configure virtual services";
    tailf:cli-explicit-exit;

    // virtual-service enable
    leaf enable {
      tailf:info "Enable virtual service";
      type empty;
    }

    // virtual-service *
    list virtual-service-list {
      tailf:cli-drop-node-name;
      tailf:cli-mode-name "config-virt-service";
      key name;
      leaf name {
        tailf:cli-disallow-value "enable";
        type string {
          tailf:info "WORD;;Name of virtual service";
        }
      }
    }
  }


  /// ========================================================================
  /// srlg
  /// ========================================================================

  container srlg {
    tailf:info "SRLG configuration commands";
    tailf:cli-add-mode;
    tailf:cli-explicit-exit;
    presence true;

    grouping value-list-grouping {
      list value-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          type uint16 {
            tailf:info "<1-65535>;;Index number for this value";
          }
        }
        leaf value {
          tailf:info "Configure SRLG network value";
          type uint32 {
            tailf:info "<0-4294967295>;;Network SRLG value";
          }
        }
        leaf priority {
          tailf:info "Set prority for the value";
          type enumeration {
            enum verylow {
              tailf:info "Very low priority";
            }
            enum low {
              tailf:info "Low priority";
            }
            enum high {
              tailf:info "High priority";
            }
            enum critical {
              tailf:info "Critical priority";
            }
          }
        }
      }
    }

    // srlg / interface *
    list interface {
      tailf:info "SRLG interface configuration submode";
      tailf:cli-mode-name "config-srlg-if";
      key id;
      leaf id {
        type string {
          tailf:info "WORD;;Interface Name";
        }
      }

      // srlg / interface * / * value
      uses value-list-grouping;

      // srlg / interface * / name *
      list name-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          tailf:info "Bind this SRLG name to the interface";
          tailf:cli-expose-key-name;
          type string {
            tailf:info "WORD;;SRLG Name";
          }
        }
      }

      // srlg / interface * / group
      container group {
        tailf:cli-add-mode;
        presence true;
        list index-list {
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-drop-node-name;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-compact-syntax;
          key index;
          leaf index {
            type uint8 {
              tailf:info "<1-1>;;Group index number for this entry";
              range "1";
            }
          }
          leaf name {
            tailf:cli-drop-node-name;
            mandatory true;
            type string {
              tailf:info "WORD;;Group name";
            }
          }
        }
      }
    }

    // srlg / name * value
    list name {
      tailf:info "SRLG name to value mapping";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;SRLG Name";
        }
      }
      leaf value {
        tailf:info "Configure SRLG network value";
        tailf:cli-no-name-on-delete;
        tailf:cli-no-value-on-delete;
        type uint32 {
          tailf:info "<0-4294967295>;;Network SRLG value";
        }
      }
    }

    // srlg / group
    list group {
      tailf:info "SRLG group configuration submode";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Group name";
        }
      }
      // srlg / group / * value
      uses value-list-grouping;
    }
  }


  /// ========================================================================
  /// monitor-session
  /// ========================================================================

  // monitor-session *
  list monitor-session {
    tailf:info "Monitor-session configuration commands";
    tailf:cli-mode-name "config-mon";
    tailf:cli-explicit-exit;
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;Session Name";
      }
    }
    // monitor-session * ethernet
    choice type-choice {
      leaf ethernet {
        tailf:info "Specify the destination that traffic should be replicated to";
        tailf:cli-hide-in-submode;
        type empty;
      }
      leaf ipv4 {
        tailf:info "Replicate IPv4 traffic";
        tailf:cli-hide-in-submode;
        type empty;
      }
      leaf ipv6 {
        tailf:info "Replicate IPv6 traffic";
        tailf:cli-hide-in-submode;
        type empty;
      }
    }

    // monitor-session * / destination
    container destination {
      tailf:info "Specify the destination that traffic should be replicated to";
      choice destination-choice {

        // monitor-session * / destination pseudowire
        leaf pseudowire {
          tailf:info "Specify a pseudowire";
          type empty;
        }

        // monitor-session * / destination interface
        container interface {
          tailf:info "Specify a destination interface";
          uses interface-name-grouping;
        }

        // monitor-session * / destination next-hop
        leaf next-hop {
          type inet:ipv4-address;
        }

        container file {
          presence true;
          tailf:info "Specify destination as a file";
          leaf size {
            tailf:info "Specify the packet buffer size";
            type uint32 {
              tailf:info "<1-16777216>;;Specify size of buffer in kilobytes";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// spanning-tree
  /// ========================================================================

  container spanning-tree {
    tailf:info "Spanning Tree Subsystem";
    tailf:cli-explicit-exit;

    // spanning-tree extend
    container extend {
      tailf:info "Spanning Tree 802.1t extensions";
      leaf system-id {
        tailf:info "Extend system-id into priority portion of the bridge id (PVST & Rapid PVST only)";
        type empty;
      }
    }

    // spanning-tree mode
    leaf mode {
      tailf:info "Spanning tree operating mode";
      type enumeration {
        enum mst {
          tailf:info "Multiple spanning tree mode";
        }
        enum rapid-pvst {
          tailf:info "Per-Vlan rapid spanning tree mode";
        }
      }
    }

    // spanning-tree mst
    container mst {
      tailf:info "Configure Multiple Spanning Tree Protocol.";

      // spanning-tree mst *
      list range {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-range-list-syntax;
        key id;
        leaf id {
          type uint8 {
            tailf:info "WORD;;MST instance range, example: 0-3,5,7-9";
          }
        }
        leaf priority {
          tailf:info "Set the bridge priority for the spanning tree";
          type uint16 {
            tailf:info "<0-61440>;;bridge priority in increments of 4096";
            range "0..61440";
          }
        }
      }

      // spanning-tree mst *
      list protocol-instance {
        tailf:cli-drop-node-name;
        tailf:cli-mode-name "config-mstp";
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;Protocol Instance name.";
          }
        }

        // spanning-tree mst * / name
        leaf name {
          tailf:info "Configuration name";
          type string {
            tailf:info "WORD;;Configuration name";
          }
        }

        // spanning-tree mst * / maximum
        container maximum {
          tailf:info "Bridge maximums, such as max-age";
          // spanning-tree mst * / maximum age
          leaf age {
            tailf:info "Bridge maximum age time.";
            type uint8 {
              tailf:info "<6-40>;;Bridge Maximum Age time in seconds.";
              range "6..40";
            }
          }
          // spanning-tree mst * / maximum hops
          leaf hops {
            tailf:info "Bridge maximum number of hops.";
            type uint8 {
              tailf:info "<6-40>;;Bridge Maximum number of hops.";
            }
          }
        }

        // spanning-tree mst * / revision
        leaf revision {
          tailf:info "Bridge revision number.";
          type uint16 {
            tailf:info "<0-65535>;;Revision number.";
          }
        }

        // spanning-tree mst * / bringup delay for
        container bringup {
          tailf:info "Bringup options.";
          container delay {
            tailf:info "Bringup delay for newly created interfaces.";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf for {
              tailf:info "Specify length of time to delay bringup for";
              tailf:cli-incomplete-command;
              type uint16 {
                tailf:info "<0-3600>;;Length of time to delay for (hours, minutes, or seconds)";
              }
            }
            leaf unit {
              tailf:cli-drop-node-name;
              type enumeration {
                enum seconds {
                  tailf:info "Time is in seconds";
                }
                enum minutes {
                  tailf:info "Time is in minutes";
                }
                enum hours {
                  tailf:info "Time is in hours";
                }
              }
            }
          }
        }

        // spanning-tree mst * / forward-delay
        leaf forward-delay {
          tailf:info "Bridge forward delay time.";
          type uint8 {
            tailf:info "<4-30>;;Forward delay time in seconds.";
            range "4..30";
          }
        }

        // spanning-tree mst * / transmit hold-count
        container transmit {
          tailf:info "Bridge transmit options";
          leaf hold-count {
            tailf:info "Bridge Transmit Hold Count.";
            type uint8 {
              tailf:info "<1-10>;;Bridge Transmit Hold Count.";
            }
          }
        }

        // spanning-tree mst * / provider-bridge
        leaf provider-bridge {
          tailf:info "Provider Bridge mode.";
          type empty;
        }

        // spanning-tree mst * / instance *
        list instance {
          tailf:info "Configure an MSTP instance.";
          tailf:cli-mode-name "config-mstp-inst";
          key id;
          leaf id {
            type uint16 {
              tailf:info "<0-4094>;;MSTI ID";
              range "0..4094";
            }
          }

          // spanning-tree mst * / instance * / priority
          leaf priority {
            tailf:info "MSTI Priority.";
            type uint16 {
              tailf:info "<0-61440>;;MSTI Priority. Must be a multiple of 4096.";
              range "0..61440" {
                tailf:step 4096;
              }
            }
          }

          // spanning-tree mst * / instance * / vlan-ids
          leaf-list vlan-ids {
            tailf:info "Assign ranges of VLANs to the specified MSTI.";
            tailf:cli-range-list-syntax;
            tailf:cli-replace-all;
            type uint16 {
              tailf:info "WORD;;List of VLAN Ranges in the form a-b,c,d,e-f,g";
            }
          }
        }

        // spanning-tree mst * / interface *
        list interface {
          tailf:info "Enable and Configure MSTP on an interface.";
          tailf:cli-mode-name "config-mstp-if";
          key ifname;
          leaf ifname {
            type ifname;
          }

          // spanning-tree mst * / interface * / portfast
          container portfast {
            tailf:info "Set PortFast on Interface.";
            presence true;
          }

          // spanning-tree mst * / interface * / instance * cost
          list instance {
            tailf:info "MSTI Specific configuration for this interface.";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-incomplete-command;
            key id;
            leaf id {
              type uint16 {
                tailf:info "<0-4094>;;MSTI ID";
                range "0..4094";
              }
            }
            leaf cost {
              tailf:info "Cost of this port on this MSTI.";
              type uint32 {
                tailf:info "<1-200000000>;;Port Cost";
                range "1..200000000";
              }
            }
          }

          // spanning-tree mst * / interface * / link-type
          leaf link-type {
            tailf:info "Configure the Link Type of an Interface.";
            tailf:cli-full-command;
            type enumeration {
              enum multipoint {
                tailf:info "Multipoint link.";
              }
              enum point-to-point {
                tailf:info "Point to Point link.";
              }
            }
          }

          // spanning-tree mst * / interface * / guard
          container guard {
            tailf:info "Configure bridge guard features";
            leaf root {
              tailf:info "Set Guard Root on Interface.";
              type empty;
            }
            leaf topology-change {
              tailf:info "Set Guard topology-change on Interface.";
              type empty;
            }
          }

          // spanning-tree mst * / interface * / hello-time
          leaf hello-time {
            tailf:info "Interface Hello Time.";
            type uint8 {
              tailf:info "<1-2>;;Interface Hello Time in seconds.  Only 2 is supported on bundles.";
              range "1..2";
            }
          }

          // spanning-tree mst * / interface * / external-cost
          leaf external-cost {
            tailf:info "Interface External Cost.";
            tailf:cli-full-command;
            type uint32 {
              tailf:info "<1-200000000>;;Interface External Cost.";
              range "1..200000000";
            }
          }
        }
      }
    }

    // spanning-tree portfast
    leaf portfast {
      tailf:info "Spanning tree portfast options";
      type enumeration {
        enum disable {
          tailf:info "Disable portfast for this interface";
        }
        enum edge {
          tailf:info "Enable portfast edge on the interface";
        }
        enum network {
          tailf:info "Enable portfast network on the interface";
        }
      }
    }

    // spanning-tree mstag *
    list mstag {
      tailf:info "Configure MST Access Gateway";
      tailf:cli-mode-name "config-mstag";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Protocol Instance name.";
        }
      }

      // spanning-tree mstag * / interface *
      list interface {
        tailf:cli-mode-name "config-mstag-if";
        key ifname;
        leaf ifname {
          type ifname;
        }

        // spanning-tree mstag * / interface * / name
        leaf name {
          tailf:info "Configuration name";
          type string {
            tailf:info "WORD;;Configuration name";
          }
        }

        // spanning-tree mstag * / interface * / revision
        leaf revision {
          tailf:info "Bridge revision number.";
          type uint16 {
            tailf:info "<0-65535>;;Revision number.";
          }
        }

        // spanning-tree mstag * / interface * / port-id
        leaf port-id {
          tailf:info "Interface Port ID.";
          type uint16 {
            tailf:info "<1-4095>;;Interface Port ID.";
            range "1..4095";
          }
        }

        // spanning-tree mstag * / interface * / bridge-id
        leaf bridge-id {
          tailf:info "Set the Bridge ID this port should use";
          type string {
            tailf:info "H.H.H;;MAC address";
            pattern '[0-9a-fA-F]+\.[0-9a-fA-F]+\.[0-9a-fA-F]+';
          }
        }

        // spanning-tree mstag * / interface * / instance *
        list instance {
          tailf:info "Enable and Configure an instance on this interface.";
          tailf:cli-mode-name "config-mstag-if-inst";
          key id;
          leaf id {
            type uint16 {
              tailf:info "<0-4094>;;MSTI ID";
              range "0..4094";
            }
          }

          // spanning-tree mstag * / interface * / instance * / cost
          container cost {
            tailf:info "Cost of this port on this MSTI.";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf cost-value {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<1-200000000>;;Port Cost";
                range "1..200000000";
              }
            }
            leaf startup-value {
              tailf:info "Set the cost of this port on this MSTI to be used during pre-empt delay";
              type uint32 {
                tailf:info "<1-200000000>;;Port Cost";
                range "1..200000000";
              }
            }
          }

          // spanning-tree mstag * / interface * / instance * / vlan-ids *
          leaf-list vlan-ids {
            tailf:info "Assign ranges of VLANs to the specified MSTI.";
            tailf:cli-range-list-syntax;
            type uint16 {
              tailf:info "WORD;;List of VLAN Ranges in the form a-b,c,d,e-f,g";
            }
          }

          // spanning-tree mstag * / interface * / instance * / root-id
          container root-id {
            tailf:info "Set the Bridge ID of the root for this instance";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf root-id-value {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "H.H.H;;MAC address";
                pattern '[0-9a-fA-F]+\.[0-9a-fA-F]+\.[0-9a-fA-F]+';
              }
            }
            leaf startup-value {
              tailf:info "Set the Bridge ID to be used during pre-empt delay";
              type string {
                tailf:info "H.H.H;;MAC address";
                pattern '[0-9a-fA-F]+\.[0-9a-fA-F]+\.[0-9a-fA-F]+';
              }
            }
          }

          // spanning-tree mstag * / interface * / instance * / edge-mode
          leaf edge-mode {
            tailf:info "Enable Access Gateway Edge Mode for this MSTI.";
            type empty;
          }

          // spanning-tree mstag * / interface * / instance * / priority
          container priority {
            tailf:info "MSTI Priority.";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf priority-value {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<0-61440>;;MSTI Priority. Must be a multiple of 4096.";
                range "0..61440" {
                  tailf:step 4096;
                }
              }
            }
            leaf startup-value {
              tailf:info "Set the MSTI Priority to be used during pre-empt delay";
              type uint16 {
                tailf:info "<0-61440>;;MSTI Priority. Must be a multiple of 4096.";
                range "0..61440" {
                  tailf:step 4096;
                }
              }
            }
          }

          // spanning-tree mstag * / interface * / instance * / root-priority
          container root-priority {
            tailf:info "Priority of the root for this instance.";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf priority-value {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<0-61440>;;MSTI Priority. Must be a multiple of 4096.";
                range "0..61440" {
                  tailf:step 4096;
                }
              }
            }
            leaf startup-value {
              tailf:info "Set the priority of the root for this instance to be used during pre-empt delay";
              type uint16 {
                tailf:info "<0-61440>;;MSTI Priority. Must be a multiple of 4096.";
                range "0..61440" {
                  tailf:step 4096;
                }
              }
            }
          }
        }

        // spanning-tree mstag * / interface * / hello-time
        leaf hello-time {
          tailf:info "Interface Hello Time";
          type uint8 {
            tailf:info "<1-2>;;Interface Hello Time in seconds. Only 2 is supported on bundles";
            range "1..2";
          }
        }
      }
    }

    // spanning-tree pvstag *
    list pvstag {
      tailf:info "Configure PVST+ Access Gateway";
      tailf:cli-mode-name "config-pvstag";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Protocol Instance name.";
        }
      }

      // spanning-tree pvstag * / interface *
      list interface {
        tailf:info "Enable and Configure PVST+AG on an interface";
        tailf:cli-mode-name "config-pvstag-if";
        key ifname;
        leaf ifname {
          type ifname;
        }

        // spanning-tree pvstag * / interface * / vlan *
        list vlan {
          tailf:info "Enable and Configure a VLAN on this interface";
          tailf:cli-mode-name "config-pvstag-if-vlan";
          key id;
          leaf id {
            type uint16 {
              tailf:info "<1-4094>;;VLAN ID";
              range "1..4094";
            }
          }

          // spanning-tree pvstag * / interface * / vlan * / root-priority
          container root-priority {
            tailf:info "Priority of the root to send in BPDUs";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf value {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<0-65535>;;Root Priority. For PVRSTAG, must be a multiple of 4096.";
                range "0..65535" {
                  tailf:step 4096;
                }
              }
            }
            leaf startup-value {
              tailf:info "Set the priority of the root to be used during pre-empt delay";
              type uint16 {
                tailf:info "<0-65535>;;Root Priority. For PVRSTAG, must be a multiple of 4096.";
                range "0..65535" {
                  tailf:step 4096;
                }
              }
            }
          }

          // spanning-tree pvstag * / interface * / vlan * / root-id
          container root-id {
            tailf:info "Bridge ID of the root to send in BPDUs";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf value {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "H.H.H;;MAC address";
              }
            }
            leaf startup-value {
              tailf:info "Set the root bridge ID to be used during pre-empt delay";
              type string {
                tailf:info "H.H.H;;MAC address";
              }
            }
          }

          // spanning-tree pvstag * / interface * / vlan * / root-cost
          container root-cost {
            tailf:info "Root cost to send in BPDUs";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf value {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<0-4294967295>;;Root Cost";
              }
            }
            leaf startup-value {
              tailf:info "Set the cost of the root to send in BPDUs to be used during pre-empt delay";
              type uint32 {
                tailf:info "<0-4294967295>;;Root Cost";
              }
            }
          }

          // spanning-tree pvstag * / interface * / vlan * / priority
          container priority {
            tailf:info "Priority of the Bridge to send in BPDUs";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf value {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<0-65535>;;Bridge Priority. For PVRSTAG, must be a multiple of 4096.";
                range "0..65535" {
                  tailf:step 4096;
                }
              }
            }
            leaf startup-value {
              tailf:info "Set the priority of this bridge to be used during pre-empt delay";
              type uint16 {
                tailf:info "<0-65535>;;Bridge Priority. For PVRSTAG, must be a multiple of 4096.";
                range "0..65535" {
                  tailf:step 4096;
                }
              }
            }
          }

          // spanning-tree pvstag * / interface * / vlan * / bridge-id
          container bridge-id {
            tailf:info "Bridge ID to use in BPDUs";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf value {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "H.H.H;;MAC address";
              }
            }
            leaf startup-value {
              tailf:info "Set the Bridge ID to be used during pre-empt delay";
              type string {
                tailf:info "H.H.H;;MAC address";
              }
            }
          }

          // spanning-tree pvstag * / interface * / vlan * / port-priority
          container port-priority {
            tailf:info "Port priority to send in BPDUs";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf value {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<0-255>;;Port Priority. For PVRSTAG, must be a multiple of 16.";
              }
            }
            leaf startup-value {
              tailf:info "Set the priority of this port to be used during pre-empt delay";
              type uint8 {
                tailf:info "<0-255>;;Port Priority. For PVRSTAG, must be a multiple of 16.";
              }
            }
          }

          // spanning-tree pvstag * / interface * / vlan * / port-id
          container port-id {
            tailf:info "Interface Port ID to send in BPDUs";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf value {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<0-255>;;Port ID.";
              }
            }
            leaf startup-value {
              tailf:info "Set the Port ID to be used during pre-empt delay";
              type uint8 {
                tailf:info "<0-255>;;Port ID.";
              }
            }
          }

          // spanning-tree pvstag * / interface * / vlan * / max age
          container max {
            tailf:info "Maximum age to send in BPDUs";
            leaf age {
              tailf:info "Maximum age to send in BPDUs";
              type uint8 {
                tailf:info "<6-40>;;Maximum Age time in seconds";
                range "6..40";
              }
            }
          }

          // spanning-tree pvstag * / interface * / vlan * / hello-time
          leaf hello-time {
            tailf:info "How often to send BPDUs";
            type uint8 {
              tailf:info "<1-2>;;How often to send BPDUs";
              range "1..2";
            }
          }
        }
      }
    }

    // spanning-tree repag *
    list repag {
      tailf:info "Configure REP Access Gateway";
      tailf:cli-mode-name "config-repag";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Protocol Instance name.";
        }
      }
      // spanning-tree repag * / interface *
      list interface {
        tailf:cli-mode-name "config-repag-if";
        key ifname;
        leaf ifname {
          type ifname;
        }
      }
    }

    // spanning-tree pvrst *
    list pvrst {
      tailf:info "Configure Per-VLAN Rapid Spaning Tree Protocol.";
      tailf:cli-mode-name "config-pvrst";
      key name;
      leaf name {
        tailf:info "WORD;;Protocol Instance name.";
        type string;
      }

      // spanning-tree pvrst * / vlan *
      list vlan {
        tailf:info "Configure PVRST on a VLAN.";
        tailf:cli-mode-name "config-pvrst-vlan";
        key id;
        leaf id {
          type uint16 {
            tailf:info "<1-4094>;;VLAN ID";
            range "1..4094";
          }
        }
        // spanning-tree pvrst * / vlan * / priority
        leaf priority {
          tailf:info "Bridge Priority.";
          type uint16 {
            tailf:info "<0-61440>;;Bridge Priority. Must be a multiple of 4096.";
            range "0..61440";
          }
        }
      }

      // spanning-tree pvrst * / interface *
      list interface {
        tailf:info "Enable and Configure PVRST on an interface.";
        tailf:cli-mode-name "config-pvrst-if";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Interface Name";
          }
        }

        // spanning-tree pvrst * / interface * / vlan * cost
        list vlan {
          tailf:info "VLAN Specific configuration for this interface.";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          key id;
          leaf id {
            type uint16 {
              tailf:info "<1-4094>;;VLAN ID";
              range "1..4094";
            }
          }
          leaf cost {
            tailf:info "Cost of this port on this VLAN.";
            type uint32 {
              tailf:info "<1-200000000>;;Port Cost";
              range "1..200000000";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// isolation
  /// ========================================================================

  container isolation {
    tailf:info "Configure Isolation";

    // isolation enable
    leaf enable {
      tailf:info "Enable isolation for RP/DRP nodes";
      type empty;
    }

    // isolation multiple
    leaf multiple {
      tailf:info "Allow the rp isolation feature to handle multiple requests";
      type empty;
    }
  }


  /// ========================================================================
  /// redundancy
  /// ========================================================================

  container redundancy {
    tailf:info "Interchassis redundancy configuration";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-redundancy";
    tailf:cli-explicit-exit;

    // redundancy iccp
    container iccp {
      tailf:info "configure iccp parameter";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-redundancy-iccp";

      // redundancy / iccp / group *
      list group {
        tailf:info "group configuration";
        tailf:cli-mode-name "config-redundancy-iccp-group";
        key id;
        leaf id {
          type uint32 {
            tailf:info "<1-4294967295>;;Enter group number";
            range "1..4294967295";
          }
        }

        // redundancy / iccp / group * / mlacp
        container mlacp {
          tailf:info "Multi-chassis Link Aggregation Control Protocol commands";

          // redundancy / iccp / group * / mlacp node
          leaf node {
            tailf:info "Set mLACP node ID to use in this ICCP Group";
            tailf:cli-full-command;
            type uint8 {
              tailf:info "<0-7>;;Unique node ID in the ICCP Group for this system.";
              range "0..7";
            }
          }

          // redundancy / iccp / group * / mlacp system
          container system {
            tailf:info "Set the default system parameters for LACP bundles";
            leaf mac {
              tailf:info "The LACP System ID to be used in this ICCP Group.";
              tailf:cli-full-command;
              type string {
                tailf:info "H.H.H;;Unique ID for this system. Any non-zero value is permitted.";
              }
            }
            leaf priority {
              tailf:info "Set the LACP system priority to be used in this ICCP Group.";
              tailf:cli-full-command;
              type uint16 {
                tailf:info "<1-65535>;;Priority for this system. Lower value is higher priority.";
                range "1..65535";
              }
            }
          }

          // redundancy / iccp / group * / mlacp connect timeout
          container connect {
            tailf:info "Specify configuration options for connecting to mLACP peers.";
            leaf timeout {
              tailf:info "Specify time to wait before assuming mLACP peer is down.";
              type uint16 {
                tailf:info "<0-65534>;;Number of seconds to wait before assuming mLACP peer is down.";
                range "0..65534";
              }
            }
          }
        }

        // redundancy / iccp / group * / member
        container member {
          tailf:info "configure ICCP members";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-redundancy-group-iccp-member";

          // redundancy / iccp / group * / member / neighbor *
          leaf neighbor {
            tailf:info "configure interchassis group ICCP members";
            tailf:cli-remove-before-change;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;neighbor ip address";
            }
          }
        }

        // redundancy / iccp / group * / mode singleton
        container mode {
          tailf:info "Set the group mode";
          leaf singleton {
            tailf:info "Run the group in singleton mode";
            type empty;
          }
        }

        // redundancy / iccp / group * / backbone
        container backbone {
          tailf:info "configure ICCP backbone interfaces";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-redundancy-group-iccp-backbone";
          // redundancy / iccp / group * / backbone / interface *
          list interface {
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;Interface Name";
              }
            }
          }
        }

        // redundancy / iccp / group * / isolation
        container isolation {
          tailf:info "Set the isolation parameters";
          leaf recovery-delay {
            tailf:info "Specify delay before clearing isolation condition after recovery from failure";
            type uint16 {
              tailf:info "<30-600>;;Recovery delay in seconds.";
              range "30..600";
            }
          }
        }

        // redundancy / iccp / group * / nv satellite
        container nv {
          tailf:info "Network Virtualization configuration";
          container satellite {
            tailf:info "Satellite configuration";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-nV";
            // redundancy / iccp / group * / nv satellite / system-mac
            leaf system-mac {
              tailf:info "System MAC for this redundancy-group";
              type string {
                tailf:info "H.H.H;;Optional system MAC address.";
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// ssh
  /// ========================================================================

  container ssh {
    tailf:info "Secure Shell configuration";
    tailf:cli-explicit-exit;

    // ssh client
    container client {
      tailf:info "Provide SSH client service";

      // ssh client v2
      leaf v2 {
        tailf:info "Set ssh client to use version 2 only";
        type empty;
      }

      // ssh client vrf
      leaf vrf {
        tailf:info "Source interface VRF for ssh client sessions";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;VRF name (max:32 chars)";
        }
      }

      // ssh client source-interface
      container source-interface {
        tailf:info "Source interface for ssh client sessions";
        uses interface-name-grouping;
      }

      // ssh client dscp
      leaf dscp {
        tailf:info "DSCP value for ssh client sessions";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<0-63>;;DSCP value range";
          range "0..63";
        }
      }

      // ssh client knownhost
      leaf knownhost {
        tailf:info "Enable the host pubkey check by local database";
        type string {
          tailf:info "WORD;;Filename - where to store known_host file";
        }
      }

      // ssh client tcp-window-scale
      leaf tcp-window-scale {
        tailf:info "Set tcp window-scale factor for High Latency links";
        type uint8 {
          tailf:info "<1-14>;;Window scale factor";
          range "1..14";
        }
      }

      // ssh client enable cipher *
      container enable {
        tailf:info "Enable AES-CBC and 3DES-CBC algorithms";
        leaf-list cipher {
          tailf:info "Enable ssh client ciphers";
          tailf:cli-flat-list-syntax;
          tailf:cli-replace-all;
          tailf:cli-no-value-on-delete;
          type enumeration {
            enum 3des-cbc {
              tailf:info "Enable ssh client 3des-cbc algorithm";
            }
            enum aes-cbc {
              tailf:info "Enable ssh client aes-cbc algorithms";
            }
          }
        }
      }

      // ssh client algorithms
      container algorithms {
        tailf:info "client algorithms";
        leaf-list cipher {
          tailf:info "Cipher algorithms";
          tailf:cli-flat-list-syntax;
          tailf:cli-replace-all;
          tailf:cli-no-value-on-delete;
          ordered-by user;
          type enumeration {
            enum aes128-ctr;
            enum aes192-ctr;
            enum aes256-ctr;
            enum aes128-gcm@openssh.com;
            enum aes256-gcm@openssh.com;
            enum aes128-cbc;
            enum aes192-cbc;
            enum aes256-cbc;
            enum 3des-cbc;
          }
        }
        leaf-list key-exchange {
          tailf:info "Key exchange algorithms";
          tailf:cli-flat-list-syntax;
          tailf:cli-replace-all;
          tailf:cli-no-value-on-delete;
          ordered-by user;
          type enumeration {
            enum ecdh-sha2-nistp521;
            enum ecdh-sha2-nistp384;
            enum ecdh-sha2-nistp256;
            enum diffie-hellman-group14-sha1;
            enum diffie-hellman-group1-sha1;
          }
        }
      }
    }

    // ssh server
    container server {
      tailf:info "Provide SSH server service";

      // ssh server enable cipher *
      container enable {
        tailf:info "Enable AES-CBC and 3DES-CBC algorithms";
        leaf-list cipher {
          tailf:info "Enable ssh server ciphers";
          tailf:cli-flat-list-syntax;
          tailf:cli-replace-all;
          tailf:cli-no-value-on-delete;
          ordered-by user;
          type enumeration {
            enum "3des-cbc" {
              tailf:info "Enable ssh server 3des-cbc algorithm";
            }
            enum "aes-cbc" {
              tailf:info "Enable ssh server aes-cbc algorithms";
            }
          }
        }
      }

      // ssh server dscp
      leaf dscp {
        tailf:info "Cisco ssh server DSCP";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<0-63>;;DSCP value range";
          range "0..63";
        }
      }

      // ssh server logging
      leaf logging {
        tailf:info "Enable ssh server logging";
        tailf:cli-full-command;
        type empty;
      }

      // ssh server netconf
      container netconf {
        tailf:info "start ssh service for netcon";
        tailf:cli-delete-when-empty;
        presence true;

        // ssh server netconf port
        leaf port {
          tailf:info "start ssh service on port";
          type uint16 {
            tailf:info "<1-65535>;;port number on which ssh service to be started for netconf";
          }
        }

        // ssh server netconf vrf *
        uses ssh-server-vrf-grouping;
      }

      // ssh server capability
      container capability {
        tailf:info "Turn on Capability";

        // ssh server capability netconf-xml
        leaf netconf-xml {
          tailf:info "Use Netconf XML stack";
          type empty;
        }
      }

      // ssh server algorithms
      container algorithms {
        tailf:info "server algorithms";

        // ssh server algorithms key-exchange *
        leaf-list key-exchange {
          tailf:info "Key exchange algorithms";
          tailf:cli-flat-list-syntax;
          tailf:cli-replace-all;
          ordered-by user;
          type enumeration {
            enum diffie-hellman-group1-sha1;
            enum diffie-hellman-group14-sha1;
            enum ecdh-sha2-nistp521;
            enum ecdh-sha2-nistp384;
            enum ecdh-sha2-nistp256;
          }
        }

        // ssh server algorithms cipher *
        leaf-list cipher {
          tailf:info "cipher algorithms, choose one or more in required preference";
          tailf:cli-flat-list-syntax;
          tailf:cli-replace-all;
          ordered-by user;
          type enumeration {
            enum aes128-ctr;
            enum aes192-ctr;
            enum aes256-ctr;
            enum aes128-gcm@openssh.com;
            enum aes256-gcm@openssh.com;
            enum aes128-cbc;
            enum aes192-cbc;
            enum aes256-cbc;
            enum 3des-cbc;
          }
        }

        // ssh server algorithms host-key *
        leaf-list host-key {
          tailf:info "Host key algorithms to be used";
          tailf:cli-flat-list-syntax;
          tailf:cli-replace-all;
          type enumeration {
            enum dsa;
            enum ecdsa-nistp256;
            enum ecdsa-nistp384;
            enum ecdsa-nistp521;
            enum ed25519;
            enum rsa;
            enum x509v3-ssh-rsa;
          }
        }
      }

      // ssh server rate-limit
      leaf rate-limit {
        tailf:info "Cisco sshd rate-limit of service requests";
        tailf:cli-full-command;
        type uint32 {
          tailf:info "<1-600>;;Limit in term of number of request per minute (default 60)";
          range "1..600";
        }
      }

      // ssh server session-limit
      leaf session-limit {
        tailf:info "Cisco sshd session-limit of service requests";
        tailf:cli-full-command;
        type uint32 {
          tailf:info "<1-1024>;;Number of allowable concurrent incoming ssh sessions";
          range "1..1024";
        }
      }

      // ssh server tcp-window-scale
      leaf tcp-window-scale {
        tailf:info "Set tcp window-scale factor for High Latency links";
        type uint8 {
          tailf:info "<1-14>;;Window scale factor";
          range "1..14";
        }
      }

      // ssh server v2
      leaf v2 {
        tailf:info "Cisco sshd force protocol version 2 only";
        tailf:cli-full-command;
        type empty;
      }

      // ssh server rekey-time
      leaf rekey-time {
        tailf:info "Configures time-based rekey (default 60 minutes)";
        type uint16 {
          tailf:info "<30-1440>;;Time Period in minutes";
          range "30..1440";
        }
      }

      // ssh server vrf *
      uses ssh-server-vrf-grouping;
    }

    // ssh timeout
    leaf timeout {
      tailf:info "Set timeout value for SSH";
      type uint8 {
        tailf:info "<5-120>;;Timeout value between 5-120 seconds";
        range "5..120";
      }
    }
  }


  /// ========================================================================
  /// performance-measurement
  /// ========================================================================

  // performance-measurement
  container performance-measurement {
    tailf:info "Enter the Performance Measurement submode";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-perf-meas";
    tailf:cli-explicit-exit;
    presence true;

    // performance-measurement / interface *
    list interface {
      tailf:info "Enable Performance Measurement on an interface";
      tailf:cli-mode-name "config-pm-intf";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Interface name";
        }
      }

      // performance-measurement / interface * / delay-measurement
      container delay-measurement {
        tailf:info "Enable delay-measurement on the interface";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-pm-intf-dm";
        presence true;

        // performance-measurement / interface * / delay-measurement / advertise-delay
        leaf advertise-delay {
          tailf:info "Advertisement delay";
          type uint32 {
            tailf:info "<0-16777215>;;Advertisement delay (uSec)";
            range "0..16777215";
          }
        }
      }
      // performance-measurement / interface * / next-hop
      container next-hop {
        tailf:info "next-hop address";
        choice ipv4-or-ipv6 {
          leaf ipv4 {
            tailf:info "IPv4 address";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IPv4 nexthop address";
            }
          }
          leaf ipv6 {
            tailf:info "IPv6 address";
            type inet:ipv6-address {
              tailf:info "X:X::X;;IPv6 nexthop address";
            }
          }
        }
      }
    }

    // performance-measurement / protocol twamp-light
    container protocol {
      tailf:info "Supported protocols";
      container twamp-light {
        tailf:info "Enter twamp-light protocol submode";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-pm-protocol";

        // performance-measurement / protocol twamp-light / measurement delay
        container measurement {
          tailf:info "Supported measurement types";
          container delay {
            tailf:info "Enter delay measurement submode";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-pm-protocol-meas";

            // performance-measurement / protocol twamp-light / measurement delay / unauthenticated
            container unauthenticated {
              tailf:info "Enter unauthenticated submode";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-pm-proto-mode";

              // performance-measurement / protocol twamp-light / measurement delay / unauthenticated / querier-dst-port
              leaf querier-dst-port {
                tailf:info "UDP port opened to process queries";
                type uint16 {
                  tailf:info "<1024-14999>;;Port number";
                  range "1024..14999";
                }
              }
            }
          }
        }
      }
    }

    // performance-measurement / delay-profile
    container delay-profile {
      tailf:info "Delay profile";

      // performance-measurement / delay-profile sr-policy name *
      container sr-policy-name {
        tailf:cli-drop-node-name;
        list sr-policy {
          tailf:info "Enter SR Policy delay profile submode";
          tailf:cli-mode-name "config-pm-dm-srpolicy";
          key name;
          leaf name {
            tailf:cli-expose-key-name;
            tailf:info "Profile name";
            type string {
              tailf:info "WORD;;Profile name";
            }
          }
          uses pm-dm-grouping;
        }
      }

      // performance-measurement / delay-profile sr-policy default
      container sr-policy-default {
        tailf:cli-drop-node-name;
        container sr-policy {
          tailf:info "Enter SR Policy delay profile submode";
          container default {
            tailf:info "Default profile";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-pm-dm-srpolicy";
            presence true;
            uses pm-dm-grouping;
          }
        }
      }

      // performance-measurement / delay-profile sr-policy
      container sr-policy {
        tailf:info "Enter SR Policy delay profile submode";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-pm-dm-srpolicy";
        presence true;
        uses pm-dm-grouping;
      }

      // performance-measurement / delay-profile interfaces name *
      container interfaces-name {
        tailf:cli-drop-node-name;
        list interfaces {
          tailf:info "Enter SR Policy delay profile submode";
          tailf:cli-mode-name "config-pm-dm-intf";
          key name;
          leaf name {
            tailf:cli-expose-key-name;
            tailf:info "Profile name";
            type string {
              tailf:info "WORD;;Profile name";
            }
          }
          uses pm-dm-grouping;
        }
      }

      // performance-measurement / delay-profile interfaces default
      container interfaces-default {
        tailf:cli-drop-node-name;
        container interfaces {
          tailf:info "Enter SR Policy delay profile submode";
          container default {
            tailf:info "Default profile";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-pm-dm-intf";
            presence true;
            uses pm-dm-grouping;
          }
        }
      }

      // performance-measurement / delay-profile interfaces
      container interfaces {
        tailf:info "Enter SR Policy delay profile submode";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-pm-dm-intf";
        presence true;
        uses pm-dm-grouping;
      }
    }
  }

  // performance-measurement / delay-profile sr-policy
  // performance-measurement / delay-profile interfaces
  grouping pm-dm-grouping {

    // performance-measurement / delay-profile * / advertisement
    container advertisement {
      tailf:info "Enter SR Policy delay profile advertisement submode";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-pm-dm-xxx-adv";

      // performance-measurement / delay-profile * / advertisement / accelerated
      container accelerated {
        tailf:info "Enter SR Policy delay profile advertisement accelerated submode";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-pm-dm-xxx-adv-acc";
        presence true;

        // performance-measurement / delay-profile * / advertisement / accelerated / minimum-change
        leaf minimum-change {
          tailf:info "Accelerated advertisement minimum change";
          type uint32 {
            tailf:info "<0-100000>;;Accelerated advertisement minimum change (uSec)";
            range "0..100000";
          }
        }

        // performance-measurement / delay-profile * / advertisement / accelerated / threshold
        leaf threshold {
          tailf:info "Accelerated advertisement threshold";
          type uint8 {
            tailf:info "<0-100>;;Accelerated advertisement threshold percentage change";
            range "0..100";
          }
        }
      }

      // performance-measurement / delay-profile * / advertisement / periodic
      container periodic {
        tailf:info "Go into SR Policy delay periodic advertisement submode";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-pm-dm-xxx-adv-per";

        // performance-measurement / delay-profile * / advertisement / periodic / minimum-change
        leaf minimum-change {
          tailf:info "Periodic advertisement minimum change (compared to last advertisement)";
          type uint32 {
            tailf:info "<0-100000>;;Periodic advertisement minimum change in uSec (compared to last advertisement)";
            range "0..100000";
          }
        }

        // performance-measurement / delay-profile * / advertisement / periodic / interval
        leaf interval {
          tailf:info "Periodic advertisement and metric aggregation interval";
          type uint16 {
            tailf:info "<30-3600>;;Periodic advertisement and metric aggregation interval (seconds)";
            range "30..3600";
          }
        }

        // performance-measurement / delay-profile * / advertisement / periodic / threshold
        leaf threshold {
          tailf:info "Periodic advertisement threshold (compared to last advertisement)";
          type uint8 {
            tailf:info "<0-100>;;Periodic advertisement threshold percentage change (compared to last advertisement)";
            range "0..100";
          }
        }
      }
    }

    // performance-measurement / delay-profile * / probe
    container probe {
      tailf:info "Enter SR Policy delay probe submode";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-pm-dm-xxx-probe";

      // performance-measurement / delay-profile * / probe / measurement-mode
      leaf measurement-mode {
        tailf:info "Delay measurement mode";
        type enumeration {
          enum loopback {
             tailf:info "Loopback the probe packet collecting only timestamp1 and 4 (reverse-path must be configured for SR Policy with RFC6374 MPLS encap)";
          }
          enum one-way {
            tailf:info "Measure one way delay with timestamp1 and 2";
          }
          enum two-way {
            tailf:info "Measure one way delay with timestamp1, 2, 3 and 4 without clock synchronization";
          }
        }
      }

      // performance-measurement / delay-profile * / probe / protocol
      leaf protocol {
        tailf:info "Configure protocol type for delay measurement probe messages";
        type enumeration {
          enum pm-mpls {
            tailf:info "Interface delay measurement using RFC6374 with MPLS encap";
          }
          enum twamp-light {
            tailf:info "Interface delay measurement using RFC5357";
          }
        }
      }

      // performance-measurement / delay-profile * / probe / computation-interval
      leaf computation-interval {
        tailf:info "Interval for metric computation";
        type uint16 {
          tailf:info "<1-3600>;;Computation interval (seconds)";
          range "1..3600";
        }
      }

      // performance-measurement / delay-profile * / probe / burst-interval
      leaf burst-interval {
        tailf:info "Burst interval";
        type uint16 {
          tailf:info "<30-15000>;;Burst interval (msec)";
          range "30..15000";
        }
      }
    }
  }


  /// ========================================================================
  /// eap
  /// ========================================================================

  // eap profile *
  container eap {
    tailf:info "EAP Global Configuration Commands";
    tailf:cli-explicit-exit;
    list profile {
      tailf:info "Configure EAP profiles";
      tailf:cli-mode-name "config-eap";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Specify a profile name (max 63 characters)";
        }
      }

      // eap profile * / method tls
      container method {
        tailf:info "Add an allowed method";
        container tls {
          tailf:info "EAP-TLS method allowed";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-eap-tls";

          // eap profile * / method tls / pki-trustpoint
          leaf pki-trustpoint {
            tailf:info "Set pki trustpoint";
            tailf:cli-suppress-leafref-in-diff;
            tailf:non-strict-leafref {
              path "/cisco-ios-xr:crypto/ca/trustpoint/name";
            }
            type string {
              tailf:info "WORD;;Specify the pki trustpoint name";
            }
          }
        }
      }

      // eap profile * / identity
      leaf identity {
        tailf:info "identity name";
        type string {
          tailf:info "WORD;;Specify EAP Identity or Username for authentication";
        }
      }
    }
  }


  /// ========================================================================
  /// dot1x
  /// ========================================================================

  // dot1x profile *
  container dot1x {
    tailf:info "IEEE 802.1X Global Configuration Commands";
    tailf:cli-explicit-exit;
    list profile {
      tailf:info "Configure 802.1X profiles";
      tailf:cli-mode-name "config-dot1x";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Specify a profile name (max 63 charecters)";
        }
      }

      // dot1x profile * / pae
      leaf pae {
        tailf:info "Set 802.1x pae type";
        type enumeration {
          enum authenticator {
            tailf:info "Set PAE Type as Authenticator";
          }
          enum supplicant {
            tailf:info "Set PAE Type as Supplicant";
          }
          enum both {
            tailf:info "Set PAE Type as both Supplicant and Authenticator";
          }
        }
      }

      // dot1x profile * / authenticator
      container authenticator {
        tailf:info "Enter in Authenticator submode";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-dot1x-auth";

        // dot1x profile * / authenticator / timer reauth-time
        container timer {
          tailf:info "Set various timeouts";
          container reauth-time {
            tailf:info "In seconds, after which an automatic reauth should be initiated";
            leaf seconds {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<60-5184000>;;In seconds, admin configured reauth timer value, min:60, max:5184000 (2 months)";
                range "60..5184000";
              }
            }
            leaf server {
              tailf:info "server given re-auth timer value, min expected value is 60 sec, default: 1hr";
              type empty;
            }
          }
        }
      }

      // dot1x profile * / supplicant
      container supplicant {
        tailf:info "Enter in Supplicant submode";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-dot1x-supp";

        // dot1x profile * / supplicant / eap profile
        container eap {
          tailf:info "Configure EAP Supplicant Parameters";
          leaf profile {
            tailf:info "EAP Profile Configuration";
            tailf:cli-suppress-leafref-in-diff;
            tailf:non-strict-leafref {
              path "/cisco-ios-xr:eap/profile/name";
            }
            type string {
              tailf:info "WORD;;EAP Profile Name";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// macsec-policy
  /// ========================================================================

  // macsec-policy *
  list macsec-policy {
    tailf:info "MACSec Policy configuration";
    tailf:cli-mode-name "config-macsec-policy";
    tailf:cli-explicit-exit;
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;Enter the policy name of max-length 16";
        length "1..16";
      }
    }

    // macsec-policy * / conf-offset
    leaf conf-offset {
      tailf:info "conf-offset used for encryption";
      type enumeration {
        enum CONF-OFFSET-0 {
          tailf:info "Offset 0";
        }
        enum CONF-OFFSET-30 {
          tailf:info "Offset 30";
        }
        enum CONF-OFFSET-50 {
          tailf:info "Offset 50";
        }
      }
    }

    // macsec-policy * / security-policy
    leaf security-policy {
      tailf:info "Must Secure/Should Secure for Data encryption";
      type enumeration {
        enum must-secure {
          tailf:info "Enable must secure";
        }
        enum should-secure {
          tailf:info "Enable should secure";
        }
      }
    }

    // macsec-policy * / window-size
    leaf window-size {
      tailf:info "window-size used for encryption";
      type uint16 {
        tailf:info "<0-1024>;;Enter the window size";
        range "0..1024";
      }
    }

    // macsec-policy * / cipher-suite
    leaf cipher-suite {
      tailf:info "Cipher-Suite used for encryption";
      type enumeration {
        enum GCM-AES-128 {
          tailf:info "GCM AES 128 bit encryption";
        }
        enum GCM-AES-256 {
          tailf:info "GCM AES 256 bit encryption";
        }
        enum GCM-AES-XPN-128 {
          tailf:info "GCM AES XPN 128 bit encryption";
        }
        enum GCM-AES-XPN-256 {
          tailf:info "GCM AES XPN 256 bit encryption";
        }
      }
    }

    // macsec-policy * / include-icv-indicator
    leaf include-icv-indicator {
      tailf:info "Include ICV Indicator paramset in MKPDU";
      type empty;
    }

    // macsec-policy * / delay-protection
    leaf delay-protection {
      tailf:info "enable data delay protection";
      type empty;
    }

    // macsec-policy * / key-server-priority
    leaf key-server-priority {
      tailf:info "Key Server Priority for the node";
      type uint8 {
        tailf:info "<0-255>;;Enter the key server priority for the node";
      }
    }

    // macsec-policy * / sak-rekey-interval seconds
    container sak-rekey-interval {
      tailf:info "Interval after which key-server generates new SAK for a Secured Session";
      leaf seconds {
        tailf:info "Interval(in seconds)<60-2592000>, Default: OFF";
        type uint32 {
          tailf:info "<60-2592000>;;Enter SAK rekey interval(in seconds) ";
          range "60..2592000";
        }
      }
    }

    // macsec-policy * / policy-exception lacp-in-clear
    container policy-exception {
      tailf:info "macsec policy exception to allow packets in clear text";
      leaf lacp-in-clear {
        tailf:info "Allow LACP(Link aggregation control plane protocol) Packets in clear Text";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// track
  /// ========================================================================

  // track *
  list track {
    tailf:info "Configure Track";
    tailf:cli-explicit-exit;
    key name;
    leaf name {
      tailf:cli-suppress-range;
      type string {
        tailf:info "WORD;;track name";
      }
    }

    // track * / type
    container type {
      tailf:info "Set track type";

      // track * / type rtr ? reachability
      container rtr {
        tailf:info "track type ipsla";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf ipsla-no {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<1-2048>;;ipsla operation number";
            range "1..2048";
          }
        }
        leaf reachability {
          tailf:info "Tracks whether the route is reachable";
          type empty;
        }
      }

      // track * / type list
      container list {
        tailf:info "track type list";

        // track * / type list boolean
        container boolean {
          tailf:info "track type list boolean";

          // track * / type list boolean and / object *
          container and {
            tailf:info "track type list boolean and";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-track-list-boolean";
            presence true;
            list object {
              tailf:info "Set track object";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key name;
              leaf name {
                type string {
                  tailf:info "WORD;;object name";
                }
              }
              leaf not {
                tailf:info "boolean not";
                type empty;
              }
            }
          }

          // track * / type list boolean or / object *
          container or {
            tailf:info "track type list boolean or";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-track-list-boolean";
            presence true;
            list object {
              tailf:info "Set track object";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key name;
              leaf name {
                type string {
                  tailf:info "WORD;;object name";
                }
              }
              leaf not {
                tailf:info "boolean not";
                type empty;
              }
            }
          }
        }
      }

      // track * / type line-protocol state
      container line-protocol {
        tailf:info "track type line-protocol";
        container state {
          tailf:info "track type line-protocol state";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-track-line-prot";
          presence true;

          // track * / type line-protocol state / interface
          container interface {
            tailf:info "Set track interface";
            uses interface-name-grouping;
          }
        }
      }

      // track * / type route reachability
      container route {
        tailf:info "track type ipv4 route";
        container reachability {
          tailf:info "track type ipv4 route reachability";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-track-route";
          presence true;

          // track * / type route reachability / vrf
          leaf vrf {
            tailf:info "specify vrf";
            type string {
              tailf:info "WORD;;VRF tag";
            }
          }

          // track * / type route reachability / route ipv4
          container route {
            tailf:info "Set track route";
            leaf ipv4 {
              tailf:info "IP Address";
              type inet:ipv4-prefix {
                tailf:info "A.B.C.D/prefix;;IP prefix <network/length>,e.g. 10.56.8.10/16";
              }
            }
          }
        }
      }
    }

    // track * / action
    container action {
      tailf:info "Actions to be taken when the state of the track changes";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-track-action";

      // track * / action / track-down error-disable interface *
      container track-down {
        tailf:info "Action will be performed when track goes Down";
        container error-disable {
          tailf:info "Disable specified interface when track state changes";
          list interface {
            tailf:info "Interface to be disabled";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            key name;
            leaf name {
              type ifname;
            }
            leaf auto-recover {
              tailf:info "Auto-recover the interface state when the track returns to pre-error-disable state";
              type empty;
            }
          }
        }
      }
    }

    // track * / delay
    container delay {
      tailf:info "Set track notification delay";

      // track * / delay up
      leaf up {
        tailf:info "Up time";
        type uint8 {
          tailf:info "<1-180>;;Up time delay";
        }
      }

      // track * / delay down
      leaf down {
        tailf:info "Down time";
        type uint8 {
          tailf:info "<1-180>;;Down time delay";
        }
      }
    }
  }


  /// ========================================================================
  /// ipsla
  /// ========================================================================

  container ipsla {
    tailf:info "IPSLA configuration commands";
    tailf:cli-add-mode;
    tailf:cli-explicit-exit;

    // ipsla / hw-timestamp disable
    container hw-timestamp {
      tailf:info "ardware timestamp configuration";
      leaf disable {
        tailf:info "isable hardware timestamp";
        type empty;
      }
    }

    // ipsla / operation *
    list operation {
      tailf:info "IPSLA operation configuration";
      tailf:cli-mode-name "config-ipsla-op";
      cisco-ios-xr:lock-delete-redeploy "/operation :: /schedule/operation ::  schedule operation" {
        cli:arguments " operation (\\d+) :: no ipsla schedule operation $1";
      }
      cisco-ios-xr:lock-delete-redeploy "/operation :: /reaction/operation ::  reaction operation" {
        cli:arguments " operation (\\d+) :: no ipsla reaction operation $1";
      }
      key id;
      leaf id {
        type uint16 {
          tailf:info "<1-2048>;;Operation number";
          range "1..2048";
        }
      }

      // ipsla / operation * / apply-group
      uses apply-group-grouping;

      // ipsla / operation * / type
      container type {
        tailf:info "Type of operation";

        // ipsla / operation * / type udp *
        list udp {
          tailf:info "UDP operation types";
          tailf:cli-mode-name "config-ipsla-udp";
          key name;
          leaf name {
            type enumeration {
              enum echo {
                tailf:info "UDP echo operation type";
              }
              enum jitter {
                tailf:info "UDP jitter operation type";
              }
            }
          }
          uses ipsla-operation-type-grouping;
        }

        // ipsla / operation * / type icmp *
        list icmp {
          tailf:info "ICMP operation types";
          tailf:cli-mode-name "config-ipsla-icmp";
          key name;
          leaf name {
            type enumeration {
              enum echo {
                tailf:info "ICMP echo operation type";
              }
              enum path-echo {
                tailf:info "ICMP path-echo operation type";
              }
              enum path-jitter {
                tailf:info "ICMP path-jitter operation type";
              }
            }
          }
          uses ipsla-operation-type-grouping;
        }

        // ipsla / operation * / type mpls lsp *
        container mpls {
          tailf:info "MPLS operation types";
          list lsp  {
            tailf:info "MPLS LSP operation types";
            tailf:cli-mode-name "config-ipsla-mpls-lsp";
            key name;
            leaf name {
              type enumeration {
                enum ping {
                  tailf:info "MPLS Echo operation type";
                }
                enum trace {
                  tailf:info "MPLS Trace operation type";
                }
              }
            }
            uses ipsla-operation-type-grouping;
          }
        }
      }
    }

    // ipsla / reaction
    container reaction {
      tailf:info "IPSLA reaction configuration";

      // ipsla / reaction operation *
      list operation {
        tailf:info "Reaction configuration for operation";
        tailf:cli-mode-name "config-ipsla-react";
        key id;
        leaf id {
          type uint16 {
            tailf:info "<1-2048>;;Operation number";
            range "1..2048";
          }
        }

        // ipsla / reaction operation * / apply-group
        uses apply-group-grouping;

        // ipsla / reaction operation * / react
        container react {
          tailf:info "Specify an element to be monitored for reaction";

          // ipsla / reaction operation * / react connection-loss
          container connection-loss {
            tailf:info "Reaction on connection loss of monitored operation";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-ipsla-react-cond";
            uses ipsla-reaction-operation-react-grouping;
          }

          // ipsla / reaction operation * / react jitter-average
          container jitter-average {
            tailf:info "Reaction on round trip jitter value violation";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-ipsla-react-cond";
            uses ipsla-reaction-operation-react-grouping;
          }

          // ipsla / reaction operation * / react packet-loss
          container packet-loss {
            tailf:info "Reaction on packet loss value violation";

            // ipsla / reaction operation * / react packet-loss dest-to-source
            container dest-to-source {
              tailf:info "Packet loss  destination to source(DS) violation";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-ipsla-react-cond";
              uses ipsla-reaction-operation-react-grouping;
            }

            // ipsla / reaction operation * / react packet-loss source-to-dest
            container source-to-dest {
              tailf:info "Packet loss source to destination (SD) violation";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-ipsla-react-cond";
              uses ipsla-reaction-operation-react-grouping;
            }
          }

          // ipsla / reaction operation * / react timeout
          container timeout {
            tailf:info "Reaction on timeout of monitored operation";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-ipsla-react-cond";

            // ipsla / reaction operation * / react timeout / action
            container action {
              tailf:info "Type of action to be taken on threshold violation(s)";
              // ipsla / reaction operation * / react timeout / action logging
              leaf logging {
                tailf:info "Generate a syslog alarm on threshold violation";
                type empty;
              }
              // ipsla / reaction operation * / react timeout / action trigger
              leaf trigger {
                tailf:info "Generate trigger to active reaction triggered operation(s)";
                type empty;
              }
            }

            // ipsla / reaction operation * / react timeout / threshold type
            container threshold {
              tailf:info "Configure threshold parameters on monitored element";
              container type {
                tailf:info "Threshold type";

                // ipsla / reaction operation * / react timeout / threshold type
                choice type-choice {
                  leaf consecutive {
                    tailf:info "Take action after a number of consecutive violations";
                    type uint8 {
                      tailf:info "<1-16>;;Number of consecutive violations";
                      range "1..16";
                    }
                  }
                  leaf immediate {
                    tailf:info "Take action immediately upon threshold violation";
                    type empty;
                  }
                  container xofy {
                    tailf:info "Take action upon X violations in Y probe operations";
                    tailf:cli-compact-syntax;
                    tailf:cli-sequence-commands {
                      tailf:cli-reset-siblings;
                    }
                    leaf x-value {
                      tailf:cli-drop-node-name;
                      type uint8 {
                        tailf:info "<1-16>;;Number of threshold violations (X value)";
                        range "1..16";
                      }
                    }
                    leaf y-value {
                      tailf:cli-drop-node-name;
                      type uint8 {
                        tailf:info "<1-16>;;Number of probes observing the violations (Y value)";
                        range "1..16";
                      }
                    }
                  }
                }
              }
            }
          }

          // ipsla / reaction operation * / react rtt
          container rtt {
            tailf:info "Reaction on round trip time violation";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-ipsla-react-cond";
            uses ipsla-reaction-operation-react-grouping;
          }
        }
      }
    }

    // ipsla / schedule operation *
    container schedule {
      tailf:info "Schedule an operation";
      list operation {
        tailf:info " Specify an operation";
        tailf:cli-mode-name "config-ipsla-sched";
        key id;
        leaf id {
          type uint16 {
            tailf:info "<1-2048>;;Operation number";
            range "1..2048";
          }
        }

        // ipsla / schedule operation * / apply-group
        uses apply-group-grouping;

        // ipsla / schedule operation * / start-time
        container start-time {
          tailf:info "Start time of the operation";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          choice start-time-choice {
            leaf after {
              tailf:info "Schedule operation after specified time";
              type string {
                tailf:info "hh:mm:ss;;Start after (hh:mm:ss) has elapsed";
              }
            }
            leaf now {
              tailf:info "Schedule operation now";
              type empty;
            }
            leaf pending {
              tailf:info "Keep operation in the pending state";
              type empty;
            }
            leaf time {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "hh:mm[:ss];;Start time (hh:mm:[ss])";
              }
            }
          }
        }

        // ipsla / schedule operation * / life
        leaf life {
          tailf:info "Length of the time to execute (default 3600 seconds)";
          type union {
            type enumeration {
              enum forever {
                tailf:info "Schedule operation to run indefinitely";
              }
            }
            type uint32 {
              tailf:info "<1-2147483647>;;Life in seconds. (default 3600 seconds)";
              range "1..2147483647";
            }
          }
        }

        // ipsla / schedule operation * / ageout
        leaf ageout {
          tailf:info "How long to keep this entry after it becomes inactive";
          type uint32 {
            tailf:info "<0-2073600>;;Ageout interval in seconds (default 0, never ageout)";
            range "0..2073600";
          }
        }
      }
    }

    // ipsla / key-chain
    leaf key-chain {
      tailf:info "Use MD5 authentication for IPSLA control message";
      tailf:cli-full-command;
      type string {
        tailf:info "WORD;;Name of key-chain";
      }
    }

    // ipsla / responder
    container responder {
      tailf:info "IPSLA responder configuration";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-ipsla-resp";
      presence true;

      // ipsla / responder / type udp ipv4 address * port *
      container type {
        tailf:info "Operation type";
        container udp {
          tailf:info "Udp operation";
          list ipv4 {
            tailf:info "IPv4 address configuration";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key "address port";
            leaf address {
              tailf:cli-expose-key-name;
              tailf:info "Permanent address on responder";
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Enter IPv4 address";
              }
            }
            leaf port {
              tailf:cli-expose-key-name;
              tailf:info "Permanent port on responder";
              type uint16 {
                tailf:info "<1-65535>;;Enter port number";
              }
            }
          }
        }
      }

      // ipsla / responder / twamp
      container twamp {
        tailf:info "Setup TWAMP responder";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-twamp-ref";
        presence true;

        // ipsla / responder / twamp / timeout
        leaf timeout {
          tailf:info "Inactivity timeout period";
          type uint32 {
            tailf:info "<1-604800>;;Inactivity timeout value in seconds (Default 900)";
            range "1..604800";
          }
        }
      }

      // ipsla / responder / twamp-light test-session *
      container twamp-light {
        tailf:info "etup TWAMP-LIGHT responder";
        list test-session {
          tailf:info "reate a new test session";
          tailf:cli-mode-name "config-twamp-light-def";
          key id;
          leaf id {
            type uint8 {
              tailf:info "1-5>;;Test session ID";
              range "1..5";
            }
          }

          // ipsla / responder / twamp-light test-session * / local-ip *
          list local-ip {
            tailf:info "Local interface IPv4/IPv6 address";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key "local-ip local-port remote-ip remote-port vrf";
            leaf local-ip {
              type union {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IPv4 address of the local interface";
                }
                type inet:ipv6-address {
                  tailf:info "X:X::X;;IPv6 address of the local interface";
                }
              }
            }
            leaf local-port {
              tailf:info "Local UDP port";
              tailf:cli-expose-key-name;
              type uint16 {
                tailf:info "<1-65535>;;Enter port number";
                range "1..65535";
              }
            }
            leaf remote-ip {
              tailf:info "Remote (client) interface IPv4/IPv6 address";
              tailf:cli-expose-key-name;
              type union {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IPv4 address of the remote interface";
                }
                type inet:ipv6-address {
                  tailf:info "X:X::X;;IPv6 address of the remote interface";
                }
              }
            }
            leaf remote-port {
              tailf:info "Remote (client) UDP port";
              tailf:cli-expose-key-name;
              type uint16 {
                tailf:info "<1-65535>;;Enter port number";
                range "1..65535";
              }
            }
            leaf vrf {
              tailf:info "VRF name for local-ip";
              tailf:cli-expose-key-name;
              type string {
                tailf:info "WORD;;Name of VRF ('default' for none)";
              }
            }
          }
        }
      }
    }

    // ipsla / server twamp
    container server {
      tailf:info "IPSLA IPPM server configuration";
      container twamp {
        tailf:info "IPSLA IPPM TWAMP server configuration";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-ipsla-server-twamp";
        presence true;

        // ipsla / server twamp / port
        leaf port {
          tailf:info "IPPM server port";
          type uint16 {
            tailf:info "<1-65535>;;Enter TWAMP server port number (Default 862)";
            range "1..65535";
          }
        }

        // ipsla / server twamp / timer inactivity
        container timer {
          tailf:info "IPPM server timer configurations";
          leaf inactivity {
            tailf:info "IPPM server inactivity timer";
            type uint16 {
              tailf:info "<1-6000>;;Enter inactivity timer value in seconds (Default 900)";
              range "1..6000";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// performance-mgmt
  /// ========================================================================

  container performance-mgmt {
    tailf:info "Performance Management configuration & operation subcommands";
    tailf:cli-explicit-exit;

    // performance-mgmt statistics interface basic-counter
    container statistics {
      tailf:info "Configure statistics for data collection";
      container interface {
        tailf:info "Configure statistics collection for interfaces";

        // performance-mgmt statistics interface basic-counter
        container basic-counters {
          tailf:info "Configure data collection for basic counters";
          // performance-mgmt statistics interface basic-counter template *
          uses performance-mgmt-template-grouping;
        }
        // performance-mgmt statistics interface data-rates
        container data-rates {
          tailf:info "Configure data collection for data rates";
          // performance-mgmt statistics interface data-rates template *
          uses performance-mgmt-template-grouping;
        }
        // performance-mgmt statistics interface generic-counters
        container generic-counters {
          tailf:info "Configure data collection for generic counters";
          // performance-mgmt statistics interface generic-counters template *
          uses performance-mgmt-template-grouping;
        }
      }
      // performance-mgmt statistics bgp
      container bgp {
        tailf:info "Configure statistics collection for bgp";
        // performance-mgmt statistics bgp template *
        uses performance-mgmt-template-grouping;
      }
    }

    // performance-mgmt thresholds
    container thresholds {
      tailf:info "Configure thresholds for collected data";
      container node {
        tailf:info "Configure thresholds for node";
        container cpu {
          tailf:info "Configure thresholds for cpu";
          list template {
            tailf:info "Specify template";
            tailf:cli-mode-name "config-threshold-cpu";
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;Template name";
              }
            }
            uses performance-mgmt-grouping;
          }
        }
        container process {
          tailf:info "Configure thresholds for process";
          list template {
            tailf:info "Specify template";
            tailf:cli-mode-name "config-threshold-proc";
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;Template name";
              }
            }
            uses performance-mgmt-grouping;
          }
        }
      }
    }

    // performance-mgmt resources
    container resources {
      tailf:info "Resources configuration";
      // performance-mgmt resources dump
      leaf dump {
        tailf:info "Configure data dump parameters";
        type enumeration {
          enum local {
            tailf:info "Dump onto local filesystem";
          }
        }
      }
      // performance-mgmt resources memory
      container memory {
        tailf:info "Configure memory usage limits";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf max-limit {
          tailf:info "Maximum limit for memory usage for data buffers";
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<0-4294967295>;;Specify maximum memory limit in Kbytes";
          }
        }
        leaf min-reserved {
          tailf:info "Ensure a minimum free memory before allowing a collection request";
          type uint32 {
            tailf:info "<0-4294967295>;;Specify free memory amount in Kbytes";
          }
        }
      }
      container tftp-server {
        tailf:info "Configure tftp server parameters";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf host {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type string {
            tailf:info "Hostname or A.B.C.D;;Tftp server hostname or IP address";
          }
        }
        leaf vrf {
          tailf:info "VRF name for TFTP service";
          tailf:cli-optional-in-sequence;
          tailf:cli-incomplete-command;
          type string {
            tailf:info "WORD;;Name of VRF";
          }
        }
        leaf directory {
          tailf:info "Directory Name";
          type string {
            tailf:info "WORD;;Enter the directory name";
          }
        }
      }
    }

    // performance-mgmt apply *
    list apply {
      tailf:info "Start data collection and/or threshold monitoring";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        tailf:cli-multi-word-key;
        type string {
          tailf:info "WORD;;performance-mgmt object";
        }
      }
    }
  }


  /// ========================================================================
  /// vlan
  /// ========================================================================

  container vlan {
    tailf:info "Vlan commands";
    tailf:cli-explicit-exit;

    // vlan internal
    container internal {
      tailf:info "internal VLAN";
      container allocation {
        tailf:info "internal VLAN allocation";
        leaf policy {
          tailf:info "internal VLAN allocation policy";
          type enumeration {
            enum ascending {
              tailf:info "Allocate internal VLAN in ascending order";
            }
            enum descending {
              tailf:info "Allocate internal VLAN in descending order";
            }
          }
        }
      }
    }

    // vlan access-log
    container access-log {
      tailf:info "Configure VACL logging";
      leaf maxflow {
        tailf:info "Set vacl logging maximum flow number";
        type uint16 {
          tailf:info "<0-2048>;;Maximum flow number";
          range "0..2048";
        }
      }
      leaf ratelimit {
        tailf:info "Set vacl logging rate limiter";
        type uint16 {
          tailf:info "<0-5000>;;Maximum number of packets logged per second";
          range "0..5000";
        }
      }
      leaf threshold {
        tailf:info "Set vacl log-update threshold";
        type uint32 {
          tailf:info "<0-2147483647>;;log-update threshold (number of hits)";
          range "0..2147483647";
        }
      }
    }

    // vlan *
    list vlan-list {
      tailf:cli-drop-node-name;
      tailf:cli-mode-name "config-vlan";
      tailf:cli-range-list-syntax;
      key id;
      leaf id {
        type uint16 {
          tailf:info "WORD;;ISL VLAN IDs 1-4094";
          range "1..4094";
        }
      }
      leaf name {
        tailf:info "Ascii name of the VLAN";
        tailf:cli-full-command;
        tailf:cli-multi-value;
        type string {
          tailf:info "WORD;;The ascii name for the VLAN";
        }
      }
      leaf uni-vlan {
        tailf:info "Configure a UNI VLAN";
        tailf:cli-full-command;
        type enumeration {
          enum community {
            tailf:info "UNI/ENI community VLAN";
          }
          enum isolated {
            tailf:info "UNI/ENI isolated VLAN";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// lldp
  /// ========================================================================

  container lldp {
    tailf:info "Global LLDP configuration subcommands";
    tailf:cli-add-mode;
    tailf:cli-explicit-exit;
    presence true;

    // lldp / subinterfaces enable
    container subinterfaces {
      tailf:info "Configure LLDP over Sub-interfaces";
      leaf enable {
        tailf:info "Enable LLDP over Sub-interfaces as well";
        type empty;
      }
    }

    // lldp / holdtime
    leaf holdtime {
      tailf:info "Specify the holdtime (in sec) to be sent in packets";
      type uint16 {
        tailf:info "<0-65535>;;Length  of time (in sec) that receiver must keep this packet";
      }
    }

    // lldp / reinit
    leaf reinit {
      tailf:info "Delay (in sec) for LLDP initialization on any interface";
      type uint8 {
        tailf:info "<2-5>;;Specify the delay (in secs) for LLDP to initialize";
        range "2..5";
      }
    }

    // lldp / run
    leaf run {
      tailf:info "Enable LLDP";
      type empty;
    }

    // lldp / timer
    leaf timer {
      tailf:info "Specify the rate at which LLDP packets are sent (in sec)";
      type uint16 {
        tailf:info "<5-65534>;;Rate at which LLDP packets are sent (in sec)";
        range "5..65534";
      }
    }

    // lldp / extended-show-width enable
    container extended-show-width {
      tailf:info "Configure Extended Show LLDP Neighbor Width";
      leaf enable {
        tailf:info "Enable Extended Show LLDP Neighbor Width";
        type empty;
      }
    }

    // lldp / tlv-select
    container tlv-select {
      tailf:info "Selection of LLDP TLVs to disable";
      tailf:cli-add-mode;

      // lldp / tlv-select / management-address
      leaf management-address {
        tailf:info "Management Address TLV";
        type enumeration {
          enum disable {
            tailf:info "disable Management Address TLV";
          }
        }
      }

      // lldp / tlv-select / system-description
      leaf system-description {
        tailf:info "System Description TLV";
        type enumeration {
          enum disable {
            tailf:info "disable System Description TLV";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// mld
  /// ========================================================================

  container mld {
    tailf:info "IPv6 Address Family";
    tailf:cli-explicit-exit;

    // mld snooping profile *
    container snooping {
      tailf:info "Enter MLD snooping subcommands";
      list profile {
        tailf:info "Enter MLD snooping profile name";
        tailf:cli-mode-name "config-mld-snooping-profile";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Profile name - maximum 32 characters";
          }
        }

        // mld snooping profile * / router-guard
        leaf router-guard {
          tailf:info "Prevent dynamic mrouter discovery on a port";
          type empty;
        }

        // mld snooping profile * / minimum-version
        leaf minimum-version {
          tailf:info "Configure minimum MLD version (default 1)";
          type uint8 {
            tailf:info "<1-2>;;Enter minimum-version";
            range "1..2";
          }
        }

        // mld snooping profile * / mrouter
        container mrouter-enable {
          tailf:cli-drop-node-name;
          leaf mrouter {
            tailf:info "Configure a static mrouter on a port";
            type empty;
          }
        }

        // mld snooping profile * / mrouter forwarding disable
        container mrouter {
          tailf:info "Configure a static mrouter on a port";
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          container forwarding {
            tailf:info "Forward multicast to all mrouters";
            leaf disable {
              tailf:info "Disable mrouter forwarding";
              type empty;
            }
          }
        }

        // mld snooping profile * / router-alert-check disable
        container router-alert-check {
          tailf:info "Check for IP RA Option in snooped MLD messages";
          leaf disable {
            tailf:info "Disable router-alert-check";
            type empty;
          }
        }
      }
    }
  }


  /// ========================================================================
  /// igmp
  /// ========================================================================

  container igmp {
    tailf:info "IPv4 Address Family";
    tailf:cli-explicit-exit;
    container snooping {
      tailf:info "Enter IGMP snooping subcommands";

      // igmp snooping profile *
      list profile {
        tailf:info "Enter IGMP snooping profile name";
        tailf:cli-mode-name "config-igmp-snooping-profile";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Profile name - maximum 32 characters";
          }
        }

        // igmp snooping profile * / mrouter
        container mrouter {
          tailf:info "Configure a static mrouter on a port";
          presence true;
        }

        // igmp snooping profile * / system-ip-address
        leaf system-ip-address {
          tailf:info "Source address for generated IGMP messages";
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Enter a valid ip address";
          }
        }

        // igmp snooping profile * / minimum-version
        leaf minimum-version {
          tailf:info "Configure minimum IGMP version (default 2)";
          type uint8 {
            tailf:info "<2-3>;;Enter minimum-version";
            range "2..3";
          }
        }

        // igmp snooping profile * / internal-querier
        container internal-querier {
          tailf:info "Configure the IGMP internal-querier";
          tailf:cli-full-command;
          presence true;
        }

        // igmp snooping profile * / internal-querier version
        container internal-querier-conf {
          tailf:cli-drop-node-name;
          container internal-querier {
            tailf:info "Configure the IGMP internal-querier";
            tailf:cli-incomplete-command;
            tailf:cli-incomplete-no;
            leaf version {
              tailf:info "IGMP version (default 3)";
              type uint8 {
                tailf:info "<2-3>;;Enter internal-querier version";
                range "2..3";
              }
            }
          }
        }

        // igmp snooping profile * / tcn
        container tcn {
          tailf:info "Configure behavior on topology change";

          // igmp snooping profile * / tcn query solicit
          container query {
            tailf:info "Require G-Query to expedite relearning";
            leaf solicit {
              tailf:info "Solicit a G-Query on topology change (default disabled)";
              type empty;
            }
          }

          // igmp snooping profile * / tcn flood
          container flood {
            tailf:info "Add all STP ports to all mroutes during topology change";

            // igmp snooping profile * / tcn flood query count
            container query {
              tailf:info "tcn flood query";
              leaf count {
                tailf:info "Topology change complete after count G-Queries (default 2)";
                type uint8 {
                  tailf:info "<1-10>;;Enter tcn flood query count";
                  range "1..10";
                }
              }
            }
          }
        }

        // igmp snooping profile * / report-suppression disable
        container report-suppression {
          tailf:info "Minimize number of IGMP reports sent to mrouters";
          leaf disable {
            tailf:info "Disable report-suppression";
            type empty;
          }
        }

        // igmp snooping profile * / router-alert-check disable
        container router-alert-check {
          tailf:info "Check for IP RA Option in snooped IGMP message";
          leaf disable {
            tailf:info "Disable router-alert-check";
            type empty;
          }
        }
      }
    }
  }


  /// ========================================================================
  /// switch-fabric
  /// ========================================================================

  container switch-fabric {
    tailf:cli-add-mode;
    tailf:cli-explicit-exit;

    list service-policy {
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        tailf:cli-suppress-leafref-in-diff;
        tailf:non-strict-leafref {
          path "/cisco-ios-xr:policy-map/name";
        }
        type string {
          tailf:info "WORD;;Name of the service policy";
        }
      }
    }
  }


  /// ========================================================================
  /// lpts
  /// ========================================================================

  container lpts {
    tailf:info "lpts configuration commands";
    tailf:cli-explicit-exit;

    // lpts pifib hardware
    container pifib {
      tailf:info "pre-ifib configuration commands";
      container hardware {
        tailf:info "hardware configuration commands";

        // lpts pifib hardware police
        container police {
          tailf:info "ingress policers configuration command";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-pifib-policer-global";
          presence true;

          // lpts pifib hardware police / flow *
          uses lpts-flow-grouping;
        }

        // lpts pifib hardware police location *
        container police-location {
          tailf:cli-drop-node-name;
          container police {
            tailf:info "ingress policers configuration command";
            list location {
              tailf:info "Location Specification";
              tailf:cli-mode-name "config-pifib-policer-per-node";
              key id;
              leaf id {
                type string {
                  tailf:info "WORD;;Enter Location";
                }
              }
              leaf preconfigure {
                tailf:info "Specify a preconfig";
                tailf:cli-prefix-key;
                type empty;
              }

              // lpts pifib hardware police location * / flow *
              uses lpts-flow-grouping;
            }
          }
        }

        // lpts pifib hardware dynamic-flows location *
        container dynamic-flows {
          tailf:info "ingress flows configuration command";
          list location {
            tailf:info "Location Specification";
            tailf:cli-mode-name "config-pifib-flows-per-node";
            key id;
            leaf id {
              type string {
                tailf:info "WORD;;Enter Location";
              }
            }
            leaf preconfigure {
              tailf:info "Specify a preconfig";
              tailf:cli-prefix-key;
              type empty;
            }

            // lpts pifib hardware dynamic-flows location * / flow *
            list flow {
              tailf:info "lpts flow type";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-incomplete-command;
              key name;
              leaf name {
                tailf:cli-multi-word-key;
                tailf:cli-disallow-value "exit|(.+ (known|configured|max).*)";
                type string {
                  tailf:info "WORD;;flow specifier(s)";
                }
              }
              container known {
                tailf:info "Known ";
                leaf max {
                  tailf:info "Max number of TCAM entries";
                  type uint32 {
                    tailf:info "<0-4294967295>;;TCAM Entries NUM";
                  }
                }
              }
              container configured {
                tailf:info "Configured";
                leaf max {
                  tailf:info "Max number of TCAM entries";
                  type uint32 {
                    tailf:info "<0-4294967295>;;TCAM Entries NUM";
                  }
                }
              }
              leaf max {
                tailf:info "Max number of TCAM entries";
                type uint32 {
                  tailf:info "<0-4294967295>;;TCAM Entries NUM";
                }
              }
            }
          }
        }
      }
    }

    // lpts punt
    container punt {
      tailf:info "punt configuration commands";

      // lpts punt excessive-flow-trap
      container excessive-flow-trap {
        tailf:info "excessive punt flow trap configuration commands";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-control-plane-policer";

        // lpts punt excessive-flow-trap / penalty-rate *
        list penalty-rate {
          tailf:info "Configure penalty policing rate";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          key protocol;
          leaf protocol {
            type enumeration {
              enum arp {
                tailf:info "Configure penalty policing rate for arp";
              }
              enum dhcp {
                tailf:info "Configure penalty policing rate for dhcp";
              }
              enum icmp {
                tailf:info "Configure penalty policing rate for icmp";
              }
              enum igmp {
                tailf:info "Configure penalty policing rate for igmp";
              }
              enum ip {
                tailf:info "Configure penalty policing rate for ipv4/v6";
              }
              enum l2tp {
                tailf:info "Configure penalty policing rate for l2tp";
              }
              enum ppp {
                tailf:info "Configure penalty policing rate for ppp";
              }
              enum pppoe {
                tailf:info "Configure penalty policing rate for pppoe";
              }
              enum unclassified {
                tailf:info "Configure penalty policing rate for unclassified";
              }
              enum default {
                tailf:info "Configure default penalty policing rate for all protocols";
              }
            }
          }
          leaf rate {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<2-100>;;Penalty policer rate in packets-per-second";
              range "2..100";
            }
          }
        }

        // lpts punt excessive-flow-trap / exclude interface *
        container exclude {
          tailf:info "Exclude an interface from all traps";
          list interface {
            tailf:info "Exclude an interface from all traps";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key name;
            leaf name {
              type ifname;
            }
          }
        }

        // lpts punt excessive-flow-trap / dampening
        container dampening {
          tailf:info "Dampening bad actor notifications";
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          presence true;
          leaf time {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<5000-60000>;;Dampening period for a bad actor flow in milliseconds";
              range "5000..60000";
            }
          }
        }

        // lpts punt excessive-flow-trap / non-subscriber-interfaces
        container non-subscriber-interfaces {
          tailf:info "Enable the trap on non-subscriber interfaces";
          tailf:cli-delete-when-empty;
          tailf:cli-reset-container;
          presence true;
          leaf mac {
            tailf:info "Enable trap based on source mac on non-subscriber interface";
            type empty;
          }
        }

        // lpts punt excessive-flow-trap / report-threshold
        leaf report-threshold {
          tailf:info "Bad actor report threshold(cisco-support)";
          type uint16 {
            tailf:info "<1-65535>;;Threshold to cross for a flow to be considered as bad actor flow";
            range "1..65535";
          }
        }
      }

      // lpts punt police location *
      container police {
        tailf:info "ingress policers configuration command";
        list location {
          tailf:info "Configure line card location";
          tailf:cli-mode-name "config-punt-policer-per-node";
          key name;
          leaf name {
            tailf:cli-disallow-value "preconfigure";
            type string {
              tailf:info "WORD;;Fully qualified line card specification";
            }
          }

          // lpts punt police location preconfigure *
          leaf preconfigure {
            tailf:info "Specify a preconfig";
            tailf:cli-prefix-key;
            type empty;
          }

          // lpts punt police location * / protocol * rate
          list protocol {
            tailf:info "Protocol packets";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key name;
            leaf name {
              tailf:cli-multi-word-key;
              tailf:cli-disallow-value "exit|(.+ rate.*)";
              type string {
                tailf:info "WORD;;Protocol name";
              }
            }
            leaf rate {
              tailf:info "Rate in PPS";
              type uint32 {
                tailf:info "<0-4294967295>;;Packets Per Second";
              }
            }
          }

          // lpts punt police location * / exception
          container exception {
            tailf:info "Exception packets";

            // lpts punt police location * / exception ipv4
            container ipv4 {
              tailf:info "IPV4 exception packets";

              // lpts punt police location * / exception ipv4 fragment rate
              container fragment {
                tailf:info "Fragmentation needed packets";
                leaf rate {
                  tailf:info "Rate in PPS";
                  type uint32 {
                    tailf:info "<0-4294967295>;;packet per second";
                  }
                }
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// hw-module
  /// ========================================================================

  container hw-module {
    tailf:info "Configure h/w module";
    tailf:cli-explicit-exit;

    // hw-module ejector
    container ejector {
      tailf:info "Enable waiting for ejector close on all RP cards";

      // hw-module ejector close
      container close {
        tailf:info "Wait for ejector close before initiating card shutdown";

        // hw-module ejector close wait
        leaf wait {
          tailf:info "Wait for 15 seconds before initiating card shutdown";
          type empty;
        }
      }
    }

    // hw-module fib
    container fib {
      tailf:info "Forwarding table to configure";

      // hw-module fib ipv4 scale
      container ipv4 {
        tailf:info "Configure ipv4 protocol";
        leaf scale {
          tailf:info "Configure scale mode for no-TCAM card";
          type enumeration {
            enum host-optimized-disable {
              tailf:info "Configure Host optimization by default";
            }
            enum internet-optimized {
              tailf:info "Configure Internet optimized";
            }
          }
        }
      }

      // hw-module fib ipv6 scale
      container ipv6 {
        tailf:info "Configure ipv6 protocol";
        leaf scale {
          tailf:info "Configure scale mode for no-TCAM card";
          type enumeration {
            enum internet-optimized-disable {
              tailf:info "Configure by default Internet optimized";
            }
            enum internet-optimized {
              tailf:info "Configure Internet optimized";
            }
          }
        }
      }

      // hw-module fib mpls
      container mpls {
        tailf:info "Configure mpls protocol";
        container label {
          tailf:info "Configure MPLS label convergence optimization for LDP/SR labels";
          leaf lsr-optimized {
            tailf:info "Configure LSR optimization";
            type empty;
          }
        }
        container ldp {
          tailf:info "Configure signalling protocol for MPLS2";
          leaf lsr-optimized {
            tailf:info "Configure optimization for LSR role";
            type empty;
          }
        }
      }
    }

    // hw-module qos
    container qos {
      tailf:info "Quality of Service";

      // hw-module qos pol-gran
      container pol-gran {
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf granularity {
          tailf:cli-drop-node-name;
          type uint8 {
            range "8..64";
          }
        }
        leaf location {
          type string;
        }
      }

      // hw-module qos queue-auto-defrag
      container queue-auto-defrag {
        container disable {
          list location {
            key id;
            leaf id {
              type string {
                // node-id
              }
            }
          }
        }
      }

      // hw-module qos account
      container account {
        container layer2 {
          container encapsulation {
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            choice encapsulation-choice {
              leaf arpa {
                type empty;
              }
              leaf dot1q {
                type empty;
              }
              leaf length {
                type uint8 {
                  range "1..50";
                }
              }
            }
            leaf location {
              type string {
                // node-idx
              }
            }
          }
        }
      }

      // hw-module qos multicast
      container multicast {
        tailf:cli-compact-syntax;

        // hw-module qos multicast location
        leaf location {
          type string {
          }
        }

        // hw-module qos multicast priorityq disable location
        container priorityq {
          container disable {
            leaf location {
              type string;
            }
          }
        }
      }
    }

    // hw-module pse
    container pse {
      container allocate {
        container tcam {
          list location {
            key id;
            leaf id {
              type string {
                // node-id
              }
            }
            list region {
              key "name num";
              leaf name {
                type string;
              }
              leaf num {
                type uint32;
              }
            }
          }
        }
      }
    }

    // hw-module mac-move police-mode
    container mac-move {
      tailf:info "Configure mac-move behavior.";
      leaf police-mode {
        tailf:info "Control the mode for mac-move.";
        type enumeration {
          enum on {
            tailf:info "Switch on mac-move policing.";
          }
          enum off {
            tailf:info "Switch off mac-move policing.";
          }
        }
      }
    }

    // hw-module linecard throughput *
    container linecard {
      tailf:info "Configure linecard";
      list throughput {
        tailf:info "Configure linecard throughput";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Fully qualified location specification";
          }
        }
        leaf throughput {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type enumeration {
            enum 20G {
              tailf:info "20Gps throughput";
            }
            enum 40G {
              tailf:info "40Gps throughput";
            }
          }
        }
      }
    }

    // hw-module location *
    container location  {
      tailf:info "Fully qualified location specification";
      uses hw-module-location-list-grouping;

      // hw-module location preconfigure *
      container preconfigure {
        tailf:info "Specify a preconfig";
        uses hw-module-location-list-grouping;
      }
    }

    // hw-module subslot *
    list subslot {
      tailf:info "Configure subslot h/w module";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Fully qualified location specification";
        }
      }
      leaf cardtype {
        tailf:info "Configure the SPA physical interface type";
        tailf:cli-full-command;
        type enumeration {
          enum e1 {
            tailf:info "E1 interface type";
          }
          enum e3 {
            tailf:info "E3 interface type";
          }
          enum sdh {
            tailf:info "SDH interface type";
          }
          enum sonet {
            tailf:info "Sonet interface type";
          }
          enum t1 {
            tailf:info "T1 interface type";
          }
          enum t3 {
            tailf:info "T3 interface type(default)";
          }
        }
      }
      // hw-module subslot * shutdown
      container shutdown {
        tailf:info "Shutdown a subslot h/w module";
        tailf:cli-delete-when-empty;
        presence true;
        leaf option {
          tailf:cli-drop-node-name;
          type enumeration {
            // hw-module subslot * shutdown powered
            enum powered {
              tailf:info "Keep the shutdown module powered (default)";
            }
            // hw-module subslot * shutdown unpowered
            enum unpowered {
              tailf:info "Keep the shutdown module unpowered";
            }
          }
        }
      }
    }

    // hw-module port * srp location *
    list port {
      tailf:info "The port";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key id;
      leaf id {
        type uint8 {
          tailf:info "<0-15>;;Port number on the specified Linecard";
          range "0..15";
        }
      }
      list srp {
        tailf:info "set port in SRP mode";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key location;
        leaf location {
          tailf:info "Fully qualified location";
          tailf:cli-expose-key-name;
          type string {
            tailf:info "WORD;;fully qualified port location";
          }
        }
        leaf spa-bay {
          tailf:info "Execute subslot h/w module operations";
          type uint8 {
            tailf:info "<0-5>;;spa_to_configure";
            range "0..5";
          }
        }
      }
    }

    // hw-module port-range
    list port-range {
      tailf:info "Configure port range";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      key "start end";
      leaf start {
        type uint8 {
          tailf:info "<0-71>;;configure start port";
        }
      }
      leaf end {
        type uint8 {
          tailf:info "<0-71>;;configure end port";
        }
      }
      leaf instance {
        tailf:info "card instance of MPA's";
        tailf:cli-incomplete-command;
        type uint8 {
          tailf:info "<0-5>;;MPA Instance 1,2,3 etc for MPA's";
        }
      }
      leaf location {
        tailf:info "fully qualified location specification";
        tailf:cli-incomplete-command;
        type string {
          tailf:info "0/RP0/CPU0;;fully qualified location specification";
        }
      }
      leaf mode {
        tailf:info "port mode 40-100, 400, 2x100, 4x10, 4x25, 4x10-4x25, 1x100, 2x100-PAM4, 3x100, 4x100";
        type string {
          tailf:info "WORD;;port mode 40-100, 400, 2x100, 4x10, 4x25, 4x10-4x25, 1x100, 2x100-PAM4, 3x100, 4x100";
        }
      }
    }

    // hw-module profile
    container profile {
      tailf:info "Configure profile.";

      // hw-module profile acl egress layer3 interface-based
      container acl {
        tailf:info "Configure acl profile";
        container egress {
          tailf:info "egress acl";
          container layer3 {
            tailf:info "egress layer3 acl";
            leaf interface-based {
              tailf:info "egress layer3 interface-based acl";
              type empty;
            }
          }
        }
      }

      // hw-module profile qos
      container qos {
        tailf:info "Configure qos profile";

        // hw-module profile qos hqos-enable
        leaf hqos-enable {
          tailf:info "Enable Hierarchical QoS";
          type empty;
        }

        // hw-module profile qos physical-hqos-enable
        leaf physical-hqos-enable {
          type empty;
        }

        // hw-module profile qos qosg-dscp-mark-enable *
        leaf-list qosg-dscp-mark-enable {
          tailf:info "Enable both 'set qos-group' and 'set dscp/precedence' actions in the same ingress QoS policy";
          tailf:cli-flat-list-syntax;
          tailf:cli-replace-all;
          ordered-by user;
          max-elements 8;
          type uint8 {
            tailf:info "<0-63>;;DSCP/Precedence value (1-8 values)";
            range "0..63";
          }
        }

        // hw-module profile qos max-classmap-size
        container max-classmap-size {
          tailf:info "max class map size";

          // hw-module profile qos max-classmap-size
          leaf value {
            tailf:cli-drop-node-name;
            tailf:cli-full-command;
            type enumeration {
              enum 4 {
                tailf:info "Max 4 class-maps per policy";
              }
              enum 8 {
                tailf:info "Max 8 class-maps per policy";
              }
              enum 16 {
                tailf:info "Max 16 class-maps per policy";
              }
              enum 32 {
                tailf:info "Max 32 class-maps per policy";
              }
            }
          }

          // hw-module profile qos max-classmap-size ? location *
          list location-list {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf value {
              tailf:cli-drop-node-name;
              tailf:cli-prefix-key;
              type enumeration {
                enum 4 {
                  tailf:info "Max 4 class-maps per policy";
                }
                enum 8 {
                  tailf:info "Max 8 class-maps per policy";
                }
                enum 16 {
                  tailf:info "Max 16 class-maps per policy";
                }
                enum 32 {
                  tailf:info "Max 32 class-maps per policy";
                }
              }
            }
            key location;
            leaf location {
              tailf:info "Location of QoS config";
              tailf:cli-expose-key-name;
              type string {
                tailf:info "WORD;;Location of QoS config";
              }
            }
          }
        }

        // hw-module profile qos ingress-model
        container ingress-model {
          tailf:info "QoS model for ingress feature";

          // hw-module profile qos ingress-model peering
          leaf peering {
            tailf:info "Peering model for ingress QoS";
            type empty;
          }

          // hw-module profile qos ingress-model peering location *
          container peering-location {
            tailf:cli-drop-node-name;
            container peering {
              tailf:info "Peering model for ingress QoS";
              list location {
                tailf:info "Location of QoS config";
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                key name;
                leaf name {
                  type string {
                    tailf:info "WORD;;Location of QoS config";
                  }
                }
              }
            }
          }
        }

        // hw-module profile qos conform-aware-policer
        leaf conform-aware-policer {
          tailf:info "Configure Conform Aware Policer mode";
          type empty;
        }
      }

      // hw-module profile segment-routing srv6
      container segment-routing {
        tailf:info "Segment routing options";
        container srv6 {
          tailf:info "Configure support for SRv6 and its paramaters";
          tailf:cli-delete-when-empty;
          tailf:cli-reset-container;
          presence true;
          // hw-module profile segment-routing srv6 encapsulation traffic-class
          container encapsulation {
            tailf:info "Configure encapsulation parameters";
            leaf traffic-class {
              tailf:info "Control traffic-class field on IPv6 header";
              type union {
                type enumeration {
                  enum propagate {
                    tailf:info "Propagate traffic-class from incoming packet/frame";
                  }
                }
                type string {
                  tailf:info "<0x0-0xff>;;Traffic-class value (specified as 2 hexadecimal nibbles)";
                  pattern '0x[0-9a-f]{2}';
                }
              }
            }
          }
        }
      }

      // hw-module profile stats
      container stats {
        tailf:info "Configure stats profile.";
        choice stats-choice {
          leaf acl-permit {
            tailf:info "Enable ACL permit stats.";
            type empty;
          }
          leaf enh-sr-policy {
            tailf:info "Enable Enhanced_SR_Policy_Scale stats profile counter.";
            type empty;
          }
          leaf ingress-sr {
            tailf:info "Enable ingress SR stats profile counter.";
            type empty;
          }
          leaf qos-enhanced {
            tailf:info "Enable enhanced QoS stats.";
            type empty;
          }
          leaf tx-scale-enhanced {
            tailf:info "Enable enhanced TX stats scale (Non L2 stats).";
            type empty;
          }
        }
      }

      // hw-module profile flowspec
      container flowspec {
        tailf:info "Configure support for v6 flowspec";

        // hw-module profile flowspec v6-enable
        leaf v6-enable {
          tailf:info "Configure support for v6 flowspec";
          tailf:cli-full-command;
          type empty;
        }

        // hw-module profile flowspec v6-enable location *
        container v6-enable-location {
          tailf:cli-drop-node-name;
          container v6-enable {
            tailf:info "Configure support for v6 flowspec";
            tailf:cli-incomplete-command;
            tailf:cli-incomplete-no;
            list location {
              tailf:info "Location of flowspec config";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key name;
              leaf name {
                type string {
                  tailf:info "WORD;;Location of flowspec config";
                }
              }
            }
          }
        }
      }

      // hw-module profile tcam
      container tcam {
        tailf:info "profile tcam";

        // hw-module profile tcam acl-prefix percent
        container acl-prefix {
          tailf:info "ACL table to configure";
          leaf percent {
            tailf:info "percent to configure";
            type uint8 {
              tailf:info "<0-100>;;value in percent";
              range "0..100";
            }
          }
        }

        // hw-module profile tcam fib ipv4 unicast percent
        container fib {
          tailf:info "Forwarding table to configure";
          container ipv4 {
            tailf:info "Configure ipv4 addresses in TCAM";
            container unicast {
              tailf:info "Unicast address";
              leaf percent {
                tailf:info "percent to configure";
                type uint8 {
                  tailf:info "<1-100>;;value in percent";
                  range "1..100";
                }
              }
            }
          }
        }

        // hw-module profile tcam format access-list *
        container format {
          tailf:info "format of the tcam entry";
          list access-list {
            tailf:info "Access List format";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key af;
            leaf af {
              tailf:cli-incomplete-command;
              type enumeration {
                enum ipv4 {
                  tailf:info "IPv4";
                }
                enum ipv6 {
                  tailf:info "IPv6";
                }
              }
            }
            leaf acl-qualifiers {
              tailf:cli-drop-node-name;
              tailf:cli-multi-value;
              tailf:cli-preformatted;
              type string {
                tailf:info "LINE;;format qualifiers with optional names";
              }
            }
          }
        }
      }

      // hw-module profile load-balance algorithm gtp-mpls
      container load-balance {
        tailf:info "Configure load balance parameters";
        container algorithm {
          tailf:info "Configure hashing algorithm profiles";
          choice alg-choice {
            leaf gtp-mpls {
              type empty;
            }
            leaf gtp {
              tailf:info "GTP optimized.";
              type empty;
            }
            leaf L3-only {
              type empty;
            }
          }
        }
      }

      // hw-module profile bundle-scale
      leaf bundle-scale {
        tailf:info "Max number of bundles supported";
        type enumeration {
          enum 256 {
            tailf:info "Max 256 trunks, Max 64 members";
          }
          enum 512 {
            tailf:info "Max 512 trunks, Max 32 members";
          }
          enum 1024 {
            tailf:info "Max 1024 trunks, Max 16 members";
          }
        }
      }

      // hw-module profile cef
      container cef {
        tailf:info "Configure cef profiles";
        container bgplu {
          tailf:info "Configure bgplu attribute";
          leaf enable {
            tailf:info "Enable BGPLU feature";
            type empty;
          }
        }
        container cbf {
          tailf:info "Enable cbf";
          leaf enable {
            tailf:info "Enable CBF feature";
            type empty;
          }
        }
        container dark-bw {
          tailf:info "Configure dark-bandwidth";
          leaf enable {
            tailf:info "Enable Dark bandwidth feature";
            type empty;
          }
        }
        container ip-redirect {
          tailf:info "IP redirect";
          leaf enable {
            tailf:info "Enable IP redirect";
            type empty;
          }
        }
        container ipv6 {
          tailf:info "IPv6";
          container hop-limit {
            tailf:info "Hop-limit 0 packets";
            leaf punt {
              tailf:info "Punt hop-limit 0 packets";
              type empty;
            }
          }
        }
        container lpts {
          tailf:info "LPTS / Enable lpts pifib per-entry counters";
          leaf acl {
            tailf:info "Enable ACL";
            type empty;
          }
          leaf pifib-entry-counters {
            tailf:info "Configure number of counters";
            type uint16 {
              tailf:info "<256-512>;;number of counters";
            }
          }
        }
        container stats {
          tailf:info "Configure feature level stats";
          container label {
            tailf:info "Configure label stats";
            container app-default {
              tailf:info "Applies to - LDP and SR";
              leaf dynamic {
                tailf:info "Allocate counters till OOR";
                type empty;
              }
            }
          }
        }
        container te-tunnel {
          tailf:info "Configure te tunnel profile";
          leaf highscale-no-ldp-over-te {
            tailf:info "Enable te tunnels high scale and disable ldp over te";
            type empty;
          }
        }
        container ttl {
          tailf:info "Configure ttl profile";
          container tunnel-ip {
            tailf:info "Configure tunnel-ip ttl mode";
            container decrement {
              tailf:info "Configure tunnel-ip ttl decrement behaviour";
              leaf disable {
                tailf:info "Disable tunnl-ip inner ttl decrement";
                type empty;
              }
            }
          }
        }
      }

    }

    // hw-module tcam fib ipv4 scaledisable
    container tcam {
      tailf:info "Configure profile for TCAM LC cards";
      container fib {
        tailf:info "Forwarding table to configure";
        container ipv4 {
          tailf:info "Configure ipv4 protocol";
          leaf scaledisable {
            tailf:info "Configure scale mode for TCAM card";
            type empty;
          }
        }
      }
    }

    // hw-module all qos-mode
    container all {
      tailf:info "all line cards";
      container qos-mode {
        tailf:info "Configure qos mode in HW Module port(s)";

        // hw-module all qos-mode pwhe-aggregate-shaper sub-interface
        container pwhe-aggregate-shaper {
          tailf:info "Configure pseudo wire headend interface qos parameters";
          container sub-interface {
            tailf:info "Configure pseudo wire headend sub interface qos mode";
            leaf egress {
              tailf:info "egress direction";
              type enumeration {
                enum non-queuing {
                  tailf:info "coexistence non-queuing";
                }
                enum queuing {
                  tailf:info "coexistence queuing";
                }
              }
            }
            leaf ingress {
              tailf:info "ingress direction";
              type enumeration {
                enum non-queuing {
                  tailf:info "coexistence non-queuing";
                }
                enum queuing {
                  tailf:info "coexistence queuing";
                }
              }
            }
          }
        }

        // hw-module all qos-mode aggregate-bundle-mode
        leaf aggregate-bundle-mode {
          tailf:info "set aggregate bundle mode";
          type empty;
        }

        // hw-module all qos-mode ingress-queue-enable
        leaf ingress-queue-enable {
          tailf:info "enable ingress queueuing support for MOD-80 4*10G MPA or MOD-400 20*10G MPA";
          type empty;
        }
      }
    }

    // hw-module service
    container service {
      tailf:info "Configure service role.";

      // hw-module service offline location *
      container offline {
        tailf:info "Take all services on the card offline";
        list location {
          tailf:info "Location to configure";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Fully qualified location specification";
            }
          }
        }
      }
    }

    // hw-module quad * location
    list quad {
      tailf:info "Configure quad.";
      tailf:cli-incomplete-command;
      key id;
      leaf id {
        tailf:cli-suppress-range;
        type uint8 {
          tailf:info "<0-11>;;configure quad properties";
        }
      }
      leaf location {
        tailf:info "fully qualified location specification";
        tailf:cli-hide-in-submode;
        type string {
          tailf:info "WORD;;fully qualified location specification";
        }
      }

      // hw-module quad * location / mode
      leaf mode {
        tailf:info "select mode 10g or 25g for a quad(group of 4 ports).";
        type string {
          tailf:info "WORD;;10g or 25g, (10g mode also operates 1g transceivers)";
        }
      }
    }

    // hw-module bfd-hw-offload enable location
    container bfd-hw-offload {
      tailf:info "Configure BFD hw offload parameters";
      container enable {
        tailf:info "Enable BFD hw offload mode";
        leaf location {
          tailf:info "Configure line card location";
          type string {
            tailf:info "WORD;;Fully qualified line card specification";
          }
        }
      }
    }

    // hw-module vrrpscale enable
    container vrrpscale {
      leaf enable {
        tailf:info "enable";
        type empty;
      }
    }

    // hw-module fia-intf-policer disable
    container fia-intf-policer {
      tailf:info "FIA interface rate-limiter on 7-Fabric LC";
      leaf disable {
        tailf:info "disable FIA interface policer";
        type empty;
      }
    }

  }


  /// ========================================================================
  /// fpd
  /// ========================================================================

  // fpd
  container fpd {
    tailf:info "FPD firmware configuration";

    // fpd auto-reload
    leaf auto-reload {
      tailf:info "Auto-reload node(Linecard) after FPD auto-upgrade";
      type enumeration {
        enum disable {
          tailf:info "Disable fpd auto reload`";
        }
        enum enable {
          tailf:info "Enable fpd auto reload`";
        }
      }
    }

    // fpd auto-upgrade
    leaf auto-upgrade {
      tailf:info "FPD auto-upgrade configuration";
      type enumeration {
        enum disable {
          tailf:info "Disable fpd auto upgrade`";
        }
        enum enable {
          tailf:info "Enable fpd auto upgrade`";
        }
      }
    }
  }


  /// ========================================================================
  /// class-map
  /// ========================================================================

  list class-map {
    tailf:info "Configure QoS Class Map";
    tailf:cli-mode-name "config-cmap";
    tailf:cli-exit-command "end-class-map";
    key name;
    leaf name {
      tailf:cli-disallow-value "end-class-map";
      type string {
        tailf:info "WORD;;class-map name";
      }
    }

    // class-map type traffic *
    leaf type {
      tailf:info "The type of class-map";
      tailf:cli-prefix-key;
      type enumeration {
        enum traffic {
          tailf:info "Traffic class-map";
        }
      }
    }

    // class-map * / prematch
    leaf prematch {
      tailf:cli-drop-node-name;
      tailf:cli-prefix-key;
      type enumeration {
        enum match-all {
          tailf:info "Logical-AND all matching statements under this classmap";
        }
        enum match-any {
          tailf:info "Logical-OR all matching statements under this classmap";
        }
      }
      default match-all;
    }

    // class-map * / description
    leaf description {
      tailf:info "Class-Map description";
      tailf:cli-multi-value;
      tailf:cli-preformatted;
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;Description of this class-map (up to 200 characters)";
      }
    }

    // class-map * / match
    container match {
      tailf:info "classification criteria";
      uses class-map-match-grouping;
      container not {
        tailf:info "Negate match criteria";
        uses class-map-match-grouping;
      }
    }

    // Note: rename is action and not needed
  }


  /// ========================================================================
  /// class-map type control subscriber
  /// ========================================================================

  // class-map type control subscriber *
  container class-map-filter-control {
    tailf:cli-drop-node-name;
    list class-map {
      tailf:info "Configure QoS Class Map";
      tailf:cli-mode-name "config-cmap";
      tailf:cli-suppress-list-no;
      tailf:cli-no-key-completion;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-full-command;
      tailf:cli-exit-command "end-class-map" {
        tailf:info "End class map configuration";
      }
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;class-map name";
        }
      }
      leaf type {
        tailf:info "The type of class-map";
        tailf:cli-prefix-key;
        type enumeration {
          enum control {
            tailf:info "Control class-map";
          }
        }
      }
      leaf domain {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        type enumeration {
          enum subscriber {
            tailf:info "Subscriber control class-map";
          }
        }
      }
      leaf prematch {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        type enumeration {
          enum match-all {
            tailf:info "Match all match criteria";
          }
          enum match-any {
            tailf:info "Match any match criteria (default)";
          }
        }
      }

      // class-map type control subscriber * / match
      container match {
        tailf:info "Configure match criteria for this class.";
        uses class-map-filter-control-match-grouping;
        container not {
          tailf:info "Negate match criteria";
          uses class-map-filter-control-match-grouping;
        }
      }
    }
  }


  /// ========================================================================
  /// policy-map
  /// ========================================================================

  list policy-map {
    tailf:info "Configure a policymap";
    tailf:cli-mode-name "config-pmap";
    tailf:cli-exit-command "end-policy-map" {
      tailf:info "End policy map configuration";
    }
    key name;
    leaf name {
      tailf:cli-disallow-value "end-policy-map";
      type string {
        tailf:info "WORD;;Name of the policymap";
      }
    }

    // policy-map type *
    leaf type {
      tailf:info "The type of policymap";
      tailf:cli-prefix-key;
      type enumeration {
        enum pbr {
          tailf:info "PBR policy-map";
        }
        enum performance-traffic {
          tailf:info "Performance traffic policy-map";
        }
        enum redirect {
          tailf:info "Redirect policy-map";
        }
        enum traffic {
          tailf:info "Traffic policy-map";
        }
      }
    }

    // policy-map * / description
    leaf description {
      tailf:info "Set description for this policy-map";
      tailf:cli-multi-value;
      tailf:cli-preformatted;
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;Description for this policy-map";
      }
    }

    // policy-map * / class
    container class {
      tailf:info "Class map";

      // policy-map * / class *
      list class-ref {
        tailf:cli-drop-node-name;
        tailf:cli-mode-name "config-pmap-c";
        tailf:cli-full-command;
        tailf:cli-show-long-obu-diffs;
        ordered-by user;
        key map;
        leaf map {
          tailf:cli-disallow-value "class-default";
          tailf:non-strict-leafref {
            path "/cisco-ios-xr:class-map/name";
          }
          type string {
            tailf:info "WORD;;Name of class";
          }
        }
        uses policy-map-class-grouping;
      }

      // policy-map * / class class-default
      list class-default {
        tailf:cli-drop-node-name;
        tailf:cli-mode-name "config-pmap-c";
        tailf:cli-full-command;
        key map;
        leaf map {
          type enumeration {
            enum class-default {
              tailf:info "The default class";
            }
          }
        }
        uses policy-map-class-grouping;
      }
    }
  }


  /// ========================================================================
  /// policy-map type control subscriber
  /// ========================================================================

  container policy-map-event-control {
    tailf:cli-drop-node-name;
    list policy-map {
      tailf:info "Configure a policymap";
      tailf:cli-mode-name "config-pmap";
      tailf:cli-sequence-commands;
      tailf:cli-exit-command "end-policy-map" {
        tailf:info "End policy map configuration";
      }
      key name;
      leaf name {
        tailf:cli-disallow-value "type";
        type string {
          tailf:info "WORD;;policy-map name";
        }
      }
      /// policy-map type control subscriber *
      leaf type {
        tailf:info "The type of policymap";
        tailf:cli-prefix-key;
        type enumeration {
          enum control {
            tailf:info "Control policy-map";
          }
        }
      }
      leaf domain {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        type enumeration {
          enum subscriber {
            tailf:info "Subscriber control policy-map";
          }
        }
      }

      // policy-map * / event *
      list event {
        tailf:info "Policy event";
        tailf:cli-mode-name "config-pmap-e";
        tailf:cli-show-long-obu-diffs;
        ordered-by user;
        key "name match";
        leaf name {
          tailf:cli-suppress-range;
          type enumeration {
            enum account-logoff {
              tailf:info "Account logoff event";
            }
            enum account-logon {
              tailf:info "Account logon event";
            }
            enum authentication-failure {
              tailf:info "Authentication failure event";
            }
            enum authentication-no-response {
              tailf:info "Authentication no response event";
            }
            enum authorization-failure {
              tailf:info "Authorization failure event";
            }
            enum authorization-no-response {
              tailf:info "Authorization no response event";
            }
            enum credit-exhausted {
              tailf:info "Credit exhaustion event";
            }
            enum exception {
              tailf:info "Exception event";
            }
            enum idle-timeout {
              tailf:info "Idle timeout event";
            }
            enum quota-depleted {
              tailf:info "Quota depletion event";
            }
            enum service-start {
              tailf:info "Service start event";
            }
            enum service-stop {
              tailf:info "Service stop event";
            }
            enum session-activate {
              tailf:info "Session activate event";
            }
            enum session-identity-change {
              tailf:info "session identity change event";
            }
            enum session-start {
              tailf:info "Session start event";
            }
            enum session-stop {
              tailf:info "Session stop event";
            }
            enum timer-expiry {
              tailf:info "Timer expiry event";
            }
          }
        }
        leaf match {
          tailf:key-default "match-all";
          type enumeration {
            enum match-all {
              tailf:info "Execute all the matched classes";
            }
            enum match-first {
              tailf:info "Execute only the first matched class";
            }
          }
        }

        // policy-map * / event * / class *
        list class {
          tailf:info "Class map";
          tailf:cli-mode-name "config-pmap-c";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Name of class";
            }
          }
          leaf type {
            tailf:info "The type of policymap";
            tailf:cli-prefix-key;
            type enumeration {
              enum control {
                tailf:info "Class of type control";
              }
            }
          }
          leaf domain {
            tailf:cli-drop-node-name;
            tailf:cli-prefix-key;
            type enumeration {
              enum subscriber {
                tailf:info "Class of sub-type subscriber";
              }
            }
          }
          leaf execute {
            tailf:cli-drop-node-name;
            tailf:cli-hide-in-submode;
            type enumeration {
              enum do-all {
                tailf:info "Do all actions";
              }
              enum do-until-failure {
                tailf:info "Do all actions until failure";
              }
              enum do-until-success {
                tailf:info "Do all actions until success";
              }
            }
          }

          // policy-map * / event * / class * / *
          list action-list {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            tailf:cli-incomplete-command;
            key id;
            leaf id {
              type uint16 {
                tailf:info "<1-65535>;;Sequence number for this action";
                range "1..65535";
              }
            }
            leaf action {
              tailf:cli-drop-node-name;
              type enumeration {
                enum activate {
                  tailf:info "Activate";
                }
                enum authenticate {
                  tailf:info "Authentication related configuration";
                }
                enum authorize {
                  tailf:info "Authorize";
                }
                enum deactivate {
                  tailf:info "Deactivate";
                }
                enum disconnect {
                  tailf:info "Disconnect session";
                }
                enum monitor {
                  tailf:info "Monitor session";
                }
                enum set-timer {
                  tailf:info "Set a timer to execute a rule on its expiry";
                }
                enum stop-timer {
                  tailf:info "Disable timer before it expires";
                }
              }
            }
            leaf action-string {
              tailf:cli-drop-node-name;
              tailf:cli-multi-value;
              type string {
                tailf:info "WORD;;action string";
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// crypto
  /// ========================================================================

  container crypto {
    tailf:info "Global Crypto configuration command";
    tailf:cli-explicit-exit;

    // crypto keyring *
    list keyring {
      tailf:info "Key ring commands";
      tailf:cli-mode-name "config-keyring";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;name of the key ring";
        }
      }
      leaf vrf {
        tailf:info "Mention a vrf it belongs to";
        tailf:cli-hide-in-submode;
        type string {
          tailf:info "WORD;;the VRF name";
        }
      }

      // crypto keyring * / description
      uses description-grouping;

      // crypto keyring * / rsa-pubkey
      container rsa-pubkey {
        tailf:info "Peer RSA public key chain management";

        // crypto keyring * / rsa-pubkey name *
        list name {
          tailf:info "Public key associated with a hostname";
          tailf:cli-mode-name "config-pubkey";
          key "name type";
          leaf name {
            type string {
              tailf:info "WORD;;name of key";
            }
          }
          leaf type {
            tailf:key-default "signature";
            type enumeration {
              enum encryption {
                tailf:info "Key is to be used for encryption only";
              }
              enum signature {
                tailf:info "Key is to be used for verifying signature only (default)";
              }
            }
          }
        }
      }
    }

    // crypto ca
    container ca {
      tailf:info "Certification authority";

      // crypto ca trustpoint *
      list trustpoint {
        tailf:info "Config a trustpoint";
        tailf:cli-mode-name "config-trustp";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Trustpoint Name";
          }
        }

        // crypto ca trustpoint * / keypair
        container keypair {
          tailf:info "key pair for router/leaf cert";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf name {
            tailf:cli-drop-node-name;
            type enumeration {
              enum dsa {
                tailf:info "Dsa key pair label";
              }
              enum ecdsanistp256 {
                tailf:info "Ecdsa key pair";
              }
              enum ecdsanistp384 {
                tailf:info "Self enrollment, ecdsa key pair";
              }
              enum ecdsanistp521 {
                tailf:info "Self enrollment, ecdsa key pair";
              }
              enum rsa {
                tailf:info "Rsa key pair";
              }
            }
          }
          leaf label {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;key pair label";
            }
          }
        }

        // crypto ca trustpoint * / ca-keypair
        container ca-keypair {
          tailf:info "Self enrollment, key pair ca cert";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf name {
            tailf:cli-drop-node-name;
            type enumeration {
              enum dsa {
                tailf:info "Dsa key pair label";
              }
              enum ecdsanistp256 {
                tailf:info "Ecdsa key pair";
              }
              enum ecdsanistp384 {
                tailf:info "Self enrollment, ecdsa key pair";
              }
              enum ecdsanistp521 {
                tailf:info "Self enrollment, ecdsa key pair";
              }
              enum rsa {
                tailf:info "Rsa key pair";
              }
            }
          }
          leaf label {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;key pair label";
            }
          }
        }

        // crypto ca trustpoint * / ip-address
        leaf ip-address {
          tailf:info "include ip address";
          type union {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;ip address";
            }
            type enumeration {
              enum none {
                tailf:info "do not include ip address";
              }
            }
          }
        }

        // crypto ca trustpoint * / crl optional
        container crl {
          tailf:info "CRL options";
          leaf optional {
            tailf:info "CRL verification as optional";
            type empty;
          }
        }

        // crypto ca trustpoint * / subject-name
        leaf subject-name {
          tailf:info "Subject Name";
          type string {
            tailf:info "LINE;;Subject Name";
          }
        }

        // crypto ca trustpoint * / enrollment
        container enrollment {
          tailf:info "Enrollment parameters";

          // crypto ca trustpoint * / enrollment url
          leaf url {
            tailf:info "CA server enrollment URL";
            type union {
              type enumeration {
                enum terminal {
                  tailf:info "Enroll via the terminal (cut-and-paste)";
                }
              }
              type string {
                tailf:info "WORD;;URL";
              }
            }
          }
        }

        // crypto ca trustpoint * / rsakeypair
        leaf rsakeypair {
          tailf:info "RSA key pair";
          type string {
            tailf:info "WORD;;Key pair label";
          }
        }

        // crypto ca trustpoint * / message-digest
        leaf message-digest {
          tailf:info "Certificate message digesti self enrollment";
          type enumeration {
            enum md5 {
              tailf:info "md5 algorithm for message digest.(1)";
            }
            enum sha1 {
              tailf:info "sha1 algorithm for message digest.(2)";
            }
            enum sha256 {
              tailf:info "sha256 algorithm for message digest.(3)";
            }
            enum sha384 {
              tailf:info "sha384 algorithm for message digest.(4)";
            }
            enum sha512 {
              tailf:info "sha384 algorithm for message digest.(5)";
            }
          }
        }

        // crypto ca trustpoint * / vrf
        leaf vrf {
          tailf:info "Source interface VRF";
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;VRF name (max:32 chars)";
          }
        }
      }
    }


    // crypto gdoi group *
    container gdoi {
      tailf:info "Configure GDOI policy";
      list group {
        tailf:info "Define a GDOI group";
        tailf:cli-mode-name "config-gdoi";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Group Name";
          }
        }

        // crypto gdoi group * / client registration interface
        container client {
          tailf:info "Set the group client parameters";
          container registration {
            tailf:info "Set the group client management/register interface";
            container interface {
              tailf:info "Specify group client management/register interface";
              uses interface-name-grouping;
            }
          }
        }

        // crypto gdoi group * / identity number
        container identity {
          tailf:info "Set the identity of the group";
          leaf number {
            tailf:info "Set the identity of the group as a number";
            type uint32 {
              tailf:info "<1-2147483647>;;Set the group number";
              range "1..2147483647";
            }
          }
        }

        // crypto gdoi group * / * server address ipv4
        list server {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          key id;
          leaf id {
            type uint16 {
              tailf:info "<1-10000>;;Group Key Server Precedence ";
              range "1..10000";
            }
          }
          container server {
            tailf:info "Set the group key server parameters";
            container address {
              tailf:info "Identify the group server by address";
              leaf ipv4 {
                tailf:info "Set the identity of the group as an IPv4 address";
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IPv4 address";
                }
              }
            }
          }
        }
      }
    }

    // crypto ipsec
    container ipsec {
      tailf:info "Configure IPSEC policy";

      // crypto ipsec profile *
      list profile {
    	tailf:info "Configure IPSEC profile";
    	key name;
    	leaf name {
    	  type string {
    		tailf:info "WORD;;IPSec profile name - maximum 32 characters";
    	  }
    	}

    	// crypto ipsec profile * / set
    	container set {
    	  tailf:info "Specify profile settings";

    	  // crypto ipsec profile * / set transform-set *
    	  leaf-list transform-set {
    		tailf:info "Specify list of transform sets in priority order";
    		tailf:cli-flat-list-syntax;
    		tailf:cli-replace-all;
    		ordered-by user;
    		type string {
    		  tailf:info "WORD;;Transform - maximum 32 characters";
    		}
    	  }

    	  // crypto ipsec profile * / set pfs
    	  leaf pfs {
    		tailf:info "Specify PFS setting";
    		type enumeration {
    		  enum group1 {
    			tailf:info "D-H Group1 (768-bit modp)";
    		  }
    		  enum group14 {
      			tailf:info "D-H Group14 (2048-bit modp)";
      		  }
    		  enum group15 {
        	    tailf:info "D-H Group15";
              }
    		  enum group16 {
          	    tailf:info "D-H Group16";
              }
    		  enum group17 {
          	    tailf:info "D-H Group17";
              }
      		  enum group18 {
            	tailf:info "D-H Group18";
              }
      		  enum group2 {
        	    tailf:info "D-H Group2 (1024-bit modp)";
              }
    		  enum group5 {
          	    tailf:info "D-H Group5 (1536-bit modp)";
              }
    		}
    	  }

    	  // crypto ipsec profile * / set isakmp-profile
    	  leaf isakmp-profile {
    		tailf:info "Specify isakmp Profile";
    		type string {
    		  tailf:info "WORD;;isakmp profile name - maximum 32 characters";
    		}
    	  }

    	  // crypto ipsec profile * / set security-association
    	  container security-association {
    		tailf:info "Profile security association parameters";

    		// crypto ipsec profile * / set security-association lifetime
    		container lifetime {
    		  tailf:info "security association lifetime";
    		  choice lifetime-choice {
    		    // crypto ipsec profile * / set security-association lifetime days
    		    leaf days {
    			  tailf:info "Time-based key duration in days";
    			  type uint8 {
    			    tailf:info "<1-30>;;Profile security association duration in days";
                    range "1..30";
    			  }
    		    }

    		    // crypto ipsec profile * / set security-association lifetime seconds
    		    leaf seconds {
    			  tailf:info "Time-based key duration in seconds";
    			  type uint32 {
    			    tailf:info "<120-2592000>;;Profile security association duration in seconds";
                    range "120..2592000";
    		  	  }
    		    }
    		  }
    		}

    		// crypto ipsec profile * / set security-association replay
    		container replay {
    		  tailf:info "Set replay checking";

    		  // crypto ipsec profile * / set security-association replay disable
    		  leaf disable {
    			tailf:info "Disable replay checking";
    			type empty;
    		  }
    		}
    	  }
    	}
      }

      // crypto ipsec transform-set *
      list transform-set {
    	tailf:info "Define transform and settings";
    	tailf:cli-incomplete-command;
    	key name;
    	leaf name {
    	  type string {
    		tailf:info "WORD;;Transform set tag - maximum 32 characters";
    	  }
    	}
    	choice esp-choice {
    	  // crypto ipsec transform-set * / esp-aes
    	  leaf esp-aes {
    	    tailf:info "ESP transform using AES cipher (128 bits)";
    	    tailf:cli-hide-in-submode;
    	    type enumeration {
    	      enum 128 {
    	    	tailf:info "128 bit keys";
    	      }
    		  enum 192 {
    			tailf:info "192 bit keys";
    		  }
    		  enum 256 {
    			tailf:info "256 bit keys";
    		  }
    	    }
    	  }
    	  // crypto ipsec transform-set * / esp-3des
    	  leaf esp-3des {
    	    tailf:info "ESP transform using 3DES(EDE) cipher (168 bits)";
    	    tailf:cli-hide-in-submode;
    	    type empty;
    	  }
    	}

    	leaf transform {
    	  tailf:cli-drop-node-name;
    	  tailf:cli-hide-in-submode;
    	  tailf:cli-full-command;
    	  type enumeration {
    		enum esp-md5-hmac {
    		  tailf:info "ESP transform using HMAC-MD5 auth";
    		}
    		enum esp-sha-hmac {
      		  tailf:info "ESP transform using HMAC-SHA auth";
      		}
    		enum esp-sha256-hmac {
      		  tailf:info "ESP-HMAC-SHA256 transform";
      		}
    		enum esp-sha384-hmac {
        	  tailf:info "ESP-HMAC-SHA384 transform";
        	}
    		enum esp-sha512-hmac {
        	  tailf:info "ESP-HMAC-SHA512 transform";
        	}
    	  }
    	}

    	// crypto ipsec transform-set * / mode
  	    leaf mode {
  		  tailf:info "encapsulation mode (transport/tunnel)";
  		  type enumeration {
  		    enum transport {
  			  tailf:info "transport encapsulation mode";
  		    }
  		    enum tunnel {
    		  tailf:info "tunnel encapsulation mode";
    	    }
  		  }
  	    }
      }
    }

    // crypto ipsec-node *
    list ipsec-node {
      tailf:info "ipsec node global configuration";
      tailf:cli-mode-name "config-ipsec-node";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Specify the node name";
        }
      }

      // crypto ipsec-node * / admin
      leaf admin {
        tailf:info "Admin specific details";
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;ipv4 address";
        }
      }

      // crypto ipsec-node * / data
      leaf data {
        tailf:info "Data path  specific details";
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;ipv4 address";
        }
      }
    }

    // crypto isakmp
    container isakmp {
      tailf:info "Configure isakmp Options";

      // crypto isakmp keyring *
      list keyring {
        tailf:info "Configure keyring Options";
        tailf:cli-mode-name "config-crypto-keyring";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;name of the key ring";
          }
        }

        // crypto isakmp keyring * vrf
        leaf vrf {
          tailf:info "mention a vrf it belongs to";
          tailf:cli-hide-in-submode;
          type string {
            tailf:info "WORD;;vrf name";
          }
        }

        // crypto isakmp keyring * / description
        uses description-grouping;

        // crypto isakmp keyring * / pre-shared-key address *
        list pre-shared-key {
          tailf:info "Specify pre-shared-key to use";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          key address;
          leaf address {
        	tailf:info "pre shared key by address";
            tailf:cli-expose-key-name;
        	tailf:cli-incomplete-command;
        	type inet:ipv4-address {
              tailf:info "A.B.C.D;;A.B.C.D address prefix";
            }
          }
          leaf netmask {
      	    tailf:info "address prefix mask";
      	    tailf:cli-drop-node-name;
      	    tailf:cli-optional-in-sequence;
      	    tailf:cli-incomplete-command;
      	    type inet:ipv4-address {
              tailf:info "A.B.C.D;;address prefix mask";
            }
          }

          // crypto isakmp keyring * / pre-shared-key address * key
          container key {
            tailf:info "specify the key";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf type {
              tailf:cli-drop-node-name;
              tailf:cli-optional-in-sequence;
              tailf:cli-incomplete-command;
              type enumeration {
                enum encrypted {
                   tailf:info "Specifies a HIDDEN password will follow";
                }
              }
            }
            leaf secret {
              tailf:cli-drop-node-name;
              tailf:cli-reset-container;
              tailf:cli-disallow-value "encrypted";
              cli:secret " key <SECRET>";
              type NEDCOM_SECRET_TYPE {
                tailf:info "LINE;;The UNENCRYPTED (cleartext) user password";
              }
            }
          }
        }
      }

      // crypto isakmp policy *
      list policy {
    	tailf:info "Define isakmp policy";
        tailf:cli-mode-name "config-isakmp-policy";
    	key policy-id;
    	leaf policy-id {
    	  type uint16 {
    		tailf:info "<1-10000>;;Policy number";
    	  }
    	}

    	// crypto isakmp policy * / hash
    	leaf hash {
    	  tailf:info "Hash algorithm {md5 | sha | sha256 | sha384 | sha512}";
    	  type enumeration {
    		enum md5 {
    		  tailf:info "Message Digest 5";
    		}
    		enum sha {
    		  tailf:info "Secure Hash Standard 1 (96 bit)";
    		}
    		enum sha256 {
    		  tailf:info "Secure Hash Standard 2 (256 bit)";
    		}
    		enum sha384 {
    		  tailf:info "Secure Hash Standard 2 (384 bit)";
    		}
    		enum sha512 {
    		  tailf:info "Secure Hash Standard 2 (512 bit)";
    		}
    	  }
    	}

    	// crypto isakmp policy * / group
    	leaf group {
    	  tailf:info "Set the Diffie-Hellman group";
    	  type enumeration {
    		enum 1 {
    		  tailf:info "Diffie-Hellman group 1 (768 bit)";
    		}
    		enum 14 {
      		  tailf:info "Diffie-Hellman group 14 (2048 bit)";
      		}
    		enum 15 {
      		  tailf:info "Diffie-Hellman group 15 (3072 bit)";
      		}
    		enum 16 {
      		  tailf:info "Diffie-Hellman group 16 (4096 bit)";
      		}
    		enum 17 {
      		  tailf:info "Diffie-Hellman group 17 (6144 bit)";
      		}
    		enum 18 {
      		  tailf:info "Diffie-Hellman group 18 (8192 bit)";
      		}
    		enum 2 {
      		  tailf:info "Diffie-Hellman group 2 (1024 bit)";
      		}
    		enum 5 {
      		  tailf:info "Diffie-Hellman group 5 (1536 bit)";
      		}
    	  }
    	}

    	// crypto isakmp policy * / encryption
    	container encryption {
    	  tailf:info "Set encryption algorithm for protection suite";

    	  choice enc-choice {
    	    // crypto isakmp policy * / encryption aes
    	    leaf aes {
    		  tailf:info "AES - Advanced Encryption Standard";
    		  type enumeration {
    			enum 128 {
    			  tailf:info "128 bit keys";
    			}
    			enum 192 {
      			  tailf:info "192 bit keys";
      			}
    			enum 256 {
      			  tailf:info "256 bit keys";
      			}
    		  }
    	    }
    	    // crypto isakmp policy * / encryption 3des
    	    leaf a3des {
    	      tailf:info "Three key triple DES";
    	      tailf:alt-name "3des";
    	      type empty;
    	    }
    	  }
    	}

    	// crypto isakmp policy * /  lifetime
    	leaf lifetime {
    	  tailf:info "Set lifetime for ISAKMP security association";
    	  type uint32  {
    		tailf:info "<60-86400>;;lifetime in seconds";
            range "60..86400";
    	  }
    	}

    	// crypto isakmp policy * / authentication pre-share
    	leaf authentication {
    	  tailf:info "Set authentication method for protection suite";
    	  type enumeration {
    		enum pre-share {
    		  tailf:info "Pre-Shared Key";
    		}
    	  }
    	}
      }

      // crypto isakmp profile *
      list profile {
    	tailf:info "Define isakmp profile";
    	tailf:cli-mode-name "config-isakmp-profile";
    	key name;
    	leaf name {
          type string {
            tailf:info "WORD;;Profile name";
          }
    	}

        // crypto isakmp profile * / match identity address * *
    	container match {
    	  tailf:info "match values of peer";
    	  container identity {
    		tailf:info "identity;;Identity";
    		list address {
    		  tailf:info "IPv4 Address and mask";
    		  tailf:cli-suppress-mode;
    		  tailf:cli-delete-when-empty;
    		  key "ipv4-address netmask";
    		  leaf ipv4-address {
    			type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IP address";
                }
    		  }
    		  leaf netmask {
    			type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IP mask";
                }
    		  }
            }
          }
        }


        // crypto isakmp profile * / match identity address * * vrf *
        container match-vrf {
          tailf:cli-drop-node-name;
          container match {
            tailf:info "match values of peer";
            container identity {
              tailf:info "identity;;Identity";
              list address {
                tailf:info "IPv4 Address and mask";
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                key "ipv4-address netmask vrf";
                leaf ipv4-address {
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;IP address";
                  }
                }
                leaf netmask {
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;IP mask";
                  }
                }
                leaf vrf {
                  tailf:info "set tunnel vrf membership";
                  tailf:cli-expose-key-name;
    			  type string {
    			    tailf:info "WORD;;VRF Name";
    			  }
    			}
    		  }
    		}
    	  }
    	}

    	// crypto isakmp profile * / keyring *
    	list keyring {
    	  tailf:info "Specify keyring to use";
    	  tailf:cli-suppress-mode;
    	  tailf:cli-delete-when-empty;
    	  key name;
    	  leaf name {
    	    type union {
    		  type enumeration {
    		    enum default {
    		      tailf:info "Use default keyring";
    		    }
    		  }
    		  type string {
    			tailf:info "WORD;;Specify the keyring";
    		  }
    	    }
    	  }
    	}
      }
    }

    // crypto map * * gdoi
    list map {
      tailf:info "Enter a crypto map";
      tailf:cli-mode-name "config-crypto-map";
      tailf:cli-incomplete-command;
      key "name id";
      leaf name {
        type string {
          tailf:info "WORD;;Name of the crypto map";
        }
      }
      leaf id {
        type uint16 {
          tailf:info "<1-65535>;;Sequence to insert into crypto map entry";
          range "1..65535";
        }
      }
      leaf gdoi {
        tailf:info "Configure crypto map gdoi features";
        tailf:cli-hide-in-submode;
        type empty;
      }

      // crypto map * * gdoi / set group
      container set {
        tailf:info "Set values";
        leaf group {
          tailf:info "Set the group parameters";
          type string {
            tailf:info "WORD;;Set the group name";
          }
        }
      }

      // crypto map * * gdoi / match address
      container match {
        tailf:info "Match values.";
        leaf address {
          tailf:info "Match address of packets to encrypt.";
          type string {
            tailf:info "WORD;;Access-list name";
          }
        }
      }

      // crypto map * * gdoi / fail-close
      container fail-close {
        tailf:info "Specify a fail-close ACL.";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf acl {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;Access-list name";
          }
        }
        leaf revert {
          tailf:info "Revert on SA lifetime expiry";
          type empty;
        }
      }

      // crypto map * * gdoi / ipsec-node
      leaf ipsec-node {
        tailf:info "Set the ipsec node on this crypto map";
        type string {
          tailf:info "WORD;;Set the ipsec-node name";
        }
      }

      // crypto map * * gdoi / interface *
      list interface {
        tailf:info "Enable crypto map on an interface";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Interface Name";
          }
        }
        leaf auto-shut {
          tailf:info "Bring down this interface on ipsec failure";
          type empty;
        }
      }
    }

    // crypto fips-mode
    leaf fips-mode {
      tailf:info "Enable FIPS mode";
      type empty;
    }
  }


  /// ========================================================================
  /// flow
  /// ========================================================================

  container flow {
    tailf:info "Configure a flexible flow object";
    tailf:cli-explicit-exit;

    // flow exporter-map *
    list exporter-map {
      tailf:info "Configure a flow exporter map";
      tailf:cli-mode-name "config-fem";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Exporter map name - maximum 32 characters";
        }
      }

      // flow exporter-map * / version
      container version {
        tailf:info "Specify export version parameters";

        // flow exporter-map * / version v9
        container v9 {
          tailf:info "Use version 9 export format";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-fem-ver";
          presence true;

          // flow exporter-map * / version v9 / options
          container options {
            tailf:info "Specify export of options template";

            // flow exporter-map * / version v9 / options interface-table
            container interface-table {
              tailf:info "Export interface table";
              tailf:cli-delete-when-empty;
              presence true;
              // flow exporter-map * / version v9 / options interface-table timeout
              leaf timeout {
                tailf:info "Specify export timeout";
                type uint32 {
                  tailf:info "<1-604800>;;1Timeout value in seconds";
                  range "1..604800";
                }
              }
            }

            // flow exporter-map * / version v9 / options sampler-table
            container sampler-table {
              tailf:info "Export sampler table";
              tailf:cli-delete-when-empty;
              presence true;
              // flow exporter-map * / version v9 / options sampler-table timeout
              leaf timeout {
                tailf:info "Specify export timeout";
                type uint32 {
                  tailf:info "<1-604800>;Timeout value in seconds";
                  range "1..604800";
                }
              }
            }

            // flow exporter-map * / version v9 / options vrf-table
            container vrf-table {
              tailf:info "Export VRF ID-to-name table";
              tailf:cli-delete-when-empty;
              presence true;
              leaf timeout {
                tailf:info "Specify export timeout";
                type uint32 {
                  tailf:info "<1-604800>;;Timeout value in seconds";
                }
              }
            }
          }

          // flow exporter-map * / version v9 / template
          container template {
            tailf:info "Specify template export parameters";

            // flow exporter-map * / version v9 / template timeout
            leaf timeout {
              tailf:info "Specify custom timeout for the template";
              type uint32 {
                tailf:info "<1-604800>;Timeout value in seconds";
                range "1..604800";
              }
            }

            // flow exporter-map * / version v9 / template data timeout
            container data {
              tailf:info "Data template configuration options";
              leaf timeout {
                tailf:info "Specify custom timeout for the template";
                type uint32 {
                  tailf:info "<1-604800>;;Timeout value in seconds";
                  range "1..604800";
                }
              }
            }

            // flow exporter-map * / version v9 / template options timeout
            container options {
              tailf:info "Options template configuration options";
              leaf timeout {
                tailf:info "Specify custom timeout for the template";
                type uint32 {
                  tailf:info "<1-604800>;;Timeout value in seconds";
                  range "1..604800";
                }
              }
            }
          }
        }

        // flow exporter-map * / version ipfix
        container ipfix {
          tailf:info "Use IPFIX export format";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-fem-ver";
          presence true;
          container options {
            tailf:info "Specify export of options template";
            grouping timeout-grouping {
              leaf timeout {
                tailf:info "Specify export timeout";
                type uint32 {
                  tailf:info "<1-604800>;;Timeout value in seconds";
                }
              }
            }
            container interface-table {
              tailf:info "Export interface table";
              presence true;
              uses timeout-grouping;
            }
            container sampler-table {
              tailf:info "Export sampler table";
              presence true;
              uses timeout-grouping;
            }
            container vrf-table {
              tailf:info "Export VRF ID-to-name table";
              presence true;
              uses timeout-grouping;
            }
          }
          container template {
            tailf:info "Specify template export parameters";
            grouping timeout-grouping {
              leaf timeout {
                tailf:info "Specify custom timeout for the template";
                type uint32 {
                  tailf:info "<1-604800>;;Timeout value in seconds";
                }
              }
            }
            container data {
              tailf:info "Data template configuration options";
              uses timeout-grouping;
            }
            container options {
              tailf:info "Options template configuration options";
              uses timeout-grouping;
            }
            uses timeout-grouping;
          }
        }
      }

      // flow exporter-map * / dscp
      leaf dscp {
        tailf:info "Specify DSCP value for export packets";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<0-63>;;Differentiated services codepoint value";
          range "0..63";
        }
      }

      // flow exporter-map * / transport udp
      container transport {
        tailf:info "Specify the transport protocol for export packets";
        leaf udp {
          tailf:info "Use UDP as transport protocol";
          type uint16 {
            tailf:info "<1024-65535>;;Destination UDP port value";
            range "1024..65535";
          }
        }
      }

      // flow exporter-map * / source
      container source {
        tailf:info "Source interface";
        uses interface-name-grouping;
      }

      // flow exporter-map * / destination
      container destination {
        tailf:info "Export destination configuration";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf address {
          tailf:cli-drop-node-name;
          type inet:host {
            tailf:info "Hostname or A.B.C.D;;Destination IP address";
          }
        }
        leaf vrf {
          tailf:info "Configure VRF to be used for reaching export destination";
          type vrf-type;
        }
      }
    }

    // flow monitor-map *
    list monitor-map {
      tailf:info "Configure a flow monitor map";
      tailf:cli-mode-name "config-fmm";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Monitor map name - maximum 32 characters";
        }
      }

      // flow monitor-map * / record
      container record {
        tailf:info "Specify a flow record map name";
        choice record-choice {
          // flow monitor-map * / record ipv4
          container ipv4 {
            tailf:info "IPv4 raw record format";
            presence true;
            choice record-ipv4-choice {
              leaf peer-as {
                tailf:info "Record peer AS";
                type empty;
              }
              leaf destination-tos {
                tailf:info "IPv4 Destination Based NetFlow Accounting TOS";
                type empty;
              }
            }
          }

          // flow monitor-map * / record ipv6
          container ipv6 {
            tailf:info "IPv6 raw record format";
            presence true;
            leaf peer-as {
              tailf:info "Record peer AS";
              type empty;
            }
          }

          // flow monitor-map * / record mpls
          container mpls {
            tailf:info "MPLS record format";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            presence true;
            leaf fields-fmt {
              tailf:cli-drop-node-name;
              tailf:cli-optional-in-sequence;
              type enumeration {
                enum ipv4-fields {
                  tailf:info "MPLS with IPv4 fields format";
                }
                enum ipv4-ipv6-fields {
                  tailf:info "MPLS with IPv4 and IPv6 fields format";
                }
                enum ipv6-fields {
                  tailf:info "MPLS with IPv6 fields format";
                }
              }
            }
            leaf labels {
              tailf:info "Labels to be used for Hashing";
              type uint8 {
                tailf:info "<1-6>;;Number of Labels to be used for Hashing";
                range "1..6";
              }
            }
          }

          leaf datalinksectiondump {
            tailf:info "dump data link section";
            type empty;
          }
        }
      }

      // flow monitor-map * / option *
      leaf-list option {
        tailf:info "Select an optional feature for the flow cache";
        tailf:cli-list-syntax;
        type enumeration {
          enum bgpattr {
            tailf:info "export bgp attributes AS_PATH and STD_COMMUNITY";
          }
          enum filtered {
            tailf:info "Enable filtering of records";
          }
          enum outphysint {
            tailf:info "export output interfaces as physical interfaces";
          }
          enum outbundlemember {
            tailf:info "export output physical interfaces of bundle interface";
          }
        }
      }

      // flow monitor-map * / exporter *
      leaf-list exporter {
        tailf:info "Specify flow exporter map name";
        tailf:cli-list-syntax;
        tailf:cli-suppress-leafref-in-diff;
        tailf:non-strict-leafref {
          path "../../exporter-map/name";
        }
        type string {
          tailf:info "WORD;;Exporter map name - maximum 32 characters";
        }
      }

      // flow monitor-map * / cache
      container cache {
        tailf:info "Specify flow cache attributes";

        // flow monitor-map * / cache immediate
        // flow monitor-map * / cache permanent
        choice cache-choice {
          leaf immediate {
            tailf:info "Immediate removal of entries from flow cache";
            type empty;
          }
          leaf permanent {
            tailf:info "Disable removal of entries from flow cache";
            type empty;
          }
        }

        // flow monitor-map * / cache entries
        leaf entries {
          tailf:info "Specify the number of entries in the flow cache";
          type uint32 {
            tailf:info "<4096-1000000>;;Number of flow cache entries";
            range "4096..1000000";
          }
        }

        // flow monitor-map * / cache timeout
        container timeout {
          tailf:info "Specify the flow cache timeouts";

          // flow monitor-map * / cache timeout active
          leaf active {
            tailf:info "Specify the active flow timeout";
            type uint32 {
              tailf:info "<1-604800>;;Timeout value in seconds";
              range "1..604800";
            }
          }

          // flow monitor-map * / cache timeout inactive
          leaf inactive {
            tailf:info "Specify the inactive flow timeout";
            type uint32 {
              tailf:info "<1-604800>;;Timeout value in seconds";
              range "1..604800";
            }
          }

          // flow monitor-map * / cache timeout rate-limit
          leaf rate-limit {
            tailf:info "Maximum number of entries to age each second";
            type uint32 {
              tailf:info "<1-1000000>;;Entries per second";
              range "1..1000000";
            }
          }

          // flow monitor-map * / cache timeout update
          leaf update {
            tailf:info "Specify the update timeout";
            type uint32 {
              tailf:info "<1-604800>;;Timeout value in seconds";
              range "1..604800";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// sampler-map
  /// ========================================================================

  list sampler-map {
    tailf:info "Configure a sampler map";
    tailf:cli-mode-name "config-sm";
    tailf:cli-explicit-exit;
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;Sampler map name - maximum 32 characters";
      }
    }

    // sampler-map * / random
    container random {
      tailf:info "Use random mode for sampling packets";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf number-of-packets {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type enumeration {
          enum "1" {
            tailf:info "<1-1>;;Number of packets to be sampled in the sampling interval";
          }
        }
      }
      leaf out-of {
        tailf:info "Sample one packet out of";
        tailf:cli-incomplete-command;
        type empty;
      }
      leaf sampling-interval {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<1-65535>;;Sampling interval in units of packets";
          range "1..65535";
        }
      }
    }
  }


  /// ========================================================================
  /// clock-interface
  /// ========================================================================

  container clock-interface {
    tailf:info "Clock interface configuration commands";
    tailf:cli-explicit-exit;

    // clock-interface sync *
    list sync {
      tailf:info "Synchronization clock interface";
      tailf:cli-mode-name "config-clock-if";
      key "id location";
      leaf id {
        type uint32 {
          tailf:info "<0-4294967295>;;Clock interface port number";
        }
      }

      // clock-interface sync * / shutdown
      leaf shutdown {
        tailf:info "Disable the SyncE Port";
        type empty;
      }

      // clock-interface sync * / location
      leaf location {
        tailf:info "Specify the clock interface location";
        tailf:cli-expose-key-name;
        type string {
          tailf:info "WORD;;Fully qualified location specification";
        }
      }

      // clock-interface sync * / port-parameters
      container port-parameters {
        tailf:info "clock port parameter setting";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-clk-parms";

        // clock-interface sync * / port-parameters / bits-input
        container bits-input {
          tailf:info "BITS RX interface";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf mode {
            tailf:cli-drop-node-name;
            type enumeration {
              enum "2m" {
                tailf:info "2m mode";
              }
              enum "64k-input-only" {
                tailf:info "64k-input-only mode";
              }
              enum "e1" {
                tailf:info "e1 mode";
              }
              enum "t1" {
                tailf:info "t1 mode";
              }
            }
          }
          leaf mode1 {
            tailf:cli-drop-node-name;
            type enumeration {
              enum d4 {
                tailf:info "d4 mode";
              }
              enum esf {
                tailf:info "esf mode";
              }
              enum crc-4 {
                tailf:info "crc4 mode";
              }
              enum non-crc-4 {
                tailf:info "non-crc-4 mode";
              }
            }
          }
          leaf sa {
            when "../mode1 = 'crc-4'";
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            type enumeration {
              enum sa4 {
                tailf:info "SSM on Sa4 bit channel";
              }
              enum sa5 {
                tailf:info "SSM on Sa5 bit channel";
              }
              enum sa6 {
                tailf:info "SSM on Sa6 bit channel";
              }
              enum sa7 {
                tailf:info "SSM on Sa7 bit channel";
              }
              enum sa8 {
                tailf:info "SSM on Sa8 bit channel";
              }
            }
          }
          leaf mode2 {
            tailf:cli-drop-node-name;
            type union {
              type enumeration {
                enum ami {
                  tailf:info "ami mode";
                }
                enum b8zs {
                  tailf:info "b8zs mode";
                }
                enum hdb3 {
                  tailf:info "hdb3 mode";
                }
              }
              type string {
              }
            }
          }
        }

        // clock-interface sync * / port-parameters / bits-output
        container bits-output {
          tailf:info "BITS TX interface";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf mode {
            tailf:cli-drop-node-name;
            type enumeration {
              enum "2m" {
                tailf:info "2m mode";
              }
              enum "6m-output-only" {
                tailf:info "6m-output-only mode";
              }
              enum "e1" {
                tailf:info "e1 mode";
              }
              enum "t1" {
                tailf:info "t1 mode";
              }
            }
          }
          leaf mode1 {
            tailf:cli-drop-node-name;
            type enumeration {
              enum d4 {
                tailf:info "d4 mode";
              }
              enum esf {
                tailf:info "esf mode";
              }
            }
          }
          leaf mode2 {
            tailf:cli-drop-node-name;
            type enumeration {
              enum ami {
                tailf:info "ami mode";
              }
              enum b8zs {
                tailf:info "b8zs mode";
              }
            }
          }
          leaf buildout {
            tailf:cli-drop-node-name;
            type enumeration {
              enum 0 {
                tailf:info "line buildout 0-133ft";
              }
              enum 1 {
                tailf:info "line buildout 134-266ft";
              }
              enum 2 {
                tailf:info "line buildout 267-399ft";
              }
              enum 3 {
                tailf:info "line buildout 400-533ft";
              }
              enum 4 {
                tailf:info "line buildout 534-655ft";
              }
            }
          }
        }
      }

      // clock-interface sync * / frequency
      container frequency {
        tailf:info "Frequency Synchronization configuration";

        // clock-interface / frequency synchronization
        container synchronization {
          tailf:info "Frequency Synchronization configuration";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-clk-freqsync";

          // clock-interface / frequency synchronization / selection
          container selection {
            tailf:info "Selection configuration commands";
            leaf input {
              tailf:info "Enable this source for selection";
              type empty;
            }
          }

          // clock-interface / frequency synchronization / priority
          leaf priority {
            tailf:info "Source priority";
            tailf:cli-full-command;
            type uint8 {
              tailf:info "<1-254>;;Source priority";
              range "1..254";
            }
          }

          // clock-interface / frequency synchronization / time-of-day-priority
          leaf time-of-day-priority {
            tailf:info "Source time-of-day priority";
            type uint8 {
              tailf:info "<1-254>;;Source time-of-day priority";
              range "1..254";
            }
          }

          // clock-interface / frequency synchronization / wait-to-restore
          leaf wait-to-restore {
            tailf:info "Set the wait-to-restore time";
            tailf:cli-full-command;
            type uint8 {
              tailf:info "<0-12>;;Wait-to-restore time, in minutes";
              range "0..12";
            }
          }

          // clock-interface / frequency synchronization / ssm
          container ssm {
            tailf:info "SSM configuration commands";
            leaf disable {
              tailf:info "Disable sending of SSMs";
              type empty;
            }
          }

          // clock-interface / frequency synchronization / quality
          container quality {
            tailf:info "Quality level configuration";
            container receive {
              tailf:info "Adjust the received quality level";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              uses freqsync-quality-grouping;
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// l2
  /// ========================================================================

  container l2 {
    tailf:info "Layer 2 configuration";
    tailf:cli-explicit-exit;

    // l2 vfi *
    list vfi {
      tailf:info "Configure a virtual forwarding instance";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;VFI name";
        }
      }

      leaf mode {
        tailf:cli-drop-node-name;
        tailf:cli-hide-in-submode;
        type enumeration {
          enum manual {
          }
          enum autodiscovery {
            tailf:info "Multipoint autodiscovery configuration mode";
          }
        }
      }

      // l2 vfi * / vpn
      container vpn {
        tailf:info "VPN configuration";
        leaf id {
          tailf:info "VPN id";
          type uint32 {
            tailf:info "<1-4294967295>;;VPN id value";
            range "1..4294967295";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// auto
  /// ========================================================================

  container auto {
    tailf:info "Configure Automation";
    tailf:cli-explicit-exit;

    // auto qos
    leaf qos {
      tailf:info "Configure AutoQoS";
      type enumeration {
        enum default {
          tailf:info "Configure AutoQoS Default";
        }
      }
    }
  }


  /// =================================1======================================
  /// ethernet-services
  /// ========================================================================

  container ethernet-services {
    tailf:info "Ethernet related services";
    tailf:cli-explicit-exit;

    // ethernet-services access-list *
    list access-list {
      tailf:cli-mode-name "config-es-acl";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Access list name - maximum 64 characters";
          length "1..64";
        }
      }
      list rule {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key id;
        leaf id {
          type uint32 {
            tailf:info "<1-2147483646>;;Sequence number for this entry";
            range "1..2147483646";
          }
        }
        leaf line {
          tailf:cli-drop-node-name;
          tailf:cli-multi-value;
          type string {
            tailf:info "deny|permit|remark <parameters>";
            pattern "(deny.*)|(permit.*)|(remark.*)|(no.*)";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// interface
  /// ========================================================================

  container interface {
    tailf:info "Select an interface to configure";
    tailf:cli-explicit-exit;

    uses interface-grouping;

    container preconfigure {
      tailf:info "Specify a preconfig";
      uses interface-grouping;
    }
  }


  /// ========================================================================
  /// controller
  /// ========================================================================

  container controller {
    tailf:info "Controller configuration subcommands";
    tailf:cli-explicit-exit;

    // controller *
    uses controller-grouping;

    // controller preconfigure *
    container preconfigure {
      tailf:info "Specify a preconfig";
      uses controller-grouping;
    }
  }


  /// ========================================================================
  /// dynamic-template
  /// ========================================================================

  container dynamic-template {
    tailf:info "Dynamically Applied Configuration Template Definition";
    tailf:cli-add-mode;
    tailf:cli-explicit-exit;

    // dynamic-template / type
    container type {
      tailf:info "'type' keyword";

      // dynamic-template / type ppp *
      list ppp {
        tailf:info "PPP dynamic template type";
        tailf:cli-mode-name "config-dynamic-template-type";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Dynamic Template Name";
          }
        }

        // dynamic-template / type ppp * / ppp
        container ppp {
          tailf:info "Point-to-Point Protocol";

          // dynamic-template / type ppp * / ppp max-configure
          leaf max-configure {
            tailf:info "Configure maximum number of unacknowledged Conf-Requests";
            type uint8 {
              tailf:info "<4-20>;;number of retries";
              range "4..20";
            }
          }

          // dynamic-template / type ppp * / ppp timeout
          container timeout {
            tailf:info "Set timeout";

            // dynamic-template / type ppp * / ppp timeout
            leaf retry {
              tailf:info "Maximum time to wait for a response during PPP negotiation";
              type uint8 {
                tailf:info "<1-10>;;Seconds";
                range "1..10";
              }
            }

            // dynamic-template / type ppp * / ppp timeout
            leaf authentication {
              tailf:info "Maximum time to wait for an authentication response";
              type uint8 {
                tailf:info "<3-30>;;Seconds";
                range "3..30";
              }
            }

            // dynamic-template / type ppp * / ppp timeout
            leaf absolute {
              tailf:info "The absolute timeout for a PPP session";
              type uint32 {
                tailf:info "<0-35000000>;;Minutes";
                range "0..35000000";
              }
            }
          }

          // dynamic-template / type ppp * / ppp authentication *
          leaf-list authentication {
            tailf:info "Set PPP link authentication method";
            tailf:cli-flat-list-syntax;
            tailf:cli-replace-all;
            ordered-by user;
            type enumeration {
              enum chap {
                tailf:info "Authenticate using CHAP";
              }
              enum ms-chap {
                tailf:info "Authenticate using Microsoft-CHAP";
              }
              enum pap {
                tailf:info "Authenticate using PAP";
              }
            }
          }

          // dynamic-template / type ppp * / ppp ipcp
          container ipcp {
            tailf:info "Set IPCP negotiation options";

            // dynamic-template / type ppp * / ppp ipcp passive
            leaf passive {
              tailf:info "Run IPCP in Passive mode";
              type empty;
            }

            // dynamic-template / type ppp * / ppp ipcp dns
            container dns {
              tailf:info "DNS options";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf primary {
                tailf:cli-drop-node-name;
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Primary DNS IP address";
                }
              }
              leaf secondary {
                tailf:cli-drop-node-name;
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Secondary DNS IP address";
                }
              }
            }

            // dynamic-template / type ppp * / ppp ipcp peer-address
            container peer-address {
              tailf:info "Change peer-address configuration";

              // dynamic-template / type ppp * / ppp ipcp peer-address pool
              leaf pool {
                tailf:info "Name of peer-address pool to use";
                type string {
                  tailf:info "WORD;;Name of pool";
                }
              }
            }
          }

          // dynamic-template / type ppp * / ppp ipv6cp
          container ipv6cp {
            tailf:info "Set IPv6CP negotiation options";

            // dynamic-template / type ppp * / ppp ipv6cp passive
            leaf passive {
              tailf:info "Run IPv6CP in Passive mode";
              type empty;
            }

            // dynamic-template / type ppp * / ppp ipv6cp peer-interface-id
            leaf peer-interface-id {
              tailf:info "Specify the Interface-ID for the peer";
              type string {
                tailf:info "WORD;;64-bit Peer Interface-ID (hex value without leading 0x)";
              }
            }
          }
        }

        // dynamic-template / type ppp * / keepalive
        container keepalive {
          tailf:info "Set the keepalive interval, or disable keepalives";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          choice keepalive-choice {
            case values-case {
              leaf interval {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<10-180>;;Enable keepalives with this interval"
                    +" (default is 60 seconds for RP Subscriber, 120 seconds for LC Subscriber)";
                  range "10..180";
                }
              }
              leaf retry {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<1-255>;;Set the keepalive retry count (default is 5)";
                  range "1..255";
                }
              }
            }
            leaf disable {
              tailf:info "Disable keepalives";
              type empty;
            }
          }
        }

        // dynamic-template / type ppp * / service-policy *
        uses dynamic-template-service-policy-grouping;

        // dynamic-template / type ppp * / accounting aaa list *
        container accounting {
          tailf:info "Accounting Feature Config";
          container aaa {
            tailf:info "Accounting Feature AAA Config";
            list list {
              tailf:info "Accounting Method-list";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              tailf:cli-incomplete-command;
              key name;
              leaf name {
                type string {
                  tailf:info "WORD;;Preconfigured method-list name";
                }
              }
              leaf type {
                tailf:info "Type of accounting performed";
                type enumeration {
                  enum session {
                    tailf:info "Apply accounting to a session";
                  }
                }
              }
              leaf periodic-interval {
                tailf:info "Periodic accounting interval in minutes";
                tailf:cli-optional-in-sequence;
                type uint16 {
                  tailf:info "<1-65535>;;Enter value in minutes";
                  range "1..65535";
                }
              }
              leaf dual-stack-delay {
                tailf:info "Dual stack set delay wait";
                type uint8 {
                  tailf:info "<1-30>;;Enter value in seconds";
                  range "1..30";
                }
              }
            }
          }
        }

        // dynamic-template / type ppp * / vrf
        leaf vrf {
          tailf:info "Set VRF in which the interface operates";
          type string {
            tailf:info "WORD;;VRF name";
          }
        }

        // dynamic-template / type ppp * / ipv4
        container ipv4 {
          tailf:info "ipv4 subcommands";

          // dynamic-template / type ppp * / ipv4 mtu
          leaf mtu {
            tailf:info "Set IPv4 Maximum Transmission Unit";
            type uint16 {
              tailf:info "<68-65535>;;MTU (bytes)";
              range "68..65535";
            }
          }

          // dynamic-template / type ppp * / ipv4 verify unicast source reachable-via rx
          container verify {
            tailf:info "Enable per packet validation";
            container unicast {
              tailf:info "Enable per packet validation for unicast";
              container source {
                tailf:info "Validation of source address";
                leaf reachable-via {
                  tailf:info "Specify reachability check to apply to the source address";
                  type enumeration {
                    enum rx {
                      tailf:info "Source is reachable via interface on which packet was received";
                    }
                  }
                }
              }
            }
          }

          // dynamic-template / type ppp * / ipv4 unnumbered
          container unnumbered {
            tailf:info "Enable IPv4 processing without an explicit address";
            uses interface-name-grouping;
          }

          // dynamic-template / type ppp * / ipv4 unreachables disable
          container unreachables {
            tailf:info "Enable sending ICMP Unreachable messages";
            leaf disable {
              tailf:info "Suppress ICMPv4 Unreachable messages on subscriber interfaces";
              type empty;
            }
          }

          // dynamic-template / type ppp * / ipv4 access-group ? ingress
          // dynamic-template / type ppp * / ipv4 access-group ? egress
          list access-group {
            tailf:info "Specify access control for packets";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-remove-before-change;
            key direction;
            leaf direction {
              type enumeration {
                enum egress {
                  tailf:info "Filter outgoing packets";
                }
                enum ingress {
                  tailf:info "Filter incoming packets";
                }
              }
            }
            leaf name {
              tailf:cli-drop-node-name;
              tailf:cli-prefix-key;
              type string {
                tailf:info "WORD;;Access-list name";
              }
            }
          }
        }

        // dynamic-template / type ppp * / ipv6
        container ipv6 {
          tailf:info "ipv6 subcommands";

          // dynamic-template / type ppp * / ipv6 nd
          container nd {
            tailf:info "ipv6 Neighbor Discovery subcommands";

            // dynamic-template / type ppp * / ipv6 nd nud-enable
            leaf nud-enable {
              tailf:info "IPv6 Neighbor Unreachability Detection(NUD) configuration."
                +" Applies only to IPoe Sessions";
              type empty;
            }

            // dynamic-template / type ppp * / ipv6 nd ra-unicast
            leaf ra-unicast {
              tailf:info "IPv6 unicast RA enable configuration";
              type empty;
            }

            // dynamic-template / type ppp * / ipv6 nd ra-interval
            container ra-interval {
              tailf:info "Set IPv6 Router Advertisement(RA) Interval";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf maximum {
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<4-1800>;;Maximum RA Interval (sec)";
                  range "4..1800";
                }
              }
              leaf minimum {
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<3-1800>;;Minimum RA Interval (sec)";
                  range "3..1800";
                }
              }
            }

            // dynamic-template / type ppp * / ipv6 nd ra-lifetime
            leaf ra-lifetime {
              tailf:info "Set IPv6 Router Advertisement(RA) Lifetime";
              tailf:cli-full-command;
              type uint16 {
                tailf:info "<0-9000>;;RA Lifetime (seconds)";
                range "0..9000";
              }
            }

            // dynamic-template / type ppp * / ipv6 nd reachable-time
            leaf reachable-time {
              tailf:info "Set advertised reachability time";
              tailf:cli-full-command;
              type uint32 {
                tailf:info "<0-3600000>;;Reachability time in milliseconds";
                range "0..3600000";
              }
            }

            // dynamic-template / type ppp * / ipv6 nd other-config-flag
            leaf other-config-flag {
              tailf:info "Hosts should use stateful protocol for non-address config";
              tailf:cli-full-command;
              type empty;
            }

            // dynamic-template / type ppp * / ipv6 nd framed-prefix-pool
            leaf framed-prefix-pool {
              tailf:info "IPv6 Neighbor Discovery(ND) pool configuration";
              type string {
                tailf:info "WORD;;Name of framed address pool";
              }
            }

            // dynamic-template / type ppp * / ipv6 nd managed-config-flag
            leaf managed-config-flag {
              tailf:info "Hosts should use stateful protocol for address config";
              tailf:cli-full-command;
              type empty;
            }
          }

          // dynamic-template / type ppp * / ipv6 mtu
          leaf mtu {
            tailf:info "Set IPv6 Maximum Transmission Unit";
            type uint16 {
              tailf:info "<1280-65535>;;MTU (bytes)";
              range "1280..65535";
            }
          }

          // dynamic-template / type ppp * / ipv6 verify unicast source reachable-via rx
          container verify {
            tailf:info "Enable per packet validation";
            container unicast {
              tailf:info "Enable per packet validation for unicast";
              container source {
                tailf:info "Validation of source address";
                container reachable-via {
                  tailf:info "Specify reachability check to apply to the source address";
                  leaf rx {
                    tailf:info "Source is reachable via interface on which packet was received";
                    type empty;
                  }
                }
              }
            }
          }

          // dynamic-template / type ppp * / ipv6 enable
          leaf enable {
            tailf:info "Enable IPv6 on interface";
            type empty;
          }
        }

        // dynamic-template / type ppp * / dhcpv6
        container dhcpv6 {
          tailf:info "dhcpv6 subcommands";

          // dynamic-template / type ppp * / dhcpv6 address-pool
          leaf address-pool {
            tailf:info "Address-pool Configuration";
            type string {
              tailf:info "WORD;;Name of address pool";
            }
          }

          // dynamic-template / type ppp * / dhcpv6 delegated-prefix-pool
          leaf delegated-prefix-pool {
            tailf:info "Delegated-Prefix-pool Configuration";
            type string {
              tailf:info "WORD;;Name of delegated prefix pool";
            }
          }
        }

        // dynamic-template / type ppp * / multicast
        container multicast {
          tailf:info "multicast mode";

          // dynamic-template / type ppp * / multicast ipv4
          container ipv4 {
            tailf:info "IPv4 address family";
            choice functionality-choice {
              // dynamic-template / type ppp * / multicast ipv4 qos-correlation
              leaf qos-correlation {
                tailf:info "Enable QOS correlation functionality";
                type empty;
              }
              // dynamic-template / type ppp * / multicast ipv4 passive
              leaf passive {
                tailf:info "Enable forwarding functionality";
                type empty;
              }
            }
          }
        }
      }

      // dynamic-template / type service *
      list service {
        tailf:info "Service dynamic template type";
        tailf:cli-mode-name "config-dynamic-template-type";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Dynamic Template Name";
          }
        }

        // dynamic-template / type service * / service-policy *
        uses dynamic-template-service-policy-grouping;

        // dynamic-template / type service * / accounting aaa list *
        container accounting {
          tailf:info "Accounting Feature Config";
          container aaa {
            tailf:info "Accounting Feature AAA Config";
            list list {
              tailf:info "Accounting Method-list";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              tailf:cli-incomplete-command;
              key name;
              leaf name {
                type string {
                  tailf:info "WORD;;Preconfigured method-list name";
                }
              }
              leaf type {
                tailf:info "Type of accounting performed";
                type enumeration {
                  enum session {
                    tailf:info "Apply accounting to a session";
                  }
                  enum service {
                    tailf:info "Apply accounting to a service";
                  }
                }
              }
              leaf periodic-interval {
                tailf:info "Periodic accounting interval in minutes";
                tailf:cli-optional-in-sequence;
                type uint16 {
                  tailf:info "<1-65535>;;Enter value in minutes";
                  range "1..65535";
                }
              }
              leaf dual-stack-delay {
                tailf:info "Dual stack set delay wait";
                type uint8 {
                  tailf:info "<1-30>;;Enter value in seconds";
                  range "1..30";
                }
              }
            }
          }
        }

        // dynamic-template / type service * / ipv4
        container ipv4 {
          tailf:info "ipv4 subcommands";

          // dynamic-template / type service * / ipv4 access-group * ingress
          // dynamic-template / type service * / ipv4 access-group * egress
          list access-group {
            tailf:info "Specify access control for packets";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key direction;
            leaf direction {
              type enumeration {
                enum egress {
                  tailf:info "Filter outgoing packets";
                }
                enum ingress {
                  tailf:info "Filter incoming packets";
                }
              }
            }
            leaf name {
              tailf:cli-drop-node-name;
              tailf:cli-prefix-key;
              type string {
                tailf:info "WORD;;access-list name";
              }
            }
          }

          // dynamic-template / type service * / ipv4 unnumbered
          container unnumbered {
            tailf:info "Enable IPv4 processing without an explicit address";
            uses interface-name-grouping;
          }
        }

        // dynamic-template / type service * / ipv6
        container ipv6 {
          tailf:info "ipv6 subcommands";

          // dynamic-template / type service * / ipv6 access-group * ingress
          // dynamic-template / type service * / ipv6 access-group * egress
          list access-group {
            tailf:info "Specify access control for packets";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key direction;
            leaf direction {
              type enumeration {
                enum egress {
                  tailf:info "Filter outgoing packets";
                }
                enum ingress {
                  tailf:info "Filter incoming packets";
                }
              }
            }
            leaf name {
              tailf:cli-drop-node-name;
              tailf:cli-prefix-key;
              type string {
                tailf:info "WORD;;access-list name";
              }
            }
          }

          // dynamic-template / type service * / ipv6 enable
          leaf enable {
            tailf:info "Enable IPv6 on interface";
            type empty;
          }
        }
      }

      // dynamic-template / type ipsubscriber *
      list ipsubscriber {
        tailf:info "IP Subscriber dynamic template type";
        tailf:cli-mode-name "config-dynamic-template-type";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Dynamic Template Name";
          }
        }

        // dynamic-template / type ipsubscriber * / service-policy
        uses interface-service-policy-grouping;

        // dynamic-template / type ipsubscriber * / vrf
        leaf vrf {
          tailf:info "Set VRF in which the interface operate";
          type string {
            tailf:info "WORD;;VRF name";
          }
        }

        // dynamic-template / type ipsubscriber * / timeout idle
        container timeout {
          tailf:info "Subscriber Accounting Idle Timer Config";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf idle {
            tailf:info "Subscriber Accounting Idle Timer Config";
            type uint32 {
              tailf:info "<60-4320000>;;Idle timeout duration in seconds";
              range "60..4320000";
            }
          }
          leaf threshold {
            tailf:info "Configure threshold duration for idleness tracking";
            tailf:cli-optional-in-sequence;
            type uint16 {
              tailf:info "<1-10000>;;Duration of threshold in minute(s) per packet - should be less than idle duration";
              range "1..10000";
            }
          }
          leaf traffic {
            tailf:info "Traffic direction to consider while deriving idleness";
            type enumeration {
              enum both {
                tailf:info "Consider both inbound and outbound traffic while deriving idleness";
              }
              enum inbound {
                tailf:info "Consider Inbound traffic while deriving idleness(Default)";
              }
              enum outbound {
                tailf:info "Consider outbound traffic while deriving idleness";
              }
            }
          }
        }

        // dynamic-template / type ipsubscriber * / accounting aaa list *
        container accounting {
          tailf:info "Accounting Feature Config";
          container aaa {
            tailf:info "Accounting Feature AAA Config";
            list list {
              tailf:info "Accounting Method-list";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              tailf:cli-incomplete-command;
              key name;
              leaf name {
                type string {
                  tailf:info "WORD;;Preconfigured method-list name";
                }
              }
              leaf type {
                tailf:info "Type of accounting performed";
                type enumeration {
                  enum session {
                    tailf:info "Apply accounting to a session";
                  }
                }
              }
              leaf periodic-interval {
                tailf:info "Periodic accounting interval in minutes";
                tailf:cli-optional-in-sequence;
                type uint16 {
                  tailf:info "<1-65535>;;Enter value in minutes";
                  range "1..65535";
                }
              }
              leaf dual-stack-delay {
                tailf:info "Dual stack set delay wait";
                type uint8 {
                  tailf:info "<1-30>;;Enter value in seconds";
                  range "1..30";
                }
              }
            }
          }
        }

        // dynamic-template / type ipsubscriber * / ipv4
        container ipv4 {
          tailf:info "ipv4 subcommands";

          // dynamic-template / type ipsubscriber * / ipv4 verify unicast source reachable-via rx
          container verify {
            tailf:info "Enable per packet validation";
            container unicast {
              tailf:info "Enable per packet validation for unicast";
              container source {
                tailf:info "Validation of source address";
                container reachable-via {
                  tailf:info "Specify reachability check to apply to the source address";
                  leaf rx {
                    tailf:info "Source is reachable via interface on which packet was received";
                    type empty;
                  }
                }
              }
            }
          }

          // dynamic-template / type ipsubscriber * / ipv4 unnumbered
          container unnumbered {
            tailf:info "Enable IPv4 processing without an explicit address";
            uses interface-name-grouping;
          }

          // dynamic-template / type ipsubscriber * / ipv4 unreachables disable
          container unreachables {
            tailf:info "Enable sending ICMP Unreachable messages";
            leaf disable {
              tailf:info "Suppress ICMPv4 Unreachable messages on subscriber interfaces";
              type empty;
            }
          }

          // dynamic-template / type ipsubscriber * / ipv4 access-group ? egress
          // dynamic-template / type ipsubscriber * / ipv4 access-group ? ingress
          list access-group {
            tailf:info "Specify access control for packets";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key direction;
            leaf direction {
              type enumeration {
                enum egress {
                  tailf:info "Filter outgoing packets";
                }
                enum ingress {
                  tailf:info "Filter incoming packets";
                }
              }
            }
            leaf name {
              tailf:cli-drop-node-name;
              tailf:cli-prefix-key;
              type string {
                tailf:info "WORD;;access-list name";
              }
            }
          }
        }

        // dynamic-template / type ipsubscriber * / ipv6
        container ipv6 {
          tailf:info "ipv6 subcommands";

          // dynamic-template / type ipsubscriber * / ipv6 enable
          leaf enable {
            tailf:info "Enable IPv6 on interface";
            type empty;
          }

          // dynamic-template / type ipsubscriber * / ipv6 nd
          container nd {
            tailf:info "ipv6 Neighbor Discovery subcommands";

            // dynamic-template / type ipsubscriber * / ipv6 nd ra-initial
            container ra-initial {
              tailf:info "Set IPv6 Initial Router Advertisement(RA) Count and Interval";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf count {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<0-32>;;Initial number of Router Advertisements(RA)";
                  range "0..32";
                }
              }
              leaf interval {
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<4-1800>;;Initial Router Advertisement(RA) Interval (sec).";
                  range "4..1800";
                }
              }
            }

            // dynamic-template / type ipsubscriber * / ipv6 nd ra-interval
            leaf ra-interval {
              tailf:info "Set IPv6 Router Advertisement(RA) Interval";
              type uint16 {
                tailf:info "<4-1800>;;Maximum RA Interval (sec)";
                range "4..1800";
              }
            }

            // dynamic-template / type ipsubscriber * / ipv6 nd dad attempts
            container dad {
              tailf:info "Set number of Duplicate Address Detection(DAD) transmits";
              leaf attempts {
                tailf:info "Set IPv6 Duplicate Address Detection(DAD) Transmits";
                type uint16 {
                  tailf:info "<0-600>;;Number of attempts";
                  range "0..600";
                }
              }
            }

            // dynamic-template / type ipsubscriber * / ipv6 nd other-config-flag
            leaf other-config-flag {
              tailf:info "Hosts should use stateful protocol for non-address config";
              type empty;
            }

            // dynamic-template / type ipsubscriber * / ipv6 nd managed-config-flag
            leaf managed-config-flag {
              tailf:info "Hosts should use stateful protocol for address config";
              type empty;
            }
          }

          // dynamic-template / type ipsubscriber * / ipv6 access-group ? egress
          // dynamic-template / type ipsubscriber * / ipv6 access-group ? ingress
          list access-group {
            tailf:info "Specify access control for packets";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key direction;
            leaf direction {
              type enumeration {
                enum egress {
                  tailf:info "Filter outgoing packets";
                }
                enum ingress {
                  tailf:info "Filter incoming packets";
                }
              }
            }
            leaf name {
              tailf:cli-drop-node-name;
              tailf:cli-prefix-key;
              type string {
                tailf:info "WORD;;access-list name";
              }
            }
          }
        }

        // dynamic-template / type ipsubscriber * /  multicast ipv4 qos-correlation
        container multicast {
          tailf:info "multicast mode";
          container ipv4 {
            tailf:info "IPv4 address family";
            leaf qos-correlation {
              tailf:info "Enable QOS correlation functionality";
              type empty;
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// lawful-intercept
  /// ========================================================================

  // lawful-intercept disable
  container lawful-intercept {
    tailf:info "Global LI enable disable";
    leaf disable {
      tailf:info "disable LI feature";
      type empty;
    }
  }


  /// ========================================================================
  /// evpn
  /// ========================================================================

  uses evpn-config-grouping;

  grouping evpn-config-grouping {
    container evpn {
      tailf:info "Configure E-VPN commands";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-evpn";
      tailf:cli-explicit-exit;
      presence true;

      // evpn / apply-group
      uses apply-group-grouping;

      // evpn / ethernet-segment
      container ethernet-segment {
        tailf:info "Configure global ethernet-segment commands";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-evpn-es";
        tailf:cli-explicit-exit;
        presence true;

        // evpn / ethernet-segment / type 1 auto-generation-disable
        container type {
          tailf:info "ESI type";
          container one {
            tailf:alt-name "1";
            tailf:info "LACP ESI-auto-generation";
            leaf auto-generation-disable {
              tailf:info "Disable ESI auto-generation";
              type empty;
            }
          }
        }
      }

      // evpn / vni *
      list vni {
        tailf:info "Configure EVPN VNI";
        tailf:cli-mode-name "config-evpn-instance";
        key id;
        leaf id {
          type uint32 {
            tailf:info "<1-16777215>;;EVPN VNI value";
            range "1..16777215";
          }
        }
        leaf stitching {
          tailf:info "Treat EVPN Instance as Stitching side";
          tailf:cli-hide-in-submode;
          type empty;
        }

        // evpn / vni * / bgp
        container bgp {
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-evpn-instance-bgp";
          presence true;

          // evpn / vni * / bgp / rd
          // evpn / vni * / bgp / route-target
          uses evpn-bgp-grouping;
        }

        // evpn / vni * / advertise-mac
        container advertise-mac {
          tailf:info "Configure locally-learned MAC advertisement";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-evpn-instance-mac";
          presence true;

          // evpn / vni * / advertise-mac / bvi-mac
          leaf bvi-mac {
            tailf:info "Advertise local MAC and BVI MAC routes";
            type empty;
          }
        }
      }

      // evpn / evi *
      list evi {
        tailf:info "Configure Ethernet VPN ID(EVI)";
        tailf:cli-mode-name "config-evpn-evi";
        key id;
        leaf id {
          type uint16 {
            tailf:info "<1-65534>;;Ethernet VPN ID to set";
            range "1..65534";
          }
        }
        leaf stitching {
          tailf:info "Treat EVPN Instance as Stitching side";
          tailf:cli-hide-in-submode;
          type empty;
        }

        // evpn / evi * / bgp
        container bgp {
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-evpn-evi-bgp";
          presence true;

          // evpn / evi * / bgp / rd
          // evpn / evi * / bgp / route-target
          uses evpn-bgp-grouping;

          // evpn / evi * / bgp / route-policy
          container route-policy {
            tailf:info "Apply route policy";

            // evpn / evi * / bgp / route-policy export
            leaf export {
              tailf:info "Export route policy";
              tailf:cli-suppress-leafref-in-diff;
              tailf:non-strict-leafref {
                path "/cisco-ios-xr:route-policy/name";
              }
              type string {
                tailf:info "WORD;;Name of the policy";
              }
            }

            // evpn / evi * / bgp / route-policy import
            leaf import {
              tailf:info "Import route policy";
              tailf:cli-suppress-leafref-in-diff;
              tailf:non-strict-leafref {
                path "/cisco-ios-xr:route-policy/name";
              }
              type string {
                tailf:info "WORD;;Name of the policy";
              }
            }
          }
        }

        // evpn / evi * / description
        uses description-grouping;

        // evpn / evi * / etree
        container etree {
          tailf:info "Configure EVPN Instance E-Tree";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-evpn-instance-etree";
          tailf:cli-explicit-exit;
          presence true;

          // evpn / evi * / etree / leaf
          leaf leaf {
            tailf:info "Designate EVPN Instance as EVPN E-Tree Leaf Site";
            type empty;
          }

          // evpn / evi * / etree / rt-leaf
          leaf rt-leaf {
            tailf:info "Designate EVPN Instance as EVPN E-Tree Route-Target Leaf Site";
            type empty;
          }
        }

        // evpn / evi * / control-word-disable
        leaf control-word-disable {
          tailf:info "Disabling control-word";
          type empty;
        }

        // evpn / evi * / load-balancing
        container load-balancing {
          tailf:info "Configure EVPN Instance load-balancing";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-evpn-instance-lb";
          presence true;

          // evpn / evi * / load-balancing / flow-label static
          container flow-label {
            tailf:info "Flow Label load balancing";
            leaf static {
              tailf:info "Static configuration of Flow Label";
              type empty;
            }
          }
        }

        // evpn / evi * / ecmp-disable
        container ecmp-disable {
          tailf:info "Disable ECMP on this EVI (Active/Backup)";
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          presence true;
          // evpn / evi * / ecmp-disable nexthop-preference
          leaf nexthop-preference {
            tailf:info "Prefer active path based on nexthop IP";
            type enumeration {
              enum lowest-ip {
                tailf:info "Lowest nexthop IP is active";
              }
              enum highest-ip {
                tailf:info "Highest nexthop IP is active";
              }
            }
          }
        }

        // evpn / evi * / advertise-mac
        container advertise-mac {
          tailf:info "Advertise locally-learned MACs";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-evpn-instance-mac";
          tailf:cli-exit-command "!"; // XR 6.3 enters sub-mode, 6.1 does not
          presence true;

          // evpn / evi * / advertise-mac / bvi-mac
          leaf bvi-mac {
            tailf:info "Advertise local MAC and BVI MAC routes";
            type empty;
          }
        }

        // evpn / evi * / unknown-unicast-suppression
        leaf unknown-unicast-suppression {
          tailf:info "Enabling unknown unicast suppression";
          type empty;
        }

        // evpn / evi * / network-controller
        container network-controller {
          tailf:info "Configure EVPN Network Controller Settings";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-evpn-evi-nc";

          // evpn / evi * / network-controller / vni
          leaf vni {
            tailf:info "Layer 3 VXLAN VNI";
            type uint16 {
              tailf:info "<0-65535>;;Layer 3 VXLAN VNI";
              range "0..65535";
            }
          }

          // evpn / evi * / network-controller / host *
          list host {
            tailf:info "Host Configuration";
            tailf:cli-mode-name "config-evpn-evi-nc-host";
            key mac;
            leaf mac {
              tailf:info "Host MAC address";
              tailf:cli-expose-key-name;
              type string {
                tailf:info "H.H.H;;Host MAC address";
              }
            }
            leaf ip-address {
              tailf:info "Host IP Address";
              tailf:cli-hide-in-submode;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Host IP Address";
              }
            }

            // evpn / evi * / network-controller / host * / ipv4 address
            container ipv4 {
              tailf:info "IPv4 Address Family";
              leaf address {
                tailf:info "IPv4 Address of a host";
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IP Address for the host";
                }
              }
            }

            // evpn / evi * / network-controller / host * / switch
            leaf switch {
              tailf:info "Switch the host is connected to";
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IP Address of the Switch the host is connected to";
              }
            }

            // evpn / evi * / network-controller / host * / gateway
            container gateway {
              tailf:info "Gateway for the host";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf ip-address {
                tailf:cli-drop-node-name;
                type union {
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;Gateway IP Address for the host";
                  }
                  type inet:ipv4-prefix {
                    tailf:info "A.B.C.D/prefix;;Gateway IPv4 Address/prefix";
                  }
                }
              }
              leaf netmask {
                tailf:cli-drop-node-name;
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IP subnet mask";
                }
              }
            }

            // evpn / evi * / network-controller / host * / vlan
            leaf vlan {
              tailf:info "VLAN the host is on";
              type uint16 {
                tailf:info "<1-4094>;;VLAN the host is on";
                range "1..4094";
              }
            }
          }
        }

        // evpn / evi * / bvi-coupled-mode
        leaf bvi-coupled-mode {
          tailf:info "Couples BVI state to the core EVPN Instance state";
          type empty;
        }
      }

      // evpn / group *
      list group {
        tailf:info "Configure EVPN group";
        tailf:cli-mode-name "config-evpn-group";
        key id;
        leaf id {
          type uint32 {
            tailf:info "<1-4294967295>;;EVPN group ID number";
            range "1..4294967295";
          }
        }

        // evpn / group * / core interface *
        container core {
          tailf:info "configure EVPN group core interface";
          list interface {
            tailf:info "configure EVPN group core interface";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;Interface Name";
              }
            }
          }
        }
      }

      // evpn / logging
      container logging {
        tailf:info "Configure evpn logging commands";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-evpn-log";
        tailf:cli-explicit-exit;
        presence true;

        // evpn / logging / df-election
        leaf df-election {
          tailf:info "Enable Designated Forwarder election logging";
          type empty;
        }
      }

      // evpn / timers
      uses evpn-timers-grouping;

      // evpn / interface *
      list interface {
        tailf:info "Assign interface to EVPN";
        tailf:cli-mode-name "config-evpn-ac";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Interface Name";
          }
        }

        // evpn / interface * / ethernet-segment
        container ethernet-segment {
          tailf:info "Ethernet Segment configuration commands";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-evpn-ac-es";

          // evpn / interface * / ethernet-segment / identifier type 0
          container identifier {
            tailf:info "Ethernet Segment identifier (ESI)";
            list type {
              tailf:info "ESI Type";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-incomplete-command;
              key esi-type;
              leaf esi-type {
                type enumeration {
                  enum "0" {
                    tailf:info "Type 0 (arbitrary 9-octet ESI value)";
                  }
                }
              }
              leaf esi-identifier  {
                tailf:cli-drop-node-name;
                type string {
                  tailf:info "<0-ff>.;;9-octet ESI value";
                }
              }
            }
          }

          // evpn / interface * / ethernet-segment / service-carving manual
          container service-carving {
            tailf:info "Specify service carving";
            container manual {
              tailf:info "Manually specify i-sid/evi-list services";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-evpn-ac-es-vlan-man";
              presence true;
              container services-lists {
                tailf:cli-drop-node-name;
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                leaf primary {
                  tailf:info "Primary services list";
                  tailf:cli-incomplete-command;
                  type string {
                    tailf:info "WORD;;Primary services list notation: '256,356-400,410'";
                  }
                }
                leaf secondary {
                  tailf:info "Secondary services list";
                  type string {
                    tailf:info "WORD;;Secondary services list notation: '256,356-400,410'";
                  }
                }
              }
            }
          }

          // evpn / interface * / ethernet-segment / bgp route-target
          container bgp {
            tailf:info "Configure BGP";
            leaf route-target {
              tailf:info "Set ES-Import Route Target";
              type string {
                tailf:info "H.H.H;;Route Target value (6-octet)";
              }
            }
          }

          // evpn / interface * / ethernet-segment / load-balancing-mode
          container load-balancing-mode {
            tailf:info "Specify load balancing mode";
            choice mode-choice {
              leaf single-active {
                tailf:info "Single-Active load balancing";
                type empty;
              }
              leaf port-active {
                tailf:info "Port-Active load balancing";
                type empty;
              }
              leaf single-flow-active {
                tailf:info "Single-Flow-Active load balancing";
                type empty;
              }
            }
          }
        }

        // evpn / interface * / core-isolation-group
        leaf core-isolation-group {
          tailf:info "Core isolation group";
          type uint32 {
            tailf:info "<1-4294967295>;;EVPN group ID number";
            range "1..4294967295";
          }
        }

        // evpn / interface * / timers
        uses evpn-timers-grouping;
      }

      // evpn / virtual neighbor * pw-id *
      container virtual {
        tailf:info "Virtual Access Segment to EVPN";

        // evpn / virtual neighbor * pw-id *
        list neighbor {
          tailf:info "Specify the peer to cross connect";
          tailf:cli-mode-name "config-evpn-ac-pw";
          key "address pw-id";
          leaf address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IPv4 address of the peer";
            }
          }
          leaf pw-id {
            tailf:info "Specify the pseudowire id";
            tailf:cli-expose-key-name;
            type uint32 {
              tailf:info "<1-4294967295>;;Pseudowire ID";
              range "1..4294967295";
            }
          }
          uses evpn-virtual-grouping;
        }

        // evpn / virtual vfi *
        list vfi {
          tailf:info "Specify the virtual forwarding interface name";
          tailf:cli-mode-name "config-evpn-ac-vfi";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Name of the Virtual Forwarding Interface";
            }
          }
          uses evpn-virtual-grouping;
        }
      }

      // evpn / source interface Loopback
      container source {
        tailf:info "Configure EVPN source interface";
        container interface {
          tailf:info "Configure EVPN router-id implicitly through Loopback Interface";
          leaf Loopback {
            tailf:info "Loopback interface";
            tailf:cli-allow-join-with-value {
              tailf:cli-display-joined;
            }
            tailf:cli-suppress-leafref-in-diff;
            tailf:non-strict-leafref {
              path "/cisco-ios-xr:interface/Loopback/id";
            }
            type uint32 {
              tailf:info "<0-2147483647>";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// l2vpn
  /// ========================================================================

  container l2vpn {
    tailf:info "Configure l2vpn commands";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-l2vpn";
    tailf:cli-explicit-exit;
    presence true;

    // l2vpn / router-id
    leaf router-id {
      tailf:info "Global L2VPN Router ID";
      tailf:cli-full-command;
      type inet:ipv4-address {
        tailf:info "A.B.C.D;;IP Address";
      }
    }

    // l2vpn / description
    leaf description {
      tailf:info "Multi segment psedowire global description";
      type string {
        tailf:info "WORD;;l2vpn global description string - maximum 64 characters";
      }
    }

    // l2vpn / nsr
    leaf nsr {
      tailf:info "Configure Non-Stop Routing";
      tailf:cli-full-command;
      type empty;
    }

    // l2vpn / pw-grouping
    leaf pw-grouping {
      tailf:info "Enable PW-Grouping";
      tailf:cli-full-command;
      type empty;
    }

    // l2vpn / pw-status
    container pw-status {
      tailf:info "Configure PW status";
      tailf:cli-delete-when-empty;
      presence true;
      leaf disable {
        tailf:info "Disable PW status";
        type empty;
      }
    }

    // l2vpn / autodiscovery bgp
    container autodiscovery {
      tailf:info "Configure global auto-discovery attributes";
      container bgp {
        tailf:info "auto discovery type bgp";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-l2vpn-ad";

        // l2vpn / autodiscovery bgp / signaling-protocol bgp
        container signaling-protocol {
          tailf:info "Configure global signaling protocol attributes";
          container bgp {
            tailf:info "signaling protocol type bgp";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-l2vpn-ad-sig";

            // l2vpn / autodiscovery bgp /signaling-protocol bgp / mtu mismatch ignore
            container mtu {
              tailf:info "mtu";
              container mismatch {
                tailf:info "mtu mismatch";
                leaf ignore {
                  tailf:info "Ignore MTU mismatch for auto-discovered PWs";
                  type empty;
                }
              }
            }
          }
        }
      }
    }

    // l2vpn / logging
    container logging {
      tailf:info "Configure l2vpn logging commands";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-l2vpn-log";
      tailf:cli-delete-when-empty;
      presence true;

      // l2vpn / logging / nsr
      leaf nsr {
        tailf:info "Enable Non-Stop Routing logging";
        tailf:cli-full-command;
        type empty;
      }

      // l2vpn / logging / pseudowire
      container pseudowire {
        tailf:info "Enable pseudowire logging";
        tailf:cli-delete-when-empty;
        presence true;
        leaf status {
          type empty;
        }
      }

      // l2vpn / logging / bridge-domain
      leaf bridge-domain {
        tailf:info "Enable bridge-domain logging";
        type empty;
      }

      // l2vpn / logging / vfi
      leaf vfi {
        tailf:info "Enable VFI logging";
        type empty;
      }
    }

    // l2vpn / load-balancing
    container load-balancing {
      tailf:info "Global L2VPN Load Balancing";
      leaf flow {
        tailf:info "Enable Flow based load balancing";
        type enumeration {
          enum src-dst-ip {
            tailf:info "Use source and destination IP addresses for hashing";
          }
          enum src-dst-mac {
            tailf:info "Use source and destination MAC addresses for hashing";
          }
        }
      }
    }

    // l2vpn / capability
    leaf capability {
      tailf:info "Global capability mode";
      tailf:cli-full-command;
      type enumeration {
        enum high-mode {
          tailf:info "Compute global capability as the highest node capability";
        }
        enum single-mode {
          tailf:info "Disable global capability re-computation";
        }
      }
    }

    // l2vpn / ignore-mtu-mismatch
    leaf ignore-mtu-mismatch {
      tailf:info "Ignore MTU mismatch for all L2VPN(cisco-support)";
      tailf:cli-full-command;
      type empty;
    }

    // l2vpn / ignore-mtu-mismatch-ad
    leaf ignore-mtu-mismatch-ad {
      tailf:info "Ignore MTU mismatch for auto-discovered PWs(cisco-support)";
      type empty;
    }

    // l2vpn / redundancy
    container redundancy {
      tailf:info "Redundancy";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-l2vpn-red";
      presence true;

      // l2vpn / redundancy / iccp group *
      container iccp {
        tailf:info "Inter-Chassis Communication Protocol";
        list group {
          tailf:info "Group configuration";
          tailf:cli-mode-name "config-l2vpn-red-grp";
          key id;
          leaf id {
            type uint32 {
              tailf:info "<1-4294967295>;;Enter group number";
            }
          }

          // l2vpn / redundancy / iccp group * / multi-homing node-id
          container multi-homing {
            tailf:info "ICCP-based service multi-homing";
            leaf node-id {
              tailf:info "Enter multi-homing node ID";
              type uint8 {
                tailf:info "<0-254>;;Node ID";
                range "0..254";
              }
            }
          }

          // l2vpn / redundancy / iccp group * / interface *
          list interface {
            tailf:info "Interface name";
            tailf:cli-mode-name "config-l2vpn-red-grp-intf";
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;Interface Name";
              }
            }

            // l2vpn / redundancy / iccp group * / interface * / primary vlan
            container primary {
              tailf:info "Primary VLAN configuration";
              leaf-list vlan {
                tailf:info "Assign primary VLANs";
                tailf:cli-range-list-syntax;
                tailf:cli-replace-all;
                type uint16 {
                  tailf:info "WORD;;List of VLAN IDs in the form of 1-3,5,8-11";
                  range "1..4094";
                }
              }
            }

            // l2vpn / redundancy / iccp group * / interface * / secondary vlan
            container secondary {
              tailf:info "Secondary VLAN configuration";
              leaf-list vlan {
                tailf:info "Assign secondary VLANs";
                tailf:cli-range-list-syntax;
                tailf:cli-replace-all;
                type uint16 {
                  tailf:info "WORD;;List of VLAN IDs in the form of 1-3,5,8-11";
                  range "1..4094";
                }
              }
            }

            // l2vpn / redundancy / iccp group * / interface * / recovery delay
            container recovery {
              tailf:info "Failure recovery reversion delay timer. Default is revertive after 180 seconds.";
              leaf delay {
                tailf:info "Specify delay before recovery reversion after failure clears";
                type uint16 {
                  tailf:info "<30-3600>;;input time in seconds";
                  range "30..3600";
                }
              }
            }
          }
        }
      }
    }

    // l2vpn / ethernet ring g8032 *
    container ethernet {
      tailf:info "Ethernet";
      container ring {
        tailf:info "Ring";
        list g8032 {
          tailf:info "Specify the g.8032 ethernet ring";
          tailf:cli-mode-name "config-l2vpn-erp";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Name of the ethernet ring";
            }
          }

          // l2vpn / ethernet ring g8032 * / port0 interface *
          container port0 {
            tailf:info "Port0 of the local node connected to G.8032 ring";
            list interface {
              tailf:info "Assign interface as port0";
              tailf:cli-mode-name "config-l2vpn-erp-port0";
              key name;
              leaf name {
                type string {
                  tailf:info "WORD;;Interface Name";
                }
              }

              // l2vpn / ethernet ring g8032 * / port0 interface * / monitor interface
              container monitor {
                tailf:info "Assign the monitor interface for g.8032 ring port0";
                container interface {
                  tailf:info "Assign the monitor interface";
                  uses interface-name-grouping;
                }
              }
            }
          }

          // l2vpn / ethernet ring g8032 * / port1
          container port1 {
            tailf:info "Port1 of the local node connected to G.8032 ring";

            // l2vpn / ethernet ring g8032 * / port1 interface *
            list interface {
              tailf:info "Assign interface as port1";
              tailf:cli-mode-name "config-l2vpn-erp-port1";
              key name;
              leaf name {
                type string {
                  tailf:info "WORD;;Interface Name";
                }
              }

              // l2vpn / ethernet ring g8032 * / port1 interface * / monitor interface
              container monitor {
                tailf:info "Assign the monitor interface for g.8032 ring port1";
                container interface {
                  tailf:info "Assign the monitor interface";
                  uses interface-name-grouping;
                }
              }
            }

            // l2vpn / ethernet ring g8032 * / port1 none
            leaf none {
              tailf:info "Assign port1 as none to enable g.8032 open-ring";
              type empty;
            }
          }

          // l2vpn / ethernet ring g8032 * / open-ring
          leaf open-ring {
            tailf:info "Specify the g.8032 ring as open ring";
            type empty;
          }

          // l2vpn / ethernet ring g8032 * / instance *
          list instance {
            tailf:info "Configure the g.8032 ethernet ring instance";
            tailf:cli-mode-name "config-l2vpn-erp-instance";
            key id;
            leaf id {
              type uint8 {
                tailf:info "<1-2>;;Instance number";
                range "1..2";
              }
            }

            // l2vpn / ethernet ring g8032 * / instance * / profile
            leaf profile {
              tailf:info "Specify associated g.8032 ethernet ring profile";
              type string {
                tailf:info "WORD;;Ethernet ring profile name";
              }
            }

            // l2vpn / ethernet ring g8032 * / instance * / inclusion-list vlan-ids
            container inclusion-list {
              tailf:info "Specifiy inclusion list protected by ERP";
              leaf vlan-ids {
                tailf:info "Associates a set of VLAN IDs with the current instance";
                type string {
                  tailf:info "WORD;;List of VLAN IDs in the form a-b,c,d,e-f,g,untagged";
                }
              }
            }

            // l2vpn / ethernet ring g8032 * / instance * / aps-channel
            container aps-channel {
              tailf:info "Configure g.8032 instance aps-channel";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-l2vpn-erp-instance-aps";
              presence true;

              // l2vpn / ethernet ring g8032 * / instance * / aps-channel / level
              leaf level {
                tailf:info "Specify the aps message level";
                type uint8 {
                  tailf:info "<0-7>;;APS message level";
                  range "0..7";
                }
              }

              // l2vpn / ethernet ring g8032 * / instance * / aps-channel / port0 interface
              container port0 {
                tailf:info "Config g.8032 aps-channel info associated to port0";
                container interface {
                  tailf:info "Assign interface associated to port0";
                  uses interface-name-grouping;
                }
              }

              // l2vpn / ethernet ring g8032 * / instance * / aps-channel / port1
              container port1 {
                tailf:info "Config g.8032 aps-channel info associated to port1";

                // l2vpn / ethernet ring g8032 * / instance * / aps-channel / port1 interface
                container interface {
                  tailf:info "Assign interface associated to port1";
                  uses interface-name-grouping;
                }

                // l2vpn / ethernet ring g8032 * / instance * / aps-channel / port1 none
                leaf none {
                  tailf:info "Specify APS channel port1 as none";
                  type empty;
                }
              }
            }

            // l2vpn / ethernet ring g8032 * / instance * / rpl
            container rpl {
              tailf:info "Specify RPL owner, neighbor or next-neighbor";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              leaf port {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type enumeration {
                  enum port0 {
                    tailf:info "Assign port0 as RPL owner, neighbor or next-neighbor";
                  }
                  enum port1 {
                    tailf:info "Assign port1 as RPL owner, neighbor or next-neighbor";
                  }
                }
              }
              leaf mode {
                tailf:cli-drop-node-name;
                type enumeration {
                  enum neighbor {
                    tailf:info "RPL neighbor";
                  }
                  enum next-neighbor {
                    tailf:info "RPL next neighbor";
                  }
                  enum owner {
                    tailf:info "RPL owner";
                  }
                }
              }
            }
          }
        }
      }
    }

    // l2vpn / pw-class *
    list pw-class {
      tailf:info "Pseudowire class template";
      tailf:cli-mode-name "config-l2vpn-pwc";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Pseudowire-class name";
        }
      }

      // l2vpn / pw-class * / encapsulation
      container encapsulation {
        tailf:info "Pseudowire encapsulation";

        // l2vpn / pw-class * / encapsulation l2tpv3
        container l2tpv3 {
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-l2vpn-pwc-l2tpv3";
          presence true;

          // l2vpn / pw-class * / encapsulation l2tpv3 / protocol l2tpv3
          leaf protocol {
            tailf:info "Set the dynamic pseudowire signaling protocol";
            type enumeration {
              enum l2tpv3 {
                tailf:info "Set L2TPv3 as the signaling protocol for this pseudowire class";
              }
            }
          }
          // l2vpn / pw-class * / encapsulation l2tpv3 / ttl
          leaf ttl {
            tailf:info "Set the Time To Live (TTL)";
            type uint8 {
              tailf:info "<1-255>;;TTL value";
              range "1..255";
            }
          }
        }

        // l2vpn / pw-class * / encapsulation mpls
        container mpls {
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-l2vpn-pwc-mpls";
          presence true;

          // l2vpn / pw-class * / encapsulation mpls / protocol ldp
          container protocol {
            tailf:info "Set the dynamic pseudowire signaling protocol";
            leaf ldp {
              tailf:info "Set LDP as the signaling protocol for this pseudowire class";
              type empty;
            }
          }

          // l2vpn / pw-class * / encapsulation mpls / control-word
          leaf control-word {
            tailf:info "Enable Control word";
            type empty;
          }

          // l2vpn / pw-class * / encapsulation mpls / vccv
          container vccv {
            tailf:info "VCCV settings";
            container verification-type {
              tailf:info "Enable or disable VCCV verification type";
              leaf none {
                tailf:info "No VCCV verification";
                type empty;
              }
            }
          }

          // l2vpn / pw-class * / encapsulation mpls / transport-mode
          container transport-mode {
            tailf:info "Remote transport mode";
            choice transport-mode-choice {
              leaf ethernet {
                tailf:info "Ethernet port mode";
                type empty;
              }
              container vlan {
                tailf:info "Vlan tagged mode";
                tailf:cli-delete-when-empty;
                presence true;
                leaf passthrough {
                  tailf:info "passthrough incoming tags";
                  type empty;
                }
              }
            }
          }

          // l2vpn / pw-class * / encapsulation mpls / load-balancing
          container load-balancing {
            tailf:info "PW class Load Balancing";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-l2vpn-pwc-mpls-load-bal";

            // l2vpn / pw-class * / encapsulation mpls / load-balancing / pw-label
            leaf pw-label {
              tailf:info "Enable PW VC label based load balancing";
              type empty;
            }

            // l2vpn / pw-class * / encapsulation mpls / load-balancing / flow-label
            container flow-label {
              tailf:info "Flow label based load balancing setting";

              // l2vpn / pw-class * / encapsulation mpls / load-balancing / flow-label both
              container both {
                tailf:info "Insert/Discard Flow label on transmit/recceive";
                tailf:cli-delete-when-empty;
                tailf:cli-reset-container;
                presence true;
                leaf static {
                  tailf:info "Set Flow label parameters statically";
                  type empty;
                }
              }

              // l2vpn / pw-class * / encapsulation mpls / load-balancing / flow-label code
              container code {
                tailf:info "Flow label TLV code";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                leaf value {
                  tailf:cli-drop-node-name;
                  type enumeration {
                    enum 17 {
                      tailf:info "Legacy code value";
                    }
                  }
                }
                leaf disable {
                  tailf:info "Disables sending code 17 TLV";
                  type empty;
                }
              }
            }
          }

          // l2vpn / pw-class * / encapsulation mpls / preferred-path
          container preferred-path {
            tailf:info "Preferred path tunnel settings";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            choice preferred-path-choice {

              // l2vpn / pw-class * / encapsulation mpls / preferred-path interface
              case interface {
                leaf interface {
                  tailf:info "Use tunnel interface for preferred path";
                  tailf:cli-incomplete-command;
                  type enumeration {
                    enum tunnel-ip {
                      tailf:info "Specify IP tunnel interface name for preferred path";
                    }
                    enum tunnel-te {
                      tailf:info "Specify TE tunnel interface name for preferred path";
                    }
                    enum tunnel-tp {
                      tailf:info "Specify TP tunnel interface name for preferred path";
                    }
                  }
                }
                leaf id {
                  tailf:cli-drop-node-name;
                  type uint16 {
                    tailf:info "<0-65535>;;Specify tunnel number for preferred path";
                  }
                }
                leaf fallback {
                  tailf:info "Fallback option for preferred path";
                  type enumeration {
                    enum disable {
                      tailf:info "Disable fallback for preferred path";
                    }
                  }
                }
              }

              // l2vpn / pw-class * / encapsulation mpls / preferred-path sr-te
              container sr-te {
                tailf:info "Use segment-routing traffic-engineering for preferred path";
                tailf:cli-flatten-container;
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                leaf policy {
                  tailf:info "Specify SR TE policy for preferred path";
                  type string {
                    tailf:info "WORD;;Name of SR TE policy";
                  }
                }
                leaf fallback {
                  tailf:info "Fallback option for preferred path";
                  type enumeration {
                    enum disable {
                      tailf:info "Disable fallback for preferred path";
                    }
                  }
                }
              }
            }
          }

          // l2vpn / pw-class * / encapsulation mpls / ipv4 source
          container ipv4 {
            tailf:info "Set the local source IPv4 address";
            leaf source {
              tailf:info "The local source IPv4 address";
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;The source address";
              }
            }
          }

          // l2vpn / pw-class * / encapsulation mpls / redundancy
          container redundancy {
            tailf:info "PW redundancy settings";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-l2vpn-pwc-mpls-pw";

            // l2vpn / pw-class * / encapsulation mpls / redundancy / one-way
            leaf one-way {
              tailf:info "Force one-way PW redundancy behavior in Redundancy Group";
              type empty;
            }

            // l2vpn / pw-class * / encapsulation mpls / redundancy / initial-delay
            leaf initial-delay {
              tailf:info "Initial delay before activating the redundant PW";
              type uint8 {
                tailf:info "<0-120>;;Time in seconds (round to 10). The default is 60";
                range "0..120";
              }
            }
          }
        }
      }

      // l2vpn / pw-class * / backup disable
      container backup {
        tailf:info "Pseudowire backup";
        container disable {
          tailf:info "Disable backup when primary comes back up";
          choice disable-choice {
            leaf delay {
              tailf:info "Disable backup after a specified delay";
              type uint8 {
                tailf:info "<0-180>;;Delay in seconds";
                range "0..180";
              }
            }
            leaf never {
              tailf:info "Never disable backup";
              type empty;
            }
          }
        }
      }
    }

    // l2vpn / flexible-xconnect-service
    container flexible-xconnect-service {
      tailf:info "Configure flexible-xconnect-service";

      // l2vpn / flexible-xconnect-service vlan-aware evi *
      list vlan-aware {
        tailf:info "Configure in vlan-aware mode";
        tailf:cli-mode-name "config-l2vpn-fxs-va";
        key evi;
        leaf evi {
          tailf:info "Ethernet VPN Identifier";
          tailf:cli-expose-key-name;
          type uint16 {
            tailf:info "<1-65534>;;Ethernet VPN ID to set";
            range "1..65534";
          }
        }

        // l2vpn / flexible-xconnect-service vlan-aware evi * / interface *
        list interface {
          tailf:info "Specify the attachment circuit";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Interface Name";
            }
          }
        }
      }
      // l2vpn / flexible-xconnect-service vlan-unaware *
      list vlan-unaware {
        tailf:info "Configure in vlan-unaware mode";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of the flexible-xconnect-service";
          }
        }
        // l2vpn / flexible-xconnect-service vlan-unaware * / interface *
        list interface {
          tailf:info "Specify the attachment circuit";
          tailf:cli-suppress-mode;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Interface Name";
            }
          }
        }
        // l2vpn / flexible-xconnect-service vlan-unaware * / neighbor
        container neighbor {
          tailf:info "Specify the peer to cross connect";
          container evpn {
            tailf:info "Specify the Ethernet VPN";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf evi {
              tailf:info "Ethernet VPN Identifier";
              tailf:cli-incomplete-command;
              tailf:cli-remove-before-change;
              type uint16 {
                tailf:info "<1-65534>  Ethernet VPN ID to set";
              }
            }
            leaf target {
              tailf:info "Specify remote attachment circuit identifier";
              type uint32 {
                tailf:info "<1-16777215>;;Remote ac-id (hex or decimal format)";
              }
            }
          }
        }
      }

    }

    // l2vpn / xconnect
    container xconnect {
      tailf:info "Configure cross connect commands";

      // l2vpn / xconnect group *
      list group {
        tailf:info "Specify the group the cross connects belong to";
        tailf:cli-mode-name "config-l2vpn-xc";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of the cross connects group";
          }
        }

        // l2vpn / xconnect group * / mp2mp *
        list mp2mp {
          tailf:info "Specify the MP2MP instance name";
          tailf:cli-mode-name "config-l2vpn-xc-mp2mp";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Name of the MP2MP instance";
            }
          }

          // l2vpn / xconnect group * / mp2mp * / vpn-id
          leaf vpn-id {
            tailf:info "VPN Identifier (VPN ID)";
            type uint32 {
              tailf:info "<1-4294967295>;;Value of the VPN ID";
              range "1..4294967295";
            }
          }

          // l2vpn / xconnect group * / mp2mp * / mtu
          leaf mtu {
            tailf:info "Set maximum transmission unit (payload) for this VPN MP2MP Instance";
            type uint32 {
              tailf:info "<64-4294967295>;;Value of the MTU";
              range "64..4294967295";
            }
          }

          // l2vpn / xconnect group * / mp2mp * / l2-encapsulation
          leaf l2-encapsulation {
            tailf:info "Configure the L2 encapsulation for this L2VPN MP2MP Instance";
            type enumeration {
              enum ethernet {
                tailf:info "Ethernet encapsulation";
              }
              enum vlan {
                tailf:info "Ethernet VLAN encapsulation";
              }
            }
          }

          // l2vpn / xconnect group * / mp2mp * / control-word
          container control-word {
            tailf:info "Set control-word option for this VPN MP2MP Instance";
            leaf disable {
              tailf:info "Disable control-word";
              type empty;
            }
          }

          // l2vpn / xconnect group * / mp2mp * / autodiscovery bgp
          container autodiscovery {
            tailf:info "Enable auto-discovery in this MP2MP";
            container bgp {
              tailf:info "Enable BGP auto-discovery in this MP2MP";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-l2vpn-xc-mp2mp-ad";
              presence true;

              // l2vpn / xconnect group * / mp2mp * / auto-discovery bgp / rd
              leaf rd {
                tailf:info "route distinguisher";
                type string {
                  tailf:info "WORD;;AS-number, IPv4 address:index or 'auto'";
                }
              }

              // l2vpn / xconnect group * / mp2mp * / auto-discovery bgp / route-target
              uses route-target-import-export-grouping;

              // l2vpn / xconnect group * / mp2mp * / auto-discovery bgp / signaling-protocol bgp
              container signaling-protocol {
                tailf:info "Enable signaling protocol in this MP2MP";
                container bgp {
                  tailf:info "Enable BGP signaling protocol this MP2MP";
                  tailf:cli-add-mode;
                  tailf:cli-mode-name "config-l2vpn-xc-mp2mp-ad-sig";
                  presence true;

                  // l2vpn / xconnect group * / mp2mp * / auto-discovery bgp / signaling-protocol bgp / ce-id *
                  list ce-id {
                    tailf:cli-mode-name "config-l2vpn-xc-mp2mp-ad-sig-ce";
                    key id;
                    leaf id {
                      type uint16 {
                        tailf:info "<1-16384>;;Value of the local CE ID";
                        range "1..16384";
                      }
                    }

                    // l2vpn / xconnect group * / mp2mp * / auto-discovery bgp / signaling-protocol bgp / ce-id * / interface * remote-ce-id
                    list interface {
                      tailf:info "Specify the attachment circuit";
                      tailf:cli-suppress-mode;
                      tailf:cli-delete-when-empty;
                      tailf:cli-incomplete-command;
                      key name;
                      leaf name {
                        type string {
                          tailf:info "WORD;;Interface Name";
                        }
                      }
                      leaf remote-ce-id {
                        tailf:info "Remote Customer Edge Identifier";
                        type uint16 {
                          tailf:info "<1-16384>;;Value of the remote CE ID";
                          range "1..16384";
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }

        // l2vpn / xconnect group * / p2p *
        list p2p {
          tailf:info "Configure point to point cross connect commands";
          tailf:cli-mode-name "config-l2vpn-xc-p2p";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Name of the point to point cross connect";
            }
          }

          // l2vpn / xconnect group * / p2p * / interface
          list interface {
            tailf:info "Specify the attachment circuit";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;Interface Name";
              }
            }
          }

          // l2vpn / xconnect group * / p2p * / monitor-session
          leaf monitor-session {
            tailf:info "Specify the monitor session";
            tailf:cli-suppress-leafref-in-diff;
            tailf:non-strict-leafref {
              path "/cisco-ios-xr:monitor-session/name";
            }
            type string {
              tailf:info "WORD;;Name of the monitor session";
            }
          }

          // l2vpn / xconnect group * / p2p * / neighbor ipv4 *
          // l2vpn / xconnect group * / p2p * / neighbor ipv6 *
          list neighbor {
            tailf:info "Specify the peer to cross connect";
            tailf:cli-mode-name "config-l2vpn-xc-p2p-pw";
            key "address pw-id";
            leaf address {
              type string {
                tailf:info "IP address of the peer";
              }
            }
            leaf pw-id {
              tailf:info "Specify the pseudowire id";
              tailf:cli-expose-key-name;
              type uint32 {
                tailf:info "<1-4294967295>;;Pseudowire ID";
              }
            }
            leaf ip-version {
              tailf:cli-drop-node-name;
              tailf:cli-prefix-key;
              type enumeration {
                enum ipv4 {
                  tailf:info "Specify IPv4 address or hostname";
                }
                enum ipv6 {
                  tailf:info "Specify IPv6 address or host name";
                }
              }
            }

            // l2vpn / xconnect group * / p2p * / neighbor * / mpls
            container mpls {
              tailf:info "MPLS L2VPN PW command";
              container static {
                tailf:info "MPLS L2VPN static settings";
                container label {
                  tailf:info "MPLS L2VPN static labels";
                  tailf:cli-compact-syntax;
                  tailf:cli-sequence-commands {
                    tailf:cli-reset-siblings;
                  }
                  leaf local {
                    tailf:info "Local pseudowire label";
                    tailf:cli-incomplete-command;
                    type uint32 {
                      tailf:info "<16-1048575>;;Local pseudowire label";
                      range "16..1048575";
                    }
                  }
                  leaf remote {
                    tailf:info "Remote pseudowire label";
                    type uint32 {
                      tailf:info "<16-1048575>;;Remote pseudowire label";
                      range "16..1048575";
                    }
                  }
                }
              }
            }

            // l2vpn / xconnect group * / p2p * / neighbor * / pw-class
            leaf pw-class {
              tailf:info "PW class template name to use for this XC";
              tailf:cli-full-command;
              type string {
                tailf:info "WORD;;Pseudowire-class name";
              }
            }

            // l2vpn / xconnect group * / p2p * / neighbor * / tag-impose
            container tag-impose {
              tailf:info "tag impose mode";
              leaf vlan {
                tailf:info "vlan tagged mode";
                type uint16 {
                  tailf:info "<1-4094>;;vlan tagged mode";
                  range "1..4094";
                }
              }
            }

            // l2vpn / xconnect group * / p2p * / neighbor * / l2tp
            container l2tp {
              tailf:info "L2TP PW";
              container static {
                tailf:info "L2TP PW static";
                tailf:cli-add-mode;
                tailf:cli-mode-name "config-l2vpn-xc-p2p-pw-l2tp";
                presence true;

                // l2vpn / xconnect group * / p2p * / neighbor * / l2tp / local cookie
                container local {
                  tailf:info "L2TP PW static local";
                  container cookie {
                    tailf:info "L2TP PW static local cookie settings";
                    tailf:cli-flatten-container;
                    tailf:cli-compact-syntax;
                    tailf:cli-sequence-commands {
                      tailf:cli-reset-siblings;
                    }
                    leaf size {
                      tailf:info "L2TP PW static local cookie size settings";
                      type enumeration {
                        enum 0 {
                          tailf:info "The cookie size is zero bytes";
                        }
                        enum 4 {
                          tailf:info "The cookie size is four bytes";
                        }
                        enum 8 {
                          tailf:info "The cookie size is eight bytes";
                        }
                      }
                    }
                    container value {
                      tailf:info "The value of the cookie";
                      tailf:cli-flatten-container;
                      tailf:cli-compact-syntax;
                      tailf:cli-sequence-commands;
                      when "../size != 0";
                      leaf value-1 {
                        tailf:cli-drop-node-name;
                        type string {
                          tailf:info "<0x0-0xffffffff>;;Lower 4 bytes value";
                        }
                      }
                      leaf value-2 {
                        tailf:cli-drop-node-name;
                        when "../../size != 4";
                        type string {
                          tailf:info "<0x0-0xffffffff>;;Higher 4 bytes value";
                        }
                      }
                    }
                  }
                }

                // l2vpn / xconnect group * / p2p * / neighbor * / l2tp / remote cookie
                container remote {
                  tailf:info "L2TP PW static remote";
                  container cookie {
                    tailf:info "L2TP PW static remote cookie settings";
                    tailf:cli-flatten-container;
                    tailf:cli-compact-syntax;
                    tailf:cli-sequence-commands {
                      tailf:cli-reset-siblings;
                    }
                    leaf size {
                      tailf:info "L2TP PW static remote cookie size settings";
                      type enumeration {
                        enum 0 {
                          tailf:info "The cookie size is zero bytes";
                        }
                        enum 4 {
                          tailf:info "The cookie size is four bytes";
                        }
                        enum 8 {
                          tailf:info "The cookie size is eight bytes";
                        }
                      }
                    }
                    container value {
                      tailf:info "The value of the cookie";
                      tailf:cli-flatten-container;
                      tailf:cli-compact-syntax;
                      tailf:cli-sequence-commands;
                      when "../size != 0";
                      leaf value-1 {
                        tailf:cli-drop-node-name;
                        type string {
                          tailf:info "<0x0-0xffffffff>;;Lower 4 bytes value";
                        }
                      }
                      leaf value-2 {
                        tailf:cli-drop-node-name;
                        when "../../size != 4";
                        type string {
                          tailf:info "<0x0-0xffffffff>;;Higher 4 bytes value";
                        }
                      }
                    }
                  }
                }
              }
            }

            // l2vpn / xconnect group * / p2p * / neighbor * / source
            leaf source {
              tailf:info "Source address of PW";
              type inet:ipv6-address {
                tailf:info "X:X::X;;Source IPv6 address of PW";
              }
            }

            // l2vpn / xconnect group * / p2p * / neighbor * / backup
            container backup {
              tailf:info "Backup pseudowire for the cross connect";

              // l2vpn / xconnect group * / p2p * / neighbor * / backup neighbor *
              list neighbor {
                tailf:info "Specify the peer to cross connect";
                tailf:cli-mode-name "config-l2vpn-xc-p2p-pw-backup";
                key "address pw-id";
                leaf address {
                  type string {
                    tailf:info "IP address of the peer";
                  }
                }
                leaf pw-id {
                  tailf:info "Specify the pseudowire id";
                  tailf:cli-expose-key-name;
                  type uint32 {
                    tailf:info "<1-4294967295>;;Pseudowire ID";
                  }
                }
                // l2vpn / xconnect group * / p2p * / neighbor * / backup neighbor * / pw-class
                leaf pw-class {
                  tailf:info "PW class template name to use for this XC backup";
                  tailf:cli-full-command;
                  type string {
                    tailf:info "WORD;;Pseudowire-class name";
                  }
                }
              }
            }
          }

          // l2vpn / xconnect group * / p2p * / neighbor routed *
          container neighbor-routed {
            tailf:cli-drop-node-name;
            list neighbor {
              tailf:info "Specify the peer to cross connect";
              tailf:cli-mode-name "config-l2vpn-xc-p2p-pwr";
              key "routed source";
              leaf routed {
                tailf:info "Specify a routed PW";
                tailf:cli-expose-key-name;
                type string {
                  tailf:info "WORD;;global-id:prefix:ac-id";
                }
              }
              leaf source {
                tailf:info "Source addresss of the routed PW";
                tailf:cli-expose-key-name;
                type uint32 {
                  tailf:info "<1-4294967295>;;Local AC id (hex or decimal format)";
                  range "1..4294967295";
                }
              }

              // l2vpn / xconnect group * / p2p * / neighbor routed * / pw-class
              leaf pw-class {
                tailf:info "PW class template name to use for this XC";
                tailf:cli-full-command;
                type string {
                  tailf:info "WORD;;Pseudowire-class name";
                }
              }

              // l2vpn / xconnect group * / p2p * / neighbor routed * / tag-impose
              container tag-impose {
                tailf:info "tag impose mode";
                leaf vlan {
                  tailf:info "vlan tagged mode";
                  type uint16 {
                    tailf:info "<1-4094>;;vlan tagged mode";
                    range "1..4094";
                  }
                }
              }
            }
          }

          // l2vpn / xconnect group * / p2p * / neighbor evpn evi * target * source *
          container neighbor-evpn {
            tailf:cli-drop-node-name;
            container neighbor {
              tailf:info "Specify the peer to cross connect";
              list evpn {
                tailf:info "Specify the Ethernet VPN";
                tailf:cli-mode-name "config-l2vpn-xc-p2p-pw";
                tailf:cli-exit-command "!"; // XR 6.4 enters sub-mode, 6.2 does not
                key "evi target source";
                leaf evi {
                  tailf:info "Ethernet VPN Identifier";
                  tailf:cli-expose-key-name;
                  type uint16 {
                    tailf:info "<1-65534>;;Ethernet VPN ID to set";
                    range "1..65534";
                  }
                }
                leaf target {
                  tailf:info "Specify remote attachment circuit identifier";
                  tailf:cli-expose-key-name;
                  type uint32 {
                    tailf:info "<1-16777215>;;Remote ac-id (hex or decimal format)";
                    range "1..16777215";
                  }
                }
                leaf source {
                  tailf:info "Specify source attachment circuit identifier";
                  tailf:cli-expose-key-name;
                  type uint32 {
                    tailf:info "<1-16777215>;;Source ac-id (hex or decimal format)";
                    range "1..16777215";
                  }
                }

                // l2vpn / xconnect group * / p2p * / neighbor evpn evi * target * source * / pw-class
                leaf pw-class {
                  tailf:info "PW class template name to use";
                  type string {
                    tailf:info "WORD;;Pseudowire-class name";
                  }
                }
              }
            }
          }

          // l2vpn / xconnect group * / p2p * / neighbor evpn evi * service *
          container neighbor-evpn-service {
            tailf:cli-drop-node-name;
            container neighbor {
              tailf:info "Specify the peer to cross connect";
              list evpn {
                tailf:info "Specify the Ethernet VPN";
                tailf:cli-mode-name "config-l2vpn-xc-p2p-pw";
                tailf:cli-exit-command "!"; // XR 6.4 enters sub-mode, 6.2 does not
                key "evi service";
                leaf evi {
                  tailf:info "Ethernet VPN Identifier";
                  tailf:cli-expose-key-name;
                  type uint16 {
                    tailf:info "<1-65534>;;Ethernet VPN ID to set";
                    range "1..65534";
                  }
                }
                leaf service {
                  tailf:info "Specify service ID (used as local and remote ac-id)";
                  tailf:cli-expose-key-name;
                  type uint32 {
                    tailf:info "<1-4294967294>;;Service ID (decimal format)";
                    range "1..4294967294";
                  }
                }
                container segment-routing {
                  tailf:info "Configure Segment Routing VPWS Instance";
                  tailf:cli-flatten-container;
                  tailf:cli-hide-in-submode;
                  leaf srv6 {
                    tailf:info "Configure SRv6 VPWS Instance";
                    type empty;
                  }
                }

                // l2vpn / xconnect group * / p2p * / neighbor evpn * service * / pw-class
                leaf pw-class {
                  tailf:info "PW class template name to use";
                  type string {
                    tailf:info "WORD;;Pseudowire-class name";
                  }
                }

                // l2vpn / xconnect group * / p2p * / neighbor evpn * service * / locator
                leaf locator {
                  tailf:info "PW locator to use for EVPN SID allocation";
                  type string {
                    tailf:info "WORD;;Specify locator name";
                  }
                }
              }
            }
          }

          // l2vpn / xconnect group * / p2p * / interworking
          leaf interworking {
            tailf:info "Set attachment circuit interworking";
            type enumeration {
              enum ethernet {
                tailf:info "Ethernet interworking";
              }
              enum ipv4 {
                tailf:info "IPv4 interworking";
              }
            }
          }

          // l2vpn / xconnect group * / p2p * / description
          leaf description {
            tailf:info "Description for cross connect";
            tailf:cli-full-command;
            // note: not a multi-vale string, needs "" if whitespaces
            type string {
              tailf:info "WORD;;Cross connect description string";
            }
          }
        }
      }
    }

    // l2vpn / bridge
    container bridge {
      tailf:info "Configure bridge commands";

      // l2vpn / bridge group *
      list group {
        tailf:info "Specify the group the bridge belongs to";
        tailf:cli-mode-name "config-l2vpn-bg";
        key group-name;
        leaf group-name {
          tailf:info "Name of the bridge group";
          type string {
            tailf:info "WORD;;Name of the bridge group";
          }
        }

        // l2vpn / bridge group * / apply-group
        uses apply-group-grouping;

        // l2vpn / bridge group * / bridge-domain *
        list bridge-domain {
          tailf:info "Configure bridge domain";
          tailf:cli-mode-name "config-l2vpn-bg-bd";
          key bridge-domain-name;
          leaf bridge-domain-name {
            tailf:info "Name of the bridge domain";
            type string {
              tailf:info "WORD;;Name of the bridge domain";
            }
          }

          // l2vpn / bridge group * / bridge-domain * / apply-group
          uses apply-group-grouping;

          // l2vpn / bridge group * / bridge-domain * / description
          uses description-grouping;

          // l2vpn / bridge group * / bridge-domain * / multicast-source
          leaf multicast-source {
            tailf:info "Multicast Source Traffic";
            type enumeration {
              enum ipv4 {
                tailf:info "Traffic Type IPv4";
              }
              enum ipv6 {
                tailf:info "Traffic Type IPv6";
              }
              enum ipv4-ipv6 {
                tailf:info "Traffic Type IPv4 and IPv6";
              }
            }
          }

          // l2vpn / bridge group * / bridge-domain * / mtu
          leaf mtu {
            tailf:info "Maximum transmission unit (payload) for this Bridge Domain";
            type uint16 {
              tailf:info "<46-65535>;;Maximum transmission unit size (payload) in bytes";
              range "46..65535";
            }
          }

          // l2vpn / bridge group * / bridge-domain * / nv satellite
          container nv {
            tailf:info "Configure nV Satellite Settings";
            container satellite {
              tailf:info "Configure nV Satellite Settings";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-l2vpn-bg-bd-nv";
              presence true;
            }
          }

          uses l2vpn-bridge-domain-grouping;

          // l2vpn / bridge group * / bridge-domain * / shutdown
          leaf shutdown {
            tailf:info "shutdown the Bridge Domain";
            type empty;
          }

          // l2vpn / bridge group * / bridge-domain * / interface *
          list interface {
            tailf:info "Assign interface to bridge domain";
            tailf:cli-mode-name "config-l2vpn-bg-bd-ac";
            key name;
            leaf name {
              tailf:info "Interface Name";
              type string {
                tailf:info "WORD;;Interface Name";
              }
            }

            // l2vpn / bridge group * / bridge-domain * / interface * / mac
            container mac {
              tailf:info "MAC configuration commands";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-l2vpn-bg-bd-ac-mac";
              uses l2vpn-bridge-domain-mac-grouping;
            }

            // l2vpn / bridge group * / bridge-domain * / interface * / static-mac-address *
            list static-mac-address {
              tailf:info "Static MAC address";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key address;
              leaf address {
                type string {
                  tailf:info "H.H.H;;Static MAC address";
                }
              }
            }

            // l2vpn / bridge group * / bridge-domain * / interface * / storm-control
            uses storm-control-grouping;

            // l2vpn / bridge group * / bridge-domain * / interface * / igmp
            container igmp {
              tailf:info "IGMP protocol";
              container snooping {
                tailf:info "Set the snooping profile";
                leaf profile {
                  tailf:info "Attach a IGMP profile";
                  type string {
                    tailf:info "WORD;;IGMP Snooping profile name";
                  }
                }
              }
            }

            // l2vpn / bridge group * / bridge-domain * / interface * / split-horizon group
            container split-horizon {
              tailf:info "Configure split horizon group";
              leaf group {
                tailf:info "Configure split horizon group";
                type empty;
              }
            }

            // l2vpn / bridge group * / bridge-domain * / interface * / flooding
            container flooding {
              tailf:info "Traffic flooding";

              // l2vpn / bridge group * / bridge-domain * / interface * / flooding disable
              leaf disable {
                tailf:info "Disable flooding";
                type empty;
              }

              // l2vpn / bridge group * / bridge-domain * / interface * / flooding unknown-unicast disable
              container unknown-unicast {
                tailf:info "Traffic flooding unknown unicast";
                leaf disable {
                  tailf:info "Disable Unknown Unicast flooding";
                  type empty;
                }
              }
            }
          }

          // l2vpn / bridge group * / bridge-domain * / neighbor *
          list neighbor {
            tailf:info "Specify the peer to cross connect";
            tailf:cli-mode-name "config-l2vpn-bg-bd-pw";
            key "address pw-id";
            leaf address {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IPv4 address of the peer";
              }
            }
            leaf pw-id {
              tailf:info "Specify the pseudowire id";
              tailf:cli-expose-key-name;
              type uint32 {
                tailf:info "<1-4294967295>;;Pseudowire ID";
                range "1..4294967295";
              }
            }

            // l2vpn / bridge group * / bridge-domain * / neighbor * / pw-class
            leaf pw-class {
              tailf:info "PW class template name to use for this pseudowire";
              tailf:cli-full-command;
              type string {
                tailf:info "WORD;;Pseudowire-class name";
              }
            }

            // l2vpn / bridge group * / bridge-domain * / neighbor * / static-mac-address *
            list static-mac-address {
              tailf:info "Static MAC address";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key address;
              leaf address {
                type string {
                  tailf:info "H.H.H;;Static MAC address";
                }
              }
            }

            // l2vpn / bridge group * / bridge-domain * / neighbor * / mpls
            container mpls {
              tailf:info "MPLS L2VPN PW command";
              container static {
                tailf:info "MPLS L2VPN static settings";
                container label {
                  tailf:info "MPLS L2VPN static labels";
                  tailf:cli-compact-syntax;
                  tailf:cli-sequence-commands {
                    tailf:cli-reset-siblings;
                  }
                  leaf local {
                    tailf:info "Local pseudowire label";
                    tailf:cli-incomplete-command;
                    type uint32 {
                      tailf:info "<16-1048575>;;Local pseudowire label";
                      range "16..1048575";
                    }
                  }
                  leaf remote {
                    tailf:info "Remote pseudowire label";
                    type uint32 {
                      tailf:info "<16-1048575>;;Remote pseudowire label";
                      range "16..1048575";
                    }
                  }
                }
              }
            }

            uses l2vpn-bridge-domain-grouping;

            // l2vpn / bridge group * / bridge-domain * / neighbor * / backup neighbor *
            container backup {
              tailf:info "Backup pseudowire for the access pseudowire";
              list neighbor {
                tailf:info "Specify the peer";
                tailf:cli-mode-name "config-l2vpn-bg-bd-pw-backup";
                key "address pw-id";
                leaf address {
                  type string {
                    tailf:info "IP address of the peer";
                  }
                }
                leaf pw-id {
                  tailf:info "Specify the pseudowire id";
                  tailf:cli-expose-key-name;
                  type uint32 {
                    tailf:info "<1-4294967295>;;Pseudowire ID";
                  }
                }
                // l2vpn / bridge group * / bridge-domain * / neighbor * / backup neighbor * / pw-class
                leaf pw-class {
                  tailf:info "PW class template name to use for this XC backup";
                  type string {
                    tailf:info "WORD;;Pseudowire-class name";
                  }
                }
              }
            }

            // l2vpn / bridge group * / bridge-domain * / neighbor * / split-horizon group
            container split-horizon {
              tailf:info "Configure split horizon group";
              leaf group {
                tailf:info "Configure split horizon group";
                type empty;
              }
            }
          }

          // l2vpn / bridge group * / bridge-domain * / access-vfi *
          list access-vfi {
            tailf:info "Specify the access virtual forwarding interface name";
            tailf:cli-mode-name "config-l2vpn-bg-bd-accessvfi";
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;Name of the Access Virtual Forwarding Interface";
              }
            }

            // l2vpn / bridge group * / bridge-domain * / access-vfi * / neighbor *
            list neighbor {
              tailf:info "Specify the peer to cross connect";
              tailf:cli-mode-name "config-l2vpn-bg-bd-accessvfi-pw";
              key "address pw-id";
              leaf address {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IPv4 address of the peer";
                }
              }
              leaf pw-id {
                tailf:cli-expose-key-name;
                tailf:info "Specify the pseudowire id";
                type uint32 {
                  tailf:info "<1-4294967295>;;Pseudowire ID";
                  range "1..4294967295";
                }
              }
            }
          }

          // l2vpn / bridge group * / bridge-domain * / routed interface *
          container routed {
            tailf:info "Bridge domain L3 interface";
            list interface {
              tailf:info "Assign interface to bridge domain";
              tailf:cli-mode-name "config-l2vpn-bg-bd-bvi";
              tailf:cli-exit-command "!";
              key name;
              leaf name {
                type string {
                  tailf:info "BVI;;Bridge-Group Virtual Interface";
                }
              }

              // l2vpn / bridge group * / bridge-domain * / routed interface * / split-horizon group core
              container split-horizon {
                tailf:info "Configure split-horizon group";
                container group {
                  tailf:info "Configure split-horizon group";
                  leaf core {
                    tailf:info "Configure BVI under SHG 1";
                    type empty;
                  }
                }
              }
            }
          }

          // l2vpn / bridge group * / bridge-domain * / vfi *
          list vfi {
            tailf:info "Specify the virtual forwarding interface name";
            tailf:cli-mode-name "config-l2vpn-bg-bd-vfi";
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;Name of the Virtual Forwarding Interface";
              }
            }

            // l2vpn / bridge group * / bridge-domain * / vfi * / vpn-id
            leaf vpn-id {
              tailf:info "VPN Identifier (VPN ID)";
              type uint32 {
                tailf:info "<1-4294967295>;;Value of the VPN ID";
                range "1..4294967295";
              }
            }

            // l2vpn / bridge group * / bridge-domain * / vfi * / autodiscovery bgp
            container autodiscovery {
              tailf:info "Enable auto-discovery in this VFI";
              container bgp {
                tailf:info "Enable BGP auto-discovery in this VFI";
                tailf:cli-add-mode;
                tailf:cli-mode-name "config-l2vpn-bg-bd-vfi-ad";
                presence true;

                // l2vpn / bridge group * / bridge-domain * / vfi * / autodiscovery bgp / rd
                leaf rd {
                  tailf:info "route distinguisher";
                  tailf:cli-full-command;
                  type string {
                    tailf:info "WORD;;AS-number, IPv4 address:index or 'auto'";
                  }
                }

                // l2vpn / bridge group * / bridge-domain * / vfi * / autodiscovery bgp / route-target *
                // l2vpn / bridge group * / bridge-domain * / vfi * / autodiscovery bgp / route-target import *
                // l2vpn / bridge group * / bridge-domain * / vfi * / autodiscovery bgp / route-target export *
                uses route-target-import-export-grouping;

                // l2vpn / bridge group * / bridge-domain * / vfi * / autodiscovery bgp / signaling-protocol
                container signaling-protocol {
                  tailf:info "Enable signaling protocol for this VFI";

                  // l2vpn / bridge group * / bridge-domain * / vfi * / autodiscovery bgp / signaling-protocol bgp
                  container bgp {
                    tailf:info "Enable BGP signaling protocol for this VFI";
                    tailf:cli-add-mode;
                    tailf:cli-mode-name "config-l2vpn-bg-bd-vfi-ad-sig";
                    presence true;

                    // l2vpn / bridge group * / bridge-domain * / vfi * / autodiscovery bgp / signaling-protocol bgp / ve-id
                    leaf ve-id {
                      tailf:info "Local Virtual Edge Identifier (VE ID)";
                      type uint16 {
                        tailf:info "<1-16384>;;Value of the local VE ID";
                        range "1..16384";
                      }
                    }

                    // l2vpn / bridge group * / bridge-domain * / vfi * / autodiscovery bgp / signaling-protocol bgp / ve-range
                    leaf ve-range {
                      tailf:info "Local Virtual Edge Block Configurable Range";
                      type uint16 {
                        tailf:info "<11-100>;;Value of the VE Range";
                        range "11..100";
                      }
                    }

                    // l2vpn / bridge group * / bridge-domain * / vfi * / autodiscovery bgp / signaling-protocol bgp / load-balancing flow-label
                    container load-balancing {
                      tailf:info "Load Balancing";
                      tailf:cli-compact-syntax;
                      tailf:cli-sequence-commands {
                        tailf:cli-reset-siblings;
                      }
                      leaf flow-label {
                        tailf:info "Flow label based load balancing setting";
                        type enumeration {
                          enum both {
                             tailf:info "Insert/Discard Flow label when transmit/recceive";
                          }
                          enum receive {
                             tailf:info "Discard Flow label when receive";
                          }
                          enum transmit {
                             tailf:info "Insert Flow label when transmit";
                          }
                        }
                      }
                      leaf static {
                        tailf:info "Set Flow label parameters statically";
                        type empty;
                      }
                    }
                  }

                  // l2vpn / bridge group * / bridge-domain * / vfi * / autodiscovery bgp / signaling-protocol ldp
                  container ldp {
                    tailf:info "Enable LDP signaling protocol for this VFI";
                    tailf:cli-add-mode;
                    tailf:cli-mode-name "config-l2vpn-bg-bd-vfi-ad-sig";
                    presence true;

                    // l2vpn / bridge group * / bridge-domain * / vfi * / autodiscovery bgp / signaling-protocol ldp / vpls-id
                    leaf vpls-id {
                      tailf:info "VPLS ID";
                      type union {
                        type string {
                          tailf:info "<1-65535>;;Two Byte AS number";
                        }
                        type inet:ipv4-address {
                          tailf:info "A.B.C.D;;IP address";
                        }
                      }
                    }

                    // l2vpn / bridge group * / bridge-domain * / vfi * / autodiscovery bgp / signaling-protocol ldp / load-balancing flow-label
                    container load-balancing {
                      tailf:info "Load Balancing";
                      tailf:cli-compact-syntax;
                      tailf:cli-sequence-commands {
                        tailf:cli-reset-siblings;
                      }
                      leaf flow-label {
                        tailf:info "Flow label based load balancing setting";
                        type enumeration {
                          enum both {
                             tailf:info "Insert/Discard Flow label when transmit/recceive";
                          }
                          enum receive {
                             tailf:info "Discard Flow label when receive";
                          }
                          enum transmit {
                             tailf:info "Insert Flow label when transmit";
                          }
                        }
                      }
                      leaf static {
                        tailf:info "Set Flow label parameters statically";
                        type empty;
                      }
                    }
                  }
                }

                // l2vpn / bridge group * / bridge-domain * / vfi * / autodiscovery bgp / control-word
                leaf control-word {
                  tailf:info "Enable control-word for BGP-Autodiscovered PWs for this VFI";
                  type empty;
                }
              }
            }

            // l2vpn / bridge group * / bridge-domain * / vfi * / neighbor *
            list neighbor {
              tailf:info "Specify the peer to cross connect";
              tailf:cli-mode-name "config-l2vpn-bg-bd-vfi-pw";
              key "address pw-id";
              leaf address {
                type string {
                  tailf:info "IP address of the peer";
                }
              }
              leaf pw-id {
                tailf:info "Specify the pseudowire id";
                tailf:cli-expose-key-name;
                type uint32 {
                  tailf:info "<1-4294967295>;;Pseudowire ID";
                }
              }

              // l2vpn / bridge group * / bridge-domain * / vfi * / neighbor * / pw-class
              leaf pw-class {
                tailf:info "PW class template name to use for this pseudowire";
                tailf:cli-full-command;
                type string {
                  tailf:info "WORD;;Pseudowire-class name";
                }
              }

              // l2vpn / bridge group * / bridge-domain * / vfi * / neighbor * / static-mac-address *
              list static-mac-address {
                tailf:info "Static MAC address";
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                key address;
                leaf address {
                  type string {
                    tailf:info "H.H.H;;Static MAC address";
                  }
                }
              }

              // l2vpn / bridge group * / bridge-domain * / vfi * / neighbor * / igmp snooping profile
              container igmp {
                tailf:info "IGMP protocol";
                container snooping {
                  tailf:info "Set the snooping profile";
                  leaf profile {
                    tailf:info "Attach an IGMP profile";
                    type string {
                      tailf:info "WORD;;IGMP Snooping profile name";
                    }
                  }
                }
              }
            }
          }

          // l2vpn / bridge group * / bridge-domain * / pbb
          container pbb {
            tailf:info "Configure Provider Backbone Bridge";

            // l2vpn / bridge group * / bridge-domain * / pbb edge *
            list edge {
              tailf:info "PBB edge bridge domain";
              tailf:cli-mode-name "config-l2vpn-bg-bd-pbb-edge";
              key "i-sid core-bridge";
              leaf i-sid {
                tailf:cli-expose-key-name;
                tailf:info "Configure Service Instance Identifier";
                type uint32 {
                  tailf:info "<256-16777214>;;Service Instance ID";
                  range "256..16777214";
                }
              }
              leaf core-bridge {
                tailf:cli-expose-key-name;
                tailf:info "Specifiy PBB core bridge domain to associate with";
                type string {
                  tailf:info "WORD;;Name of the PBB core bridge domain";
                }
              }

              // l2vpn / bridge group * / bridge-domain * / pbb edge * / unknown-unicast-bmac
              leaf unknown-unicast-bmac {
                tailf:info "Unknown Unicast backbone MAC address";
                type string {
                  tailf:info "H.H.H;;Unknown Unicast backbone MAC address";
                }
              }
            }

            // l2vpn / bridge group * / bridge-domain * / pbb core
            container core {
              tailf:info "PBB core bridge domain";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-l2vpn-bg-bd-pbb-core";
              presence true;

              // l2vpn / bridge group * / bridge-domain * / pbb core / evi
              leaf evi {
                tailf:info "Ethernet VPN identifier";
                tailf:cli-full-command;
                type uint16 {
                  tailf:info "<1-65534>;;Ethernet VPN ID to set";
                  range "1..65534";
                }
              }

              // l2vpn / bridge group * / bridge-domain * / pbb core / evpn evi
              container evpn {
                tailf:info "Specify the Ethernet VPN interface name [deprecated?]";
                leaf evi {
                  tailf:info "Ethernet VPN identifier";
                  type uint16 {
                    tailf:info "<1-65534>;;Ethernet VPN ID to set";
                    range "1..65534";
                  }
                }
              }
            }
          }

          // l2vpn / bridge group * / bridge-domain * / evpn evi
          container evpn {
            tailf:info "Specify the Ethernet VPN interface name";
            leaf evi {
              tailf:info "Ethernet VPN identifier";
              type uint16 {
                tailf:info "<1-65534>;;Ethernet VPN ID to set";
                range "1..65534";
              }
            }
          }

          // l2vpn / bridge group * / bridge-domain * / evi *
          list evi {
            tailf:info "Ethernet VPN identifier";
            tailf:cli-mode-name "config-l2vpn-bg-bd-evi";
            max-elements 1;
            key id;
            leaf id {
              type uint16 {
                tailf:info "<1-65534>;;Ethernet VPN ID to set";
                range "1..65534";
              }
            }
          }

          // l2vpn / bridge group * / bridge-domain * / member vni *
          container member {
            tailf:info "Bridge domain member";
            list vni {
              tailf:info "Assign VxLAN Network Identifier to bridge domain";
              tailf:cli-mode-name "config-l2vpn-bg-bd-vni";
              max-elements 1;
              key id;
              leaf id {
                type uint32 {
                  tailf:info "<1-16777215>;;Specify VxLAN Network Identifier value";
                  range "1..16777215";
                }
              }
            }
          }

          // l2vpn / bridge group * / bridge-domain * / dhcp ipv4 snoop profile
          container dhcp {
            tailf:info "DHCP protocol";
            container ipv4 {
              tailf:info "IP Version 4";
              container snoop {
                tailf:info "Set the snooping profile";
                leaf profile {
                  tailf:info "Attach a DHCP profile";
                  type string {
                    tailf:info "WORD;;DHCPv4 Snooping profile name";
                  }
                }
              }
            }
          }
        }
      }
    }

    // l2vpn / pbb
    container pbb {
      tailf:info "PBB configuration commands";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-l2vpn-pbb";

      // l2vpn / pbb / backbone-source-mac
      leaf backbone-source-mac {
        tailf:info "Backbone Source MAC";
        type string {
          tailf:info "H.H.H;;Backbone Source MAC address";
          pattern '[0-9a-f]{4}\.[0-9a-f]{4}\.[0-9a-f]{4}';
        }
      }
    }
  }


  /// ========================================================================
  /// policy-global
  /// ========================================================================

  container policy-global {
    tailf:info "Define global variables for route policy";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-rpl-gl";
    tailf:cli-exit-command "end-global";
    presence true;
    list set {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-show-long-obu-diffs;
      ordered-by user;
      key value;
      leaf value {
        tailf:cli-multi-word-key;
        tailf:cli-disallow-value "end-global|abort|exit";
        type string {
          tailf:info "WORD;;policy-global line";
          pattern ".*[^,]";
        }
      }
    }
  }


  /// ========================================================================
  /// extcommunity-set
  /// ========================================================================

  container extcommunity-set {
    tailf:info "Define an extended community set";

    // extcommunity-set rt *
    list rt {
      tailf:info "BGP Route Target (RT) extended community";
      tailf:cli-mode-name "config-ext";
      tailf:cli-exit-command "end-set";
      tailf:cli-full-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Route Target type extcommunity set name";
        }
      }
      uses set-list-grouping;
    }

    // extcommunity-set soo *
    list soo {
      tailf:info "BGP Site of Origin (SoO) extended community";
      tailf:cli-mode-name "config-ext";
      tailf:cli-exit-command "end-set";
      tailf:cli-full-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Site of Origin type extcommunity set name";
        }
      }
      uses set-list-grouping;
    }

    // extcommunity-set opaque *
    list opaque {
      tailf:info "MLDP opaque types";
      tailf:cli-mode-name "config-ext";
      tailf:cli-exit-command "end-set";
      tailf:cli-full-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Opaque type extcommunity set name";
        }
      }
      uses set-list-grouping;
    }
  }


  /// ========================================================================
  /// rd-set
  /// ========================================================================

  // rd-set *
  list rd-set {
    tailf:info "Define a BGP VPN route-distinguisher set";
    tailf:cli-mode-name "config-rd";
    tailf:cli-exit-command "end-set";
    tailf:cli-full-command;
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;Route Distinguisher set name";
      }
    }
    uses set-list-grouping;
  }


  /// ========================================================================
  /// tag-set
  /// ========================================================================

  // tag-set *
  list tag-set {
    tailf:info "Configuration for a tag set";
    tailf:cli-mode-name "config-tag";
    tailf:cli-exit-command "end-set";
    tailf:cli-full-command;
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;tag set name";
                     }
    }
    uses set-list-grouping;
  }


  /// ========================================================================
  /// prefix-set
  /// ========================================================================

  // prefix-set *
  list prefix-set {
    tailf:info "Define a prefix set";
    tailf:cli-mode-name "config-pfx";
    tailf:cli-exit-command "end-set";
    tailf:cli-full-command;
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;Prefix setname";
      }
    }
    uses set-list-grouping;
  }


  /// ========================================================================
  /// as-path-set
  /// ========================================================================

  // as-path-set *
  list as-path-set {
    tailf:info "Define an AS-path set";
    tailf:cli-mode-name "config-as";
    tailf:cli-exit-command "end-set";
    tailf:cli-full-command;
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;AS-path set name";
      }
    }
    uses set-list-grouping;
  }


  /// ========================================================================
  /// community-set
  /// ========================================================================

  // community-set *
  list community-set {
    tailf:info "Define a community set";
    tailf:cli-mode-name "config-comm";
    tailf:cli-exit-command "end-set";
    tailf:cli-full-command;
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;Community set name";
      }
    }
    uses set-list-grouping;
  }


  /// ========================================================================
  /// community-set
  /// ========================================================================

  // large-community-set *
  list large-community-set {
    tailf:info "Define a large community set";
    tailf:cli-mode-name "config-comm";
    tailf:cli-exit-command "end-set";
    tailf:cli-full-command;
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;Large Community set name";
      }
    }
    uses set-list-grouping;
  }


  /// ========================================================================
  /// rpl
  /// ========================================================================

  container rpl {
    tailf:info "RPL commands";

    // rpl editor
    leaf editor {
      tailf:info "Set default RPL editor";
      type enumeration {
        enum emacs {
          tailf:info "Set default RPL editor to Emacs";
        }
        enum nano {
          tailf:info "Set default RPL editor to nano";
        }
        enum vim {
          tailf:info "Set default RPL editor to Vim";
        }
      }
    }

    // rpl set-exit-as-abort
    leaf set-exit-as-abort {
      tailf:info "Set exit under RPL config to abort";
      type empty;
    }
  }


  /// ========================================================================
  /// route-policy
  /// ========================================================================

  list route-policy {
    when "not(/cisco-ios-xr:tailfned/api/edit-route-policy)" {
      tailf:dependency "/cisco-ios-xr:tailfned/api/edit-route-policy";
    }
    cli:parse-global-when;
    tailf:info "Define a route policy";
    tailf:cli-mode-name "config-rpl";
    tailf:cli-exit-command "end-policy";
    tailf:cli-full-command;
    key name;
    leaf name {
      tailf:cli-suppress-range;
      type string {
        tailf:info "WORD;;Route Policy name";
      }
    }
    leaf value {
      tailf:cli-drop-node-name;
      tailf:cli-disallow-value "end-policy";
      type string {
        tailf:info "WORD;;route-policy contents as a single quoted string.";
      }
    }
  }

  container route-policy-edit {
    tailf:cli-drop-node-name;
    when "/cisco-ios-xr:tailfned/api/edit-route-policy" {
      tailf:dependency "/cisco-ios-xr:tailfned/api/edit-route-policy";
    }
    cli:parse-global-when;
    list route-policy {
      tailf:info "Define a route policy";
      tailf:cli-mode-name "config-rpl";
      tailf:cli-exit-command "end-policy";
      tailf:cli-full-command;
      key name;
      leaf name {
        tailf:cli-suppress-range;
        type string {
          tailf:info "WORD;;Route Policy name";
        }
      }
      list line {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          tailf:cli-suppress-range;
          type uint32 {
            tailf:info "<0-2147483647>;;Line number";
            range "0..2147483647";
          }
        }
        leaf value {
          tailf:cli-drop-node-name;
          tailf:cli-multi-value;
          tailf:cli-preformatted;
          tailf:cli-disallow-value "end-policy";
          type string {
            tailf:info "WORD;;route-policy line.";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// generic-interface-list
  /// ========================================================================

  list generic-interface-list {
    tailf:info "Interface list";
    tailf:cli-mode-name "config-gen-if-list";
    tailf:cli-explicit-exit;
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;Interface-list name";
      }
    }

    // generic-interface-list / interface *
    list interface {
      tailf:info "Specify an interface";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        type ifname;
      }
    }
  }


  /// ========================================================================
  /// generic-interface-list
  /// ========================================================================

  list gnss-receiver {
    tailf:info "GNSS receiver configuration commands";
    key "number location";
    leaf number {
      type uint32 {
        tailf:info "<0-4294967295>;;GNSS receiver number";
      }
    }
    leaf location {
      tailf:info "Specify the GNSS receiver location";
      tailf:cli-expose-key-name;
      type string {
        tailf:info "WORD;;Fully qualified location specification";
      }
    }
    // gnss-receiver * * / 1pps
    container onepps {
      tailf:alt-name "1pps";
      leaf polarity {
        tailf:info "1PPS polarity configuration";
        type enumeration {
          enum negative {
            tailf:info "Negative 1PPD polarity";
          }
          enum positive {
            tailf:info "Positive 1PPS polarity";
          }
        }
      }
    }
    // gnss-receiver * * / anti-jam disable
    container anti-jam {
      tailf:info "Anti-jam mode configuration";
      leaf disable {
        tailf:info "Disable anti-jam mode";
        type empty;
      }
    }
    // gnss-receiver * * / band-width
    leaf band-width {
      tailf:info "PLL Band-width configuration for GNSS";
      type uint16 {
        tailf:info "<1-2000>;;PLL Band-width for GNSS, in mHz";
      }
    }
    // gnss-receiver * * / cable-delay compensation
    container cable-delay {
      tailf:info "Cable-delay compensation configuration";
      leaf compensation {
        tailf:info "Cable-delay compensation configuration";
        type int32 {
          tailf:info "<-1000000,+1000000>  Cable-delay compensation value, in nanoseconds";
        }
      }
    }
    // gnss-receiver * * / constellation
    leaf constellation {
      tailf:info "Constellation configuration";
      type enumeration {
        enum auto {
          tailf:info "Auto-select the constellation";
        }
        enum beidou {
          tailf:info "Beidou";
        }
        enum galileo {
          tailf:info "Galileo";
        }
        enum glonass {
          tailf:info "GLONASS";
        }
        enum gps {
          tailf:info "GPS";
        }
        enum irnss {
          tailf:info "IRNSS";
        }
        enum qzss {
          tailf:info "QZSS";
        }
        enum sbas {
          tailf:info "SBAS (WAAS)";
        }
      }
    }
    // gnss-receiver * * / elevation threshold
    container elevation {
      tailf:info "Elevation threshold configuration";
      leaf threshold {
        tailf:info "Elevation threshold configuration";
        type uint8 {
          tailf:info "<0-40>;;Elevation threshold value, in degrees";
        }
      }
    }
    // gnss-receiver * * / frequency synchronization
    container frequency {
      tailf:info "Frequency Synchronization configuration";
      container synchronization {
        tailf:info "Frequency Synchronization configuration";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-gnss-freqsync";
        leaf priority {
          tailf:info "Source priority";
          type uint8 {
            tailf:info "<1-254>;;Source priority";
          }
        }
        container quality {
          tailf:info "Quality level configuration";
          grouping quality-grouping {
            leaf type {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type enumeration {
                enum exact {
                  tailf:info "Specify the exact QL value to use";
                }
                enum highest {
                  tailf:info "Specify the highest acceptable QL value";
                }
                enum lowest {
                  tailf:info "Specify the lowest acceptable QL value";
                }
              }
            }
            leaf itu-t {
              tailf:info "ITU-T QL options";
              tailf:cli-incomplete-command;
              type empty;
            }
            leaf option {
              tailf:info "ITU-T QL options";
              tailf:cli-incomplete-command;
              type enumeration {
                enum 1 {
                  tailf:info "ITU-T QL option 1";
                }
                enum 2 {
                  tailf:info "ITU-T QL option 2";
                }
              }
            }
            leaf generation {
              tailf:info "generation  ITU-T QL option 2 generation";
              tailf:cli-incomplete-command;
              when "../option = '2'" {
                tailf:dependency "../option";
              }
              type enumeration {
                enum 1 {
                  tailf:info "ITU-T QL option 2, generation 1";
                }
                enum 2 {
                  tailf:info "ITU-T QL option 2, generation 2";
                }
              }
            }
            leaf value-opt1 {
              tailf:cli-drop-node-name;
              when "../option = '1'" {
                tailf:dependency "../option";
              }
              type enumeration {
                enum DNU {
                  tailf:info "This signal should not be used for synchronization";
                }
                enum EEC1 {
                  tailf:info "ITU-T Option 1: Ethernet equipment clock";
                }
                enum PRC {
                  tailf:info "ITU-T Option 1: Primary reference clock";
                }
                enum PRTC {
                  tailf:info "ITU-T Option 1: Primary reference timing clock";
                }
                enum SEC {
                  tailf:info "ITU-T Option 1: SONET equipment clock";
                }
                enum SSU-A {
                  tailf:info "ITU-T Option 1: Type I or V slave clock";
                }
                enum SSU-B {
                  tailf:info "ITU-T Option 1: Type IV slave clock";
                }
                enum eEEC {
                  tailf:info "ITU-T Option 1: Enhanced ethernet equipment clock";
                }
                enum ePRTC {
                  tailf:info "ITU-T Option 1: Enhanced primary reference timing clock";
                }
              }
            }
            leaf value-opt2 {
              tailf:cli-drop-node-name;
              when "../option = '2'" {
                tailf:dependency "../option";
              }
              type enumeration {

                enum DUS {
                  tailf:info "This signal should not be used for synchronization";
                }
                enum EEC2 {
                  tailf:info "ITU-T Option 2, Generation 1/2: Ethernet equipment clock";
                }
                enum PROV {
                  tailf:info "ITU-T Option 2, Generation 2: Provisionable by the network operator.";
                }
                enum PRS {
                  tailf:info "ITU-T Option 2, Generation 1/2: Primary reference source";
                }
                enum PRTC {
                  tailf:info "ITU-T Option 2, Generation 1/2: Primary reference timing clock";
                }
                enum RES {
                  tailf:info "ITU-T Option 2, Generation 1: Reserved for network synchronization use";
                }
                enum SMC {
                  tailf:info "ITU-T Option 2, Generation 1/2: SONET clock self timed";
                }
                enum ST2 {
                  tailf:info "ITU-T Option 2, Generation 1/2: Stratum 2";
                }
                enum ST3 {
                  tailf:info "ITU-T Option 2, Generation 1/2: Stratum 3";
                }
                enum ST3E {
                  tailf:info "ITU-T Option 2, Generation 2: Stratum 3E";
                }
                enum ST4 {
                  tailf:info "ITU-T Option 2, Generation 1/2: Stratum 4 freerun";
                }
                enum STU {
                  tailf:info "ITU-T Option 2, Generation 1/2: Synchronized - traceability unknown";
                }
                enum TNC {
                  tailf:info "ITU-T Option 2, Generation 2: Transit node clock";
                }
                enum eEEC {
                  tailf:info "ITU-T Option 2, Generation 1/2: Enhanced ethernet equipment clock";
                }
                enum ePRTC {
                  tailf:info "ITU-T Option 2, Generation 1/2: Enhanced primary reference timing clock";
                }
              }
            }
          }
          // gnss-receiver * * / frequency synchronization / quality receive
          container receive {
            tailf:info "Adjust the received quality level";
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            tailf:cli-compact-syntax;
            uses quality-grouping;
          }
          // gnss-receiver * * / frequency synchronization / quality transmit
          container transmit {
            tailf:info "Set the quality level to be transmitted";
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            tailf:cli-compact-syntax;
            uses quality-grouping;
          }
        }
        // gnss-receiver * * / frequency synchronization / selection
        container selection {
          tailf:info "Selection configuration commands";
          leaf input {
            tailf:info "Enable this source for selection";
            type empty;
          }
        }
        // gnss-receiver * * / frequency synchronization / ssm disable
        container ssm {
          tailf:info "SSM configuration commands";
          leaf disable {
            tailf:info "Disable sending of SSMs";
            type empty;
          }
        }
        // gnss-receiver * * / frequency synchronization / time-of-day-priority
        leaf time-of-day-priority {
          tailf:info "Source time-of-day priority";
          type uint8 {
            tailf:info "<1-254>;;Source time-of-day priority";
          }
        }
        // gnss-receiver * * / frequency synchronization / wait-to-restore
        leaf wait-to-restore {
          tailf:info "Set the wait-to-restore time";
          type uint8 {
            tailf:info "<0-12>;;Wait-to-restore time, in minutes";
          }
        }
      }
    }
    // gnss-receiver * * / pdop threshold
    container pdop {
      tailf:info "PDOP threshold configuration";
      leaf threshold {
        tailf:info "PDOP threshold configuration";
        type uint8 {
          tailf:info "<0-10>;;PDOP threshold value";
        }
      }
    }
    // gnss-receiver * * / shutdown
    leaf shutdown {
      tailf:info "Shutdown the GNSS receiver";
      type empty;
    }
    // gnss-receiver * * / snr threshold
    container snr {
      tailf:info "SNR threshold configuration";
      leaf threshold {
        tailf:info "SNR threshold configuration";
        type uint8 {
          tailf:info "<0-40>;;SNR threshold value, in dB-Hz";
        }
      }
    }
    // gnss-receiver * * / traim threshold
    container traim {
      tailf:info "TRAIM threshold configuration";
      leaf threshold {
        tailf:info "TRAIM threshold configuration";
        type uint8 {
          tailf:info "<0-2>;;TRAIM threshold value, in microseconds";
        }
      }
    }
  }


  /// ========================================================================
  /// ospf
  /// ========================================================================

  container ospf {
    tailf:info "Global OSPF configuration commands";
    tailf:cli-explicit-exit;

    // ospf name-lookup
    leaf name-lookup {
      tailf:info "Display OSPF router ids as DNS names";
      type empty;
    }
  }


  /// ========================================================================
  /// router-convergence
  /// ========================================================================

  container router-convergence {
    tailf:info "Configure Router Convergence Monitoring";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-rcmd";
    tailf:cli-explicit-exit;
    presence true;

    // router-convergence / collect-diagnostics *
    list collect-diagnostics {
      tailf:info "Collect diagnostics on specified node";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Specified location";
        }
      }
    }
  }


  /// ========================================================================
  /// router
  /// ========================================================================

  container router {
    tailf:info "Enable a routing process";
    tailf:cli-explicit-exit;

    /// router static
    // router static
    container static {
      tailf:info "Static route configuration subcommands";
      tailf:cli-add-mode;
      uses router-static-grouping;

      // router static / vrf *
      list vrf {
        tailf:info "VRF Static route configuration subcommands";
        tailf:cli-mode-name "config-static-vrf";
        key name;
        leaf name {
          tailf:info "VRF name";
          type string {
            tailf:info "WORD;;VRF name";
          }
        }
        uses router-static-grouping;
      }
    }

    /// router igmp
    // router igmp
    container igmp {
      tailf:info "IPv4 Address Family";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-igmp";
      presence true;
      uses router-igmp-grouping;

      // router igmp / nsf
      container nsf {
        tailf:info "Configure NSF specific options(cisco-support)";
        leaf lifetime {
          tailf:info "Configure maximum time for IGMP NSF mode";
          type uint16 {
            tailf:info "<10-3600>;;Maximum time for IGMP NSF mode in seconds";
          }
        }
      }

      // router igmp / vrf *
      list vrf {
        tailf:info "VRF configs";
        tailf:cli-mode-name "config-igmp-vrf";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Enter VRF name";
          }
        }
        uses router-igmp-grouping;
      }
    }

    /// router isis
    // router isis *
    container isis {
      tailf:info "ISO IS-IS";
      tailf:cli-incomplete-command;
      list tag {
        tailf:cli-drop-node-name;
        tailf:cli-mode-name "config-isis";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;ISO routing area tag";
          }
        }

        // router isis * / apply-group
        uses apply-group-grouping;

        // router isis * / vrf-context
        leaf vrf-context {
          tailf:info "VRF context for this ISIS process";
          type string {
            tailf:info "WORD;;VRF name";
          }
        }

        // router isis * / affinity-map *
        list affinity-map {
          tailf:info "Affinity map configuration";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-incomplete-command;
          key name;
          leaf name {
            tailf:cli-suppress-range;
            tailf:cli-disallow-value "color|name";
            type string {
              tailf:info "WORD;;Affinity attribute name";
            }
          }
          leaf bit-position {
            tailf:info "Bit position for affinity attribute value";
            type uint8 {
              tailf:info "<0-255>;;Bit position";
            }
          }
        }

        // router isis * / flexo-algo *
        list flex-algo {
          tailf:info "Flex Algorithm definition";
          tailf:cli-mode-name "config-isis-flex-algo";
          key id;
          leaf id {
            type uint8 {
              tailf:info "<128-255>;;Algorithm number";
              range "128..255";
            }
          }

          // router isis * / flexo-algo * / priority
          leaf priority {
            tailf:info "Flex-Algo definition priority";
            type uint8 {
              tailf:info "<0-255>;;Priority value";
            }
          }

          // router isis * / flexo-algo * / metric-type delay
          container metric-type {
            tailf:info "Metric-type used by flex-algo calculation";
            choice metric-type-choice {
              leaf delay {
                tailf:info "Use delay as metric";
                type empty;
              }
              leaf te {
                tailf:info "Use Traffic Engineering metric";
                type empty;
              }
            }
          }

          // router isis * / flexo-algo * / advertise-definition
          leaf advertise-definition {
            tailf:info "Advertise the Flex-Algo Definition";
            type empty;
          }

          // router isis * / flexo-algo * / affinity exclude-any *
          container affinity {
            tailf:info "Specify affinity names to exclude";
            leaf-list exclude-any {
              tailf:info "Exclude objects in flex-algo calculation";
              tailf:cli-flat-list-syntax;
              tailf:cli-replace-all;
              type string {
                tailf:info "WORD;;Affinity to exclude";
              }
            }
          }
        }

        // router isis * / set-overload-bit * level
        container set-overload-bit-level {
          tailf:cli-drop-node-name;
          list set-overload-bit {
            tailf:info "Signal other routers not to use us in SPF";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            cli:ned-diff-move-before ">set-overload-bit" {
              cli:arguments "when-delete";
            }
            key level;
            leaf level {
              tailf:info "Set overload-bit for one level only";
              tailf:cli-expose-key-name;
              type uint8 {
                tailf:info "<1-2>;;Level";
                range "1..2";
              }
            }
            leaf on-startup {
              tailf:info "Set overload-bit temporarily after reboot";
              tailf:cli-prefix-key;
              tailf:cli-optional-in-sequence;
              type union {
                type uint32 {
                  tailf:info "<5-86400>;;Time in seconds to advertise ourself as overloaded after reboot";
                  range "5..86400";
                }
                type enumeration {
                  enum wait-for-bgp {
                    tailf:info "Let BGP decide when to unset the overload bit";
                  }
                }
              }
            }
            container advertise {
              tailf:info "If overload-bit set advertise the following types of IP prefixes";
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              leaf external {
                tailf:info "If overload-bit set advertise IP prefixes learned from other protocols";
                type empty;
              }
              leaf interlevel {
                tailf:info "If overload-bit set advertise IP prefixes learned from another ISIS level";
                type empty;
              }
            }
          }
        }

        // router isis * / set-overload-bit
        container set-overload-bit {
          tailf:info "Signal other routers not to use us in SPF";
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-reset-container;
          cli:ned-diff-move-before ">set-overload-bit" {
            cli:arguments "when-delete";
          }
          presence true;
          leaf on-startup {
            tailf:info "Set overload-bit temporarily after reboot";
            tailf:cli-optional-in-sequence;
            type union {
              type uint32 {
                tailf:info "<5-86400>;;Time in seconds to advertise ourself as overloaded after reboot";
                range "5..86400";
              }
              type enumeration {
                enum wait-for-bgp {
                  tailf:info "Let BGP decide when to unset the overload bit";
                }
              }
            }
          }
          container advertise {
            tailf:info "If overload-bit set advertise the following types of IP prefixes";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            leaf external {
              tailf:info "If overload-bit set advertise IP prefixes learned from other protocols";
              type empty;
            }
            leaf interlevel {
              tailf:info "If overload-bit set advertise IP prefixes learned from another ISIS level";
              type empty;
            }
          }

        }

        // router isis * / max-link-metric
        leaf max-link-metric {
          tailf:info "Signal other routers to use us as transit option of last resort";
          tailf:cli-full-command;
          tailf:cli-full-no;
          type empty;
        }

        // router isis * / max-link-metric level *
        container max-link-metric-level {
          tailf:cli-drop-node-name;
          container max-link-metric {
            tailf:info "Signal other routers to use us as transit option of last resort";
            tailf:cli-incomplete-command;
            tailf:cli-incomplete-no;
            list level {
              tailf:info "Set Max Link Metric for one level only";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key id;
              leaf id {
                type uint8 {
                  tailf:info "<1-2>;;Level";
                  range "1..2";
                }
              }
            }
          }
        }

        // router isis * / hostname dynamic disable
        container hostname {
          tailf:info "Dynamic hostname resolution for show/debug output";
          container dynamic {
            tailf:info "Dynamic hostname resolution";
            leaf disable {
              tailf:info "Disable dynamic hostname resolution";
              type empty;
            }
          }
        }

        // router isis * / is-type
        leaf is-type {
          tailf:info "IS Level for this routing process (OSI only)";
          type enumeration {
            enum level-1 {
              tailf:info "Act as a station router only";
            }
            enum level-1-2 {
              tailf:info "Act as both a station router and an area router";
            }
            enum level-2-only {
              tailf:info "Act as an area router only";
            }
          }
        }

        // router isis * / net *
        list net {
          tailf:info "A Network Entity Title for this process (OSI only)";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key id;
          leaf id {
            type string {
              tailf:info "XX.XXXX. ... .XXX.XX;;Network entity title (NET)";
            }
          }
        }

        // router isis * / segment-routing global-block
        container segment-routing {
          tailf:info "IS-IS segment-routing configuration";
          container global-block {
            tailf:info "MPLS label range for SID allocation";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf lower-bound {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint32 {
                tailf:info "<16000-1048574>;;The lower bound of the SRGB";
                range "16000..1048574";
              }
            }
            leaf upper-bound {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<16001-1048575>;;The upper bound of the SRGB";
                range "16001..1048575";
              }
            }
          }
        }

        // router isis * / nsf
        container nsf {
          tailf:info "Non-stop forwarding";
          choice nsf-choice {
            container advertise {
              tailf:info "Send information to neighbors";
              leaf holdtime {
                tailf:info "Adjust holdtime advertised in IIH when RR set";
                type uint16 {
                  tailf:info "<5-3600>;;Seconds";
                  range "5..3600";
                }
              }
            }
            leaf cisco {
              tailf:info "Checkpoint method";
              type empty;
            }
            leaf ietf {
              tailf:info "IETF method";
              type empty;
            }
            container interface {
              tailf:info "Interface properties";
              leaf wait {
                tailf:info "Maximum time to wait for interface up";
                type uint8 {
                  tailf:info "<1-60>;;Seconds";
                  range "1..60";
                }
              }
            }
            leaf interval {
              tailf:info "Minimum required stable interval between restarts";
              type uint16 {
                tailf:info "<0-1440>;;Minutes";
                range "0..1440";
              }
            }
            container t3 {
              tailf:info "Time to set overload-bit if LSPDB synchronization not completed (T3 expiration)";
              choice t3-choice {
                leaf adjacency {
                  tailf:info "Use minimum advertised adjacency holdtime for NSF T3 timeout";
                  type empty;
                }
                leaf manual {
                  tailf:info "Manually configure NSF T3 timeout";
                  type uint16 {
                    tailf:info "<5-3600>;;Seconds";
                    range "5..3600";
                  }
                }
              }
            }
          }

          // router isis * / nsf lifetime
          leaf lifetime {
            tailf:info "Maximum route lifetime following restart (seconds)";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<5-300>;;second";
              range "5..300";
            }
          }

          // router isis * / nsf interface-timer
          leaf interface-timer {
            tailf:info "Timer used to wait for a restart ACK (seconds)";
            type uint8 {
              tailf:info "<1-20>;;seconds";
              range "1..20";
            }
          }

          // router isis * / nsf interface-expires
          leaf interface-expires {
            tailf:info "# of times T1 can expire waiting for the restart ACK";
            type uint8 {
              tailf:info "<1-10>;;expiry count";
              range "1..10";
            }
          }
        }

        // router isis * / nsr
        leaf nsr {
          tailf:info "Enable NSR";
          tailf:cli-full-command;
          type empty;
        }

        // router isis * / distribute
        container distribute {
          tailf:info "Distribute routing information to external services";

          // router isis * / distribute link-state
          container link-state {
            tailf:info "Distribute the link-state database to external services";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            tailf:cli-delete-when-empty;
            presence true;
            leaf instance-id {
              tailf:info "Set distribution process instance identifier";
              tailf:cli-optional-in-sequence;
              type uint16 {
                tailf:info "<2-65535>;;Instance ID";
                range "2..65535";
              }
            }

            leaf level {
              tailf:info "Set distribution for one level only";
              tailf:cli-optional-in-sequence;
              type uint8 {
                tailf:info "<1-2>;;Level";
                range "1..2";
              }
            }

            leaf throttle {
              tailf:info "Set throttle update in seconds";
              type uint8 {
                tailf:info "<1-20>;;Seconds";
                range "1..20";
              }
            }
          }

          // router isis * / distribute bgp-ls
          container bgp-ls {
            tailf:info "Set external routing service to BGP-LS";
            tailf:cli-compact-syntax;
            leaf instance-id {
              tailf:info "Set distribution process instance identifier";
              type uint32 {
                tailf:info "<32-4294967295>;;Instance ID";
                range "32..4294967295";
              }
            }
            leaf level {
              tailf:info "Set distribution for one level only";
              type uint8 {
                tailf:info "<1-2>;;Level";
                range "1..2";
              }
            }
            leaf throttle {
              tailf:info "Set throttle update in seconds";
              type uint8 {
                tailf:info "<5-20>;;Seconds";
                range "5..20";
              }
            }
          }
        }

        // router isis * / log
        container log {
          tailf:info "Log changes in adjacency state";
          container adjacency {
            tailf:info "Enable logging of adjacency state";
            leaf changes {
              tailf:info "Enable logging adjacency state changes";
              type empty;
            }
          }
          container pdu {
            tailf:info "Enable PDU logging";
            leaf drops {
              tailf:info "Enable logging PDU drops";
              type empty;
            }
          }
        }

        // router isis * / trace
        container trace {
          tailf:info "Set trace buffer parameters";

          // router isis * / trace mode
          leaf mode {
            tailf:info "Set tracing type";
            type enumeration {
              enum off {
                tailf:info "No tracing";
              }
              enum basic {
                tailf:info "Basic tracing (less overhead)";
              }
              enum enhanced {
                tailf:info "Enhanced tracing (more overhead)";
              }
            }
            default basic;
          }
        }

        // router isis * / lsp-gen-interval * level 1
        container lsp-gen-interval-1 {
          tailf:cli-drop-node-name;
          container lsp-gen-interval {
            tailf:info "System and Pseudonode LSP generation scheduling parameters";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            uses router-isis-lsp-gen-interval-level-grouping;
            leaf level {
              tailf:info "Set LSP generation interval for one level only";
              type enumeration {
                enum 1 {
                  tailf:info "Level 1";
                }
              }
            }
          }
        }

        // router isis * / lsp-gen-interval * level 2
        container lsp-gen-interval-2 {
          tailf:cli-drop-node-name;
          container lsp-gen-interval {
            tailf:info "System and Pseudonode LSP generation scheduling parameters";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            uses router-isis-lsp-gen-interval-level-grouping;
            leaf level {
              tailf:info "Set LSP generation interval for one level only";
              type enumeration {
                enum 2 {
                  tailf:info "Level 2";
                }
              }
            }
          }
        }

        // router isis * / lsp-gen-interval
        container lsp-gen-interval {
          tailf:info "System and Pseudonode LSP generation scheduling parameters";
          tailf:cli-compact-syntax;
          leaf maximum-wait {
            tailf:info "Maximum delay before generating an LSP";
            type uint32 {
              tailf:info "<0-120000>;;Delay in milliseconds";
              range "0..120000";
            }
          }
          leaf initial-wait {
            tailf:info "Initial delay before generating an LSP";
            type uint32 {
              tailf:info "<0-120000>;;Delay in milliseconds";
              range "0..120000";
            }
          }
          leaf secondary-wait {
            tailf:info "Secondary delay before generating an LSP";
            type uint32 {
              tailf:info "<0-120000>;;Delay in milliseconds";
              range "0..120000";
            }
          }
        }

        // router isis * / lsp-check-interval
        leaf lsp-check-interval {
          tailf:info "Set LSP checksum check interval(cisco-support)";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<10-65535>;;LSP checksum check interval time in seconds";
            range "10..65535";
          }
        }

        // router isis * / lsp-refresh-interval
        leaf lsp-refresh-interval {
          tailf:info "Set LSP refresh interval";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<1-65535>;;LSP refresh time in seconds";
            range "1..65535";
          }
        }

        // router isis * / lsp-mtu
        leaf lsp-mtu {
          tailf:info "Set maximum LSP size";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<128-4352>;;Max LSP size in bytes";
            range "128..4352";
          }
        }

        // router isis * / lsp-password
        container lsp-password {
          tailf:info "Configure the area password";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-all-siblings;
          }
          leaf auth-type {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            tailf:cli-optional-in-sequence;
            type enumeration {
              enum hmac-md5 {
                tailf:info "Use HMAC-MD5 authentication";
              }
              enum text {
                tailf:info "Use cleartext password authentication";
              }
            }
          }
          leaf enc-type {
            tailf:info "The encryption type";
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            type enumeration {
              enum clear {
                tailf:info "Specifies an unencrypted password will follow";
              }
              enum encrypted {
                tailf:info "Specifies an encrypted password will follow";
              }
            }
          }
          choice password-choice {
            leaf password {
              tailf:cli-drop-node-name;
              tailf:cli-reset-container;
              tailf:cli-disallow-value "keychain|text|hmac-md5|text|clear|encrypted";
              cli:secret " lsp-password \\S+ <SECRET>";
              type NEDCOM_SECRET_TYPE {
                tailf:info "WORD;;The unencrypted (clear text) LSP/SNP password";
              }
            }
            leaf keychain {
              tailf:info "Specifies a Key Chain name will follow";
              tailf:cli-reset-container;
              tailf:cli-suppress-leafref-in-diff;
              tailf:non-strict-leafref {
                path "/cisco-ios-xr:key/chain/name";
              }
              type string {
                tailf:info "WORD;;The Key Chain name";
              }
            }
          }
          leaf level {
            tailf:cli-break-sequence-commands;
            tailf:info "Set lsp-password for one level only";
            type uint8 {
              tailf:info "<1-2>;;Set lsp-password for LSPs/SNPs at this level only";
              range "1..2";
            }
          }
          leaf snp {
            tailf:info "Specify SNP packets authentication mode";
            type empty;
          }
          leaf send-only  {
            tailf:info "Authenticate outgoing LSPs/SNPs only";
            type empty;
          }
        }

        // router isis * / max-lsp-lifetime
        leaf max-lsp-lifetime {
          tailf:info "Set maximum LSP lifetime";
          type uint16 {
            tailf:info "<1-65535>;;Maximum LSP lifetime in seconds";
            range "1..65535";
          }
        }

        // router isis * / purge-transmit strict
        container purge-transmit {
          tailf:info "Control TLVs permitted in purge LSP";
          container strict {
            tailf:info "Only authentication TLV is allowed";
            tailf:cli-reset-container;
            tailf:cli-delete-when-empty;
            presence true;
            leaf level {
              tailf:cli-drop-node-name;
              type enumeration {
                enum level-1 {
                  tailf:info "Apply for Level-1 only";
                }
                enum level-2 {
                  tailf:info "Apply for Level-2 only";
                }
              }
            }
          }
        }

        // router isis * / receive application flex-algo delay app-only
        container receive {
          tailf:info "Control if ASLA takes precedence over Legacy";
          container application {
            tailf:info "Select Application";
            container flex-algo {
              tailf:info "Flex-Algo Applciation";
              container delay {
                tailf:info "Unidirectionial Min Delay metric";
                leaf app-only {
                  tailf:info "ASLA to take precedence";
                  type empty;
                }
              }
            }
          }
        }

        // router isis * / address-family
        container address-family {
          tailf:info "Enter the IS-IS address-family configuration submode";

          // router isis * / address-family ipv4
          container ipv4 {
            tailf:info "IPV4 address family";

            // router isis * / address-family ipv4 unicast
            container unicast {
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-isis-af";
              presence true;
              uses router-isis-common-grouping;
              uses router-isis-common-af-grouping;
              uses router-isis-af-grouping;
            }

            // router isis * / address-family ipv4 multicast
            container multicast {
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-isis-af";
              presence true;
              uses router-isis-common-grouping;
              uses router-isis-common-af-grouping;
              uses router-isis-af-grouping;
            }
          }

          // router isis * / address-family ipv6
          container ipv6 {
            tailf:info "IPV6 address family";

            // router isis * / address-family ipv6 unicast
            container unicast {
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-isis-af";
              presence true;
              uses router-isis-common-grouping;
              uses router-isis-common-af-grouping;
              uses router-isis-af-grouping;
            }

            // router isis * / address-family ipv6 multicast
            container multicast {
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-isis-af";
              presence true;
              uses router-isis-common-grouping;
              uses router-isis-common-af-grouping;
              uses router-isis-af-grouping;
            }
          }
        }

        // router isis * / interface *
        list interface {
          tailf:info "Enter the IS-IS interface configuration submode";
          tailf:cli-mode-name "config-isis-if";
          key name;
          leaf name {
            cisco-ios-xr:if-strict-name;
            type string {
              tailf:info "WORD;;Interface Name";
            }
          }

          // router isis / interface * / apply-group
          uses apply-group-grouping;

          // router isis / interface * / interface-type
          leaf interface-type {
            tailf:cli-drop-node-name;
            tailf:cli-full-command;
            type enumeration {
              enum active {
              }
              enum passive {
                tailf:info "Do not establish adjacencies over this interface";
              }
              enum suppressed {
                tailf:info "Do not advertise connected prefixes of this interface";
              }
              enum shutdown {
                tailf:info "Shutdown IS-IS on this interface";
              }
            }
          }

          // router isis / interface * / circuit-type
          leaf circuit-type {
            tailf:info "Configure circuit type for interface";
            type enumeration {
              enum level-1 {
                tailf:info "Form level-1 adjacencies only";
              }
              enum level-1-2 {
                tailf:info "Form level-1 and level-2 adjacencies";
              }
              enum level-2-only {
                tailf:info "Form level-2 adjacencies only";
              }
            }
          }

          // router isis / interface * / bfd
          container bfd {
            tailf:info "Configure BFD parameters";

            // router isis / interface * / bfd minimum-interval
            leaf minimum-interval {
              tailf:info "Hello interval";
              tailf:cli-full-command;
              type uint16 {
                tailf:info "<3-30000>;;hello interval in milli-seconds";
              }
            }

            // router isis / interface * / bfd multiplier
            leaf multiplier {
              tailf:info "Detect multiplier";
              tailf:cli-full-command;
              type uint16 {
                tailf:info "<2-50>;;Detect multiplier";
              }
            }

            // router isis / interface * / bfd fast-detect
            container fast-detect {
              tailf:info "Enable Fast detection";
              // router isis / interface * / bfd fast-detect ipv4
              leaf ipv4 {
                tailf:info "Address Family";
                type empty;
              }
              // router isis / interface * / bfd fast-detect ipv6
              leaf ipv6 {
                tailf:info "Address Family";
                type empty;
              }
            }
          }

          // router isis / interface * / priority
          leaf priority {
            tailf:info "Set priority for Designated Router election";
            type uint8 {
              tailf:info "<0-127>;;Priority value";
              range "0..127";
            }
          }

          // router isis / interface * / point-to-point
          leaf point-to-point {
            tailf:info "Treat active LAN interface as point-to-point";
            tailf:cli-full-command;
            type empty;
          }

          // router isis * / interface * / lsp-interval
          container lsp-interval {
            tailf:info "Set LSP transmission interval";

            // router isis * / interface * / lsp-interval
            leaf milliseconds {
              tailf:cli-drop-node-name;
              tailf:cli-full-command;
              type uint32 {
                tailf:info "<1-4294967295>;;LSP transmission interval (milliseconds)";
                range "1..4294967295";
              }
            }

            // router isis / interface * / lsp-interval ? level *
            list lsp-number-level {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              key level;
              leaf level {
                tailf:info "set lsp-interval for this level";
                tailf:cli-expose-key-name;
                type uint8 {
                  tailf:info "<1-2>;;Set lsp-interval at this level only";
                  range "1..2";
                }
              }
              leaf milliseconds {
                tailf:cli-drop-node-name;
                tailf:cli-prefix-key;
                type uint32 {
                  tailf:info "<1-4294967295>;;LSP transmission interval (milliseconds)";
                  range "1..4294967295";
                }
              }
            }
          }

          // router isis * / interface * / csnp-interval
          container csnp-interval {
            tailf:info "Set CSNP interval";

            // router isis / interface * / csnp-interval
            leaf csnp-number {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<0-65535>;;CSNP interval value (seconds)";
              }
            }

            // router isis / interface * / csnp-interval ? level *
            list csnp-number-level {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              key level;
              leaf level {
                tailf:info "Set the CSNP interval only at the supplied level";
                tailf:cli-expose-key-name;
                type uint8 {
                  tailf:info "<1-2>;;Set lsp fast-flood threshold at this level only";
                  range "1..2";
                }
              }
              leaf csnp-number {
                tailf:cli-drop-node-name;
                tailf:cli-prefix-key;
                type uint16 {
                  tailf:info "<0-65535>;;CSNP interval value (seconds)";
                }
              }
            }
          }

          // router isis * / interface * / hello-interval
          leaf hello-interval {
            tailf:info "Set Hello interval in seconds";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<1-65535>;;Hello interval value";
            }
            default 10;
          }

          // router isis / interface * / hello-padding
          leaf hello-padding {
            tailf:info "Add padding to IS-IS hello packets";
            tailf:cli-full-command;
            type enumeration {
              enum disable {
                tailf:info "Disable hello-padding";
              }
              enum enable {
                tailf:info "Enable hello-padding during adjacency formation only";
              }
              enum sometimes {
                tailf:info "Enable hello-padding during adjacency formation only";
              }
            }
          }

          // router isis / interface * / hello-password
          container hello-password {
            tailf:info "Configure the IIH password";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            cli:secret " (?:hmac-md5|text|accept) <SECRET>";
            choice authentication-choice {
              leaf keychain {
                tailf:info "Specifies a Key Chain name will follow";
                tailf:cli-optional-in-sequence;
                tailf:cli-disallow-value "keychain|accept|hmac-md5|text|clear|encrypted";
                type string {
                  tailf:info "WORD;;The Key Chain name";
                }
              }
              leaf accept {
                tailf:info "Use password for incoming authentication only";
                tailf:cli-optional-in-sequence;
                type empty;
              }
              leaf hmac-md5 {
                tailf:info "Use HMAC-MD5 authentication";
                tailf:cli-optional-in-sequence;
                type empty;
              }
              leaf text {
                tailf:info "Use cleartext password authentication";
                tailf:cli-optional-in-sequence;
                type empty;
              }
            }
            choice password-choice {
              leaf clear {
                tailf:info "Specifies an unencrypted password will follow";
                tailf:cli-optional-in-sequence;
                type NEDCOM_SECRET_TYPE {
                  tailf:info "WORD;;The unencrypted (clear text) hello password";
                }
              }
              leaf encrypted {
                tailf:info "Specifies an encrypted password will follow";
                tailf:cli-optional-in-sequence;
                type string {
                  tailf:info "WORD;;The encrypted hello password";
                }
              }
              leaf password {
                tailf:cli-drop-node-name;
                tailf:cli-optional-in-sequence;
                tailf:cli-disallow-value "keychain|accept|hmac-md5|text|clear|encrypted|level|send-only";
                type NEDCOM_SECRET_TYPE {
                  tailf:info "WORD;;The unencrypted (clear text) hello password";
                }
              }
            }
            leaf level {
              tailf:info "Set hello-password for one level only";
              tailf:cli-optional-in-sequence;
              type uint8 {
                tailf:info "<1-2>;;Set hello-password for IIHs at this level only";
                range "1..2";
              }
            }
            leaf send-only {
              tailf:info "Do not require authentication of incoming IIHs";
              type empty;
            }
          }

          // router isis / interface * / hello-multiplier
          container hello-multiplier {
            tailf:info "Set multiplier for Hello holding time";

            // router isis / interface * / hello-multiplier
            leaf value {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<3-1000>;;Hello multiplier value";
                range "3..1000";
              }
            }
          }

          // router isis / interface * / lsp fast-flood threshold
          container lsp {
            tailf:info "LSP configuration";
            container fast-flood {
              tailf:info "LSP fast flood configuration";
              container threshold {
                tailf:info "Set LSP transmission fast flood threshold";

                // router isis / interface * / lsp fast-flood threshold
                leaf lsp-number {
                  tailf:cli-drop-node-name;
                  type uint32 {
                    tailf:info "<1-4294967295>;;Number of LSPs to send back to back";
                    range "1..4294967295";
                  }
                }

                // router isis / interface * / lsp fast-flood threshold ? level *
                list lsp-number-level {
                  tailf:cli-drop-node-name;
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  tailf:cli-compact-syntax;
                  tailf:cli-sequence-commands;
                  key level;
                  leaf level {
                    tailf:info "Set lsp fast-flood threshold for this level";
                    tailf:cli-expose-key-name;
                    type uint8 {
                      tailf:info "<1-2>;;Set lsp fast-flood threshold at this level only";
                      range "1..2";
                    }
                  }
                  leaf lsp-number {
                    tailf:cli-drop-node-name;
                    tailf:cli-prefix-key;
                    type uint32 {
                      tailf:info "<1-4294967295>;;Number of LSPs to send back to back";
                      range "1..4294967295";
                    }
                  }
                }
              }
            }
          }

          // router isis / interface * / link-down
          container link-down {
            tailf:info "Configure interface down event parameters";
            leaf fast-detect {
              tailf:info "Enable high priority detection";
              type empty;
            }
          }

          // router isis / interface * / retransmit-interval
          container retransmit-interval {
            tailf:info "Interval between retransmissions of the same LSP";
            leaf milliseconds {
              tailf:cli-drop-node-name;
              tailf:cli-full-command;
              type uint16 {
                tailf:info "<0-65535>;;(milliseconds)";
              }
            }
            // router isis / interface * / retransmit-interval ? level 1
            // router isis / interface * / retransmit-interval ? level 2
          }

          // router isis / interface * / retransmit-throttle-interval
          container retransmit-throttle-interval {
            tailf:info "Minimum interval betwen retransissions of different LSPs";
            leaf milliseconds {
              tailf:cli-drop-node-name;
              tailf:cli-full-command;
              type uint16 {
                tailf:info "<0-65535>;;(milliseconds)";
              }
            }
            // router isis / interface * / retransmit-throttle-interval ? level 1
            // router isis / interface * / retransmit-throttle-interval ? level 2
          }

          // router isis * / interface * / affinity flex-algo *
          container affinity {
            tailf:info "Application specific interface affinities";
            leaf-list flex-algo {
              tailf:info "Affinities for Flexible Algorithm application";
              tailf:cli-flat-list-syntax;
              tailf:cli-replace-all;
              type string {
                tailf:info "WORD;;Affinity names";
              }
            }
          }

          // router isis * / interface * / delay normalize
          container delay {
            tailf:info "Delay normalization setting";
            container normalize {
              tailf:info "Delay normalization setting";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf interval {
                tailf:info "Normalization interval";
                type uint32 {
                  tailf:info "<1-4294967295>;;Value in microseconds";
                  range "1..4294967295";
                }
              }
              leaf offset {
                tailf:info "Normalization offset";
                type uint32 {
                  tailf:info "<0-4294967295>;;Value in microseconds";
                }
              }
            }
          }
          // router isis / interface * / address-family
          container address-family {
            tailf:info "Enter the IS-IS interface address-family configuration submode";

            // router isis * / interface * / address-family ipv4
            container ipv4 {
              tailf:info "IPV4 address family";

              // router isis * / interface * / address-family ipv4 unicast
              container unicast {
                tailf:cli-add-mode;
                tailf:cli-mode-name "config-isis-if-af";
                presence true;
                uses router-isis-common-af-grouping;
                uses router-isis-if-af-grouping;
              }

              // router isis * / interface * / address-family ipv4 multicast
              container multicast {
                tailf:cli-add-mode;
                tailf:cli-mode-name "config-isis-if-af";
                presence true;
                uses router-isis-common-af-grouping;
                uses router-isis-if-af-grouping;
              }
            }

            // router isis * / interface * / address-family ipv6
            container ipv6 {
              tailf:info "IPV6 address family";

              // router isis * / interface * / address-family ipv6 unicast
              container unicast {
                tailf:cli-add-mode;
                tailf:cli-mode-name "config-isis-if-af";
                presence true;
                uses router-isis-common-af-grouping;
                uses router-isis-if-af-grouping;
              }

              // router isis * / interface * / address-family ipv6 multicast
              container multicast {
                tailf:cli-add-mode;
                tailf:cli-mode-name "config-isis-if-af";
                presence true;
                uses router-isis-common-af-grouping;
                uses router-isis-if-af-grouping;
              }
            }
          }
        }

        // router isis * / authentication
        container authentication {
          tailf:info "ISIS authentication for LSPs";
          container key-chain {
            tailf:info "Authentication key-chain";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf ref {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-leafref-in-diff;
              tailf:non-strict-leafref {
                path "/cisco-ios-xr:key/chain/name";
              }
              type string {
                tailf:info "WORD;;Key-chain name";
              }
            }
            leaf level {
              tailf:cli-drop-node-name;
              type enumeration {
                enum level-1 {
                  tailf:info "ISIS authentication for level-1";
                }
                enum level-2 {
                  tailf:info "ISIS authentication for level-2";
                }
              }
            }
          }
          container mode {
            tailf:info "Authentication mode";
            choice mode-choice {
              container md5 {
                tailf:info "Keyed message digest";
                presence true;
                leaf level {
                  tailf:cli-drop-node-name;
                  type enumeration {
                    enum level-1 {
                      tailf:info "ISIS authentication for level-1";
                    }
                    enum level-2 {
                      tailf:info "ISIS authentication for level-2";
                    }
                  }
                }
              }

              container text {
                tailf:info "Clear text password";
                presence true;
                leaf level {
                  tailf:cli-drop-node-name;
                  type enumeration {
                    enum level-1 {
                      tailf:info "ISIS authentication for level-1";
                    }
                    enum level-2 {
                      tailf:info "ISIS authentication for level-2";
                    }
                  }
                }
              }
            }
          }
          //  send-only  Authentication send only, receive ignore
        }

        // router isis * / bfd
        container bfd {
          tailf:info "BFD configuration commands";
          leaf all-interfaces {
            tailf:info "Enable BFD on all interfaces";
            type empty;
          }
          leaf check-ctrl-plane-failure {
            tailf:info "BFD check control plane failure";
            type empty;
          }
        }

        // router isis * / mpls
        container mpls {
          tailf:info "Configure MPLS routing protocol parameters";

          // router isis * / mpls ldp
          leaf ldp {
            tailf:info "routing protocol commands for MPLS LDP";
            type enumeration {
              enum "sync" {
                tailf:info "Configure LDP-IGP Synchronization";
              }
            }
          }

          // router isis * / mpls traffic-eng
          container traffic-eng {
            tailf:info "routing protocol commands for MPLS Traffic Engineering";
            leaf level-1 {
              tailf:info "Run MPLS TE on IS-IS level 1 only";
              type empty;
            }
            leaf level-2 {
              tailf:info "Run MPLS TE on IS-IS level 2 only";
              type empty;
            }
            leaf multicast-intact {
              tailf:info "MPLS TE and PIM interaction";
              type empty;
            }
            leaf router-id {
              tailf:info "Traffic Engineering stable IP address for system";
              type empty;
            }
            leaf scanner {
              tailf:info "Timer parameters for TE database";
              type empty;
            }
          }
        }

        // router isis * / srlg
        container srlg {
          tailf:info "ISIS SRLG submode";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-isis-srlg";
          presence true;
          // router isis * / admin-weight
          leaf admin-weight {
            tailf:info "Administrative weight for all SRLGs, default is 1000";
            type uint32 {
              tailf:info "<0-16777215>;;Value added to link admin-weight during SRLG-aware path computation";
            }
          }
          // router isis * / srlg / name *
          list name {
            tailf:info "SRLG Name";
            tailf:cli-mode-name "config-isis-srlg-name";
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;SRLG Name";
              }
            }

            // router isis * / srlg / name * / admin-weight
            leaf admin-weight {
              tailf:info "Administrative weight: default inherited from the global admin-weight";
              type uint32 {
                tailf:info "<0-16777215>;;Value added to link admin-weight during SRLG-aware path computation";
                range "0..16777215";
              }
            }
          }
        }

        uses router-isis-common-grouping;
      }
    }

    /// router ospf *
    // router ospf *
    list ospf {
      tailf:info "OSPF configuration subcommands";
      tailf:cli-mode-name "config-ospf";
      key name;
      leaf name {
        tailf:info "Name for this OSPF process";
        type string {
          tailf:info "WORD;;Name for this OSPF process";
        }
      }

      uses router-ospf-authentication-grouping;

      uses router-ospf-grouping;

      // router ospf * / mpls
      container mpls {
        tailf:info "Configure MPLS routing protocol parameters";

        // router ospf * / mpls traffic-eng
        container traffic-eng {
          tailf:info "Routing protocol commands for MPLS Traffic Engineering";

          // router ospf * / mpls traffic-eng router-id
          choice router-id-choice {
            container router-id {
              tailf:info "Traffic Engineering stable IP address for system";
              uses interface-name-grouping;
            }
            container router-id-address {
              tailf:cli-drop-node-name;
              leaf router-id {
                tailf:info "Traffic Engineering stable IP address for system";
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;MPLS TE router-id in IPv4 address format";
                }
              }
            }
          }

          // router ospf * / mpls traffic-eng multicast-intact
          leaf multicast-intact {
            tailf:info "Publish multicast-intact paths to RIB";
            tailf:cli-full-command;
            type empty;
          }

          // router ospf * / mpls traffic-eng autoroute-exclude route-policy
          container autoroute-exclude {
            tailf:info "Exclude IP address destinations from using TE tunnels";
            leaf route-policy {
              tailf:info "Route Policy to exclude TE paths from routes";
              tailf:cli-suppress-leafref-in-diff;
              tailf:non-strict-leafref {
                path "/cisco-ios-xr:route-policy/name";
              }
              type string {
                tailf:info "WORD;;Name of the policy";
              }
            }
          }
        }

        // router ospf * / mpls ldp
        container ldp {
          tailf:info "Configure LDP parameters";

          // router ospf * / mpls ldp sync
          leaf sync {
            tailf:info "Enable LDP IGP synchronization";
            tailf:cli-full-command;
            type empty;
          }

          // router ospf * / mpls ldp auto-config
          leaf auto-config {
            tailf:info "Enable LDP IGP interface auto-configuration";
            tailf:cli-full-command;
            type empty;
          }

          // router ospf * / mpls ldp sync-igp-shortcuts
          leaf sync-igp-shortcuts {
            tailf:info "LDP sync for igp-shortcut tunnels";
            type empty;
          }
        }
      }

      // router ospf * / vrf *
      list vrf {
        tailf:info "Enter the OSPF vrf configuration submode";
        tailf:cli-mode-name "config-ospf-vrf";
        key name;
        leaf name {
          tailf:info "Name for this OSPF vrf";
          type string {
            tailf:info "WORD;;Name for this OSPF vrf";
          }
        }
        // router ospf * / vrf * / authentication
        // router ospf * / vrf * / message-digest-key
        uses router-ospf-authentication-grouping;

        // router ospf * / vrf * / ?
        uses router-ospf-grouping {

          // router ospf * / vrf * / capability vrf-life
          augment capability {
            leaf vrf-lite {
              tailf:info "Enable VRF-lite support";
              type empty;
            }
          }

          augment area {
            list sham-link {
              tailf:info "Define a sham link";
              key "local remote";
              leaf local {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Address of the local sham-link end-point";
                }
              }
              leaf remote {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D  Address of the remote sham-link endpoint";
                }
              }
              leaf cost {
                tailf:info "Sham-link cost";
                type uint16 {
                  tailf:info "<1-65535>;;Cost";
                }
              }
            }
          }
        }

        // router ospf * / vrf * / domain-tag
        leaf domain-tag {
          tailf:info "OSPF domain tag";
          type uint32 {
            tailf:info "<1-4294967295>;;OSPF domain tag - 32-bit value";
            range "1..4294967295";
          }
        }
      }
    }

    /// router ospfv3 *
    // router ospfv3 *
    list ospfv3 {
      tailf:info "IPv6 Open Shortest Path First protocol (OSPFv3)";
      tailf:cli-mode-name "config-ospfv3";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Name for this OSPFv3 process";
        }
      }

      uses router-ospfv3-grouping;

      // router ospfv3 * / stub-router router-lsa *
      container stub-router {
        tailf:info "Enter stub router configuration submode";
        list router-lsa {
          tailf:info "Modify self originated router LSAs";
          tailf:cli-mode-name "config-ospfv3-stub";
          key mode;
          leaf mode {
            type enumeration {
              enum max-metric {
                tailf:info "advertise LSAs with maximum metric";
              }
              enum r-bit {
                tailf:info "advertise LSAs with R-bit cleared";
              }
              enum v6-bit {
                tailf:info "advertise LSAs with V6-bit cleared";
              }
            }
          }
        }
      }

      // router ospfv3 * / vrf *
      list vrf {
        tailf:info "Enter the OSPFv3 vrf configuration submode";
        tailf:cli-mode-name "config-ospfv3-vrf";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name for this OSPFv3 vrf";
          }
        }
        // router ospfv3 * / vrf * / ?
        uses router-ospfv3-grouping {
          augment area {
            list sham-link {
              tailf:info "Define a sham link";
              key "local remote";
              leaf local {
                type inet:ipv6-address {
                  tailf:info "X:X::X;;Address of the local sham-link end-point";
                }
              }
              leaf remote {
                type inet:ipv6-address {
                  tailf:info "X:X::X;;Address of the remote sham-link endpoint";
                }
              }
              leaf cost {
                tailf:info "Sham-link cost";
                type uint16 {
                  tailf:info "<1-65535>;;Cost";
                }
              }
            }
          }
        }
      }
    }

    /// router bgp *
    // router bgp *
    container bgp {
      tailf:info "BGP configuration subcommand";

      // router bgp *
      list bgp-no-instance {
        tailf:cli-drop-node-name;
        tailf:cli-mode-name "config-bgp";
        key id;
        leaf id {
          tailf:cli-suppress-range;
          type union {
            type uint32 {
              tailf:info "<1-4294967295>;;Autonomous system number";
              range "1..4294967295";
            }
            type string {
              tailf:info "<1.0-XX.YY>;;Autonomous system number";
              pattern '[0-9]+\.[0-9]+';
            }
          }
        }
        uses router-bgp-grouping;
      }

      // router bgp * instance
      list bgp-instance {
        tailf:cli-drop-node-name;
        tailf:cli-mode-name "config-bgp";
        key "id instance";
        leaf id {
          tailf:info "Autonomous system number";
          tailf:cli-suppress-range;
          type union {
            type uint32 {
              tailf:info "<1-4294967295>;;Autonomous system number";
              range "1..4294967295";
            }
            type string {
              tailf:info "<1.0-XX.YY>;;Autonomous system number";
              pattern '[0-9]+\.[0-9]+';
            }
          }
        }
        leaf instance {
          tailf:cli-expose-key-name;
          type string {
            tailf:info "WORD;;instance name (maximum length 32 characters)";
          }
        }
        uses router-bgp-grouping;
      }
    }

    /// router mld
    // router mld
    container mld {
      tailf:info "IPv6 address family";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-mld";
      presence true;

      uses router-mld-grouping;

      // router mld / vrf *
      list vrf {
        tailf:info "VRF configs";
        tailf:cli-mode-name "config-mld-vrf";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Enter VRF name";
          }
        }
        uses router-mld-grouping;
      }
    }

    /// router pim
    // router pim
    container pim {
      tailf:info "PIM configuration subcommands";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-pim";
      presence true;

      uses router-pim-grouping;

      // router pim / vrf *
      list vrf {
        tailf:info "VRF configs";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Enter VRF name";
          }
        }
        uses router-pim-grouping;
      }
    }

    /// router rip
    // router rip
    container rip {
      tailf:info "RIP configuration subcommands";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-rip";
      presence true;

      uses router-rip-grouping;

      // router rip / vrf *
      list vrf {
        tailf:info "VRF configs";
        tailf:cli-mode-name "config-rip-vrf";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Enter VRF name";
          }
        }
        uses router-rip-grouping;
      }
    }

    /// router eigrp *
    // router eigrp *
    list eigrp {
      tailf:info "EIGRP configuration subcommands";
      tailf:cli-mode-name "config-eigrp";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;AS number (1 - 65535) or Virtual instance name of the EIGRP process";
        }
      }
      uses router-eigrp-grouping;

      // router eigrp * / vrf *
      list vrf {
        tailf:info "EIGRP VRF configuration submode";
        tailf:cli-mode-name "config-eigrp-vrf";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;VRF name";
          }
        }
        uses router-eigrp-grouping;
      }
    }

    /// router vrrp
    // router vrrp
    container vrrp {
      tailf:info "VRRP configuration subcommands";
      tailf:cli-add-mode;

      // router vrrp / apply-group
      uses apply-group-grouping;

      // router vrrp / interface *
      list interface {
        tailf:cli-mode-name "config-vrrp-if";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Interface Name";
          }
        }

        // router vrrp / interface * / delay minimum
        container delay {
          tailf:info "Set activation delay for vrrp";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf minimum {
            tailf:info "Set minimum delay on every interface up event";
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<0-10000>;;Minimum delay in seconds";
              range "0..10000";
            }
          }
          leaf reload {
            tailf:info "Set reload delay for first interface up even";
            type uint16 {
              tailf:info "<0-10000>;;Reload delay in seconds";
              range "0..10000";
            }
          }
        }

        // router vrrp / interface * / bfd
        container bfd {
          tailf:info "Configure BFD parameters";

          // router vrrp / interface * / bfd minimum-interval
          leaf minimum-interval {
            tailf:info "Hello interval";
            type uint16 {
              tailf:info "<3-30000>;;hello interval in milli-seconds";
              range "3..30000";
            }
          }

          // router vrrp / interface * / bfd multiplier
          leaf multiplier {
            tailf:info "Detect multiplier";
            type uint8 {
              tailf:info "<2-50>;;Detect multiplier";
              range "2..50";
            }
          }
        }

        // router vrrp / interface * / address-family
        container address-family {
          tailf:info "VRRP address family";

          // router vrrp / interface * / address-family ipv4
          container ipv4 {
            tailf:info "IPv4 address family";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-vrrp-address-family";

            // router vrrp / interface * / address-family ipv4 / vrrp *
            list vrrp {
              tailf:cli-mode-name "config-vrrp-virtual-router";
              cisco-ios-xr:mode-delete-redeploy "slave";
              key id;
              leaf id {
                type uint8 {
                  tailf:info "<1-255>;;VRID Virtual Router Identifier";
                  range "1..255";
                }
              }
              leaf slave {
                tailf:info "slave group";
                tailf:cli-hide-in-submode;
                type empty;
              }
              leaf follow {
                tailf:info "Follow specified MGO session";
                type string {
                  tailf:info "WORD;;MGO session";
                }
              }
              uses router-vrrp-if-af4-vrrp-grouping;
            }

            // router vrrp / interface * / address-family ipv4 / vrrp * version 3
            container vrrp-version {
              tailf:cli-drop-node-name;
              list vrrp {
                tailf:cli-mode-name "config-vrrp-virtual-router";
                tailf:cli-incomplete-command;
                key id;
                leaf id {
                  type uint8 {
                    tailf:info "<1-255>;;VRID Virtual Router Identifier";
                    range "1..255";
                  }
                }
                leaf version {
                  tailf:info "VRRP version";
                  tailf:cli-hide-in-submode;
                  tailf:cli-full-command;
                  type uint8 {
                    tailf:info "<3>;;VRID version";
                    range "3";
                  }
                }
                uses router-vrrp-if-af4-vrrp-grouping;
              }
            }
          }

          // router vrrp / interface * / address-family ipv6
          container ipv6 {
            tailf:info "IPv6 address family";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-vrrp-address-family";

            // router vrrp / interface * / address-family ipv6 / vrrp *
            list vrrp {
              tailf:cli-mode-name "config-vrrp-virtual-router";
              key id;
              leaf id {
                type uint8 {
                  tailf:info "<1-255>;;VRID Virtual Router Identifier";
                  range "1..255";
                }
              }
              leaf slave {
                tailf:info "slave group";
                tailf:cli-hide-in-submode;
                type empty;
              }
              leaf follow {
                tailf:info "Follow specified MGO session";
                type string {
                  tailf:info "WORD;;MGO session";
                }
              }

              uses router-vrrp-if-af-vrrp-grouping;

              // router vrrp / interface * / address-family ipv6 / vrrp * / bfd
              container bfd {
                tailf:info "Configure BFD parameters";
                container fast-detect {
                  tailf:info "Enable Fast detection";
                  container peer {
                    tailf:info "Information about VRRP peer for BFD monitoring";
                    leaf ipv6 {
                      tailf:info "BFD peer interface IPv6 address";
                      type inet:ipv6-address {
                        tailf:info "X:X::X;;VRRP BFD remote interface IP address";
                      }
                    }
                  }
                }
              }

              // router vrrp / interface * / address-family ipv6 / vrrp * / address
              container address {
                tailf:info "Enable VRRP and specify IP address(es)";

                // router vrrp / interface * / address-family ipv6 / vrrp * / address global *
                list global {
                  tailf:info "Global VRRP IPv6 address";
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  tailf:cli-compact-syntax;
                  key ip;
                  leaf ip {
                    type inet:ipv6-address {
                      tailf:info "X:X::X;;Set Global VRRP IPv6 address";
                    }
                  }
                }

                // router vrrp / interface * / address-family ipv6 / vrrp * / address linklocal
                leaf linklocal {
                  tailf:info "VRRP IPv6 linklocal address";
                  type union {
                    type inet:ipv6-address {
                      tailf:info "X:X::X;;VRRP IPv6 linklocal address";
                    }
                    type enumeration {
                      enum autoconfig {
                        tailf:info "Autoconfigure the VRRP IPv6 linklocal address";
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    /// router hsrp
    // router hsrp
    container hsrp {
      tailf:info "HSRP configuration subcommands";
      tailf:cli-add-mode;

      // router hsrp / interface *
      list interface {
        tailf:info "VRRP interface configuration subcommands";
        tailf:cli-mode-name "config-hsrp-if";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Interface Name";
          }
        }

        // router hsrp / interface * / hsrp
        container hsrp {
          tailf:info "HSRP configuration";

          // router hsrp / interface * / hsrp X
          uses router-hsrp-old-group-grouping;

          // router hsrp / interface * / hsrp delay
          container delay {
            tailf:info "Set activation delay for hsrp";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf minimum {
              tailf:info "Set minimum delay on every interface up event";
              type uint16 {
                tailf:info "<0-10000>;;Minimum delay in seconds";
                range "0..10000";
              }
            }
            leaf reload {
              tailf:info "Set reload delay for first interface up even";
              type uint16 {
                tailf:info "<0-10000>;;Reload delay in seconds";
                range "0..10000";
              }
            }
          }

          // router hsrp / interface * / hsrp use-bia
          leaf use-bia {
            tailf:info "Use burned-in address";
            tailf:cli-full-command;
            type empty;
          }

          // router hsrp / interface * / hsrp redirects
          container redirects {
            tailf:info "Enable/Disable HSRP filtered ICMP redirects";
            leaf disable {
              tailf:info "Disable HSRP filtered ICMP redirects";
              type empty;
            }
          }

          // router hsrp / interface * / hsrp * X
          list group {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            key id;
            leaf id {
              type uint8 {
                tailf:info "<0-255>;;group number";
              }
            }
            uses router-hsrp-old-group-grouping;
          }
        }

        // router hsrp / interface * / address-family
        container address-family {
          tailf:info "HSRP address family";

          // router hsrp / interface * / address-family ipv4
          container ipv4 {
            tailf:info "IPv4 address family";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-hsrp-ipv4";

            // router hsrp / interface * / address-family ipv4 / hsrp
            container hsrp {
              tailf:info "HSRP group configuration";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-hsrp-gp";
              presence true;
              uses router-hsrp-ipv4-group-grouping;
            }

            // router hsrp / interface * / address-family ipv4 / hsrp *
            container hsrp-version1-list {
              tailf:cli-drop-node-name;
              list hsrp {
                tailf:cli-mode-name "config-hsrp-gp";
                key id;
                leaf id {
                  type uint16 {
                    tailf:info "<0-255>;;group number (version 1 0-255)";
                    range "0..255";
                  }
                }
                uses router-hsrp-ipv4-group-grouping;
              }
            }

            // router hsrp / interface * / address-family ipv4 / hsrp * slave
            container hsrp-slave-list {
              tailf:cli-drop-node-name;
              list hsrp {
                tailf:cli-mode-name "config-hsrp-slave";
                key "id slave";
                leaf id {
                  type uint16 {
                    tailf:info "<0-4095>;;slave group number";
                    range "0..4095";
                  }
                }
                leaf slave {
                  type enumeration {
                    enum slave {
                      tailf:info "slave group";
                    }
                  }
                }
                uses router-hsrp-ipv4-slave-group-grouping;
              }
            }

            // router hsrp / interface * / address-family ipv4 / hsrp version 1
            // router hsrp / interface * / address-family ipv4 / hsrp version 2
            container hsrp-version2 {
              tailf:cli-drop-node-name;
              container hsrp {
                tailf:info "HSRP group configuration";
                list version {
                  tailf:info "HSRP version";
                  tailf:cli-mode-name "config-hsrp-gp";
                  key version;
                  leaf version {
                    type enumeration {
                      enum "1" {}
                      enum "2" {}
                    }
                  }
                  uses router-hsrp-ipv4-group-grouping;
                }
              }
            }

            // router hsrp / interface * / address-family ipv4 / hsrp * version 1
            // router hsrp / interface * / address-family ipv4 / hsrp * version 2
            container hsrp-version2-list {
              tailf:cli-drop-node-name;
              list hsrp {
                tailf:cli-mode-name "config-hsrp-gp";
                key id;
                leaf id {
                  type uint16 {
                    tailf:info "<0-4095>;;group number (version 2 0-4095)";
                    range "0..4095";
                  }
                }
                leaf version {
                  tailf:info "HSRP version";
                  tailf:cli-hide-in-submode;
                  type uint8 {
                    tailf:info "<1-2>;;HSRP version number";
                    range "1..2";
                  }
                }
                uses router-hsrp-ipv4-group-grouping;
              }
            }
          }

          // router hsrp / interface * / address-family ipv6
          container ipv6 {
            tailf:info "IPv6 address family";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-hsrp-ipv6";

            // router hsrp / interface * / address-family ipv6 / hsrp
            container hsrp {
              tailf:info "HSRP group configuration";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-hsrp-gp";
              presence true;
              uses router-hsrp-ipv6-group-grouping;
            }

            // router hsrp / interface * / address-family ipv6 / hsrp *
            container hsrp-version1-list {
              tailf:cli-drop-node-name;
              list hsrp {
                tailf:cli-mode-name "config-hsrp-gp";
                key id;
                leaf id {
                  type uint16 {
                    tailf:info "<0-4095>;;group number (version 1 0-255, version 2 0-4095)";
                    range "0..4095";
                  }
                }
                uses router-hsrp-ipv6-group-grouping;
              }
            }

            // router hsrp / interface * / address-family ipv6 / hsrp * slave
            container hsrp-slave-list {
              tailf:cli-drop-node-name;
              list hsrp {
                tailf:cli-mode-name "config-hsrp-slave";
                key "id slave";
                leaf id {
                  type uint16 {
                    tailf:info "<0-4095>;;slave group number";
                    range "0..4095";
                  }
                }
                leaf slave {
                  type enumeration {
                    enum slave {
                      tailf:info "slave group";
                    }
                  }
                }
                uses router-hsrp-ipv6-slave-group-grouping;
              }
            }

            // router hsrp / interface * / address-family ipv6 / hsrp version 2
            container hsrp-version2 {
              tailf:cli-drop-node-name;
              container hsrp {
                tailf:info "HSRP group configuration";
                list version {
                  tailf:info "HSRP version";
                  tailf:cli-mode-name "config-hsrp-gp";
                  key version;
                  leaf version {
                    type enumeration {
                      enum "2" {}
                    }
                  }
                  uses router-hsrp-ipv6-group-grouping;
                }
              }
            }

            // router hsrp / interface * / address-family ipv6 / hsrp * version 2
            container hsrp-version2-list {
              tailf:cli-drop-node-name;
              list hsrp {
                tailf:cli-mode-name "config-hsrp-gp";
                key "id version";
                leaf id {
                  type uint16 {
                    tailf:info "<0-4095>;;group number (version 1 0-255, version 2 0-4095)";
                    range "0..4095";
                  }
                }
                leaf version {
                  tailf:info "HSRP version";
                  tailf:cli-expose-key-name;
                  type uint8 {
                    tailf:info "<2>;;HSRP version number";
                    range "2";
                  }
                }
                uses router-hsrp-ipv6-group-grouping;
              }
            }
          }
        }
      }
    }

    /// router msdp
    // router msdp
    container msdp {
      tailf:info "MSDP configuration subcommands";
      tailf:cli-add-mode;

      uses router-msdp-grouping;

      // router msdp / vrf *
      list vrf {
        tailf:info "VRF configs";
        tailf:cli-mode-name "config-msdp-vrf";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;VRF name";
          }
        }
        uses router-msdp-grouping;
      }
    }

    /// router rib
    // router rib
    container rib {
      tailf:info "RIB configuration subcommands";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-rib";

      // router rib / address-family
      container address-family {
        tailf:info "RIB address family";

        // router rib / address-family ipv4
        container ipv4 {
          tailf:info "IPv4 address family";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-rib-afi";

          // router rib / address-family ipv4 / rump always-replicate
          container rump {
            tailf:info "RUMP related commands.";
            leaf always-replicate {
              tailf:info "Replicate routes from uRIB to muRIB always.";
              type empty;
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// accounting
  /// ========================================================================

  // accounting
  container accounting {
    tailf:info "Enable accounting";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-acc";
    tailf:cli-explicit-exit;
    presence true;

    // accounting / interfaces
    container interfaces {
      tailf:info "Enable interfaces submode";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-acc-if";
      presence true;

      // accounting / interfaces / segment-routing mpls
      container segment-routing {
        tailf:info "Enable Segment-Routing (SR) accounting";
        container mpls {
          tailf:info "Enable SR MPLS accounting";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-acc-if-sr-mpls";
          presence true;

          // accounting / interfaces / segment-routing mpls / ipv4
          leaf ipv4 {
            tailf:info "Enable IPv4 accounting";
            type empty;
          }

          // accounting / interfaces / segment-routing mpls / ipv6
          leaf ipv6 {
            tailf:info "Enable IPv6 accounting";
            type empty;
          }
        }
      }

      // accounting / interfaces / mpls
      container mpls {
        tailf:info "Enable MPLS accounting";
        tailf:cli-add-mode;
        presence true;
        container ipv4 {
          tailf:info "Enable IPv4 accounting";
          leaf rsvp-te {
            tailf:info "Enable RSVP-TE accounting";
            type empty;
          }
        }
      }
    }
  }


  /// ========================================================================
  /// service-policy
  /// ========================================================================

  container service-policy {
    tailf:info "Configure global service policy";

    // service-policy apply-order
    leaf-list apply-order {
      tailf:info "Configure service policy ordering";
      tailf:cli-flat-list-syntax;
      tailf:cli-replace-all;
      ordered-by user;
      type enumeration {
        enum pbr {
          tailf:info "Policy based routing";
        }
        enum qos {
          tailf:info "Quality of service";
        }
      }
    }
  }


  /// ========================================================================
  /// service-function-chaining
  /// ========================================================================

  container service-function-chaining {
    tailf:info "configure service function chaining";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-service-function-chain";
    tailf:cli-explicit-exit;

    // service-function-chaining / sf *
    list sf {
      tailf:info "service function";
      tailf:cli-mode-name "config-service-function-chain-sf";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;service function name";
        }
      }

      // service-function-chaining / sf * / locator *
      list locator {
        tailf:info "Specify service function locator id";
        tailf:cli-mode-name "config-service-function-chain-sfl";
        key id;
        leaf id {
          type uint8 {
            tailf:info "<1-255>;;Specify locator id";
            range "1..255";
          }
        }

        // service-function-chaining / sf * / locator * transport vxlan-gpe
        container transport {
          tailf:info "Choose SFL transport";
          container vxlan-gpe {
            tailf:info "transport vxlan-gpe";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-service-function-chain-vxl";
            tailf:cli-compact-syntax;
            // service-function-chaining / sf * / locator * transport vxlan-gpe / source-address ipv4 ? destination-address ipv4 ? source-port ? vni ?
            container source-address {
              tailf:info "Local IP address";
              tailf:cli-flatten-container;
              leaf ipv4 {
                tailf:info "setup IPv4  path";
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Local IP address";
                }
              }
            }
            container destination-address {
              tailf:info "Remote IP address";
              tailf:cli-flatten-container;
              leaf ipv4 {
                tailf:info "setup IPv4  path";
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Remote IP address";
                }
              }
            }
            leaf source-port {
              tailf:info "Local port";
              type uint16 {
                tailf:info "<1-65535>;;Enter local port";
                range "1..65535";
              }
            }
            leaf vni {
              tailf:info "vni value";
              type uint16 {
                tailf:info "<1-65535>;;Enter vni value";
                range "1..65535";
              }
            }
          }
        }
      }
    }

    // service-function-chaining / sff *
    list sff {
      tailf:info "service function forwarder";
      tailf:cli-mode-name "config-service-function-chain-sf";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;service function name";
        }
      }

      // service-function-chaining / sff * / locator *
      list locator {
        tailf:info "Specify service function locator id";
        tailf:cli-mode-name "config-service-function-chain-sfl";
        key id;
        leaf id {
          type uint8 {
            tailf:info "<1-255>;;Specify locator id";
            range "1..255";
          }
        }

        // service-function-chaining / sff * / locator * transport vxlan-gpe
        container transport {
          tailf:info "Choose SFL transport";
          container vxlan-gpe {
            tailf:info "transport vxlan-gpe";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-service-function-chain-vxl";
            tailf:cli-compact-syntax;
            // service-function-chaining / sff * / locator * transport vxlan-gpe /
            // .. source-address ipv4 ? destination-address ipv4 ? source-port ? vni ?
            container source-address {
              tailf:info "Local IP address";
              tailf:cli-flatten-container;
              leaf ipv4 {
                tailf:info "setup IPv4  path";
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Local IP address";
                }
              }
            }
            container destination-address {
              tailf:info "Remote IP address";
              tailf:cli-flatten-container;
              leaf ipv4 {
                tailf:info "setup IPv4  path";
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Remote IP address";
                }
              }
            }
            leaf source-port {
              tailf:info "Local port";
              type uint16 {
                tailf:info "<1-65535>;;Enter local port";
                range "1..65535";
              }
            }
            leaf vni {
              tailf:info "vni value";
              type uint16 {
                tailf:info "<1-65535>;;Enter vni value";
                range "1..65535";
              }
            }
          }
        }
      }
    }

    // service-function-chaining / metadata *
    list metadata {
      tailf:info "metadata imposition";
      tailf:cli-mode-name "config-sfc-metadata";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;metadata profile name";
        }
      }

      // service-function-chaining / metadata * / type * format dc-allocation
      list type {
        tailf:info "Specify metadata type";
        tailf:cli-mode-name "config-sfc-metadata-type";
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          type enumeration {
            enum "1" {
              tailf:info "Type 1 metadata";
            }
          }
        }
        leaf format {
          tailf:info "Specify metadata format";
          tailf:cli-hide-in-submode;
          type enumeration {
            enum dc-allocation {
              tailf:info "format dc-allocation";
            }
          }
        }

        // service-function-chaining / metadata * / type * format dc-allocation / tenant-id
        leaf tenant-id {
          tailf:info "Specify tenant id";
          type uint32 {
            tailf:info "<1-16777215>;;Enter 24-bit tenant id";
            range "1..16777215";
          }
        }
      }
    }

    // service-function-chaining / path *
    list path {
      tailf:info "Configure service function path";
      tailf:cli-mode-name "config-service-function-chain-path";
      key id;
      leaf id {
        type uint32 {
          tailf:info "<1-16777215>;;Specify the service function path id";
          range "1..16777215";
        }
      }

      // service-function-chaining / path * / * terminate metadata-disposition ? default-action redirect ipv4 nexthop vrf|?
      list terminate-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          type uint8 {
            tailf:info "<1-255>;;Specify the id of service function";
            range "1..255";
          }
        }
        leaf terminate {
          tailf:info "Configure terminate";
          tailf:cli-incomplete-command;
          type empty;
        }
        leaf metadata-disposition {
          tailf:info "Specify metadata-disposition name";
          tailf:cli-incomplete-command;
          type string {
            tailf:info "WORD;,metadata-disposition name";
          }
        }
        container default-action {
          tailf:info "Configure the default action for service function path";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          container redirect {
            tailf:info "Configure redirect action";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            container ipv4 {
              tailf:info "Enter ipv4 configuration";
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              container nexthop {
                tailf:info "Configure the nexthop action";
                tailf:cli-flatten-container;
                tailf:cli-compact-syntax;
                choice nexthop-choice {
                  leaf address {
                    tailf:cli-drop-node-name;
                    type inet:ipv4-address {
                      tailf:info "A.B.C.D;;IPv4 nexthop address";
                    }
                  }
                  leaf vrf {
                    tailf:info "Enter vrf name for the nexthop";
                    type string {
                      tailf:info "WORD;;Enter VRF name";
                    }
                  }
                }
              }
            }
          }
        }
      }

      // service-function-chaining / path * / * sf *
      list sf-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "id sf";
        leaf id {
          type uint8 {
            tailf:info "<1-255>;;Specify the id of service function";
            range "1..255";
          }
        }
        leaf sf {
          tailf:info "service function";
          tailf:cli-expose-key-name;
          type string {
            tailf:info "WORD;;service function name";
          }
        }
      }

      // service-function-chaining / path * / * sff *
      list sff-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "id sff";
        leaf id {
          type uint8 {
            tailf:info "<1-255>;;Specify the id of service function";
            range "1..255";
          }
        }
        leaf sff {
          tailf:info "service function forwarder";
          tailf:cli-expose-key-name;
          type string {
            tailf:info "WORD;;service function name";
          }
        }
      }
    }

    // service-function-chaining / metadata-disposition *
    list metadata-disposition {
      tailf:info "metadata disposition";
      tailf:cli-mode-name "config-sfc-disposition";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;specify service disposition name";
        }
      }

      // service-function-chaining / metadata-disposition * / type * format dc-allocation
      list type {
        tailf:info "Specify disposition allocation type";
        tailf:cli-mode-name "config-sfc-metadata-type";
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          type enumeration {
            enum "1" {
              tailf:info "Allocation format Type 1";
            }
          }
        }
        leaf format {
          tailf:info "Specify allocation format";
          tailf:cli-hide-in-submode;
          type enumeration {
            enum dc-allocation {
              tailf:info "data center allocation";
            }
          }
        }

        // service-function-chaining / metadata * / type * format dc-allocation / match-entry *
        list match-entry {
          tailf:info "Specify the match entry name";
          tailf:cli-mode-name "config-sfc-disposition-match";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;match-entry name";
            }
          }

          // service-function-chaining / metadata * / type * format dc-allocation / match-entry * / tenant-id
          container tenant-id {
            tailf:info "Specify the tenant-ids";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-sfc-disposition-action";
            tailf:cli-incomplete-command;
            leaf id {
              tailf:cli-drop-node-name;
              tailf:cli-hide-in-submode;
              type uint32 {
                tailf:info "<0-4294967295>;;tenant id";
              }
            }

            // service-function-chaining / metadata * / type * format dc-allocation / match-entry * / tenant-id ? /
            container redirect {
              tailf:info "Configure redirect action";
              container ipv4 {
                tailf:info "Enter ipv4 configuration";
                container nexthop {
                  tailf:info "Configure the nexthop action";
                  choice nexthop-choice {
                    leaf address {
                      tailf:cli-drop-node-name;
                      type inet:ipv4-address {
                        tailf:info "A.B.C.D;;IPv4 nexthop address";
                      }
                    }
                    leaf vrf {
                      tailf:info "Enter vrf name for the nexthop";
                      type string {
                        tailf:info "WORD;;Enter VRF name";
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// bundle-offload
  /// ========================================================================

  // bundle-offload
  container bundle-offload {
    tailf:info "Enable protocol offload over bundle interfaces";
    presence true;
  }


  /// ========================================================================
  /// subscriber
  /// ========================================================================

  container subscriber {
    tailf:info "Subscriber Configuration";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-subscriber";
    tailf:cli-explicit-exit;

    // subscriber / arp
    container arp {
      tailf:info "ARP Subscriber configuration option";

      // subscriber / arp scale-mode-enable
      leaf scale-mode-enable {
        tailf:info "Supressing ARP entry creation on subscribers interfaces";
        type empty;
      }

      // subscriber / arp uncond-proxy-arp-enable
      leaf uncond-proxy-arp-enable {
        tailf:info "Enable unconditional proxy ARP";
        type empty;
      }
    }

    // subscriber / redundancy
    container redundancy {
      tailf:info "Subscriber Redundancy configuration";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-subscr-red";
      presence true;

      // subscriber / redundancy / source-interface
      container source-interface {
        tailf:info "Source Interface for Redundancy Peer Communication";
        uses interface-name-grouping;
      }

      // subscriber / redundancy / group *
      list group {
        tailf:info "Redundancy Group configuration";
        tailf:cli-mode-name "config-subscr-red-group";
        key id;
        leaf id {
          type uint16 {
            tailf:info "<1-500>;;Group ID";
            range "1..500";
          }
        }

        // subscriber / redundancy / group * / description
        uses description-grouping;

        // subscriber / redundancy / group * / preferred-role
        leaf preferred-role {
          tailf:info "Preferred Role for this Group";
          tailf:cli-full-command;
          type enumeration {
            enum master {
              tailf:info "Master Role";
            }
            enum slave {
              tailf:info "Slave Role";
            }
          }
        }

        // subscriber / redundancy / group * / virtual-mac
        leaf virtual-mac {
          tailf:info "Virtual MAC Address for this Group";
          tailf:cli-full-command;
          type string {
            tailf:info "H.H.H;;MAC address";
          }
        }

        // subscriber / redundancy / group * / slave-mode
        leaf slave-mode {
          tailf:info "Slave Mode for this Group";
          tailf:cli-full-command;
          type enumeration {
            enum hot {
              tailf:info "Hot Standby (Default)";
            }
            enum warm {
              tailf:info "Warm Standby";
            }
          }
        }

        // subscriber / redundancy / group * / peer
        container peer {
          tailf:info "Peer config for this Group";

          // subscriber / redundancy / group * / peer ?
          leaf address {
            tailf:cli-drop-node-name;
            tailf:cli-full-command;
            type union {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IPv4 address";
              }
              type inet:ipv6-address {
                tailf:info "X:X::X;;IPv6 address";
              }
            }
          }

          // subscriber / redundancy / group * / peer route-disable
          leaf route-disable {
            tailf:info "Disable route addition on SRG Slave";
            type empty;
          }
        }

        // subscriber / redundancy / group * / core-tracking
        leaf core-tracking {
          tailf:info "Core Tracking Object for this Group";
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;Tracking Object Name";
          }
        }

        // subscriber / redundancy / group * / access-tracking BE102
        leaf access-tracking {
          tailf:info "Access Tracking Object for this Group";
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;Tracking Object Name";
          }
        }

        // subscriber / redundancy / group * / state-control-route
        container state-control-route {
          tailf:info "state control route config for this Group";

          // subscriber / redundancy / group * / state-control-route ipv4 10.253.0.0/16 tag 10
          container ipv4 {
            tailf:info "IPv4 route";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf prefix {
              tailf:cli-drop-node-name;
              type ipv4-prefix {
                tailf:info "A.B.C.D/length;;IPv4 Prefix";
              }
            }
            leaf vrf {
              tailf:info "Set vrf for the route";
              tailf:cli-optional-in-sequence;
              type string {
                tailf:info "WORD;;VRF name";
              }
            }
            leaf tag {
              tailf:info "Set a tag value for the route";
              type uint32 {
                tailf:info "<1-4294967295>;;Tag value";
                range "1..4294967295";
              }
            }
          }

          // subscriber / redundancy / group * / state-control-route ipv6
          container ipv6 {
            tailf:info "IPv6 route";

            // subscriber / redundancy / group * / state-control-route ipv6 iapd
            container iapd {
              tailf:info "IAPD route";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf prefix {
                tailf:cli-drop-node-name;
                type tailf:ipv6-address-and-prefix-length {
                  tailf:info "X:X::X/length;;IPv6 address with prefix-length";
                }
              }
              leaf vrf {
                tailf:info "Set vrf for the route";
                tailf:cli-optional-in-sequence;
                type string {
                  tailf:info "WORD;;VRF name";
                }
              }
              leaf tag {
                tailf:info "Set a tag value for the route";
                type uint32 {
                  tailf:info "<1-4294967295>;;Tag value";
                  range "1..4294967295";
                }
              }
            }
          }
        }

        // subscriber / redundancy / group * / interface-list
        container interface-list {
          tailf:info "List of Interfaces for this Group";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-subscr-red-grp-intf";
          presence true;

          // subscriber / redundancy / group * / interface-list / interface *
          list interface {
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key name;
            leaf name {
              type ifname;
            }
            leaf id {
              tailf:info "Map Identifier";
              type uint16 {
                tailf:info "<1-65535>;;ID for the interface to be mapped on to slave";
              }
            }
          }
        }
      }
    }

    // subscriber / session limit
    container session {
      tailf:info "iEdge Subscriber Management session";
      leaf limit {
        tailf:info "Configure subscriber session limits";
        type uint32 {
          tailf:info "<1-200000>;;Number of sessions";
          range "1..200000";
        }
      }
    }

    // subscriber / pta tcp mss-adjust
    container pta {
      tailf:info "pta subscriber configuration";
      container tcp {
        tailf:info "tcp";
        leaf mss-adjust {
          tailf:info "Set the TCP segment size to be adjusted";
          type uint16 {
            tailf:info "<1280-1536>;;TCP MSS Adjust maximum segment size";
            range "1280..1536";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// traffic-collector
  /// ========================================================================

  // traffic-collector
  container traffic-collector {
    tailf:info "Traffic Collector";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-tc";
    tailf:cli-explicit-exit;
    presence true;

    // traffic-collector / interface *
    list interface {
      tailf:info "Configure an External interface";
      tailf:cli-mode-name "config-tc-if";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Interface Name";
        }
      }
    }

    // traffic-collector / statistics
    container statistics {
      tailf:info "Configure statistics related parameters";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-tc-stat";
      presence true;

      // traffic-collector / statistics / history-size
      leaf history-size {
        tailf:info "Configure statistics history size";
        type uint8 {
          tailf:info "<1-10>;;History size (default is 5)";
          range "1..10";
        }
      }

      // traffic-collector / statistics / collection-interval
      leaf collection-interval {
        tailf:info "Configure statistics collection interval";
        type uint8 {
          tailf:info "1-60;;minutes. Default 1";
          range "1..60";
        }
      }

      // traffic-collector / statistics / history-timeout
      leaf history-timeout {
        tailf:info "Configure statistics history timeout interval";
        type uint16 {
          tailf:info "<0-720>;;Timeout interval (hours, 0 to specify immediate timeout. default is 48)";
        }
      }
    }
  }


  /// ========================================================================
  /// flowspec
  /// ========================================================================

  container flowspec {
    tailf:info "FlowSpec configuration";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-flowspec";
    tailf:cli-explicit-exit;
    presence true;

    // flowspec / local-install interface-all
    container local-install {
      tailf:info "Local installation of flowspec policy";
      leaf interface-all {
        tailf:info "Install flowspec policy on all interfaces";
        type empty;
      }
    }

    container address-family {
      tailf:info "Address Family Identifier Type (IPv4/IPv6)";

      // flowspec / address-family ipv4
      container ipv4 {
        tailf:info "IPv4 flow";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-flowspec-af";

        // flowspec / addres-family ipv4 / local-install interface-all
        container local-install {
          tailf:info "Local installation of flowspec policy";
          leaf interface-all {
            tailf:info "Install flowspec policy on all interfaces";
            type empty;
          }
        }

        // flowspec / address-family ipv4 / service-policy *
        list service-policy {
          tailf:info "Service Policy configuration";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-full-command;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Policy map name";
            }
          }
          leaf type {
            tailf:info "Type of the service policy";
            tailf:cli-prefix-key;
            type enumeration {
              enum pbr {
                tailf:info "PBR policy type";
              }
            }
          }
        }
      }

      // flowspec / address-family ipv6
      container ipv6 {
        tailf:info "IPv6 flow";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-flowspec-af";

        // flowspec / addres-family ipv6 / local-install interface-all
        container local-install {
          tailf:info "Local installation of flowspec policy";
          leaf interface-all {
            tailf:info "Install flowspec policy on all interfaces";
            type empty;
          }
        }
      }
    }
  }


  /// ========================================================================
  /// rsvp
  /// ========================================================================

  container rsvp {
    tailf:info "Global RSVP configuration commands";
    tailf:cli-add-mode;
    tailf:cli-explicit-exit;

    // rsvp / apply-group
    uses apply-group-grouping;

    // rsvp / bandwidth
    container bandwidth {
      tailf:info "Configure RSVP default I/F bandwidth parameters";

      // rsvp / bandwidth rdm percentage
      container rdm {
        tailf:info "Russian Doll Model";
        container percentage {
          tailf:info "Supply bandwidths as percentages of physical link bandwidth";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf max-reservable-bc0 {
            tailf:info "Maximum reservable/BC0";
            type uint16 {
              tailf:info "<0-10000>;;B/W I/F percentage";
              range "0..10000";
            }
          }
          leaf bc1 {
            tailf:info "BC1 pool";
            type uint16 {
              tailf:info "<0-10000>;;B/W I/F percentage";
              range "0..10000";
            }
          }
        }
      }
    }

    // rsvp / authentication
    uses rsvp-authentication-grouping;

    // rsvp / interface *
    list interface {
      tailf:info "Enable RSVP on an interface";
      tailf:cli-mode-name "config-rsvp-if";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Interface Name";
        }
      }

      // rsvp / interface * / authentication
      uses rsvp-authentication-grouping;

      // rsvp / interface * / bandwidth
      container bandwidth {
        tailf:info "Configure RSVP bandwidth parameters";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-delete-when-empty;
        presence true;
        choice bandwidth-choice {
          // rsvp / interface * / bandwidth percentage
          case percentage-case {
            leaf percentage {
              tailf:info "Supply bandwidths as percentages of physical link bandwidth";
              tailf:cli-incomplete-command;
              type empty;
            }
            leaf total-reservable-percent {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<0-10000>;;Total reservable bandwidth as percentage of physical link bandwidth";
                range "0..10000";
              }
            }
            leaf largest-reservable-flow {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<0-10000>;;Largest reservable flow as percentage of physical link bandwidth";
                range "0..10000";
              }
            }
          }

          // rsvp / interface * / bandwidth global-pool *
          case rsvp-case {
            leaf global-pool {
              tailf:info "Global pool";
              tailf:cli-optional-in-sequence;
              type empty;
            }
            leaf total-reservable {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<0-4294967295>;;Total reservable bandwidth (in Kbps, Mbps or Gbps)";
              }
            }
            leaf total-reservable-unit {
              tailf:cli-drop-node-name;
              tailf:cli-optional-in-sequence;
              when "../total-reservable" {
                tailf:dependency "../total-reservable";
              }
              type enumeration {
                enum Gbps {
                  tailf:info "BW in Gbps";
                }
                enum Kbps {
                  tailf:info "BW in Kbps (Default)";
                }
                enum Mbps {
                  tailf:info "BW in Mbps";
                }
              }
            }
            leaf largest-reservable {
              tailf:cli-drop-node-name;
              tailf:cli-optional-in-sequence;
              type uint32 {
                tailf:info "<0-4294967295>;;Largest reservable flow (in Kbps, Mbps or Gbps)";
              }
            }
            leaf largest-reservable-unit {
              tailf:cli-drop-node-name;
              tailf:cli-optional-in-sequence;
              when "../largest-reservable" {
                tailf:dependency "../largest-reservable";
              }
              type enumeration {
                enum Gbps {
                  tailf:info "BW in Gbps";
                }
                enum Kbps {
                  tailf:info "BW in Kbps (Default)";
                }
                enum Mbps {
                  tailf:info "BW in Mbps";
                }
              }
            }
            leaf sub-pool {
              tailf:info "Reservable bandwidth in sub-pool";
              type uint32 {
                tailf:info "<0-4294967295>;;Reservable bandwidth in sub-pool (in Kbps, Mbps or Gbps)";
              }
            }
          }

          // rsvp / interface * / bandwidth rdm
          case rdm-case {
            container rdm {
              tailf:info "Russian Doll Model";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf bc0 {
                tailf:info "BC0 pool";
                type uint32 {
                  tailf:info "<0-4294967295>;;Total reservable bandwidth";
                }
              }
              leaf largest-reservable-flow {
                tailf:cli-drop-node-name;
                tailf:cli-optional-in-sequence;
                type uint32 {
                  tailf:info "<0-4294967295>;;Largest reservable flow";
                }
              }
              leaf bc1 {
                tailf:info "BC1 pool";
                type uint32 {
                  tailf:info "<0-4294967295>;;Reservable bandwidth in sub-pool";
                }
              }
            }
          }
        }
      }

      // rsvp / interface * / signalling
      container signalling {
        tailf:info "Configure RSVP signalling parameters";

        // rsvp / interface * / signalling dscp
        leaf dscp {
          tailf:info "Set DSCP for RSVP signalling messages";
          type uint8 {
            tailf:info "<0-63>;;Differentiated Services Code Point (DSCP)";
            range "0..63";
          }
        }

        // rsvp / interface * / signalling hello graceful-restart interface-based
        container hello {
          tailf:info "Configure Hello parameters";
          container graceful-restart {
            tailf:info "Configure Graceful-Restart Hello parameters";
            leaf interface-based {
              tailf:info "Configure Interface-based Hello";
              type empty;
            }
          }
        }

        // rsvp / interface * / signalling refresh
        container refresh {
          tailf:info "Configure refresh options";

          // rsvp / interface * / signalling refresh interval
          leaf interval {
            tailf:info "Set interval between successive refreshes";
            type uint8 {
              tailf:info "<10-180>;;Refresh interval (seconds)";
              range "10..180";
            }
          }

          // rsvp / interface * / signalling refresh reduction
          container reduction {
            tailf:info "Configure refresh reduction options";

            // rsvp / interface * / signalling refresh reduction disable
            leaf disable {
              tailf:info "Disable refresh reduction";
              type empty;
            }

            // rsvp / interface * / signalling refresh reduction reliable
            container reliable {
              tailf:info "Configure refresh reduction reliability options";

              // rsvp / interface * / signalling refresh reduction reliable summary-refresh
              leaf summary-refresh {
                tailf:info "Configure use of reliable messaging for summary refresh";
                type empty;
              }

              // rsvp / interface * / signalling refresh reduction reliable ack-max-size
              leaf ack-max-size {
                tailf:info "Set max size of a single RSVP ACK message";
                type uint16 {
                  tailf:info "<20-65000>  Max size of an ACK message (bytes)";
                }
              }

              // rsvp / interface * / signalling refresh reduction reliable ack-hold-time
              leaf ack-hold-time {
                tailf:info "Set hold time for sending RSVP ACK message(s)";
                type uint16 {
                  tailf:info "<100-5000>;ACK message hold time (milliseconds)";
                }
              }

              // rsvp / interface * / signalling refresh reduction reliable retransmit-time
              leaf retransmit-time {
                tailf:info "Set min delay to wait for an ACK before a retransmit";
                type uint16 {
                  tailf:info "<100-10000>;;Min time before RSVP messages retransmit (milliseconds)";
                }
              }
            }
          }
        }

        // rsvp / interface * / signalling rate-limit
        container rate-limit {
          tailf:info "Configure message rate limit (pacing) options";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-delete-when-empty;
          presence true;
          leaf rate {
            tailf:info "Set message rate";
            type uint16 {
              tailf:info "<1-500>;;Number of messages to be sent per interval";
              range "1..500";
            }
          }
          leaf interval {
            tailf:info "Set scheduling interval";
            type uint16 {
              tailf:info "<250-2000>;;Size of an interval (milliseconds)";
              range "250..2000";
            }
          }
        }
      }
    }

    // rsvp / logging
    container logging {
      tailf:info "RSVP logging configuration";

      // rsvp / logging events
      container events {
        tailf:info "Global logging events";

        leaf issu {
          tailf:info "Enable ISSU Status Logging";
          tailf:cli-full-command;
          type empty;
        }
        leaf nsr {
          tailf:info "Enable NSR Status Logging";
          tailf:cli-full-command;
          type empty;
        }
      }
    }

    // rsvp / neighbor *
    list neighbor {
      tailf:info "Configure RSVP neighbors for RSVP authentication";
      tailf:cli-mode-name "config-rsvp-nbr";
      key address;
      leaf address {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;IPv4 address of neighbor";
        }
      }

      // rsvp / neighbor * / authentication
      uses rsvp-authentication-grouping;
    }

    // rsvp / controller *
    list controller {
      tailf:info "Enable RSVP on controller";
      tailf:cli-mode-name "config-rsvp-cntl";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Controller Name";
        }
      }

      // rsvp / controller * / signalling refresh out-of-band
      container signalling {
        tailf:info "Configure global RSVP signalling parameters";
        container refresh {
          tailf:info "Configure refresh options";
          container out-of-band {
            tailf:info "Configure refresh options for out-of-band tunnels";
            leaf interval {
              tailf:info "Set interval between successive refreshes";
              type uint32 {
                tailf:info "<180-86400>;;Refresh interval (seconds)";
                range "180..86400";
              }
            }
            leaf missed {
              tailf:info "Set max number of consecutive missed messages for state expiry";
              type uint32 {
                tailf:info "<1-110000>;;Number of Messages";
                range "1..110000";
              }
            }
          }
        }
      }
    }

    // rsvp / signalling
    container signalling {
      tailf:info "Configure global RSVP signalling parameters";

      // rsvp / signalling graceful-restart
      leaf graceful-restart {
        tailf:info "Configure RSVP Graceful-Restart parameters";
        tailf:cli-full-command;
        type empty;
      }

      // rsvp / signalling graceful-restart X
      container graceful-restart-conf {
        tailf:cli-drop-node-name;
        container graceful-restart {
          tailf:info "Configure RSVP Graceful-Restart parameters";
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          // rsvp / signalling graceful-restart restart-time
          leaf restart-time {
            tailf:info "Configure the restart-time";
            type uint16 {
              tailf:info "<60-3600>;;Restart time (seconds)";
              range "60..3600";
            }
          }
          // rsvp / signalling graceful-restart recovery-time
          leaf recovery-time {
            tailf:info "Configure the recovery time(cisco-support)";
            type uint16 {
              tailf:info "<0-3600>;;Recovery time (seconds)";
              range "0..3600";
            }
          }
        }
      }

      // rsvp / signalling hello graceful-restart refresh
      container hello {
        tailf:info "Configure Hello parameters";
        container graceful-restart {
          tailf:info "Configure Graceful-Restart Hello parameters";
          container refresh {
            tailf:info "Configure Graceful-Restart Hello refresh parameters";

            // rsvp / signalling hello graceful-restart refresh misses
            leaf misses {
              tailf:info "Set max number of consecutive missed Hello messages";
              type uint8 {
                tailf:info "<1-10>;;Number of messages";
                range "1..10";
              }
            }

            // rsvp / signalling hello graceful-restart refresh interval
            leaf interval {
              tailf:info "Set interval between successive Hello messages";
              type uint16 {
                tailf:info "<3000-30000>;;Hello interval (milliseconds)";
                range "3000..30000";
              }
            }
          }
        }
      }

      // rsvp / signalling message-bundle disable
      container message-bundle {
        tailf:info "Sending bundled messages(cisco-support)";
        leaf disable {
          tailf:info "Disable bundling of outgoing RSVP messages";
          type empty;
        }
      }
    }
  }


  /// ========================================================================
  /// xconnect
  /// ========================================================================

  list xconnect {
    tailf:info "Specify the cross connects";
    tailf:cli-suppress-mode;
    tailf:cli-delete-when-empty;
    tailf:cli-compact-syntax;
    tailf:cli-sequence-commands {
      tailf:cli-reset-siblings;
    }
    tailf:cli-incomplete-command;
    key id;
    leaf id {
      type uint16 {
        tailf:info "<1-32655>;;Xconnect ID";
        range "1..32655";
      }
    }
    leaf endpoint-1 {
      tailf:info "Specify Endpoint1 in Cross Connection";
      tailf:cli-incomplete-command;
      type string {
        tailf:info "WORD;;Controller name";
      }
    }
    leaf endpoint-2 {
      tailf:info "Specify Endpoint2 in Cross Connection";
      type string {
        tailf:info "WORD;;Controller name";
      }
    }
    leaf name {
      tailf:cli-drop-node-name;
      tailf:cli-multi-value;
      tailf:cli-preformatted;
      type string {
        tailf:info "LINE;;XConnect Name (Max length 256 character)";
      }
    }
  }


  /// ========================================================================
  /// lmp
  /// ========================================================================

  container lmp {
    tailf:info "Configure OLM/LMP application settings";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-lmp";
    tailf:cli-explicit-exit;
    presence true;

    // lmp / gmpls optical-uni
    container gmpls {
      tailf:info "Configure LMP GMPLS application settings";
      container optical-uni {
        tailf:info "Configure GMPLS Optical UNI application settings";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-lmp-gmpls-uni";

        // lmp / gmpls optical-uni / controller *
        list controller {
          tailf:info "Enable LMP GMPLS UNI on a controller";
          tailf:cli-mode-name "config-lmp-gmpls-uni-cntl";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Interface/controller name";
            }
          }

          // lmp / gmpls optical-uni / controller * / neighbor
          container neighbor {
            tailf:info "Neighbor LMP GMPLS UNI configuration commands";

            // lmp / gmpls optical-uni / controller * / neighbor ?
            leaf name {
              tailf:cli-drop-node-name;
              tailf:cli-full-command;
              tailf:cli-disallow-value "interface-id|link-id";
              type string {
                tailf:info "WORD;;LMP Neighbor name";
              }
            }

            // lmp / gmpls optical-uni / controller * / neighbor link-id
            container link-id {
              tailf:info "LMP Neighbor link identifier address";
              container ipv4 {
                tailf:info "Neighbor Link identifier address (IPv4 Address)";
                leaf unicast {
                  tailf:info "Unicast address";
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;Neighbor Link identifier address (IPv4 Address)";
                  }
                }
              }
            }

            // lmp / gmpls optical-uni / controller * / neighbor interface-id
            container interface-id {
              tailf:info "LMP Neighbor interface identifier";
              leaf unnumbered {
                tailf:info "Neighbor link unnumbered interface identifier";
                type uint32 {
                  tailf:info "<1-4294967295>;;Neighbor unnumbered interface identifier";
                  range "1..4294967295";
                }
              }
            }
          }

          // lmp / gmpls optical-uni / controller * / link-id
          container link-id {
            tailf:info "Local LMP GMPLS UNI link identifier address";
            container ipv4 {
              tailf:info "Local link identifier address (IPv4 Address)";
              choice ipv4-choice {
                leaf unicast {
                  tailf:info "Unicast address";
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;Local Link identifier address (IPv4 Address)";
                  }
                }
                leaf unnumbered {
                  tailf:info "Local Link unnumbered";
                  type empty;
                }
              }
            }
          }
        }

        // lmp / gmpls optical-uni / neighbor *
        list neighbor {
          tailf:info "The GMPLS UNI LMP neighbor configuration submode";
          tailf:cli-mode-name "config-lmp-gmpls-uni-nbr";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Interface/controller name";
            }
          }

          // lmp / gmpls optical-uni / neighbor * / ipcc routed
          container ipcc {
            tailf:info "IPCC manipulation commands";
            leaf routed {
              tailf:info "Create a routed IPCC";
              type empty;
            }
          }

          // lmp / gmpls optical-uni / neighbor * / router-id
          container router-id {
            tailf:info "GMPLS UNI LMP neighbor router ID";
            container ipv4 {
              tailf:info "IPv4 address";
              leaf unicast {
                tailf:info "Unicast address";
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Remote LMP neighbor router ID (IPv4 Address)";
                }
              }
            }
          }
        }

        // lmp / gmpls optical-uni / router-id ipv4 unicast
        container router-id {
          tailf:info "GMPLS UNI LMP local node ID";
          container ipv4 {
            tailf:info "IPv4 address";
            leaf unicast {
              tailf:info "Unicast address";
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;GMPLS UNI LMP router id address";
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// mpls
  /// ========================================================================

  container mpls {
    tailf:info "Configure MPLS parameters";
    tailf:cli-explicit-exit;

    // mpls label
    container label {
      tailf:info "Label properties";

      // mpls label protocol
      leaf protocol {
        tailf:info "Set platform default label distribution protocol";
        type enumeration {
          enum ldp {
            tailf:info "Use LDP (default)";
          }
          enum tdp {
            tailf:info "Use TDP";
          }
        }
      }

      // mpls label range
      container range {
        tailf:info "Label range";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf table {
          tailf:info "Specify label table";
          tailf:cli-optional-in-sequence;
          type uint8 {
            tailf:info "<0-0>;;Label table index";
            range "0";
          }
          default 0;
        }
        leaf min {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<16000-1048575>;;Minimum label value";
            range "16000..1048575";
          }
        }
        leaf max {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<16000-1048575>;;Maximum label value";
            range "16000..1048575";
          }
        }
      }
    }

    // mpls traffic-eng
    container traffic-eng {
      tailf:info "Go into the MPLS-TE submode";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-mpls-te";
      presence true;

      // mpls traffic-eng / apply-group
      uses apply-group-grouping;

      // mpls traffic-eng / auto-tunnel
      container auto-tunnel {
        tailf:info "Automatically created tunnel configuration";

        // mpls traffic-eng / auto-tunnel p2p
        container p2p {
          tailf:info "Enter the auto-tunnel p2p configuration submode";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-te-auto-p2p";

          // mpls traffic-eng / auto-tunnel p2p / tunnel-id
          container tunnel-id {
            tailf:info "Specify Tunnel ID range (modify may result auto-tunnel delete)";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf min {
              tailf:info "Minimum tunnel ID for auto-tunnel p2p";
              tailf:cli-incomplete-command;
              type uint16 {
                tailf:info "<0-65535>;;Minimum value of tunnel ID for auto-tunnel p2p";
              }
            }
            leaf max {
              tailf:info "Maximum tunnel ID for auto-tunnel p2p";
              type uint16 {
                tailf:info "<0-65535>;;Maximum value of tunnel ID for auto-tunnel p2p";
              }
            }
          }
        }

        // mpls traffic-eng / auto-tunnel pcc
        container pcc {
          tailf:info "Enter the auto-tunnel stateful PCE client configuration submode";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-te-auto-pcc";

          // mpls traffic-eng / auto-tunnel pcc / tunnel-id
          container tunnel-id {
            tailf:info "Specify Tunnel ID range (modify may result auto-tunnel delete)";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf min {
              tailf:info "Minimum tunnel ID for stateful PCE client auto-tunnels";
              tailf:cli-incomplete-command;
              type uint16 {
                tailf:info "<0-65535>;;Minimum tunnel ID value for stateful PCE client auto-tunnels";
              }
            }
            leaf max {
              tailf:info "Maximum tunnel ID for stateful PCE client auto-tunnels";
              type uint16 {
                tailf:info "<0-65535>;;Maximum tunnel ID value for stateful PCE client auto-tunnels";
              }
            }
          }
        }

        // mpls traffic-eng / auto-tunnel backup
        container backup {
          tailf:info "Enter the auto-tunnel backup configuration submode";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-mpls-te-auto-bk";

          // mpls traffic-eng / auto-tunnel backup / timers
          container timers {
            tailf:info "Auto-tunnel backups related timers";
            container removal {
              tailf:info "Auto-tunnel backups removal timers";
              leaf unused {
                tailf:info "Auto-tunnel backups unused removal timer";
                type uint16 {
                  tailf:info "<0-10080>;;Auto-tunnel backup unused timeout in minutes (0=never timeout)";
                  range "0..10080";
                }
              }
            }
          }

          // mpls traffic-eng / auto-tunnel backup / tunnel-id
          container tunnel-id {
            tailf:info "Specify Tunnel ID range (modify may result auto-tunnel delete)";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf min {
              tailf:info "Minimum tunnel ID for auto-tunnel backups";
              type uint16 {
                tailf:info "<0-65535>;;Minimum value of tunnel ID for auto-tunnel backups";
              }
            }
            leaf max {
              tailf:info "Maximum tunnel ID for auto-tunnel backups";
              type uint16 {
                tailf:info "<0-65535>;;Maximum value of tunnel ID for auto-tunnel backups";
              }
            }
          }

          // mpls traffic-eng / auto-tunnel backup / affinity ignore
          container affinity {
            tailf:info "Affinity for auto-tunnel backup tunnels";
            leaf ignore {
              tailf:info "Ignore link affinites for PCALC for auto-backup tunnels";
              type empty;
            }
          }
        }

        // mpls traffic-eng / auto-tunnel mesh
        container mesh {
          tailf:info "Enter the auto-tunnel mesh configuration submode";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-te-auto-mesh";

          // mpls traffic-eng / auto-tunnel mesh / group *
          list group {
            tailf:info "Enter the auto-tunnel mesh group configuration submode";
            tailf:cli-mode-name "config-te-mesh-group";
            key id;
            leaf id {
              type uint32 {
                tailf:info "<0-4294967295>;;Auto-tunnel mesh group ID";
              }
            }

            // mpls traffic-eng / auto-tunnel mesh / group * / onehop
            leaf onehop {
              tailf:info "Automatically create tunnel to all next-hops";
              type empty;
            }

            // mpls traffic-eng / auto-tunnel mesh / group * / attribute-set
            leaf attribute-set {
              tailf:info "Attribute-set name of type auto-mesh";
              type string {
                tailf:info "WORD;;Specify attribute-set name (max 64 char)";
              }
            }

            // mpls traffic-eng / auto-tunnel mesh / group * / destination-list
            leaf destination-list {
              tailf:info "Destination-list (prefix-list) name";
              type string {
                tailf:info "WORD;;Specify destination-list (prefix-list) (max 32 char)";
              }
            }
          }

          // mpls traffic-eng / auto-tunnel mesh / timers removal unused
          container timers {
            tailf:info "Auto-tunnel mesh related timers";
            container removal {
              tailf:info "Auto-tunnel mesh removal timers";
              leaf unused {
                tailf:info "Auto-tunnel mesh unused removal timer";
                type uint16 {
                  tailf:info "<0-10080>;;Auto-tunnel mesh unused timeout in minutes (0=never timeout)";
                  range "0..10080";
                }
              }
            }
          }

          // mpls traffic-eng / auto-tunnel mesh / tunnel-id
          container tunnel-id {
            tailf:info "Specify Tunnel ID range (modify may result auto-tunnel delete)";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf min {
              tailf:info "Minimum tunnel ID for auto-tunnel mesh";
              tailf:cli-incomplete-command;
              type uint16 {
                tailf:info "<0-65535>;;Minimum value of tunnel ID for auto-tunnel mesh";
              }
            }
            leaf max {
              tailf:info "Maximum tunnel ID for auto-tunnel mesh";
              type uint16 {
                tailf:info "<0-65535>;;Maximum value of tunnel ID for auto-tunnel mesh";
              }
            }
          }
        }
      }

      // mpls traffic-eng / bandwidth-accounting
      container bandwidth-accounting {
        tailf:info "MPLS Traffic Engineering Bandwidth Accounting submode";
        tailf:cli-add-mode;

        // mpls traffic-eng / bandwidth-accounting / adjustment-factor
        leaf adjustment-factor {
          tailf:info "Configure bandwidth accounting adjustment factor";
          type uint8 {
            tailf:info "<0-200>;;Set the percentage adjustment of bandwidth (default 100%)";
          }
        }

        // mpls traffic-eng / bandwidth-accounting / application
        container application {
          tailf:info "Configure bandwidth accounting application";
          tailf:cli-add-mode;
          // mpls traffic-eng / bandwidth-accounting / application / interval
          leaf interval {
            tailf:info "Configure application interval";
            type uint16 {
              tailf:info "<30-1800>;;Set the frequency of application in seconds (default 180 sec)";
            }
          }
        }

        // mpls traffic-eng / bandwidth-accounting / collection rsvp-te
        container collection {
          tailf:info "Configure bandwidth accounting traffic sample collection type";
          leaf rsvp-te {
            tailf:info "Collect RSVP-TE traffic samples (default Segment-Routing)";
            type empty;
          }
        }

        // mpls traffic-eng / bandwidth-accounting / flooding threshold up N down M
        container flooding {
          tailf:info "Configure bandwidth accounting flooding";
          container threshold {
            tailf:info "Configure bandwidth accounting flooding thresholds";
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            tailf:cli-compact-syntax;
            leaf up {
              tailf:info "Upward flooding threshold for maximum reservable bandwidth";
              tailf:cli-incomplete-command;
              type uint8 {
                tailf:info "<0-100>;;Upward flooding threshold as percentage of maximum reservable bandwidth change (default 10%)";
              }
            }
            leaf down {
              tailf:info "Downward flooding threshold for maximum reservable bandwidth";
              type uint8 {
                tailf:info "<0-100>;;Downward flooding threshold as percentage of maximum reservable bandwidth change (default 10%)";
              }
            }
          }
        }

        // mpls traffic-eng / bandwidth-accounting / sampling-interval
        leaf sampling-interval {
          tailf:info "Configure bandwidth accounting sampling interval";
          type uint16 {
            tailf:info "<10-600>;;Set the frequency of collecting bandwidth rate samples in seconds (default 60 sec)";
          }
        }
      }

      // mpls traffic-eng / interface *
      list interface {
        tailf:info "Enable MPLS-TE on an interface";
        tailf:cli-mode-name "config-mpls-te-if";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Interface Name";
          }
        }

        // mpls traffic-eng / interface * / apply-group
        uses apply-group-grouping;

        // mpls traffic-eng / interface * / bfd fast-detect
        container bfd {
          tailf:info "Configure BFD parameters";
          leaf fast-detect {
            tailf:info "Enable Fast detection";
            type empty;
          }
        }

        // mpls traffic-eng / interface * / auto-tunnel backup
        container auto-tunnel {
          tailf:info "Auto-tunnel configuration";
          container backup {
            tailf:info "Enable the auto-tunnel backup feature on an interface";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-mpls-te-if-auto-backup";
            presence true;

            // mpls traffic-eng / interface * / auto-tunnel backup / exclude srlg
            container exclude {
              tailf:info "Restrict auto-tunnel backup path based on specific criteria.";
              container srlg {
                tailf:info "Backup requires SRLG exclusion from protected interface";
                tailf:cli-delete-when-empty;
                tailf:cli-reset-container;
                presence true;
                leaf preferred {
                  tailf:info "SRLG exclusion is preferred but not mandatory";
                  type empty;
                }
              }
            }

            // mpls traffic-eng / interface * / auto-tunnel backup / nhop-only
            leaf nhop-only {
              tailf:info "Allow only next hop backup tunnels";
              type empty;
            }
          }
        }

        // mpls traffic-eng / interface * / attribute-flags
        leaf attribute-flags {
          tailf:info "Set user defined interface attribute flags";
          type string {
            tailf:info "<0x0-0xffffffff>;;User defined interface attribute flags";
          }
        }

        // mpls traffic-eng / interface * / attribute-names
        container attribute-names {
          tailf:info "Specify one or more attribute names";

          // mpls traffic-eng / interface * / attribute-names
          leaf name {
            tailf:cli-drop-node-name;
            tailf:cli-multi-value;
            tailf:cli-no-value-on-delete;
            tailf:cli-disallow-value "index";
            type string {
              tailf:info "WORD;;User defined attribute name";
            }
          }

          // mpls traffic-eng / interface * / attribute-names index *
          list index {
            tailf:info "Specify the entry index";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key id;
            leaf id {
              type uint8 {
                tailf:info "<1-8>;;Index number";
                range "1..8";
              }
            }
            leaf name {
              tailf:cli-drop-node-name;
              tailf:cli-multi-value;
              tailf:cli-no-value-on-delete;
              type string {
                tailf:info "WORD;;User defined attribute name";
              }
            }
          }
        }

        // mpls traffic-eng / interface * / admin-weight
        leaf admin-weight {
          tailf:info "Set administrative weight for the interface";
          type uint32 {
            tailf:info "<0-4294967295>;;Administrative weight for the interface";
          }
        }

        // mpls traffic-eng / interface * / backup-path tunnel-te *
        container backup-path {
          tailf:info "Configure an MPLS TE backup for this interface";
          leaf-list tunnel-te {
            tailf:info "Tunnel interface number";
            tailf:cli-list-syntax;
            type union {
              type uint16 {
                tailf:info "<0-65535>;;Tunnel interface number";
              }
              type string {
                tailf:info "WORD;;Backup Tunnel Name";
              }
            }
          }
        }
      }

      // mpls traffic-eng / pce
      container pce {
        tailf:info "MPLS Traffic Engineering PCE functionality";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-mpls-te-pce";

        // mpls traffic-eng / pce / deadtimer
        leaf deadtimer {
          tailf:info "Keepalive dead in sec";
          type uint8 {
            tailf:info "<0-255>;;Keepalive dead interval in sec";
          }
        }

        // mpls traffic-eng / pce / peer
        container peer {
          tailf:info "PCE peer related configuration";

          // mpls traffic-eng / pce / peer source ipv4
          container source {
            tailf:info "Peer source";
            leaf ipv4 {
              tailf:info "IPv4 address";
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IPv4 address of the source";
              }
            }
          }

          // mpls traffic-eng / pce / peer ipv4 *
          list ipv4 {
            tailf:info "IPv4 address";
            tailf:cli-mode-name "config-mpls-te-pce-peer";
            key address;
            leaf address {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IPv4 address of the peer";
              }
            }

            // mpls traffic-eng / pce / peer ipv4 * / password
            container password {
              tailf:info "Configure password for MD5 authentication";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              uses password-grouping {
                refine "secret" {
                  cli:secret " password <SECRET>";
                }
              }
            }

            // mpls traffic-eng / pce / peer ipv4 * / precedence
            leaf precedence {
              tailf:info "PCE Peer Precedence";
              type uint8 {
                tailf:info "<0-255>;;PCE server precedence order (low precedence corresponds to high priority)";
              }
            }
          }
        }

        // mpls traffic-eng / pce / reoptimize
        leaf reoptimize {
          tailf:info "Reoptimization period for PCE-based paths";
          type uint32 {
            tailf:info "<60-604800>;;Reoptimization period in seconds";
            range "60..604800";
          }
        }

        // mpls traffic-eng / pce / logging events peer-status
        container logging {
          tailf:info "Log PCE info";
          container events {
            tailf:info "Log events info";
            leaf peer-status {
              tailf:info "Log peer status changes";
              type empty;
            }
          }
        }

        // mpls traffic-eng / pce / segment-routing
        leaf segment-routing {
          tailf:info "Enable segment-routing capability";
          type empty;
        }

        // mpls traffic-eng / pce / stateful-client
        container stateful-client {
          tailf:info "Enter the stateful PCE client configuration submode";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-mpls-te-pce-stateful";
          presence true;

          // mpls traffic-eng / pce / stateful-client / instantiation
          leaf instantiation {
            tailf:info "Enable stateful instantiate capability";
            type empty;
          }

          // mpls traffic-eng / pce / stateful-client / cisco-extension
          leaf cisco-extension {
            tailf:info "Enable processing of PCEP Cisco extension";
            type empty;
          }

          // mpls traffic-eng / pce / stateful-client / report
          leaf report {
            tailf:info "Report all statically configured tunnel";
            type empty;
          }

          // mpls traffic-eng / pce / stateful-client / timers
          container timers {
            tailf:info "Stateful client timers";

            // mpls traffic-eng / pce / stateful-client / timers redelegation-timeout
            leaf redelegation-timeout {
              tailf:info "Redelegation timeout for LSPs after session failure in seconds, zero means immediate drop";
              type uint32 {
                tailf:info "<0-1576800000>;;Time in seconds";
                range "0..1576800000";
              }
            }

            // mpls traffic-eng / pce / stateful-client / timers state-timeout
            leaf state-timeout {
              tailf:info "State timeout for LSPs without delegation in seconds, zero means immediate removal, default is 180";
              type uint16 {
                tailf:info "<0-3600>;;Cleanup time in seconds";
                range "0..3600";
              }
            }
          }

          // mpls traffic-eng / pce / stateful-client / fast-repair
          leaf fast-repair {
            tailf:info "Enable head-end to react to path failures";
            type empty;
          }

          // mpls traffic-eng / pce / stateful-client / redundancy
          container redundancy {
            tailf:info "PCE Redundancy configuration";
            leaf pcc-centric {
              tailf:info "Enable PCC centric model";
              type empty;
            }
          }

          // mpls traffic-eng / pce / stateful-client / autoroute-announce
          leaf autoroute-announce {
            tailf:info "Enable autoroute announce for PCE tunnels";
            type empty;
          }

        }

        // mpls traffic-eng / pce / tolerance keepalive
        container tolerance {
          tailf:info "Tolerance for session parameters proposed by peers";
          leaf keepalive {
            tailf:info "Minimum acceptable peer proposed keepalive";
            type uint8 {
              tailf:info "<0-255>;;Keepalive interval in sec";
            }
          }
        }
      }

      // mpls traffic-eng / logging events
      container logging {
        tailf:info "MPLS Traffic-Eng. logging configuration";
        container events {
          tailf:info "Global logging events";

          // mpls traffic-eng / logging events all
          leaf all {
            tailf:info "Enable all logging for all events";
            type empty;
          }

          // mpls traffic-eng / logging events role
          container role {
            tailf:info "Enable all logging for a tunnel role";
            leaf mid {
              tailf:info "Enable all logging for mid";
              type empty;
            }
            leaf head {
              tailf:info "Enable all logging for head";
              type empty;
            }
            leaf tail {
              tailf:info "Enable all logging for tail";
              type empty;
            }
          }

          // mpls traffic-eng / logging events nsr
          leaf nsr {
            tailf:info "Enable NSR Status Loggin";
            type empty;
          }

          // mpls traffic-eng / logging events frr-protection
          container frr-protection {
            tailf:info "Enable protection change Syslog";
            tailf:cli-delete-when-empty;
            tailf:cli-reset-container;
            presence true;

            // mpls traffic-eng / logging events frr-protection primary-lsp
            leaf primary-lsp {
              tailf:info "Enable logging for primary LSP(s)";
              type enumeration {
                enum ready-state {
                  tailf:info "Enable logging when FRR backup is assigned or unassigned";
                }
                enum active-state {
                  tailf:info "Enable logging when FRR backup is triggered";
                }
              }
            }
          }

          // mpls traffic-eng / logging events preemption
          leaf preemption {
            tailf:info "Enable Tunnel Preemption alarms";
            type empty;
          }
        }
      }

      // mpls traffic-eng / affinity-map *
      list affinity-map {
        tailf:info "Affinity Map Configuration";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Affinity attribute name";
          }
        }

        // mpls traffic-eng / affinity-map * <value>
        leaf value {
          tailf:cli-drop-node-name;
          tailf:cli-full-command;
          type string {
            tailf:info "<0x1-0x80000000>;;Affinity attribute value";
          }
        }

        // mpls traffic-eng / affinity-map * bit-position
        leaf bit-position {
          tailf:info "Bit Position for Affinity attribute value";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<0-255>;;Bit Position";
          }
        }
      }

      // mpls traffic-eng / attribute-set path-option *
      // mpls traffic-eng / attribute-set auto-backup *
      // mpls traffic-eng / attribute-set auto-mesh *
      // mpls traffic-eng / attribute-set p2mp-te *
      // mpls traffic-eng / attribute-set p2p-te
      // mpls traffic-eng / attribute-set path-protection-aps
      // mpls traffic-eng / attribute-set xro
      list attribute-set {
        tailf:info "Specify attribute set";
        tailf:cli-mode-name "config-te-attribute-set";
        key "type pathname";
        leaf type {
          type enumeration {
            enum path-option {
              tailf:info "Attribute-set of a path option";
            }
            enum auto-backup {
              tailf:info "Attribute-set of auto-backup type";
            }
            enum auto-mesh {
              tailf:info "Attribute-set of auto mesh type";
            }
            enum p2mp-te {
              tailf:info "Attribute-set of p2mp-te type";
            }
            enum path-protection-aps {
              tailf:info "Attribute-set of path protection";
            }
            enum xro {
              tailf:info "An XRO attribute-set";
            }
            enum p2p-te {
              tailf:info "Attribute-set of p2p-te type";
            }
          }
        }
        leaf pathname {
          type string {
            tailf:info "WORD;;Specify attribute-set name";
          }
        }

        // mpls traffic-eng / attribute-set * affinity
        uses affinity-grouping;

        // mpls traffic-eng / attribute-set * logging events lsp-status
        container logging {
          tailf:info "Per-interface logging configuration";
          container events {
            tailf:info "Per-interface logging events";
            uses logging-events-lsp-status-grouping;
          }
        }

        // mpls traffic-eng / attribute-set * bandwidth
        leaf bandwidth {
          tailf:info "Set the bandwidth of an interface";
          tailf:cli-full-command;
          type uint32 {
            tailf:info "<0-4294967295>;;bandwidth in kbps";
          }
        }

        // mpls traffic-eng / attribute-set * / priority
        container priority {
          tailf:info "Tunnel priority";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf setup {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-7>;;Setup Priority";
              range "0..7";
            }
          }
          leaf hold {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<0-7>;;Hold Priority";
              range "0..7";
            }
          }
        }

        // mpls traffic-eng / attribute-set * / signalled-bandwidth
        container signalled-bandwidth {
          tailf:info "Tunnel bandwidth requirement to be signalled";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf bw-req {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<0-4294967295>;;Bandwidth requirement in kbps";
              range "0..4294967295";
            }
          }
          leaf class-type {
            tailf:info "Specify the bandwidth class type";
            type uint8 {
              tailf:info "<0-1>;;Class type number";
              range "0..1";
            }
          }
        }

        // mpls traffic-eng / attribute-set * / auto-bw
        container auto-bw {
          tailf:info "Enable tunnel auto-bandwidth";
          leaf collect-bw-only {
            tailf:info "Enable bandwidth collection only, no auto-bw adjustment";
            type empty;
          }
        }

        // mpls traffic-eng / attribute-set * / autoroute announce
        container autoroute {
          tailf:info "Parameters for IGP routing over tunnel";
          leaf announce {
            tailf:info "Announce tunnel to IGP";
            type empty;
          }
        }

        // mpls traffic-eng / attribute-set * / fast-reroute
        container fast-reroute {
          tailf:info "Specify MPLS tunnel can be fast-rerouted";
          tailf:cli-delete-when-empty;
          presence true;
          leaf-list protect {
            tailf:info "Enable protection request";
            tailf:cli-flat-list-syntax;
            tailf:cli-replace-all;
            type enumeration {
              enum node {
                tailf:info "Enable node protection request";
              }
              enum bandwidth {
                tailf:info "Enable bandwidth protection request";
              }
            }
          }
        }

        // mpls traffic-eng / attribute-set * / policy-class
        container policy-class {
          tailf:info "Specify class for policy-based tunnel selection";
          tailf:cli-delete-when-empty;
          presence true;
          leaf value {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-7>;;Tunnel policy class";
              range "1..7";
            }
          }
        }

        // mpls traffic-eng / attribute-set * / record-route
        leaf record-route {
          tailf:info "Record the route used by the tunnel";
          tailf:cli-full-command;
          type empty;
        }

        // mpls traffic-eng / attribute-set * / forward-class
        leaf forward-class {
          tailf:info "Specify tunnel forward class for policy based routing";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<1-7>;;Forward class for the tunnel (default value 0)";
            range "1..7";
          }
        }

        // mpls traffic-eng / attribute-set * exclude *
        list exclude {
          tailf:info "Specify exclusions for path diversity";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          key "source destination tunnel-id extended-tunnel-id";
          leaf mode {
            tailf:cli-drop-node-name;
            tailf:cli-prefix-key;
            type enumeration {
              enum best-effort {
                tailf:info "Specified condition should be met if possible";
              }
              enum strict {
                tailf:info "Specified condition must be met";
              }
            }
          }
          leaf lsp {
            tailf:info "Specify path-diversity from another LSP";
            tailf:cli-prefix-key;
            type empty;
          }
          leaf source {
            tailf:info "The source of the LSP from which a diverse path is required";
            tailf:cli-expose-key-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;The LSP's source address";
            }
          }
          leaf destination {
            tailf:info "The destination of the LSP from which a diverse path is required";
            tailf:cli-expose-key-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;The LSP's destination address";
            }
          }
          leaf tunnel-id {
            tailf:info "The tunnel-id of the LSP from which a diverse path is required";
            tailf:cli-expose-key-name;
            type uint16 {
              tailf:info "<0-65535>;;The LSP's tunnel-id";
            }
          }
          leaf extended-tunnel-id {
            tailf:info "The extended tunnel-id of the LSP from which a diverse path is required";
            tailf:cli-expose-key-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;The LSP's extended tunnel-id";
            }
          }
          leaf lsp-id {
            tailf:info "The lsp-id of the LSP from which a diverse path is required";
            type uint16 {
              tailf:info "<0-65535>;;The LSP's lsp-id (optional)";
            }
          }
        }

        // mpls traffic-eng / attribute-set * pce
        container pce {
          tailf:info "Specify PCE Configuration";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-te-attrset-pce";
          presence true;

          // mpls traffic-eng / attribute-set * pce / disjoint-path
          container disjoint-path {
            tailf:info "Disjoint Path Configuration";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf source {
              tailf:info "Source address";
              tailf:cli-incomplete-command;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IPv4 Address";
              }
            }
            leaf type {
              tailf:info "Disjointness type";
              tailf:cli-incomplete-command;
              type enumeration {
                enum link {
                  tailf:info "Link Disjointness";
                }
                enum node {
                  tailf:info "Node Disjointness";
                }
                enum srlg {
                  tailf:info "SRLG Disjointness";
                }
              }
            }
            leaf group-id {
              tailf:info "Group ID";
              type uint32 {
                tailf:info "<1-4294967295>;;Enter group-id";
              }
            }
          }
        }

        // mpls traffic-eng / attribute-set * path-selection
        container path-selection {
          tailf:info "Specify path selection";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-te-attrset-path-select";
          presence true;

          // mpls traffic-eng / attribute-set * path-selection / metric
          leaf metric {
            tailf:info "Metric type for path calculation";
            type enumeration {
              enum igp {
                tailf:info "Use IGP metric";
              }
              enum te {
                tailf:info "Use TE metric";
              }
            }
          }

          // mpls traffic-eng / attribute-set * path-selection / segment-routing prepend
          container segment-routing {
            tailf:info "Segment-routing path-selection options";
            container prepend {
              tailf:info "Prepend label list";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-te-attrset-prepend";
              presence true;

              // mpls traffic-eng / attribute-set * path-selection / segment-routing prepend / index *
              list index {
                tailf:info "Specify the next entry index to add or edit";
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                key id;
                leaf id {
                  type uint8 {
                    tailf:info "<1-10>;;Index number";
                    range "1..10";
                  }
                }
                leaf next-label {
                  tailf:info "Specify the next MPLS label in the pat";
                  type uint32 {
                    tailf:info "<0-1048575>;;MPLS label value";
                    range "0..1048575";
                  }
                }
                leaf bgp-nhop {
                  tailf:info "BGP next hop";
                  type empty;
                }
              }
            }
          }
        }
      }

      // mpls traffic-eng / path-selection
      container path-selection {
        tailf:info "MPLS Traffic Engineering Path-Selection submode";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-mpls-te-path-sel";

        // mpls traffic-eng / path-selection / metric
        container metric {
          tailf:info "Metric Type for path calculation";
          leaf metric-type {
            tailf:cli-drop-node-name;
            tailf:cli-full-command;
            type enumeration {
              enum igp {
                tailf:info "Use IGP metric";
              }
              enum te {
                tailf:info "Use TE metric";
              }
            }
          }
        }

        // mpls traffic-eng / path-selection / ignore overload
        container ignore {
          tailf:info "Ignore specified condition during CSPF";
          leaf-list overload {
            tailf:info "Ignore overload node during CSPF";
            tailf:cli-flat-list-syntax;
            tailf:cli-replace-all;
            type enumeration {
              enum head {
                tailf:info "Ignore overload node during CSPF for role head";
              }
              enum mid {
                tailf:info "Ignore overload node during CSPF for role mid";
              }
              enum tail {
                tailf:info "Ignore overload node during CSPF for role tail";
              }
            }
          }
        }

        // mpls traffic-eng / path-selection / loose-expansion metric ? class-type *
        container loose-expansion {
          tailf:info "Loose ERO Hop Expansion Configuration";
          list metric {
            tailf:info "Metric Type for path calculation";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key class-type;
            leaf class-type {
              tailf:info "Specify the class type";
              tailf:cli-expose-key-name;
              type uint8 {
                tailf:info "<0-1>;;Class type number";
                range "0..1";
              }
            }
            leaf metric-type {
              tailf:cli-drop-node-name;
              tailf:cli-prefix-key;
              type enumeration {
                enum delay {
                  tailf:info "Use delay metric";
                }
                enum igp {
                  tailf:info "Use IGP metric";
                }
                enum te {
                  tailf:info "Use TE metric";
                }
              }
            }
          }

          // mpls traffic-eng / path-selection / loose-expansion affinity * class-type *
          list affinity {
            tailf:info "Desired link attributes for links comprising tunnel";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            key class-type;
            leaf value {
              tailf:cli-drop-node-name;
              tailf:cli-prefix-key;
              type string {
                tailf:info "<0x0-0xffffffff>;;Affinity value";
              }
            }
            leaf mask {
              tailf:info "Affinity mask value";
              tailf:cli-prefix-key;
              type string {
                tailf:info "<0x0-0xffffffff>;;Affinity mask value";
              }
            }
            leaf class-type {
              tailf:info "Specify the class type";
              tailf:cli-expose-key-name;
              type uint8 {
                tailf:info "<0-1>;;Class type number";
                range "0..1";
              }
            }
          }

          // mpls traffic-eng / path-selection / loose-expansion domain-match
          leaf domain-match {
            tailf:info "Use only the IGP instance of the incoming interface";
            type empty;
          }
        }
      }

      // mpls traffic-eng / ds-te
      container ds-te {
        tailf:info "Diff-Serv Traffic-Engineering Parameters";

        // mpls traffic-eng / ds-te mode ietf
        container mode {
          tailf:info "Diff-Serv Traffic-Engineering Mode";
          leaf ietf {
            tailf:info "IETF Standard Mode";
            type empty;
          }
        }

        // mpls traffic-eng / ds-te te-classes
        container te-classes {
          tailf:info "enter the DS-TE te-class map configuration mode";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-te-class";

          // mpls traffic-eng / ds-te te-classes / te-class *
          list te-class {
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            key id;
            leaf id {
              type uint8 {
                tailf:info "<0-7>;;DS-TE class number";
                range "0..7";
              }
            }

            // mpls traffic-eng / ds-te te-classes / te-class *
            choice te-class-choice {
              leaf unused {
                tailf:info "Mark the TE-class as unused";
                type empty;
              }
              case used {
                leaf class-type {
                  tailf:info "Class type";
                  tailf:cli-incomplete-command;
                  type uint8 {
                    tailf:info "<0-1>;;Class type number";
                    range "0..1";
                  }
                }
                leaf priority {
                  tailf:info "Class priority";
                  type uint8 {
                    tailf:info "<0-7>;;Class-type priority";
                    range "0..7";
                  }
                }
              }
            }
          }
        }
      }

      // mpls traffic-eng / soft-preemption
      container soft-preemption {
        tailf:info "Enable soft-preemption";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-soft-preemption";
        presence true;

        // mpls traffic-eng / soft-preemption / timeout
        leaf timeout {
          tailf:info "Specify a timeout for soft-preempted LSP";
          type uint32 {
            tailf:info "<1-300>;;Timeout for soft-preempted LSP in seconds: default 60";
            range "1..300";
          }
        }
      }

      // mpls traffic-eng / auto-bw
      container auto-bw {
        tailf:info "Auto-bandwidth configuration";
        container collect {
          tailf:info "Auto-bandwidth collection parameters";
          leaf frequency {
            tailf:info "Auto-bandwidth collection frequency parameter";
            type uint16 {
              tailf:info "<1-10080>;;Auto-bandwidth collection frequency in minutes";
              range "1..10080";
            }
          }
        }
      }

      // mpls traffic-eng / reoptimize
      container reoptimize {
        tailf:info "MPLS TE Reoptimize config";
        leaf value {
          tailf:cli-drop-node-name;
          tailf:cli-full-command;
          type uint32 {
            tailf:info "<0-604800>;;Reoptimize timers frequency (secs)";
            range "0..604800";
          }
        }

        // mpls traffic-eng / reoptimize load-balance
        leaf load-balance {
          tailf:info "Load balance bandwidth during reoptimization";
          type empty;
        }

        // mpls traffic-eng / reoptimize timers delay
        container timers {
          tailf:info "Reoptimization timers";
          container delay {
            tailf:info "Delay reoptimization action";

            // mpls traffic-eng / reoptimize timers delay cleanup
            leaf cleanup {
              tailf:info "Delay cleanup of reoptimized LSP";
              type uint16 {
                tailf:info "<0-300>;;Seconds to delay cleanup of reoptimized LSP";
                range "0..300";
              }
            }

            // mpls traffic-eng / reoptimize timers delay installation
            leaf installation {
              tailf:info "Delay replacement of current LSP by reoptimized LSP";
              type uint16 {
                tailf:info "<0-3600>;;Seconds to delay replacement of tunnel LSP";
                range "0..3600";
              }
            }

            // mpls traffic-eng / reoptimize timers delay after-frr
            leaf after-frr {
              tailf:info "Delay LSP reoptimization in the event of FRR";
              tailf:cli-full-command;
              type uint8 {
                tailf:info "<0-120>;;Seconds to delay re-opt initiation of tunnel after an FRR event";
                range "0..120";
              }
            }

            // mpls traffic-eng / reoptimize timers delay path-protection
            leaf path-protection {
              tailf:info "Time between path protection switchover event and tunnel re-optimization";
              type uint32 {
                tailf:info "<0-604800>;;Seconds between path protection switchover event and tunnel re-optimization. Set to 0 to disable";
                range "0..604800";
              }
            }
          }
        }
      }

      // mpls traffic-eng / bfd
      container bfd {
        tailf:info "Configure BFD parameters";

        // mpls traffic-eng / bfd lsp
        container lsp {
          tailf:info "Configure parameters for BFD over LSP";

          // mpls traffic-eng / bfd lsp head down-action
          container head {
            tailf:info "Head end configuration";

            container down-action {
              tailf:info "Action to take for FRR enabled tunnel when BFD session down";

              // mpls traffic-eng / bfd lsp head down-action resetup
              leaf resetup {
                tailf:info "Teardown and resetup when received BFD session down event";
                type empty;
              }

              // mpls traffic-eng / bfd lsp head down-action reoptimize timeout
              container reoptimize {
                tailf:info "Reoptimize when received BFD session down event (default)";
                leaf timeout {
                  tailf:info "Timeout and teardown if failed to reoptimize";
                  type uint32 {
                    tailf:info "<120-4294967295>;;Reoptmization timeout in seconds (default 300)";
                    range "120..4294967295";
                  }
                }
              }
            }
          }

          // mpls traffic-eng / bfd lsp tail
          container tail {
            tailf:info "Tail end configuration";
            leaf minimum-interval {
              tailf:info "Hello interval";
              type uint16 {
                tailf:info "<50-30000>;;Hello interval in milliseconds (default 100)";
                range "50..30000";
              }
            }
            leaf multiplier {
              tailf:info "Detect multiplier";
              type uint8 {
                tailf:info "<3-10>;;Detect multiplier (default 3)";
                range "3..10";
              }
            }
          }
        }

        // mpls traffic-eng / bfd multiplier
        leaf multiplier {
          tailf:info "Detect multiplier";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<2-10>;;Detect multiplier";
            range "2..10";
          }
        }

        // mpls traffic-eng / bfd minimum-interval
        leaf minimum-interval {
          tailf:info "Hello interval";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<3-200>;;hello interval in milli-seconds";
            range "3..200";
          }
        }
      }

      // mpls traffic-eng / router-id secondary *
      container router-id {
        tailf:info "Router ID";
        list secondary {
          tailf:info "Configure secondary TE Router ID to be used locally (not advertised)";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key address;
          leaf address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Secondary TE Router ID";
            }
          }
        }
      }

      // mpls traffic-eng / fast-reroute
      container fast-reroute {
        tailf:info "Fast-reroute config parameters";
        container timers {
          tailf:info "Configure fast-reroute timer";
          leaf promotion {
            tailf:info "Configure how often we scan for LSP backup promotion";
            tailf:cli-full-command;
            type uint32 {
              tailf:info "<0-604800>;;Seconds between promotions (0 disables promotion)";
              range "0..604800";
            }
          }
        }
      }

      // mpls traffic-eng / link-management
      container link-management {
        tailf:info "MPLS Link Manager subcommands";
        container timers {
          tailf:info "MPLS Link Manager Timer subcommands";

          // mpls traffic-eng / link-management timers periodic-flooding
          leaf periodic-flooding {
            tailf:info "Periodic flooding timer";
            type uint16 {
              tailf:info "<0-3600>;;Periodic flooding value (seconds), minimum 30 seconds";
              range "0..3600";
            }
          }

          // mpls traffic-eng / link-management timers preemption-delay
          container preemption-delay {
            tailf:info "Delay LSP preemption";
            leaf bundle-capacity {
              tailf:info "Bundle capacity change preemption delay timer";
              type uint16 {
                tailf:info "<0-300>;;Bundle capacity change preemption timer value (seconds)";
                range "0..300";
              }
            }
          }
        }
      }

      // mpls traffic-eng / signalling advertise explicit-null
      container signalling {
        tailf:info "Signalling options";
        container advertise {
          tailf:info "Label advertising options";
          leaf explicit-null {
            tailf:info "Enable explicit-null advertising to PHOP";
            type empty;
          }
        }
      }

      // mpls traffic-eng / gmpls
      container gmpls {
        tailf:info "GMPLS submode";

        // mpls traffic-eng / gmpls optical-nni
        container optical-nni {
          tailf:info "GMPLS-NNI submode";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-lmp-gmpls-nni";

          // mpls traffic-eng / gmpls optical-nni / topology instance ospf *
          container topology {
            tailf:info "GMPLS NNI topology instance";
            container instance {
              tailf:info "GMPLS NNI topology instance";
              list ospf {
                tailf:info "OSPF instance";
                tailf:cli-mode-name "config-te-gmpls-nni-ti";
                key "name area";
                leaf name {
                  type string {
                    tailf:info "WORD;;Name for this OSPF instance";
                  }
                }
                leaf area {
                  tailf:info "Specify the OSPF area to flood link into";
                  tailf:cli-expose-key-name;
                  type ospf-area-type;
                }

                // mpls traffic-eng / gmpls optical-nni / topology instance ospf * / controller *
                list controller {
                  tailf:info "Configure GMPLS-NNI on a link";
                  tailf:cli-mode-name "config-te-gmpls-nni-ti-cntl";
                  key name;
                  leaf name {
                    type string {
                      tailf:info "WORD;;Controller name";
                    }
                  }

                  // mpls traffic-eng / gmpls optical-nni / topology instance ospf * / controller * / tti-mode
                  leaf tti-mode {
                    tailf:info "TTI Mode to carry TE Link Id,default is otu_sm";
                    type enumeration {
                      enum odu-pm {
                        tailf:info "Path Monitoring for ODU";
                      }
                      enum odu-tcm {
                        tailf:info "Tandem Connection Monitoring for ODU";
                      }
                      enum otu-sm {
                        tailf:info "Section Monitoring for OTU";
                      }
                    }
                  }

                  // mpls traffic-eng / gmpls optical-nni / topology instance ospf * / controller * / admin-weight
                  leaf admin-weight {
                    tailf:info "Contoller admin weight";
                    type uint16 {
                      tailf:info "<0-65535>;;Admin weight value";
                    }
                  }
                }
              }
            }
          }

          // mpls traffic-eng / gmpls optical-nni / controller Odu-Group-Te *
          container controller {
            tailf:info "Configure GMPLS-NNI tunnel";
            list Odu-Group-Te {
              tailf:info "Odu-Group-Te controller(s)";
              tailf:cli-mode-name "config-te-gmpls-tun";
              key id;
              leaf id {
                type uint16 {
                  tailf:info "<0-64535>;;Enter the Tunnel ID";
                  range "0..64535";
                }
              }

              // mpls traffic-eng / gmpls optical-nni / controller Odu-Group-Te * / signalled-name
              leaf signalled-name {
                tailf:info "The signaling name to assign to the tunnel";
                type string {
                  tailf:info "WORD;;The name to be included in signaling (max 254 characters)";
                }
              }

              // mpls traffic-eng / gmpls optical-nni / controller Odu-Group-Te * / logging events lsp-status
              container logging {
                tailf:info "Per-interface logging configuration";
                container events {
                  tailf:info "Per-interface logging events";
                  container lsp-status {
                    tailf:info "Enable interface LSP state change alarms";
                    leaf state {
                      tailf:info "Enable tunnel oper-state change notification";
                      type empty;
                    }
                    leaf signalling-state {
                      tailf:info "Enable all sub-LSP state change notification";
                      type empty;
                    }
                    leaf homepath-state {
                      tailf:info "Enable Homepath state change notification";
                      type empty;
                    }
                    leaf switch-over {
                      tailf:info "Enable Active LSP change notification";
                      type empty;
                    }
                    leaf cross-connect {
                      tailf:info "Enable Static X-connects change notification";
                      type empty;
                    }
                    leaf insufficient-bandwidth {
                      tailf:info "Enable Syslog for setup failure due to bandwidth";
                      type empty;
                    }
                    leaf path-change {
                      tailf:info "Enable Path-change notification";
                      type empty;
                    }
                  }
                }
              }

              // mpls traffic-eng / gmpls optical-nni / controller Odu-Group-Te * / signalled-bandwidth
              leaf signalled-bandwidth {
                tailf:info "Set the signaled B/W of the tunnel";
                type string {
                  tailf:info "WORD;;Signalled Bandwidth, e.g. 'ODU0'";
                  pattern 'ODU.+';
                }
              }

              // mpls traffic-eng / gmpls optical-nni / controller Odu-Group-Te * / static-uni
              container static-uni {
                tailf:info "Set the static UNI endpoints of the NNI Tunnel";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                choice ingress-choice {
                  leaf ingress-port {
                    tailf:info "Specify an ingress-port";
                    tailf:cli-incomplete-command;
                    type empty;
                  }
                  leaf local-termination {
                    tailf:info "Local termination for ingress";
                    tailf:cli-incomplete-command;
                    type empty;
                  }
                }
                leaf controller {
                  tailf:info "Specify an ingress-port controller";
                  tailf:cli-incomplete-command;
                  type string {
                    tailf:info "WORD;;Controller name";
                  }
                }
                choice egress-choice {
                  leaf egress-port {
                    tailf:info "Specify an egress-port";
                    type empty;
                  }
                  leaf remote-termination {
                    tailf:info "Remote termination for egress";
                    type empty;
                  }
                }
                leaf unnumbered {
                  tailf:info "Specify tail-end customer port IF index";
                  type uint32 {
                    tailf:info "<0-4294967295>;;Enter the tail-end customer port IF index";
                    range "0..4294967295";
                  }
                }
              }

              // mpls traffic-eng / gmpls optical-nni / controller Odu-Group-Te * / destination
              container destination {
                tailf:info "Specify tunnel destination";
                container ipv4 {
                  tailf:info "Specify an IPv4 destination";
                  tailf:cli-compact-syntax;
                  tailf:cli-sequence-commands {
                    tailf:cli-reset-siblings;
                  }
                  choice destination-choice {
                    leaf unicast {
                      tailf:info "Specify an IPv4 unicast destination";
                      type inet:ipv4-address {
                        tailf:info "A.B.C.D;;Tunnel destination address";
                      }
                    }
                    case unnumbered {
                      leaf unnumbered {
                        tailf:info "Enter Router-id (A.B.C.D)";
                        type inet:ipv4-address {
                          tailf:info "A.B.C.D;;Destination router-id";
                        }
                      }
                      leaf interface-ifindex {
                        tailf:info "Specify terminated interface index assigned by destination node";
                        type uint32 {
                          tailf:info "<0-4294967295>;;Enter the destination IF-index";
                        }
                      }
                    }
                  }
                }
              }

              // mpls traffic-eng / gmpls optical-nni / controller Odu-Group-Te * / record-route
              leaf record-route {
                tailf:info "Records the route used by the tunnel";
                type empty;
              }

              // mpls traffic-eng / gmpls optical-nni / controller Odu-Group-Te * / path-option *
              uses mpls-traffic-eng-controller-path-option-grouping;
            }
          }
        }

        // mpls traffic-eng / gmpls optical-uni
        container optical-uni {
          tailf:info "GMPLS-UNI submode";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-lmp-gmpls-uni";

          // mpls traffic-eng / gmpls optical-uni / controller *
          list controller {
            tailf:info "Configure GMPLS-UNI on a link";
            tailf:cli-mode-name "config-te-gmpls-cntl";
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;Interface/controller name";
              }
            }

            // mpls traffic-eng / gmpls optical-uni / controller * / logging discovered-srlgs
            container logging {
              tailf:info "Per-controller logging configuration";
              leaf discovered-srlgs {
                tailf:info "Enable logging for discovered SRLGs on this link";
                type empty;
              }
            }

            // mpls traffic-eng / gmpls optical-uni / controller * / announce srlgs
            container announce {
              tailf:info "Announce discovered tunnel properties to system";
              leaf srlgs {
                tailf:info "Announce discovered SRLGs to system";
                type empty;
              }
            }

            // mpls traffic-eng / gmpls optical-uni / controller * / tunnel-properties
            container tunnel-properties {
              tailf:info "Configure GMPLS-UNI tunnel head properties";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-te-gmpls-tun";
              presence true;

              // mpls traffic-eng / gmpls optical-uni / controller * / tunnel-properties / signalled-name
              leaf signalled-name {
                tailf:info "The signaling name to assign to the tunnel";
                tailf:cli-full-command;
                type string {
                  tailf:info "WORD;;The name to be included in signaling (max 64 characters)";
                }
              }

              // mpls traffic-eng / gmpls optical-uni / controller * / tunnel-properties / logging events lsp-status state
              container logging {
                tailf:info "Per-tunnel logging configuration";
                container events {
                  tailf:info "Per-tunnel logging events";
                  container lsp-status {
                    tailf:info "Enable interface LSP state change alarms";
                    leaf state {
                      tailf:info "Enable interface LSP UP/DOWN change alarms";
                      type empty;
                    }
                  }
                }
              }

              // mpls traffic-eng / gmpls optical-uni / controller * / tunnel-properties / tunnel-id
              leaf tunnel-id {
                tailf:info "GMPLS-UNI tunnel id";
                tailf:cli-full-command;
                type uint16 {
                  tailf:info "<0-65535>;;Tunnel ID";
                }
              }

              // mpls traffic-eng / gmpls optical-uni / controller * / tunnel-properties / record srlg
              container record {
                tailf:info "Request recording of tunnel properties during signaling";
                leaf srlg {
                  tailf:info "SRLG recording";
                  type empty;
                }
              }

              // mpls traffic-eng / gmpls optical-uni / controller * / tunnel-properties / destination
              container destination {
                tailf:info "Specify tunnel destination";
                container ipv4 {
                  tailf:info "Specify an IPv4 destination";
                  leaf unicast {
                    tailf:info "Specify an IPv4 unicast destination";
                    type inet:ipv4-address {
                      tailf:info "A.B.C.D;;Tunnel destination address";
                    }
                  }
                }
              }

              // mpls traffic-eng / gmpls optical-uni / controller * / tunnel-properties / path-option *
              uses mpls-traffic-eng-controller-path-option-grouping;

              // mpls traffic-eng / gmpls optical-uni / controller * / tunnel-properties / record-route
              leaf record-route {
                tailf:info "Record the route used by the tunnel";
                type empty;
              }
            }
          }
        }
      }

      // mpls traffic-eng / load-share unequal
      container load-share {
        tailf:info "Load-share configuration";
        leaf unequal {
          tailf:info "Enable unequal load-sharing across TE tunnels to the same destination";
          type empty;
        }
      }

      // mpls traffic-eng / timers loose-path retry-period
      container timers {
        tailf:info "Traffic Engineering timers";
        container loose-path {
          tailf:info "Control the LSP terminating outside the headend area";
          leaf retry-period {
            tailf:info "Period in seconds between retries after path errors";
            type uint16 {
              tailf:info "<30-600>;;Seconds to retry signalling of loose path tunnels after path errors";
              range "30..600";
            }
          }
        }
      }
    }

    // mpls ldp
    container ldp {
      tailf:info "Label Distribution Protocol";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-ldp";
      presence true;

      // mpls ldp / nsr
      leaf nsr {
        tailf:info "Configure Non-Stop Routing";
        tailf:cli-full-command;
        type empty;
      }

      // mpls ldp / log
      container log {
        tailf:info "Configure logging of LDP events";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-ldp-log";

        // mpls ldp / log / adjacency
        leaf adjacency {
          tailf:info "Adjacency events";
          tailf:cli-full-command;
          type empty;
        }

        // mpls ldp / log / hello-adjacency
        leaf hello-adjacency {
          tailf:info "Hello adjacency events";
          tailf:cli-full-command;
          type empty;
        }

        // mpls ldp / log / neighbor
        leaf neighbor {
          tailf:info "Neighbor events";
          tailf:cli-full-command;
          type empty;
        }

        // mpls ldp / log / graceful-restart
        leaf graceful-restart {
          tailf:info "Graceful Restart events";
          tailf:cli-full-command;
          type empty;
        }

        // mpls ldp / log / session-protection
        leaf session-protection {
          tailf:info "Session Protection events";
          tailf:cli-full-command;
          type empty;
        }

        // mpls ldp / log / nsr
        leaf nsr {
          tailf:info "NSR synchronization events";
          tailf:cli-full-command;
          type empty;
        }
      }

      // mpls ldp / graceful-restart
      leaf graceful-restart {
        tailf:info "Configure graceful restart feature";
        tailf:cli-full-command;
        type empty;
      }

      // mpls ldp / graceful-restart X
      container graceful-restart-conf {
        tailf:cli-drop-node-name;
        container graceful-restart {
          tailf:info "Configure graceful restart feature";
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;

          // mpls ldp / graceful-restart reconnect-timeout
          leaf reconnect-timeout {
            tailf:info "Session Reconnect timeout";
            type uint16 {
              tailf:info "<60-1800>;;Time (seconds)";
              range "60..1800";
            }
          }

          // mpls ldp / graceful-restart forwarding-state-holdtime
          leaf forwarding-state-holdtime {
            tailf:info "Forwarding State holdtime for a restarting LSR";
            type uint16 {
              tailf:info "<60-1800>;;Time (seconds)";
              range "60..1800";
            }
          }

          // mpls ldp / graceful-restart helper-peer maintain-on-local-reset for
          container helper-peer {
            tailf:info "Configure parameters related to GR peer(s) operating in helper mode";
            container maintain-on-local-reset {
              tailf:info "Maintain the state of a GR peer upon a local reset";
              leaf for {
                tailf:info "Access list of LDP Peers";
                type string {
                  tailf:info "WORD;;IPv4 access-list (specify peer LSR Ids)";
                }
              }
            }
          }
        }
      }

      // mpls ldp / holdtime
      leaf holdtime {
        tailf:info "Configure session holdtime";
        type uint16 {
          tailf:info "<15-65535>;;Time (seconds)";
        }
      }

      // mpls ldp / session
      container session {
        tailf:info "Configure session parameters";

        // mpls ldp / session backoff
        container backoff {
          tailf:info "Configure session backoff parameters";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf initial {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<5-2147483>;;Initial session backoff time (seconds)";
              range "5..2147483";
            }
          }
          leaf maximum {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<5-2147483>;;Maximum session backoff time (seconds)";
              range "5..2147483";
            }
          }
        }

        // mpls ldp / session holdtime
        leaf holdtime {
          tailf:info "Configure session holdtime";
          type uint16 {
            tailf:info "<15-65535>;;Time (seconds)";
            range "15..65535";
          }
        }

        // mpls ldp / session protection
        container protection {
          tailf:info "Configure session protection parameters";
          tailf:cli-delete-when-empty;
          tailf:cli-reset-container;
          presence true;
          choice protection-choice {
            leaf duration {
              tailf:info "Session protection duration after loss of link discovery";
              type union {
                type uint32 {
                  tailf:info "<30-2147483>;;Holdup time in seconds";
                  range "30..2147483";
                }
                type enumeration {
                  enum infinite {
                    tailf:info "Protect session forever after loss of link discovery";
                  }
                }
              }
            }
            leaf for {
              tailf:info "IP Access list to specify LDP Peers";
              type string {
                tailf:info "WORD;;IPv4 access-list (specify peer LSR Ids)";
              }
            }
          }
        }
      }

      // mpls ldp / signalling dscp
      container signalling {
        tailf:info "Configure signalling parameters";
        leaf dscp {
          tailf:info "Set DSCP for LDP control packets";
          type uint8 {
            tailf:info "<0-63>;;Differentiated Services Code Point (DSCP)";
            range "0..63";
          }
        }
      }

      // mpls ldp / igp sync delay
      container igp {
        tailf:info "Configure IGP related parameters";
        container sync {
          tailf:info "Configure LDP-IGP synchronization parameters";
          container delay-on-proc-restart {
            tailf:cli-drop-node-name;
            // mpls ldp / igp sync delay on-proc-restart
            container delay {
              tailf:info "Configure sync up delay after session up";
              leaf on-proc-restart {
                tailf:info "Global sync up delay to be used after process restart";
                type uint16 {
                  tailf:info "<60-600>;;Global sync-up delay (seconds)";
                  range "60..600";
                }
              }
            }
          }
          container delay {
            tailf:info "Configure sync up delay after session up";
            tailf:cli-compact-syntax;
            // mpls ldp / igp sync delay on-session-up
            leaf on-session-up {
              tailf:info "Interface sync-up delay after session up";
              type empty;
            }
            leaf delay-value {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<5-300>;;Interface sync-up delay (seconds)";
                range "5..300";
              }
            }
          }
        }
      }

      // mpls ldp / entropy-label
      leaf entropy-label {
        tailf:info "Configure Entropy Label";
        type empty;
      }

      // mpls ldp / mldp
      container mldp {
        tailf:info "Configure mLDP parameters";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-ldp-mldp";
        presence true;

        // mpls ldp / mldp / logging
        container logging {
          tailf:info "MLDP logging commands";

          // mpls ldp / mldp / logging notifications
          leaf notifications {
            tailf:info "MLDP logging notifications";
            type empty;
          }

          // mpls ldp / mldp / logging internal
          leaf internal {
            tailf:info "MLDP logging internal(cisco-support)";
            type empty;
          }
        }

        // mpls ldp / mldp / address-family ipv4
        container address-family {
          tailf:info "Configure Address Family and its parameters";
          container ipv4 {
            tailf:info "IPv4";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-ldp-mldp-af";
            presence true;

            // mpls ldp / mldp / address-family ipv4 / make-before-break
            container make-before-break {
              tailf:info "Make Before Break";

              // mpls ldp / mldp / address-family ipv4 / make-before-break delay
              container delay {
                tailf:info "MBB delay";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                leaf seconds {
                  tailf:cli-drop-node-name;
                  type uint16 {
                    tailf:info "<0-600>;;Forwarding delay in seconds";
                    range "0..600";
                  }
                }
                leaf delete-seconds {
                  tailf:cli-drop-node-name;
                  type uint8 {
                    tailf:info "<0-60>;;Delete delay in seconds";
                    range "0..60";
                  }
                }
              }
            }

            // mpls ldp / mldp / address-family ipv4 / forwarding recursive
            container forwarding {
              tailf:info "Forwarding commands";
              leaf recursive {
                tailf:info "Enable recursive forwarding";
                type empty;
              }
            }

            // mpls ldp / mldp / address-family ipv4 / recursive-fec
            container recursive-fec {
              tailf:info "MLDP Recursive FEC support";
              presence true;
            }
          }
        }
      }

      // mpls ldp / discovery
      container discovery {
        tailf:info "Configure discovery parameters";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-ldp-disc";

        // mpls ldp / discovery / instance-tlv
        container instance-tlv {
          tailf:info "Control support for Neighbor instance TLV in Hello messages";
          leaf disable {
            tailf:info "Disable transmit and receive processing for TLV";
            tailf:cli-full-command;
            type empty;
          }
        }

        // mpls ldp / discovery / hello
        container hello {
          tailf:info "LDP Link Hellos";
          leaf holdtime {
            tailf:info "Hello holdtime";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<1-65535>;;Time (seconds) - 65535 implies infinite";
              range "1..65535";
            }
          }
          leaf interval {
            tailf:info "Hello interval";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<1-65535>;;Time (seconds)";
              range "1..65535";
            }
          }
        }

        // mpls ldp / discovery / targeted-hello
        container targeted-hello {
          tailf:info "LDP Targeted Hellos";

          // mpls ldp / discovery / targeted-hello accept
          container accept {
            tailf:info "Accept and respond to targeted hellos";
            tailf:cli-delete-when-empty;
            tailf:cli-reset-container;
            presence true;
            leaf from {
              tailf:info "IP Access list to specify acceptable targeted hello sources";
              type string {
                tailf:info "WORD;;access-list";
              }
            }
          }

          // mpls ldp / discovery / targeted-hello holdtime
          leaf holdtime {
            tailf:info "Targeted hello holdtime";
            type uint16 {
              tailf:info "<1-65535>;;Time (seconds) - 65535 implies infinite";
              range "1..65535";
            }
          }

          // mpls ldp / discovery / targeted-hello interval
          leaf interval {
            tailf:info "Targeted Hello interval";
            type uint16 {
              tailf:info "<1-65535>;;Time (seconds)";
              range "1..65535";
            }
          }
        }
      }

      // mpls ldp / router-id
      leaf router-id {
        tailf:info "Configure router Id";
        tailf:cli-full-command;
        type union {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP address to be used";
          }
          type ifname;
        }
      }

      // mpls ldp / neighbor
      container neighbor {
        tailf:info "Configure neighbor parameters";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-ldp-nbr";

        // mpls ldp / neighbor / password
        container password {
          tailf:info "Configure password for MD5 authentication for all neighbors";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf type {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type enumeration {
              enum clear {
                tailf:info "Specifies an UNENCRYPTED password will follow";
              }
              enum encrypted {
                tailf:info "Specifies an ENCRYPTED password will follow";
              }
            }
          }
          leaf password {
            tailf:cli-drop-node-name;
            tailf:cli-reset-container;
            cli:secret " password <SECRET>";
            type NEDCOM_SECRET_TYPE {
              tailf:info "LINE;;The UNENCRYPTED (cleartext) password";
            }
          }
        }

        // mpls ldp / neighbor / *
        list neighbor-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-incomplete-command;
          key id;
          leaf id {
            type union {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;DEPRECATED - LSR Id of neighbor";
              }
              type string {
                tailf:info "A.B.C.D:;;LDP Id of neighbor";
              }
            }
          }

          // mpls ldp / neighbor / * password
          container password {
            tailf:info "Configure password for MD5 authentication";
            cli:secret " password <SECRET>";

            choice password-choice {
              // mpls ldp / neighbor / * password disable
              leaf disable {
                tailf:info "Disables the global password from this neighbor";
                type empty;
              }

              // mpls ldp / neighbor / * password clear
              leaf clear {
                tailf:info "Specifies an UNENCRYPTED password will follow";
                type NEDCOM_SECRET_TYPE {
                  tailf:info "LINE;;The UNENCRYPTED (cleartext) neighbor password";
                }
              }

              // mpls ldp / neighbor / * password encrypted
              leaf encrypted {
                tailf:info "Specifies an encrypted password will follow";
                type string {
                  tailf:info "WORD;;The ENCRYPTED neighbor password string";
                }
              }
            }
          }
        }
      }

      // mpls ldp / password
      container password {
        tailf:info "Configure LDP MD5 password";

        //  fallback  Specifies a fallback password will follow

        // mpls ldp / password option
        container option {
          tailf:info "LDP password options";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf sequence-nr {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<1-32767>;;Sequence number of the LDP password option";
              range "1..32767";
            }
          }
          leaf for {
            tailf:info "IP access-list specifying control on LDP peers";
            tailf:cli-incomplete-command;
            type string {
              tailf:info "WORD;;IP standard access-list for LDP peers; name or number (1-99)";
            }
          }
          leaf enc-type {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type enumeration {
              enum 0 {
                tailf:info "Specifies an UNENCRYPTED password will follow";
              }
              enum 7 {
                tailf:info "Specifies a HIDDEN password will follow";
              }
            }
          }
          leaf password {
            tailf:cli-drop-node-name;
            cisco-ios-xr:maapi-encrypted;
            type NEDCOM_SECRET_TYPE {
              tailf:info "LINE;;The UNENCRYPTED (cleartext) password";
            }
          }
        }

        // mpls ldp / password required
        container required {
          tailf:info "MD5 password is required for the peer";
          tailf:cli-reset-container;
          presence true;
          leaf for {
            tailf:info "IP access-list specifying control on LDP peers";
            type string {
              tailf:info "WORD;;IP standard access-list for LDP peers; name or number (1-99)";
            }
          }
        }
      }

      // mpls ldp / label
      container label {
        tailf:info "Configure label allocation, advertisement, and acceptance";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-ldp-lbl";

        // mpls ldp / label / allocate for
        container allocate {
          tailf:info "Configure label allocation control";
          leaf for {
            tailf:info "Limit label allocation to a set of prefixes";
            type string {
              tailf:info "WORD;;IP access-list";
            }
          }
        }

        // mpls ldp / label / accept
        container accept {
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-ldp-lbl-acpt";

          // mpls ldp / label / accept / from * for
          list from {
            tailf:info "Neighbor from whom to accept label advertisement";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key id;
            leaf id {
              type string {
                tailf:info "WORD;;Neighbor from whom to accept label advertisement";
              }
            }
            leaf for {
              tailf:info "IP access-list for destination prefixes";
              type string {
                tailf:info "WORD;;IP access-list name or number (1-99)";
              }
            }
          }
        }

        // mpls ldp / label / advertise
        container advertise {
          tailf:info "Configure outbound label advertisement control";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-ldp-lbl-advt";
          leaf disable {
            tailf:info "Disable label advertisement to all peers for all prefixes";
            tailf:cli-full-command;
            type empty;
          }
          leaf for {
            tailf:info "Prefix centric outbound label filtering";
            tailf:cli-full-command;
            type string {
              tailf:info "WORD;;IP access-list name or number (1-99)";
            }
          }
        }
      }

      // mpls ldp / address-family ipv4
      container address-family {
        tailf:info "Configure Address Family and its parameters";
        container ipv4 {
          tailf:info "IPv4";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-ldp-af";
          presence true;

          // mpls ldp / address-family ipv4 / neighbor * targeted
          list neighbor {
            tailf:info "Configure neighbor parameters";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key address;
            leaf address {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IP address of neighbor";
              }
            }
            leaf targeted {
              tailf:info "Establish targeted session";
              type empty;
            }
          }

          // mpls ldp / address-family ipv4 / discovery targeted-hello accept
          container discovery {
            tailf:info "Configure discovery parameters";
            container targeted-hello {
              tailf:info "LDP Targeted Hellos";
              container accept {
                tailf:info "Accept and respond to targeted hellos";
                tailf:cli-delete-when-empty;
                tailf:cli-reset-container;
                presence true;
                leaf from {
                  tailf:info "IP Access list to specify acceptable targeted hello sources";
                  type string {
                    tailf:info "WORD;;access-list";
                  }
                }
              }
            }
          }

          // mpls ldp / address-family ipv4 / label
          container label {
            tailf:info "Configure label control and policies";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-ldp-af-lbl";

            // mpls ldp / address-family ipv4 / label / local
            container local {
              tailf:info "Configure local label control and policies";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-ldp-af-lbl-lcl";

              // mpls ldp / address-family ipv4 / label / local / allocate
              container allocate {
                tailf:info "Configure label allocation control";
                leaf for {
                  tailf:info "Limit label allocation to a set of prefixes";
                  type union {
                    type string {
                      tailf:info "WORD;;IP access-list";
                    }
                    type enumeration {
                      enum host-routes {
                        tailf:info "Allocate label for host routes only";
                      }
                    }
                  }
                }
              }

              // mpls ldp / address-family ipv4 / label / local / advertise
              container advertise {
                tailf:info "Configure outbound label advertisement control";
                tailf:cli-add-mode;
                tailf:cli-mode-name "config-ldp-af-lbl-lcl-advt";

                // mpls ldp / address-family ipv4 / label / local / advertise / interface *
                list interface {
                  tailf:info "Advertise interface host address";
                  key name;
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  leaf name {
                    type ifname;
                  }
                }

                // mpls ldp / address-family ipv4 / label / local / advertise / explicit-null
                container explicit-null {
                  tailf:info "Configure explicit-null advertisement";
                  tailf:cli-compact-syntax;
                  tailf:cli-delete-when-empty;
                  presence true;
                  leaf for {
                    tailf:info "IP Access-list specifying controls on destination prefixes";
                    type string {
                      tailf:info "WORD;;IP access-list";
                    }
                  }
                  leaf to {
                    tailf:info "IP Access-list specifying controls on LDP Peers";
                    type string {
                      tailf:info "WORD;;IPv4 access-list (specify peer LSR Ids)";
                    }
                  }
                }

                // mpls ldp / address-family ipv4 / label / local / advertise / disable
                leaf disable {
                  tailf:info "Disable label advertisement to all peers for all prefixes";
                  type empty;
                }

                // mpls ldp / address-family ipv4 / label / local / advertise / for *
                list for {
                  tailf:info "Prefix centric outbound label filtering";
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  tailf:cli-compact-syntax;
                  tailf:cli-sequence-commands {
                    tailf:cli-reset-siblings;
                  }
                  key acl;
                  leaf acl {
                    tailf:info "WORD;;IP access-list";
                    type string {
                      tailf:info "WORD;;IP access-list";
                    }
                  }
                  leaf to {
                    tailf:info "IP access-list for LDP peers";
                    type string {
                      tailf:info "WORD;;IPv4 access-list (specify peer LSR Ids)";
                    }
                  }
                }

                // mpls ldp / address-family ipv4 / label / local / advertise / to *
                list to {
                  tailf:info "Peer centric outbound label filtering";
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  tailf:cli-compact-syntax;
                  tailf:cli-sequence-commands {
                    tailf:cli-reset-siblings;
                  }
                  key acl;
                  leaf acl {
                    type string {
                      tailf:info "A.B.C.D: LDP Id of neighbor";
                    }
                  }
                  leaf for {
                    tailf:info "IP access-list for prefixes to be sent";
                    type string {
                      tailf:info "WORD;;IP access-list";
                    }
                  }
                }
              }
            }

            // mpls ldp / address-family ipv4 / label / remote
            container remote {
              tailf:info "remote/peer label control and policies";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-ldp-af-lbl-rmt";

              // mpls ldp / address-family ipv4 / label / remote / accept
              container accept {
                tailf:cli-add-mode;
                tailf:cli-mode-name "config-ldp-af-lbl-rmt-acpt";

                // mpls ldp / address-family ipv4 / label / remote / accept / from *
                list from {
                  tailf:info "Neighbor from whom to accept label advertisement";
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  tailf:cli-incomplete-command;
                  key id;
                  leaf id {
                    type string {
                      tailf:info "WORD;;Neighbor from whom to accept label advertisement";
                    }
                  }
                  leaf for {
                    tailf:info "IP access-list for destination prefixes";
                    type string {
                      tailf:info "WORD;;IP access-list name or number (1-99)";
                    }
                  }
                }

              }
            }
          }

          // mpls ldp / address-family ipv4 / traffic-eng
          container traffic-eng {
            tailf:info "Configure LDP parameters for MPLS Traffic-Engineering (TE)";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-ldp-af-te";
            container auto-tunnel {
              tailf:info "Configure LDP TE auto-tunnel related parameters";
              // mpls ldp / address-family ipv4 / traffic-eng / auto-tunnel mesh
              container mesh {
                tailf:info "Configure TE auto-tunnel mesh groups";
                tailf:cli-add-mode;
                tailf:cli-mode-name "config-ldp-af-te-mesh";
                // mpls ldp / address-family ipv4 / traffic-eng / auto-tunnel mesh / group *
                list group {
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  key id;
                  leaf id {
                    type union {
                      type enumeration {
                        enum all {
                          tailf:info "Enable LDP on all TE meshgroup interfaces";
                        }
                      }
                      type uint32 {
                        tailf:info "<0-4294967295>;;The TE mesh group ID on which to enable LDP";
                      }
                    }
                  }
                }
              }
            }
          }

          // mpls ldp / address-family ipv4 / redistribute
          container redistribute {
            tailf:info "Redistribute routes from routing protocols";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-ldp-af-redist";

            // mpls ldp / address-family ipv4 / redistribute / bgp / as
            container bgp {
              tailf:info "Redistribute routes from BGP protocol";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-ldp-af-redist-bgp";
              leaf as {
                tailf:info "BGP AS-number";
                type string {
                  tailf:info "WORD;;AS number in 2-byte, 4-byte asdot and asplain";
                }
              }
            }
          }
        }
      }

      container capabilities {
        tailf:info "Configure LDP Capabilities(cisco-support)";
        choice sac-choice {
          leaf-list sac {
            tailf:info "State Advertisement Control";
            tailf:cli-flat-list-syntax;
            tailf:cli-replace-all;
            type enumeration {
              enum fec128-disable {
                tailf:info "Disable exchanging PW FEC128 label bindings";
              }
              enum fec129-disable {
                tailf:info "Disable exchanging PW FEC129 label bindings";
              }
              enum ipv4-disable {
                tailf:info "Disable exchanging IPv4 prefix label bindings";
              }
              enum ipv6-disable {
                tailf:info "Disable exchanging IPv6 prefix label bindings";
              }
            }
          }
          container sac-mldp-only {
            tailf:cli-drop-node-name;
            container sac {
              leaf mldp-only {
                tailf:info "Only exchange mLDP label bindings";
                type empty;
              }
            }
          }
        }
      }

      // mpls ldp / interface *
      list interface {
        tailf:info "Enable LDP on an interface and enter interface submode";
        tailf:cli-mode-name "config-ldp-if";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Interface Name";
          }
        }

        // mpls ldp / interface * / apply-group
        uses apply-group-grouping;

        // mpls ldp / interface * / igp sync delay on-session-up
        container igp {
          tailf:info "Configure igp parameters";
          container sync {
            tailf:info "Configure LDP-IGP synchronization parameters";
            container delay {
              tailf:info "Configure sync up delay";
              leaf on-session-up {
                tailf:info "Interface sync-up delay after session up";
                type union {
                  type uint16 {
                    tailf:info "<5-300>;;Interface sync-up delay (seconds)";
                    range "5..300";
                  }
                  type enumeration {
                    enum disable {
                      tailf:info "Disable";
                    }
                  }
                }
              }
            }
          }
        }

        // mpls ldp / interface * / discovery
        container discovery {
          tailf:info "Configure discovery parameters";

          // mpls ldp / interface * / discovery hello
          container hello {
            tailf:info "LDP Link Hellos";
            // mpls ldp / interface * / discovery hello holdtime
            leaf holdtime {
              tailf:info "Hello holdtime";
              type uint16 {
                tailf:info "<1-65535>;;Time (seconds) - 65535 implies infinite";
                range "1..65535";
              }
            }
            // mpls ldp / interface * / discovery hello interval
            leaf interval {
              tailf:info "Hello interval";
              type uint16 {
                tailf:info "<1-65535>;;Time (seconds)";
              }
            }
          }
        }

        // mpls ldp / interface * / address-family ipv4
        container address-family {
          tailf:info "Configure Address Family and its parameters";
          container ipv4 {
            tailf:info "IPv4";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-ldp-if-af";
            presence true;

            // mpls ldp / interface * / address-family ipv4 / mldp disable
            container mldp {
              tailf:info "Configure mLDP parameters";
              leaf disable {
                tailf:info "Disable mLDP on LDP enabled interface";
                type empty;
              }
            }

            // mpls ldp / interface * / address-family ipv4 / discovery transport-address
            container discovery {
              tailf:info "Configure discovery parameters";
              leaf transport-address {
                tailf:info "Specify interface LDP transport address";
                type union {
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;IP address to be used as transport address";
                  }
                  type enumeration {
                    enum interface {
                      tailf:info "Use this interface address as transport address";
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // mpls oam
    container oam {
      tailf:info "OAM configuration";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-oam";
      presence true;

      // mpls oam / echo
      container echo {
        tailf:info "Echo request attributes";

        // mpls oam / echo revision
        leaf revision {
          tailf:info "Echo packet default revision";
          type enumeration {
            enum "1" {
              tailf:info "draft-ietf-mpls-lsp-ping-03 (initial)";
            }
            enum "2" {
              tailf:info "draft-ietf-mpls-lsp-ping-03 (rev 1)";
            }
            enum "3" {
              tailf:info "draft-ietf-mpls-lsp-ping-03 (rev 2)";
            }
            enum "4" {
              tailf:info "draft-ietf-mpls-lsp-ping-09 (initial)";
            }
          }
        }

        // mpls oam / echo disable-vendor-extensio
        leaf disable-vendor-extension {
          tailf:info "Disable sending vendor extension TLV with echo req";
          tailf:cli-full-command;
          type empty;
        }
      }

      // mpls oam / dpm
      container dpm {
        tailf:info "data plane monitoring";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-oam-dpm";
        presence true;

        // mpls oam / dpm / pps
        leaf pps {
          tailf:info "DPM packets per second rate - default is 50pps";
          type uint8 {
            tailf:info "<1-250>;;Rate limit in packets per second - default is 50pps";
            range "1..250";
          }
        }

        // mpls oam / dpm / interval
        leaf interval {
          tailf:info "Wait time between each iteration of DPM - default is 30mins";
          type uint16 {
            tailf:info "<1-3600>;;Gap in minutes - default is 30 mins";
            range "1..3600";
          }
        }
      }
    }

    // mpls static
    container static {
      tailf:info "Configure static MPLS forwarding";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-mpls-static";
      presence true;

      // mpls static / ipv4 *
      list ipv4 {
        tailf:info "Configure MPLS static IPv4 imposition";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        tailf:cli-incomplete-command;
        key "address mask interface";
        leaf address {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IPv4 address";
          }
        }
        leaf mask {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IPv4 mask";
          }
        }
        leaf interface {
          type string {
            tailf:info "WORD;;Interface Name";
          }
        }
        leaf nexthop {
          tailf:cli-drop-node-name;
          tailf:cli-optional-in-sequence;
          tailf:cli-incomplete-command;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IPv4 address of next hop router";
          }
        }
        choice label-choice {
          leaf label {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<16-1048575>;;Outgoing label";
            }
          }
          leaf ipv4-explicit-null  {
            tailf:info "IPv4 explicit null";
            type empty;
          }
          leaf ipv6-explicit-null {
            tailf:info "IPv6 explicit null";
            type empty;
          }
          container pop {
            tailf:cli-compact-syntax;
            tailf:info "Pop label";
            presence true;
            choice pop-choice {
              leaf labelled {
                tailf:info "Pop label to MPLS only";
                type empty;
              }
              leaf unlabelled {
                tailf:info "Pop label to non-MPLS only";
                type empty;
              }
            }
          }
        }
      }

      // mpls static / interface *
      list interface {
        tailf:info "Enable MPLS Static on an interface";
        key name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        leaf name {
          type ifname;
        }
      }

      // mpls static / address-family ipv4 unicast
      container address-family {
        tailf:info "Configure Address Family and its parameters";
        list ipv4 {
          tailf:info "Configure IPv4 Address Family parameters";
          tailf:cli-mode-name "config-mpls-static-af";
          tailf:cli-full-command;
          key af-modifier;
          leaf af-modifier {
            type enumeration {
              enum unicast {
                tailf:code-name "ipv4_unicast";
                tailf:info "Unicast";
              }
            }
          }

          // mpls static / address-family ipv4 * / local-label *
          list local-label {
            tailf:info "Configure local label assignment and forwarding";
            tailf:cli-mode-name "config-mpls-static-af-lbl";
            tailf:cli-incomplete-command;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            key id;
            leaf id {
              type uint32 {
                tailf:info "<16-1048575>;;Label value";
                range "16..1048575";
              }
            }
            leaf allocate {
              tailf:info "Label Allocation Option";
              tailf:cli-hide-in-submode;
              type empty;
            }
            leaf per-prefix {
              tailf:info "For a given prefix";
              tailf:cli-hide-in-submode;
              tailf:cli-optional-in-sequence;
              type ipv4-prefix {
                tailf:info "A.B.C.D/length;;IPv4 Prefix";
              }
            }

            // mpls static / address-family ipv4 * / local-label * / forward
            container forward {
              tailf:cli-break-sequence-commands;
              tailf:info "Configure forwarding rewrites";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-mpls-static-af-lbl-fwd";
              list path {
                tailf:info "Configure cross-connect path parameters";
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                tailf:cli-incomplete-command;
                key id;
                leaf id {
                  type uint16 {
                    tailf:info "<1-1>;;Path count";
                  }
                }
                leaf nexthop {
                  tailf:info "nexthop";
                  tailf:cli-incomplete-command;
                  type ifname;
                }
                leaf nexthop-address {
                  tailf:cli-optional-in-sequence;
                  tailf:cli-incomplete-command;
                  tailf:cli-drop-node-name;
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;Next-hop IPv4 address";
                  }
                }
                leaf out-label {
                  tailf:info "output label";
                  type union {
                    type uint32 {
                      tailf:info "<16-1048575>;;Output MPLS label value";
                      range "16..1048575";
                    }
                    type enumeration {
                      enum exp-null {
                        tailf:info "Set the output label to explicit null";
                      }
                      enum pop {
                        tailf:info "Pop off the top of the label stack";
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }

      // mpls static / vrf *
      list vrf {
        tailf:info "Configure VRF parameters";
        tailf:cli-mode-name "config-mpls-static-vrf";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Specify the VRF Name";
          }
        }

        // mpls static / vrf * / address-family ipv4 unicast
        container address-family {
          tailf:info "Configure Address Family and its parameters";
          list ipv4 {
            tailf:info "Configure IPv4 Address Family parameters";
            tailf:cli-mode-name "config-mpls-static-vrf-af";
            tailf:cli-full-command;
            key af-modifier;
            leaf af-modifier {
              type enumeration {
                enum unicast {
                  tailf:code-name "mpls_static_vrf_ipv4_unicast";
                  tailf:info "Unicast";
                }
              }
            }
            // mpls static / vrf * / address-family ipv4 unicast / local-label *
            list local-label {
              tailf:info "Configure local label assignment and forwarding";
              tailf:cli-mode-name "config-mpls-static-vrf-af-lbl";
              tailf:cli-incomplete-command;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              key id;
              leaf id {
                tailf:cli-suppress-range;
                type uint32 {
                  tailf:info "<16-1048575>;;Label value";
                  range "16..1048575";
                }
              }
              leaf allocate {
                tailf:info "Label Allocation Option";
                tailf:cli-incomplete-command;
                tailf:cli-hide-in-submode;
                type empty;
              }
              choice allocate-choice {
                leaf per-prefix {
                  tailf:info "For a given prefix";
                  tailf:cli-hide-in-submode;
                  tailf:cli-optional-in-sequence;
                  type ipv4-prefix {
                    tailf:info "A.B.C.D/length;;IPv4 Prefix";
                  }
                }
                leaf per-vrf {
                  tailf:info "For a VRF";
                  tailf:cli-hide-in-submode;
                  type empty;
                }
              }

              // mpls static / vrf * / address-family ipv4 unicast / local-label * / forward
              container forward {
                tailf:info "Configure forwarding rewrites";
                tailf:cli-break-sequence-commands;
                tailf:cli-add-mode;
                tailf:cli-mode-name "config-mpls-static-vrf-af-lbl-fwd";
                when "../per-vrf";
                list path {
                  tailf:info "Configure cross-connect path parameters";
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  tailf:cli-incomplete-command;
                  key id;
                  leaf id {
                    tailf:cli-suppress-range;
                    type uint8 {
                      tailf:info "<1-1>;;Path count";
                    }
                  }
                  leaf pop-and-lookup {
                    tailf:info "Pop and lookup";
                    type empty;
                  }
                }
              }
            }
          }
        }
      }
    }

    // mpls ip-ttl-propagate
    container ip-ttl-propagate {
      tailf:info "Propagate IP TTL into the label stack";
      container disable {
        tailf:info "Disable IP TTL propagation";
        tailf:cli-delete-when-empty;
        tailf:cli-reset-container;
        presence true;
        leaf disable-type {
          tailf:cli-drop-node-name;
          type enumeration {
            enum forwarded {
              tailf:info "Disable IP TTL propagation for only forwarded MPLS packets";
            }
            enum local {
              tailf:info "Disable IP TTL propagation for only locally generated MPLS packets";
            }
          }
        }
      }
    }

    // mpls ip-ttl-expiration-pop
    leaf ip-ttl-expiration-pop {
      tailf:info "Number of labels to pop when MPLS TTL expires";
      type uint8 {
        tailf:info "<1-10>;;Number of labels to pop on TTL expiry";
        range "1..10";
      }
    }

    // mpls lsd
    container lsd {
      tailf:info "MPLS LSD process command";

      // mpls lsd app-reg-delay disable
      container app-reg-delay {
        tailf:info "Application registration delay";
        leaf disable {
          tailf:info "Disable delay for regular applications' registration";
          type empty;
        }
      }

      // mpls lsd ltrace-buffer multiplier
      container ltrace-buffer {
        tailf:info "MPLS LSD LTrace buffer files(cisco-support)";
        leaf multiplier {
          tailf:info "Ltrace buffer file size multiplier(cisco-support)";
          type uint8 {
            tailf:info "<2-5>;;Multiplier factor";
            range "2..5";
          }
        }
      }
    }

    // mpls ipv4 ttl-expiration-pop
    container ipv4 {
      tailf:info "Configure IPv4 parameters";
      leaf ttl-expiration-pop {
        tailf:info "Number of labels to pop when MPLS TTL expires";
        type uint8 {
          tailf:info "<1-10>;;Number of labels to pop on TTL expiry";
          range "1..10";
        }
      }
    }

    // mpls ipv6 ttl-expiration-pop
    container ipv6 {
      tailf:info "Configure IPv6 parameters";
      leaf ttl-expiration-pop {
        tailf:info "Number of labels to pop when MPLS TTL expires";
        type uint8 {
          tailf:info "<1-10>;;Number of labels to pop on TTL expiry";
          range "1..10";
        }
      }
    }
  }


  /// ========================================================================
  /// bmp
  /// ========================================================================

  container bmp {
    tailf:info "BGP Monitoring Protocol commands";
    tailf:cli-explicit-exit;

    // bmp server *
    container server {
      tailf:info "BMP server configuration";

      // bmp server all
      container all {
        tailf:info "Common commands for all BMP servers";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-bgp-bmp";

        // bmp server all / max-buffer-size
        leaf max-buffer-size {
          tailf:info "Maximum buffer limit upto which BMP messages will be queued to TCP sockets";
          type uint32 {
            tailf:info "<1-4294967295>;;Range in MegaBytes for the maximum buffer size of BMP message queue.";
            range "1..4294967295";
          }
        }
      }

      // bmp server *
      list server-list {
        tailf:cli-drop-node-name;
        tailf:cli-mode-name "config-bgp-bmp";
        key id;
        leaf id {
          type uint8 {
            tailf:info "<1-8>;;BMP server ID to configure";
            range "1..8";
          }
        }

        // bmp server * / host
        container host {
          tailf:info "Hostname of BMP Server";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf name {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type inet:host {
              tailf:info "WORD;;Name of the BMP server(accepts IP Address format too)";
            }
          }
          leaf port {
            tailf:info "BMP Server Listen Port";
            type uint16 {
              tailf:info "<1-65535>;;Port Number of listening BMP server";
              range "1..65535";
            }
          }
        }

        // bmp server * / dscp
        leaf dscp {
          tailf:info "Set IP DSCP (DiffServ CodePoint)";
          type dscp-type;
        }

        // bmp server * / description
        uses description-grouping;

        // bmp server * / vrf
        leaf vrf {
          tailf:info "VRF for the BMP server";
          type string {
            tailf:info "WORD;;VRF Name";
          }
        }

        // bmp server * / update-source
        container update-source {
          tailf:info "Source to reach BMP server";
          uses interface-name-grouping;
        }

        // bmp server * / flapping-delay
        leaf flapping-delay {
          tailf:info "delay in connecting to BMP Server after a flap had been detected. Default=300";
          type uint16 {
            tailf:info "<60-3600>;;Range in seconds for the connection delay after flap";
            range "60..3600";
          }
        }

        // bmp server * / initial-delay
        leaf initial-delay {
          tailf:info "Initial connect delay in sending BMP server updates. Default=0";
          type uint16 {
            tailf:info "<1-3600>;;Initial connect delay in sending BMP server updates";
            range "1..3600";
          }
        }

        // bmp server * / stats-reporting-period
        leaf stats-reporting-period {
          tailf:info "Stats reporting period for BMP server. Default=0";
          type uint16 {
            tailf:info "<1-3600>;;Stats-report-period in seconds";
            range "1..3600";
          }
        }

        // bmp server * / initial-refresh
        container initial-refresh {
          tailf:info "Initial refresh to generate BGP updates. DEfault=1";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          choice refresh-choice {
            leaf skip {
              tailf:info "Skip sending Refresh request to Peers";
              tailf:cli-optional-in-sequence;
              type empty;
            }
            case delay {
              leaf delay {
                tailf:info "Initial delay before sending route refresh request";
                type uint16 {
                  tailf:info "<1-3600>;;Delay in sending Refresh request to Peers (default : 30 secs)";
                  range "1..3600";
                }
              }
              leaf spread {
                tailf:info "Maximum additional random delay for initial Refresh Request";
                type uint16 {
                  tailf:info "<1-3600>;;Maximum additional random delay (in secs)";
                  range "1..3600";
                }
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// segment-routing
  /// ========================================================================

  uses segment-routing-grouping;

  grouping segment-routing-grouping {
    container segment-routing {
      tailf:info "Segment Routing";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-sr";
      //DISABLED DUE TO XR API CHANGES: tailf:cli-explicit-exit;
      presence true;

      // segment-routing / global-block
      container global-block {
        tailf:info "Prefix-SID Global label Block (SRGB)";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf lower-bound {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<16000-1048574>;;The lower bound of the SRGB";
            range "16000..1048574";
          }
        }
        leaf upper-bound {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<16001-1048575>;;The upper bound of the SRGB";
            range "16001..1048575";
          }
        }
      }

      // segment-routing / local-block
      container local-block {
        tailf:info "Local Block (SRLB) of labels";
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        leaf lower {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<15000-1048575>;;The lower bound of SRLB";
          }
        }
        leaf upper {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<47111-1048575>;;The upper bound of SRLB (block size may not exceed 262143)";
          }
        }
      }

      // segment-routing / mapping-server
      container mapping-server {
        tailf:info "Segment Routing Mapping Server (SRMS)";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-sr-sm";

        // segment-routing / mapping-server / prefix-sid-map
        container prefix-sid-map {
          tailf:info "Prefix SID Map";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-sr-sm-map";

          // segment-routing / mapping-server / prefix-sid-map / address-family
          container address-family {
            tailf:info "Address Family";

            // segment-routing / mapping-server / prefix-sid-map / address-family ipv4
            container ipv4 {
              tailf:info "IP version 4";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-sr-sm-map-af";

              // segment-routing / mapping-server / prefix-sid-map / address-family ipv4 / *
              list prefix {
                tailf:cli-drop-node-name;
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                tailf:cli-incomplete-command;
                key prefix;
                leaf prefix {
                  type inet:ipv4-prefix {
                    tailf:info "A.B.C.D/length;;IPv4 address with prefix";
                  }
                }
                leaf SID-interval {
                  tailf:cli-drop-node-name;
                  type uint32 {
                    tailf:info "<0-1048575>;;Start of SID index range";
                    range "0..1048575";
                  }
                }
                leaf range {
                  tailf:info "Number of allocated SIDs";
                  type uint32 {
                    tailf:info "<0-1048575>;;Number of allocated SIDs";
                    range "0..1048575";
                  }
                }
              }
            }
          }
        }
      }

      // segment-routing / traffic-eng
      container traffic-eng {
        tailf:info "Segment Routing Traffic Engineering";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-sr-te";
        presence true;

        // segment-routing / traffic-eng / apply-group
        uses apply-group-grouping;

        // segment-routing / traffic-eng / srv6
        uses segment-routing-te-srv6-grouping;

          // segment-routing / traffic-eng / candidate-paths
        container candidate-paths {
          tailf:info "Configurations for candidate paths.";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-sr-te-candidate-path";
          presence true;
        }

        // segment-routing / traffic-eng / interface *
        list interface {
          tailf:info "Enable SR-TE on an interface(cisco-support)";
          tailf:cli-mode-name "config-sr-if";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Interface Name";
            }
          }

          // segment-routing / traffic-eng / interface * / affinity
          container affinity {
            tailf:info "Interface affinity configuration(cisco-support)";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-sr-if-affinity";

            // segment-routing / traffic-eng / interface * / affinity / color *
            // Note: XR 6.5.1?
            list color {
              tailf:info "An affinity color";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key name;
              leaf name {
                type string {
                  tailf:info "WORD;;Affinity color name";
                }
              }
            }

            // segment-routing / traffic-eng / interface * / affinity / name *
            // Note: XR 6.5.2
            list name {
              tailf:info "Affinity name";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key name;
              leaf name {
                type string {
                  tailf:info "WORD;;Affinity color name";
                }
              }
            }
          }

          // segment-routing / traffic-eng / interface * / metric
          leaf metric {
            tailf:info "Interface TE metric configuration";
            type uint32 {
              tailf:info "<0-2147483647>;;TE metric value";
              range "0..2147483647";
            }
          }
        }

        // segment-routing / traffic-eng / logging
        container logging {
          tailf:info "Logging configuration";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-sr-te-log";

          // segment-routing / traffic-eng / logging / policy status
          container policy {
            tailf:info "Configure policy logging parameters";
            leaf status {
              tailf:info "Enable policy status logging";
              type empty;
            }
          }
        }

        // segment-routing / traffic-eng / segment-list *
        list segment-list {
          tailf:info "Segment-list configuration";
          tailf:cli-mode-name "config-sr-te-sl";
          key name;
          leaf name {
            tailf:info "Segment-list name";
            tailf:cli-suppress-range;
            type string {
              tailf:info "WORD;;Identifying name for segment-list with max 128 characters";
              length "1..128";
            }
          }

          // segment-routing / traffic-eng / segment-list * name
          leaf prefix {
            tailf:cli-drop-node-name;
            tailf:cli-prefix-key;
            tailf:ned-ignore-compare-config;
            type enumeration {
              enum name {
                         tailf:info "Segment-list name [DEPRECATED]";
              }
            }
          }

          // segment-routing / traffic-eng / segment-list * / index * mpls label
          // segment-routing / traffic-eng / segment-list * / index * mpls adjacency
          // segment-routing / traffic-eng / segment-list * / index * address ipv4
          list index {
            tailf:info "Next entry index";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key id;
            leaf id {
              tailf:cli-suppress-range;
              type uint16 {
                tailf:info "<1-65535>;;Index number";
                range "1..65535";
              }
            }
            choice config-choice {
              container mpls {
                tailf:info "MPLS configuration";
                leaf label {
                  tailf:info "MPLS label configuration";
                  type uint32 {
                    tailf:info "<0-1048575>;;MPLS label value";
                    range "0..1048575";
                  }
                }
                leaf adjacency {
                  tailf:info "Specify hop address";
                  type union {
                    type inet:ipv4-address {
                      tailf:info "A.B.C.D;;Ip Address";
                    }
                    type inet:ipv6-address {
                      tailf:info "X:X::X;;IPV6 address";
                    }
                  }
                }
              }
              container address {
                tailf:info "Specify hop address";
                leaf ipv4 {
                  tailf:info "Specify the address AFI";
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;IPv4 address (A.B.C.D)";
                  }
                }
              }
            }
          }
        }

        // segment-routing / traffic-eng / on-demand color *
        container on-demand {
          tailf:info "On-Demand configuration";
          list color {
            tailf:info "On-Demand color configuration";
            tailf:cli-mode-name "config-sr-te-color";
            tailf:cli-explicit-exit;
            key id;
            leaf id {
              type uint32 {
                tailf:info "<1-4294967295>;;color value";
                range "1..4294967295";
              }
            }

            // segment-routing / traffic-eng / on-demand color * / srv6
            container srv6 {
              tailf:info "Segment Routing with IPv6 dataplane";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-sr-te-color-srv6";
              presence true;

              // segment-routing / traffic-eng / on-demand color * / srv6 / locator
              container locator {
                tailf:info "Configure locator";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                leaf name {
                  tailf:cli-drop-node-name;
                  tailf:cli-incomplete-command;
                  type string {
                    tailf:info "WORD;;Specify locator name with max 64 characters";
                  }
                }
                container binding-sid {
                  tailf:info "Binding-SID allocation options";
                  tailf:cli-flatten-container;
                  tailf:cli-compact-syntax;
                  container dynamic {
                    tailf:info "Dynamic based option";
                    tailf:cli-flatten-container;
                    tailf:cli-compact-syntax;
                    container behavior {
                      tailf:info "Binding-SID behavior options";
                      tailf:cli-flatten-container;
                      tailf:cli-compact-syntax;
                      leaf ub6-insert-reduced {
                        tailf:info "Binding-SID insert reduced behavior";
                        type empty;
                      }
                    }
                  }
                }
              }
            }

            // segment-routing / traffic-eng / on-demand color * / source-address ipv4
            container source-address {
              tailf:info "Source address of ODN policies";
              choice address-source {
                leaf ipv4 {
                  tailf:info "IPv4 address";
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;IPv4 source address";
                  }
                }
                leaf ipv6 {
                  tailf:info "IPv6 address";
                  type inet:ipv6-address {
                    tailf:info "X:X::X;;IPv6 source address";
                  }
                }
              }
            }

            // segment-routing / traffic-eng / on-demand color * / bandwidth
            leaf bandwidth {
              tailf:info "Requested Bandwidth";
              type uint32 {
                tailf:info "<1-4294967295>;;Bandwidth value in kbps";
                range "1..4294967295";
              }
            }

            // segment-routing / traffic-eng / on-demand color * / dynamic
            // segment-routing / traffic-eng / on-demand color * / dynamic mpls
            container dynamic {
              tailf:info "Dynamically computed path";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-sr-te-color-dyn";
              presence true;
              leaf mpls {
                tailf:info "MPLS path type";
                tailf:cli-hide-in-submode;
                tailf:ned-ignore-compare-config;
                type empty;
              }

              // segment-routing / traffic-eng / on-demand color * / dynamic / pce
              // segment-routing / traffic-eng / on-demand color * / dynamic / pcep
              container pcep {
                tailf:info "Use Path Computation Element to obtain a path"
                  +" [pcep will be auto-transformed to pce for older XR]";
                tailf:cli-add-mode;
                tailf:cli-mode-name "config-sr-te-color-dyn-mpls-pce";
                presence true;
              }

              // segment-routing / traffic-eng / on-demand color * / dynamic / metric
              container metric {
                tailf:info "Specify the path computation metric options";
                tailf:cli-add-mode;
                tailf:cli-mode-name "config-sr-te-color-dyn-mpls-metric";
                presence true;

                // segment-routing / traffic-eng / on-demand color * / dynamic / metric / type
                leaf type {
                  tailf:info "Specify the path computation metric type to be used";
                  type enumeration {
                    enum igp {
                              tailf:info "Use the IGP metric for path computation";
                    }
                    enum te {
                             tailf:info "Use the TE metric for path computation";
                    }
                    enum latency {
                                  tailf:info "Use the measure latency for path computation";
                    }
                    enum hopcount {
                                   tailf:info "Use the least number of hops for path computation";
                    }
                  }
                }

                // segment-routing / traffic-eng / on-demand color * / dynamic / metric / margin
                container margin {
                  tailf:info "Metric margin";
                  choice margin-choice {
                    leaf absolute {
                      tailf:info "Absolute metric margin";
                      type uint32 {
                        tailf:info "<0-2147483647>;;Absolute metric margin value";
                      }
                    }
                    leaf relative {
                      tailf:info "Relative metric margin";
                      type uint32 {
                        tailf:info "<0-2147483647>;;Relative metric margin value";
                      }
                    }
                  }
                }
              }

              // segment-routing / traffic-eng / on-demand color * / dynamic / disjoint-path
              container disjoint-path {
                tailf:info "Request disjoint path computation";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                leaf group-id {
                  tailf:info "Group ID";
                  tailf:cli-incomplete-command;
                  type uint16 {
                    tailf:info "<1-65535>;;Group ID";
                    range "1..65535";
                  }
                }
                leaf type {
                  tailf:info "Disjointness type";
                  type enumeration {
                    enum link {
                               tailf:info "Link Disjointness";
                    }
                    enum node {
                               tailf:info "Node Disjointness";
                    }
                    enum srlg {
                               tailf:info "SRLG Disjointness";
                    }
                    enum srlg-node {
                      tailf:info "SRLG Node Disjointness";
                    }
                  }
                }
                leaf sub-id {
                  tailf:info "Subgroup ID";
                  type uint16 {
                    tailf:info "<1-65535>;;Subgroup ID number";
                    range "1..65535";
                  }
                }
              }

              // segment-routing / traffic-eng / on-demand color * / dynamic / flex-alg
              leaf flex-alg {
                tailf:info "Specify the path computation metric options";
                type uint16 {
                  tailf:info "<1-65535>;;Flex-algorithm value";
                  range "1..65535";
                }
              }

              // segment-routing / traffic-eng / on-demand color * / dynamic / anycast-sid-inclusion
              container anycast-sid-inclusion {
                tailf:info "Anycast SID Inclusion";
                tailf:cli-add-mode;
                tailf:cli-mode-name "config-sr-te-color-dyn-anycast";
                presence true;
              }

              // segment-routing / traffic-eng / on-demand color * / dynamic / sid-algorithm
              leaf sid-algorithm {
                tailf:info "Specify the Prefix-SID algorithm";
                type uint8 {
                  tailf:info "<128-255>;;The Prefix-SID algorithm value";
                  range "128..255";
                }
              }

              // segment-routing / traffic-eng / on-demand color * / dynamic / affinity *
              list affinity {
                tailf:info "Assign affinities to path";
                tailf:cli-mode-name "config-sr-te-color-aff-rule";
                key name;
                leaf name {
                  type enumeration {
                    enum include-all {
                      tailf:info "Affinity attributes - all must be included";
                    }
                    enum include-any {
                      tailf:info "Affinity attributes - at least one must be included";
                      value 2;
                    }
                    enum exclude-any {
                      tailf:info "Affinity attributes to exclude - presence of at least one excludes link";
                      value 3;
                    }
                  }
                }

                // segment-routing / traffic-eng / on-demand color * / dynamic / affinity * / name *
                list name-list {
                  tailf:cli-drop-node-name;
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  leaf name {
                    tailf:info "Affinity name";
                    tailf:cli-prefix-key;
                    type empty;
                  }
                  key color;
                  leaf color {
                    type string {
                      tailf:info "WORD;;Affinity color name";
                    }
                  }
                }
              }
            }

            // segment-routing / traffic-eng / on-demand color * / maximum-sid-depth
            leaf maximum-sid-depth {
              tailf:info "Maximum SID Depth";
              type uint8 {
                tailf:info "<1-255>;;Maximum SID Depth";
                range "1..255";
              }
            }

            // segment-routing / traffic-eng / on-demand color * / per-flow
            container per-flow {
              tailf:info "Per-flow configuration";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-sr-te-odc-pfp";
              presence true;

              // segment-routing / traffic-eng / on-demand color * / per-flow / forward-class *
              list forward-class {
                tailf:info "Specify forward class for per-flow based routing";
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                tailf:cli-compact-syntax;
                tailf:cli-incomplete-command;
                key id;
                leaf id {
                  type union {
                    type uint8 {
                      tailf:info "<0-7>;;Forward class value";
                    }
                    type enumeration {
                      enum default {
                        tailf:info "Configure default forward-class";
                      }
                    }
                  }
                }
                leaf color {
                  tailf:info "Specify corresponding policy color for the forwarding class";
                  type uint32 {
                    tailf:info "<1-4294967295>;;Color value";
                  }
                }
              }
            }

            // segment-routing / traffic-eng / on-demand color * / steering
            container steering {
              tailf:info "Steering options for on-demand color";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-sr-te-on-demand-color-steering";

              // segment-routing / traffic-eng / on-demand color * / steering / path-invalidation
              container path-invalidation {
                tailf:info "Path invalidation action, default is to fall back to unconstrained IGP path";
                leaf drop {
                  tailf:info "If path became invalid, keep policy up, but drop all traffic sent on the policy";
                  type empty;
                }
              }
            }

            // segment-routing / traffic-eng / on-demand color * / constraints
            container constraints {
              tailf:info "Candidate path constraints";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-sr-te-color-const";

              // segment-routing / traffic-eng / on-demand color * / constraints / segments
              container segments {
                tailf:info "Path segments constraints";
                tailf:cli-add-mode;
                tailf:cli-mode-name "config-sr-te-color-const-seg";

                // segment-routing / traffic-eng / on-demand color * / constraints / segments / sid-algorithm
                leaf sid-algorithm {
                  tailf:info "Specify the Prefix-SID algorithm";
                  type uint8 {
                    tailf:info "<128-255>;;The Prefix-SID algorithm value";
                    range "128..255";
                  }
                }
              }
            }
          }
        }

        // segment-routing / traffic-eng / maximum-sid-depth
        leaf maximum-sid-depth {
          tailf:info "Maximum number of SIDs that the PCC can impose on a packet";
          type uint8 {
            tailf:info "<1-255>;;Maximum SID Depth";
            range "1..255";
          }
        }

        // segment-routing / traffic-eng / policy *
        list policy {
          tailf:info "Name of SR-TE Policy";
          tailf:cli-mode-name "config-sr-te-policy";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Identifying name for policy with max 128 characters";
            }
          }

          // segment-routing / traffic-eng / policy * / srv6
          uses segment-routing-te-srv6-grouping;

          // segment-routing / traffic-eng / policy * / bandwidth
          leaf bandwidth {
            tailf:info "Requested Bandwidth";
            type uint32 {
              tailf:info "<0-4294967295>;;Bandwidth value";
            }
          }

          // segment-routing / traffic-eng / policy * / binding-sid mpls
          container binding-sid {
            tailf:info "Binding Segment Identifier";
            leaf mpls {
              tailf:info "MPLS label";
              type uint32 {
                tailf:info "<16-1048575>;;MPLS label";
                range "16..1048575";
              }
            }
          }

          // segment-routing / traffic-eng / policy * / source-address
          container source-address {
            tailf:info "Source address of policy";
            choice address-source {
              leaf ipv4 {
                tailf:info "IPv4 address";
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IPv4 source address";
                }
              }
              leaf ipv6 {
                tailf:info "IPv6 address";
                type inet:ipv6-address {
                  tailf:info "X:X::X;;IPv6 source address";
                }
              }
            }
          }

          // segment-routing / traffic-eng / policy * / color
          container color {
            tailf:info "Specify color for policy";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf value {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint32 {
                tailf:info "<1-4294967295>;;Color value";
                range "1..4294967295";
              }
            }
            container end-point {
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              choice af-choice {
                leaf ipv4 {
                  tailf:info "IPv4 address";
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;IPv4 endpoint address";
                  }
                }
                leaf ipv6 {
                  tailf:info "IPv6 address";
                  type inet:ipv6-address {
                    tailf:info "X:X::X;;IPv6 endpoint address (X:X::X)";
                  }
                }
              }
            }
          }

          // segment-routing / traffic-eng / policy * / autoroute
          container autoroute {
            tailf:info "Autoroute configuration";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-sr-te-policy-autoroute";
            presence true;

            // segment-routing / traffic-eng / policy * / autoroute / metric
            container metric {
              tailf:info "Autoroute metric";
              choice metric-choice {
                leaf constant {
                  tailf:info "Set metric mode constant";
                  type uint32 {
                    tailf:info "<1-2147483647>;;Constant metric";
                    range "1..2147483647";
                  }
                }
                leaf relative {
                  tailf:info "Set metric mode relative";
                  type int8 {
                    tailf:info "<-10,+10>;;Relative metric";
                    range "-10..10";
                  }
                }
              }
            }

            // segment-routing / traffic-eng / policy * / autoroute / force-sr-include
            leaf force-sr-include {
              tailf:info "Force autoroute Policy to be safe for carrying SR Labelled traffic";
              type empty;
            }

            // segment-routing / traffic-eng / policy * / autoroute / include
            container include {
              tailf:info "Prefixes for which IGP routes will be installed";
              // segment-routing / traffic-eng / policy * / autoroute / include ipv4 *
              list ipv4 {
                tailf:info "IPv4 address family";
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                key prefix;
                leaf prefix {
                  type ipv4-prefix {
                    tailf:info "A.B.C.D/length;;IP prefix route to include";
                  }
                }
              }
              // segment-routing / traffic-eng / policy * / autoroute / include all
              leaf all {
                tailf:info "Include all eligible prefixes";
                type empty;
              }
            }

            // segment-routing / traffic-eng / policy * / autoroute / forward-class
            leaf forward-class {
              tailf:info "Specify forward class for policy based routing";
              type uint8 {
                tailf:info "<0-7>;;Forward class value, default value is 0";
                range "0..7";
              }
            }
          }

          // segment-routing / traffic-eng / policy * / shutdown
          leaf shutdown {
            tailf:info "Policy admin-shutdown";
            type empty;
          }

          // segment-routing / traffic-eng / policy * / candidate-paths
          container candidate-paths {
            tailf:info "Candidate-paths configuration";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-sr-te-policy-path";
            presence true;

            // segment-routing / traffic-eng / policy * / candidate-paths / preference *
            list preference {
              tailf:info "Policy path-option preference entry";
              tailf:cli-mode-name "config-sr-te-policy-path-preference";
              key id;
              leaf id {
                type uint16 {
                  tailf:info "<1-65535>;;Path-option preference";
                  range "1..65535";
                }
              }

              // segment-routing / traffic-eng / policy * / candidate-paths / preference * / dynamic
              // segment-routing / traffic-eng / policy * / candidate-paths / preference * / dynamic mpls
              container dynamic {
                tailf:info "Dynamically allocated path";
                tailf:cli-add-mode;
                tailf:cli-mode-name "config-sr-te-pp-info";
                presence true;
                leaf mpls {
                  tailf:info "MPLS path type";
                  tailf:cli-hide-in-submode;
                  tailf:ned-ignore-compare-config;
                  type empty;
                }

                // segment-routing / traffic-eng / policy * / candidate-paths / preference * / dynamic / pce
                // segment-routing / traffic-eng / policy * / candidate-paths / preference * / dynamic / pcep
                container pcep {
                  tailf:info "Path Computation Element Protocol related configuration"
                    +" [pcep will be auto-transformed to pce for older XR]";
                  tailf:cli-add-mode;
                  tailf:cli-mode-name "config-sr-te-path-pce";
                  presence true;

                  // segment-routing / traffic-eng / policy * / candidate-paths / preference * / dynamic / pce / address
                  container address {
                    tailf:info "PCE address";
                    leaf ipv4 {
                      tailf:info "IPv4 address of PCE";
                      type inet:ipv4-address {
                        tailf:info "A.B.C.D;;IPv4 address of PCE";
                      }
                    }
                  }
                }

                // segment-routing / traffic-eng / policy * / candidate-paths / preference * / dynamic / weight
                leaf weight {
                  tailf:info "Path option weight";
                  type uint32 {
                    tailf:info "<0-4294967295>;;Weight";
                  }
                }

                // segment-routing / traffic-eng / policy * / candidate-paths / preference * / dynamic / metric
                container metric {
                  tailf:info "Path metric configuration";
                  tailf:cli-add-mode;
                  tailf:cli-mode-name "config-sr-te-path-metric";
                  presence true;

                  // segment-routing / traffic-eng / policy * / candidate-paths / preference * / dynamic / metric / sid-limit
                  leaf sid-limit {
                    tailf:info "SID limit";
                    type uint8 {
                      tailf:info "<1-255>;;SID limit value";
                      range "1..255";
                    }
                  }

                  // segment-routing / traffic-eng / policy * / candidate-paths / preference * / dynamic / metric / type
                  leaf type {
                    tailf:info "Metric type configuration";
                    type enumeration {
                      enum igp {
                                tailf:info "IGP metric type";
                      }
                      enum te {
                               tailf:info "TE metric type";
                      }
                      enum latency {
                                    tailf:info "Latency metric type";
                      }
                      enum hopcount {
                                     tailf:info "Hopcount metric type";
                      }
                    }
                  }

                  // segment-routing / traffic-eng / policy * / candidate-paths / preference * / dynamic / metric / margin
                  container margin {
                    tailf:info "Metric margin";
                    choice margin-choice {
                      leaf absolute {
                        tailf:info "Metric mode absolute";
                        type uint32 {
                          tailf:info "<0-2147483647>;;Absolute metric value";
                          range "0..2147483647";
                        }
                      }
                      leaf relative {
                        tailf:info "Metric mode relative";
                        type uint32 {
                          tailf:info "<0-2147483647>;;Relative metric value";
                          range "0..2147483647";
                        }
                      }
                    }
                  }
                }
              }

              // segment-routing / traffic-eng / policy * / candidate-paths / preference * / explicit segment-list *
              container explicit {
                tailf:info "Preconfigured path";
                list segment-list {
                  tailf:info "Specify Segment-list";
                  tailf:cli-mode-name "config-sr-te-pp-info";
                  key name;
                  leaf name {
                    type string {
                      tailf:info "WORD;;Identifying name for Segment-list";
                    }
                  }

                  // segment-routing / traffic-eng / policy * / candidate-paths / preference * / explicit segment-list * / weight
                  leaf weight {
                    tailf:info "Path option weight";
                    type uint32 {
                      tailf:info "<0-4294967295>;;Weight";
                    }
                  }
                }
              }

              // segment-routing / traffic-eng / policy * / candidate-paths / preference * / constraints
              container constraints {
                tailf:info "Candidate path constraints";
                tailf:cli-add-mode;
                tailf:cli-mode-name "config-sr-te-path-pref-const";

                // segment-routing / traffic-eng / policy * / candidate-paths / preference * / constraints / segments
                container segments {
                  tailf:info "Path segments constraints";
                  tailf:cli-add-mode;
                  tailf:cli-mode-name "config-sr-te-path-pref-const-seg";

                  // segment-routing / traffic-eng / policy * / candidate-paths / preference * / constraints / segments / sig-algorithm
                  leaf sid-algorithm {
                    tailf:info "Prefix-SID algorithm";
                    type uint8 {
                      tailf:info "<128-255>;;Prefix-SID algorithm";
                      range "128..255";
                    }
                  }
                  // segment-routing / traffic-eng / policy * / candidate-paths / preference * / constraints / segments / protection
                  leaf protection {
                    tailf:info "Protection type";
                    type enumeration {
                      enum protected-only {
                        tailf:info "Protected adj-SID only";
                      }
                      enum protected-preferred {
                        tailf:info "Protected adj-SID preferred (default)";
                      }
                      enum unprotected {
                        tailf:info "Unprotected adj-SID only";
                      }
                      enum unprotected-only {
                        tailf:info "Unprotected adj-SID only";
                      }
                      enum unprotected-preferred {
                        tailf:info "Unprotected adj-SID preferred";
                      }
                    }
                  }
                }

                // segment-routing / traffic-eng / policy * / candidate-paths / preference * / constraints / affinity
                container affinity {
                  tailf:info "Assign affinities to path";
                  tailf:cli-add-mode;
                  tailf:cli-mode-name "config-sr-te-path-pref-const-aff";

                  // segment-routing / traffic-eng / policy * / candidate-paths / constraints / affinity / include-all
                  // segment-routing / traffic-eng / policy * / candidate-paths / constraints / affinity / exclude
                  // segment-routing / traffic-eng / policy * / candidate-paths / constraints / affinity / include-any
                  // segment-routing / traffic-eng / policy * / candidate-paths / constraints / affinity / exclude-any
                  list rule {
                    tailf:cli-drop-node-name;
                    tailf:cli-mode-name "config-sr-te-path-pref-const-aff-rule";
                    key name;
                    leaf name {
                      type enumeration {
                        enum include-all {
                          tailf:info "Affinity attributes - all must be included";
                        }
                        enum exclude {
                                      tailf:info "Affinity attributes to exclude";
                        }
                        enum include-any {
                          tailf:info "Affinity attributes - at least one must be inclu";
                        }
                        enum exclude-any {
                          tailf:info "Affinity attributes to exclude - presence of at least one excludes link";
                        }
                      }
                    }

                    // segment-routing / traffic-eng / policy * / candidate-paths / constraints / affinity / * / color *
                    list color {
                      tailf:info "An affinity color";
                      tailf:cli-suppress-mode;
                      tailf:cli-delete-when-empty;
                      key name;
                      leaf name {
                        type string {
                          tailf:info "WORD;;Affinity color name";
                        }
                      }
                    }

                    // segment-routing / traffic-eng / policy * / candidate-paths / constraints / affinity / * / name *
                    // Note: Odd-looking YANG due to backwards compatiblity with older YANG
                    list name-list {
                      tailf:cli-drop-node-name;
                      tailf:cli-suppress-mode;
                      tailf:cli-delete-when-empty;
                      tailf:cli-sequence-commands;
                      leaf name {
                        tailf:info "Affinity name";
                        tailf:cli-prefix-key;
                        type empty;
                      }
                      key color;
                      leaf color {
                        type string {
                          tailf:info "WORD;;Affinity color name";
                        }
                      }
                    }
                  }
                }

                // segment-routing / traffic-eng / policy * / candidate-paths / preference * / constraints / disjoint-path
                container disjoint-path {
                  tailf:info "Request disjoint path computation";
                  tailf:cli-compact-syntax;
                  tailf:cli-sequence-commands {
                    tailf:cli-reset-siblings;
                  }
                  leaf group-id {
                    tailf:info "Group ID";
                    tailf:cli-incomplete-command;
                    type uint16 {
                      tailf:info "<1-65535>;;Group ID";
                      range "1..65535";
                    }
                  }
                  leaf type {
                    tailf:info "Disjointness type";
                    type enumeration {
                      enum link {
                                 tailf:info "Link Disjointness";
                      }
                      enum node {
                                 tailf:info "Node Disjointness";
                      }
                      enum srlg {
                                 tailf:info "SRLG Disjointness";
                      }
                      enum srlg-node {
                        tailf:info "SRLG Node Disjointness";
                      }
                    }
                  }
                  leaf sub-id {
                    tailf:info "Subgroup ID";
                    type uint16 {
                      tailf:info "<1-65535>;;Subgroup ID number";
                      range "1..65535";
                    }
                  }
                }
              }
            }
          }

          // segment-routing / traffic-eng / policy * / performance-measurement
          container performance-measurement {
            tailf:info "Performance Measurement configuration submode";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-sr-te-policy-perf-meas";

            // segment-routing / traffic-eng / policy * / performance-measurement / delay-measurement
            container delay-measurement {
              tailf:info "Delay-measurement configuration submode";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-sr-te-policy-delay-meas";
              presence true;

              // segment-routing / traffic-eng / policy * / performance-measurement / delay-measurement / logging
              container logging {
                tailf:info "Syslog configuration options";
                tailf:cli-add-mode;
                tailf:cli-mode-name "config-sr-te-policy-pm-dm-log";
                presence true;
              }

              // segment-routing / traffic-eng / policy * / performance-measurement / delay-measurement / liveness-detection
              container liveness-detection {
                tailf:info "Enable liveness-detection using the DM packets";
                tailf:cli-add-mode;
                tailf:cli-mode-name "config-sr-te-policy-pm-live";
                presence true;

                // segment-routing / traffic-eng / policy * / performance-measurement / delay-measurement / liveness-detection / logging
                container logging {
                  tailf:info "Syslog configuration options";
                  tailf:cli-add-mode;
                  tailf:cli-mode-name "config-sr-te-policy-liveness-log";
                  presence true;

                  // segment-routing / traffic-eng / policy * / performance-measurement / delay-measurement / liveness-detection / logging / session-state-change
                  leaf session-state-change {
                    tailf:info "Emit syslog when the state of the session changes";
                    type empty;
                  }
                }

                // segment-routing / traffic-eng / policy * / performance-measurement / delay-measurement / liveness-detection / invalidation-action
                leaf invalidation-action {
                  tailf:info "Action to be taken when PM liveness session is invalidated";
                  type enumeration {
                    enum none {
                      tailf:info "PM liveness session state does not affect LSP state, use for diagnostic purposes";
                    }
                    enum down {
                      tailf:info "LSP can only be operationally up if the PM liveness session is up";
                    }
                  }
                }
              }

              // segment-routing / traffic-eng / policy * / performance-measurement / delay-measurement / reverse-path
              container reverse-path {
                tailf:info "Specify parameters about the reverse path back to the head-end";
                tailf:cli-add-mode;
                tailf:cli-mode-name "config-sr-te-policy-pm-rev";

                // segment-routing / traffic-eng / policy * / performance-measurement / delay-measurement / reverse-path / label
                leaf label {
                  tailf:info "DM packets return to head-end using a label";
                  type uint32 {
                    tailf:info "<16-1048575>;;Reverse path label";
                    range "16..1048575";
                  }
                }
              }
            }
          }

          // segment-routing / traffic-eng / policy * / steering
          container steering {
            tailf:info "Steering options configuration";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-sr-te-policy-steering";

            // segment-routing / traffic-eng / policy * / steering / bgp disable
            container bgp {
              tailf:info "BGP client";
              leaf disable {
                tailf:info "Disable all services";
                type empty;
              }
            }
            // segment-routing / traffic-eng / policy * / steering / path-invalidation
            container path-invalidation {
              tailf:info "Path invalidation action, default is to fall back to unconstrained IGP path";
              leaf drop {
                tailf:info "If path became invalid, keep policy up, but drop all traffic sent on the policy";
                type empty;
              }
            }
          }

          // segment-routing / traffic-eng / policy * / per-flow
          container per-flow {
            tailf:info "Per-flow configuration";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-sr-te-policy-pfp";

            // pce / backoff / segment-routing / traffic-eng / peer ipv4 * / policy * / per-flow / forward-class *
            list forward-class {
              tailf:info "Specify forward class for per-flow based routing";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-incomplete-command;
              key id;
              leaf id {
                type uint8 {
                  tailf:info "<0-7>;;Forward class value";
                  range "0..7";
                }
              }
              leaf color {
                tailf:info "Specify corresponding policy color for the forwarding class";
                type uint32 {
                  tailf:info "<1-4294967295>;;Color value";
                  range "1..4294967295";
                }
              }
            }
          }
        }

        // segment-routing / traffic-eng / affinity-map
        container affinity-map {
          tailf:info "Affinity map configuration";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-sr-te-affinity-map";

          // segment-routing / traffic-eng / affinity-map bit-map [XR 6.4.x]
          leaf bit-map {
            tailf:info "Affinity attribute value to color mapping";
            tailf:cli-hide-in-submode;
            tailf:cli-full-command;
            type empty;
          }

          // segment-routing / traffic-eng / affinity-map bit-map / * [XR 6.4.x]
          // segment-routing / traffic-eng / affinity-map / color * [XR 6.5.1]
          // segment-routing / traffic-eng / affinity-map / name * [XR 6.5.2]
          list color {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            tailf:cli-incomplete-command;
            key name;
            leaf prefix {
              tailf:cli-prefix-key;
              tailf:cli-drop-node-name;
              tailf:cli-optional-in-sequence;
              type enumeration {
                enum color {
                            tailf:info "An affinity color";
                }
                enum name {
                           tailf:info "An affinity color";
                }
              }
            }
            leaf name {
              tailf:cli-suppress-range;
              tailf:cli-disallow-value "color|name|bit-map";
              type string {
                tailf:info "WORD;;Affinity color name";
              }
            }
            leaf bit-position {
              tailf:info "Bit Position for the mapped affinity";
              type uint8 {
                tailf:info "<0-255>;;Affinity attribute bit position";
              }
            }
          }
        }

        // segment-routing / traffic-eng / pcc
        container pcc {
          tailf:info "Path Computation Client configurations";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-sr-te-pcc";
          presence true;

          // segment-routing / traffic-eng / pcc / source-address ipv4
          container source-address {
            tailf:info "Source address of PCEP sessions";
            leaf ipv4 {
              tailf:info "IPv4 address";
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Local IPv4 address of the PCC";
              }
            }
          }

          // segment-routing / traffic-eng / pcc / pce address ipv4 *
          container pce {
            tailf:info "Path Computation Element (PCE) server";
            container address {
              tailf:info "Address of PCE server";
              list ipv4 {
                tailf:info "IPv4 address";
                tailf:cli-mode-name "config-pcc-pce";
                key address;
                leaf address {
                  tailf:cli-suppress-range;
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;IPv4 address of PCE server";
                  }
                }

                // segment-routing / traffic-eng / pcc / pce address ipv4 * / precedence
                leaf precedence {
                  tailf:info "Precedence of PCE peer, default is 255";
                  type uint8 {
                    tailf:info "<0-255>;;Precedence value (0 is most preferred, 255 is least preferred)";
                  }
                }

                // segment-routing / traffic-eng / pcc / pce address ipv4 * / password
                container password {
                  tailf:info "Configure password for MD5 authentication";
                  tailf:cli-compact-syntax;
                  tailf:cli-sequence-commands;
                  uses password-grouping {
                    refine "secret" {
                      cli:secret " password <SECRET>";
                    }
                  }
                }

                // segment-routing / traffic-eng / pcc / pce address ipv4 * / tcp-ao
                container tcp-ao {
                  tailf:info "Configure AO keychain based authentication";
                  tailf:cli-compact-syntax;
                  tailf:cli-sequence-commands {
                    tailf:cli-reset-siblings;
                  }
                  leaf name {
                    tailf:cli-drop-node-name;
                    type string {
                      tailf:info "WORD;;Name of the TCP AO keychain - maximum 32 characters";
                    }
                  }
                  leaf include-tcp-options {
                    tailf:info "Include other TCP options in the header";
                    type empty;
                  }
                }
              }
            }
          }

          // segment-routing / traffic-eng / pcc / report-all
          leaf report-all {
            tailf:info "Report all local SR policies to connected PCEP peers";
            type empty;
          }

          // segment-routing / traffic-eng / pcc / maximum-sid-depth
          leaf maximum-sid-depth {
            tailf:info "Maximum number of SIDs that the PCC can impose on a packet";
            type uint8 {
              tailf:info "<1-32>;;Override the platform Maximum SID Depth value with a user configured value";
              range "1..32";
            }
          }

          // segment-routing / traffic-eng / pcc / redundancy pcc-centric
          container redundancy {
            tailf:info "PCC redundancy configuration";
            leaf pcc-centric {
              tailf:info "Enable PCC centric model, where PCC only allows the lowest precedence PCE to initiate policies";
              type empty;
            }
          }

          // segment-routing / traffic-eng / pcc / profile *
          list profile {
            tailf:info "Configuration template that can be specified via PCEP";
            tailf:cli-mode-name "config-pcc-prof";
            key id;
            leaf id {
              type uint16 {
                tailf:info "<1-65534>;;numeric identifier for the profile";
                range "1..65534";
              }
            }

            // segment-routing / traffic-eng / pcc / profile * / autoroute
            container autoroute {
              tailf:info "Autoroute configuration";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-pcc-prof-aa";

              // segment-routing / traffic-eng / pcc / profile * / autoroute / include all
              container include {
                tailf:info "Prefixes for which routes will be installed";
                leaf all {
                  tailf:info "Include all eligible prefixes";
                  type empty;
                }
              }

              // segment-routing / traffic-eng / pcc / policy * / autoroute / force-sr-include
              leaf force-sr-include {
                tailf:info "Force autoroute Policy to be safe for carrying SR Labelled traffic";
                type empty;
              }
            }
          }
        }

        // segment-routing / traffic-eng / explicit-path *
        list explicit-path {
          tailf:info "Explicit-path configuration";
          tailf:cli-mode-name "config-sr-te-exp-path";
          key name;
          leaf name {
            tailf:info "Explicit-path name";
            tailf:cli-expose-key-name;
            type string {
              tailf:info "WORD;;Identifying name for explicit-path with max 128 characters";
            }
          }

          // segment-routing / traffic-eng / explicit-path * / index *
          list index {
            tailf:info "Next entry index";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key id;
            leaf id {
              type uint16 {
                tailf:info "<1-65535>;;Index number";
                range "1..65535";
              }
            }
            choice config-choice {
              container address {
                tailf:info "Specify hop address";
                leaf ipv4 {
                  tailf:info "Specify the address AFI";
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;IPv4 address (A.B.C.D)";
                  }
                }
              }
              container mpls {
                tailf:info "MPLS configuration";
                leaf label {
                  tailf:info "MPLS label configuration";
                  type uint32 {
                    tailf:info "<0-1048575>;;MPLS label value";
                    range "0..1048575";
                  }
                }
              }
            }
          }

          // segment-routing / traffic-eng / explicit-path * / policy *
          list policy {
            tailf:info "Name of SR-TE Policy";
            tailf:cli-mode-name "config-sr-te-policy";
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;Identifying name for policy with max 128 characters";
              }
            }

            // segment-routing / traffic-eng / explicit-path * / policy * / end-point
            container end-point {
              tailf:info "Policy endpoint";
              choice address-choice {
                leaf ipv4 {
                  tailf:info "IPv4 address";
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;IPv4 endpoint address";
                  }
                }
                leaf ipv6 {
                  tailf:info "IPv6 address";
                  type inet:ipv6-address {
                    tailf:info "X:X::X;;IPv6 endpoint address (X:X::X)";
                  }
                }
              }
            }

            // segment-routing / traffic-eng / explicit-path * / policy * / color
            leaf color {
              tailf:info "Specify color for policy";
              type uint32 {
                tailf:info "<1-4294967295>;;Color value, default value is 0";
              }
            }

            // segment-routing / traffic-eng / explicit-path * / policy * / binding-sid mpls
            container binding-sid {
              tailf:info "Bnding Segment Identifier";
              leaf mpls {
                tailf:info "MPLS label";
                type uint32 {
                  tailf:info "<16-1048575>;;MPLS label";
                  range "16..1048575";
                }
              }
            }

            // segment-routing / traffic-eng / explicit-path * / policy * / path
            container path {
              tailf:info "Path configuration";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-sr-te-policy-path";

              // segment-routing / traffic-eng / explicit-path * / policy * / path / preference *
              list preference {
                tailf:info "Policy path-option preference entry";
                tailf:cli-mode-name "config-sr-te-policy-path-index";
                key id;
                leaf id {
                  type uint16 {
                    tailf:info "<1-65535>;;Path-option preference";
                    range "1..65535";
                  }
                }

                // segment-routing / traffic-eng / explicit-path * / policy * / path / preference * / explicit *
                list explicit {
                  tailf:info "Preconfigured path";
                  tailf:cli-mode-name "config-sr-te-policy-path-info";
                  key name;
                  leaf name {
                    type string {
                      tailf:info "WORD;;Identifying name for explicit-path";
                    }
                  }

                  // segment-routing / traffic-eng / explicit-path * / policy * / path / preference * / explicit * / weight
                  leaf weight {
                    tailf:info "Path option weight";
                    type uint32 {
                      tailf:info "<0-4294967295>;;Weight";
                    }
                  }
                }
              }
            }

            // segment-routing / traffic-eng / explicit-path * / policy * / shutdow
            leaf  shutdown {
              tailf:info "Policy admin-shutdown";
              type empty;
            }
          }
        }

        // segment-routing / traffic-eng / steering
        container steering {
          tailf:info "Global Steering options";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-sr-te-steering";
          presence true;
        }

        // segment-routing / traffic-eng / timers
        container timers {
          tailf:info "SR-TE timers configuration";
          tailf:cli-add-mode;
          container candidate-path {
            tailf:info "Candidate path related timers";
            leaf cleanup-delay {
              tailf:info "Delay before cleaning up candidate paths (default: 120 seconds)";
              type uint32 {
                tailf:info "<0-86400>;;Cleanup timer value in seconds (0 for immediate cleanup)";
              }
            }
          }
          leaf cleanup-delay {
            tailf:info "Delay before cleaning up previous path (default: 10 seconds)";
            type uint16 {
              tailf:info "<0-300>;;Cleanup timer value in seconds (0 for immediate cleanup)";
            }
          }
          leaf install-delay {
            tailf:info "Delay before switching to a reoptimized path (default: 10 seconds)";
            type uint16 {
              tailf:info "<0-300>;;Install timer value in seconds (0 for immediate installation)";
            }
          }
          leaf periodic-reoptimization {
            tailf:info "How often to perform periodic reoptimization of policies (default: 600 seconds)";
            type uint32 {
              tailf:info "<0-86400>;;Reoptimization timer value in seconds (0 to disable periodic reoptimization)";
            }
          }
          // segment-routing / traffic-eng / timers / exclude-item
          container exclude-item {
            tailf:info "Negate a command or set its defaults";
            container candidate-path {
              tailf:info "Candidate path related timers";
              leaf cleanup-delay {
                tailf:info "Delay before cleaning up candidate paths (default: 120 seconds)";
                type empty;
              }
            }
            leaf cleanup-delay {
              tailf:info "Delay before cleaning up previous path (default: 10 seconds)";
              type empty;
            }
            leaf install-delay {
              tailf:info "Delay before switching to a reoptimized path (default: 10 seconds)";
              type empty;
            }
            leaf periodic-reoptimization {
              tailf:info "How often to perform periodic reoptimization of policies (default: 600 seconds)";
              type empty;
            }
          }
        }
      }

      // segment-routing / adjacency-sid
      container adjacency-sid {
        tailf:info "Segment Routing (MPLS) Adjacency SID";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-sr-adj";

        // segment-routing / adjacency-sid / interface *
        list interface {
          tailf:info "Interface Instance";
          tailf:cli-mode-name "config-sr-adj-intf";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Interface name";
            }
          }

          // segment-routing / adjacency-sid / interface * / address-family ipv4 unicast
          container address-family {
            tailf:info "Address Family";
            container ipv4 {
              tailf:info "IP version 4";
              container unicast {
                tailf:info "Unicast Address Family";
                tailf:cli-add-mode;
                tailf:cli-mode-name "config-sr-adj-intf-af";

                // segment-routing / adjacency-sid / interface * / address-family ipv4 unicast / l2-adjacency-sid
                container l2-adjacency-sid {
                  tailf:info "L2 Adjacency SID";
                  choice sid-choice {
                    leaf absolute {
                      tailf:info "Absolute SID";
                      type uint32 {
                        tailf:info "<0-1048575>;;L2 Adjacency SID value";
                        range "0..1048575";
                      }
                    }
                    leaf index {
                      tailf:info "Index SID";
                      type uint32 {
                        tailf:info "<0-1048575>;;L2 Adjacency SID value";
                        range "0..1048575";
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }

      // segment-routing / srv6
      container srv6 {
        tailf:info "Segment Routing with IPv6 dataplane";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-srv6";
        cisco-ios-xr:inject-before "segment-routing";
        presence true;

        // segment-routing / srv6 / logging locator status
        container logging {
          tailf:info "Enable logging";
          container locator {
            tailf:info "Configure logging for locator events";
            leaf status {
              tailf:info "Enable logging for locator status changes";
              type empty;
            }
          }
        }

        // segment-routing / srv6 / encapsulation
        container encapsulation {
          tailf:info "Configure encapsulation parameters";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-srv6-encap";

          // segment-routing / srv6 / encapsulation / source-address
          leaf source-address {
            tailf:info "Specify Source address";
            type inet:ipv6-address {
              tailf:info "X:X::X;;IPv6 address";
            }
          }
        }

        // segment-routing / srv6 / locators
        container locators {
          tailf:info "Configure Locators";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-srv6-locators";

          // segment-routing / srv6 / locators / locator *
          list locator {
            tailf:info "Configure a Locator";
            tailf:cli-mode-name "config-srv6-locator";
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;Specify locator name";
              }
            }

            // segment-routing / srv6 / locators / locator * / micro-segment behavior unode
            container micro-segment {
              tailf:info "Configure micro-segments (uSID) related parameters";
              container behavior {
                tailf:info "Specify Locator's behavior";
                leaf unode {
                  tailf:info "uNode type";
                  type enumeration {
                    enum psp-usd {
                      tailf:info "uNode PSP/USD variant";
                    }
                    enum shift-only {
                      tailf:info "uNode (shift only)";
                    }
                  }
                }
              }
            }

            // segment-routing / srv6 / locators / locator * / prefix
            leaf prefix {
              tailf:info "Configure locator's prefix value";
              type tailf:ipv6-address-and-prefix-length {
                tailf:info "X:X::X/length;;Specify IPv6 subnet";
              }
            }

            // segment-routing / srv6 / locators / locator * / algorithm
            leaf algorithm {
              tailf:info "lgorithm associated with the locator";
              type uint8 {
                tailf:info "128-255>;;Algorithm ID";
                range "128..255";
              }
            }
          }
        }
      }
    }
  }


  grouping segment-routing-te-srv6-grouping {
    container srv6 {
      tailf:info "Specify SRv6 configurations";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-sr-te-policy-srv6";
      presence true;

      // segment-routing / traffic-eng / policy * / srv6 / locator
      container locator {
        tailf:info "Configure locator";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf name {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          tailf:cli-disallow-value "binding-sid";
          type string {
            tailf:info "WORD;;Specify locator name with max 64 characters";
          }
        }
        container binding-sid {
          tailf:info "Binding-SID allocation options";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          container dynamic {
            tailf:info "Dynamic based option";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            container behavior {
              tailf:info "Binding-SID behavior options";
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              leaf ub6-insert-reduced {
                tailf:info "Binding-SID insert reduced behavior";
                type empty;
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// telemetry
  /// ========================================================================

  container telemetry {
    tailf:info "Telemetry configuration";
    tailf:cli-explicit-exit;

    // telemetry model-driven
    container model-driven {
      tailf:info "Model Driven Telemetry configuration commands";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-model-driven";
      presence true;

      // telemetry model-driven / max-sensor-paths
      leaf max-sensor-paths {
        tailf:info "Maximum allowed sensor paths, default: 1000";
        type uint16 {
          tailf:info "<0-4000>;;Maximum sensor paths, 0 disables the check";
          range "0..4000";
        }
      }

      // telemetry model-driven / max-containers-per-path
      leaf max-containers-per-path {
        tailf:info "Maximum containers allowed per sensor path,default:16";
        type uint16 {
          tailf:info "<0-1024>;;Maximum containers allowed per path, 0 disables the check";
          range "0..1024";
        }
      }

      // telemetry model-driven / destination-group *
      list destination-group {
        tailf:info "Destination Id";
        tailf:cli-mode-name "config-model-driven-dest";
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;Destination Id string";
          }
        }

        // telemetry model-driven / destination-group * / vrf
        leaf vrf {
          tailf:info "vrf for the dest grp";
          type string {
            tailf:info "WORD;;vrf-name for the dest grp";
          }
        }

        // telemetry model-driven / destination-group * / address family
        container address-family {
          tailf:info "Destination address of the recepient of the telemetry information";

          // telemetry model-driven / destination-group * / address family ipv4 *
          list ipv4 {
            tailf:info "ipv4 address family";
            tailf:cli-mode-name "config-model-driven-dest-addr";
            key "address port";
            leaf address {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Destination ipv4 address";
              }
            }
            leaf port {
              tailf:info "Destination Port configuration";
              tailf:cli-expose-key-name;
              type uint16 {
                tailf:info "<1-65535>;;Port Number";
                range "1..65535";
              }
            }
            uses telemetry-model-driven-dest-addr-grouping;
          }

          // telemetry model-driven / destination-group * / address family ipv6 *
          list ipv6 {
            tailf:info "ipv6 address family";
            tailf:cli-mode-name "config-model-driven-dest-addr";
            key "address port";
            leaf address {
              type inet:ipv6-address {
                tailf:info "X:X::X;;Destination ipv6 address";
              }
            }
            leaf port {
              tailf:info "Destination Port configuration";
              tailf:cli-expose-key-name;
              type uint16 {
                tailf:info "<1-65535>;;Port Number";
                range "1..65535";
              }
            }
            uses telemetry-model-driven-dest-addr-grouping;
          }
        }
      }

      // telemetry model-driven / sensor-group *
      list sensor-group {
        tailf:info "Sensor group configuration";
        tailf:cli-mode-name "config-model-driven-snsr-grp";
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;Sensor Group Id";
          }
        }

        // telemetry model-driven / sensor-group * / sensor-path *
        list sensor-path {
          tailf:info "Sensor Path";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Sensor Path";
            }
          }
        }
      }

      // telemetry model-driven / subscription *
      list subscription {
        tailf:info "Subscription Id";
        tailf:cli-mode-name "config-model-driven-subs";
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;Subscription Id string";
          }
        }

        // telemetry model-driven / subscription * / sensor-group-id *
        list sensor-group-id {
          tailf:info "Association of one or more Sensor Groups with a Subscription Id";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Available Sensor Groups";
            }
          }
          // telemetry model-driven / subscription * / sensor-group-id * strict-timer
          leaf strict-timer {
            tailf:info "use strict timer, default is relative timer";
            type empty;
          }
          // telemetry model-driven / subscription * / sensor-group-id * sample-interval
          leaf sample-interval {
            tailf:info "Sample interval";
            type uint32 {
              tailf:info "<0-4294967295>;;Sample interval in milliseconds";
            }
          }
        }

        // telemetry model-driven / subscription * / destination-id *
        list destination-id {
          tailf:info "Destination Id to associate with the current subscription id";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Available Destination Ids";
            }
          }
        }

        // telemetry model-driven / subscription * / source-interface
        container source-interface {
          tailf:info "Source interface to use in the outgoing IP packets";
          uses interface-name-grouping;
        }

        // telemetry model-driven / subscription * / source-qos-marking
        leaf source-qos-marking {
          tailf:info "Outgoing DSCP value";
          type enumeration {
            enum af11 {
              tailf:info "Match packets with AF11 dscp (001010)";
            }
            enum af12 {
              tailf:info "Match packets with AF12 dscp (001100)";
            }
            enum af13 {
              tailf:info "Match packets with AF13 dscp (001110)";
            }
            enum af21 {
              tailf:info "Match packets with AF21 dscp (010010)";
            }
            enum af22 {
              tailf:info "Match packets with AF22 dscp (010100)";
            }
            enum af23 {
              tailf:info "Match packets with AF23 dscp (010110)";
            }
            enum af31 {
              tailf:info "Match packets with AF31 dscp (011010)";
            }
            enum af32 {
              tailf:info "Match packets with AF32 dscp (011100)";
            }
            enum af33 {
              tailf:info "Match packets with AF33 dscp (011110)";
            }
            enum af41 {
              tailf:info "Match packets with AF41 dscp (100010)";
            }
            enum af42 {
              tailf:info "Match packets with AF42 dscp (100100)";
            }
            enum af43 {
              tailf:info "Match packets with AF43 dscp (100110)";
            }
            enum cs1 {
              tailf:info "Match packets with CS1 dscp (001000)";
            }
            enum cs2 {
              tailf:info "Match packets with CS2 dscp (010000)";
            }
            enum cs3 {
              tailf:info "Match packets with CS3 dscp (011000)";
            }
            enum cs4 {
              tailf:info "Match packets with CS4 dscp (100000)";
            }
            enum cs5 {
              tailf:info "Match packets with CS5 dscp (101000)";
            }
            enum cs6 {
              tailf:info "Match packets with CS6 dscp (110000)";
            }
            enum cs7 {
              tailf:info "Match packets with CS7 dscp (111000)";
            }
            enum default {
              tailf:info "Match packets with default dscp (000000)";
            }
            enum ef {
              tailf:info "Match packets with EF dscp (101110)";
            }
          }
        }
      }
    }

    // telemetry policy-driven
    container policy-driven {
      tailf:info "Telemetry policy-driven configuration";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-telemetry-policydriven";

      // telemetry policy-driven / encoder
      container encoder {
        tailf:info "Encoder configuration";

        // telemetry policy-driven / encoder gpb
        container gpb {
          tailf:info "GPB encoder configuration";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-telem-plcy-driven-gpb";
          uses telemetry-policy-driven-encoder-grouping;
        }

        // telemetry policy-driven / encoder json
        container json {
          tailf:info "JSON encoder configuration";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-telem-plcy-driven-json";
          uses telemetry-policy-driven-encoder-grouping;
        }
      }
    }
  }


  /// ========================================================================
  /// multicast-routing
  /// ========================================================================

  container multicast-routing {
    tailf:info "Enable IP multicast forwarding";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-mcast";
    tailf:cli-explicit-exit;
    presence true;

    uses multicast-routing-grouping;

    // multicast-routing / vrf *
    list vrf {
      tailf:info "VRF configs";
      tailf:cli-mode-name "config-mcast-vrf";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Enter VRF name";
        }
      }
      uses multicast-routing-grouping;
    }
  }


  /// ========================================================================
  /// alias
  /// ========================================================================

  container alias {
    tailf:info "Create an alias for entity";

    // alias *
    list alias-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      key name;
      leaf name {
        tailf:cli-disallow-value "exec|config";
        type string {
          tailf:info "WORD;;Alias name";
        }
      }
      leaf line {
        tailf:cli-drop-node-name;
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-no-value-on-delete;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE;;Alias body with optional parameters e.g,(name) show $name";
        }
      }
    }

    // alias exec *
    list exec {
      tailf:info "Exec command alias";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Exec Alias name";
        }
      }
      leaf line {
        tailf:cli-drop-node-name;
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-no-value-on-delete;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE;;Aliased exec command";
        }
      }
    }

    // alias config *
    list config {
      tailf:info "Config command alias";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Config Alias name";
        }
      }
      leaf line {
        tailf:cli-drop-node-name;
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-no-value-on-delete;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE;;Aliased config command";
        }
      }
    }
  }


  /// ========================================================================
  /// process
  /// ========================================================================

  container process {
    tailf:info "Process config commands";
    container mandatory {
      tailf:info "Set the process mandatory";

      // process mandatory location *
      list location {
        tailf:info "Location on which this config applies";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "name executable";
        leaf name {
          type string {
            tailf:info "WORD;;Fully qualified location specification";
          }
        }
        leaf executable {
          type string {
            tailf:info "WORD;;Name of the executable";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// ltrace
  /// ========================================================================

  // ltrace mode ? scale-factor ? *
  list ltrace {
    tailf:info "ltrace memory allocation configuration";
    tailf:cli-suppress-mode;
    tailf:cli-delete-when-empty;
    tailf:cli-compact-syntax;
    tailf:cli-sequence-commands {
      tailf:cli-reset-siblings;
    }
    key name;
    leaf name {
      tailf:cli-disallow-value "preconfigure";
      type string {
        tailf:info "WORD;;Fully qualified location specification";
      }
    }
    leaf mode {
      tailf:info "Select a memory allocation mode";
      tailf:cli-prefix-key;
      type enumeration {
        enum static {
          tailf:info "Set ltrace memory allocation to static mode";
        }
        enum dynamic {
          tailf:info "Set ltrace memory allocation to dynamic mode";
        }
      }
    }
    leaf scale-factor {
      tailf:cli-prefix-key;
      tailf:info "Configure a scaling down factor for memory allocation";
      type enumeration {
        enum 0 {
          tailf:info "Use platform-defined scale-factor";
        }
        enum 1 {
          tailf:info "Do not scale down ltrace memory request";
        }
        enum 2 {
          tailf:info "Scale down ltrace memory request by 2";
        }
        enum 4 {
          tailf:info "Scale down ltrace memory request by 4";
        }
        enum 8 {
          tailf:info "Scale down ltrace memory request by 8";
        }
        enum 16 {
          tailf:info "Scale down ltrace memory request by 16";
        }
      }
    }
    leaf location {
      tailf:info "Specify a location";
      tailf:cli-prefix-key;
      type empty;
    }
    leaf preconfigure {
      tailf:info "Specify a preconfig";
      tailf:cli-prefix-key;
      tailf:cli-optional-in-sequence;
      type empty;
    }
  }


  /// ========================================================================
  /// call-home
  /// ========================================================================

  container call-home {
    tailf:info "Enter call-home configuration mode";
    tailf:cli-add-mode;
    tailf:cli-explicit-exit;

    // call-home / vrf
    leaf vrf {
      tailf:info "VPN Routing/Forwarding instance name";
      type string {
        tailf:info "WORD;;VRF instance name";
      }
    }

    // call-home / service active
    container service {
      tailf:info "Enable or disable Call-home service";
      leaf active {
        tailf:info "Enable Call-home service";
        type empty;
      }
    }

    // call-home / site-id
    leaf site-id {
      tailf:info "Site identification for Cisco Smart Call Home";
      type string {
        tailf:info "WORD;;Alphanumeric site identification";
      }
    }

    // call-home / sender
    container sender {
      tailf:info "Call home msg's sender email addresses";
      leaf from {
        tailf:info "Call home msg's from email address";
        type string {
          tailf:info "WORD;;Email address";
        }
      }
      leaf reply-to {
        tailf:info "Call home msg's reply-to email address";
        type string {
          tailf:info "WORD;;Email address";
        }
      }
    }

    // call-home / contact smart-licensing
    container contact {
      tailf:info "System Contact";
      leaf smart-licensing {
        tailf:info "System Contact is Smart-Licensing";
        type empty;
      }
    }

    // call-home / mail-server *
    list mail-server {
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      key address;
      leaf address {
        type string {
          tailf:info "WORD;;Email server";
        }
      }
      leaf priority {
        tailf:info "Mail server priority order";
        type uint8 {
          tailf:info "<1-100>;;Mail server with lower # will be used first";
          range "1..100";
        }
      }
    }

    // call-home / contact-email-addr
    leaf contact-email-addr {
      tailf:info "System Contact's email address";
      type string {
        tailf:info "WORD;;Contact person's email address";
      }
    }

    // call-home / http-proxy
    container http-proxy {
      tailf:info "Specify proxy server for http request";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf address {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type inet:host {
          tailf:info "WORD;;Http proxy server";
        }
      }
      leaf port {
        tailf:info "proxy server port number";
        type uint16 {
          tailf:info "<1-65535>;;http proxy server port number";
          range "1..65535";
        }
      }
    }

    // call-home / phone-number +1-408-526-8438
    leaf phone-number {
      tailf:info "Phone number of the contact person";
      type string {
        tailf:info "WORD;;Phone number of the contact person.";
      }
    }

    // call-home / rate-limit
    leaf rate-limit {
      tailf:info "Configure call-home event trigger rate-limit threshold";
      type uint8 {
        tailf:info "<1-5>;;Call-home event trigger rate-limit threshold per minute";
        range "1..5";
      }
    }

    // call-home / data-privacy
    container data-privacy {
      tailf:info "Set call-home data-privacy";

      // call-home / data-privacy level
      leaf level {
        tailf:info "Set call-home data-privacy level";
        type enumeration {
          enum normal {
            tailf:info "Level normal";
          }
          enum high {
            tailf:info "Level high";
          }
        }
      }

      // call-home / data-privacy hostname
      leaf hostname {
        tailf:info "Level hostname";
        type empty;
      }
    }

    // call-home / syslog-throttling
    leaf syslog-throttling {
      tailf:info "Enable or disable call-home syslog message throttling";
      type empty;
    }

    // call-home / source-interface
    container source-interface {
      tailf:info "Source interface name to send call-home messages";
      uses interface-name-grouping;
    }

    // call-home / alert-group-config snapshop
    container alert-group-config {
      tailf:info "Enter call-home alert-group configuration mode";
      container snapshot {
        tailf:info "Enter snapshot configuration mode";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-call-home-snapshot";

        // call-home / alert-group-config snapshop / add-command *
        list add-command {
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;CLI command (1-127) characters. If you include spaces, you must enclose your entry in quotes.";
            }
          }
        }
      }
    }

    // call-home / profile *
    list profile {
      tailf:info "Enter call-home profile configuration mode";
      tailf:cli-mode-name "config-call-home-profile";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Profile name";
        }
      }

      // call-home / profile * / active
      leaf active {
        tailf:info "Activate the current profile";
        type empty;
      }

      // call-home / profile * / destination
      container destination {
        tailf:info "Message destination related configuration";

        // call-home / profile * / destination address
        container address {
          tailf:info "To add destination address to this profile";
          leaf email {
            tailf:info "To add email address to this profile";
            type string {
              tailf:info "WORD;;Destination address (1-200) characters";
            }
          }
          leaf http {
            tailf:info "To add http address to this profile";
            type string {
              tailf:info "WORD;;Destination address (1-200) characters";
            }
          }
        }

        // call-home / profile * / destination transport-method
        container transport-method {
          tailf:info "To specify transport method for this profile";
          leaf email {
            tailf:info "Enable email as transport method";
            type empty;
          }
          leaf http {
            tailf:info "Enable http as transport method";
            type empty;
          }
        }
      }

      // call-home / profile * / reporting
      container reporting {
        tailf:info "Choose what data to report";

        // call-home / profile * / reporting smart-call-home-data
        container smart-call-home-data {
          tailf:info "Report Smart Call Home data";
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          presence true;
          leaf disable {
            tailf:info "Disable";
            type empty;
          }
        }

        // call-home / profile * / reporting smart-licensing-data
        container smart-licensing-data {
          tailf:info "Report Smart Licensing data";
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          presence true;
          leaf disable {
            tailf:info "Disable";
            type empty;
          }
        }
      }

      // call-home / profile * / subscribe-to-alert-group
      container subscribe-to-alert-group {
        tailf:info "Subscribe to alert-group";

        // call-home / profile * / subscribe-to-alert-group snapshot
        container snapshot {
          tailf:info "snapshot info";
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          presence true;
          uses call-home-profile-subscribe-to-alert-group-grouping;
        }

        // call-home / profile * / subscribe-to-alert-group inventory
        container inventory {
          tailf:info "inventory info";
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          presence true;
          uses call-home-profile-subscribe-to-alert-group-grouping;
        }

        // call-home / profile * / subscribe-to-alert-group configuration
        container configuration {
          tailf:info "configuration info";
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          presence true;
          uses call-home-profile-subscribe-to-alert-group-grouping;
        }
      }
    }
  }


  /// ========================================================================
  /// cached-show
  /// ========================================================================
  /// Cached output of some non-configurable info like version, model and serial.

  container cached-show {
    tailf:info "DEPRECATED. Use 'devices device <devname> platform'";

    // show version
    container version {
      leaf version {
        type string;
      }
      leaf model {
        type string;
      }
      leaf serial-number {
        type string;
      }
    }
  }


  /// ========================================================================
  /// EXEC (exec commands executed in config mode)
  /// ========================================================================

  container EXEC {
    tailf:cli-drop-node-name;

    // execute (run) config exec command(s)
    tailf:action "exec" {
      tailf:info "Execute config exec-command(s), e.g. 'default interface GigabitEthernet0/1/1'";
      tailf:actionpoint ncsinternal {
        tailf:internal;
      }
      input {
        leaf admin-mode {
          tailf:info "Set to run the action in admin mode";
          type empty;
        }
        list auto-prompts {
          tailf:info "One-shot auto-prompts list, used to ignore/reply on questions";
          tailf:cli-suppress-mode;
          key question;
          leaf question {
            tailf:info "Device question, regular expression";
            type string {
              tailf:info "WORD;;Question, regex format";
            }
          }
          leaf answer {
            tailf:info "Answer to device question";
            type string {
              tailf:info "WORD;;Answer to device question | <exit|prompt|timeout|ignore|enter>";
            }
          }
        }
        leaf-list args {
          tailf:cli-drop-node-name;
          tailf:cli-flat-list-syntax;
          type string {
            tailf:info "ACTION:;;exec \"<command> <argument(s)> [options]\"";
          }
        }
      }
      output {
        leaf result {
          type string;
        }
      }
    }
  }


  /// ========================================================================
  /// developer "config" - DO NOT MODIFY
  /// ========================================================================

  leaf bad-config {
    tailf:info "Internal developer variable, do not modify";
    type empty;
  }
  leaf xyzexit {
    tailf:info "Internal developer variable, do not modify";
    type uint8;
  }

  leaf xyzroot {
    tailf:info "Internal state variable, do not modify";
    tailf:cli-run-template "";
    tailf:cli-show-with-default;
    type uint16;
    default "0";
  }

}


/// ========================================================================
//                          EOF
/// ========================================================================
